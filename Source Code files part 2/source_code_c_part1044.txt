 id is not indexed, it's just
    //  some metadata for the user's benefit.
    //

    UCHAR ExtendedInfo[OBJECT_ID_EXT_INFO_LENGTH];

} NTFS_OBJECTID_INFORMATION, *PNTFS_OBJECTID_INFORMATION;

#define OBJECT_ID_FLAG_CORRUPT           (0x00000001)


//
//  Security Descriptor attribute.  This is just a normal attribute
//  stream containing a security descriptor as defined by NT
//  security and is really treated pretty opaque by NTFS.
//

//
//  Security descriptors are stored only once on a volume since there may be
//  many files that share the same descriptor bits.  Typically each principal
//  will create files with a single descriptor.
//
//  The descriptors themselves are stored in a stream, packed on DWORD boundaries.
//  No descriptor will span a 256K cache boundary.  The descriptors are assigned
//  a ULONG Id each time a unique descriptor is stored.  Prefixing each descriptor
//  in the stream is the hash of the descriptor, the assigned security ID, the
//  length, and the offset within the stream to the beginning of the structure.
//
//  For robustness, all security descriptors are written to the stream in two
//  different places, with a fixed offset between them.  The fixed offset is the
//  size of the VACB_MAPPING_GRANULARITY.
//
//  An index is used to map from a security Id to offset within the stream.  This
//  is used to retrieve the security descriptor bits for access validation.  The key
//  format is simply the ULONG security Id.  The data portion of the index record
//  is the header of the security descriptor in the stream (see above paragraph).
//
//  Another index is used to map from a hash to offset within the stream.  To
//  simplify the job of the indexing package, the key used in this index is the
//  hash followed by the assigned Id.  When a security descriptor is stored,
//  a hash is computed and an approximate seek is made on this index.  As entries
//  are enumerated in the index, the descriptor stream is mapped and the security
//  descriptor bits are compared.  The key format is a structure that contains
//  the hash and then the Id.  The collation routine tests the hash before the Id.
//  The data portion of the index record is the header of the security descriptor.
//

//
//  Key structure for Security Hash index
//

typedef struct _SECURITY_HASH_KEY
{
    ULONG   Hash;                           //  Hash value for descriptor
    ULONG   SecurityId;                     //  Security Id (guaranteed unique)
} SECURITY_HASH_KEY, *PSECURITY_HASH_KEY;

//
//  Key structure for Security Id index is simply the SECURITY_ID itself
//

//
//  Header for security descriptors in the security descriptor stream.  This
//  is the data format for all indexes and is part of SharedSecurity
//

typedef struct _SECURITY_DESCRIPTOR_HEADER
{
    SECURITY_HASH_KEY HashKey;              //  Hash value for the descriptor
    ULONGLONG Offset;                       //  offset to beginning of header
    ULONG   Length;                         //  Length in bytes
} SECURITY_DESCRIPTOR_HEADER, *PSECURITY_DESCRIPTOR_HEADER;

#define GETSECURITYDESCRIPTORLENGTH(HEADER)         \
    ((HEADER)->Length - sizeof( SECURITY_DESCRIPTOR_HEADER ))

#define SetSecurityDescriptorLength(HEADER,LENGTH)  \
    ((HEADER)->Length = (LENGTH) + sizeof( SECURITY_DESCRIPTOR_HEADER ))

//
//  Define standard values for well-known security IDs
//

#define SECURITY_ID_INVALID              (0x00000000)
#define SECURITY_ID_FIRST                (0x00000100)


//
//  Volume Name attribute.  This attribute is just a normal
//  attribute stream containing the unicode characters that make up
//  the volume label.  It is an attribute of the Mft File.
//


//
//  Volume Information attribute.  This attribute is only intended
//  to be used on the Volume DASD file.
//

typedef struct _VOLUME_INFORMATION {

    LONGLONG Reserved;

    //
    //  Major and minor version number of NTFS on this volume,
    //  starting with 1.0.  The major and minor version numbers are
    //  set from the major and minor version of the Format and NTFS
    //  implementation for which they are initialized.  The policy
    //  for incementing major and minor versions will always be
    //  decided on a case by case basis, however, the following two
    //  paragraphs attempt to suggest an approximate strategy.
    //
    //  The major version number is incremented if/when a volume
    //  format change is made which requires major structure changes
    //  (hopefully never?).  If an implementation of NTFS sees a
    //  volume with a higher major version number, it should refuse
    //  to mount the volume.  If a newer implementation of NTFS sees
    //  an older major version number, it knows the volume cannot be
    //  accessed without performing a one-time conversion.
    //
    //  The minor version number is incremented if/when minor
    //  enhancements are made to a major version, which potentially
    //  support enhanced functionality through additional file or
    //  attribute record fields, or new system-defined files or
    //  attributes.  If an older implementation of NTFS sees a newer
    //  minor version number on a volume, it may issue some kind of
    //  warning, but it will proceed to access the volume - with
    //  presumably some degradation in functionality compared to the
    //  version of NTFS which initialized the volume.  If a newer
    //  implementation of NTFS sees a volume with an older minor
    //  version number, it may issue a warning and proceed.  In this
    //  case, it may choose to increment the minor version number on
    //  the volume and begin full or incremental upgrade of the
    //  volume on an as-needed basis.  It may also leave the minor
    //  version number unchanged, until some sort of explicit
    //  directive from the user specifies that the minor version
    //  should be updated.
    //

    UCHAR MajorVersion;                                             //  offset = 0x008

    UCHAR MinorVersion;                                             //  offset = 0x009

    //
    //  VOLUME_xxx flags.
    //

    USHORT VolumeFlags;                                             //  offset = 0x00A

    //
    //  The following fields will only exist on version 4 and greater
    //

    UCHAR LastMountedMajorVersion;                                  //  offset = 0x00C
    UCHAR LastMountedMinorVersion;                                  //  offset = 0x00D

    USHORT Reserved2;                                               //  offset = 0x00E

    USN LowestOpenUsn;                                              //  offset = 0x010

} VOLUME_INFORMATION;                                               //  sizeof = 0xC or 0x18
typedef VOLUME_INFORMATION *PVOLUME_INFORMATION;




//
//  Volume is Dirty
//

#define VOLUME_DIRTY                     (0x0001)
#define VOLUME_RESIZE_LOG_FILE           (0x0002)
#define VOLUME_UPGRADE_ON_MOUNT          (0x0004)
#define VOLUME_MOUNTED_ON_40             (0x0008)
#define VOLUME_DELETE_USN_UNDERWAY       (0x0010)
#define VOLUME_REPAIR_OBJECT_ID          (0x0020)

#define VOLUME_CHKDSK_RAN_ONCE           (0x4000)   // this bit is used by autochk/chkdsk only
#define VOLUME_MODIFIED_BY_CHKDSK        (0x8000)


//
//  Common Index Header for Index Root and Index Allocation Buffers.
//  This structure is used to locate the Index Entries and describe
//  the free space in either of the two structures above.
//

typedef struct _INDEX_HEADER {

    //
    //  Offset from the start of this structure to the first Index
    //  Entry.
    //

    ULONG FirstIndexEntry;                                          //  offset = 0x000

    //
    //  Offset from the start of the first index entry to the first
    //  (quad-word aligned) free byte.
    //

    ULONG FirstFreeByte;                                            //  offset = 0x004

    //
    //  Total number of bytes available, from the start of the first
    //  index entry.  In the Index Root, this number must always be
    //  equal to FirstFreeByte, as the total attribute record will
    //  be grown and shrunk as required.
    //

    ULONG BytesAvailable;                                           //  offset = 0x008

    //
    //  INDEX_xxx flags.
    //

    UCHAR Flags;                                                    //  offset = 0x00C

    //
    //  Reserved to round up to quad word boundary.
    //

    UCHAR Reserved[3];                                              //  offset = 0x00D

} INDEX_HEADER;                                                     //  sizeof = 0x010
typedef INDEX_HEADER *PINDEX_HEADER;

//
//  INDEX_xxx flags
//

//
//  This Index or Index Allocation buffer is an intermediate node,
//  as opposed to a leaf in the Btree.  All Index Entries will have
//  a block down pointer.
//

#define INDEX_NODE                       (0x01)

//
//  Index Root attribute.  The index attribute consists of an index
//  header record followed by one or more index entries.
//

typedef struct _INDEX_ROOT {

    //
    //  Attribute Type Code of the attribute being indexed.
    //

    ATTRIBUTE_TYPE_CODE IndexedAttributeType;                       //  offset = 0x000

    //
    //  Collation rule for this index.
    //

    COLLATION_RULE CollationRule;                                   //  offset = 0x004

    //
    //  Size of Index Allocation Buffer in bytes.
    //

    ULONG BytesPerIndexBuffer;                                      //  offset = 0x008

    //
    //  Size of Index Allocation Buffers in units of blocks.
    //  Blocks will be clusters when index buffer is equal or
    //  larger than clusters and log blocks for large
    //  cluster systems.
    //

    UCHAR BlocksPerIndexBuffer;                                     //  offset = 0x00C

    //
    //  Reserved to round to quad word boundary.
    //

    UCHAR Reserved[3];                                              //  offset = 0x00D

    //
    //  Index Header to describe the Index Entries which follow
    //

    INDEX_HEADER IndexHeader;                                       //  offset = 0x010

} INDEX_ROOT;                                                       //  sizeof = 0x020
typedef INDEX_ROOT *PINDEX_ROOT;

//
//  Index Allocation record is used for non-root clusters of the
//  b-tree.  Each non root cluster is contained in the data part of
//  the index allocation attribute.  Each cluster starts with an
//  index allocation list header and is followed by one or more
//  index entries.
//

typedef struct _INDEX_ALLOCATION_BUFFER {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "INDX" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;                          //  offset = 0x000

    //
    //  Log File Sequence Number of last logged update to this Index
    //  Allocation Buffer.
    //

    LSN Lsn;                                                        //  offset = 0x008

    //
    //  We store the index block of this Index Allocation buffer for
    //  convenience and possible consistency checking.
    //

    VCN ThisBlock;                                                  //  offset = 0x010

    //
    //  Index Header to describe the Index Entries which follow
    //

    INDEX_HEADER IndexHeader;                                       //  offset = 0x018

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the Index Allocation Buffer.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;                      //  offset = 0x028

} INDEX_ALLOCATION_BUFFER;
typedef INDEX_ALLOCATION_BUFFER *PINDEX_ALLOCATION_BUFFER;

//
//  Default size of index buffer and index blocks.
//

#define DEFAULT_INDEX_BLOCK_SIZE        (0x200)
#define DEFAULT_INDEX_BLOCK_BYTE_SHIFT  (9)

//
//  Index Entry.  This structure is common to both the resident
//  index list attribute and the Index Allocation records
//

typedef struct _INDEX_ENTRY {

    //
    //  Define a union to distinguish directory indices from view indices
    //

    union {

        //
        //  Reference to file containing the attribute with this
        //  attribute value.
        //

        FILE_REFERENCE FileReference;                               //  offset = 0x000

        //
        //  For views, describe the Data Offset and Length in bytes
        //

        struct {

            USHORT DataOffset;                                      //  offset = 0x000
            USHORT DataLength;                                      //  offset = 0x001
            ULONG ReservedForZero;                                  //  offset = 0x002
        };
    };

    //
    //  Length of this index entry, in bytes.
    //

    USHORT Length;                                                  //  offset = 0x008

    //
    //  Length of attribute value, in bytes.  The attribute value
    //  immediately follows this record.
    //

    USHORT AttributeLength;                                         //  offset = 0x00A

    //
    //  INDEX_ENTRY_xxx Flags.
    //

    USHORT Flags;                                                   //  offset = 0x00C

    //
    //  Reserved to round to quad-word boundary.
    //

    USHORT Reserved;                                                //  offset = 0x00E

    //
    //  If this Index Entry is an intermediate node in the tree, as
    //  determined by the INDEX_xxx flags, then a VCN  is stored at
    //  the end of this entry at Length - sizeof(VCN).
    //

} INDEX_ENTRY;                                                      //  sizeof = 0x010
typedef INDEX_ENTRY *PINDEX_ENTRY;

//
//  INDEX_ENTRY_xxx flags
//

//
//  This entry is currently in the intermediate node form, i.e., it
//  has a Vcn at the end.
//

#define INDEX_ENTRY_NODE                 (0x0001)

//
//  This entry is the special END record for the Index or Index
//  Allocation buffer.
//

#define INDEX_ENTRY_END                  (0x0002)

//
//  This flag is *not* part of the on-disk structure.  It is defined
//  and reserved here for the convenience of the implementation to
//  help avoid allocating buffers from the pool and copying.
//

#define INDEX_ENTRY_POINTER_FORM         (0x8000)

#define NtfsIndexEntryBlock(IE) (                                       \
    *(PLONGLONG)((PCHAR)(IE) + (ULONG)(IE)->Length - sizeof(LONGLONG))  \
    )

#define NtfsSetIndexEntryBlock(IE,IB) {                                         \
    *(PLONGLONG)((PCHAR)(IE) + (ULONG)(IE)->Length - sizeof(LONGLONG)) = (IB);  \
    }

#define NtfsFirstIndexEntry(IH) (                       \
    (PINDEX_ENTRY)((PCHAR)(IH) + (IH)->FirstIndexEntry) \
    )

#define NtfsNextIndexEntry(IE) (                        \
    (PINDEX_ENTRY)((PCHAR)(IE) + (ULONG)(IE)->Length)   \
    )

#define NtfsCheckIndexBound(IE, IH) {                                                               \
    if (((PCHAR)(IE) < (PCHAR)(IH)) ||                                                              \
        (((PCHAR)(IE) + sizeof( INDEX_ENTRY )) > ((PCHAR)Add2Ptr((IH), (IH)->BytesAvailable)))) {   \
        NtfsRaiseStatus(IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );                        \
    }                                                                                               \
}


//
//  MFT Bitmap attribute
//
//  The MFT Bitmap is simply a normal attribute stream in which
//  there is one bit to represent the allocation state of each File
//  Record Segment in the MFT.  Bit clear means free, and bit set
//  means allocated.
//
//  Whenever the MFT Data attribute is extended, the MFT Bitmap
//  attribute must also be extended.  If the bitmap is still in a
//  file record segment for the MFT, then it must be extended and
//  the new bits cleared.  When the MFT Bitmap is in the Nonresident
//  form, then the allocation should always be sufficient to store
//  enough bits to describe the MFT, however ValidDataLength insures
//  that newly allocated space to the MFT Bitmap has an initial
//  value of all 0's.  This means that if the MFT Bitmap is extended,
//  the newly represented file record segments are automatically in
//  the free state.
//
//  No structure definition is required; the positional offset of
//  the file record segment is exactly equal to the bit offset of
//  its corresponding bit in the Bitmap.
//


//
//  USN Journal Instance
//
//  The following describe the current instance of the Usn journal.
//

typedef struct _USN_JOURNAL_INSTANCE {

#ifdef __cplusplus
    CREATE_USN_JOURNAL_DATA JournalData;
#else   // __cplusplus
    CREATE_USN_JOURNAL_DATA;
#endif  // __cplusplus

    ULONGLONG JournalId;
    USN LowestValidUsn;

} USN_JOURNAL_INSTANCE, *PUSN_JOURNAL_INSTANCE;

//
//  Reparse point index keys.
//
//  The index with all the reparse points that exist in a volume at a
//  given time contains entries with keys of the form
//                        <reparse tag, file record id>.
//  The data part of these records is empty.
//

typedef struct _REPARSE_INDEX_KEY {

    //
    //  The tag of the reparse point.
    //

    ULONG FileReparseTag;

    //
    //  The file record Id where the reparse point is set.
    //

    LARGE_INTEGER FileId;

} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;



//
//  Ea Information attribute
//
//  This attribute is only present if the file/directory also has an
//  EA attribute.  It is used to store common EA query information.
//

typedef struct _EA_INFORMATION {

    //
    //  The size of buffer needed to pack these Ea's
    //

    USHORT PackedEaSize;                                            //  offset = 0x000

    //
    //  This is the count of Ea's with their NEED_EA
    //  bit set.
    //

    USHORT NeedEaCount;                                             //  offset = 0x002

    //
    //  The size of the buffer needed to return all Ea's
    //  in their unpacked form.
    //

    ULONG UnpackedEaSize;                                           //  offset = 0x004

}  EA_INFORMATION;                                                  //  sizeof = 0x008
typedef EA_INFORMATION *PEA_INFORMATION;


//
//  Define the struture of the quota data in the quota index.  The key for
//  the quota index is the 32 bit owner id.
//

typedef struct _QUOTA_USER_DATA {
    ULONG QuotaVersion;
    ULONG QuotaFlags;
    ULONGLONG QuotaUsed;
    ULONGLONG QuotaChangeTime;
    ULONGLONG QuotaThreshold;
    ULONGLONG QuotaLimit;
    ULONGLONG QuotaExceededTime;
    SID QuotaSid;
} QUOTA_USER_DATA, *PQUOTA_USER_DATA;

//
//  Define the size of the quota user data structure without the quota SID.
//

#define SIZEOF_QUOTA_USER_DATA FIELD_OFFSET(QUOTA_USER_DATA, QuotaSid)

//
//  Define the current version of the quote user data.
//

#define QUOTA_USER_VERSION 2

//
//  Define the quota flags.
//

#define QUOTA_FLAG_DEFAULT_LIMITS           (0x00000001)
#define QUOTA_FLAG_LIMIT_REACHED            (0x00000002)
#define QUOTA_FLAG_ID_DELETED               (0x00000004)
#define QUOTA_FLAG_USER_MASK                (0x00000007)

//
//  The following flags are only stored in the quota defaults index entry.
//

#define QUOTA_FLAG_TRACKING_ENABLED         (0x00000010)
#define QUOTA_FLAG_ENFORCEMENT_ENABLED      (0x00000020)
#define QUOTA_FLAG_TRACKING_REQUESTED       (0x00000040)
#define QUOTA_FLAG_LOG_THRESHOLD            (0x00000080)
#define QUOTA_FLAG_LOG_LIMIT                (0x00000100)
#define QUOTA_FLAG_OUT_OF_DATE              (0x00000200)
#define QUOTA_FLAG_CORRUPT                  (0x00000400)
#define QUOTA_FLAG_PENDING_DELETES          (0x00000800)

//
//  Define special quota owner ids.
//

#define QUOTA_INVALID_ID        0x00000000
#define QUOTA_DEFAULTS_ID       0x00000001
#define QUOTA_FISRT_USER_ID     0x00000100


//
//  Attribute Definition Table
//
//  The following struct defines the columns of this table.
//  Initially they will be stored as simple records, and ordered by
//  Attribute Type Code.
//

typedef struct _ATTRIBUTE_DEFINITION_COLUMNS {

    //
    //  Unicode attribute name.
    //

    WCHAR AttributeName[64];                                        //  offset = 0x000

    //
    //  Attribute Type Code.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;                          //  offset = 0x080

    //
    //  Default Display Rule for this attribute
    //

    DISPLAY_RULE DisplayRule;                                       //  offset = 0x084

    //
    //  Default Collation rule
    //

    COLLATION_RULE CollationRule;                                   //  offset = 0x088

    //
    //  ATTRIBUTE_DEF_xxx flags
    //

    ULONG Flags;                                                    //  offset = 0x08C

    //
    //  Minimum Length for attribute, if present.
    //

    LONGLONG MinimumLength;                                         //  offset = 0x090

    //
    //  Maximum Length for attribute.
    //

    LONGLONG MaximumLength;                                         //  offset = 0x098

} ATTRIBUTE_DEFINITION_COLUMNS;                                     //  sizeof = 0x0A0
typedef ATTRIBUTE_DEFINITION_COLUMNS *PATTRIBUTE_DEFINITION_COLUMNS;

//
//  ATTRIBUTE_DEF_xxx flags
//

//
//  This flag is set if the attribute may be indexed.
//

#define ATTRIBUTE_DEF_INDEXABLE          (0x00000002)

//
//  This flag is set if the attribute may occur more than once, such
//  as is allowed for the File Name attribute.
//

#define ATTRIBUTE_DEF_DUPLICATES_ALLOWED (0x00000004)

//
//  This flag is set if the value of the attribute may not be
//  entirely null, i.e., all binary 0's.
//

#define ATTRIBUTE_DEF_MAY_NOT_BE_NULL    (0x00000008)

//
//  This attribute must be indexed, and no two attributes may exist
//  with the same value in the same file record segment.
//

#define ATTRIBUTE_DEF_MUST_BE_INDEXED    (0x00000010)

//
//  This attribute must be named, and no two attributes may exist
//  with the same name in the same file record segment.
//

#define ATTRIBUTE_DEF_MUST_BE_NAMED      (0x00000020)

//
//  This attribute must be in the Resident Form.
//

#define ATTRIBUTE_DEF_MUST_BE_RESIDENT   (0x00000040)

//
//  Modifications to this attribute should be logged even if the
//  attribute is nonresident.
//

#define ATTRIBUTE_DEF_LOG_NONRESIDENT    (0X00000080)



//
//  MACROS
//
//  Define some macros that are helpful for manipulating NTFS on
//  disk structures.
//

//
//  The following macro returns the first attribute record in a file
//  record segment.
//
//      PATTRIBUTE_RECORD_HEADER
//      NtfsFirstAttribute (
//          IN PFILE_RECORD_SEGMENT_HEADER FileRecord
//          );
//
//  The following macro takes a pointer to an attribute record (or
//  attribute list entry) and returns a pointer to the next
//  attribute record (or attribute list entry) in the list
//
//      PVOID
//      NtfsGetNextRecord (
//          IN PATTRIB_RECORD or PATTRIB_LIST_ENTRY Struct
//          );
//
//
//  The following macro takes as input a attribute record or
//  attribute list entry and initializes a string variable to the
//  name found in the record or entry.  The memory used for the
//  string buffer is the memory found in the attribute.
//
//      VOID
//      NtfsInitializeStringFromAttribute (
//          IN OUT PUNICODE_STRING Name,
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//      VOID
//      NtfsInitializeStringFromEntry (
//          IN OUT PUNICODE_STRING Name,
//          IN PATTRIBUTE_LIST_ENTRY Entry
//          );
//
//
//  The following two macros assume resident form and should only be
//  used when that state is known.  They return a pointer to the
//  value a resident attribute or a pointer to the byte one beyond
//  the value.
//
//      PVOID
//      NtfsGetValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//      PVOID
//      NtfsGetBeyondValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//  The following two macros return a boolean value indicating if
//  the input attribute record is of the specified type code, or the
//  indicated value.  The equivalent routine to comparing attribute
//  names cannot be defined as a macro and is declared in AttrSup.c
//
//      BOOLEAN
//      NtfsEqualAttributeTypeCode (
//          IN PATTRIBUTE_RECORD_HEADER Attribute,
//          IN ATTRIBUTE_TYPE_CODE Code
//          );
//
//      BOOLEAN
//      NtfsEqualAttributeValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute,
//          IN PVOID Value,
//          IN ULONG Length
//          );
//

#define NtfsFirstAttribute(FRS) (                                          \
    (PATTRIBUTE_RECORD_HEADER)((PCHAR)(FRS) + (FRS)->FirstAttributeOffset) \
)

#define NtfsGetNextRecord(STRUCT) (                    \
    (PVOID)((PUCHAR)(STRUCT) + (STRUCT)->RecordLength) \
)

#define NtfsCheckRecordBound(PTR, SPTR, SIZ) {                                          \
    if (((PCHAR)(PTR) < (PCHAR)(SPTR)) || ((PCHAR)(PTR) >= ((PCHAR)(SPTR) + (SIZ)))) {  \
        NtfsRaiseStatus(IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );            \
    }                                                                                   \
}

#define NtfsInitializeStringFromAttribute(NAME,ATTRIBUTE) {                \
    (NAME)->Length = (USHORT)(ATTRIBUTE)->NameLength << 1;                 \
    (NAME)->MaximumLength = (NAME)->Length;                                \
    (NAME)->Buffer = (PWSTR)Add2Ptr((ATTRIBUTE), (ATTRIBUTE)->NameOffset); \
}

#define NtfsInitializeStringFromEntry(NAME,ENTRY) {                        \
    (NAME)->Length = (USHORT)(ENTRY)->AttributeNameLength << 1;            \
    (NAME)->MaximumLength = (NAME)->Length;                                \
    (NAME)->Buffer = (PWSTR)((ENTRY) + 1);                                 \
}

#define NtfsGetValue(ATTRIBUTE) (                                \
    Add2Ptr((ATTRIBUTE), (ATTRIBUTE)->Form.Resident.ValueOffset) \
)

#define NtfsGetBeyondValue(ATTRIBUTE) (                                      \
    Add2Ptr(NtfsGetValue(ATTRIBUTE), (ATTRIBUTE)->Form.Resident.ValueLength) \
)

#define NtfsEqualAttributeTypeCode(A,C) ( \
    (C) == (A)->TypeCode                  \
)

#define NtfsEqualAttributeValue(A,V,L) (     \
    NtfsIsAttributeResident(A) &&            \
    (A)->Form.Resident.ValueLength == (L) && \
    RtlEqualMemory(NtfsGetValue(A),(V),(L))  \
)

#pragma pack()

#endif //  _NTFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfsexp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Ntfsexp.c

Abstract:

    This module implements the exported routines for Ntfs

Author:

    Jeff Havens     [JHavens]        20-Dec-1995

Revision History:

--*/

#include "NtfsProc.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsLoadAddOns)
#pragma alloc_text(PAGE, NtOfsRegisterCallBacks)
#endif

NTSTATUS
EfsInitialization(
    void
    );


VOID
NtfsLoadAddOns (
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Context,
    IN ULONG Count
    )

/*++

Routine Description:

    This routine attempts to initialize the efs support library.

Arguments:

    DriverObject - Driver object for NTFS

    Context - Unused, required by I/O system.

    Count - Unused, required by I/O system.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Count);
    UNREFERENCED_PARAMETER(DriverObject);

    //
    // do any efs initialization
    // we ignore the status return bedcause there really
    // isn't anything we can do about it and ntfs will work
    // fine without it.
    //

    if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_PERSONAL )) {
        Status = EfsInitialization();
    }

    //
    // return to caller
    //

    return;
}


NTSTATUS
NtOfsRegisterCallBacks (
    NTFS_ADDON_TYPES NtfsAddonType,
    PVOID CallBackTable
    )

/*++

Routine Description:

    This routine is called by one of the NTFS add-ons to register its
    callback routines. These routines are call by NTFS at the appropriate
    times.

Arguments:

    NtfsAddonType - Indicates the type of callback table.

    CallBackTable - Pointer to call back routines for addon.

Return Value:

    Returns a status indicating if the callbacks were accepted.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    switch (NtfsAddonType) {

    case Encryption :

        {
            Status = STATUS_INVALID_PARAMETER;

            //
            //  Bail if Ntfs has not been initialized.
            //

            if (SafeNodeType( &NtfsData ) != NTFS_NTC_DATA_HEADER) {

                return STATUS_DEVICE_DOES_NOT_EXIST;

            } else {

                //
                //  Only allow one encryption driver to register.
                //

                NtfsLockNtfsData();

                if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

                    ENCRYPTION_CALL_BACK *EncryptionCallBackTable = CallBackTable;

                    //
                    //  The caller must pass a callback table and the version must be correct.
                    //

                    if ((EncryptionCallBackTable != NULL) &&
                        (EncryptionCallBackTable->InterfaceVersion == ENCRYPTION_CURRENT_INTERFACE_VERSION)) {

                        //
                        // Save the call back values.
                        //

                        RtlCopyMemory( &NtfsData.EncryptionCallBackTable,
                                       EncryptionCallBackTable,
                                       sizeof( ENCRYPTION_CALL_BACK ));
#ifdef EFSDBG
                        NtfsData.EncryptionCallBackTable.AfterReadProcess = NtfsDummyEfsRead;
                        NtfsData.EncryptionCallBackTable.BeforeWriteProcess = NtfsDummyEfsWrite;
#endif
                        SetFlag( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER );
                        Status = STATUS_SUCCESS;
                    }
                }

                NtfsUnlockNtfsData();
                return Status;
            }
        }

    default :

        return STATUS_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfsdata.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsData.h

Abstract:

    This module declares the global data used by the Ntfs file system.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#ifndef _NTFSDATA_
#define _NTFSDATA_

//
//  The following are used to determine what level of protection to attach
//  to system files and attributes.
//

extern BOOLEAN NtfsProtectSystemFiles;
extern BOOLEAN NtfsProtectSystemAttributes;

//
//  The following is used to indicate the multiplier value for the Mft zone.
//

extern ULONG NtfsMftZoneMultiplier;

//
//  Debug code for finding corruption.
//

/*
#if (DBG || defined( NTFS_FREE_ASSERTS ))
*/
extern BOOLEAN NtfsBreakOnCorrupt;
/*
#endif
*/

//
//  Enable compression on the wire.
//

extern BOOLEAN NtfsEnableCompressedIO;

//
//  Default restart version.
//

extern ULONG NtfsDefaultRestartVersion;

//
//  Performance statistics
//

extern ULONG NtfsMaxDelayedCloseCount;
extern ULONG NtfsMinDelayedCloseCount;
extern ULONG NtfsThrottleCreates;
extern ULONG NtfsFailedHandedOffPagingFileOps;
extern ULONG NtfsFailedPagingFileOps;
extern ULONG NtfsFailedLfsRestart;

extern ULONG NtfsCleanCheckpoints;
extern ULONG NtfsPostRequests;

//
//  The global fsd data record
//

extern NTFS_DATA NtfsData;

//
//  Mutant to synchronize creation of stream files. This can be acquired recursively
//  which we need in this case
//

extern KMUTANT StreamFileCreationMutex;

//
//  Notification event for creation of encrypted files.
//

extern KEVENT NtfsEncryptionPendingEvent;
#ifdef KEITHKA
extern ULONG EncryptionPendingCount;
#endif

//
//  A mutex and queue of NTFS MCBS that will be freed
//  if we reach over a certain threshold
//

extern FAST_MUTEX NtfsMcbFastMutex;
extern LIST_ENTRY NtfsMcbLruQueue;

extern ULONG NtfsMcbHighWaterMark;
extern ULONG NtfsMcbLowWaterMark;
extern ULONG NtfsMcbCurrentLevel;

extern BOOLEAN NtfsMcbCleanupInProgress;
extern WORK_QUEUE_ITEM NtfsMcbWorkItem;

//
//  The following are global large integer constants used throughout ntfs
//  We declare the actual name using Ntfs prefixes to avoid any linking
//  conflicts but internally in the file system we'll use smaller Li prefixes
//  to denote the values.
//

extern LARGE_INTEGER NtfsLarge0;
extern LARGE_INTEGER NtfsLarge1;
extern LARGE_INTEGER NtfsLargeMax;
extern LARGE_INTEGER NtfsLargeEof;

extern LONGLONG NtfsLastAccess;

#define Li0                              (NtfsLarge0)
#define Li1                              (NtfsLarge1)
#define LiMax                            (NtfsLargeMax)
#define LiEof                            (NtfsLargeEof)

#define MAXULONGLONG                     (0xffffffffffffffff)
#define UNUSED_LCN                       ((LONGLONG)(-1))

//
//  Maximum file size is limited by MM's shift from file size to number of pages.
//

#define MAXFILESIZE                      (0xfffffff0000)

//
//  Maximum clusters per Ntfs Mcb range.  We currently only support (2^32 - 1)
//  clusters in an Mcb.
//

#define MAX_CLUSTERS_PER_RANGE          (0x100000000 - 1)

//
//   The following fields are used to allocate nonpaged structures
//  using a lookaside list, and other fixed sized structures from a
//  small cache.
//

extern NPAGED_LOOKASIDE_LIST NtfsIoContextLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsIrpContextLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsKeventLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsScbNonpagedLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsScbSnapshotLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsCompressSyncLookasideList;

extern PAGED_LOOKASIDE_LIST NtfsCcbLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsCcbDataLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsDeallocatedRecordsLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsFcbDataLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsFcbIndexLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsIndexContextLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsLcbLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsNukemLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsScbDataLookasideList;

//
//  This is the string for the name of the index allocation attributes.
//

extern const UNICODE_STRING NtfsFileNameIndex;

//
//  This is the string for the attribute code for index allocation.
//  $INDEX_ALLOCATION.
//

extern const UNICODE_STRING NtfsIndexAllocation;

//
//  This is the string for the data attribute, $DATA.
//

extern const UNICODE_STRING NtfsDataString;

//
//  This is the string for the bitmap attribute, $BITMAP.
//

extern const UNICODE_STRING NtfsBitmapString;

//
//  This is the string for the attribute list attribute, $ATTRIBUTE_LIST.
//

extern const UNICODE_STRING NtfsAttrListString;

//
//  This is the string for the reparse pt. attribute, $REPARSE_POINT
//

extern const UNICODE_STRING NtfsReparsePointString;


//
//  These strings are used as the Scb->AttributeName for
//  user-opened general indices.
//

extern const UNICODE_STRING NtfsObjId;
extern const UNICODE_STRING NtfsQuota;

extern const UNICODE_STRING JournalStreamName;

//
//  These are the strings for the files in the extend directory.
//

extern const UNICODE_STRING NtfsExtendName;
extern const UNICODE_STRING NtfsUsnJrnlName;
extern const UNICODE_STRING NtfsQuotaName;
extern const UNICODE_STRING NtfsObjectIdName;
extern const UNICODE_STRING NtfsMountTableName;

//
//  This strings are used for informational popups.
//

extern const UNICODE_STRING NtfsSystemFiles[];

//
//  This is the '.' string to use to lookup the parent entry.
//

extern const UNICODE_STRING NtfsRootIndexString;

extern const UNICODE_STRING NtfsInternalUseFile[];

#define CHANGEATTRIBUTEVALUE_FILE_NUMBER            (0)     //  $ChangeAttributeValue
#define CHANGEATTRIBUTEVALUE2_FILE_NUMBER           (1)     //  $ChangeAttributeValue2
#define COMMONCLEANUP_FILE_NUMBER                   (2)     //  $CommonCleanup
#define CONVERTTONONRESIDENT_FILE_NUMBER            (3)     //  $ConvertToNonresident
#define CREATENONRESIDENTWITHVALUE_FILE_NUMBER      (4)     //  $CreateNonresidentWithValue
#define DEALLOCATERECORD_FILE_NUMBER                (5)     //  $DeallocateRecord
#define DELETEALLOCATIONFROMRECORD_FILE_NUMBER      (6)     //  $DeleteAllocationFromRecord
#define DIRECTORY_FILE_NUMBER                       (7)     //  $Directory
#define INITIALIZERECORDALLOCATION_FILE_NUMBER      (8)     //  $InitializeRecordAllocation
#define MAPATTRIBUTEVALUE_FILE_NUMBER               (9)     //  $MapAttributeValue
#define NONCACHEDIO_FILE_NUMBER                     (10)    //  $NonCachedIo
#define PERFORMHOTFIX_FILE_NUMBER                   (11)    //  $PerformHotFix
#define PREPARETOSHRINKFILESIZE_FILE_NUMBER         (12)    //  $PrepareToShrinkFileSize
#define REPLACEATTRIBUTE_FILE_NUMBER                (13)    //  $ReplaceAttribute
#define REPLACEATTRIBUTE2_FILE_NUMBER               (14)    //  $ReplaceAttribute2
#define SETALLOCATIONINFO_FILE_NUMBER               (15)    //  $SetAllocationInfo
#define SETENDOFFILEINFO_FILE_NUMBER                (16)    //  $SetEndOfFileInfo
#define ZERORANGEINSTREAM_FILE_NUMBER               (17)    //  $ZeroRangeInStream
#define ZERORANGEINSTREAM2_FILE_NUMBER              (18)    //  $ZeroRangeInStream2
#define ZERORANGEINSTREAM3_FILE_NUMBER              (19)    //  $ZeroRangeInStream3

//
//  This is the empty string.  This can be used to pass a string with
//  no length.
//

extern const UNICODE_STRING NtfsEmptyString;

//
//  The following file references are used to identify system files.
//

extern const FILE_REFERENCE MftFileReference;
extern const FILE_REFERENCE Mft2FileReference;
extern const FILE_REFERENCE LogFileReference;
extern const FILE_REFERENCE VolumeFileReference;
extern const FILE_REFERENCE AttrDefFileReference;
extern const FILE_REFERENCE RootIndexFileReference;
extern const FILE_REFERENCE BitmapFileReference;
extern const FILE_REFERENCE BootFileReference;
extern const FILE_REFERENCE ExtendFileReference;
extern const FILE_REFERENCE FirstUserFileReference;

//
//  The number of attributes in the attribute definition table, including the end record
//

extern ULONG NtfsAttributeDefinitionsCount;

//
//  The global structure used to contain our fast I/O callbacks
//

extern FAST_IO_DISPATCH NtfsFastIoDispatch;

#ifdef BRIANDBG
extern ULONG NtfsIgnoreReserved;
#endif

extern const UCHAR BaadSignature[4];
extern const UCHAR IndexSignature[4];
extern const UCHAR FileSignature[4];
extern const UCHAR HoleSignature[4];
extern const UCHAR ChkdskSignature[4];

//
//  Reserved buffers needed.
//
//      RESERVED_BUFFER_ONE_NEEDED - User only needs one buffer to complete request, any buffer will do.
//      RESERVED_BUFFER_TWO_NEEDED - User may need a second buffer after this one.
//      RESERVED_BUFFER_WORKSPACE_NEEDED - This is second buffer of two needed.
//

#define RESERVED_BUFFER_ONE_NEEDED          (0x0)
#define RESERVED_BUFFER_TWO_NEEDED          (0x1)
#define RESERVED_BUFFER_WORKSPACE_NEEDED    (0x2)

//
//  Large Reserved Buffer Context
//

extern ULONG NtfsReservedInUse;
extern PVOID NtfsReserved1;
extern PVOID NtfsReserved2;
extern ULONG NtfsReserved2Count;
extern PVOID NtfsReserved3;
extern PVOID NtfsReserved1Thread;
extern PVOID NtfsReserved2Thread;
extern PVOID NtfsReserved3Thread;
extern PFCB NtfsReserved12Fcb;
extern PFCB NtfsReserved3Fcb;
extern PVOID NtfsReservedBufferThread;
extern BOOLEAN NtfsBufferAllocationFailure;
extern FAST_MUTEX NtfsReservedBufferMutex;
extern ERESOURCE NtfsReservedBufferResource;
extern LARGE_INTEGER NtfsShortDelay;
extern FAST_MUTEX NtfsScavengerLock;
extern PIRP_CONTEXT NtfsScavengerWorkList;
extern BOOLEAN NtfsScavengerRunning;
extern ULONGLONG NtfsMaxQuotaNotifyRate;
extern ULONG NtfsAsyncPostThreshold;

#define LARGE_BUFFER_SIZE                (0x10000)

#ifdef _WIN64
#define WORKSPACE_BUFFER_SIZE           (LARGE_BUFFER_SIZE + PAGE_SIZE)
#else
#define WORKSPACE_BUFFER_SIZE           (LARGE_BUFFER_SIZE)
#endif

extern UCHAR NtfsZeroExtendedInfo[48];

#ifdef NTFS_RWC_DEBUG
//
//  Range to include in COW checks.
//

extern LONGLONG NtfsRWCLowThreshold;
extern LONGLONG NtfsRWCHighThreshold;
#endif

//
//  The following is the number of minutes for the last access increment
//

#define LAST_ACCESS_INCREMENT_MINUTES   (60)

//
// Read ahead amount used for normal data files
//

#define READ_AHEAD_GRANULARITY           (0x10000)

//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define NTFS_MAX_PARALLEL_IOS            ((ULONG)8)

//
//  Define a symbol which states the maximum number of runs that will be
//  added or deleted in one transaction per attribute.  Note that the per-run
//  cost of deleting a run is 8-bytes in the BITMAP_RANGE, an average of
//  four bytes in the mapping array, and 16 bytes in the LCN_RANGE - for a total
//  of 28-bytes.  Allocations do not log an LCN_RANGE, so their per-run cost is
//  12 bytes.  The worst problem is deleteing large fragmented files, where you
//  must add the cost of the rest of the log records for deleting all the attributes.
//

#define MAXIMUM_RUNS_AT_ONCE             (128)



//
//  Turn on pseudo-asserts if NTFS_FREE_ASSERTS is defined.
//

#if (!DBG && defined( NTFS_FREE_ASSERTS )) || defined( NTFSDBG )
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)                                             \
    ((exp) ? TRUE :                                             \
             (DbgPrint( "%s:%d %s\n",__FILE__,__LINE__,#exp ),  \
              DbgBreakPoint(),                                  \
              TRUE))
#define ASSERTMSG(msg,exp)                                              \
    ((exp) ? TRUE :                                                     \
             (DbgPrint( "%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp ),   \
              DbgBreakPoint(),                                          \
              TRUE))
#endif

#ifdef NTFS_LOG_FULL_TEST
extern LONG NtfsFailCheck;
extern LONG NtfsFailFrequency;
extern LONG NtfsPeriodicFail;

//
//  Perform log-file-full testing.
//

#define FailCheck(I,S) {                                    \
    PIRP_CONTEXT FailTopContext = (I)->TopLevelIrpContext;  \
    if (FailTopContext->NextFailCount != 0) {               \
        if (--FailTopContext->CurrentFailCount == 0) {      \
            FailTopContext->NextFailCount++;                \
            FailTopContext->CurrentFailCount = FailTopContext->NextFailCount; \
            ExRaiseStatus( S );                             \
        }                                                   \
    }                                                       \
}

#define LogFileFullFailCheck(I) FailCheck( I, STATUS_LOG_FILE_FULL )
#endif

//
//  The following debug macros are used in ntfs and defined in this module
//
//      DebugTrace( Indent, Level, (DbgPrint list) );
//
//      DebugUnwind( NonquotedString );
//
//      DebugDoit( Statement );
//
//      DbgDoit( Statement );
//
//  The following assertion macros ensure that the indicated structure
//  is valid
//
//      ASSERT_VCB( IN PVCB Vcb );
//      ASSERT_OPTIONAL_VCB( IN PVCB Vcb OPTIONAL );
//
//      ASSERT_FCB( IN PFCB Fcb );
//      ASSERT_OPTIONAL_FCB( IN PFCB Fcb OPTIONAL );
//
//      ASSERT_SCB( IN PSCB Scb );
//      ASSERT_OPTIONAL_SCB( IN PSCB Scb OPTIONAL );
//
//      ASSERT_CCB( IN PSCB Ccb );
//      ASSERT_OPTIONAL_CCB( IN PSCB Ccb OPTIONAL );
//
//      ASSERT_LCB( IN PLCB Lcb );
//      ASSERT_OPTIONAL_LCB( IN PLCB Lcb OPTIONAL );
//
//      ASSERT_PREFIX_ENTRY( IN PPREFIX_ENTRY PrefixEntry );
//      ASSERT_OPTIONAL_PREFIX_ENTRY( IN PPREFIX_ENTRY PrefixEntry OPTIONAL );
//
//      ASSERT_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext );
//      ASSERT_OPTIONAL_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext OPTIONAL );
//
//      ASSERT_IRP( IN PIRP Irp );
//      ASSERT_OPTIONAL_IRP( IN PIRP Irp OPTIONAL );
//
//      ASSERT_FILE_OBJECT( IN PFILE_OBJECT FileObject );
//      ASSERT_OPTIONAL_FILE_OBJECT( IN PFILE_OBJECT FileObject OPTIONAL );
//
//  The following macros are used to check the current thread owns
//  the indicated resource
//
//      ASSERT_EXCLUSIVE_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_SHARED_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_RESOURCE_NOT_MINE( IN PERESOURCE Resource );
//
//  The following macros are used to check whether the current thread
//  owns the resoures in the given structures.
//
//      ASSERT_EXCLUSIVE_FCB( IN PFCB Fcb );
//
//      ASSERT_SHARED_FCB( IN PFCB Fcb );
//
//      ASSERT_EXCLUSIVE_SCB( IN PSCB Scb );
//
//      ASSERT_SHARED_SCB( IN PSCB Scb );
//
//  The following macro is used to check that we are not trying to
//  manipulate an lcn that does not exist
//
//      ASSERT_LCN_RANGE( IN PVCB Vcb, IN LCN Lcn );
//

#ifdef NTFSDBG

extern LONG NtfsDebugTraceLevel;
extern LONG NtfsDebugTraceIndent;
extern LONG NtfsReturnStatusFilter;

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_QUOTA                (0x00000002)
#define DEBUG_TRACE_OBJIDSUP             (0x00000002) // shared with Quota
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_UNWIND               (0x00000008)

#define DEBUG_TRACE_CLEANUP              (0x00000010)
#define DEBUG_TRACE_CLOSE                (0x00000020)
#define DEBUG_TRACE_CREATE               (0x00000040)
#define DEBUG_TRACE_DIRCTRL              (0x00000080)
#define DEBUG_TRACE_VIEWSUP              (0x00000080) // shared with DirCtrl

#define DEBUG_TRACE_EA                   (0x00000100)
#define DEBUG_TRACE_PROP_FSCTL           (0x00000100) // shared with EA
#define DEBUG_TRACE_FILEINFO             (0x00000200)
#define DEBUG_TRACE_SEINFO               (0x00000200) // shared with FileInfo
#define DEBUG_TRACE_FSCTRL               (0x00000400)
#define DEBUG_TRACE_SHUTDOWN             (0x00000400) // shared with FsCtrl
#define DEBUG_TRACE_LOCKCTRL             (0x00000800)

#define DEBUG_TRACE_READ                 (0x00001000)
#define DEBUG_TRACE_VOLINFO              (0x00002000)
#define DEBUG_TRACE_WRITE                (0x00004000)
#define DEBUG_TRACE_FLUSH                (0x00008000)

#define DEBUG_TRACE_DEVCTRL              (0x00010000)
#define DEBUG_TRACE_PNP                  (0x00010000) // shared with DevCtrl
#define DEBUG_TRACE_LOGSUP               (0x00020000)
#define DEBUG_TRACE_BITMPSUP             (0x00040000)
#define DEBUG_TRACE_ALLOCSUP             (0x00080000)

#define DEBUG_TRACE_MFTSUP               (0x00100000)
#define DEBUG_TRACE_INDEXSUP             (0x00200000)
#define DEBUG_TRACE_ATTRSUP              (0x00400000)
#define DEBUG_TRACE_FILOBSUP             (0x00800000)

#define DEBUG_TRACE_NAMESUP              (0x01000000)
#define DEBUG_TRACE_SECURSUP             (0x01000000) // shared with NameSup
#define DEBUG_TRACE_VERFYSUP             (0x02000000)
#define DEBUG_TRACE_CACHESUP             (0x04000000)
#define DEBUG_TRACE_PREFXSUP             (0x08000000)
#define DEBUG_TRACE_HASHSUP              (0x08000000) // shared with PrefxSup

#define DEBUG_TRACE_DEVIOSUP             (0x10000000)
#define DEBUG_TRACE_STRUCSUP             (0x20000000)
#define DEBUG_TRACE_FSP_DISPATCHER       (0x40000000)
#define DEBUG_TRACE_ACLINDEX             (0x80000000)

__inline BOOLEAN
NtfsDebugTracePre(LONG Indent, LONG Level)
{
    if (Level == 0 || (NtfsDebugTraceLevel & Level) != 0) {
        DbgPrint( "%08lx:", PsGetCurrentThread( ));
        if (Indent < 0) {
            NtfsDebugTraceIndent += Indent;
            if (NtfsDebugTraceIndent < 0) {
                NtfsDebugTraceIndent = 0;
            }
        }

        DbgPrint( "%*s", NtfsDebugTraceIndent, "" );

        return TRUE;
    } else {
        return FALSE;
    }
}

__inline void
NtfsDebugTracePost( LONG Indent )
{
    if (Indent > 0) {
        NtfsDebugTraceIndent += Indent;
    }
}

#define DebugTrace(INDENT,LEVEL,M) {                \
    if (NtfsDebugTracePre( (INDENT), (LEVEL))) {    \
        DbgPrint M;                                 \
        NtfsDebugTracePost( (INDENT) );             \
    }                                               \
}

#define DebugUnwind(X) {                                                        \
    if (AbnormalTermination()) {                                                \
        DebugTrace( 0, DEBUG_TRACE_UNWIND, (#X ", Abnormal termination.\n") );  \
    }                                                                           \
}

#define DebugDoit(X)    X
#define DebugPrint(X)   (DbgPrint X, TRUE)

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG NtfsFsdEntryCount;
extern ULONG NtfsFspEntryCount;
extern ULONG NtfsIoCallDriverCount;

#else

#define DebugTrace(INDENT,LEVEL,M)  {NOTHING;}
#define DebugUnwind(X)              {NOTHING;}
#define DebugDoit(X)                 NOTHING
#define DebugPrint(X)                NOTHING

#endif // NTFSDBG

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just  NTFSDBG users
//

#ifdef NTFSDBG

#define DbgDoit(X)                       {X;}

#define ASSERT_VCB(V) {                    \
    ASSERT((NodeType(V) == NTFS_NTC_VCB)); \
}

#define ASSERT_OPTIONAL_VCB(V) {           \
    ASSERT(((V) == NULL) ||                \
           (NodeType(V) == NTFS_NTC_VCB)); \
}

#define ASSERT_FCB(F) {                    \
    ASSERT((NodeType(F) == NTFS_NTC_FCB)); \
}

#define ASSERT_OPTIONAL_FCB(F) {           \
    ASSERT(((F) == NULL) ||                \
           (NodeType(F) == NTFS_NTC_FCB)); \
}

#define ASSERT_SCB(S) {                                 \
    ASSERT((NodeType(S) == NTFS_NTC_SCB_DATA) ||        \
           (NodeType(S) == NTFS_NTC_SCB_MFT)  ||        \
           (NodeType(S) == NTFS_NTC_SCB_INDEX) ||       \
           (NodeType(S) == NTFS_NTC_SCB_ROOT_INDEX));   \
}

#define ASSERT_OPTIONAL_SCB(S) {                        \
    ASSERT(((S) == NULL) ||                             \
           (NodeType(S) == NTFS_NTC_SCB_DATA) ||        \
           (NodeType(S) == NTFS_NTC_SCB_MFT)  ||        \
           (NodeType(S) == NTFS_NTC_SCB_INDEX) ||       \
           (NodeType(S) == NTFS_NTC_SCB_ROOT_INDEX));   \
}

#define ASSERT_CCB(C) {                                 \
    ASSERT((NodeType(C) == NTFS_NTC_CCB_DATA) ||        \
           (NodeType(C) == NTFS_NTC_CCB_INDEX));        \
}

#define ASSERT_OPTIONAL_CCB(C) {                        \
    ASSERT(((C) == NULL) ||                             \
           ((NodeType(C) == NTFS_NTC_CCB_DATA) ||       \
            (NodeType(C) == NTFS_NTC_CCB_INDEX)));      \
}

#define ASSERT_LCB(L) {                    \
    ASSERT((NodeType(L) == NTFS_NTC_LCB)); \
}

#define ASSERT_OPTIONAL_LCB(L) {           \
    ASSERT(((L) == NULL) ||                \
           (NodeType(L) == NTFS_NTC_LCB)); \
}

#define ASSERT_PREFIX_ENTRY(P) {                    \
    ASSERT((NodeType(P) == NTFS_NTC_PREFIX_ENTRY)); \
}

#define ASSERT_OPTIONAL_PREFIX_ENTRY(P) {           \
    ASSERT(((P) == NULL) ||                         \
           (NodeType(P) == NTFS_NTC_PREFIX_ENTRY)); \
}

#define ASSERT_IRP_CONTEXT(I) {                    \
    ASSERT((NodeType(I) == NTFS_NTC_IRP_CONTEXT)); \
}

#define ASSERT_OPTIONAL_IRP_CONTEXT(I) {           \
    ASSERT(((I) == NULL) ||                        \
           (NodeType(I) == NTFS_NTC_IRP_CONTEXT)); \
}

#define ASSERT_IRP(I) {                 \
    ASSERT(((I)->Type == IO_TYPE_IRP)); \
}

#define ASSERT_OPTIONAL_IRP(I) {        \
    ASSERT(((I) == NULL) ||             \
           ((I)->Type == IO_TYPE_IRP)); \
}

#define ASSERT_FILE_OBJECT(F) {          \
    ASSERT(((F)->Type == IO_TYPE_FILE)); \
}

#define ASSERT_OPTIONAL_FILE_OBJECT(F) { \
    ASSERT(((F) == NULL) ||              \
           ((F)->Type == IO_TYPE_FILE)); \
}

#define ASSERT_EXCLUSIVE_RESOURCE(R) {   \
    ASSERTMSG("ASSERT_EXCLUSIVE_RESOURCE ", ExIsResourceAcquiredExclusiveLite(R)); \
}

#define ASSERT_SHARED_RESOURCE(R)        \
    ASSERTMSG( "ASSERT_RESOURCE_NOT_MINE ", ExIsResourceAcquiredSharedLite(R));

#define ASSERT_RESOURCE_NOT_MINE(R)     \
    ASSERTMSG( "ASSERT_RESOURCE_NOT_MINE ", !ExIsResourceAcquiredSharedLite(R));

#define ASSERT_EXCLUSIVE_FCB(F) {                                    \
    if (NtfsSegmentNumber( &(F)->FileReference )                     \
            >= FIRST_USER_FILE_NUMBER) {                             \
        ASSERT_EXCLUSIVE_RESOURCE(F->Resource);                      \
    }                                                                \
}                                                                    \

#define ASSERT_SHARED_FCB(F) {                                       \
    if (NtfsSegmentNumber( &(F)->FileReference )                     \
            >= FIRST_USER_FILE_NUMBER) {                             \
        ASSERT_SHARED_RESOURCE(F->Resource);                         \
    }                                                                \
}                                                                    \

#define ASSERT_EXCLUSIVE_SCB(S)     ASSERT_EXCLUSIVE_FCB(S->Fcb)

#define ASSERT_SHARED_SCB(S)        ASSERT_SHARED_FCB(S->Fcb)

#define ASSERT_LCN_RANGE_CHECKING(V,L) {                                             \
    ASSERTMSG("ASSERT_LCN_RANGE_CHECKING ",                                          \
        ((V)->TotalClusters == 0) || ((L) <= (V)->TotalClusters));                   \
}

#else

#define DbgDoit(X)                       {NOTHING;}
#define ASSERT_VCB(V)                    {DBG_UNREFERENCED_PARAMETER(V);}
#define ASSERT_OPTIONAL_VCB(V)           {DBG_UNREFERENCED_PARAMETER(V);}
#define ASSERT_FCB(F)                    {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_OPTIONAL_FCB(F)           {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_SCB(S)                    {DBG_UNREFERENCED_PARAMETER(S);}
#define ASSERT_OPTIONAL_SCB(S)           {DBG_UNREFERENCED_PARAMETER(S);}
#define ASSERT_CCB(C)                    {DBG_UNREFERENCED_PARAMETER(C);}
#define ASSERT_OPTIONAL_CCB(C)           {DBG_UNREFERENCED_PARAMETER(C);}
#define ASSERT_LCB(L)                    {DBG_UNREFERENCED_PARAMETER(L);}
#define ASSERT_OPTIONAL_LCB(L)           {DBG_UNREFERENCED_PARAMETER(L);}
#define ASSERT_PREFIX_ENTRY(P)           {DBG_UNREFERENCED_PARAMETER(P);}
#define ASSERT_OPTIONAL_PREFIX_ENTRY(P)  {DBG_UNREFERENCED_PARAMETER(P);}
#define ASSERT_IRP_CONTEXT(I)            {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_OPTIONAL_IRP_CONTEXT(I)   {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_IRP(I)                    {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_OPTIONAL_IRP(I)           {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_FILE_OBJECT(F)            {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_OPTIONAL_FILE_OBJECT(F)   {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_EXCLUSIVE_RESOURCE(R)     {NOTHING;}
#define ASSERT_SHARED_RESOURCE(R)        {NOTHING;}
#define ASSERT_RESOURCE_NOT_MINE(R)      {NOTHING;}
#define ASSERT_EXCLUSIVE_FCB(F)          {NOTHING;}
#define ASSERT_SHARED_FCB(F)             {NOTHING;}
#define ASSERT_EXCLUSIVE_SCB(S)          {NOTHING;}
#define ASSERT_SHARED_SCB(S)             {NOTHING;}
#define ASSERT_LCN_RANGE_CHECKING(V,L)   {NOTHING;}

#endif // DBG

#endif // _NTFSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfsdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsData.c

Abstract:

    This module declares the global data used by the Ntfs file system.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_NTFSDATA)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

//
//  Debugging control variables
//

PUCHAR NtfsPageInAddress = NULL;
LONGLONG NtfsMapOffset = -1;

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('NFtN')

#define CollectExceptionStats(VCB,EXCEPTION_CODE) {                                         \
    if ((VCB) != NULL) {                                                                    \
        PFILE_SYSTEM_STATISTICS FsStat = &(VCB)->Statistics[KeGetCurrentProcessorNumber()]; \
        if ((EXCEPTION_CODE) == STATUS_LOG_FILE_FULL) {                                     \
            FsStat->Ntfs.LogFileFullExceptions += 1;                                        \
        } else {                                                                            \
            FsStat->Ntfs.OtherExceptions += 1;                                              \
        }                                                                                   \
    }                                                                                       \
}

//
//  The global fsd data record
//

NTFS_DATA NtfsData;

//
//  Mutex to synchronize creation of stream files.
//

KMUTANT StreamFileCreationMutex;

//
//  Notification event for creation of encrypted files.
//

KEVENT NtfsEncryptionPendingEvent;
#ifdef KEITHKA
ULONG EncryptionPendingCount = 0;
#endif

//
//  A mutex and queue of NTFS MCBS that will be freed
//  if we reach over a certain threshold
//

FAST_MUTEX NtfsMcbFastMutex;
LIST_ENTRY NtfsMcbLruQueue;

ULONG NtfsMcbHighWaterMark;
ULONG NtfsMcbLowWaterMark;
ULONG NtfsMcbCurrentLevel;

BOOLEAN NtfsMcbCleanupInProgress;
WORK_QUEUE_ITEM NtfsMcbWorkItem;

//
//  The global large integer constants
//

LARGE_INTEGER NtfsLarge0 = {0x00000000,0x00000000};
LARGE_INTEGER NtfsLarge1 = {0x00000001,0x00000000};
LARGE_INTEGER NtfsLargeMax = {0xffffffff,0x7fffffff};
LARGE_INTEGER NtfsLargeEof = {0xffffffff,0xffffffff};

LONGLONG NtfsLastAccess;

//
//   The following fields are used to allocate nonpaged structures
//  using a lookaside list, and other fixed sized structures from a
//  small cache.
//

NPAGED_LOOKASIDE_LIST NtfsIoContextLookasideList;
NPAGED_LOOKASIDE_LIST NtfsIrpContextLookasideList;
NPAGED_LOOKASIDE_LIST NtfsKeventLookasideList;
NPAGED_LOOKASIDE_LIST NtfsScbNonpagedLookasideList;
NPAGED_LOOKASIDE_LIST NtfsScbSnapshotLookasideList;
NPAGED_LOOKASIDE_LIST NtfsCompressSyncLookasideList;

PAGED_LOOKASIDE_LIST NtfsCcbLookasideList;
PAGED_LOOKASIDE_LIST NtfsCcbDataLookasideList;
PAGED_LOOKASIDE_LIST NtfsDeallocatedRecordsLookasideList;
PAGED_LOOKASIDE_LIST NtfsFcbDataLookasideList;
PAGED_LOOKASIDE_LIST NtfsFcbIndexLookasideList;
PAGED_LOOKASIDE_LIST NtfsIndexContextLookasideList;
PAGED_LOOKASIDE_LIST NtfsLcbLookasideList;
PAGED_LOOKASIDE_LIST NtfsNukemLookasideList;
PAGED_LOOKASIDE_LIST NtfsScbDataLookasideList;

//
//  Useful constant Unicode strings.
//

//
//  This is the string for the name of the index allocation attributes.
//

const UNICODE_STRING NtfsFileNameIndex = CONSTANT_UNICODE_STRING( L"$I30" );

//
//  This is the string for the attribute code for index allocation.
//  $INDEX_ALLOCATION.
//

const UNICODE_STRING NtfsIndexAllocation = CONSTANT_UNICODE_STRING( L"$INDEX_ALLOCATION" );

//
//  This is the string for the data attribute, $DATA.
//

const UNICODE_STRING NtfsDataString = CONSTANT_UNICODE_STRING( L"$DATA" );

//
//  This is the string for the bitmap attribute
//

const UNICODE_STRING NtfsBitmapString = CONSTANT_UNICODE_STRING( L"$BITMAP" );

//
//  This is the string for the attribute list attribute
//

const UNICODE_STRING NtfsAttrListString = CONSTANT_UNICODE_STRING( L"$ATTRIBUTE_LIST" );

//
//  This is the string for the attribute list attribute
//

const UNICODE_STRING NtfsReparsePointString = CONSTANT_UNICODE_STRING( L"$REPARSE_POINT" );

//
//  These strings are used as the Scb->AttributeName for
//  user-opened general indices.  Declaring them here avoids
//  having to marshal allocating & freeing them.
//

const UNICODE_STRING NtfsObjId = CONSTANT_UNICODE_STRING( L"$O" );
const UNICODE_STRING NtfsQuota = CONSTANT_UNICODE_STRING( L"$Q" );

//
//  The following is the name of the data stream for the Usn journal.
//

const UNICODE_STRING JournalStreamName = CONSTANT_UNICODE_STRING( L"$J" );

//
//  These are the strings for the files in the extend directory.
//

const UNICODE_STRING NtfsExtendName = CONSTANT_UNICODE_STRING( L"$Extend" );
const UNICODE_STRING NtfsUsnJrnlName = CONSTANT_UNICODE_STRING( L"$UsnJrnl" );
const UNICODE_STRING NtfsQuotaName = CONSTANT_UNICODE_STRING( L"$Quota" );
const UNICODE_STRING NtfsObjectIdName = CONSTANT_UNICODE_STRING( L"$ObjId" );
const UNICODE_STRING NtfsMountTableName = CONSTANT_UNICODE_STRING( L"$Reparse" );

//
//  This strings are used for informational popups.
//

const UNICODE_STRING NtfsSystemFiles[] = {

    CONSTANT_UNICODE_STRING( L"\\$Mft" ),
    CONSTANT_UNICODE_STRING( L"\\$MftMirr" ),
    CONSTANT_UNICODE_STRING( L"\\$LogFile" ),
    CONSTANT_UNICODE_STRING( L"\\$Volume" ),
    CONSTANT_UNICODE_STRING( L"\\$AttrDef" ),
    CONSTANT_UNICODE_STRING( L"\\" ),
    CONSTANT_UNICODE_STRING( L"\\$BitMap" ),
    CONSTANT_UNICODE_STRING( L"\\$Boot" ),
    CONSTANT_UNICODE_STRING( L"\\$BadClus" ),
    CONSTANT_UNICODE_STRING( L"\\$Secure" ),
    CONSTANT_UNICODE_STRING( L"\\$UpCase" ),
    CONSTANT_UNICODE_STRING( L"\\$Extend" ),
};

const UNICODE_STRING NtfsInternalUseFile[] = {
    CONSTANT_UNICODE_STRING( L"\\$ChangeAttributeValue" ),
    CONSTANT_UNICODE_STRING( L"\\$ChangeAttributeValue2" ),
    CONSTANT_UNICODE_STRING( L"\\$CommonCleanup" ),
    CONSTANT_UNICODE_STRING( L"\\$ConvertToNonresident" ),
    CONSTANT_UNICODE_STRING( L"\\$CreateNonresidentWithValue" ),
    CONSTANT_UNICODE_STRING( L"\\$DeallocateRecord" ),
    CONSTANT_UNICODE_STRING( L"\\$DeleteAllocationFromRecord" ),
    CONSTANT_UNICODE_STRING( L"\\$Directory" ),
    CONSTANT_UNICODE_STRING( L"\\$InitializeRecordAllocation" ),
    CONSTANT_UNICODE_STRING( L"\\$MapAttributeValue" ),
    CONSTANT_UNICODE_STRING( L"\\$NonCachedIo" ),
    CONSTANT_UNICODE_STRING( L"\\$PerformHotFix" ),
    CONSTANT_UNICODE_STRING( L"\\$PrepareToShrinkFileSize" ),
    CONSTANT_UNICODE_STRING( L"\\$ReplaceAttribute" ),
    CONSTANT_UNICODE_STRING( L"\\$ReplaceAttribute2" ),
    CONSTANT_UNICODE_STRING( L"\\$SetAllocationInfo" ),
    CONSTANT_UNICODE_STRING( L"\\$SetEndOfFileInfo" ),
    CONSTANT_UNICODE_STRING( L"\\$ZeroRangeInStream" ),
    CONSTANT_UNICODE_STRING( L"\\$ZeroRangeInStream2" ),
    CONSTANT_UNICODE_STRING( L"\\$ZeroRangeInStream3" ),
};

const UNICODE_STRING NtfsUnknownFile =
    CONSTANT_UNICODE_STRING( L"\\????" );

const UNICODE_STRING NtfsRootIndexString =
    CONSTANT_UNICODE_STRING( L"." );

//
//  This is the empty string.  This can be used to pass a string with
//  no length.
//

const UNICODE_STRING NtfsEmptyString =
    CONSTANT_UNICODE_STRING( L"" );

//
//  The following file references are used to identify system files.
//

const FILE_REFERENCE MftFileReference = { MASTER_FILE_TABLE_NUMBER, 0, MASTER_FILE_TABLE_NUMBER };
const FILE_REFERENCE Mft2FileReference = { MASTER_FILE_TABLE2_NUMBER, 0, MASTER_FILE_TABLE2_NUMBER };
const FILE_REFERENCE LogFileReference = { LOG_FILE_NUMBER, 0, LOG_FILE_NUMBER };
const FILE_REFERENCE VolumeFileReference = { VOLUME_DASD_NUMBER, 0, VOLUME_DASD_NUMBER };
const FILE_REFERENCE AttrDefFileReference = { ATTRIBUTE_DEF_TABLE_NUMBER, 0, ATTRIBUTE_DEF_TABLE_NUMBER };
const FILE_REFERENCE RootIndexFileReference = { ROOT_FILE_NAME_INDEX_NUMBER, 0, ROOT_FILE_NAME_INDEX_NUMBER };
const FILE_REFERENCE BitmapFileReference = { BIT_MAP_FILE_NUMBER, 0, BIT_MAP_FILE_NUMBER };
const FILE_REFERENCE BootFileReference = { BOOT_FILE_NUMBER, 0, BOOT_FILE_NUMBER };
const FILE_REFERENCE ExtendFileReference = { EXTEND_NUMBER, 0, EXTEND_NUMBER };
const FILE_REFERENCE FirstUserFileReference = { FIRST_USER_FILE_NUMBER, 0, 0 };

//
//  The following are used to determine what level of protection to attach
//  to system files and attributes.
//

BOOLEAN NtfsProtectSystemFiles = TRUE;
BOOLEAN NtfsProtectSystemAttributes = TRUE;

//
//  The following is used to indicate the multiplier value for the Mft zone.
//

ULONG NtfsMftZoneMultiplier;

//
//  Debug code for finding corruption.
//

#if (DBG || defined( NTFS_FREE_ASSERTS ))
BOOLEAN NtfsBreakOnCorrupt = TRUE;
#else
BOOLEAN NtfsBreakOnCorrupt = FALSE;
#endif

//#endif

//
//  Enable compression on the wire.
//

BOOLEAN NtfsEnableCompressedIO = FALSE;

//
//  FsRtl fast I/O call backs
//

FAST_IO_DISPATCH NtfsFastIoDispatch;

#ifdef BRIANDBG
ULONG NtfsIgnoreReserved = FALSE;
#endif

#ifdef NTFS_LOG_FULL_TEST
LONG NtfsFailCheck = 0;
LONG NtfsFailFrequency = 0;
LONG NtfsPeriodicFail = 0;
#endif

#ifdef NTFSDBG

LONG NtfsDebugTraceLevel = DEBUG_TRACE_ERROR;
LONG NtfsDebugTraceIndent = 0;

ULONG NtfsFsdEntryCount = 0;
ULONG NtfsFspEntryCount = 0;
ULONG NtfsIoCallDriverCount = 0;
LONG NtfsReturnStatusFilter = 0xf0ffffffL; // just an non-existent error code

#endif // NTFSDBG

//
//  Default restart version.
//

#ifdef _WIN64
ULONG NtfsDefaultRestartVersion = 1;
#else
ULONG NtfsDefaultRestartVersion = 0;
#endif

//
//  Performance statistics
//

ULONG NtfsMaxDelayedCloseCount;
ULONG NtfsMinDelayedCloseCount;
ULONG NtfsThrottleCreates;
ULONG NtfsFailedHandedOffPagingFileOps = 0;
ULONG NtfsFailedPagingFileOps = 0;
ULONG NtfsFailedAborts = 0;
ULONG NtfsFailedLfsRestart = 0;

ULONG NtfsCleanCheckpoints = 0;
ULONG NtfsPostRequests = 0;

const UCHAR BaadSignature[4] = {'B', 'A', 'A', 'D'};
const UCHAR IndexSignature[4] = {'I', 'N', 'D', 'X'};
const UCHAR FileSignature[4] = {'F', 'I', 'L', 'E'};
const UCHAR HoleSignature[4] = {'H', 'O', 'L', 'E'};
const UCHAR ChkdskSignature[4] = {'C', 'H', 'K', 'D'};

//
//  Large Reserved Buffer Context
//

ULONG NtfsReservedInUse = 0;
PVOID NtfsReserved1 = NULL;
PVOID NtfsReserved2 = NULL;
ULONG NtfsReserved2Count = 0;
PVOID NtfsReserved3 = NULL;
PVOID NtfsReserved1Thread = NULL;
PVOID NtfsReserved2Thread = NULL;
PVOID NtfsReserved3Thread = NULL;
PFCB NtfsReserved12Fcb = NULL;
PFCB NtfsReserved3Fcb = NULL;
PVOID NtfsReservedBufferThread = NULL;
BOOLEAN NtfsBufferAllocationFailure = FALSE;
FAST_MUTEX NtfsReservedBufferMutex;
ERESOURCE NtfsReservedBufferResource;
LARGE_INTEGER NtfsShortDelay = {(ULONG)-100000, -1};    // 10 milliseconds

FAST_MUTEX NtfsScavengerLock;
PIRP_CONTEXT NtfsScavengerWorkList;
BOOLEAN NtfsScavengerRunning;
ULONGLONG NtfsMaxQuotaNotifyRate = MIN_QUOTA_NOTIFY_TIME;
ULONG NtfsAsyncPostThreshold;

UCHAR NtfsZeroExtendedInfo[48];

typedef struct _VOLUME_ERROR_PACKET {
    NTSTATUS Status;
    UNICODE_STRING FileName;
    PKTHREAD Thread;
} VOLUME_ERROR_PACKET, *PVOLUME_ERROR_PACKET;

#ifdef NTFS_RWC_DEBUG
//
//  Range to include in COW checks.
//

LONGLONG NtfsRWCLowThreshold = 0;
LONGLONG NtfsRWCHighThreshold = 0x7fffffffffffffff;
#endif

VOID
NtfsResolveVolumeAndRaiseErrorSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    );

NTSTATUS
NtfsFsdDispatchSwitch (
    IN PIRP_CONTEXT StackIrpContext OPTIONAL,
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

//
//  Locals used to track specific failures.
//

BOOLEAN NtfsTestStatus = FALSE;
BOOLEAN NtfsTestFilter = FALSE;
NTSTATUS NtfsTestStatusCode = STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsFastIoCheckIfPossible)
#pragma alloc_text(PAGE, NtfsFastQueryBasicInfo)
#pragma alloc_text(PAGE, NtfsFastQueryStdInfo)
#pragma alloc_text(PAGE, NtfsFastQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, NtfsFastIoQueryCompressionInfo)
#pragma alloc_text(PAGE, NtfsFastIoQueryCompressedSize)
#pragma alloc_text(PAGE, NtfsFsdDispatch)
#pragma alloc_text(PAGE, NtfsFsdDispatchWait)
#pragma alloc_text(PAGE, NtfsFsdDispatchSwitch)
#pragma alloc_text(PAGE, NtfsResolveVolumeAndRaiseErrorSpecial)
#endif

//
//  Internal support routines
//

LONG
NtfsProcessExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    )
{
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( ExceptionPointer->ExceptionRecord->ExceptionCode != STATUS_LOG_FILE_FULL );

#ifndef LFS_CLUSTER_CHECK
    ASSERT( NT_SUCCESS( ExceptionPointer->ExceptionRecord->ExceptionCode ));
#endif

    return EXCEPTION_EXECUTE_HANDLER;
}

ULONG
NtfsRaiseStatusFunction (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is only required by the NtfsDecodeFileObject macro.  It is
    a function wrapper around NtfsRaiseStatus.

Arguments:

    Status - Status to raise

Return Value:

    0 - but no one will see it!

--*/

{
    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    return 0;
}



VOID
NtfsRaiseStatus (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    )

{
    //
    //  If the caller is declaring corruption, then let's mark the
    //  the volume corrupt appropriately, and maybe generate a popup.
    //

    if ((Status == STATUS_DISK_CORRUPT_ERROR) ||
        (Status == STATUS_FILE_CORRUPT_ERROR) ||
        (Status == STATUS_EA_CORRUPT_ERROR)) {


        if ((IrpContext->Vcb != NULL) &&
            (IRP_MJ_FILE_SYSTEM_CONTROL == IrpContext->MajorFunction) &&
            (IRP_MN_MOUNT_VOLUME == IrpContext->MinorFunction) &&
            FlagOn( IrpContext->Vcb->Vpb->RealDevice->Flags, DO_SYSTEM_BOOT_PARTITION ) &&
            !FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

            NtfsBugCheck( (ULONG_PTR)IrpContext, (ULONG_PTR)Status, 0 );
        }

        NtfsPostVcbIsCorrupt( IrpContext, Status, FileReference, Fcb );
    }

    //
    //  Set a flag to indicate that we raised this status code and store
    //  it in the IrpContext.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS );

    if (NT_SUCCESS( IrpContext->ExceptionStatus )) {

        //
        //  If this is a paging io request and we got a Quota Exceeded error
        //  then translate the status to FILE_LOCK_CONFLICT so that this
        //  is a retryable condition in the write path.
        //

        if ((Status == STATUS_QUOTA_EXCEEDED) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (IrpContext->OriginatingIrp != NULL) &&
            (FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ))) {

            Status = STATUS_FILE_LOCK_CONFLICT;
        }

        IrpContext->ExceptionStatus = Status;
    }

    //
    //  Now finally raise the status, and make sure we do not come back.
    //

    ExRaiseStatus( IrpContext->ExceptionStatus );
}


LONG
NtfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It inserts the status
    into the IrpContext and either indicates that we should handle
    the exception or bug check the system.

Arguments:

    ExceptionPointer - Supplies the exception record to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );

    DebugTrace( 0, DEBUG_TRACE_UNWIND, ("NtfsExceptionFilter %X\n", ExceptionCode) );

    //
    //  Check if this status is the status we are watching for.
    //

    if (NtfsTestFilter && (NtfsTestStatusCode == ExceptionCode)) {

        NtfsTestStatusProc();
    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    //
    //  We should not raise insufficient resources during paging file reads
    //

    if (ARGUMENT_PRESENT( IrpContext ) && (IrpContext->OriginatingIrp != NULL)) {

        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );
        PSCB Scb = NULL;

        if (IrpSp->FileObject != NULL) {
            Scb = (PSCB)IrpSp->FileObject->FsContext;
        }

        ASSERT( (IrpContext->MajorFunction != IRP_MJ_READ) ||
                (ExceptionCode != STATUS_INSUFFICIENT_RESOURCES) ||
                (Scb == NULL) ||
                (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) );
    }
#endif

    //
    //  If the exception is an in page error, then get the real I/O error code
    //  from the exception record
    //

    if ((ExceptionCode == STATUS_IN_PAGE_ERROR) &&
        (ExceptionPointer->ExceptionRecord->NumberParameters >= 3)) {

        ExceptionCode = (NTSTATUS) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];

        //
        //  If we got FILE_LOCK_CONFLICT from a paging request then change it
        //  to STATUS_CANT_WAIT.  This means that we couldn't wait for a
        //  reserved buffer or some other retryable condition.  In the write
        //  case the correct error is already in the IrpContext.  The read
        //  case doesn't pass the error back via the top-level irp context
        //  however.
        //

        if (ExceptionCode == STATUS_FILE_LOCK_CONFLICT) {

            ExceptionCode = STATUS_CANT_WAIT;
        }
    }

    //
    //  If there is not an irp context, we must have had insufficient resources
    //

    if (!ARGUMENT_PRESENT(IrpContext)) {

        //
        //  Check whether this is a fatal error and bug check if so.
        //  Typically the only error is insufficient resources but
        //  it is possible that pool has been corrupted.
        //

        if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

            NtfsBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                          (ULONG_PTR)ExceptionPointer->ContextRecord,
                          (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

        return EXCEPTION_EXECUTE_HANDLER;
    }

    //
    //  For now break if we catch corruption errors on both free and checked
    //  TODO:  Remove this before we ship
    //

    if (NtfsBreakOnCorrupt &&
        ((ExceptionCode == STATUS_FILE_CORRUPT_ERROR) ||
         (ExceptionCode == STATUS_DISK_CORRUPT_ERROR))) {

        if (*KdDebuggerEnabled) {
            DbgPrint("*******************************************\n");
            DbgPrint("NTFS detected corruption on your volume\n");
            DbgPrint("IrpContext=0x%08x, VCB=0x%08x\n",IrpContext,IrpContext->Vcb);
            DbgPrint("Send email to NTFSDEV\n");
            DbgPrint("*******************************************\n");
            DbgBreakPoint();

            while (NtfsPageInAddress) {

                volatile CHAR test;

                if (NtfsMapOffset != -1) {

                    PBCB Bcb;
                    PVOID Buffer;

                    CcMapData( IrpContext->Vcb->LogFileObject, (PLARGE_INTEGER)&NtfsMapOffset, PAGE_SIZE, TRUE, &Bcb, &Buffer );
                }

                test = *NtfsPageInAddress;
                DbgBreakPoint();
            }

        }
    }

/*
#if (DBG || defined( NTFS_FREE_ASSERTS ) || NTFS_RESTART)
    ASSERT( !NtfsBreakOnCorrupt ||
            ((ExceptionCode != STATUS_FILE_CORRUPT_ERROR) &&
             (ExceptionCode != STATUS_DISK_CORRUPT_ERROR) ));
#endif
*/

    //
    //  When processing any exceptions we always can wait.  Remember the
    //  current state of the wait flag so we can restore while processing
    //  the exception.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
    }

    SetFlag(IrpContext->State, IRP_CONTEXT_STATE_WAIT);

    //
    //  If someone got STATUS_LOG_FILE_FULL or STATUS_CANT_WAIT, let's
    //  handle that.  Note any other error that also happens will
    //  probably not go away and will just reoccur.  If it does go
    //  away, that's ok too.
    //

    if (IrpContext->TopLevelIrpContext == IrpContext) {

        if ((IrpContext->ExceptionStatus == STATUS_LOG_FILE_FULL) ||
            (IrpContext->ExceptionStatus == STATUS_CANT_WAIT)) {

            ExceptionCode = IrpContext->ExceptionStatus;
        }

    }

    //
    //  If we didn't raise this status code then we need to check if
    //  we should handle this exception.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS )) {

        if (FsRtlIsNtstatusExpected( ExceptionCode )) {

            //
            //  If we got an allocation failure doing paging Io then convert
            //  this to FILE_LOCK_CONFLICT.
            //

            if ((ExceptionCode == STATUS_QUOTA_EXCEEDED) &&
                (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                (IrpContext->OriginatingIrp != NULL) &&
                (FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ))) {

                ExceptionCode = STATUS_FILE_LOCK_CONFLICT;
            }

            IrpContext->ExceptionStatus = ExceptionCode;

        } else {

            NtfsBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                          (ULONG_PTR)ExceptionPointer->ContextRecord,
                          (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

    } else {

        //
        //  We raised this code explicitly ourselves, so it had better be
        //  expected.
        //

        ASSERT( ExceptionCode == IrpContext->ExceptionStatus );
        ASSERT( FsRtlIsNtstatusExpected( ExceptionCode ) );
    }

#ifdef LFS_CLUSTER_CHECK
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH ) ||
            ((IrpContext->ExceptionStatus != STATUS_NO_SUCH_DEVICE) &&
             (IrpContext->ExceptionStatus != STATUS_DEVICE_BUSY) &&
             (IrpContext->ExceptionStatus != STATUS_DEVICE_OFF_LINE) ));
#endif

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS );

    //
    //  If the exception code is log file full, then remember the current
    //  RestartAreaLsn in the Vcb, so we can see if we are the ones to flush
    //  the log file later.  Note, this does not have to be synchronized,
    //  because we are just using it to arbitrate who must do the flush, but
    //  eventually someone will anyway.
    //

    if (ExceptionCode == STATUS_LOG_FILE_FULL) {

        IrpContext->TopLevelIrpContext->LastRestartArea = IrpContext->Vcb->LastRestartArea;
        IrpContext->Vcb->LogFileFullCount += 1;
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
NtfsProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine process an exception.  It either completes the request
    with the saved exception status or it sends the request off to the Fsp

Arguments:

    Irp - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PVCB Vcb;
    PIRP_CONTEXT PostIrpContext = NULL;
    BOOLEAN Retry = FALSE;
    PUSN_FCB ThisUsn, LastUsn;
    BOOLEAN ReleaseBitmap = FALSE;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_OPTIONAL_IRP( Irp );

    DebugTrace( 0, Dbg, ("NtfsProcessException\n") );

    //
    //  If there is not an irp context, we must have had insufficient resources
    //

    if (IrpContext == NULL) {

        NtfsCompleteRequest( NULL, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Get the real exception status from the Irp Context.
    //

    ExceptionCode = IrpContext->ExceptionStatus;

    //
    //  All errors which could possibly have started a transaction must go
    //  through here.  Abort the transaction.
    //

    //
    //  Increment the appropriate performance counters.
    //

    Vcb = IrpContext->Vcb;
    CollectExceptionStats( Vcb, ExceptionCode );

    try {

        //
        //  If this is an Mdl write request, then take care of the Mdl
        //  here so that things get cleaned up properly, and in the
        //  case of log file full we will just create a new Mdl.  By
        //  getting rid of this Mdl now, the pages will not be locked
        //  if we try to truncate the file while restoring snapshots.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (FlagOn( IrpContext->MinorFunction, IRP_MN_MDL | IRP_MN_COMPLETE ) == IRP_MN_MDL) &&
            (Irp->MdlAddress != NULL)) {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

            CcMdlWriteAbort( IrpSp->FileObject, Irp->MdlAddress );
            Irp->MdlAddress = NULL;
        }

        //
        //  On a failed mount this value will be NULL.  Don't perform the
        //  abort in that case or we will fail when looking at the Vcb
        //  in the Irp COntext.
        //

        if (Vcb != NULL) {

            //
            //  To make sure that we can access all of our streams correctly,
            //  we first restore all of the higher sizes before aborting the
            //  transaction.  Then we restore all of the lower sizes after
            //  the abort, so that all Scbs are finally restored.
            //

            NtfsRestoreScbSnapshots( IrpContext, TRUE );

            //
            //  If we modified the volume bitmap during this transaction we
            //  want to acquire it and hold it throughout the abort process.
            //  Otherwise this abort could constantly be setting the rescan
            //  bitmap flag at the same time as some interleaved transaction
            //  is performing bitmap operations and we will thrash performing
            //  bitmap scans.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP ) &&
                (IrpContext->TransactionId != 0)) {

                //
                //  Acquire the resource and remember we need to release it.
                //

                NtfsAcquireResourceExclusive( IrpContext, Vcb->BitmapScb, TRUE );

                //
                //  Restore the free cluster count in the Vcb.
                //

                Vcb->FreeClusters -= IrpContext->FreeClusterChange;

                ReleaseBitmap = TRUE;
            }

            //
            //  If we are aborting a transaction, then it is important to clear out the
            //  Usn reasons, so we do not try to write a Usn Journal record for
            //  somthing that did not happen!  Worse yet if we get a log file full
            //  we fail the abort, which is not allowed.
            //
            //  First, reset the bits in the Fcb, so we will not fail to allow posting
            //  and writing these bits later.  Note that all the reversible changes are
            //  done with the Fcb exclusive, and they are actually backed out anyway.
            //  All the nonreversible ones (only unnamed and named data overwrite) are
            //  forced out first anyway before the data is actually modified.
            //

            ThisUsn = &IrpContext->Usn;
            do {

                PFCB UsnFcb;

                if (ThisUsn->CurrentUsnFcb != NULL) {

                    UsnFcb = ThisUsn->CurrentUsnFcb;

                    NtfsLockFcb( IrpContext, UsnFcb );

                    //
                    //  We may hold nothing here (write path) so we have to retest for the usn
                    //  after locking it down in case of the deleteusnjournal worker
                    //

                    if (UsnFcb->FcbUsnRecord != NULL) {

                        //
                        //  If any rename flags are part of the new reasons then
                        //  make sure to look the name up again.
                        //

                        if (FlagOn( ThisUsn->NewReasons,
                                    USN_REASON_RENAME_NEW_NAME | USN_REASON_RENAME_OLD_NAME )) {

                            ClearFlag( UsnFcb->FcbState, FCB_STATE_VALID_USN_NAME );
                        }

                        //
                        //  Now restore the reason and source info fields.
                        //

                        ClearFlag( UsnFcb->FcbUsnRecord->UsnRecord.Reason,
                                   ThisUsn->NewReasons );
                        if (UsnFcb->FcbUsnRecord->UsnRecord.Reason == 0) {

                            UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo = 0;

                        } else {

                            SetFlag( UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo,
                                     ThisUsn->RemovedSourceInfo );
                        }
                    }

                    NtfsUnlockFcb( IrpContext, UsnFcb );

                    //
                    //  Zero out the structure.
                    //

                    ThisUsn->CurrentUsnFcb = NULL;
                    ThisUsn->NewReasons = 0;
                    ThisUsn->RemovedSourceInfo = 0;
                    ThisUsn->UsnFcbFlags = 0;

                    if (ThisUsn != &IrpContext->Usn) {

                        LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                        NtfsFreePool( ThisUsn );
                        ThisUsn = LastUsn;
                    }
                }

                if (ThisUsn->NextUsnFcb == NULL) {
                    break;
                }

                LastUsn = ThisUsn;
                ThisUsn = ThisUsn->NextUsnFcb;

            } while (TRUE);

            //
            //  Only abort the transaction if the volume is still mounted.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                NtfsAbortTransaction( IrpContext, Vcb, NULL );
            }

            if (ReleaseBitmap) {

                NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
                ReleaseBitmap = FALSE;
            }

            NtfsRestoreScbSnapshots( IrpContext, FALSE );

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );

            //
            //  It is a rare path where the user is extending a volume and has hit
            //  an exception.  In that case we need to roll back the total clusters
            //  in the Vcb.  We detect this case is possible by comparing the
            //  snapshot value for total clusters in the Vcb.
            //

            if (Vcb->TotalClusters != Vcb->PreviousTotalClusters) {

                //
                //  Someone is changing this value but is it us.
                //

                if ((Vcb->BitmapScb != NULL) &&
                    NtfsIsExclusiveScb( Vcb->BitmapScb )) {

                    Vcb->TotalClusters = Vcb->PreviousTotalClusters;
                }
            }
        }

    //
    //  Exceptions at this point are pretty bad, we failed to undo everything.
    //

    } except(NtfsProcessExceptionFilter( GetExceptionInformation() )) {

        PSCB_SNAPSHOT ScbSnapshot;
        PSCB NextScb;

        //
        //  Update counter
        //

        NtfsFailedAborts += 1;

        //
        //  If we get an exception doing this then things are in really bad
        //  shape but we still don't want to bugcheck the system so we
        //  need to protect ourselves
        //

        try {

            NtfsPostVcbIsCorrupt( IrpContext, 0, NULL, NULL );

        } except(NtfsProcessExceptionFilter( GetExceptionInformation() )) {

            NOTHING;
        }

        if (ReleaseBitmap) {

            //
            //  Since we had an unexpected failure and we know that
            //  we have modified the bitmap we need to do a complete
            //  scan to accurately know the free cluster count.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS );
            NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
            ReleaseBitmap = FALSE;
        }

        //
        //  We have taken all the steps possible to cleanup the current
        //  transaction and it has failed.  Any of the Scb's involved in
        //  this transaction could now be out of ssync with the on-disk
        //  structures.  We can't go to disk to restore this so we will
        //  clean up the in-memory structures as best we can so that the
        //  system won't crash.
        //
        //  We will go through the Scb snapshot list and knock down the
        //  sizes to the lower of the two values.  We will also truncate
        //  the Mcb to that allocation.  If this is a normal data stream
        //  we will actually empty the Mcb.
        //

        ScbSnapshot = &IrpContext->ScbSnapshot;

        //
        //  There is no snapshot data to restore if the Flink is still NULL.
        //

        if (ScbSnapshot->SnapshotLinks.Flink != NULL) {

            //
            //  Loop to retore first the Scb data from the snapshot in the
            //  IrpContext, and then 0 or more additional snapshots linked
            //  to the IrpContext.
            //

            do {

                NextScb = ScbSnapshot->Scb;

                if (NextScb == NULL) {

                    ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;
                    continue;
                }

                //
                //  Unload all information from memory and force future references to resynch to disk
                //  for all regular files. For system files / paging files truncate all sizes
                //  and unload based on the snapshot
                //

                if (!FlagOn( NextScb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE | FCB_STATE_PAGING_FILE )) {

                    ClearFlag( NextScb->ScbState, SCB_STATE_HEADER_INITIALIZED | SCB_STATE_FILE_SIZE_LOADED );
                    NextScb->Header.AllocationSize.QuadPart =
                    NextScb->Header.FileSize.QuadPart =
                    NextScb->Header.ValidDataLength.QuadPart = 0;

                    //
                    //  Remove all of the mappings in the Mcb.
                    //

                    NtfsUnloadNtfsMcbRange( &NextScb->Mcb, (LONGLONG)0, MAXLONGLONG, FALSE, FALSE );

                    //
                    //  If there is any caching tear it down so that we reinit it with values off disk
                    //

                    if (NextScb->FileObject) {
                        NtfsDeleteInternalAttributeStream( NextScb, TRUE, FALSE );
                    }

                } else {

                    //
                    //  Go through each of the sizes and use the lower value for system files.
                    //

                    if (ScbSnapshot->AllocationSize < NextScb->Header.AllocationSize.QuadPart) {

                        NextScb->Header.AllocationSize.QuadPart = ScbSnapshot->AllocationSize;
                    }

                    if (ScbSnapshot->FileSize < NextScb->Header.FileSize.QuadPart) {

                        NextScb->Header.FileSize.QuadPart = ScbSnapshot->FileSize;
                    }

                    if (ScbSnapshot->ValidDataLength < NextScb->Header.ValidDataLength.QuadPart) {

                        NextScb->Header.ValidDataLength.QuadPart = ScbSnapshot->ValidDataLength;
                    }

                    NtfsUnloadNtfsMcbRange( &NextScb->Mcb,
                                            Int64ShraMod32(NextScb->Header.AllocationSize.QuadPart, NextScb->Vcb->ClusterShift),
                                            MAXLONGLONG,
                                            TRUE,
                                            FALSE );

                    //
                    //  For the mft set the record allocation context size so that it
                    //  will be reininitialized the next time its used
                    //

                    if (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

                        NextScb->ScbType.Mft.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
                    }
                }

                //
                //  Update the FastIoField.
                //

                NtfsAcquireFsrtlHeader( NextScb );
                NextScb->Header.IsFastIoPossible = FastIoIsNotPossible;
                NtfsReleaseFsrtlHeader( NextScb );

                ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

            } while (ScbSnapshot != &IrpContext->ScbSnapshot);
        }

        //
        //  It is a rare path where the user is extending a volume and has hit
        //  an exception.  In that case we need to roll back the total clusters
        //  in the Vcb.  We detect this case is possible by comparing the
        //  snapshot value for total clusters in the Vcb.
        //

        if ((Vcb != NULL) && (Vcb->TotalClusters != Vcb->PreviousTotalClusters)) {

            //
            //  Someone is changing this value but is it us.
            //

            if ((Vcb->BitmapScb != NULL) &&
                NtfsIsExclusiveScb( Vcb->BitmapScb )) {

                Vcb->TotalClusters = Vcb->PreviousTotalClusters;
            }
        }

        //ASSERTMSG( "***Failed to abort transaction, volume is corrupt", FALSE );

        //
        //  Clear the transaction Id in the IrpContext to make sure we don't
        //  try to write any log records in the complete request.
        //

        IrpContext->TransactionId = 0;
    }

    //
    //  If this isn't the top-level request then make sure to pass the real
    //  error back to the top level.
    //

    if (IrpContext != IrpContext->TopLevelIrpContext) {

        //
        //  Make sure this error is returned to the top level guy.
        //  If the status is FILE_LOCK_CONFLICT then we are using this
        //  value to stop some lower level request.  Convert it to
        //  STATUS_CANT_WAIT so the top-level request will retry.
        //

        if (NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus )) {

            if (ExceptionCode == STATUS_FILE_LOCK_CONFLICT) {

                IrpContext->TopLevelIrpContext->ExceptionStatus = STATUS_CANT_WAIT;

            } else {

                IrpContext->TopLevelIrpContext->ExceptionStatus = ExceptionCode;
            }
        }
    }

    //
    //  We want to look at the LOG_FILE_FULL or CANT_WAIT cases and consider
    //  if we want to post the request.  We only post requests at the top
    //  level.
    //

    if (ExceptionCode == STATUS_LOG_FILE_FULL ||
        ExceptionCode == STATUS_CANT_WAIT) {

        //
        //  If we are top level, we will either post it or retry.  Also, make
        //  sure we always take this path for close, because we should never delete
        //  his IrpContext.
        //

        if (NtfsIsTopLevelRequest( IrpContext ) || (IrpContext->MajorFunction == IRP_MJ_CLOSE)) {

            //
            //  See if we are supposed to post the request.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST )) {

                PostIrpContext = IrpContext;

            //
            //  Otherwise we will retry this request in the original thread.
            //

            } else {

                Retry = TRUE;
            }

        //
        //  Otherwise we will complete the request, see if there is any
        //  related processing to do.
        //

        } else {

            //
            //  We are the top level Ntfs call.  If we are processing a
            //  LOG_FILE_FULL condition then there may be no one above us
            //  who can do the checkpoint.  Go ahead and fire off a dummy
            //  request.  Do an unsafe test on the flag since it won't hurt
            //  to generate an occasional additional request.
            //

            if ((ExceptionCode == STATUS_LOG_FILE_FULL) &&
                (IrpContext->TopLevelIrpContext == IrpContext) &&
                !FlagOn( Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED )) {

                //
                //  Create a dummy IrpContext but protect this request with
                //  a try-except to catch any allocation failures.
                //

                if ((ExceptionCode == STATUS_LOG_FILE_FULL) &&
                    (IrpContext->TopLevelIrpContext == IrpContext)) {

                    //
                    //  If this is the lazy writer then we will just set a flag
                    //  in the top level field to signal ourselves to perform
                    //  the clean checkpoint when the cache manager releases
                    //  the Scb.
                    //

                    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE ) &&
                        (NtfsGetTopLevelContext()->SavedTopLevelIrp == (PIRP) FSRTL_CACHE_TOP_LEVEL_IRP)) {

                        SetFlag( (ULONG_PTR) NtfsGetTopLevelContext()->SavedTopLevelIrp, 0x80000000 );

                    } else if (!FlagOn( Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED )) {

                        //
                        //  Create a dummy IrpContext but protect this request with
                        //  a try-except to catch any allocation failures.
                        //

                        try {

                            PostIrpContext = NULL;
                            NtfsInitializeIrpContext( NULL, TRUE, &PostIrpContext );
                            PostIrpContext->Vcb = Vcb;
                            PostIrpContext->LastRestartArea = PostIrpContext->Vcb->LastRestartArea;

                            NtfsAcquireCheckpoint( IrpContext, Vcb );
                            SetFlag( Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED );
                            NtfsReleaseCheckpoint( IrpContext, Vcb );

                        } except( EXCEPTION_EXECUTE_HANDLER ) {

                            NOTHING;
                        }
                    }
                }
            }

            //
            //  If this is a paging write and we are not the top level
            //  request then we need to return STATUS_FILE_LOCk_CONFLICT
            //  to make MM happy (and keep the pages dirty) and to
            //  prevent this request from retrying the request.
            //

            ExceptionCode = STATUS_FILE_LOCK_CONFLICT;
        }
    }

    if (PostIrpContext) {

        NTSTATUS PostStatus;

        //
        //  Clear the current error code.
        //

        PostIrpContext->ExceptionStatus = 0;

        //
        //  We need a try-except in case the Lock buffer call fails.
        //

        try {

            PostStatus = NtfsPostRequest( PostIrpContext, PostIrpContext->OriginatingIrp );

            //
            //  If we posted the original request we don't have any
            //  completion work to do.
            //

            if (PostIrpContext == IrpContext) {

                Irp = NULL;
                IrpContext = NULL;
                ExceptionCode = PostStatus;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            //  If we don't have an error in the IrpContext then
            //  generate a generic IO error.  We can't use the
            //  original status code if either LOG_FILE_FULL or
            //  CANT_WAIT.  We would complete the Irp yet retry the
            //  request.
            //

            if (IrpContext == PostIrpContext) {

                if (PostIrpContext->ExceptionStatus == 0) {

                    if ((ExceptionCode == STATUS_LOG_FILE_FULL) ||
                        (ExceptionCode == STATUS_CANT_WAIT)) {

                        ExceptionCode = STATUS_UNEXPECTED_IO_ERROR;
                    }

                } else {

                    ExceptionCode = PostIrpContext->ExceptionStatus;
                }
            }
        }
    }

    //
    //  If this is a top level Ntfs request and we still have the Irp
    //  it means we will be retrying the request.  In that case
    //  mark the Irp Context so it doesn't go away.
    //

    if (Retry) {

        //
        //  Cleanup but don't delete the IrpContext.  Don't delete the Irp.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
        Irp = NULL;

        //
        //  Clear the status code in the IrpContext, because we'll be retrying.
        //

        IrpContext->ExceptionStatus = 0;

    //
    //  If this is a create then sometimes we want to complete the Irp.  Otherwise
    //  save the Irp.  Save the Irp by clearing it here.
    //

    } else if ((IrpContext != NULL) &&
               !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) &&
               FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE )) {

        Irp = NULL;
    }

    NtfsCompleteRequest( IrpContext, Irp, ExceptionCode );
    return ExceptionCode;
}


VOID
NtfsCompleteRequest (
    IN OUT PIRP_CONTEXT IrpContext OPTIONAL,
    IN OUT PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine completes an IRP and deallocates the IrpContext

Arguments:

    IrpContext - Supplies the IrpContext being completed

    Irp - Supplies the Irp being processed

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    //
    //  If we have an Irp Context then unpin all of the repinned bcbs
    //  we might have collected, and delete the Irp context.  Delete Irp
    //  Context will zero out our pointer for us.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        ASSERT_IRP_CONTEXT( IrpContext );

        //
        //  If we have posted any Usn journal changes, then they better be written,
        //  because commit is not supposed to fail for log file full.
        //

        ASSERT( (IrpContext->Usn.NewReasons == 0) &&
                (IrpContext->Usn.RemovedSourceInfo == 0) );

        if (IrpContext->TransactionId != 0) {
            NtfsCommitCurrentTransaction( IrpContext );
        }

        //
        //  Always store the status in the top level Irp Context unless
        //  there is already an error code.
        //

        if ((IrpContext != IrpContext->TopLevelIrpContext) &&
            NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus )) {

            IrpContext->TopLevelIrpContext->ExceptionStatus = Status;
        }

        NtfsCleanupIrpContext( IrpContext, TRUE );
    }

    //
    //  If we have an Irp then complete the irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
        PSCB Scb = NULL;

        if (IrpSp->FileObject) {
            Scb = (PSCB) IrpSp->FileObject->FsContext;
        }

        ASSERT_IRP( Irp );

        if (NT_ERROR( Status ) &&
            FlagOn( Irp->Flags, IRP_INPUT_OPERATION )) {

            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;

#ifdef NTFS_RWC_DEBUG
        ASSERT( (Status != STATUS_FILE_LOCK_CONFLICT) ||
                (IrpSp->MajorFunction != IRP_MJ_READ) ||
                !FlagOn( Irp->Flags, IRP_PAGING_IO ));
#endif

        //
        //  Update counter for any failed paging file reads or writes
        //

        if (((IrpSp->MajorFunction == IRP_MJ_READ) ||
             (IrpSp->MajorFunction == IRP_MJ_WRITE)) &&

            (Status == STATUS_INSUFFICIENT_RESOURCES) &&

            (Scb != NULL) &&

            FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

            NtfsFailedPagingFileOps++;
        }

        ASSERT( (IrpSp->MajorFunction != IRP_MJ_READ) ||
                (Status != STATUS_INSUFFICIENT_RESOURCES) ||
                (Scb == NULL) ||
                (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) );

        //
        //  We should never return STATUS_CANT_WAIT on a create.
        //

        ASSERT( (Status != STATUS_CANT_WAIT ) ||
                (IrpSp->MajorFunction != IRP_MJ_CREATE) );

#ifdef LFS_CLUSTER_CHECK

      ASSERT( (IrpSp->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
              (IrpSp->MinorFunction != IRP_MN_USER_FS_REQUEST) ||
              (IrpSp->Parameters.FileSystemControl.FsControlCode != FSCTL_DISMOUNT_VOLUME) ||
              ((Status != STATUS_NO_SUCH_DEVICE) &&
               (Status != STATUS_DEVICE_BUSY) &&
               (Status != STATUS_DEVICE_OFF_LINE)) );
#endif
        //
        //  Check if this status is the status we are watching for.
        //

        if (NtfsTestStatus && (NtfsTestStatusCode == Status)) {

            NtfsTestStatusProc();
        }

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
    }

    return;
}


BOOLEAN
NtfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route

--*/

{
    PSCB Scb;
    PFCB Fcb;

    LARGE_INTEGER LargeLength;
    ULONG Extend, Overwrite;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( IoStatus );
    UNREFERENCED_PARAMETER( Wait );

    PAGED_CODE();

#ifdef NTFS_NO_FASTIO

    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( CheckForReadOperation );

    return FALSE;

#endif

    //
    //  Decode the file object to get our fcb, the only one we want
    //  to deal with is a UserFileOpen
    //

#ifdef  COMPRESS_ON_WIRE
    if (((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) ||
        ((Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) && (Scb->Header.FileObjectC == NULL))) {

        return FALSE;
    }
#else
    if ((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) {

        return FALSE;
    }
#endif

    LargeLength = RtlConvertUlongToLargeInteger( Length );

    //
    //  Based on whether this is a read or write operation we call
    //  fsrtl check for read/write
    //

    if (CheckForReadOperation) {

        if (Scb->ScbType.Data.FileLock == NULL
            || FsRtlFastCheckLockForRead( Scb->ScbType.Data.FileLock,
                                          FileOffset,
                                          &LargeLength,
                                          LockKey,
                                          FileObject,
                                          PsGetCurrentProcess() )) {

            return TRUE;
        }

    } else {

        ULONG Reason = 0;

        Overwrite = (FileOffset->QuadPart < Scb->Header.FileSize.QuadPart);
        Extend = ((FileOffset->QuadPart + Length) > Scb->Header.FileSize.QuadPart);

        if (Scb->ScbType.Data.FileLock == NULL
             || FsRtlFastCheckLockForWrite( Scb->ScbType.Data.FileLock,
                                            FileOffset,
                                            &LargeLength,
                                            LockKey,
                                            FileObject,
                                            PsGetCurrentProcess() )) {

            //
            //  Make sure we don't have to post a Usn change.
            //

            Fcb = Scb->Fcb;
            NtfsLockFcb( NULL, Fcb );
            if (Fcb->FcbUsnRecord != NULL) {
                Reason = Fcb->FcbUsnRecord->UsnRecord.Reason;
            }
            NtfsUnlockFcb( NULL, Fcb );

            if (((Scb->AttributeName.Length != 0) ?
                ((!Overwrite || FlagOn(Reason, USN_REASON_NAMED_DATA_OVERWRITE)) &&
                 (!Extend || FlagOn(Reason, USN_REASON_NAMED_DATA_EXTEND))) :
                ((!Overwrite || FlagOn(Reason, USN_REASON_DATA_OVERWRITE)) &&
                 (!Extend || FlagOn(Reason, USN_REASON_DATA_EXTEND))))

              &&

              //
              //  If the file is compressed, reserve clusters for it.
              //

              ((Scb->CompressionUnit == 0) ||
               NtfsReserveClusters( NULL, Scb, FileOffset->QuadPart, Length))) {

                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOLEAN
NtfsFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN _ TRUE if the operation is successful and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    if (Wait) {
        SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    } else {
        ClearFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    }

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    FsRtlEnterFileSystem();

    try {

        switch (TypeOfOpen) {

        case UserFileOpen:
        case UserDirectoryOpen:
        case StreamFileOpen:

            if (ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

                FcbAcquired = TRUE;

                if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                    FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    leave;
                }

            } else {

                leave;
            }

            NtfsFillBasicInfo( Buffer, Scb );
            Results = TRUE;

            IoStatus->Information = sizeof(FILE_BASIC_INFORMATION);

            IoStatus->Status = STATUS_SUCCESS;

            break;

        default:

            NOTHING;
        }

    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  Return to our caller
    //

    return Results;
    UNREFERENCED_PARAMETER( DeviceObject );
}


BOOLEAN
NtfsFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN _ TRUE if the operation is successful and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN FsRtlHeaderLocked = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    if (Wait) {
        SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    } else {
        ClearFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    }

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    FsRtlEnterFileSystem();

    try {

        switch (TypeOfOpen) {

        case UserFileOpen:
        case UserDirectoryOpen:
        case StreamFileOpen:

            if (Scb->Header.PagingIoResource != NULL) {
                ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );
            }

            FsRtlLockFsRtlHeader( &Scb->Header );
            FsRtlHeaderLocked = TRUE;

            if (ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

                FcbAcquired = TRUE;

                if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                    FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    leave;
                }

            } else {

                leave;
            }

            //
            //  Fill in the standard information fields.  If the
            //  Scb is not initialized then take the long route
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED) &&
                (Scb->AttributeTypeCode != $INDEX_ALLOCATION)) {

                NOTHING;

            } else {

                NtfsFillStandardInfo( Buffer, Scb, Ccb );

                IoStatus->Information = sizeof(FILE_STANDARD_INFORMATION);

                IoStatus->Status = STATUS_SUCCESS;

                Results = TRUE;
            }

            break;

        default:

            NOTHING;
        }

    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Resource ); }

        if (FsRtlHeaderLocked) {
            FsRtlUnlockFsRtlHeader( &Scb->Header );
            if (Scb->Header.PagingIoResource != NULL) {
                ExReleaseResourceLite( Scb->Header.PagingIoResource );
            }
        }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
    UNREFERENCED_PARAMETER( DeviceObject );
}


BOOLEAN
NtfsFastQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query network open call.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN _ TRUE if the operation is successful and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    if (Wait) {
        SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    } else {
        ClearFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    }

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    FsRtlEnterFileSystem();

    try {

        switch (TypeOfOpen) {

        case UserFileOpen:
        case UserDirectoryOpen:
        case StreamFileOpen:

            if (ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

                FcbAcquired = TRUE;

                if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                    FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) ||
                    (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED) &&
                     (Scb->AttributeTypeCode != $INDEX_ALLOCATION))) {

                    leave;
                }

            } else {

                leave;
            }

            NtfsFillNetworkOpenInfo( Buffer, Scb );
            IoStatus->Information = sizeof(FILE_NETWORK_OPEN_INFORMATION);

            IoStatus->Status = STATUS_SUCCESS;

            Results = TRUE;

            break;

        default:

            NOTHING;
        }

    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
    UNREFERENCED_PARAMETER( DeviceObject );
}


VOID
NtfsFastIoQueryCompressionInfo (
    IN PFILE_OBJECT FileObject,
    OUT PFILE_COMPRESSION_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine is a fast call for returning the comprssion information
    for a file.  It assumes that the caller has an exception handler and
    will treat exceptions as an error.  Therefore, this routine only uses
    a finally clause to cleanup any resources, and it does not worry about
    returning errors in the IoStatus.

Arguments:

    FileObject - FileObject for the file on which the compressed information
        is desired.

    Buffer - Buffer to receive the compressed data information (as defined
        in ntioapi.h)

    IoStatus - Returns STATUS_SUCCESS and the size of the information being
        returned.

Return Value:

    None.

--*/

{
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN ScbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);

    //
    //  Assume success (otherwise caller should see the exception)
    //

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = sizeof(FILE_COMPRESSION_INFORMATION);

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE);

    if (TypeOfOpen == UnopenedFileObject) {

        ExRaiseStatus( STATUS_INVALID_PARAMETER );
    }

    FsRtlEnterFileSystem();

    try {

        NtfsAcquireSharedScb( &IrpContext, Scb );
        ScbAcquired = TRUE;

        //
        //  Now return the compressed data information.
        //

        Buffer->CompressedFileSize.QuadPart = Scb->TotalAllocated;
        Buffer->CompressionFormat = (USHORT)(Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);
        if (Buffer->CompressionFormat != 0) {
            Buffer->CompressionFormat += 1;
        }
        Buffer->CompressionUnitShift = (UCHAR)(Scb->CompressionUnitShift + Vcb->ClusterShift);
        Buffer->ChunkShift = NTFS_CHUNK_SHIFT;
        Buffer->ClusterShift = (UCHAR)Vcb->ClusterShift;
        Buffer->Reserved[0] = Buffer->Reserved[1] = Buffer->Reserved[2] = 0;

    } finally {

        if (ScbAcquired) {NtfsReleaseScb( &IrpContext, Scb );}
        FsRtlExitFileSystem();
    }
}


VOID
NtfsFastIoQueryCompressedSize (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    OUT PULONG CompressedSize
    )

/*++

Routine Description:

    This routine is a fast call for returning the the size of a specified
    compression unit.  It assumes that the caller has an exception handler and
    will treat exceptions as an error.  Therefore, this routine does not even
    have a finally clause, since it does not acquire any resources directly.

Arguments:

    FileObject - FileObject for the file on which the compressed information
        is desired.

    FileOffset - FileOffset for a compression unit for which the allocated size
        is desired.

    CompressedSize - Returns the allocated size of the compression unit.

Return Value:

    None.

--*/

{
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    VCN Vcn;
    LCN Lcn;
    LONGLONG SizeInBytes;
    LONGLONG ClusterCount = 0;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE);

    IrpContext.Vcb = Vcb;

    ASSERT(Scb->CompressionUnit != 0);
    ASSERT((FileOffset->QuadPart & (Scb->CompressionUnit - 1)) == 0);

    //
    //  Calculate the Vcn the caller wants, and initialize our output.
    //

    Vcn = LlClustersFromBytes( Vcb, FileOffset->QuadPart );
    *CompressedSize = 0;

    //
    //  Loop as long as we are looking up allocated Vcns.
    //

    while (NtfsLookupAllocation(&IrpContext, Scb, Vcn, &Lcn, &ClusterCount, NULL, NULL)) {

        SizeInBytes = LlBytesFromClusters( Vcb, ClusterCount );

        //
        //  If this allocated run goes beyond the end of the compresion unit, then
        //  we know it is fully allocated.
        //

        if ((SizeInBytes + *CompressedSize) > Scb->CompressionUnit) {
            *CompressedSize = Scb->CompressionUnit;
            break;
        }

        *CompressedSize += (ULONG)SizeInBytes;
        Vcn += ClusterCount;
    }
}


VOID
NtfsRaiseInformationHardError (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    )

/*++

Routine Description:

    This routine is used to generate a popup in the event a corrupt file
    or disk is encountered.  The main purpose of the routine is to find
    a name to pass to the popup package.  If there is no Fcb we will take
    the volume name out of the Vcb.  If the Fcb has an Lcb in its Lcb list,
    we will construct the name by walking backwards through the Lcb's.
    If the Fcb has no Lcb but represents a system file, we will return
    a default system string.  If the Fcb represents a user file, but we
    have no Lcb, we will use the name in the file object for the current
    request.

Arguments:

    Status - Error status.

    FileReference - File reference being accessed in Mft when error occurred.

    Fcb - If specified, this is the Fcb being used when the error was encountered.

Return Value:

    None.

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Entry = NULL;

    PKTHREAD Thread;
    UNICODE_STRING Name;
    ULONG NameLength = 0;

    PFILE_OBJECT FileObject;

    WCHAR *NewBuffer = NULL;

    PIRP Irp = NULL;
    PIO_STACK_LOCATION IrpSp;

    PUNICODE_STRING FileName = NULL;
    PUNICODE_STRING RelatedFileName = NULL;

    BOOLEAN UseLcb = FALSE;
    PVOLUME_ERROR_PACKET VolumeErrorPacket = NULL;
    ULONG OldCount;

    //
    //  Return if there is no originating Irp, for example when originating
    //  from NtfsPerformHotFix or if the originating irp type doesn't match an irp
    //

    if ((IrpContext->OriginatingIrp == NULL) ||
        (IrpContext->OriginatingIrp->Type != IO_TYPE_IRP)) {
        return;
    }

    Irp = IrpContext->OriginatingIrp;
    IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );
    FileObject = IrpSp->FileObject;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the Fcb isn't specified and the file reference is, then
        //  try to get the Fcb from the Fcb table.
        //

        if (!ARGUMENT_PRESENT( Fcb )
            && ARGUMENT_PRESENT( FileReference )) {

            Key.FileReference = *FileReference;

            NtfsAcquireFcbTable( IrpContext, IrpContext->Vcb );
            Entry = RtlLookupElementGenericTable( &IrpContext->Vcb->FcbTable,
                                                  &Key );
            NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );

            if (Entry != NULL) {

                Fcb = Entry->Fcb;
            }
        }

        if (Irp == NULL ||

            IoIsSystemThread( IrpContext->OriginatingIrp->Tail.Overlay.Thread )) {
            Thread = NULL;

        } else {

            Thread = (PKTHREAD)IrpContext->OriginatingIrp->Tail.Overlay.Thread;
        }

        //
        //  If there is no fcb  assume the error occurred in a system file.
        //  if its fileref is outside of this range default to $MFT
        //

        if (!ARGUMENT_PRESENT( Fcb )) {

            if (ARGUMENT_PRESENT( FileReference )) {
                if (NtfsSegmentNumber( FileReference ) <= UPCASE_TABLE_NUMBER) {
                    FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[NtfsSegmentNumber( FileReference )]));
                } else  {
                    FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[0]));
                }
            }

        //
        //  If the name has an Lcb, we will contruct a name with a chain of Lcb's.
        //

        } else if (!IsListEmpty( &Fcb->LcbQueue )) {

            UseLcb = TRUE;

        //
        //  Check if this is a system file.
        //

        } else if (NtfsSegmentNumber( &Fcb->FileReference ) < FIRST_USER_FILE_NUMBER) {


            if (NtfsSegmentNumber( &Fcb->FileReference ) <= UPCASE_TABLE_NUMBER) {
                FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )]));
            } else  {
                FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[0]));
            }

        //
        //  In this case we contruct a name out of the file objects in the
        //  Originating Irp.  If there is no file object or file object buffer
        //  we generate an unknown file message.
        //

        } else if (FileObject == NULL
                   || (IrpContext->MajorFunction == IRP_MJ_CREATE
                       && FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID ))
                   || (FileObject->FileName.Length == 0
                       && (FileObject->RelatedFileObject == NULL
                           || IrpContext->MajorFunction != IRP_MJ_CREATE))) {

            FileName = (PUNICODE_STRING)&(NtfsUnknownFile);
        //
        //  If there is a valid name in the file object we use that.
        //

        } else if ((FileObject->FileName.Length != 0) &&
                   (FileObject->FileName.Buffer[0] == L'\\')) {

            FileName = &(FileObject->FileName);
        //
        //  We have to construct the name from filename + related fileobject.
        //

        } else {

            if (FileObject->FileName.Length != 0) {
                FileName = &(FileObject->FileName);
            }

            if ((FileObject->RelatedFileObject) &&
                (FileObject->RelatedFileObject->FileName.Length != 0)) {
                RelatedFileName = &(FileObject->RelatedFileObject->FileName);
            }
        }

        if (FileName) {
            NameLength += FileName->Length;
        }

        if (RelatedFileName) {
            NameLength += RelatedFileName->Length;
        }

        if (UseLcb) {
            BOOLEAN LeadingBackslash;
            NameLength += NtfsLookupNameLengthViaLcb( Fcb, &LeadingBackslash );
        }

        //
        //  Either append what info we found or default to the volume label
        //

        if (NameLength > 0) {

            NewBuffer = NtfsAllocatePool(PagedPool, NameLength );
            Name.Buffer = NewBuffer;

            //
            //  For super long names truncate buffer size to 64k.
            //  RtlAppendUnicodeString handles the rest of the work
            //

            if (NameLength > 0xFFFF) {
                NameLength = 0xFFFF;
            }

            Name.MaximumLength = (USHORT) NameLength;
            Name.Length = 0;

            if (RelatedFileName) {
                RtlAppendUnicodeStringToString( &Name, RelatedFileName );
            }

            if (FileName) {
                RtlAppendUnicodeStringToString( &Name, FileName );
            }

            if (UseLcb) {
                NtfsFileNameViaLcb( Fcb, NewBuffer, NameLength, NameLength);
                Name.Length = (USHORT) NameLength;
            }

        } else {

            Name.Length = Name.MaximumLength = 0;
            Name.Buffer = NULL;
        }

        //
        //  Only allow 1 post to resolve the volume name to occur at a time
        //

        OldCount = InterlockedCompareExchange( &(NtfsData.VolumeNameLookupsInProgress), 1, 0 );
        if (OldCount == 0) {

            VolumeErrorPacket = NtfsAllocatePool( PagedPool, sizeof( VOLUME_ERROR_PACKET ) );
            VolumeErrorPacket->Status = Status;
            VolumeErrorPacket->Thread = Thread;
            RtlCopyMemory( &(VolumeErrorPacket->FileName), &Name, sizeof( UNICODE_STRING ) );

            //
            //  Reference the thread to keep it around during the resolveandpost
            //

            if (Thread) {
                ObReferenceObject( Thread );
            }

            //
            //  Now post to generate the popup. After posting ResolveVolume will free the newbuffer
            //

            NtfsPostSpecial( IrpContext, IrpContext->Vcb, NtfsResolveVolumeAndRaiseErrorSpecial, VolumeErrorPacket );
            NewBuffer = NULL;
            VolumeErrorPacket = NULL;

        } else {

            //
            //  Lets use what we have
            //

            IoRaiseInformationalHardError( Status, &Name, Thread );
        }

    } finally {

        //
        //  Cleanup any remaining buffers we still own
        //

        if (NewBuffer) {
            NtfsFreePool( NewBuffer );
        }

        if (VolumeErrorPacket) {

            if (VolumeErrorPacket->Thread) {
                ObDereferenceObject( VolumeErrorPacket->Thread );
            }
            NtfsFreePool( VolumeErrorPacket );
        }
    }

    return;
}


VOID
NtfsResolveVolumeAndRaiseErrorSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    Resolve Vcb's win32 devicename and raise an io hard error. This is done in
    a separate thread in order to have enough stack to re-enter the filesys if necc.
    Also because we may reenter. Starting from here means we own no resources other than
    having inc'ed the close count on the underlying vcb to prevent its going away

Arguments:

    IrpContext - IrpContext containing vcb we're interested in

    Context - String to append to volume win32 name


Return Value:

    None.

--*/

{
    UNICODE_STRING VolumeName;
    NTSTATUS Status;
    PVOLUME_ERROR_PACKET VolumeErrorPacket;
    UNICODE_STRING FullName;
    WCHAR *NewBuffer = NULL;
    ULONG NameLength;

    ASSERT( Context != NULL );
    ASSERT( IrpContext->Vcb->NodeTypeCode == NTFS_NTC_VCB );
    ASSERT( IrpContext->Vcb->Vpb->RealDevice != NULL );

    VolumeErrorPacket = (PVOLUME_ERROR_PACKET) Context;
    VolumeName.Length = 0;
    VolumeName.Buffer = NULL;

    try {

        //
        //  Only use the target device if we haven't stopped it and deref'ed it
        //

        Status = IoVolumeDeviceToDosName( IrpContext->Vcb->TargetDeviceObject, &VolumeName );
        ASSERT( STATUS_SUCCESS == Status );

        NameLength = VolumeName.Length + VolumeErrorPacket->FileName.Length;

        if (NameLength > 0) {
            NewBuffer = NtfsAllocatePool( PagedPool, NameLength );
            FullName.Buffer = NewBuffer;

            //
            //  For super long names truncate buffer size to 64k.
            //  RtlAppendUnicodeString handles the rest of the work
            //

            if (NameLength > 0xFFFF) {
                NameLength = 0xFFFF;
            }
            FullName.MaximumLength = (USHORT) NameLength;
            FullName.Length = 0;
            if (VolumeName.Length) {
                RtlCopyUnicodeString( &FullName, &VolumeName );
            }
            if (VolumeErrorPacket->FileName.Length) {
                RtlAppendUnicodeStringToString( &FullName, &(VolumeErrorPacket->FileName) );
            }
        } else {

            FullName.MaximumLength = FullName.Length = IrpContext->Vcb->Vpb->VolumeLabelLength;
            FullName.Buffer = (PWCHAR) IrpContext->Vcb->Vpb->VolumeLabel;
        }

        //
        //  Now generate a popup.
        //

        IoRaiseInformationalHardError( VolumeErrorPacket->Status, &FullName, VolumeErrorPacket->Thread );

    } finally {

        //
        //  Indicate we're done and other lookups can occur
        //

        InterlockedDecrement( &(NtfsData.VolumeNameLookupsInProgress) );

        //
        //  deref the thread
        //

        if (VolumeErrorPacket->Thread) {
            ObDereferenceObject( VolumeErrorPacket->Thread );
        }

        if (NewBuffer != NULL) {
            NtfsFreePool( NewBuffer );
        }

        if (VolumeName.Buffer != NULL) {
            NtfsFreePool( VolumeName.Buffer );
        }

        if (VolumeErrorPacket->FileName.Buffer != NULL) {
            NtfsFreePool( VolumeErrorPacket->FileName.Buffer );
        }

        if (Context != NULL) {
            NtfsFreePool( VolumeErrorPacket );
        }
    }
}




PTOP_LEVEL_CONTEXT
NtfsInitializeTopLevelIrp (
    IN PTOP_LEVEL_CONTEXT TopLevelContext,
    IN BOOLEAN ForceTopLevel,
    IN BOOLEAN SetTopLevel
    )

/*++

Routine Description:

    This routine is called to initializethe top level context to be used in the
    thread local storage. Ntfs always puts its own context in this location and restores
    the previous value on exit.  This routine will determine if this request is
    top level and top level ntfs.  It will return a pointer to the top level ntfs
    context which is to be stored in the local storage and associated with the
    IrpContext for this request.  The return value may be the existing stack location
    or a new one for a recursive request.  If we will use the new one we will initialize
    it but let our caller actually put it on the stack when the IrpContext is initialized.
    The ThreadIrpContext field in the TopLevelContext indicates if this is already on
    the stack.  A NULL value indicates that this is not on the stack yet.

Arguments:

    TopLevelContext - This is the local top level context for our caller.

    ForceTopLevel - Always use the input top level context.

    SetTopLevel - Only applies if the ForceTopLevel value is TRUE.  Indicates
        if we should make this look like the top level request.

Return Value:

    PTOP_LEVEL_CONTEXT - Pointer to the top level ntfs context for this thread.
        It may be the same as passed in by the caller.  In that case the fields
        will be initialized except it won't be stored on the stack and wont'
        have an IrpContext field.

--*/

{
    PTOP_LEVEL_CONTEXT CurrentTopLevelContext;
    ULONG_PTR StackBottom;
    ULONG_PTR StackTop;
    BOOLEAN TopLevelRequest = TRUE;
    BOOLEAN TopLevelNtfs = TRUE;

    BOOLEAN ValidCurrentTopLevel = FALSE;

    //
    //  Get the current value out of the thread local storage.  If it is a zero
    //  value or not a pointer to a valid ntfs top level context or a valid
    //  Fsrtl value then we are the top level request.
    //

    CurrentTopLevelContext = NtfsGetTopLevelContext();

    //
    //  Check if this is a valid Ntfs top level context.
    //

    IoGetStackLimits( &StackTop, &StackBottom);

    if (((ULONG_PTR) CurrentTopLevelContext <= StackBottom - sizeof( TOP_LEVEL_CONTEXT )) &&
        ((ULONG_PTR) CurrentTopLevelContext >= StackTop) &&
        !FlagOn( (ULONG_PTR) CurrentTopLevelContext, 0x3 ) &&
        (CurrentTopLevelContext->Ntfs == 0x5346544e)) {

        ValidCurrentTopLevel = TRUE;
    }

    //
    //  If we are to force this request to be top level then set the
    //  TopLevelRequest flag according to the SetTopLevel input.
    //

    if (ForceTopLevel) {

        TopLevelRequest = SetTopLevel;

    //
    //  If the value is NULL then we are top level everything.
    //

    } else if (CurrentTopLevelContext == NULL) {

        NOTHING;

    //
    //  If this has one of the Fsrtl magic numbers then we were called from
    //  either the fast io path or the mm paging io path.
    //

    } else if ((ULONG_PTR) CurrentTopLevelContext <= FSRTL_MAX_TOP_LEVEL_IRP_FLAG) {

        TopLevelRequest = FALSE;

    } else if (ValidCurrentTopLevel &&
               !FlagOn( CurrentTopLevelContext->ThreadIrpContext->Flags,
                        IRP_CONTEXT_FLAG_CALL_SELF )) {

        TopLevelRequest = FALSE;
        TopLevelNtfs = FALSE;

    //
    //  Handle the case where we have returned FILE_LOCK_CONFLICT to CC and
    //  want to perform a clean checkpoint when releasing the resource.
    //

    } else if ((ULONG_PTR) CurrentTopLevelContext == (0x80000000 | FSRTL_CACHE_TOP_LEVEL_IRP)) {

        TopLevelRequest = FALSE;
    }

    //
    //  If we are the top level ntfs then initialize the caller's structure.
    //  Leave the Ntfs signature and ThreadIrpContext NULL to indicate this is
    //  not in the stack yet.
    //

    if (TopLevelNtfs) {

        TopLevelContext->Ntfs = 0;
        TopLevelContext->SavedTopLevelIrp = (PIRP) CurrentTopLevelContext;
        TopLevelContext->ThreadIrpContext = NULL;
        TopLevelContext->TopLevelRequest = TopLevelRequest;

        if (ValidCurrentTopLevel) {

            TopLevelContext->VboBeingHotFixed = CurrentTopLevelContext->VboBeingHotFixed;
            TopLevelContext->ScbBeingHotFixed = CurrentTopLevelContext->ScbBeingHotFixed;
            TopLevelContext->ValidSavedTopLevel = TRUE;
            TopLevelContext->OverflowReadThread = CurrentTopLevelContext->OverflowReadThread;

        } else {

            TopLevelContext->VboBeingHotFixed = 0;
            TopLevelContext->ScbBeingHotFixed = NULL;
            TopLevelContext->ValidSavedTopLevel = FALSE;
            TopLevelContext->OverflowReadThread = FALSE;
        }

        return TopLevelContext;
    }

    return CurrentTopLevelContext;
}


//
//  Non-paged routines to set up and tear down Irps for cancel.
//

BOOLEAN
NtfsSetCancelRoutine (
    IN PIRP Irp,
    IN PDRIVER_CANCEL CancelRoutine,
    IN ULONG_PTR IrpInformation,
    IN ULONG Async
    )

/*++

Routine Description:

    This routine is called to set up an Irp for cancel.  We will set the cancel routine
    and initialize the Irp information we use during cancel.

Arguments:

    Irp - This is the Irp we need to set up for cancel.

    CancelRoutine - This is the cancel routine for this irp.

    IrpInformation - This is the context information to store in the irp
        for the cancel routine.

    Async - Indicates if this request is synchronous or asynchronous.

Return Value:

    BOOLEAN - TRUE if we initialized the Irp, FALSE if the Irp has already
        been marked cancelled.  It will be marked cancelled if the user
        has cancelled the irp before we could put it in the queue.

--*/

{
    KIRQL Irql;

    //
    //  Assume that the Irp has not been cancelled.
    //

    IoAcquireCancelSpinLock( &Irql );
    if (!Irp->Cancel) {

        Irp->IoStatus.Information = (ULONG_PTR) IrpInformation;

        IoSetCancelRoutine( Irp, CancelRoutine );
        IoReleaseCancelSpinLock( Irql );

        if (Async) {

            IoMarkIrpPending( Irp );
        }

        return TRUE;

    } else {

        IoReleaseCancelSpinLock( Irql );
        return FALSE;
    }
}

BOOLEAN
NtfsClearCancelRoutine (
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to clear an Irp from cancel.  It is called when Ntfs is
    internally ready to continue processing the Irp.  We need to know if cancel
    has already been called on this Irp.  In that case we allow the cancel routine
    to complete the Irp.

Arguments:

    Irp - This is the Irp we want to process further.

Return Value:

    BOOLEAN - TRUE if we can proceed with processing the Irp,  FALSE if the cancel
        routine will process the Irp.

--*/

{
    KIRQL Irql;

    IoAcquireCancelSpinLock( &Irql );

    //
    //  Check if the cancel routine has been called.
    //

    if (IoSetCancelRoutine( Irp, NULL ) == NULL) {

        //
        //  Let our cancel routine handle the Irp.
        //

        IoReleaseCancelSpinLock( Irql );
        return FALSE;

    } else {

        IoReleaseCancelSpinLock( Irql );

        Irp->IoStatus.Information = 0;
        return TRUE;
    }
}


NTSTATUS
NtfsFsdDispatchWait (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the driver entry to most of the NTFS Fsd dispatch points.
    IrpContext is initialized on the stack and passed from here.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    IRP_CONTEXT LocalIrpContext;
    NTSTATUS Status;

    Status = NtfsFsdDispatchSwitch( &LocalIrpContext, Irp, TRUE );

    //
    //  If we ever catch ourselves using an IrpContext of this
    //  type, we know we are doing something wrong.
    //

    LocalIrpContext.NodeTypeCode = (NODE_TYPE_CODE)-1;

    return Status;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );
}


NTSTATUS
NtfsFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the driver entry to NTFS Fsd dispatch IRPs that may
    or may not be synchronous.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/


{
    //
    //  We'd rather create the IrpContext on the stack.
    //

    if (CanFsdWait( Irp )) {

        return NtfsFsdDispatchWait( VolumeDeviceObject, Irp );

    } else {

        return NtfsFsdDispatchSwitch( NULL, Irp, FALSE );
    }
}


//
//  Local support routine.
//

NTSTATUS
NtfsFsdDispatchSwitch (
    IN PIRP_CONTEXT StackIrpContext OPTIONAL,
    IN PIRP Irp,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This is the common switch for all the FsdEntry points
    that don't need special pre-processing. This simply initializes
    the IrpContext and calls the 'Common*' code.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

    Wait - Can this request be posted or not?

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    PIRP_CONTEXT IrpContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdDispatch\n") );

    //
    //  Call the common query Information routine
    //

    FsRtlEnterFileSystem();

    //
    //  Always make these requests look top level.
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  The optional IrpContext could reside on the caller's stack.
                //

                if (ARGUMENT_PRESENT( StackIrpContext )) {

                    IrpContext = StackIrpContext;
                }

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }


            switch (IrpContext->MajorFunction) {

                case IRP_MJ_QUERY_EA:

                    Status = NtfsCommonQueryEa( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_EA:

                    Status = NtfsCommonSetEa( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_QUOTA:

                    Status = NtfsCommonQueryQuota( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_QUOTA:

                    Status = NtfsCommonSetQuota( IrpContext, Irp );
                    break;

                case IRP_MJ_DEVICE_CONTROL:

                    Status = NtfsCommonDeviceControl( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_INFORMATION:

                    Status = NtfsCommonQueryInformation( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_SECURITY:

                    Status = NtfsCommonQuerySecurityInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_SECURITY:

                    Status = NtfsCommonSetSecurityInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_VOLUME_INFORMATION:

                    Status = NtfsCommonQueryVolumeInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_VOLUME_INFORMATION:

                    Status = NtfsCommonSetVolumeInfo( IrpContext, Irp );
                    break;

                default:

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    NtfsCompleteRequest( IrpContext, Irp, Status );
                    ASSERT(FALSE);
                    break;
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdDispatch -> %08lx\n", Status) );

    return Status;
}

#ifdef NTFS_CHECK_BITMAP
BOOLEAN NtfsForceBitmapBugcheck = FALSE;
BOOLEAN NtfsDisableBitmapCheck = FALSE;

VOID
NtfsBadBitmapCopy (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BadBit,
    IN ULONG Length
    )
{
    if (!NtfsDisableBitmapCheck) {

        DbgPrint("%s:%d %s\n",__FILE__,__LINE__,"Invalid bitmap");
        DbgBreakPoint();

        if (!NtfsDisableBitmapCheck && NtfsForceBitmapBugcheck) {

            KeBugCheckEx( NTFS_FILE_SYSTEM, (ULONG) IrpContext, BadBit, Length, 0 );
        }
    }
    return;
}

BOOLEAN
NtfsCheckBitmap (
    IN PVCB Vcb,
    IN ULONG Lcn,
    IN ULONG Count,
    IN BOOLEAN Set
    )
{
    ULONG BitmapPage;
    ULONG LastBitmapPage;
    ULONG BitOffset;
    ULONG BitsThisPage;
    BOOLEAN Valid = FALSE;

    BitmapPage = Lcn / (PAGE_SIZE * 8);
    LastBitmapPage = (Lcn + Count + (PAGE_SIZE * 8) - 1) / (PAGE_SIZE * 8);
    BitOffset = Lcn & ((PAGE_SIZE * 8) - 1);

    if (LastBitmapPage > Vcb->BitmapPages) {

        return Valid;
    }

    do {

        BitsThisPage = Count;

        if (BitOffset + Count > (PAGE_SIZE * 8)) {

            BitsThisPage = (PAGE_SIZE * 8) - BitOffset;
        }

        if (Set) {

            Valid = RtlAreBitsSet( Vcb->BitmapCopy + BitmapPage,
                                   BitOffset,
                                   BitsThisPage );

        } else {

            Valid = RtlAreBitsClear( Vcb->BitmapCopy + BitmapPage,
                                     BitOffset,
                                     BitsThisPage );
        }

        BitOffset = 0;
        Count -= BitsThisPage;
        BitmapPage += 1;

    } while (Valid && (BitmapPage < LastBitmapPage));

    if (Count != 0) {

        Valid = FALSE;
    }

    return Valid;
}
#endif

//
//  Debugging support routines used for pool verification.  Alas, this works only
//  on checked X86.
//

#if DBG && i386 && defined (NTFSPOOLCHECK)
//
//  Number of backtrace items retrieved on X86


#define BACKTRACE_DEPTH 9

typedef struct _BACKTRACE
{
    ULONG State;
    ULONG Size;
    PVOID Allocate[BACKTRACE_DEPTH];
    PVOID Free[BACKTRACE_DEPTH];
} BACKTRACE, *PBACKTRACE;


#define STATE_ALLOCATED 'M'
#define STATE_FREE      'Z'

//
//  WARNING!  The following depends on pool allocations being either
//      0 mod PAGE_SIZE (for large blocks)
//  or  8 mod 0x20 (for all other requests)
//

#define PAGE_ALIGNED(pv)      (((ULONG)(pv) & (PAGE_SIZE - 1)) == 0)
#define IsKernelPoolBlock(pv) (PAGE_ALIGNED(pv) || (((ULONG)(pv) % 0x20) == 8))

ULONG NtfsDebugTotalPoolAllocated = 0;
ULONG NtfsDebugCountAllocated = 0;
ULONG NtfsDebugSnapshotTotal = 0;
ULONG NtfsDebugSnapshotCount = 0;

PVOID
NtfsDebugAllocatePoolWithTagNoRaise (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag)
{
    ULONG Ignore;
    PBACKTRACE BackTrace =
        ExAllocatePoolWithTag( Pool, Length + sizeof (BACKTRACE), Tag );

    if (PAGE_ALIGNED(BackTrace))
    {
        return BackTrace;
    }

    RtlZeroMemory( BackTrace, sizeof (BACKTRACE) );
    if (RtlCaptureStackBackTrace( 0, BACKTRACE_DEPTH, BackTrace->Allocate, &Ignore ) == 0)
        BackTrace->Allocate[0] = (PVOID)-1;

    BackTrace->State = STATE_ALLOCATED;
    BackTrace->Size = Length;

    NtfsDebugCountAllocated++;
    NtfsDebugTotalPoolAllocated += Length;

    return BackTrace + 1;
}

PVOID
NtfsDebugAllocatePoolWithTag (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag)
{
    ULONG Ignore;
    PBACKTRACE BackTrace =
        FsRtlAllocatePoolWithTag( Pool, Length + sizeof (BACKTRACE), Tag );

    if (PAGE_ALIGNED(BackTrace))
    {
        return BackTrace;
    }

    RtlZeroMemory( BackTrace, sizeof (BACKTRACE) );
    if (RtlCaptureStackBackTrace( 0, BACKTRACE_DEPTH, BackTrace->Allocate, &Ignore ) == 0)
        BackTrace->Allocate[0] = (PVOID)-1;

    BackTrace->State = STATE_ALLOCATED;
    BackTrace->Size = Length;

    NtfsDebugCountAllocated++;
    NtfsDebugTotalPoolAllocated += Length;

    return BackTrace + 1;
}

VOID
NtfsDebugFreePool (
    PVOID pv)
{
    if (IsKernelPoolBlock( pv ))
    {
        ExFreePool( pv );
    }
    else
    {
        ULONG Ignore;
        PBACKTRACE BackTrace = (PBACKTRACE)pv - 1;

        if (BackTrace->State != STATE_ALLOCATED)
        {
            DbgBreakPoint( );
        }

        if (RtlCaptureStackBackTrace( 0, BACKTRACE_DEPTH, BackTrace->Free, &Ignore ) == 0)
            BackTrace->Free[0] = (PVOID)-1;

        BackTrace->State = STATE_FREE;

        NtfsDebugCountAllocated--;
        NtfsDebugTotalPoolAllocated -= BackTrace->Size;

        ExFreePool( BackTrace );
    }
}

VOID
NtfsDebugHeapDump (
    PUNICODE_STRING UnicodeString )
{

    UNREFERENCED_PARAMETER( UnicodeString );

    DbgPrint( "Cumulative %8x bytes in %8x blocks\n",
               NtfsDebugTotalPoolAllocated, NtfsDebugCountAllocated );
    DbgPrint( "Snapshot   %8x bytes in %8x blocks\n",
               NtfsDebugTotalPoolAllocated - NtfsDebugSnapshotTotal,
               NtfsDebugCountAllocated - NtfsDebugSnapshotCount );

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfsinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Ntfs

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg         (DEBUG_TRACE_FSP_DISPATCHER)

//
//  Reference our local attribute definitions
//

extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NtfsInitializeNtfsData (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
NtfsQueryValueKey (
    IN PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG ValueLength,
    IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
    IN OUT PBOOLEAN DeallocateKeyValue
    );

BOOLEAN
NtfsRunningOnWhat(
    IN USHORT SuiteMask,
    IN UCHAR ProductType
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, NtfsInitializeNtfsData)
#pragma alloc_text(INIT, NtfsQueryValueKey)
#pragma alloc_text(INIT, NtfsRunningOnWhat)
#endif

#define UPGRADE_SETUPDD_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Setupdd"
#define UPGRADE_SETUPDD_VALUE_NAME L"Start"

#define UPGRADE_CHECK_SETUP_KEY_NAME L"\\Registry\\Machine\\System\\Setup"
#define UPGRADE_CHECK_SETUP_VALUE_NAME L"SystemSetupInProgress"

#define UPGRADE_CHECK_SETUP_CMDLINE_NAME L"CmdLine"
#define UPGRADE_CHECK_SETUP_ASR L"-asr"
#define UPGRADE_CHECK_SETUP_NEWSETUP L"-newsetup"

#define COMPATIBILITY_MODE_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"
#define COMPATIBILITY_MODE_VALUE_NAME L"NtfsDisable8dot3NameCreation"

#define EXTENDED_CHAR_MODE_VALUE_NAME L"NtfsAllowExtendedCharacterIn8dot3Name"

#define DISABLE_LAST_ACCESS_VALUE_NAME L"NtfsDisableLastAccessUpdate"

#define QUOTA_NOTIFY_RATE L"NtfsQuotaNotifyRate"

#define MFT_ZONE_SIZE_VALUE_NAME L"NtfsMftZoneReservation"

#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 128)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Ntfs file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT DeviceObject;

    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;

    ULONG Value;
    ULONG KeyValueLength;
    UCHAR Buffer[KEY_WORK_AREA];
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    BOOLEAN DeallocateKeyValue;

    UNREFERENCED_PARAMETER( RegistryPath );

    PAGED_CODE();

    //
    //  Check to make sure structure overlays are correct.
    //

    ASSERT( FIELD_OFFSET( FILE_NAME, ParentDirectory) == FIELD_OFFSET(OVERLAY_LCB, OverlayParentDirectory ));
    ASSERT( FIELD_OFFSET( FILE_NAME, FileNameLength) == FIELD_OFFSET(OVERLAY_LCB, OverlayFileNameLength ));
    ASSERT( FIELD_OFFSET( FILE_NAME, Flags) == FIELD_OFFSET(OVERLAY_LCB, OverlayFlags ));
    ASSERT( FIELD_OFFSET( FILE_NAME, FileName) == FIELD_OFFSET(OVERLAY_LCB, OverlayFileName ));
    ASSERT( sizeof( DUPLICATED_INFORMATION ) >= (sizeof( QUICK_INDEX ) + (sizeof( ULONG ) * 4) + sizeof( PFILE_NAME )));

    //
    //  The open attribute table entries should be 64-bit aligned.
    //

    ASSERT( sizeof( OPEN_ATTRIBUTE_ENTRY ) == QuadAlign( sizeof( OPEN_ATTRIBUTE_ENTRY )));

    //
    //  The first entry in an open attribute data should be the links.
    //

    ASSERT( FIELD_OFFSET( OPEN_ATTRIBUTE_DATA, Links ) == 0 );

    //
    //  Compute the last access increment.  We convert the number of
    //  minutes to number of 1/100 of nanoseconds.  We have to be careful
    //  not to overrun 32 bits for any multiplier.
    //
    //  To reach 1/100 of nanoseconds per minute we take
    //
    //      1/100 nanoseconds * 10      = 1 microsecond
    //                        * 1000    = 1 millesecond
    //                        * 1000    = 1 second
    //                        * 60      = 1 minute
    //
    //  Then multiply this by the last access increment in minutes.
    //

    NtfsLastAccess = Int32x32To64( ( 10 * 1000 * 1000 * 60 ), LAST_ACCESS_INCREMENT_MINUTES );

    //
    //  Allocate the reserved buffers for USA writes - do this early so we don't have any
    //  teardown to do.
    //

    NtfsReserved1 = NtfsAllocatePoolNoRaise( NonPagedPool, LARGE_BUFFER_SIZE );
    if (NULL == NtfsReserved1) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Buffer 2 is used for the workspace.  It may require a slightly larger buffer on
    //  a Win64 system.
    //

    NtfsReserved2 = NtfsAllocatePoolNoRaise( NonPagedPool, WORKSPACE_BUFFER_SIZE );
    if (NULL == NtfsReserved2) {
        NtfsFreePool( NtfsReserved1 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NtfsReserved3 = NtfsAllocatePoolNoRaise( NonPagedPool, LARGE_BUFFER_SIZE );
    if (NULL == NtfsReserved3) {
        NtfsFreePool( NtfsReserved1 );
        NtfsFreePool( NtfsReserved2 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &UnicodeString, L"\\Ntfs" );


    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &DeviceObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Note that because of the way data caching is done, we set neither
    //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    //  data is not in the cache, or the request is not buffered, we may,
    //  set up for Direct I/O by hand.
    //

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_QUERY_EA]                 =
    DriverObject->MajorFunction[IRP_MJ_SET_EA]                   =
    DriverObject->MajorFunction[IRP_MJ_QUERY_QUOTA]              =
    DriverObject->MajorFunction[IRP_MJ_SET_QUOTA]                =
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        = (PDRIVER_DISPATCH)NtfsFsdDispatchWait;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]           =
    DriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY]           =
    DriverObject->MajorFunction[IRP_MJ_SET_SECURITY]             =
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] =
    DriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION]   = (PDRIVER_DISPATCH)NtfsFsdDispatch;

    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]             = (PDRIVER_DISPATCH)NtfsFsdLockControl;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]        = (PDRIVER_DISPATCH)NtfsFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          = (PDRIVER_DISPATCH)NtfsFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_CREATE]                   = (PDRIVER_DISPATCH)NtfsFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    = (PDRIVER_DISPATCH)NtfsFsdClose;
    DriverObject->MajorFunction[IRP_MJ_READ]                     = (PDRIVER_DISPATCH)NtfsFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    = (PDRIVER_DISPATCH)NtfsFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]            = (PDRIVER_DISPATCH)NtfsFsdFlushBuffers;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      = (PDRIVER_DISPATCH)NtfsFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  = (PDRIVER_DISPATCH)NtfsFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                 = (PDRIVER_DISPATCH)NtfsFsdShutdown;
    DriverObject->MajorFunction[IRP_MJ_PNP]                      = (PDRIVER_DISPATCH)NtfsFsdPnp;

    DriverObject->FastIoDispatch = &NtfsFastIoDispatch;

    NtfsFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    NtfsFastIoDispatch.FastIoCheckIfPossible =   NtfsFastIoCheckIfPossible;  //  CheckForFastIo
    NtfsFastIoDispatch.FastIoRead =              NtfsCopyReadA;              //  Read
    NtfsFastIoDispatch.FastIoWrite =             NtfsCopyWriteA;             //  Write
    NtfsFastIoDispatch.FastIoQueryBasicInfo =    NtfsFastQueryBasicInfo;     //  QueryBasicInfo
    NtfsFastIoDispatch.FastIoQueryStandardInfo = NtfsFastQueryStdInfo;       //  QueryStandardInfo
    NtfsFastIoDispatch.FastIoLock =              NtfsFastLock;               //  Lock
    NtfsFastIoDispatch.FastIoUnlockSingle =      NtfsFastUnlockSingle;       //  UnlockSingle
    NtfsFastIoDispatch.FastIoUnlockAll =         NtfsFastUnlockAll;          //  UnlockAll
    NtfsFastIoDispatch.FastIoUnlockAllByKey =    NtfsFastUnlockAllByKey;     //  UnlockAllByKey
    NtfsFastIoDispatch.FastIoDeviceControl =     NULL;                       //  IoDeviceControl
    NtfsFastIoDispatch.FastIoDetachDevice            = NULL;
    NtfsFastIoDispatch.FastIoQueryNetworkOpenInfo    = NtfsFastQueryNetworkOpenInfo;
    NtfsFastIoDispatch.AcquireFileForNtCreateSection =  NtfsAcquireForCreateSection;
    NtfsFastIoDispatch.ReleaseFileForNtCreateSection =  NtfsReleaseForCreateSection;
    NtfsFastIoDispatch.AcquireForModWrite =          NtfsAcquireFileForModWrite;
    NtfsFastIoDispatch.MdlRead =                     NtfsMdlReadA;
    NtfsFastIoDispatch.MdlReadComplete =             FsRtlMdlReadCompleteDev;
    NtfsFastIoDispatch.PrepareMdlWrite =             NtfsPrepareMdlWriteA;
    NtfsFastIoDispatch.MdlWriteComplete =            FsRtlMdlWriteCompleteDev;
#ifdef  COMPRESS_ON_WIRE
    NtfsFastIoDispatch.FastIoReadCompressed =        NtfsCopyReadC;
    NtfsFastIoDispatch.FastIoWriteCompressed =       NtfsCopyWriteC;
    NtfsFastIoDispatch.MdlReadCompleteCompressed =   NtfsMdlReadCompleteCompressed;
    NtfsFastIoDispatch.MdlWriteCompleteCompressed =  NtfsMdlWriteCompleteCompressed;
#endif
    NtfsFastIoDispatch.FastIoQueryOpen =             NtfsNetworkOpenCreate;
    NtfsFastIoDispatch.AcquireForCcFlush =           NtfsAcquireFileForCcFlush;
    NtfsFastIoDispatch.ReleaseForCcFlush =           NtfsReleaseFileForCcFlush;

    //
    //  Initialize the global ntfs data structure
    //

    NtfsInitializeNtfsData( DriverObject );

    if (NtfsRunningOnWhat( VER_SUITE_PERSONAL, VER_NT_WORKSTATION )) {
        SetFlag( NtfsData.Flags, NTFS_FLAGS_PERSONAL );
    }

    KeInitializeMutant( &StreamFileCreationMutex, FALSE );
    KeInitializeEvent( &NtfsEncryptionPendingEvent, NotificationEvent, TRUE );

    //
    //  Initialize the Ntfs Mcb global data queue and variables
    //

    ExInitializeFastMutex( &NtfsMcbFastMutex );
    InitializeListHead( &NtfsMcbLruQueue );
    NtfsMcbCleanupInProgress = FALSE;

    switch ( MmQuerySystemSize() ) {

    case MmSmallSystem:

        NtfsMcbHighWaterMark = 1000;
        NtfsMcbLowWaterMark = 500;
        NtfsMcbCurrentLevel = 0;
        break;

    case MmMediumSystem:

        NtfsMcbHighWaterMark = 4000;
        NtfsMcbLowWaterMark = 2000;
        NtfsMcbCurrentLevel = 0;
        break;

    case MmLargeSystem:
    default:

        NtfsMcbHighWaterMark = 16000;
        NtfsMcbLowWaterMark = 8000;
        NtfsMcbCurrentLevel = 0;
        break;
    }

    //
    //  Double the watermark levels for all
    //  systems running data center or server appliance
    //

    if (NtfsRunningOnWhat( VER_SUITE_DATACENTER, VER_NT_SERVER ) ||
        NtfsRunningOnWhat( VER_SUITE_DATACENTER, VER_NT_DOMAIN_CONTROLLER )) {

        NtfsMcbHighWaterMark <<= 1;
        NtfsMcbLowWaterMark <<= 1;
    }

    //
    //  Allocate and initialize the free Eresource array
    //

    if ((NtfsData.FreeEresourceArray =
         NtfsAllocatePoolWithTagNoRaise( NonPagedPool, (NtfsData.FreeEresourceTotal * sizeof(PERESOURCE)), 'rftN')) == NULL) {

        KeBugCheck( NTFS_FILE_SYSTEM );
    }

    RtlZeroMemory( NtfsData.FreeEresourceArray, NtfsData.FreeEresourceTotal * sizeof(PERESOURCE) );

    //
    //  Keep a zeroed out object id extended info around for comparisons in objidsup.c.
    //

    RtlZeroMemory( NtfsZeroExtendedInfo, sizeof(NtfsZeroExtendedInfo) );

    //
    //  Register the file system with the I/O system
    //

    IoRegisterFileSystem(DeviceObject);

    //
    //  Initialize logging.
    //

    NtfsInitializeLogging();

    //
    //  Initialize global variables.  (ntfsdata.c assumes 2-digit value for
    //  $FILE_NAME)
    //

    ASSERT(($FILE_NAME >= 0x10) && ($FILE_NAME < 0x100));

    ASSERT( ((BOOLEAN) IRP_CONTEXT_STATE_WAIT) != FALSE );

    //
    //  Some big assumptions are made when these bits are set in create.  Let's
    //  make sure those assumptions are still valid.
    //

    ASSERT( (READ_DATA_ACCESS == FILE_READ_DATA) &&
            (WRITE_DATA_ACCESS == FILE_WRITE_DATA) &&
            (APPEND_DATA_ACCESS == FILE_APPEND_DATA) &&
            (WRITE_ATTRIBUTES_ACCESS == FILE_WRITE_ATTRIBUTES) &&
            (EXECUTE_ACCESS == FILE_EXECUTE) &&
            (BACKUP_ACCESS == (TOKEN_HAS_BACKUP_PRIVILEGE << 2)) &&
            (RESTORE_ACCESS == (TOKEN_HAS_RESTORE_PRIVILEGE << 2)) );

    //
    //  Let's make sure the number of attributes in the table is correct.
    //

#ifdef NTFSDBG
    {
        ULONG Count = 0;

        while (NtfsAttributeDefinitions[Count].AttributeTypeCode != $UNUSED) {

            Count += 1;
        }

        //
        //  We want to add one for the empty end record.
        //

        Count += 1;

        ASSERTMSG( "Update NtfsAttributeDefinitionsCount in attrdata.c",
                   (Count == NtfsAttributeDefinitionsCount) );
    }
#endif

    //
    //  Read the registry to determine if we should upgrade the volumes.
    //

    DeallocateKeyValue = FALSE;
    KeyValueLength = KEY_WORK_AREA;
    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) &Buffer;

    KeyName.Buffer = UPGRADE_CHECK_SETUP_KEY_NAME;
    KeyName.Length = sizeof( UPGRADE_CHECK_SETUP_KEY_NAME ) - sizeof( WCHAR );
    KeyName.MaximumLength = sizeof( UPGRADE_CHECK_SETUP_KEY_NAME );

    ValueName.Buffer = UPGRADE_CHECK_SETUP_VALUE_NAME;
    ValueName.Length = sizeof( UPGRADE_CHECK_SETUP_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( UPGRADE_CHECK_SETUP_VALUE_NAME );

    //
    //  Look for the SystemSetupInProgress flag.
    //

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    if (NT_SUCCESS( Status )) {

        if (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 1) {

            SetFlag( NtfsData.Flags, NTFS_FLAGS_DISABLE_UPGRADE );
        }

    //
    //  Otherwise look to see if the setupdd value is present.
    //

    } else {

        if (KeyValueInformation == NULL) {

            DeallocateKeyValue = FALSE;
            KeyValueLength = KEY_WORK_AREA;
            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) &Buffer;
        }

        KeyName.Buffer = UPGRADE_SETUPDD_KEY_NAME;
        KeyName.Length = sizeof( UPGRADE_SETUPDD_KEY_NAME ) - sizeof( WCHAR );
        KeyName.MaximumLength = sizeof( UPGRADE_SETUPDD_KEY_NAME );

        ValueName.Buffer = UPGRADE_SETUPDD_VALUE_NAME;
        ValueName.Length = sizeof( UPGRADE_SETUPDD_VALUE_NAME ) - sizeof( WCHAR );
        ValueName.MaximumLength = sizeof( UPGRADE_SETUPDD_VALUE_NAME );

        Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

        //
        //  The presence of this flag says "Don't upgrade"
        //

        if (NT_SUCCESS( Status )) {

            SetFlag( NtfsData.Flags, NTFS_FLAGS_DISABLE_UPGRADE );
        }
    }

    //
    //  Read the registry to determine if we are to create short names.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) &Buffer;
    }

    KeyName.Buffer = COMPATIBILITY_MODE_KEY_NAME;
    KeyName.Length = sizeof( COMPATIBILITY_MODE_KEY_NAME ) - sizeof( WCHAR );
    KeyName.MaximumLength = sizeof( COMPATIBILITY_MODE_KEY_NAME );

    ValueName.Buffer = COMPATIBILITY_MODE_VALUE_NAME;
    ValueName.Length = sizeof( COMPATIBILITY_MODE_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( COMPATIBILITY_MODE_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero then create the 8.3
    //  names.
    //

    if (!NT_SUCCESS( Status ) ||
        (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 0)) {

        SetFlag( NtfsData.Flags, NTFS_FLAGS_CREATE_8DOT3_NAMES );
    }

    //
    //  Read the registry to determine if we allow extended character in short name.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) &Buffer;
    }

    ValueName.Buffer = EXTENDED_CHAR_MODE_VALUE_NAME;
    ValueName.Length = sizeof( EXTENDED_CHAR_MODE_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( EXTENDED_CHAR_MODE_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero then do not allow
    //  extended character in 8.3 names.
    //

    if (NT_SUCCESS( Status ) &&
        (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 1)) {

        SetFlag( NtfsData.Flags, NTFS_FLAGS_ALLOW_EXTENDED_CHAR );
    }

    //
    //  Read the registry to determine if we should disable last access updates.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) &Buffer;
    }

    ValueName.Buffer = DISABLE_LAST_ACCESS_VALUE_NAME;
    ValueName.Length = sizeof( DISABLE_LAST_ACCESS_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( DISABLE_LAST_ACCESS_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero then don't update last access times.
    //

    if (NT_SUCCESS( Status ) &&
        (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 1)) {

        SetFlag( NtfsData.Flags, NTFS_FLAGS_DISABLE_LAST_ACCESS );
    }

    //
    //  Read the registry to determine if we should change the Mft
    //  Zone reservation.
    //

    NtfsMftZoneMultiplier = 1;

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) &Buffer;
    }

    ValueName.Buffer = MFT_ZONE_SIZE_VALUE_NAME;
    ValueName.Length = sizeof( MFT_ZONE_SIZE_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( MFT_ZONE_SIZE_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero or greater than 4 then
    //  use the default.
    //

    if (NT_SUCCESS( Status )) {

        ULONG NewMultiplier = *((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset ));

        if ((NewMultiplier != 0) && (NewMultiplier <= 4)) {

            NtfsMftZoneMultiplier = NewMultiplier;
        }
    }

    //
    //  Read the registry to determine if the quota notification rate has been
    //  change from the default.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) &Buffer;
    }

    ValueName.Buffer = QUOTA_NOTIFY_RATE;
    ValueName.Length = sizeof( QUOTA_NOTIFY_RATE ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( QUOTA_NOTIFY_RATE );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    if (NT_SUCCESS( Status )) {

        Value = *((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset ));

        //
        //  Value is in second, convert it to 100ns.
        //

        NtfsMaxQuotaNotifyRate = (ULONGLONG) Value * 1000 * 1000 * 10;
    }

    //
    //  Setup the CheckPointAllVolumes callback item, timer, dpc, and
    //  status.
    //

    ExInitializeWorkItem( &NtfsData.VolumeCheckpointItem,
                          NtfsCheckpointAllVolumes,
                          (PVOID)NULL );

    KeInitializeTimer( &NtfsData.VolumeCheckpointTimer );

    NtfsData.VolumeCheckpointStatus = 0;

    KeInitializeDpc( &NtfsData.VolumeCheckpointDpc,
                     NtfsVolumeCheckpointDpc,
                     NULL );
    NtfsData.TimerStatus = TIMER_NOT_SET;

    //
    //  Setup the UsnTimeout callback item, timer, dpc, and
    //  status.
    //

    ExInitializeWorkItem( &NtfsData.UsnTimeOutItem,
                          NtfsCheckUsnTimeOut,
                          (PVOID)NULL );

    KeInitializeTimer( &NtfsData.UsnTimeOutTimer );

    KeInitializeDpc( &NtfsData.UsnTimeOutDpc,
                     NtfsUsnTimeOutDpc,
                     NULL );

    {
        LONGLONG FiveMinutesFromNow = -5*1000*1000*10;

        FiveMinutesFromNow *= 60;

        KeSetTimer( &NtfsData.UsnTimeOutTimer,
                    *(PLARGE_INTEGER)&FiveMinutesFromNow,
                    &NtfsData.UsnTimeOutDpc );
    }

    //
    //  Initialize sync objects for reserved buffers
    //

    ExInitializeFastMutex( &NtfsReservedBufferMutex );
    ExInitializeResource( &NtfsReservedBufferResource );

    //
    //  Zero out the global upcase table, that way we'll fill it in on
    //  our first successful mount
    //

    NtfsData.UpcaseTable = NULL;
    NtfsData.UpcaseTableSize = 0;

    ExInitializeFastMutex( &NtfsScavengerLock );
    NtfsScavengerWorkList = NULL;
    NtfsScavengerRunning = FALSE;

    //
    // Initialize the EFS driver
    //

    IoRegisterDriverReinitialization( DriverObject, NtfsLoadAddOns, NULL );

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}


VOID
NtfsInitializeNtfsData (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine initializes the global ntfs data record

Arguments:

    DriverObject - Supplies the driver object for NTFS

Return Value:

    None.

--*/

{
    USHORT FileLockMaxDepth;
    USHORT IoContextMaxDepth;
    USHORT IrpContextMaxDepth;
    USHORT KeventMaxDepth;
    USHORT ScbNonpagedMaxDepth;
    USHORT ScbSnapshotMaxDepth;

    USHORT CcbDataMaxDepth;
    USHORT CcbMaxDepth;
    USHORT DeallocatedRecordsMaxDepth;
    USHORT FcbDataMaxDepth;
    USHORT FcbIndexMaxDepth;
    USHORT IndexContextMaxDepth;
    USHORT LcbMaxDepth;
    USHORT NukemMaxDepth;
    USHORT ScbDataMaxDepth;
    USHORT CompSyncMaxDepth;

    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;
    BOOLEAN CapturedSubjectContext = FALSE;

    PACL SystemDacl = NULL;
    ULONG SystemDaclLength;

    PSID AdminSid = NULL;
    PSID SystemSid = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Zero the record.
    //

    RtlZeroMemory( &NtfsData, sizeof(NTFS_DATA));

    //
    //  Initialize the queue of mounted Vcbs
    //

    InitializeListHead(&NtfsData.VcbQueue);

    //
    //  This list head keeps track of closes yet to be done.
    //

    InitializeListHead( &NtfsData.AsyncCloseList );
    InitializeListHead( &NtfsData.DelayedCloseList );

    ExInitializeWorkItem( &NtfsData.NtfsCloseItem,
                          (PWORKER_THREAD_ROUTINE)NtfsFspClose,
                          NULL );

    //
    //  Set the driver object, device object, and initialize the global
    //  resource protecting the file system
    //

    NtfsData.DriverObject = DriverObject;

    ExInitializeResource( &NtfsData.Resource );

    ExInitializeFastMutex( &NtfsData.NtfsDataLock );

    //
    //  Now allocate and initialize the s-list structures used as our pool
    //  of IRP context records.  The size of the zone is based on the
    //  system memory size.  We also initialize the spin lock used to protect
    //  the zone.
    //

    {

        switch ( MmQuerySystemSize() ) {

        case MmSmallSystem:

            NtfsData.FreeEresourceTotal = 14;

            //
            //  Nonpaged Lookaside list maximum depths
            //

            FileLockMaxDepth           = 8;
            IoContextMaxDepth          = 8;
            IrpContextMaxDepth         = 4;
            KeventMaxDepth             = 8;
            ScbNonpagedMaxDepth        = 8;
            ScbSnapshotMaxDepth        = 8;
            CompSyncMaxDepth           = 4;

            //
            //  Paged Lookaside list maximum depths
            //

            CcbDataMaxDepth            = 4;
            CcbMaxDepth                = 4;
            DeallocatedRecordsMaxDepth = 8;
            FcbDataMaxDepth            = 8;
            FcbIndexMaxDepth           = 4;
            IndexContextMaxDepth       = 8;
            LcbMaxDepth                = 4;
            NukemMaxDepth              = 8;
            ScbDataMaxDepth            = 4;

            SetFlag( NtfsData.Flags, NTFS_FLAGS_SMALL_SYSTEM );
            NtfsMaxDelayedCloseCount = MAX_DELAYED_CLOSE_COUNT;
            NtfsAsyncPostThreshold = ASYNC_CLOSE_POST_THRESHOLD;

            break;

        case MmMediumSystem:

            NtfsData.FreeEresourceTotal = 30;

            //
            //  Nonpaged Lookaside list maximum depths
            //

            FileLockMaxDepth           = 8;
            IoContextMaxDepth          = 8;
            IrpContextMaxDepth         = 8;
            KeventMaxDepth             = 8;
            ScbNonpagedMaxDepth        = 30;
            ScbSnapshotMaxDepth        = 8;
            CompSyncMaxDepth           = 8;

            //
            //  Paged Lookaside list maximum depths
            //

            CcbDataMaxDepth            = 12;
            CcbMaxDepth                = 6;
            DeallocatedRecordsMaxDepth = 8;
            FcbDataMaxDepth            = 30;
            FcbIndexMaxDepth           = 12;
            IndexContextMaxDepth       = 8;
            LcbMaxDepth                = 12;
            NukemMaxDepth              = 8;
            ScbDataMaxDepth            = 12;

            SetFlag( NtfsData.Flags, NTFS_FLAGS_MEDIUM_SYSTEM );
            NtfsMaxDelayedCloseCount = 4 * MAX_DELAYED_CLOSE_COUNT;
            NtfsAsyncPostThreshold = 4 * ASYNC_CLOSE_POST_THRESHOLD;

            break;

        case MmLargeSystem:

            SetFlag( NtfsData.Flags, NTFS_FLAGS_LARGE_SYSTEM );
            NtfsMaxDelayedCloseCount = 16 * MAX_DELAYED_CLOSE_COUNT;
            NtfsAsyncPostThreshold = 16 * ASYNC_CLOSE_POST_THRESHOLD;

            if (MmIsThisAnNtAsSystem()) {

                NtfsData.FreeEresourceTotal = 256;

                //
                //  Nonpaged Lookaside list maximum depths
                //

                FileLockMaxDepth           = 8;
                IoContextMaxDepth          = 8;
                IrpContextMaxDepth         = 256;
                KeventMaxDepth             = 8;
                ScbNonpagedMaxDepth        = 128;
                ScbSnapshotMaxDepth        = 8;
                CompSyncMaxDepth           = 32;

                //
                //  Paged Lookaside list maximum depths
                //

                CcbDataMaxDepth            = 40;
                CcbMaxDepth                = 20;
                DeallocatedRecordsMaxDepth = 8;
                FcbDataMaxDepth            = 128;
                FcbIndexMaxDepth           = 40;
                IndexContextMaxDepth       = 8;
                LcbMaxDepth                = 40;
                NukemMaxDepth              = 8;
                ScbDataMaxDepth            = 40;

            } else {

                NtfsData.FreeEresourceTotal = 128;

                //
                //  Nonpaged Lookaside list maximum depths
                //

                FileLockMaxDepth           = 8;
                IoContextMaxDepth          = 8;
                IrpContextMaxDepth         = 64;
                KeventMaxDepth             = 8;
                ScbNonpagedMaxDepth        = 64;
                ScbSnapshotMaxDepth        = 8;
                CompSyncMaxDepth           = 16;

                //
                //  Paged Lookaside list maximum depths
                //

                CcbDataMaxDepth            = 20;
                CcbMaxDepth                = 10;
                DeallocatedRecordsMaxDepth = 8;
                FcbDataMaxDepth            = 64;
                FcbIndexMaxDepth           = 20;
                IndexContextMaxDepth       = 8;
                LcbMaxDepth                = 20;
                NukemMaxDepth              = 8;
                ScbDataMaxDepth            = 20;
            }

            break;
        }

        NtfsMinDelayedCloseCount = NtfsMaxDelayedCloseCount * 4 / 5;
        NtfsThrottleCreates = NtfsMinDelayedCloseCount * 2;
    }

    //
    //  Initialize our various lookaside lists.  To make it a bit more readable we'll
    //  define two quick macros to do the initialization
    //

#if DBG && i386 && defined (NTFSPOOLCHECK)
#define NPagedInit(L,S,T,D) { ExInitializeNPagedLookasideList( (L), NtfsDebugAllocatePoolWithTag, NtfsDebugFreePool, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#define PagedInit(L,S,T,D)  { ExInitializePagedLookasideList(  (L), NtfsDebugAllocatePoolWithTag, NtfsDebugFreePool, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#else   //  DBG && i386
#define NPagedInit(L,S,T,D) { ExInitializeNPagedLookasideList( (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#define PagedInit(L,S,T,D)  { ExInitializePagedLookasideList(  (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#endif  //  DBG && i386

    NPagedInit( &NtfsIoContextLookasideList,   sizeof(NTFS_IO_CONTEXT), 'IftN', IoContextMaxDepth );
    NPagedInit( &NtfsIrpContextLookasideList,  sizeof(IRP_CONTEXT),     'iftN', IrpContextMaxDepth );
    NPagedInit( &NtfsKeventLookasideList,      sizeof(KEVENT),          'KftN', KeventMaxDepth );
    NPagedInit( &NtfsScbNonpagedLookasideList, sizeof(SCB_NONPAGED),    'nftN', ScbNonpagedMaxDepth );
    NPagedInit( &NtfsScbSnapshotLookasideList, sizeof(SCB_SNAPSHOT),    'TftN', ScbSnapshotMaxDepth );

    //
    //  The compresson sync routine needs its own allocate and free routine in order to initialize and
    //  cleanup the embedded resource.
    //

    ExInitializeNPagedLookasideList( &NtfsCompressSyncLookasideList,
                                     NtfsAllocateCompressionSync,
                                     NtfsDeallocateCompressionSync,
                                     0,
                                     sizeof( COMPRESSION_SYNC ),
                                     'vftN',
                                     CompSyncMaxDepth );

    PagedInit(  &NtfsCcbLookasideList,                sizeof(CCB),                 'CftN', CcbMaxDepth );
    PagedInit(  &NtfsCcbDataLookasideList,            sizeof(CCB_DATA),            'cftN', CcbDataMaxDepth );
    PagedInit(  &NtfsDeallocatedRecordsLookasideList, sizeof(DEALLOCATED_RECORDS), 'DftN', DeallocatedRecordsMaxDepth );
    PagedInit(  &NtfsFcbDataLookasideList,            sizeof(FCB_DATA),            'fftN', FcbDataMaxDepth );
    PagedInit(  &NtfsFcbIndexLookasideList,           sizeof(FCB_INDEX),           'FftN', FcbIndexMaxDepth );
    PagedInit(  &NtfsIndexContextLookasideList,       sizeof(INDEX_CONTEXT),       'EftN', IndexContextMaxDepth );
    PagedInit(  &NtfsLcbLookasideList,                sizeof(LCB),                 'lftN', LcbMaxDepth );
    PagedInit(  &NtfsNukemLookasideList,              sizeof(NUKEM),               'NftN', NukemMaxDepth );
    PagedInit(  &NtfsScbDataLookasideList,            SIZEOF_SCB_DATA,             'sftN', ScbDataMaxDepth );

    //
    //  Initialize the cache manager callback routines,  First are the routines
    //  for normal file manipulations, followed by the routines for
    //  volume manipulations.
    //

    {
        PCACHE_MANAGER_CALLBACKS Callbacks = &NtfsData.CacheManagerCallbacks;

        Callbacks->AcquireForLazyWrite = &NtfsAcquireScbForLazyWrite;
        Callbacks->ReleaseFromLazyWrite = &NtfsReleaseScbFromLazyWrite;
        Callbacks->AcquireForReadAhead = &NtfsAcquireScbForReadAhead;
        Callbacks->ReleaseFromReadAhead = &NtfsReleaseScbFromReadAhead;
    }

    {
        PCACHE_MANAGER_CALLBACKS Callbacks = &NtfsData.CacheManagerVolumeCallbacks;

        Callbacks->AcquireForLazyWrite = &NtfsAcquireVolumeFileForLazyWrite;
        Callbacks->ReleaseFromLazyWrite = &NtfsReleaseVolumeFileFromLazyWrite;
        Callbacks->AcquireForReadAhead = NULL;
        Callbacks->ReleaseFromReadAhead = NULL;
    }

    //
    //  Initialize the queue of read ahead threads
    //

    InitializeListHead(&NtfsData.ReadAheadThreads);

    //
    //  Set up global pointer to our process.
    //

    NtfsData.OurProcess = PsGetCurrentProcess();

    //
    //  Use a try-finally to cleanup on errors.
    //

    try {

        SECURITY_DESCRIPTOR NewDescriptor;
        SID_IDENTIFIER_AUTHORITY Authority = SECURITY_NT_AUTHORITY;

        SubjectContext = NtfsAllocatePool( PagedPool, sizeof( SECURITY_SUBJECT_CONTEXT ));
        SeCaptureSubjectContext( SubjectContext );
        CapturedSubjectContext = TRUE;

        //
        //  Build the default security descriptor which gives full access to
        //  system and administrator.
        //

        AdminSid = (PSID) NtfsAllocatePool( PagedPool, RtlLengthRequiredSid( 2 ));
        RtlInitializeSid( AdminSid, &Authority, 2 );
        *(RtlSubAuthoritySid( AdminSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
        *(RtlSubAuthoritySid( AdminSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

        SystemSid = (PSID) NtfsAllocatePool( PagedPool, RtlLengthRequiredSid( 1 ));
        RtlInitializeSid( SystemSid, &Authority, 1 );
        *(RtlSubAuthoritySid( SystemSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

        SystemDaclLength = sizeof( ACL ) +
                           (2 * sizeof( ACCESS_ALLOWED_ACE )) +
                           SeLengthSid( AdminSid ) +
                           SeLengthSid( SystemSid ) +
                           8; // The 8 is just for good measure

        SystemDacl = NtfsAllocatePool( PagedPool, SystemDaclLength );

        Status = RtlCreateAcl( SystemDacl, SystemDaclLength, ACL_REVISION2 );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlAddAccessAllowedAce( SystemDacl,
                                         ACL_REVISION2,
                                         GENERIC_ALL,
                                         SystemSid );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlAddAccessAllowedAce( SystemDacl,
                                         ACL_REVISION2,
                                         GENERIC_ALL,
                                         AdminSid );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlCreateSecurityDescriptor( &NewDescriptor,
                                              SECURITY_DESCRIPTOR_REVISION1 );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlSetDaclSecurityDescriptor( &NewDescriptor,
                                               TRUE,
                                               SystemDacl,
                                               FALSE );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = SeAssignSecurity( NULL,
                                   &NewDescriptor,
                                   &NtfsData.DefaultDescriptor,
                                   FALSE,
                                   SubjectContext,
                                   IoGetFileObjectGenericMapping(),
                                   PagedPool );

        if (!NT_SUCCESS( Status )) { leave; }

        NtfsData.DefaultDescriptorLength = RtlLengthSecurityDescriptor( NtfsData.DefaultDescriptor );

        ASSERT( SeValidSecurityDescriptor( NtfsData.DefaultDescriptorLength,
                                           NtfsData.DefaultDescriptor ));

    } finally {

        if (CapturedSubjectContext) {

            SeReleaseSubjectContext( SubjectContext );
        }

        if (SubjectContext != NULL) { NtfsFreePool( SubjectContext ); }

        if (SystemDacl != NULL) { NtfsFreePool( SystemDacl ); }

        if (AdminSid != NULL) { NtfsFreePool( AdminSid ); }

        if (SystemSid != NULL) { NtfsFreePool( SystemSid ); }
    }

    //
    //  Raise if we hit an error building the security descriptor.
    //

    if (!NT_SUCCESS( Status )) { ExRaiseStatus( Status ); }

    //
    //  Set its node type code and size.  We do this last as a flag to indicate that the structure is
    //  initialized.
    //

    NtfsData.NodeTypeCode = NTFS_NTC_DATA_HEADER;
    NtfsData.NodeByteSize = sizeof(NTFS_DATA);

#ifdef SYSCACHE_DEBUG
    {
        int Index;

        for (Index=0; Index < NUM_SC_LOGSETS; Index++) {
            NtfsSyscacheLogSet[Index].SyscacheLog = 0;
            NtfsSyscacheLogSet[Index].Scb = 0;
        }
        NtfsCurrentSyscacheLogSet = -1;
        NtfsCurrentSyscacheOnDiskEntry = -1;
    }
#endif



    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support routine
//

NTSTATUS
NtfsQueryValueKey (
    IN PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG ValueLength,
    IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
    IN OUT PBOOLEAN DeallocateKeyValue
    )

/*++

Routine Description:

    Given a unicode value name this routine will return the registry
    information for the given key and value.

Arguments:

    KeyName - the unicode name for the key being queried.

    ValueName - the unicode name for the registry value located in the registry.

    ValueLength - On input it is the length of the allocated buffer.  On output
        it is the length of the buffer.  It may change if the buffer is
        reallocated.

    KeyValueInformation - On input it points to the buffer to use to query the
        the value information.  On output it points to the buffer used to
        perform the query.  It may change if a larger buffer is needed.

    DeallocateKeyValue - Indicates if the KeyValueInformation buffer is on the
        stack or needs to be deallocated.

Return Value:

    NTSTATUS - indicates the status of querying the registry.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID NewKey;

    InitializeObjectAttributes( &ObjectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = ZwOpenKey( &Handle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    RequestLength = *ValueLength;


    while (TRUE) {

        Status = ZwQueryValueKey( Handle,
                                  ValueName,
                                  KeyValueFullInformation,
                                  *KeyValueInformation,
                                  RequestLength,
                                  &ResultLength);

        ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (*DeallocateKeyValue) {

                NtfsFreePool( *KeyValueInformation );
                *ValueLength = 0;
                *KeyValueInformation = NULL;
                *DeallocateKeyValue = FALSE;
            }

            RequestLength += 256;

            NewKey = (PKEY_VALUE_FULL_INFORMATION)
                     NtfsAllocatePoolWithTagNoRaise( PagedPool,
                                                     RequestLength,
                                                     'xftN');

            if (NewKey == NULL) {
                return STATUS_NO_MEMORY;
            }

            *KeyValueInformation = NewKey;
            *ValueLength = RequestLength;
            *DeallocateKeyValue = TRUE;

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status)) {

        //
        // Treat as if no value was found if the data length is zero.
        //

        if ((*KeyValueInformation)->DataLength == 0) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    return Status;
}

BOOLEAN
NtfsRunningOnWhat(
    IN USHORT SuiteMask,
    IN UCHAR ProductType
    )

/*++

Routine Description:

    This function checks the system to see if
    NTFS is running on a specified version of
    the operating system.

    The different versions are denoted by the product
    id and the product suite.

Arguments:

    SuiteMask - The mask that specifies the requested suite(s)
    ProductType - The product type that specifies the requested product type

Return Value:

    TRUE if NTFS is running on the requested version
    FALSE otherwise.

--*/

{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    PAGED_CODE();

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = SuiteMask;
    OsVer.wProductType = ProductType;

    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );
    VER_SET_CONDITION( ConditionMask, VER_SUITENAME, VER_AND );

    return RtlVerifyVersionInfo( &OsVer,
                                 VER_PRODUCT_TYPE | VER_SUITENAME,
                                 ConditionMask) == STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfslog.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsLog.h

Abstract:

    This module defines the Ntfs-specific log file structures.

Author:

    Tom Miller      [TomM]          21-Jul-1991

Revision History:

--*/

#ifndef _NTFSLOG_
#define _NTFSLOG_


//
//  The following type defines the Ntfs log operations.
//
//  The comment specifies the record type which follows the record.
//  These record types are defined either here or in ntfs.h.
//

typedef enum _NTFS_LOG_OPERATION {

    Noop =                         0x00, //
    CompensationLogRecord =        0x01, //
    InitializeFileRecordSegment =  0x02, //  FILE_RECORD_SEGMENT_HEADER
    DeallocateFileRecordSegment =  0x03, //
    WriteEndOfFileRecordSegment =  0x04, //  ATTRIBUTE_RECORD_HEADER
    CreateAttribute =              0x05, //  ATTRIBUTE_RECORD_HEADER
    DeleteAttribute =              0x06, //
    UpdateResidentValue =          0x07, //  (value)
    UpdateNonresidentValue =       0x08, //  (value)
    UpdateMappingPairs =           0x09, //  (value = mapping pairs bytes)
    DeleteDirtyClusters =          0x0A, //  array of LCN_RANGE
    SetNewAttributeSizes =         0x0B, //  NEW_ATTRIBUTE_SIZES
    AddIndexEntryRoot =            0x0C, //  INDEX_ENTRY
    DeleteIndexEntryRoot =         0x0D, //  INDEX_ENTRY
    AddIndexEntryAllocation =      0x0E, //  INDEX_ENTRY
    DeleteIndexEntryAllocation =   0x0F, //  INDEX_ENTRY
    WriteEndOfIndexBuffer =        0x10, //  INDEX_ENTRY
    SetIndexEntryVcnRoot =         0x11, //  VCN
    SetIndexEntryVcnAllocation =   0x12, //  VCN
    UpdateFileNameRoot =           0x13, //  DUPLICATED_INFORMATION
    UpdateFileNameAllocation =     0x14, //  DUPLICATED_INFORMATION
    SetBitsInNonresidentBitMap =   0x15, //  BITMAP_RANGE
    ClearBitsInNonresidentBitMap = 0x16, //  BITMAP_RANGE
    HotFix =                       0x17, //
    EndTopLevelAction =            0x18, //
    PrepareTransaction =           0x19, //
    CommitTransaction =            0x1A, //
    ForgetTransaction =            0x1B, //
    OpenNonresidentAttribute =     0x1C, //  OPEN_ATTRIBUTE_ENTRY+ATTRIBUTE_NAME_ENTRY
    OpenAttributeTableDump =       0x1D, //  OPEN_ATTRIBUTE_ENTRY array
    AttributeNamesDump =           0x1E, //  (all attribute names)
    DirtyPageTableDump =           0x1F, //  DIRTY_PAGE_ENTRY array
    TransactionTableDump =         0x20, //  TRANSACTION_ENTRY array
    UpdateRecordDataRoot =         0x21, //  (value)
    UpdateRecordDataAllocation =   0x22  //  (value)

} NTFS_LOG_OPERATION, *PNTFS_LOG_OPERATION;


//
//  The Ntfs log record header precedes every log record written to
//  disk by Ntfs.
//

//
//  Log record header.
//

typedef struct _NTFS_LOG_RECORD_HEADER {

    //
    //  Log Operations (LOG_xxx codes)
    //

    USHORT RedoOperation;
    USHORT UndoOperation;

    //
    //  Offset to Redo record, and its length
    //

    USHORT RedoOffset;
    USHORT RedoLength;

    //
    //  Offset to Undo record, and its length.  Note, for some Redo/Undo
    //  combinations, the expected records may be the same, and thus
    //  these two values will be identical to the above values.
    //

    USHORT UndoOffset;
    USHORT UndoLength;

    //
    //  Open attribute table index to which this update applies.  Index 0 is
    //  always reserved for the MFT itself.  The value of this field
    //  essentially distinguishes two cases for this update, which will be
    //  referred to as MFT update and nonresident attribute update.
    //
    //  MFT updates are for initialization and deletion of file record
    //  segments and updates to resident attributes.
    //
    //  Nonresident attribute updates are used to update attributes which
    //  have been allocated externally to the MFT.
    //

    USHORT TargetAttribute;

    //
    //  Number of Lcns in use at end of header.
    //

    USHORT LcnsToFollow;

    //
    //  Byte offset and Vcn for which this update is to be applied.  If the
    //  TargetAttribute is the MFT, then the Vcn will always be the exact
    //  Vcn of the start of the file record segment being modified, even
    //  if the modification happens to be in a subsequent cluster of the
    //  same file record.  The byte offset in this case is the offset to
    //  the attribute being changed.  For the Mft, AttributeOffset may be used
    //  to represent the offset from the start of the attribute record
    //  at which an update is to be applied.
    //
    //  If the update is to some other (nonresident) attribute, then
    //  TargetVcn and RecordOffset may be used to calculate the reference
    //  point for the update.  The ClusterBlockOffset refers to the number
    //  of 512 byte blocks this structure is from the beginning of the
    //  logged Vcn.
    //
    //  As a bottom line, the exact use of these fields is up to the
    //  writer of this particular log operation, and the associated
    //  restart routines for this attribute.
    //

    USHORT RecordOffset;
    USHORT AttributeOffset;
    USHORT ClusterBlockOffset;
    USHORT Reserved;
    VCN TargetVcn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes log records according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

    //
    //  Immediately following the last run is a log-operation-specific record
    //  whose length may be calculated by subtracting the length of this header
    //  from the length of the entire record returned by LFS.  These records
    //  are defined below.
    //

} NTFS_LOG_RECORD_HEADER, *PNTFS_LOG_RECORD_HEADER;


//
//  RESTART AREA STRUCTURES
//
//  The following structures are present in the Restart Area.
//

//
//  Generic Restart Table
//
//  This is a generic table definition for the purpose of describing one
//  of the three table structures used at Restart: the Open Attribute Table,
//  the Dirty Pages Table, and the Transaction Table.  This simple structure
//  allows for common initialization and free list management.  Allocation
//  and Deallocation and lookup by index are extremely fast, while lookup
//  by value (only performed in the Dirty Pages Table during Restart) is
//  a little slower.  I.e., all accesses to these tables during normal
//  operation are extremely fast.
//
//  If fast access to a table entry by value becomes an issue, then the
//  table may be supplemented by an external Generic Table - it is probably
//  not a good idea to make the Generic Table be part of the structure
//  written to the Log File.
//
//  Entries in a Restart Table should start with:
//
//      ULONG AllocatedOrNextFree;
//
//  An allocated entry will have the pattern RESTART_ENTRY_ALLOCATED
//  in this field.
//

#define RESTART_ENTRY_ALLOCATED          (0xFFFFFFFF)

typedef struct _RESTART_TABLE {

    //
    //  Entry size, in bytes
    //

    USHORT EntrySize;

    //
    //  Total number of entries in table
    //

    USHORT NumberEntries;

    //
    //  Number entries that are allocated
    //

    USHORT NumberAllocated;

    //
    //  Reserved for alignment
    //

    USHORT Reserved[3];

    //
    //  Free goal - Offset after which entries should be freed to end of
    //  list, as opposed to front.  At each checkpoint, the table may be
    //  truncated if there are enough free entries at the end of the list.
    //  Expressed as an offset from the start of this structure.
    //

    ULONG FreeGoal;

    //
    //  First Free entry (head of list) and Last Free entry (used to deallocate
    //  beyond Free Goal).  Expressed as an offset from the start of this
    //  structure.
    //

    ULONG FirstFree;
    ULONG LastFree;

    //
    //  The table itself starts here.
    //

} RESTART_TABLE, *PRESTART_TABLE;

//
//  Macro to get a pointer to an entry in a Restart Table, from the Table
//  pointer and entry index.  NOTE - Don't generate the index in a call
//  to NtfsAllocateRestartTableIndex within this macro.  The macro code 
//  tends to capture the Table pointer before generating the index.  If the
//  table needs to grow then the captured value may be invalid.
//

#define GetRestartEntryFromIndex(TBL,INDX) (    \
    (PVOID)((PCHAR)(TBL)->Table + (INDX))       \
)

//
//  Macro to get an index for an entry in a Restart Table, from the Table
//  pointer and entry pointer.
//

#define GetIndexFromRestartEntry(TBL,ENTRY) (           \
    (ULONG)((PCHAR)(ENTRY) - (PCHAR)(TBL)->Table)       \
)

//
//  Macro to see if an entry in a Restart Table is allocated.
//

#define IsRestartTableEntryAllocated(PTR) (                 \
    (BOOLEAN)(*(PULONG)(PTR) == RESTART_ENTRY_ALLOCATED)    \
)

//
//  Macro to retrieve the size of a Restart Table in bytes.
//

#define SizeOfRestartTable(TBL) (                                   \
    (ULONG)(((TBL)->Table->NumberEntries *                          \
     (TBL)->Table->EntrySize) +                                     \
    sizeof(RESTART_TABLE))                                          \
)

//
//  Macro to see if Restart Table is empty.  It is empty if the
//  number allocated is zero.
//

#define IsRestartTableEmpty(TBL) (!(TBL)->Table->NumberAllocated)

//
//  Macro to see if an index is within the currently allocated size
//  for that table.
//

#define IsRestartIndexWithinTable(TBL,INDX) (               \
    (BOOLEAN)((INDX) < SizeOfRestartTable(TBL))             \
)

//
//  Macros to acquire and release a Restart Table.
//

#define NtfsAcquireExclusiveRestartTable(TBL,WAIT) {        \
    ExAcquireResourceExclusiveLite( &(TBL)->Resource,(WAIT));   \
}

#define NtfsAcquireSharedStartExRestartTable(TBL,WAIT) {        \
    ExAcquireSharedStarveExclusive( &(TBL)->Resource,(WAIT));   \
}

#define NtfsAcquireSharedRestartTable(TBL,WAIT) {           \
    ExAcquireResourceSharedLite( &(TBL)->Resource,(WAIT));      \
}

#define NtfsReleaseRestartTable(TBL) {                      \
    ExReleaseResourceLite(&(TBL)->Resource);                    \
}

//
//  Define some tuning parameters to keep the restart tables a
//  reasonable size.
//

#define INITIAL_NUMBER_TRANSACTIONS      (5)
#define HIGHWATER_TRANSACTION_COUNT      (10)
#define INITIAL_NUMBER_ATTRIBUTES        (8)
#define HIGHWATER_ATTRIBUTE_COUNT        (16)

//
//  Attribute Name Entry.  This is a simple structure used to store
//  all of the attribute names for the Open Attribute Table during
//  checkpoint processing.  The Attribute Names record written to the log
//  is a series of Attribute Name Entries terminated by an entry with
//  Index == NameLength == 0.  The end of the table may be tested for by
//  looking for either of these fields to be 0, as 0 is otherwise invalid
//  for both.
//
//  Note that the size of this structure is equal to the overhead for storing
//  an attribute name in the table, including the UNICODE_NULL.
//

typedef struct _ATTRIBUTE_NAME_ENTRY {

    //
    //  Index for Attibute with this name in the Open Attribute Table.
    //

    USHORT Index;

    //
    //  Length of attribute name to follow in bytes, including a terminating
    //  UNICODE_NULL.
    //

    USHORT NameLength;

    //
    //  Start of attribute name
    //

    WCHAR Name[1];

} ATTRIBUTE_NAME_ENTRY, *PATTRIBUTE_NAME_ENTRY;

//
//  Open Attribute Table.  This is the on-disk structure for version 0.
//
//  One entry exists in the Open Attribute Table for each nonresident
//  attribute of each file that is open with modify access.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_ATTRIBUTE_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

#pragma pack(4)

typedef struct _OPEN_ATTRIBUTE_ENTRY_V0 {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Placeholder for Scb in V0.  We use it to point to the index
    //  in the in-memory structure.
    //

    ULONG OatIndex;

    //
    //  File Reference of file containing attribute.
    //

    FILE_REFERENCE FileReference;

    //
    //  Lsn of OpenNonresidentAttribute log record, to distinguish reuses
    //  of this open file record.  Log records referring to this Open
    //  Attribute Entry Index, but with Lsns  older than this field, can
    //  only occur when the attribute was subsequently deleted - these
    //  log records can be ignored.
    //

    LSN LsnOfOpenRecord;

    //
    //  Flag to say if dirty pages seen for this attribute during dirty
    //  page scan.
    //

    BOOLEAN DirtyPagesSeen;

    //
    //  Flag to indicate if the pointer in Overlay above is to an Scb or
    //  attribute name.  It is only used during restart when cleaning up
    //  the open attribute table.
    //

    BOOLEAN AttributeNamePresent;

    //
    //  Reserved for alignment
    //

    UCHAR Reserved[2];

    //
    //  The following two fields identify the actual attribute
    //  with respect to its file.   We identify the attribute by
    //  its type code and name.  When the Restart Area is written,
    //  all of the names for all of the open attributes are temporarily
    //  copied to the end of the Restart Area.
    //  The name is not used on disk but must be a 64-bit value.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    LONGLONG AttributeName;

    //
    //  This field is only relevant to indices, i.e., if AttributeTypeCode
    //  above is $INDEX_ALLOCATION.
    //

    ULONG BytesPerIndexBuffer;

} OPEN_ATTRIBUTE_ENTRY_V0, *POPEN_ATTRIBUTE_ENTRY_V0;

#pragma pack()

#define SIZEOF_OPEN_ATTRIBUTE_ENTRY_V0 (                                \
    FIELD_OFFSET( OPEN_ATTRIBUTE_ENTRY_V0, BytesPerIndexBuffer ) + 4    \
)

//
//  Auxiliary OpenAttribute data.  This is the data that doesn't need to be
//  logged.
//

typedef struct OPEN_ATTRIBUTE_DATA {

    //
    //  Queue of these structures attached to the Vcb.
    //  NOTE - This must be the first entry in this structure.
    //

    LIST_ENTRY Links;

    //
    //  Index for this entry in the On-disk open attribute table.
    //

    ULONG OnDiskAttributeIndex;

    BOOLEAN AttributeNamePresent;

    //
    //  The following overlay either contains an optional pointer to an
    //  Attribute Name Entry from the Analysis Phase of Restart, or a
    //  pointer to an Scb once attributes have been open and in the normal
    //  running system.
    //
    //  Specifically, after the Analysis Phase of Restart:
    //
    //      AttributeName == NULL if there is no attribute name, or the
    //                       attribute name was captured in the Attribute
    //                       Names Dump in the last successful checkpoint.
    //      AttributeName != NULL if an OpenNonresidentAttribute log record
    //                       was encountered, and an Attribute Name Entry
    //                       was allocated at that time (and must be
    //                       deallocated when no longer needed).
    //
    //  Once the Nonresident Attributes have been opened during Restart,
    //  and in the running system, this is an Scb pointer.
    //

    union {
        PWSTR AttributeName;
        PSCB Scb;
    } Overlay;

    //
    //  Store the unicode string for the attribute name.
    //

    UNICODE_STRING AttributeName;

} OPEN_ATTRIBUTE_DATA, *POPEN_ATTRIBUTE_DATA;

//
//  Open Attribute Table.  This is the on-disk structure for version 1 and
//  it is the version we always use in-memory.
//
//  One entry exists in the Open Attribute Table for each nonresident
//  attribute of each file that is open with modify access.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_ATTRIBUTE_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _OPEN_ATTRIBUTE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  This field is only relevant to indices, i.e., if AttributeTypeCode
    //  above is $INDEX_ALLOCATION.
    //

    ULONG BytesPerIndexBuffer;

    //
    //  The following two fields identify the actual attribute
    //  with respect to its file.   We identify the attribute by
    //  its type code and name.  When the Restart Area is written,
    //  all of the names for all of the open attributes are temporarily
    //  copied to the end of the Restart Area.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;

    //
    //  Flag to say if dirty pages seen for this attribute during dirty
    //  page scan.
    //

    BOOLEAN DirtyPagesSeen;
    CHAR Unused[3];

    //
    //  File Reference of file containing attribute.
    //

    FILE_REFERENCE FileReference;

    //
    //  Lsn of OpenNonresidentAttribute log record, to distinguish reuses
    //  of this open file record.  Log records referring to this Open
    //  Attribute Entry Index, but with Lsns  older than this field, can
    //  only occur when the attribute was subsequently deleted - these
    //  log records can be ignored.
    //

    LSN LsnOfOpenRecord;

    //
    //  Point to the OpenAttribute data.
    //

    union {

        POPEN_ATTRIBUTE_DATA OatData;
        ULONGLONG Alignment;
    };

} OPEN_ATTRIBUTE_ENTRY, *POPEN_ATTRIBUTE_ENTRY;

//
//  VOID
//  NtfsFreeAllOpenAttributeData (
//      IN PVCB vCB
//      );
//

#define NtfsFreeAllOpenAttributeData(V) {                                               \
    while (!IsListEmpty( &(V)->OpenAttributeData )) {                                   \
        POPEN_ATTRIBUTE_DATA _Next = CONTAINING_RECORD( (V)->OpenAttributeData.Flink,   \
                                                        OPEN_ATTRIBUTE_DATA,            \
                                                        Links );                        \
        NtfsFreeOpenAttributeData( _Next );                                             \
    }                                                                                   \
}

//
//  Dirty Pages Table - Version 0
//
//  This entry is for restart version 0.  It is inadvertently misaligned.
//
//  One entry exists in the Dirty Pages Table for each page which is
//  dirty at the time the Restart Area is written.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_DIRTY_PAGES_TABLE_SIZE or the size of the table in the log file.
//  It is *not* maintained in the running system.
//

#pragma pack(4)

typedef struct _DIRTY_PAGE_ENTRY_V0 {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Target attribute index.  This is the index into the Open Attribute
    //  Table to which this dirty page entry applies.
    //

    ULONG TargetAttribute;

    //
    //  Length of transfer, in case this is the end of file, and we cannot
    //  write an entire page.
    //

    ULONG LengthOfTransfer;

    //
    //  Number of Lcns in the array at end of this structure.  See comment
    //  with this array.
    //

    ULONG LcnsToFollow;

    //
    //  Reserved for alignment
    //

    ULONG Reserved;

    //
    //  Vcn of dirty page.
    //

    VCN Vcn;

    //
    //  OldestLsn for log record for which the update has not yet been
    //  written through to disk.
    //

    LSN OldestLsn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes pages according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

} DIRTY_PAGE_ENTRY_V0, *PDIRTY_PAGE_ENTRY_V0;

#pragma pack()

//
//  Dirty Pages Table - Version 1
//
//  This version correctly aligns the 64-bit fields.
//
//  One entry exists in the Dirty Pages Table for each page which is
//  dirty at the time the Restart Area is written.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_DIRTY_PAGES_TABLE_SIZE or the size of the table in the log file.
//  It is *not* maintained in the running system.
//

typedef struct _DIRTY_PAGE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Target attribute index.  This is the index into the Open Attribute
    //  Table to which this dirty page entry applies.
    //

    ULONG TargetAttribute;

    //
    //  Length of transfer, in case this is the end of file, and we cannot
    //  write an entire page.
    //

    ULONG LengthOfTransfer;

    //
    //  Number of Lcns in the array at end of this structure.  See comment
    //  with this array.
    //

    ULONG LcnsToFollow;

    //
    //  Vcn of dirty page.
    //

    VCN Vcn;

    //
    //  OldestLsn for log record for which the update has not yet been
    //  written through to disk.
    //

    LSN OldestLsn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes pages according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

} DIRTY_PAGE_ENTRY, *PDIRTY_PAGE_ENTRY;

//
//  Transaction Table
//
//  One transaction entry exists for each existing transaction at the time
//  the Restart Area is written.
//
//  Currently only local transactions are supported, and the transaction
//  ID is simply used to index into this table.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_TRANSACTION_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _TRANSACTION_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Transaction State
    //

    UCHAR TransactionState;

    //
    //  Reserved for proper alignment
    //

    UCHAR Reserved[3];

    //
    //  First Lsn for transaction.  This tells us how far back in the log
    //  we may have to read to abort the transaction.
    //

    LSN FirstLsn;

    //
    //  PreviousLsn written for the transaction and UndoNextLsn (next record
    //  which should be undone in the event of a rollback.
    //

    LSN PreviousLsn;
    LSN UndoNextLsn;

    //
    //  Number of of undo log records pending abort, and total undo size.
    //

    ULONG UndoRecords;
    LONG UndoBytes;

} TRANSACTION_ENTRY, *PTRANSACTION_ENTRY;

//
//  Restart record
//
//  The Restart record used by NTFS is small, and it only describes where
//  the above information has been written to the log.  The above records
//  may be considered logically part of NTFS's restart area.
//

typedef struct _RESTART_AREA {

    //
    //  Version numbers of NTFS Restart Implementation
    //

    ULONG MajorVersion;
    ULONG MinorVersion;

    //
    //  Lsn of Start of Checkpoint.  This is the Lsn at which the Analysis
    //  Phase of Restart must begin.
    //

    LSN StartOfCheckpoint;

    //
    //  Lsns at which the four tables above plus the attribute names reside.
    //

    LSN OpenAttributeTableLsn;
    LSN AttributeNamesLsn;
    LSN DirtyPageTableLsn;
    LSN TransactionTableLsn;

    //
    //  Lengths of the above structures in bytes.
    //

    ULONG OpenAttributeTableLength;
    ULONG AttributeNamesLength;
    ULONG DirtyPageTableLength;
    ULONG TransactionTableLength;

    //
    //  Oldest Usn from which scan must occur to pickup all files which
    //  have not been through cleanup.
    //

    USN LowestOpenUsn;

    LSN CurrentLsnAtMount;
    ULONG BytesPerCluster;

    ULONG Reserved;

    //
    //  Keep some additional information about the Usn journal so we
    //  can reduce the amount of caching we do.
    //

    FILE_REFERENCE UsnJournalReference;
    LONGLONG UsnCacheBias;

} RESTART_AREA, *PRESTART_AREA;

//
//  This symbols is used to accept Restart Areas with or without the OldestUsn
//

#define SIZEOF_OLD_RESTART_AREA          (FIELD_OFFSET( RESTART_AREA, LowestOpenUsn ))


//
//  RECORD STRUCTURES USED BY LOG RECORDS
//

//
//  Set new attribute sizes
//

typedef struct _NEW_ATTRIBUTE_SIZES {

    LONGLONG AllocationSize;
    LONGLONG ValidDataLength;
    LONGLONG FileSize;
    LONGLONG TotalAllocated;

} NEW_ATTRIBUTE_SIZES, *PNEW_ATTRIBUTE_SIZES;

#define SIZEOF_FULL_ATTRIBUTE_SIZES (                   \
    sizeof( NEW_ATTRIBUTE_SIZES )                       \
)

#define SIZEOF_PARTIAL_ATTRIBUTE_SIZES (                \
    FIELD_OFFSET( NEW_ATTRIBUTE_SIZES, TotalAllocated ) \
)

//
//  Describe a bitmap range
//

typedef struct _BITMAP_RANGE {

    ULONG BitMapOffset;
    ULONG NumberOfBits;

} BITMAP_RANGE, *PBITMAP_RANGE;

//
//  Describe a range of Lcns
//

typedef struct _LCN_RANGE {

    LCN StartLcn;
    LONGLONG Count;

} LCN_RANGE, *PLCN_RANGE;

#endif //  _NTFSLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\objidsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ObjIdSup.c

Abstract:

    This module implements the object id support routines for Ntfs

Author:

    Keith Kaplan     [KeithKa]        27-Jun-1996

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_OBJIDSUP)


//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('OFtN')

//
//  Local define for number of times to attempt to generate a unique object id.
//

#define NTFS_MAX_OBJID_RETRIES  16

NTSTATUS
NtfsSetObjectIdExtendedInfoInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PUCHAR ExtendedInfoBuffer
    );

VOID
NtfsGetIdFromGenerator (
    OUT PFILE_OBJECTID_BUFFER ObjectId
    );

NTSTATUS
NtfsSetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PFILE_OBJECTID_BUFFER ObjectIdBuffer
    );

NTSTATUS
NtfsDeleteObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN BOOLEAN DeleteFileAttribute
    );

VOID
NtfsGetIdFromGenerator (
    OUT PFILE_OBJECTID_BUFFER ObjectId
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCreateOrGetObjectId)
#pragma alloc_text(PAGE, NtfsDeleteObjectId)
#pragma alloc_text(PAGE, NtfsDeleteObjectIdInternal)
#pragma alloc_text(PAGE, NtfsGetIdFromGenerator)
#pragma alloc_text(PAGE, NtfsGetObjectId)
#pragma alloc_text(PAGE, NtfsGetObjectIdExtendedInfo)
#pragma alloc_text(PAGE, NtfsGetObjectIdInternal)
#pragma alloc_text(PAGE, NtfsInitializeObjectIdIndex)
#pragma alloc_text(PAGE, NtfsSetObjectId)
#pragma alloc_text(PAGE, NtfsSetObjectIdExtendedInfo)
#pragma alloc_text(PAGE, NtfsSetObjectIdExtendedInfoInternal)
#pragma alloc_text(PAGE, NtfsSetObjectIdInternal)
#endif


VOID
NtfsInitializeObjectIdIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the object id index for the volume.  If the index does not
    exist it is created and initialized.  We also look up the volume's object id,
    if any, in this routine.

Arguments:

    Fcb - Pointer to Fcb for the object id file.

    Vcb - Volume control block for volume being mounted.

Return Value:

    None

--*/

{
    NTSTATUS Status;
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$O" );
    FILE_OBJECTID_BUFFER ObjectId;

    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        Status = NtOfsCreateIndex( IrpContext,
                                   Fcb,
                                   IndexName,
                                   CREATE_OR_OPEN,
                                   0,
                                   COLLATION_NTOFS_ULONGS,
                                   NtOfsCollateUlongs,
                                   NULL,
                                   &Vcb->ObjectIdTableScb );

        if (NT_SUCCESS( Status )) {

            //
            //  We were able to create the index, now let's see if the volume has an object id.
            //

            Status = NtfsGetObjectIdInternal( IrpContext,
                                              Vcb->VolumeDasdScb->Fcb,
                                              FALSE,
                                              &ObjectId );

            if (NT_SUCCESS( Status )) {

                //
                //  The volume does indeed have an object id, so copy it into the Vcb
                //  and set the appropriate flag.
                //

                RtlCopyMemory( Vcb->VolumeObjectId,
                               &ObjectId.ObjectId,
                               OBJECT_ID_KEY_LENGTH );

                SetFlag( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID );
            }
        }

    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );
    }
}


NTSTATUS
NtfsSetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine associates an object id with a file.  If the object id is already
    in use on the volume we return STATUS_DUPLICATE_NAME.  If the file already has
    an object id, we return STATUS_OBJECT_NAME_COLLISION.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_INVALID;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (!(((TypeOfOpen == UserFileOpen) || (TypeOfOpen == UserDirectoryOpen)) &&
          (IrpSp->Parameters.FileSystemControl.InputBufferLength == sizeof( FILE_OBJECTID_BUFFER )))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Read only volumes stay read only.
    //
    
    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );       
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Only a restore operator or the I/O system (using its private irp minor code)
        //  is allowed to set an arbitrary object id.
        //

        if ((FlagOn( Ccb->AccessFlags, RESTORE_ACCESS )) ||
            (IrpSp->MinorFunction == IRP_MN_KERNEL_CALL)) {

            Status = NtfsSetObjectIdInternal( IrpContext,
                                              Fcb,
                                              Vcb,
                                              (PFILE_OBJECTID_BUFFER) Irp->AssociatedIrp.SystemBuffer );
                                              
            //
            //  Remember to update the timestamps.
            //

            if (NT_SUCCESS( Status )) {
                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
            }
        
        } else {

            Status = STATUS_ACCESS_DENIED;
        }

    } finally {

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsSetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the extended info for a file which already has an object
    id.  If the file does not yet have an object id, we return a status other
    than STATUS_SUCCESS.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_INVALID;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );
    if (!(((TypeOfOpen == UserFileOpen) || (TypeOfOpen == UserDirectoryOpen)) &&
          (IrpSp->Parameters.FileSystemControl.InputBufferLength == OBJECT_ID_EXT_INFO_LENGTH))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Read only volumes stay read only.
    //
    
    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );       
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Setting extended info requires either write access or else it has 
        //  to be the I/O system using its private irp minor code.
        //
        
        if ((FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )) ||
            (IrpSp->MinorFunction == IRP_MN_KERNEL_CALL)) {
            
            Status = NtfsSetObjectIdExtendedInfoInternal( IrpContext,
                                                          Fcb,
                                                          Vcb,
                                                          (PUCHAR) Irp->AssociatedIrp.SystemBuffer );

            //
            //  Remember to update the timestamps.
            //

            if (NT_SUCCESS( Status )) {
                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
            }
            
        } else {

            Status = STATUS_ACCESS_DENIED;
        }
        
    } finally {

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsSetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PFILE_OBJECTID_BUFFER ObjectIdBuffer
    )

/*++

Routine Description:

    This routine associates an object id with a file.  If the object id is already
    in use on the volume we return STATUS_DUPLICATE_NAME.  If the file already has
    an object id, we return STATUS_OBJECT_NAME_COLLISION.

Arguments:

    Fcb - The file to associate with the object id.

    Vcb - The volume whose object id index the entry should be added to.

    ObjectIdBuffer - Supplies both the object id and the extended info.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_INVALID;

    NTFS_OBJECTID_INFORMATION ObjectIdInfo;
    FILE_OBJECTID_INFORMATION FileObjectIdInfo;

    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN InitializedAttributeContext = FALSE;
    BOOLEAN AcquiredPaging = FALSE;

    try {

        RtlZeroMemory( &ObjectIdInfo,
                       sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlCopyMemory( &ObjectIdInfo.FileSystemReference,
                       &Fcb->FileReference,
                       sizeof( FILE_REFERENCE ) );

        RtlCopyMemory( ObjectIdInfo.ExtendedInfo,
                       ObjectIdBuffer->ExtendedInfo,
                       OBJECT_ID_EXT_INFO_LENGTH );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        return STATUS_INVALID_ADDRESS;
    }

    //
    //  Acquire the file we're setting the object id on.  Main blocks
    //  anybody else from deleting the file or setting another object
    //  id behind our backs.  Paging blocks collided flushes if we have to convert
    //  another (data) attribute to be non-resident. 
    // 
    //  Don't use AcquireFcbWithPaging because
    //  it can't recursively acquire paging and we come in often with it
    //  preacquired
    //

    if (Fcb->PagingIoResource != NULL) {
        ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
        AcquiredPaging = TRUE;
    }
    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
                              
    try {
                    
        //
        //  if there is now a paging resource release main and grab both
        //  This is the case for a named data stream in a directory created between our
        //  unsafe test and owning the main
        //  Note: if we already owned main before entrance this could never happen. So we can just drop
        //  and not worry about still owning main and taking paging
        //

        if (!AcquiredPaging && (Fcb->PagingIoResource != NULL)) {
            NtfsReleaseFcb( IrpContext, Fcb );
            ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
            AcquiredPaging = TRUE;
            NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
        }

        if (!IsListEmpty( &Fcb->ScbQueue )) {
            PSCB Scb;
            
            Scb = CONTAINING_RECORD( Fcb->ScbQueue.Flink, SCB, FcbLinks );
            ASSERT( Scb->Header.Resource == Fcb->Resource );
            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }
        }

        //
        //  Post the change to the Usn Journal (on errors change is backed out).
        //  We dont' want to do this if we've been called because create is
        //  trying to set an object id from the tunnel cache, since we can't
        //  call the Usn package yet, since the file record doesn't have a file
        //  name yet.
        //

        if (IrpContext->MajorFunction != IRP_MJ_CREATE) {

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_OBJECT_ID_CHANGE );
        }

        //
        //  Make sure the file doesn't already have an object id.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        InitializedAttributeContext = TRUE;

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $OBJECT_ID,
                                       &AttributeContext )) {

            try_return( Status = STATUS_OBJECT_NAME_COLLISION );
        }

        //
        //  Add ObjectId to the index, associate it with this file.
        //

        IndexKey.Key = ObjectIdBuffer->ObjectId;
        IndexKey.KeyLength = OBJECT_ID_KEY_LENGTH;
        IndexRow.KeyPart = IndexKey;

        IndexRow.DataPart.DataLength = sizeof( ObjectIdInfo );
        IndexRow.DataPart.Data = &ObjectIdInfo;

        //
        //  NtOfsAddRecords may raise if the object id isn't unique.
        //

        NtOfsAddRecords( IrpContext,
                         Vcb->ObjectIdTableScb,
                         1,          // adding one record to the index
                         &IndexRow,
                         FALSE );    // sequential insert

        //
        //  Now add the objectid attribute to the file.  Notice that
        //  we do _not_ log this operation if we're within a create
        //  operation, i.e. if we're restoring an object id from the
        //  tunnel cache.  The create path has its own logging scheme
        //  that we don't want to interfere with.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

        NtfsCreateAttributeWithValue( IrpContext,
                                      Fcb,
                                      $OBJECT_ID,
                                      NULL,
                                      ObjectIdBuffer->ObjectId,
                                      OBJECT_ID_KEY_LENGTH,
                                      0,
                                      NULL,
                                      (BOOLEAN)(IrpContext->MajorFunction != IRP_MJ_CREATE),
                                      &AttributeContext );


        ASSERT( IrpContext->TransactionId != 0 );

        //
        //  Notify anybody who's interested.
        //

        if (Vcb->ViewIndexNotifyCount != 0) {

            //
            //  The FRS field is only populated for the notification of a failed
            //  object id restore from the tunnel cache.
            //

            FileObjectIdInfo.FileReference = 0L;

            RtlCopyMemory( FileObjectIdInfo.ObjectId,
                           ObjectIdBuffer->ObjectId,
                           OBJECT_ID_KEY_LENGTH );

            RtlCopyMemory( FileObjectIdInfo.ExtendedInfo,
                           ObjectIdBuffer->ExtendedInfo,
                           OBJECT_ID_EXT_INFO_LENGTH );

            NtfsReportViewIndexNotify( Vcb,
                                       Vcb->ObjectIdTableScb->Fcb,
                                       FILE_NOTIFY_CHANGE_FILE_NAME,
                                       FILE_ACTION_ADDED,
                                       &FileObjectIdInfo,
                                       sizeof(FILE_OBJECTID_INFORMATION) );
        }

        //
        //  If we made it this far and didn't have to jump into the
        //  finally clause yet, all must have gone well.
        //

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        if (AcquiredPaging) {
            ExReleaseResourceLite( Fcb->PagingIoResource );
        }
        NtfsReleaseFcb( IrpContext, Fcb );

        if (InitializedAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }

    return Status;
}


NTSTATUS
NtfsCreateOrGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine generates a new object id, if possible, for a given file.  It is
    different from NtfsSetObjectId in that it does not take an object id as an
    input, rather it calls a routine to generate one.  If the file already has
    an object id, that existing object id is returned.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.
               STATUS_DUPLICATE_NAME if we are unable to generate a unique id
                 in NTFS_MAX_OBJID_RETRIES retries.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_OBJECTID_BUFFER ObjectId;
    FILE_OBJECTID_BUFFER *OutputBuffer;

    ULONG RetryCount = 0;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This only works for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in the
    //  irp first, then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        OutputBuffer = (FILE_OBJECTID_BUFFER *)Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        OutputBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (OutputBuffer == NULL) {
            
            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ObjectId)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Get this file exlusively so we know nobody else is trying
        //  to do this at the same time.  At this point the irpcontext flag
        //  is not set so paging is not acquired.
        //

        NtfsAcquireFcbWithPaging( IrpContext, Fcb, 0 );

        //
        //  Let's make sure the volume is still mounted.
        //
        
        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        DebugTrace( +1, Dbg, ("NtfsCreateOrGetObjectId\n") );
        
        //
        //  If this file already has an object id, let's return it.  Doing this
        //  first saves a (possibly expensive) call to NtfsGetIdFromGenerator.
        //

        Status = NtfsGetObjectIdInternal( IrpContext, Fcb, TRUE, OutputBuffer );

        if (Status == STATUS_OBJECTID_NOT_FOUND) {

            DebugTrace( 0, Dbg, ("File has no oid, we have to generate one\n") );

            //
            //  We want to keep retrying if the object id generator returns a
            //  duplicate name.  If we have success, or any other error, we
            //  should stop trying.  For instance, if we fail because the file
            //  already has an object id, retrying is just a waste of time.
            //  We also need some sane limit on the number of times we retry
            //  this operation.
            //

            do {

                RetryCount += 1;

                //
                //  Drop this file so we don't deadlock in the guid generator.
                //

                ASSERT( 0 == IrpContext->TransactionId );
                NtfsReleaseFcbWithPaging( IrpContext, Fcb ); 

                DebugTrace( 0, Dbg, ("Calling oid generator\n") );
                NtfsGetIdFromGenerator( &ObjectId );

                //
                //  Reacquire the file so we know nobody else is trying to do 
                //  this at the same time. SetObjIdInternal acquires both so we need to
                //  do the same
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
                NtfsAcquireFcbWithPaging( IrpContext, Fcb, 0 );
                
                //
                //  Make sure we didn't miss a dismount.
                //
                
                if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    try_return( Status = STATUS_VOLUME_DISMOUNTED );
                }
        
                //
                //  Let's make sure this file didn't get an object id assigned to it
                //  while we weren't holding the Fcb above.  
                //

                Status = NtfsGetObjectIdInternal( IrpContext, Fcb, TRUE, OutputBuffer );

                if (Status == STATUS_OBJECTID_NOT_FOUND) {

                    if (NtfsIsVolumeReadOnly( Vcb )) {

                        try_return( Status = STATUS_MEDIA_WRITE_PROTECTED );
                    }
                    
                    DebugTrace( 0, Dbg, ("File still has no oid, attempting to set generated one\n") );
                    
                    //
                    //  The object id generator only generates the indexed part, so
                    //  we need to fill in the rest of the 'birth id' now.  Note that if
                    //  the volume has no object id, we're relying on the Vcb creation
                    //  code to zero init the Vcb->VolumeObjectId for us.  The net result
                    //  is right -- we get zeroes in the volume id part of the extended
                    //  info if the volume has no object id.
                    //

                    RtlCopyMemory( &ObjectId.BirthVolumeId,
                                   Vcb->VolumeObjectId,
                                   OBJECT_ID_KEY_LENGTH );

                    RtlCopyMemory( &ObjectId.BirthObjectId,
                                   &ObjectId.ObjectId,
                                   OBJECT_ID_KEY_LENGTH );

                    RtlZeroMemory( &ObjectId.DomainId,
                                   OBJECT_ID_KEY_LENGTH );

                    Status = NtfsSetObjectIdInternal( IrpContext,
                                                      Fcb,
                                                      Vcb,
                                                      &ObjectId );

                    if (Status == STATUS_SUCCESS) {

                        DebugTrace( 0, Dbg, ("Successfully set generated oid\n") );
                        
                        //
                        //  We have successfully generated and set an object id for this
                        //  file, so we need to tell our caller what that id is.
                        //

                        RtlCopyMemory( OutputBuffer,
                                       &ObjectId,
                                       sizeof(ObjectId) );
                                       
                        //
                        //  Let's also remember to update the timestamps.
                        //

                        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );                
                    }                
                }
                
            } while ((Status == STATUS_DUPLICATE_NAME) &&
                     (RetryCount <= NTFS_MAX_OBJID_RETRIES));
                     
        } else if (Status == STATUS_SUCCESS) {

            //
            //  If we found an ID, make sure it isn't a partially formed id with
            //  an all zero extended info.  If it's partially formed, we'll generate
            //  extended info now.
            //

            if (RtlCompareMemory( (PUCHAR)&OutputBuffer->ExtendedInfo, &NtfsZeroExtendedInfo, sizeof(ObjectId.ExtendedInfo)) == sizeof(ObjectId.ExtendedInfo)) {

                RtlCopyMemory( &OutputBuffer->BirthVolumeId,
                               Vcb->VolumeObjectId,
                               OBJECT_ID_KEY_LENGTH );

                RtlCopyMemory( &OutputBuffer->BirthObjectId,
                               &OutputBuffer->ObjectId,
                               OBJECT_ID_KEY_LENGTH );
                               
                Status = NtfsSetObjectIdExtendedInfoInternal( IrpContext,                                                                            
                                                              Fcb,
                                                              Vcb,
                                                              (PUCHAR) &OutputBuffer->ExtendedInfo );
            }
        }

        if (Status == STATUS_SUCCESS) {

            //
            //  If we found an existing id for the file, or managed to generate one
            //  ourselves, we need to set the size in the information field so the 
            //  rdr can handle this operation correctly.
            //

            IrpContext->OriginatingIrp->IoStatus.Information = sizeof( ObjectId );
        }

    try_exit: NOTHING;
    } finally {
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsCreateOrGetObjectId -> %08lx\n", Status) );
    return Status;
}


NTSTATUS
NtfsGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine finds the object id, if any, for a given file.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_OBJECTID_BUFFER *OutputBuffer;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );
    
    //
    //  This only works for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in the
    //  irp first, then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        OutputBuffer = (FILE_OBJECTID_BUFFER *)Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        OutputBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (OutputBuffer == NULL) {
            
            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(FILE_OBJECTID_BUFFER)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    try {

        //
        //  Call the function that does the real work.
        //

        Status = NtfsGetObjectIdInternal( IrpContext, Fcb, TRUE, OutputBuffer );

        if (NT_SUCCESS( Status )) {

            //
            //  And set the size in the information field so the rdr
            //  can handle this correctly.
            //

            IrpContext->OriginatingIrp->IoStatus.Information = sizeof( FILE_OBJECTID_BUFFER );
        }

    } finally {

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsGetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN GetExtendedInfo,
    OUT FILE_OBJECTID_BUFFER *OutputBuffer
    )

/*++

Routine Description:

    Internal function to find the object id, if any, for a given file.  Called
    in response to the user's ioctl and by NtfsDeleteObjectIdInternal.

Arguments:

    Fcb - The file whose object id we need to look up.

    GetExtendedInfo - If TRUE, we also copy the object id's extended information
                      to the OutputBuffer, otherwise we only copy the object id
                      itself.  For instance, NtfsDeleteObjectIdInternal is not
                      interested in the extended info -- it only needs to know
                      which object id to delete from the index.

    OutputBuffer - Where to store the object id (and optionally, extended info)
                   if an object id is found.

Return Value:

    NTSTATUS - The return status for the operation.
               STATUS_OBJECT_NAME_NOT_FOUND if the file does not have an object id.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    UCHAR *ObjectId;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN InitializedAttributeContext = FALSE;

    if ((OutputBuffer == NULL) ||
        (OutputBuffer->ObjectId == NULL)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the file we're getting the object id for.  We don't
    //  want anybody else deleting the file or setting an object
    //  id behind our backs.
    //

    NtfsAcquireSharedFcb( IrpContext, Fcb, NULL, 0 );


    try {

        if (!IsListEmpty( &Fcb->ScbQueue )) {
            PSCB Scb;
    
            Scb = CONTAINING_RECORD( Fcb->ScbQueue.Flink, SCB, FcbLinks );
            ASSERT( Scb->Header.Resource == Fcb->Resource );
            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }
        }

        //
        //  Make sure the file has an object id.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        InitializedAttributeContext = TRUE;

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $OBJECT_ID,
                                       &AttributeContext )) {
            //
            //  Prepare the object id to be returned
            //

            ObjectId = (UCHAR *) NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            RtlCopyMemory( &OutputBuffer->ObjectId,
                           ObjectId,
                           OBJECT_ID_KEY_LENGTH );

            if (GetExtendedInfo) {

                Status = NtfsGetObjectIdExtendedInfo( IrpContext,
                                                      Fcb->Vcb,
                                                      ObjectId,
                                                      OutputBuffer->ExtendedInfo );
            }

        } else {

            //
            //  This file has no object id.
            //

            Status = STATUS_OBJECTID_NOT_FOUND;
        }

    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );

        if (InitializedAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }

    return Status;
}


NTSTATUS
NtfsGetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR *ObjectId,
    IN OUT UCHAR *ExtendedInfo
    )

/*++

Routine Description:

    This routine finds the extended info stored with a given object id.

Arguments:

    Vcb - Supplies the volume whose object id index should be searched.

    ObjectId - Supplies the object id to lookup in the index.

    ExtendedInfo - Where to store the extended info.  Must be a buffer with
                   room for OBJECT_ID_EXT_INFO_LENGTH UCHARs.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    MAP_HANDLE MapHandle;

    BOOLEAN InitializedMapHandle = FALSE;
    BOOLEAN IndexAcquired = FALSE;

    try {

        //
        //  Now look for object id in the index so we can return the
        //  extended info.
        //

        IndexKey.Key = ObjectId;
        IndexKey.KeyLength = OBJECT_ID_KEY_LENGTH;

        NtOfsInitializeMapHandle( &MapHandle );
        InitializedMapHandle = TRUE;

        //
        //  Acquire the object id index before doing the lookup.
        //  We need to make sure the file is acquired first to prevent
        //  a possible deadlock.
        //

        // **** ASSERT_EXCLUSIVE_FCB( Fcb ); ****

        //
        //  We shouldn't try to get the object id index while holding the Mft.
        //

        ASSERT( !NtfsIsExclusiveScb( Vcb->MftScb ) ||
                NtfsIsSharedScb( Vcb->ObjectIdTableScb ) );

        NtfsAcquireSharedScb( IrpContext, Vcb->ObjectIdTableScb );
        IndexAcquired = TRUE;

        if ( NtOfsFindRecord( IrpContext,
                              Vcb->ObjectIdTableScb,
                              &IndexKey,
                              &IndexRow,
                              &MapHandle,
                              NULL) != STATUS_SUCCESS ) {

            //
            //  If the object id attribute exists for the file,
            //  but it isn't in the index, the object id index
            //  for this volume is corrupt.
            //

            SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_CORRUPT );

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        RtlCopyMemory( ExtendedInfo,
                       ((NTFS_OBJECTID_INFORMATION *)IndexRow.DataPart.Data)->ExtendedInfo,
                       OBJECT_ID_EXT_INFO_LENGTH );

    try_exit: NOTHING;
    } finally {

        if (IndexAcquired) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
        }

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }
    }

    return Status;
}



NTSTATUS
NtfsDeleteObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deletes the object id attribute from a file
    and removes that object id from the index.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This only works for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Read only volumes stay read only.
    //
    
    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );       
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Only a restore operator or the I/O system (using its private irp minor code)
        //  is allowed to delete an object id.
        //

        if (FlagOn( Ccb->AccessFlags, RESTORE_ACCESS | WRITE_DATA_ACCESS) ||
            (IrpSp->MinorFunction == IRP_MN_KERNEL_CALL)) {

            Status = NtfsDeleteObjectIdInternal( IrpContext,
                                                 Fcb,
                                                 Vcb,
                                                 TRUE );

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

    } finally {

        //
        //  Update the last change timestamp
        // 

        if (NT_SUCCESS( Status )) {
            SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
        }

        //
        //  If there was no object id - just return success
        //  

        if (STATUS_OBJECTID_NOT_FOUND == Status) {
            Status = STATUS_SUCCESS;
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsDeleteObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN BOOLEAN DeleteFileAttribute
    )

/*++

Routine Description:

    Internal function to (optionally) delete the object id attribute from
    a file and remove that object id from the index.

Arguments:

    Fcb - The file from which to delete the object id.
    
    Vcb - The volume whose object id index the object id should be removed from.

    DeleteFileAttribute - Specifies whether to delete the object id file attribute
                          from the file in addition to removing the id from the index.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    FILE_OBJECTID_INFORMATION FileObjectIdInfo;

    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    MAP_HANDLE MapHandle;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN InitializedAttributeContext = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;
    BOOLEAN IndexAcquired = FALSE;

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Acquire the file we're deleting the object id from.  We don't
    //  want anybody else deleting the file or object id behind
    //  our backs.
    //

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        //
        //  We need to look up the object id.  It's quite possible that
        //  this file has no object id, so we'll treat that as success.
        //

        Status = NtfsGetObjectIdInternal( IrpContext,
                                          Fcb,
                                          FALSE,
                                          &ObjectIdBuffer );

        if (Status != STATUS_SUCCESS) {

            try_return( NOTHING );
        }

        //
        //  Look for object id in the index.
        //

        IndexKey.Key = ObjectIdBuffer.ObjectId;
        IndexKey.KeyLength = sizeof( ObjectIdBuffer.ObjectId );

        NtOfsInitializeMapHandle( &MapHandle );
        InitializedMapHandle = TRUE;

        //
        //  Acquire the object id index before doing the lookup.
        //  We need to make sure the file is acquired first to prevent
        //  a possible deadlock.
        //

        ASSERT_EXCLUSIVE_FCB( Fcb );
        NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
        IndexAcquired = TRUE;

        if ( NtOfsFindRecord( IrpContext,
                              Vcb->ObjectIdTableScb,
                              &IndexKey,
                              &IndexRow,
                              &MapHandle,
                              NULL) != STATUS_SUCCESS ) {

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        ASSERT( IndexRow.DataPart.DataLength == sizeof( NTFS_OBJECTID_INFORMATION ) );

        //
        //  Copy objectid info into the correct buffer if we need it for the notify
        //  below.
        //

        if ((Vcb->ViewIndexNotifyCount != 0) &&
            (IndexRow.DataPart.DataLength == sizeof( NTFS_OBJECTID_INFORMATION ))) {

            //
            //  The FRS field is only populated for the notification of a failed
            //  object id restore from the tunnel cache.
            //

            FileObjectIdInfo.FileReference = 0L;

            RtlCopyMemory( &FileObjectIdInfo.ObjectId,
                           ObjectIdBuffer.ObjectId,
                           OBJECT_ID_KEY_LENGTH );

            RtlCopyMemory( &FileObjectIdInfo.ExtendedInfo,
                           ((NTFS_OBJECTID_INFORMATION *)IndexRow.DataPart.Data)->ExtendedInfo,
                           OBJECT_ID_EXT_INFO_LENGTH );
        }

        //
        //  Remove ObjectId from the index.
        //

        NtOfsDeleteRecords( IrpContext,
                            Vcb->ObjectIdTableScb,
                            1,    // deleting one record from the index
                            &IndexKey );

        //
        //  Notify anybody who's interested.  We use a different action if the
        //  object id is being deleted by the fsctl versus a delete file.
        //

        if (Vcb->ViewIndexNotifyCount != 0) {

            NtfsReportViewIndexNotify( Vcb,
                                       Vcb->ObjectIdTableScb->Fcb,
                                       FILE_NOTIFY_CHANGE_FILE_NAME,
                                       (DeleteFileAttribute ?
                                        FILE_ACTION_REMOVED :
                                        FILE_ACTION_REMOVED_BY_DELETE),
                                       &FileObjectIdInfo,
                                       sizeof(FILE_OBJECTID_INFORMATION) );
        }

        if (DeleteFileAttribute) {

            //
            //  Post the change to the Usn Journal (on errors change is backed out)
            //

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_OBJECT_ID_CHANGE );

            //
            //  Now remove the object id attribute from the file.
            //

            NtfsInitializeAttributeContext( &AttributeContext );
            InitializedAttributeContext = TRUE;

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $OBJECT_ID,
                                           &AttributeContext )) {

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &AttributeContext );
            } else {

                //
                //  If the object id was in the index, but the attribute
                //  isn't on the file, then the object id index for this
                //  volume is corrupt.  We can repair this corruption in
                //  the background, so let's start doing that now.
                //

                NtfsPostSpecial( IrpContext, Vcb, NtfsRepairObjectId, NULL );
            }

            NtfsCleanupTransaction( IrpContext, Status, FALSE );
        }

    try_exit: NOTHING;
    } finally {

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        if (InitializedAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }

    return Status;
}


VOID
NtfsRepairObjectId (
    IN PIRP_CONTEXT IrpContext,                        
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called to repair the object Id index.  This is called when
    the system detects that the object Id index may be out of date.  For example
    after the volume was mounted on 4.0.

Arguments:

    IrpContext - context of the call

    Context - NULL

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN SetRepairFlag = FALSE;
    BOOLEAN IncrementedCloseCounts = FALSE;
    PBCB Bcb = NULL;
    PVCB Vcb = IrpContext->Vcb;
    PSCB ObjectIdScb;
    PREAD_CONTEXT ReadContext = NULL;
    PINDEX_ROW IndexRow = NULL;
    PINDEX_ROW ObjectIdRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    PNTFS_OBJECTID_INFORMATION ObjectIdInfo;
    PVOID RowBuffer = NULL;
    ULONG Count;
    ULONG i;
    BOOLEAN IndexAcquired = FALSE;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG MftOffset;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( Context );
    
    ASSERT( Vcb->MajorVersion >= NTFS_OBJECT_ID_VERSION );
    
    //
    //  Use a try-except to catch errors.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
    AcquiredVcb = TRUE;
        
    try {

        //
        //  Now that we're holding the Vcb, we can safely test for the presence 
        //  of the ObjectId index, as well as whether the volume is mounted.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
            (Vcb->ObjectIdTableScb != NULL) &&
            (!FlagOn( Vcb->ObjectIdTableScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ))) {
            
            ObjectIdScb = Vcb->ObjectIdTableScb;
            NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
            IndexAcquired = TRUE;

            //
            //  Since we'll be dropping the ObjectIdScb periodically, and we're
            //  not holding anything else, there's a chance that a dismount could
            //  happen, and make it unsafe for us to reacquire the ObjectIdScb.
            //  By incrementing the close counts, we keep it around as long as
            //  we need it.
            //

            NtfsIncrementCloseCounts( ObjectIdScb, TRUE, FALSE ); 
            IncrementedCloseCounts = TRUE;

            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;

        } else {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  The volume could've gotten write-protected by now.
        //
        
        if (NtfsIsVolumeReadOnly( Vcb )) {
        
            NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
        }
        
        if (!FlagOn( Vcb->ObjectIdState, VCB_OBJECT_ID_REPAIR_RUNNING )) {

            SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_REPAIR_RUNNING );
            SetRepairFlag = TRUE;

            //
            //  Check the object id index.  Periodically release all resources.
            //  See NtfsClearAndVerifyQuotaIndex
            //

            NtOfsInitializeMapHandle( &MapHandle );

            //
            //  Allocate a buffer large enough for several rows.
            //

            RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

            try {

                //
                //  Allocate a bunch of index row entries.
                //

                Count = PAGE_SIZE / sizeof( NTFS_OBJECTID_INFORMATION );

                IndexRow = NtfsAllocatePool( PagedPool,
                                             Count * sizeof( INDEX_ROW ) );

                //
                //  Iterate through the object id entries.  Start at the beginning.
                //

                RtlZeroMemory( &ObjectIdBuffer, sizeof(ObjectIdBuffer) );
                
                IndexKey.Key = ObjectIdBuffer.ObjectId;
                IndexKey.KeyLength = sizeof( ObjectIdBuffer.ObjectId );

                Status = NtOfsReadRecords( IrpContext,
                                           ObjectIdScb,
                                           &ReadContext,
                                           &IndexKey,
                                           NtOfsMatchAll,
                                           NULL,
                                           &Count,
                                           IndexRow,
                                           PAGE_SIZE,
                                           RowBuffer );

                while (NT_SUCCESS( Status )) {

                    //
                    //  Acquire the VCB shared and check whether we should
                    //  continue.
                    //

                    if (!NtfsIsVcbAvailable( Vcb )) {

                        //
                        //  The volume is going away, bail out.
                        //

                        Status = STATUS_VOLUME_DISMOUNTED;
                        leave;
                    }

                    ObjectIdRow = IndexRow;

                    for (i = 0; i < Count; i++, ObjectIdRow++) {

                        ObjectIdInfo = ObjectIdRow->DataPart.Data;

                        //
                        //  Make sure the mft record referenced in the index
                        //  row still exists and hasn't been deleted, etc.
                        //
                        //  We start by reading the disk and checking that the file record
                        //  sequence number matches and that the file record is in use.  If
                        //  we find an invalid entry, we will simply delete it from the 
                        //  object id index.
                        //

                        MftOffset = NtfsFullSegmentNumber( &ObjectIdInfo->FileSystemReference );

                        MftOffset = Int64ShllMod32(MftOffset, Vcb->MftShift);

                        if (MftOffset >= Vcb->MftScb->Header.FileSize.QuadPart) {

                            DebugTrace( 0, Dbg, ("File Id doesn't lie within Mft FRS %04x:%08lx\n", 
                                                 ObjectIdInfo->FileSystemReference.SequenceNumber,
                                                 ObjectIdInfo->FileSystemReference.SegmentNumberLowPart) );

                            NtOfsDeleteRecords( IrpContext,
                                                ObjectIdScb,
                                                1,    // deleting one record from the index
                                                &ObjectIdRow->KeyPart );
                            
                        } else {

                            NtfsReadMftRecord( IrpContext,
                                               Vcb,
                                               &ObjectIdInfo->FileSystemReference,
                                               FALSE,
                                               &Bcb,
                                               &FileRecord,
                                               NULL );

                            //
                            //  This file record better be in use, have a matching sequence number and
                            //  be the primary file record for this file.
                            //

                            if ((*((PULONG) FileRecord->MultiSectorHeader.Signature) != *((PULONG) FileSignature)) ||
                                !FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) ||
                                (FileRecord->SequenceNumber != ObjectIdInfo->FileSystemReference.SequenceNumber) ||
                                (*((PLONGLONG) &FileRecord->BaseFileRecordSegment) != 0)) {

                                DebugTrace( 0, Dbg, ("RepairOID removing an orphaned OID\n") );

                                NtOfsDeleteRecords( IrpContext,
                                                    ObjectIdScb,
                                                    1,    // deleting one record from the index
                                                    &ObjectIdRow->KeyPart );
                                
                            } else {

                                DebugTrace( 0, Dbg, ("RepairOID happy with OID %08lx on FRS %04x:%08lx\n",
                                                     *((PULONG) ObjectIdRow->KeyPart.Key),
                                                     ObjectIdInfo->FileSystemReference.SequenceNumber,
                                                     ObjectIdInfo->FileSystemReference.SegmentNumberLowPart) );
                            }

                            NtfsUnpinBcb( IrpContext, &Bcb );
                        }
                    }

                    //
                    //  Release the index and commit what has been done so far.
                    //

                    ASSERT( IndexAcquired );
                    NtfsReleaseScb( IrpContext, ObjectIdScb );
                    IndexAcquired = FALSE;

                    //
                    //  Complete the request which commits the pending
                    //  transaction if there is one and releases of the
                    //  acquired resources.  The IrpContext will not
                    //  be deleted because the no delete flag is set.
                    //

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
                    NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

                    //
                    //  Remember how far we got so we can restart correctly. **** ??? ****
                    //

                    //  Vcb->QuotaFileReference.SegmentNumberLowPart =
                    //  *((PULONG) IndexRow[Count - 1].KeyPart.Key);

                    //
                    //  Reacquire the object id index for the next pass.
                    //
                    
                    NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
                    IndexAcquired = TRUE;

                    //
                    //  Make sure a dismount didn't occur while we weren't holding any 
                    //  resources.
                    //
                    
                    if (FlagOn( ObjectIdScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
                        
                        NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                    }
        
                    //
                    //  Look up the next set of entries in the object id index.
                    //

                    Count = PAGE_SIZE / sizeof( NTFS_OBJECTID_INFORMATION );
                    Status = NtOfsReadRecords( IrpContext,
                                               ObjectIdScb,
                                               &ReadContext,
                                               NULL,
                                               NtOfsMatchAll,
                                               NULL,
                                               &Count,
                                               IndexRow,
                                               PAGE_SIZE,
                                               RowBuffer );
                }

                ASSERT( (Status == STATUS_NO_MORE_MATCHES) || 
                        (Status == STATUS_NO_MATCH) );

            } finally {

                NtfsUnpinBcb( IrpContext, &Bcb );
                
                NtfsFreePool( RowBuffer );
                NtOfsReleaseMap( IrpContext, &MapHandle );

                if (IndexAcquired) {                
                    NtfsReleaseScb( IrpContext, ObjectIdScb );
                    IndexAcquired = FALSE;
                }
                
                if (IndexRow != NULL) {
                    NtfsFreePool( IndexRow );
                }

                if (ReadContext != NULL) {
                    NtOfsFreeReadContext( ReadContext );
                }
            }

            //
            //  Acquire the Vcb to clear the object ID flag on disk.  Since we got the
            //  Vcb shared before, we better not still be holding it when we try to
            //  get it exclusively now or else we'll have a one thread deadlock.
            //

            ASSERT( !AcquiredVcb );
            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            AcquiredVcb = TRUE;

            if (!NtfsIsVcbAvailable( Vcb )) {

                NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
            }

            //
            //  Clear the on-disk flag indicating the repair is underway.
            //

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_REPAIR_OBJECT_ID,
                                        FALSE,
                                        TRUE );

            //
            //  Make sure we don't own any resources at this point.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsCheckpointCurrentTransaction( IrpContext );
        }
        
    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation())) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    //
    //  Clear the repair_running flag if we're the ones who set it, making sure
    //  to only change the ObjectIdState bits while holding the ObjectId index.
    //
    
    if (SetRepairFlag) {

        if (!IndexAcquired) {

            NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
            IndexAcquired = TRUE;
        }
        
        ClearFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_REPAIR_RUNNING );        
    }

    if (IncrementedCloseCounts) {
    
        if (!IndexAcquired) {

            NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
            IndexAcquired = TRUE;
        }

        NtfsDecrementCloseCounts( IrpContext, ObjectIdScb, NULL, TRUE, FALSE, FALSE );
    }

    //
    //  Drop the index and the Vcb.
    //

    if (IndexAcquired) {
    
        NtfsReleaseScb( IrpContext, ObjectIdScb );
    }
    
    if (AcquiredVcb) {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    //
    //  If this is a fatal failure then do any final cleanup.
    //

    if (!NT_SUCCESS( Status )) {

        //
        //  If we will not be called back then clear the running state bits.
        //

        if ((Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL)) {

            //
            //  Do we want to log this error?  Some may be expected (i.e. STATUS_VOLUME_DISMOUNTED ).
            //

            //  NtfsLogEvent( IrpContext, NULL, IO_FILE_OBJECTID_REPAIR_FAILED, Status );
        }

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }
}

//
//  Local support routine
//


NTSTATUS
NtfsSetObjectIdExtendedInfoInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PUCHAR ExtendedInfoBuffer
    )

/*++

Routine Description:

    This routine sets the extended info for a file which already has an object
    id.  If the file does not yet have an object id, we return a status other
    than STATUS_SUCCESS.

Arguments:

    Fcb - The file whose extended info is to be set.

    Vcb - The volume whose object id index the entry should be modified in.

    ExtendedInfoBuffer - Supplies the new extended info.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status;
    NTFS_OBJECTID_INFORMATION ObjectIdInfo;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    INDEX_ROW IndexRow;

    PAGED_CODE( );

    Status = NtfsGetObjectIdInternal( IrpContext,
                                      Fcb,
                                      FALSE,        //  GetExtendedInfo
                                      &ObjectIdBuffer );

    if (Status != STATUS_SUCCESS) {

        //
        //  This file may not have an object id yet.
        //

        return Status;
    }

    //
    //  Setup the index row for updating.  Since part of the data
    //  is passed into this function (the new extended info) and
    //  the rest can be determined easily (the file reference), we
    //  don't need to look up any of the existing data before
    //  proceeding.  If the NTFS_OBJECTID_INFORMATION structure
    //  ever changes, this code may have to be changed to include
    //  a lookup of the data currently in the object id index.
    //

    RtlCopyMemory( &ObjectIdInfo.FileSystemReference,
                   &Fcb->FileReference,
                   sizeof( ObjectIdInfo.FileSystemReference ) );

    RtlCopyMemory( &ObjectIdInfo.ExtendedInfo,
                   ExtendedInfoBuffer,
                   OBJECT_ID_EXT_INFO_LENGTH );

    IndexRow.DataPart.Data = &ObjectIdInfo;
    IndexRow.DataPart.DataLength = sizeof( NTFS_OBJECTID_INFORMATION );

    IndexRow.KeyPart.Key = &ObjectIdBuffer;
    IndexRow.KeyPart.KeyLength = OBJECT_ID_KEY_LENGTH;

    //
    //  Acquire the object id index before doing the modification.
    //

    NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );


    //
    //  Post the change to the Usn Journal (on errors change is backed out)
    //

    NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_OBJECT_ID_CHANGE );

    //
    //  Update the ObjectId index record's data in place.
    //

    NtOfsUpdateRecord( IrpContext,
                       Vcb->ObjectIdTableScb,
                       1,           //  Count
                       &IndexRow,
                       NULL,        //  QuickIndexHint
                       NULL );      //  MapHandle

    NtfsCleanupTransaction( IrpContext, Status, FALSE );
    return Status;
}

//
//  Local support routine
//


VOID
NtfsGetIdFromGenerator (
    OUT PFILE_OBJECTID_BUFFER ObjectId
    )

/*++

Routine Description:

    This function conjures up a random object id.

Arguments:

    ObjectId - The location where the generated object id will be stored.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    //  Cal the id generator.
    //

    ExUuidCreate( (UUID *)ObjectId->ObjectId );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfsproc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsProc.h

Abstract:

    This module defines all of the globally used procedures in the Ntfs
    file system.

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:

--*/

#ifndef _NTFSPROC_
#define _NTFSPROC_

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable
#pragma warning(error:4705)   // Statement has no effect
#pragma warning(disable:4116) // unnamed type definition in parentheses

#define RTL_USE_AVL_TABLES 0

#ifndef KDEXTMODE

#include <ntifs.h>

#else

#include <ntos.h>
#include <zwapi.h>
#include <FsRtl.h>
#include <ntrtl.h>

#endif

#include <string.h>
#include <lfs.h>
#include <ntdddisk.h>
#include <NtIoLogc.h>
#include <elfmsg.h>

#include "nodetype.h"
#include "Ntfs.h"

#ifndef INLINE
// definition of inline
#define INLINE __inline
#endif

#include <ntfsexp.h>

#include "NtfsStru.h"
#include "NtfsData.h"
#include "NtfsLog.h"

//
//  Tag all of our allocations if tagging is turned on
//

//
//  Default module pool tag
//

#define MODULE_POOL_TAG ('0ftN')

#if 0
#define NtfsVerifySizes(s)  (ASSERT( (s)->ValidDataLength.QuadPart <= (s)->FileSize.QuadPart && (s)->FileSize.QuadPart <= (s)->AllocationSize.QuadPart ))
#define NtfsVerifySizesLongLong(s)  (ASSERT( (s)->ValidDataLength <= (s)->FileSize && (s)->FileSize <= (s)->AllocationSize ))
#else   //  !DBG
#define NtfsVerifySizes(s)
#define NtfsVerifySizesLongLong(s)
#endif  //  !DBG

#if !(DBG && i386 && defined (NTFSPOOLCHECK))

//
//  Non-debug allocate and free goes directly to the FsRtl routines
//

#define NtfsAllocatePoolWithTagNoRaise(a,b,c)   ExAllocatePoolWithTag((a),(b),(c))
#define NtfsAllocatePoolWithTag(a,b,c)          FsRtlAllocatePoolWithTag((a),(b),(c))
#define NtfsAllocatePoolNoRaise(a,b)            ExAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define NtfsAllocatePool(a,b)                   FsRtlAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define NtfsFreePool(pv)                        ExFreePool(pv)

#else   //  !DBG

//
//  Debugging routines capture the stack backtrace for allocates and frees
//

#define NtfsAllocatePoolWithTagNoRaise(a,b,c)   NtfsDebugAllocatePoolWithTagNoRaise((a),(b),(c))
#define NtfsAllocatePoolWithTag(a,b,c)          NtfsDebugAllocatePoolWithTag((a),(b),(c))
#define NtfsAllocatePoolNoRaise(a,b)            NtfsDebugAllocatePoolWithTagNoRaise((a),(b),MODULE_POOL_TAG)
#define NtfsAllocatePool(a,b)                   NtfsDebugAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define NtfsFreePool(pv)                        NtfsDebugFreePool(pv)

PVOID
NtfsDebugAllocatePoolWithTagNoRaise (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag);

PVOID
NtfsDebugAllocatePoolWithTag (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag);

VOID
NtfsDebugFreePool (
    PVOID pv);

VOID
NtfsDebugHeapDump (
    PUNICODE_STRING UnicodeString );

#endif  //  !DBG

//
//  Local character comparison macros that we might want to later move to ntfsproc
//

#define IsCharZero(C)    (((C) & 0x000000ff) == 0x00000000)
#define IsCharMinus1(C)  (((C) & 0x000000ff) == 0x000000ff)
#define IsCharLtrZero(C) (((C) & 0x00000080) == 0x00000080)
#define IsCharGtrZero(C) (!IsCharLtrZero(C) && !IsCharZero(C))

//
//  The following two macro are used to find the first byte to really store
//  in the mapping pairs.  They take as input a pointer to the LargeInteger we are
//  trying to store and a pointer to a character pointer.  The character pointer
//  on return points to the first byte that we need to output.  That's we skip
//  over the high order 0x00 or 0xff bytes.
//

typedef struct _SHORT2 {
    USHORT LowPart;
    USHORT HighPart;
} SHORT2, *PSHORT2;

typedef struct _CHAR2 {
    UCHAR LowPart;
    UCHAR HighPart;
} CHAR2, *PCHAR2;

#define GetPositiveByte(LI,CP) {                           \
    *(CP) = (PCHAR)(LI);                                   \
    if ((LI)->HighPart != 0) { *(CP) += 4; }               \
    if (((PSHORT2)(*(CP)))->HighPart != 0) { *(CP) += 2; } \
    if (((PCHAR2)(*(CP)))->HighPart != 0) { *(CP) += 1; }  \
    if (IsCharLtrZero(*(*CP))) { *(CP) += 1; }             \
}

#define GetNegativeByte(LI,CP) {                                \
    *(CP) = (PCHAR)(LI);                                        \
    if ((LI)->HighPart != 0xffffffff) { *(CP) += 4; }           \
    if (((PSHORT2)(*(CP)))->HighPart != 0xffff) { *(CP) += 2; } \
    if (((PCHAR2)(*(CP)))->HighPart != 0xff) { *(CP) += 1; }    \
    if (!IsCharLtrZero(*(*CP))) { *(CP) += 1; }                 \
}


//
//  Flag macros
//
//      ULONG
//      FlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      BOOLEAN
//      BooleanFlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      SetFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      ClearFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//

#ifdef KDEXTMODE

#ifndef FlagOn
#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)
#endif

#endif

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(F,SF) { \
//    (F) |= (SF);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(F,SF) { \
//    (F) &= ~(SF);         \
//}
//#endif



//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as STATUS_FILE_INVALID (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  NtfsFsdXxx(..)
//  {
//      try {
//
//          ..
//
//      } except(NtfsExceptionFilter( IrpContext, GetExceptionRecord() )) {
//
//          Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  STATUS_FILE_INVALID, use the below macro NtfsRaiseStatus).  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  NtfsNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise STATUS_UNEXPECTED_IO_ERROR if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  IrpContext->ExceptionStatus, signaling NtfsExceptionFilter and
//  NtfsProcessException that the status we actually raise is by definition
//  expected.
//

LONG
NtfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
NtfsProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS ExceptionCode
    );

VOID
DECLSPEC_NORETURN
NtfsRaiseStatus (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    );

ULONG
NtfsRaiseStatusFunction (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status
    );

//
//      VOID
//      NtfsNormalAndRaiseStatus (
//          IN PRIP_CONTEXT IrpContext,
//          IN NT_STATUS Status
//          IN NT_STATUS NormalStatus
//          );
//

#define NtfsNormalizeAndRaiseStatus(IC,STAT,NOR_STAT) {                          \
    (IC)->ExceptionStatus = (STAT);                                              \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STAT),NOR_STAT));                      \
}

//
//  Informational popup routine.
//

VOID
NtfsRaiseInformationHardError (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS  Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    );


//
//  Allocation support routines, implemented in AllocSup.c
//
//  These routines are for querying, allocating and truncating clusters
//  for individual data streams.
//

//
//   Syscache debugging support - Main current define these are triggered on is
//   SYSCACHE_DEBUG
//

#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG) || defined(SYSCACHE_DEBUG))

BOOLEAN
FsRtlIsSyscacheFile (
    IN PFILE_OBJECT FileObject
    );

//
//  Depreciated verification routine leftover from tomm's original debugging code
//

VOID
FsRtlVerifySyscacheData (
    IN PFILE_OBJECT FileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Offset
    );

ULONG
FsRtlLogSyscacheEvent (
    IN PSCB Scb,
    IN ULONG Event,
    IN ULONG Flags,
    IN LONGLONG Start,
    IN LONGLONG Range,
    IN LONGLONG Result
    );

VOID
FsRtlUpdateSyscacheEvent (
    IN PSCB Scb,
    IN ULONG EntryNumber,
    IN LONGLONG Result,
    IN ULONG NewFlag
    );

#define ScbIsBeingLogged( S )  (((S)->SyscacheLogEntryCount != 0) && (NtfsSyscacheLogSet[(S)->LogSetNumber].Scb == (S)))

#endif

//
//  The following routine takes an Vbo and returns the lbo and size of
//  the run corresponding to the Vbo.  It function result is TRUE if
//  the Vbo has a valid Lbo mapping and FALSE otherwise.
//

ULONG
NtfsPreloadAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    );

BOOLEAN
NtfsLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN Vcn,
    OUT PLCN Lcn,
    OUT PLONGLONG ClusterCount,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    );

BOOLEAN
NtfsIsRangeAllocated (
    IN PSCB Scb,
    IN VCN StartVcn,
    IN VCN FinalCluster,
    IN BOOLEAN RoundToSparseUnit,
    OUT PLONGLONG ClusterCount
    );

//
//  The following two routines modify the allocation of a data stream
//  represented by an Scb.
//

BOOLEAN
NtfsAllocateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN AllocateAll,
    IN BOOLEAN LogIt,
    IN LONGLONG Size,
    IN PATTRIBUTE_ENUMERATION_CONTEXT NewLocation OPTIONAL
    );

VOID
NtfsAddAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN LONGLONG ClusterCount,
    IN LOGICAL AskForMore,
    IN OUT PCCB CcbForWriteExtend OPTIONAL
    );

VOID
NtfsAddSparseAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN LONGLONG StartingOffset,
    IN LONGLONG ByteCount
    );

VOID
NtfsDeleteAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt,
    IN BOOLEAN BreakupAllowed
    );

VOID
NtfsReallocateRange (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN DeleteVcn,
    IN LONGLONG DeleteCount,
    IN VCN AllocateVcn,
    IN LONGLONG AllocateCount,
    IN PLCN TargetLcn OPTIONAL
    );

//
//  Routines for Mcb to Mapping Pairs operations
//

ULONG
NtfsGetSizeForMappingPairs (
    IN PNTFS_MCB Mcb,
    IN ULONG BytesAvailable,
    IN VCN LowestVcn,
    IN PVCN StopOnVcn OPTIONAL,
    OUT PVCN StoppedOnVcn
    );

BOOLEAN
NtfsBuildMappingPairs (
    IN PNTFS_MCB Mcb,
    IN VCN LowestVcn,
    IN OUT PVCN HighestVcn,
    OUT PCHAR MappingPairs
    );

VCN
NtfsGetHighestVcn (
    IN PIRP_CONTEXT IrpContext,
    IN VCN LowestVcn,
    IN PCHAR MappingPairs
    );

BOOLEAN
NtfsReserveClusters (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    );

VOID
NtfsFreeReservedClusters (
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    );

BOOLEAN
NtfsCheckForReservedClusters (
    IN PSCB Scb,
    IN LONGLONG StartingVcn,
    IN OUT PLONGLONG ClusterCount
    );

VOID
NtfsDeleteReservedBitmap (
    IN PSCB Scb
    );


//
//  Attribute lookup routines, implemented in AttrSup.c
//

//
//  This macro detects if we are enumerating through base or external
//  attributes, and calls the appropriate function.
//
//  BOOLEAN
//  LookupNextAttribute (
//      IN PRIP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE Code,
//      IN PUNICODE_STRING Name OPTIONAL,
//      IN BOOLEAN IgnoreCase,
//      IN PVOID Value OPTIONAL,
//      IN ULONG ValueLength,
//      IN PVCN Vcn OPTIONAL,
//      IN PATTRIBUTE_ENUMERATION_CONTEXT Context
//      );
//

#define LookupNextAttribute(IRPCTXT,FCB,CODE,NAME,IC,VALUE,LENGTH,V,CONTEXT)    \
    ( (CONTEXT)->AttributeList.Bcb == NULL                                      \
      ?   NtfsLookupInFileRecord( (IRPCTXT),                                    \
                                  (FCB),                                        \
                                  NULL,                                         \
                                  (CODE),                                       \
                                  (NAME),                                       \
                                  (V),                                          \
                                  (IC),                                         \
                                  (VALUE),                                      \
                                  (LENGTH),                                     \
                                  (CONTEXT))                                    \
      :   NtfsLookupExternalAttribute((IRPCTXT),                                \
                                      (FCB),                                    \
                                      (CODE),                                   \
                                      (NAME),                                   \
                                      (V),                                      \
                                      (IC),                                     \
                                      (VALUE),                                  \
                                      (LENGTH),                                 \
                                      (CONTEXT)) )

BOOLEAN
NtfsLookupExternalAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );



//
//  The following two routines do lookups based on the attribute definitions.
//

ATTRIBUTE_TYPE_CODE
NtfsGetAttributeTypeCode (
    IN PVCB Vcb,
    IN PUNICODE_STRING AttributeTypeName
    );


//
//  PATTRIBUTE_DEFINITION_COLUMNS
//  NtfsGetAttributeDefinition (
//      IN PVCB Vcb,
//      IN ATTRIBUTE_TYPE_CODE AttributeTypeCode
//      )
//

#define NtfsGetAttributeDefinition(Vcb,AttributeTypeCode)   \
    (&Vcb->AttributeDefinitions[(AttributeTypeCode / 0x10) - 1])

//
//  This routine looks up the attribute uniquely-qualified by the specified
//  Attribute Code and case-sensitive name.  The attribute may not be unique
//  if IgnoreCase is specified.
//


BOOLEAN
NtfsLookupInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_REFERENCE BaseFileReference OPTIONAL,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );


//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode and the specified QueriedName in the
//  specified BaseFileReference.  If we find one, its attribute record is
//  pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttributeByName (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PUNICODE_STRING QueriedName OPTIONAL,
//      IN PVCN Vcn OPTIONAL,
//      IN BOOLEAN IgnoreCase,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeByName(IrpContext,Fcb,BaseFileReference,QueriedTypeCode,QueriedName,Vcn,IgnoreCase,Context)  \
    NtfsLookupInFileRecord( IrpContext,             \
                            Fcb,                    \
                            BaseFileReference,      \
                            QueriedTypeCode,        \
                            QueriedName,            \
                            Vcn,                    \
                            IgnoreCase,             \
                            NULL,                   \
                            0,                      \
                            Context )


//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttributeByName (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PUNICODE_STRING QueriedName OPTIONAL,
//      IN BOOLEAN IgnoreCase,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//
#define NtfsLookupNextAttributeByName(IrpContext,Fcb,QueriedTypeCode,QueriedName,IgnoreCase,Context)    \
    LookupNextAttribute( IrpContext,                \
                         Fcb,                       \
                         QueriedTypeCode,           \
                         QueriedName,               \
                         IgnoreCase,                \
                         NULL,                      \
                         0,                         \
                         NULL,                      \
                         Context )

//
//  The following does a search based on a VCN.
//
//
//  BOOLEAN
//  NtfsLookupNextAttributeByVcn (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PVCN Vcn OPTIONAL,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT
//      );
//

#define NtfsLookupNextAttributeByVcn(IC,F,V,C)  \
    LookupNextAttribute( (IC),                  \
                         (F),                   \
                         $UNUSED,               \
                         NULL,                  \
                         FALSE,                 \
                         NULL,                  \
                         FALSE,                 \
                         (V),                   \
                         (C) )

//
//  The following routines find the attribute record for a given Scb.
//  And also update the scb from the attribute
//
//  VOID
//  NtfsLookupAttributeForScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb,
//      IN PVCN Vcn OPTIONAL,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeForScb(IrpContext,Scb,Vcn,Context)                           \
    if (!NtfsLookupAttributeByName( IrpContext,                                         \
                                    Scb->Fcb,                                           \
                                    &Scb->Fcb->FileReference,                           \
                                    Scb->AttributeTypeCode,                             \
                                    &Scb->AttributeName,                                \
                                    Vcn,                                                \
                                    FALSE,                                              \
                                    Context ) &&                                        \
        !FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {                               \
                                                                                        \
            DebugTrace( 0, 0, ("Could not find attribute for Scb @ %08lx\n", Scb ));    \
            ASSERTMSG("Could not find attribute for Scb\n", FALSE);                     \
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );   \
    }


//
//  This routine looks up and returns the next attribute for a given Scb.
//
//  BOOLEAN
//  NtfsLookupNextAttributeForScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttributeForScb(IrpContext,Scb,Context)   \
    NtfsLookupNextAttributeByName( IrpContext,                  \
                                   Scb->Fcb,                    \
                                   Scb->AttributeTypeCode,      \
                                   &Scb->AttributeName,         \
                                   FALSE,                       \
                                   Context )

VOID
NtfsUpdateScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER AttrHeader OPTIONAL
    );

//
//  The following routines deal with the Fcb and the duplicated information field.
//

BOOLEAN
NtfsUpdateFcbInfoFromDisk (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN LoadSecurity,
    IN OUT PFCB Fcb,
    OUT POLD_SCB_SNAPSHOT UnnamedDataSizes OPTIONAL
    );

//
//  These routines looks up the first/next attribute, i.e., they may be used
//  to retrieve all atributes for a file record.
//
//  If the Bcb in the Found Attribute structure changes in the Next call, then
//  the previous Bcb is autmatically unpinned and the new one pinned.
//

//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode in the specified BaseFileReference.  If we
//  find one, its attribute record is pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttribute (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttribute(IrpContext,Fcb,BaseFileReference,Context)   \
    NtfsLookupInFileRecord( IrpContext,                                 \
                            Fcb,                                        \
                            BaseFileReference,                          \
                            $UNUSED,                                    \
                            NULL,                                       \
                            NULL,                                       \
                            FALSE,                                      \
                            NULL,                                       \
                            0,                                          \
                            Context )

//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttribute (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttribute(IrpContext,Fcb,Context) \
    LookupNextAttribute( IrpContext,                    \
                         Fcb,                           \
                         $UNUSED,                       \
                         NULL,                          \
                         FALSE,                         \
                         NULL,                          \
                         0,                             \
                         NULL,                          \
                         Context )


//
//  These routines looks up the first/next attribute of the given type code.
//
//  If the Bcb in the Found Attribute structure changes in the Next call, then
//  the previous Bcb is autmatically unpinned and the new one pinned.
//


//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode in the specified BaseFileReference.  If we
//  find one, its attribute record is pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttributeByCode (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeByCode(IrpContext,Fcb,BaseFileReference,QueriedTypeCode,Context) \
    NtfsLookupInFileRecord( IrpContext,             \
                            Fcb,                    \
                            BaseFileReference,      \
                            QueriedTypeCode,        \
                            NULL,                   \
                            NULL,                   \
                            FALSE,                  \
                            NULL,                   \
                            0,                      \
                            Context )


//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttributeByCode (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttributeByCode(IC,F,CODE,C)  \
    LookupNextAttribute( (IC),                      \
                         (F),                       \
                         (CODE),                    \
                         NULL,                      \
                         FALSE,                     \
                         NULL,                      \
                         0,                         \
                         NULL,                      \
                         (C) )

//
//  These routines looks up the first/next occurrence of an attribute by its
//  Attribute Code and exact attribute value (consider using RtlCompareMemory).
//  The value contains everything outside of the standard attribute header,
//  so for example, to look up the File Name attribute by value, the caller
//  must form a record with not only the file name in it, but with the
//  ParentDirectory filled in as well.  The length should be exact, and not
//  include any unused (such as in DOS_NAME) or reserved characters.
//
//  If the Bcb changes in the Next call, then the previous Bcb is autmatically
//  unpinned and the new one pinned.
//


//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode and the specified QueriedValue in the
//  specified BaseFileReference.  If we find one, its attribute record is
//  pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttributeByValue (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PVOID QueriedValue,
//      IN ULONG QueriedValueLength,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeByValue(IrpContext,Fcb,BaseFileReference,QueriedTypeCode,QueriedValue,QueriedValueLength,Context)    \
    NtfsLookupInFileRecord( IrpContext,             \
                            Fcb,                    \
                            BaseFileReference,      \
                            QueriedTypeCode,        \
                            NULL,                   \
                            NULL,                   \
                            FALSE,                  \
                            QueriedValue,           \
                            QueriedValueLength,     \
                            Context )

//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttributeByValue (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PVOID QueriedValue,
//      IN ULONG QueriedValueLength,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttributeByValue(IC,F,CODE,V,VL,C)    \
    LookupNextAttribute( (IC),                              \
                         (F),                               \
                         (CODE),                            \
                         NULL,                              \
                         FALSE,                             \
                         (V),                               \
                         (VL),                              \
                         (C) )


VOID
NtfsCleanupAttributeContext(
    IN OUT PIRP_CONTEXT IrpContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
    );

//
//
//
//  Here are some routines/macros for dealing with Attribute Enumeration
//  Contexts.
//
//      VOID
//      NtfsInitializeAttributeContext(
//          OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      VOID
//      NtfsPinMappedAttribute(
//          IN PIRP_CONTEXT IrpContext,
//          IN PVCB Vcb,
//          IN OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      PATTRIBUTE_RECORD_HEADER
//      NtfsFoundAttribute(
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      PBCB
//      NtfsFoundBcb(
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      PFILE_RECORD
//      NtfsContainingFileRecord (
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      LONGLONG
//      NtfsMftOffset (
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//

#define NtfsInitializeAttributeContext(CTX) {                      \
    RtlZeroMemory( (CTX), sizeof(ATTRIBUTE_ENUMERATION_CONTEXT) ); \
}

#define NtfsPinMappedAttribute(IC,V,CTX) {                  \
    NtfsPinMappedData( (IC),                                \
                       (V)->MftScb,                         \
                       (CTX)->FoundAttribute.MftFileOffset, \
                       (V)->BytesPerFileRecordSegment,      \
                       &(CTX)->FoundAttribute.Bcb );        \
}

#define NtfsFoundAttribute(CTX) (   \
    (CTX)->FoundAttribute.Attribute \
)

#define NtfsFoundBcb(CTX) (   \
    (CTX)->FoundAttribute.Bcb \
)

#define NtfsContainingFileRecord(CTX) ( \
    (CTX)->FoundAttribute.FileRecord    \
)

#define NtfsMftOffset(CTX) (                \
    (CTX)->FoundAttribute.MftFileOffset     \
)

//
//  This routine returns whether an attribute is resident or not.
//
//      BOOLEAN
//      NtfsIsAttributeResident (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//      PVOID
//      NtfsAttributeValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//

#define NtfsIsAttributeResident(ATTR) ( \
    ((ATTR)->FormCode == RESIDENT_FORM) \
)

#define NtfsAttributeValue(ATTR) (                             \
    ((PCHAR)(ATTR) + (ULONG)(ATTR)->Form.Resident.ValueOffset) \
)

//
//  This routine modifies the valid data length and file size on disk for
//  a given Scb.
//

BOOLEAN
NtfsWriteFileSizes (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG ValidDataLength,
    IN BOOLEAN AdvanceOnly,
    IN BOOLEAN LogIt,
    IN BOOLEAN RollbackMemStructures
    );

//
//  This routine updates the standard information attribute from the
//  information in the Fcb.
//

VOID
NtfsUpdateStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

//
//  This routine grows and updates the standard information attribute from
//  the information in the Fcb.
//

VOID
NtfsGrowStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

//
//  Attribute FILE_NAME routines.  These routines deal with filename attributes.
//

//      VOID
//      NtfsBuildFileNameAttribute (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFILE_REFERENCE ParentDirectory,
//          IN UNICODE_STRING FileName,
//          IN UCHAR Flags,
//          OUT PFILE_NAME FileNameValue
//          );
//

#define NtfsBuildFileNameAttribute(IC,PD,FN,FL,PFNA) {                  \
    (PFNA)->ParentDirectory = *(PD);                                    \
    (PFNA)->FileNameLength = (UCHAR)((FN).Length >> 1);                 \
    (PFNA)->Flags = FL;                                                 \
    RtlMoveMemory( (PFNA)->FileName, (FN).Buffer, (ULONG)(FN).Length ); \
}

BOOLEAN
NtfsLookupEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN BOOLEAN IgnoreCase,
    IN OUT PUNICODE_STRING Name,
    IN OUT PFILE_NAME *FileNameAttr,
    IN OUT PUSHORT FileNameAttrLength,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PBCB *IndexEntryBcb,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    );

//
//  Macro to decide when to create an attribute resident.
//
//      BOOLEAN
//      NtfsShouldAttributeBeResident (
//          IN PVCB Vcb,
//          IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
//          IN ULONG Size
//          );
//

#define RS(S) ((S) + SIZEOF_RESIDENT_ATTRIBUTE_HEADER)

#define NtfsShouldAttributeBeResident(VC,FR,S) (                         \
    (BOOLEAN)((RS(S) <= ((FR)->BytesAvailable - (FR)->FirstFreeByte)) || \
              (RS(S) < (VC)->BigEnoughToMove))                           \
)

//
//  Attribute creation/modification routines
//
//  These three routines do *not* presuppose either the Resident or Nonresident
//  form, with the single exception that if the attribute is indexed, then
//  it must be Resident.
//
//  NtfsMapAttributeValue and NtfsChangeAttributeValue implement transparent
//  access to small to medium sized attributes (such as $ACL and $EA), and
//  work whether the attribute is resident or nonresident.  The design target
//  is 0-64KB in size.  Attributes larger than 256KB (or more accurrately,
//  whatever the virtual mapping granularity is in the Cache Manager) will not
//  work correctly.
//

VOID
NtfsCreateAttributeWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN PFILE_REFERENCE WhereIndexed OPTIONAL,
    IN BOOLEAN LogIt,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsMapAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    OUT PBCB *Bcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsChangeAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG ValueOffset,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN BOOLEAN SetNewLength,
    IN BOOLEAN LogNonresidentToo,
    IN BOOLEAN CreateSectionUnderway,
    IN BOOLEAN PreserveContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsConvertToNonresident (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_RECORD_HEADER Attribute,
    IN BOOLEAN CreateSectionUnderway,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL
    );

#define DELETE_LOG_OPERATION        0x00000001
#define DELETE_RELEASE_FILE_RECORD  0x00000002
#define DELETE_RELEASE_ALLOCATION   0x00000004

VOID
NtfsDeleteAttributeRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsDeleteAllocationFromRecord (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN BreakupAllowed,
    IN BOOLEAN LogIt
    );

BOOLEAN
NtfsChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsAddToAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN MFT_SEGMENT_REFERENCE SegmentReference,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsDeleteFromAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

BOOLEAN
NtfsRewriteMftMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsSetTotalAllocatedField (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT TotalAllocatedNeeded
    );

VOID
NtfsSetSparseStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb OPTIONAL,
    IN PSCB Scb
    );

NTSTATUS
NtfsZeroRangeInStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PSCB Scb,
    IN PLONGLONG StartingOffset,
    IN LONGLONG FinalZero
    );

BOOLEAN
NtfsModifyAttributeFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT NewAttributeFlags
    );

PFCB
NtfsInitializeFileInExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCUNICODE_STRING FileName,
    IN BOOLEAN ViewIndex,
    IN ULONG CreateIfNotExist
    );

//
//  Use common routines to fill the common query buffers.
//

VOID
NtfsFillBasicInfo (
    OUT PFILE_BASIC_INFORMATION Buffer,
    IN PSCB Scb
    );

VOID
NtfsFillStandardInfo (
    OUT PFILE_STANDARD_INFORMATION Buffer,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    );

VOID
NtfsFillNetworkOpenInfo (
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PSCB Scb
    );

//
//  The following three routines dealing with allocation are to be
//  called by allocsup.c only.  Other software must call the routines
//  in allocsup.c
//

BOOLEAN
NtfsCreateAttributeWithAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN LogIt,
    IN BOOLEAN UseContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsAddAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN PVCN StartingVcn OPTIONAL,
    IN PVCN ClusterCount OPTIONAL
    );

VOID
NtfsDeleteAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN LogIt,
    IN PVCN StopOnVcn,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN TruncateToVcn
    );

//
//  To delete a file, you must first ask if it is deleteable from the ParentScb
//  used to get there for your caller, and then you can delete it if it is.
//

//
//      BOOLEAN
//      NtfsIsLinkDeleteable (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFCB Fcb,
//          OUT PBOOLEAN NonEmptyIndex,
//          OUT PBOOLEAN LastLink
//          );
//

#define NtfsIsLinkDeleteable(IC,FC,NEI,LL) ((BOOLEAN)                     \
    (((*(LL) = ((BOOLEAN) (FC)->LinkCount == 1)), (FC)->LinkCount > 1) || \
     (NtfsIsFileDeleteable( (IC), (FC), (NEI) )))                         \
)

BOOLEAN
NtfsIsFileDeleteable (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBOOLEAN NonEmptyIndex
    );

VOID
NtfsDeleteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN OUT PBOOLEAN AcquiredParentScb,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    );

VOID
NtfsPrepareForUpdateDuplicate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PLCB *Lcb,
    IN OUT PSCB *ParentScb,
    IN BOOLEAN AcquireShared
    );

VOID
NtfsUpdateDuplicateInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN PSCB ParentScb OPTIONAL
    );

VOID
NtfsUpdateLcbDuplicateInfo (
    IN PFCB Fcb,
    IN PLCB Lcb
    );

VOID
NtfsUpdateFcb (
    IN PFCB Fcb,
    IN ULONG ChangeFlags
    );

//
//  The following routines add and remove links.  They also update the name
//  flags in particular links.
//

VOID
NtfsAddLink (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CreatePrimaryLink,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN PBOOLEAN LogIt OPTIONAL,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    );

VOID
NtfsRemoveLink (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UNICODE_STRING LinkName,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    );

VOID
NtfsRemoveLinkViaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN UCHAR FileNameFlags,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    OUT PUNICODE_STRING FileName OPTIONAL
    );

VOID
NtfsUpdateFileNameFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UCHAR FileNameFlags,
    IN PFILE_NAME FileNameLink
    );

//
//  These routines are intended for low-level attribute access, such as within
//  attrsup, or for applying update operations from the log during restart.
//

VOID
NtfsRestartInsertAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID ValueOrMappingPairs OPTIONAL,
    IN ULONG Length
    );

VOID
NtfsRestartRemoveAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset
    );

VOID
NtfsRestartChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG NewRecordLength
    );

VOID
NtfsRestartChangeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN SetNewLength
    );

VOID
NtfsRestartChangeMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data,
    IN ULONG Length
    );

VOID
NtfsRestartWriteEndOfFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER OldAttribute,
    IN PATTRIBUTE_RECORD_HEADER NewAttributes,
    IN ULONG SizeOfNewAttributes
    );


//
//  Bitmap support routines.  Implemented in BitmpSup.c
//

//
//  The following routines are used for allocating and deallocating clusters
//  on the disk.  The first routine initializes the allocation support
//  routines and must be called for each newly mounted/verified volume.
//  The next two routines allocate and deallocate clusters via Mcbs.
//  The last three routines are simple query routines.
//

VOID
NtfsInitializeClusterAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN BOOLEAN AllocateAll,
    IN LONGLONG ClusterCount,
    IN PLCN TargetLcn OPTIONAL,
    IN OUT PLONGLONG DesiredClusterCount
    );

VOID
NtfsAddBadCluster (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn
    );

BOOLEAN
NtfsDeallocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PLONGLONG TotalAllocated OPTIONAL
    );

VOID
NtfsPreAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    OUT PBOOLEAN AcquiredBitmap,
    OUT PBOOLEAN AcquiredMft
    );

VOID
NtfsCleanupClusterAllocationHints (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_MCB Mcb
    );

VOID
NtfsScanEntireBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LOGICAL CachedRunsOnly
    );

VOID
NtfsModifyBitsInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG FirstBit,
    IN LONGLONG BeyondFinalBit,
    IN ULONG RedoOperation,
    IN ULONG UndoOperation
    );

typedef enum _NTFS_RUN_STATE {
    RunStateUnknown = 1,
    RunStateFree,
    RunStateAllocated
} NTFS_RUN_STATE;
typedef NTFS_RUN_STATE *PNTFS_RUN_STATE;

BOOLEAN
NtfsAddCachedRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN NTFS_RUN_STATE RunState
    );

//
//  The following two routines are called at Restart to make bitmap
//  operations in the volume bitmap recoverable.
//

VOID
NtfsRestartSetBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    );

VOID
NtfsRestartClearBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    );

//
//  The following routines are for allocating and deallocating records
//  based on a bitmap attribute (e.g., allocating mft file records based on
//  the bitmap attribute of the mft).  If necessary the routines will
//  also extend/truncate the data and bitmap attributes to satisfy the
//  operation.
//

VOID
NtfsInitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB DataScb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute,
    IN ULONG BytesPerRecord,
    IN ULONG ExtendGranularity,         // In terms of records
    IN ULONG TruncateGranularity,       // In terms of records
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    );

VOID
NtfsUninitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    );

ULONG
NtfsAllocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsDeallocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsReserveMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

ULONG
NtfsAllocateMftReservedRecord (
    IN OUT PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsDeallocateRecordsComplete (
    IN PIRP_CONTEXT IrpContext
    );

BOOLEAN
NtfsIsRecordAllocated (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsScanMftBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

BOOLEAN
NtfsCreateMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsFindMftFreeTail (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PLONGLONG FileOffset
    );

//
//  Routines to handle the cached runs.
//

VOID
NtfsInitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );

VOID
NtfsReinitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );

VOID
NtfsUninitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );


//
//  Buffer control routines for data caching using internal attribute
//  streams implemented in CacheSup.c
//

#define NtfsCreateInternalAttributeStream(IC,S,U,NM) {          \
    NtfsCreateInternalStreamCommon((IC),(S),(U),FALSE,(NM));    \
}

#define NtfsCreateInternalCompressedStream(IC,S,U,NM) {         \
    NtfsCreateInternalStreamCommon((IC),(S),(U),TRUE,(NM));     \
}

#define NtfsClearInternalFilename(_FileObject) {                \
    (_FileObject)->FileName.MaximumLength = 0;                  \
    (_FileObject)->FileName.Length = 0;                         \
    (_FileObject)->FileName.Buffer = NULL;                      \
}

VOID
NtfsCreateInternalStreamCommon (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN UpdateScb,
    IN BOOLEAN CompressedStream,
    IN UNICODE_STRING const *StreamName
    );

BOOLEAN
NtfsDeleteInternalAttributeStream (
    IN PSCB Scb,
    IN ULONG ForceClose,
    IN ULONG CompressedStreamOnly
    );

//
//  The following routines provide direct access to data in an attribute.
//

VOID
NtfsMapStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

VOID
NtfsPinMappedData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN OUT PVOID *Bcb
    );

VOID
NtfsPinStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

VOID
NtfsPreparePinWriteStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN Zero,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

NTSTATUS
NtfsCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
NtfsZeroData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN LONGLONG StartingZero,
    IN LONGLONG ByteCount,
    IN OUT PLONGLONG CommittedFileSize OPTIONAL
    );

//
//  The following is needed when biasing the SetFileSizes call for the Usn Journal.
//
//  VOID
//  NtfsSetCcFileSizes (
//      IN PFILE_OBJECT FileObject,
//      IN PSCB Scb,
//      IN PCC_FILE_SIZES CcSizes
//      );
//

#define NtfsSetCcFileSizes(FO,S,CC) {                               \
    if (FlagOn( (S)->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {       \
        CC_FILE_SIZES _CcSizes;                                     \
        RtlCopyMemory( &_CcSizes, (CC), sizeof( CC_FILE_SIZES ));   \
        _CcSizes.AllocationSize.QuadPart -= (S)->Vcb->UsnCacheBias; \
        _CcSizes.FileSize.QuadPart -= (S)->Vcb->UsnCacheBias;       \
        CcSetFileSizes( (FO), &_CcSizes );                          \
    } else {                                                        \
        CcSetFileSizes( (FO), (CC) );                               \
    }                                                               \
}

//
//  VOID
//  NtfsFreeBcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb
//      );
//
//  VOID
//  NtfsUnpinBcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb,
//      );
//

#define NtfsFreeBcb(IC,BC) {                        \
    ASSERT_IRP_CONTEXT(IC);                         \
    if (*(BC) != NULL)                              \
    {                                               \
        CcFreePinnedData(*(BC));                    \
        *(BC) = NULL;                               \
    }                                               \
}


#ifdef MAPCOUNT_DBG
#define NtfsUnpinBcb(IC,BC) {                       \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinData(*(BC));                         \
        (IC)->MapCount--;                           \
        *(BC) = NULL;                               \
    }                                               \
}
#else
#define NtfsUnpinBcb(IC,BC) {                       \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinData(*(BC));                         \
        *(BC) = NULL;                               \
    }                                               \
}
#endif

#ifdef MAPCOUNT_DBG
#define NtfsUnpinBcbForThread(IC,BC,T) {            \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinDataForThread(*(BC), (T));           \
        (IC)->MapCount--;                           \
        *(BC) = NULL;                               \
    }                                               \
}
#else
#define NtfsUnpinBcbForThread(IC,BC,T) {            \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinDataForThread(*(BC), (T));           \
        *(BC) = NULL;                               \
    }                                               \
}
#endif

INLINE
PBCB
NtfsRemapBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb
    )
{
    UNREFERENCED_PARAMETER( IrpContext );
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif
    return CcRemapBcb( Bcb );
}



//
//  Ntfs structure check routines in CheckSup.c
//

BOOLEAN
NtfsCheckFileRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    OUT PULONG CorruptionHint
    );

BOOLEAN
NtfsCheckAttributeRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG CheckHeaderOnly,
    OUT PULONG CorruptionHint
    );

BOOLEAN
NtfsCheckIndexRoot (
    IN PVCB Vcb,
    IN PINDEX_ROOT IndexRoot,
    IN ULONG AttributeSize
    );

BOOLEAN
NtfsCheckIndexBuffer (
    IN PSCB Scb,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    );

BOOLEAN
NtfsCheckIndexHeader (
    IN PINDEX_HEADER IndexHeader,
    IN ULONG BytesAvailable
    );

BOOLEAN
NtfsCheckLogRecord (
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG LogRecordLength,
    IN TRANSACTION_ID TransactionId,
    IN ULONG AttributeEntrySize
    );

BOOLEAN
NtfsCheckRestartTable (
    IN PRESTART_TABLE RestartTable,
    IN ULONG TableSize
    );


//
//  Collation routines, implemented in ColatSup.c
//
//  These routines perform low-level collation operations, primarily
//  for IndexSup.  All of these routines are dispatched to via dispatch
//  tables indexed by the collation rule.  The dispatch tables are
//  defined here, and the actual implementations are in colatsup.c
//

typedef
FSRTL_COMPARISON_RESULT
(*PCOMPARE_VALUES) (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    );

typedef
BOOLEAN
(*PIS_IN_EXPRESSION) (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

typedef
BOOLEAN
(*PARE_EQUAL) (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

typedef
BOOLEAN
(*PCONTAINS_WILDCARD) (
    IN PVOID Value
    );

typedef
VOID
(*PUPCASE_VALUE) (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN OUT PVOID Value
    );

extern PCOMPARE_VALUES    NtfsCompareValues[COLLATION_NUMBER_RULES];
extern PIS_IN_EXPRESSION  NtfsIsInExpression[COLLATION_NUMBER_RULES];
extern PARE_EQUAL         NtfsIsEqual[COLLATION_NUMBER_RULES];
extern PCONTAINS_WILDCARD NtfsContainsWildcards[COLLATION_NUMBER_RULES];
extern PUPCASE_VALUE      NtfsUpcaseValue[COLLATION_NUMBER_RULES];

BOOLEAN
NtfsFileNameIsInExpression (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileNameIsEqual (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    );


//
//  Compression on the wire routines in CowSup.c
//

BOOLEAN
NtfsCopyReadC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsCompressedCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize
    );

BOOLEAN
NtfsMdlReadCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
NtfsCopyWriteC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsCompressedCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize,
    IN ULONG EngineMatches
    );

BOOLEAN
NtfsMdlWriteCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

NTSTATUS
NtfsSynchronizeUncompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    );

NTSTATUS
NtfsSynchronizeCompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    );

PCOMPRESSION_SYNC
NtfsAcquireCompressionSync (
    IN LONGLONG FileOffset,
    IN PSCB Scb,
    IN ULONG WriteAccess
    );

VOID
NtfsReleaseCompressionSync (
    IN PCOMPRESSION_SYNC CompressionSync
    );

INLINE
VOID
NtfsSetBothCacheSizes (
    IN PFILE_OBJECT FileObject,
    IN PCC_FILE_SIZES FileSizes,
    IN PSCB Scb
    )

{
    if (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL) {
        NtfsSetCcFileSizes( FileObject, Scb, FileSizes );
    }

#ifdef  COMPRESS_ON_WIRE
    if (Scb->Header.FileObjectC != NULL) {
        CcSetFileSizes( Scb->Header.FileObjectC, FileSizes );
    }
#endif
}

//
//  Device I/O routines, implemented in DevIoSup.c
//
//  These routines perform the actual device read and writes.  They only affect
//  the on disk structure and do not alter any other data structures.
//

VOID
NtfsLockUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
NtfsMapUserBuffer (
    IN OUT PIRP Irp
    );

NTSTATUS
NtfsVolumeDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    );

VOID
NtfsPagingFileIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    );

BOOLEAN
NtfsIsReadAheadThread (
    );

//
//  Values for StreamFlags passed to NtfsNonCachedIo, etc.
//

#define COMPRESSED_STREAM   0x00000001
#define ENCRYPTED_STREAM    0x00000002

NTSTATUS
NtfsNonCachedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags
    );

VOID
NtfsNonCachedNonAlignedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    );

#ifdef EFSDBG
NTSTATUS
NtfsDummyEfsRead (
    IN OUT PUCHAR InOutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    );

NTSTATUS
NtfsDummyEfsWrite (
    IN PUCHAR InBuffer,
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    );
#endif

VOID
NtfsTransformUsaBlock (
    IN PSCB Scb,
    IN OUT PVOID SystemBuffer,
    IN OUT PVOID Buffer,
    IN ULONG Length
    );

VOID
NtfsCreateMdlAndBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN UCHAR NeedTwoBuffers,
    IN OUT PULONG Length,
    OUT PMDL *Mdl OPTIONAL,
    OUT PVOID *Buffer
    );

VOID
NtfsDeleteMdlAndBuffer (
    IN PMDL Mdl OPTIONAL,
    IN PVOID Buffer OPTIONAL
    );

VOID
NtfsWriteClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN PVOID Buffer,
    IN ULONG ClusterCount
    );

BOOLEAN
NtfsVerifyAndRevertUsaBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PVOID Buffer,
    IN ULONG Length,
    IN LONGLONG FileOffset
    );

NTSTATUS
NtfsDefragFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadFromPlex(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following support routines are contained int Ea.c
//

PFILE_FULL_EA_INFORMATION
NtfsMapExistingEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBCB *EaBcb,
    OUT PULONG EaLength
    );

NTSTATUS
NtfsBuildEaList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION UserEaList,
    OUT PULONG_PTR ErrorOffset
    );

VOID
NtfsReplaceFileEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PEA_LIST_HEADER EaList
    );


//
//  The following routines are used to manipulate the fscontext fields
//  of the file object, implemented in FilObSup.c
//

typedef enum _TYPE_OF_OPEN {

    UnopenedFileObject = 1,
    UserFileOpen,
    UserDirectoryOpen,
    UserVolumeOpen,
    StreamFileOpen,
    UserViewIndexOpen

} TYPE_OF_OPEN;

VOID
NtfsSetFileObject (
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    );

//
//  TYPE_OF_OPEN
//  NtfsDecodeFileObject (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFILE_OBJECT FileObject,
//      OUT PVCB *Vcb,
//      OUT PFCB *Fcb,
//      OUT PSCB *Scb,
//      OUT PCCB *Ccb,
//      IN BOOLEAN RaiseOnError
//      );
//

#ifdef _DECODE_MACRO_
#define NtfsDecodeFileObject(IC,FO,V,F,S,C,R) (                                     \
    ( *(S) = (PSCB)(FO)->FsContext),                                                \
      ((*(S) != NULL)                                                               \
        ?   ((*(V) = (*(S))->Vcb),                                                  \
             (*(C) = (PCCB)(FO)->FsContext2),                                       \
             (*(F) = (*(S))->Fcb),                                                  \
             ((R)                                                                   \
              && !FlagOn((*(V))->VcbState, VCB_STATE_VOLUME_MOUNTED)                \
              && ((*(C) == NULL)                                                    \
                  || ((*(C))->TypeOfOpen != UserVolumeOpen)                         \
                  || !FlagOn((*(V))->VcbState, VCB_STATE_LOCKED))                   \
              && NtfsRaiseStatusFunction((IC), (STATUS_VOLUME_DISMOUNTED))),        \
             ((*(C) == NULL)                                                        \
              ? StreamFileOpen                                                      \
              : (*(C))->TypeOfOpen))                                                \
        : (*(C) = NULL,                                                             \
           UnopenedFileObject))                                                     \
)
#else //   _DECODE_MACRO_

INLINE TYPE_OF_OPEN
NtfsDecodeFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    OUT PVCB *Vcb,
    OUT PFCB *Fcb,
    OUT PSCB *Scb,
    OUT PCCB *Ccb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine decodes a file object into a Vcb, Fcb, Scb, and Ccb.

Arguments:

    IrpContext - The Irp context to use for raising on an error.

    FileObject - The file object to decode.

    Vcb - Where to store the Vcb.

    Fcb - Where to store the Fcb.

    Scb - Where to store the Scb.

    Ccb - Where to store the Ccb.

    RaiseOnError - If FALSE, we do not raise if we encounter an error.
                   Otherwise we do raise if we encounter an error.

Return Value:

    Type of open

--*/

{
    *Scb = (PSCB)FileObject->FsContext;

    if (*Scb != NULL) {

        *Vcb = (*Scb)->Vcb;
        *Ccb = (PCCB)FileObject->FsContext2;
        *Fcb = (*Scb)->Fcb;

        //
        //  If the caller wants us to raise, let's see if there's anything
        //  we should raise.
        //

        if (RaiseOnError &&
            !FlagOn((*Vcb)->VcbState, VCB_STATE_VOLUME_MOUNTED) &&
            ((*Ccb == NULL) ||
             ((*Ccb)->TypeOfOpen != UserVolumeOpen) ||
             !FlagOn((*Vcb)->VcbState, VCB_STATE_LOCKED))) {

            NtfsRaiseStatusFunction( IrpContext, STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Every open except a StreamFileOpen has a Ccb.
        //

        if (*Ccb == NULL) {

            return StreamFileOpen;

        } else {

            return (*Ccb)->TypeOfOpen;
        }

    } else {

        //
        //  No Scb, we assume the file wasn't open.
        //

        *Ccb = NULL;
        return UnopenedFileObject;
    }
}
#endif //  _DECODE_MACRO_

//
//  PSCB
//  NtfsFastDecodeUserFileOpen (
//      IN PFILE_OBJECT FileObject
//      );
//

#define NtfsFastDecodeUserFileOpen(FO) (                                                        \
    (((FO)->FsContext2 != NULL) && (((PCCB)(FO)->FsContext2)->TypeOfOpen == UserFileOpen)) ?    \
    (PSCB)(FO)->FsContext : NULL                                                                \
)

VOID
NtfsUpdateScbFromFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN BOOLEAN CheckTimeStamps
    );

//
//  Ntfs-private FastIo routines.
//

BOOLEAN
NtfsCopyReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsCopyWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsMdlReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsPrepareMdlWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsWaitForIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN OUT PLARGE_INTEGER FileOffset,
    IN ULONG Length
    );

VOID
NtfsFinishIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header
    );

//
//  VOID
//  FsRtlLockFsRtlHeader (
//      IN PNTFS_ADVANCED_FCB_HEADER FsRtlHeader
//      );
//
//  VOID
//  FsRtlUnlockFsRtlHeader (
//      IN PNTFS_ADVANCED_FCB_HEADER FsRtlHeader
//      );
//

#define FsRtlLockFsRtlHeader(H) {                           \
    ExAcquireFastMutex( (H)->FastMutex );                   \
    if (((H)->Flags & FSRTL_FLAG_EOF_ADVANCE_ACTIVE)) {     \
        NtfsWaitForIoAtEof( (H), &LiEof, 0 );               \
    }                                                       \
    (H)->Flags |= FSRTL_FLAG_EOF_ADVANCE_ACTIVE;            \
    ExReleaseFastMutex( (H)->FastMutex );                   \
}

#define FsRtlUnlockFsRtlHeader(H) {                         \
    ExAcquireFastMutex( (H)->FastMutex );                   \
    NtfsFinishIoAtEof( (H) );                               \
    ExReleaseFastMutex( (H)->FastMutex );                   \
}


//
//  Volume locking/unlocking routines, implemented in FsCtrl.c.
//

NTSTATUS
NtfsLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObjectWithVcbLocked,
    IN OUT PULONG Retrying
    );

NTSTATUS
NtfsUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );


//
//  Indexing routine interfaces, implemented in IndexSup.c.
//

VOID
NtfsCreateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE IndexedAttributeType,
    IN COLLATION_RULE CollationRule,
    IN ULONG BytesPerIndexBuffer,
    IN UCHAR BlocksPerIndexBuffer,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN NewIndex,
    IN BOOLEAN LogIt
    );

VOID
NtfsUpdateIndexScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER IndexRootAttr,
    IN ULONG MustBeFileName
    );

BOOLEAN
NtfsFindIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PBCB *Bcb,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    );

VOID
NtfsUpdateFileNameInIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN PDUPLICATED_INFORMATION Info,
    IN OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

VOID
NtfsAddIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN PFILE_REFERENCE FileReference,
    IN PINDEX_CONTEXT IndexContext OPTIONAL,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

VOID
NtfsDeleteIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN PFILE_REFERENCE FileReference
    );

VOID
NtfsPushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

BOOLEAN
NtfsRestartIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry,
    IN PFCB AcquiredFcb OPTIONAL
    );

BOOLEAN
NtfsContinueIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry
    );

PFILE_NAME
NtfsRetrieveOtherFileName (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT OtherContext,
    IN PFCB AcquiredFcb OPTIONAL,
    OUT PBOOLEAN SynchronizationError
    );

VOID
NtfsCleanupAfterEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    );

BOOLEAN
NtfsIsIndexEmpty (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    );

VOID
NtfsDeleteIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING AttributeName
    );

VOID
NtfsInitializeIndexContext (
    OUT PINDEX_CONTEXT IndexContext
    );

VOID
NtfsCleanupIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    );

VOID
NtfsReinitializeIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    );

//
//      PVOID
//      NtfsFoundIndexEntry (
//          IN PIRP_CONTEXT IrpContext,
//          IN PINDEX_ENTRY IndexEntry
//          );
//

#define NtfsFoundIndexEntry(IE) ((PVOID)    \
    ((PUCHAR) (IE) + sizeof( INDEX_ENTRY )) \
)

//
//  Restart routines for IndexSup
//

VOID
NtfsRestartInsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PINDEX_ENTRY BeforeIndexEntry
    );

VOID
NtfsRestartInsertSimpleAllocation (
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer,
    IN PINDEX_ENTRY BeforeIndexEntry
    );

VOID
NtfsRestartWriteEndOfIndex (
    IN PINDEX_HEADER IndexHeader,
    IN PINDEX_ENTRY OverwriteIndexEntry,
    IN PINDEX_ENTRY FirstNewIndexEntry,
    IN ULONG Length
    );

VOID
NtfsRestartSetIndexBlock(
    IN PINDEX_ENTRY IndexEntry,
    IN LONGLONG IndexBlock
    );

VOID
NtfsRestartUpdateFileName(
    IN PINDEX_ENTRY IndexEntry,
    IN PDUPLICATED_INFORMATION Info
    );

VOID
NtfsRestartDeleteSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY IndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    );

VOID
NtfsRestartDeleteSimpleAllocation (
    IN PINDEX_ENTRY IndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    );

VOID
NtOfsRestartUpdateDataInIndex(
    IN PINDEX_ENTRY IndexEntry,
    IN PVOID IndexData,
    IN ULONG Length );


//
//  Ntfs hashing routines, implemented in HashSup.c
//

VOID
NtfsInitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    );

VOID
NtfsUninitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    );

PLCB
NtfsFindPrefixHashEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_HASH_TABLE Table,
    IN PSCB ParentScb,
    IN OUT PULONG CreateFlags,
    IN OUT PFCB *CurrentFcb,
    OUT PULONG FileHashValue,
    OUT PULONG FileNameLength,
    OUT PULONG ParentHashValue,
    OUT PULONG ParentNameLength,
    IN OUT PUNICODE_STRING RemainingName
    );

VOID
NtfsInsertHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb,
    IN ULONG NameLength,
    IN ULONG HashValue
    );

VOID
NtfsRemoveHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb
    );

//
//  VOID
//  NtfsRemoveHashEntriesForLcb (
//      IN PLCB Lcb
//      );
//

#define NtfsRemoveHashEntriesForLcb(L) {                            \
    if (FlagOn( (L)->LcbState, LCB_STATE_VALID_HASH_VALUE )) {      \
        NtfsRemoveHashEntry( &(L)->Fcb->Vcb->HashTable,             \
                             (L) );                                 \
    }                                                               \
}


//
//  Ntfs Logging Routine interfaces in LogSup.c
//

LSN
NtfsWriteLog (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PBCB Bcb OPTIONAL,
    IN NTFS_LOG_OPERATION RedoOperation,
    IN PVOID RedoBuffer OPTIONAL,
    IN ULONG RedoLength,
    IN NTFS_LOG_OPERATION UndoOperation,
    IN PVOID UndoBuffer OPTIONAL,
    IN ULONG UndoLength,
    IN LONGLONG StreamOffset,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN ULONG StructureSize
    );

VOID
NtfsCheckpointVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OwnsCheckpoint,
    IN BOOLEAN CleanVolume,
    IN BOOLEAN FlushVolume,
    IN ULONG LfsFlags,
    IN LSN LastKnownLsn
    );

VOID
NtfsCheckpointForLogFileFull (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
NtfsCheckpointForVolumeSnapshot (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsCleanCheckpoint (
    IN PVCB Vcb
    );

VOID
NtfsCommitCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsCheckpointCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsInitializeLogging (
    );

VOID
NtfsStartLogFile (
    IN PSCB LogFileScb,
    IN PVCB Vcb
    );

VOID
NtfsStopLogFile (
    IN PVCB Vcb
    );

VOID
NtfsInitializeRestartTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    );

VOID
InitializeNewTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    );

VOID
NtfsFreeRestartTable (
    IN PRESTART_POINTERS TablePointer
    );

VOID
NtfsExtendRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG NumberNewEntries,
    IN ULONG FreeGoal
    );

ULONG
NtfsAllocateRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Exclusive
    );

PVOID
NtfsAllocateRestartTableFromIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    );

VOID
NtfsFreeRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    );

PVOID
NtfsGetFirstRestartTable (
    IN PRESTART_POINTERS TablePointer
    );

PVOID
NtfsGetNextRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN PVOID Current
    );

VOID
NtfsUpdateOatVersion (
    IN PVCB Vcb,
    IN ULONG NewRestartVersion
    );

VOID
NtfsFreeRecentlyDeallocated (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLSN BaseLsn,
    IN ULONG CleanVolume
    );

//
//
//  VOID
//  NtfsFreeOpenAttributeData (
//  IN POPEN_ATTRIBUTE_DATA Entry
//  );
//

#define NtfsFreeOpenAttributeData(E) {  \
    RemoveEntryList( &(E)->Links );     \
    NtfsFreePool( E );                  \
}

//
//      VOID
//      NtfsNormalizeAndCleanupTransaction (
//          IN PIRP_CONTEXT IrpContext,
//          IN NTSTATUS *Status,
//          IN BOOLEAN AlwaysRaise,
//          IN NTSTATUS NormalizeStatus
//          );
//

#define NtfsNormalizeAndCleanupTransaction(IC,PSTAT,RAISE,NORM_STAT) {                  \
    if (!NT_SUCCESS( (IC)->TopLevelIrpContext->ExceptionStatus )) {                     \
        NtfsRaiseStatus( (IC), (IC)->TopLevelIrpContext->ExceptionStatus, NULL, NULL ); \
    } else if (!NT_SUCCESS( *(PSTAT) )) {                                               \
        *(PSTAT) = FsRtlNormalizeNtstatus( *(PSTAT), (NORM_STAT) );                     \
        if ((RAISE) || ((IC)->TopLevelIrpContext->TransactionId != 0)) {                \
            NtfsRaiseStatus( (IC), *(PSTAT), NULL, NULL );                              \
        }                                                                               \
    }                                                                                   \
}

//
//      VOID
//      NtfsCleanupTransaction (
//          IN PIRP_CONTEXT IrpContext,
//          IN NTSTATUS Status,
//          IN BOOLEAN AlwaysRaise
//          );
//


#define NtfsCleanupTransaction(IC,STAT,RAISE) {                                         \
    if (!NT_SUCCESS( (IC)->TopLevelIrpContext->ExceptionStatus )) {                     \
        NtfsRaiseStatus( (IC), (IC)->TopLevelIrpContext->ExceptionStatus, NULL, NULL ); \
    } else if (!NT_SUCCESS( STAT ) &&                                                   \
              ((RAISE) || ((IC)->TopLevelIrpContext->TransactionId != 0))) {            \
        NtfsRaiseStatus( (IC), (STAT), NULL, NULL );                                    \
    } else if (((IC)->Usn.NewReasons != 0) || ((IC)->Usn.RemovedSourceInfo != 0)) {     \
        NtfsWriteUsnJournalChanges( (IC) );                                             \
        NtfsCommitCurrentTransaction( (IC) );                                           \
    }                                                                                   \
}

//
//      VOID
//      NtfsCleanupTransactionAndCommit (
//          IN PIRP_CONTEXT IrpContext,
//          IN NTSTATUS Status,
//          IN BOOLEAN AlwaysRaise
//          );
//

#define NtfsCleanupTransactionAndCommit(IC,STAT,RAISE) {                                \
    if (!NT_SUCCESS( (IC)->TopLevelIrpContext->ExceptionStatus )) {                     \
        NtfsRaiseStatus( (IC), (IC)->TopLevelIrpContext->ExceptionStatus, NULL, NULL ); \
    } else if (!NT_SUCCESS( STAT ) &&                                                   \
              ((RAISE) || ((IC)->TopLevelIrpContext->TransactionId != 0))) {            \
        NtfsRaiseStatus( (IC), (STAT), NULL, NULL );                                    \
    } else if (((IC)->Usn.NewReasons != 0) || ((IC)->Usn.RemovedSourceInfo != 0)) {     \
        NtfsWriteUsnJournalChanges( (IC) );                                             \
        NtfsCommitCurrentTransaction( (IC) );                                           \
    } else {                                                                            \
        NtfsCommitCurrentTransaction( (IC) );                                           \
    }                                                                                   \
}

VOID
NtfsCleanupFailedTransaction (
    IN PIRP_CONTEXT IrpContext
    );


//
//  NTFS MCB support routine, implemented in McbSup.c
//

//
//  An Ntfs Mcb is a superset of the regular mcb package.  In
//  addition to the regular Mcb functions it will unload mapping
//  information to keep it overall memory usage down
//

VOID
NtfsInitializeNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN PNTFS_ADVANCED_FCB_HEADER FcbHeader,
    IN PNTFS_MCB_INITIAL_STRUCTS McbStructs,
    IN POOL_TYPE PoolType
    );

VOID
NtfsUninitializeNtfsMcb (
    IN PNTFS_MCB Mcb
    );

VOID
NtfsRemoveNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Count
    );

VOID
NtfsUnloadNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN TruncateOnly,
    IN BOOLEAN AlreadySynchronized
    );

ULONG
NtfsNumberOfRangesInNtfsMcb (
    IN PNTFS_MCB Mcb
    );

BOOLEAN
NtfsNumberOfRunsInRange(
    IN PNTFS_MCB Mcb,
    IN PVOID RangePtr,
    OUT PULONG NumberOfRuns
    );

BOOLEAN
NtfsLookupLastNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn
    );

ULONG
NtfsMcbLookupArrayIndex (
    IN PNTFS_MCB Mcb,
    IN VCN Vcn
    );

BOOLEAN
NtfsSplitNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Amount
    );

BOOLEAN
NtfsAddNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Lcn,
    IN LONGLONG RunCount,
    IN BOOLEAN AlreadySynchronized
    );

BOOLEAN
NtfsLookupNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    OUT PLONGLONG Lcn OPTIONAL,
    OUT PLONGLONG CountFromLcn OPTIONAL,
    OUT PLONGLONG StartingLcn OPTIONAL,
    OUT PLONGLONG CountFromStartingLcn OPTIONAL,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    );

BOOLEAN
NtfsGetNextNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN PVOID *RangePtr,
    IN ULONG RunIndex,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn,
    OUT PLONGLONG Count
    );

//
//  BOOLEAN
//  NtfsGetSequentialMcbEntry (
//      IN PNTFS_MCB Mcb,
//      IN PVOID *RangePtr,
//      IN ULONG RunIndex,
//      OUT PLONGLONG Vcn,
//      OUT PLONGLONG Lcn,
//      OUT PLONGLONG Count
//      );
//

#define NtfsGetSequentialMcbEntry(MC,RGI,RNI,V,L,C) (   \
    NtfsGetNextNtfsMcbEntry(MC,RGI,RNI,V,L,C) ||        \
    (RNI = 0) ||                                        \
    NtfsGetNextNtfsMcbEntry(MC,RGI,MAXULONG,V,L,C) ||   \
    ((RNI = MAXULONG) == 0)                             \
    )


VOID
NtfsDefineNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN AlreadySynchronized
    );

VOID
NtfsSwapMcbs (
    IN PNTFS_MCB McbTarget,
    IN PNTFS_MCB McbSource
    );

//
//  VOID
//  NtfsAcquireNtfsMcbMutex (
//      IN PNTFS_MCB Mcb
//      );
//
//  VOID
//  NtfsReleaseNtfsMcbMutex (
//      IN PNTFS_MCB Mcb
//      );
//

#define NtfsAcquireNtfsMcbMutex(M) {    \
    ExAcquireFastMutex((M)->FastMutex); \
}

#define NtfsReleaseNtfsMcbMutex(M) {    \
    ExReleaseFastMutex((M)->FastMutex); \
}


//
//  MFT access routines, implemented in MftSup.c
//

//
//  Mft map cache routines.  We maintain a cache of active maps in the
//  IRP_CONTEXT and consult this if we need to map a file record.
//

INLINE
PIRP_FILE_RECORD_CACHE_ENTRY
NtfsFindFileRecordCacheEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber
    )
{
#if (IRP_FILE_RECORD_MAP_CACHE_SIZE <= 4)
#define PROBECACHE(ic,sn,i)                                     \
    ASSERT((ic)->FileRecordCache[(i)].FileRecordBcb != NULL);   \
    if ((ic)->FileRecordCache[(i)].UnsafeSegmentNumber == (sn)) \
    {                                                           \
        return IrpContext->FileRecordCache + (i);               \
    }

//    DebugTrace( 0, 0, ("Context %08x finding %x\n", IrpContext, UnsafeSegmentNumber ));
    ASSERT(IrpContext->CacheCount <= 4);
    switch (IrpContext->CacheCount) {
    case 4:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 3 );
        //  Fallthru

    case 3:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 2 );
        //  Fallthru

    case 2:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 1 );
        //  Fallthru

    case 1:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 0 );
        //  Fallthru

    case 0:

        //
        // redundant default case (and matching assert above) added to quiet
        // warning 4715:
        //
        //  "not all control paths return a value."
        //

    default:
        return NULL;
    }
#else
    PIRP_FILE_RECORD_CACHE_ENTRY Entry;

    for (Entry = IrpContext->FileRecordCache;
         Entry < IrpContext->FileRecordCache + IrpContext->CacheCount;
         Entry++) {
        ASSERT( Entry->FileRecordBcb != NULL);
        if (Entry->UnsafeSegmentNumber == UnsafeSegmentNumber) {
            return Entry;
        }
    }

    return NULL;

#endif
}


INLINE
VOID
NtfsRemoveFromFileRecordCache (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber
    )
{
    PIRP_FILE_RECORD_CACHE_ENTRY Entry =
        NtfsFindFileRecordCacheEntry( IrpContext, UnsafeSegmentNumber );

//    DebugTrace( 0, 0, ("Context %08x removing %x\n", IrpContext, Entry ));
    if (Entry != NULL) {

        ASSERT( Entry->FileRecordBcb != NULL );

        //
        //  We delete the entry at position [i] by dereferencing the Bcb and
        //  copying the entire structure from [IrpContext->CacheCount]
        //

        NtfsUnpinBcb( IrpContext, &Entry->FileRecordBcb );

        //
        //  Decrement the active count.  If there are no more cache entries,
        //  then we're done.
        //

        IrpContext->CacheCount--;
        if (IrpContext->FileRecordCache + IrpContext->CacheCount != Entry) {
            *Entry = IrpContext->FileRecordCache[IrpContext->CacheCount];
        }
    }
}

#ifndef KDEXT

INLINE
VOID
NtfsAddToFileRecordCache (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber,
    IN PBCB FileRecordBcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    )
{
    PAGED_CODE( );

    if (IrpContext->CacheCount < IRP_FILE_RECORD_MAP_CACHE_SIZE) {
//        DebugTrace( 0, 0, ("Context %08x adding %x at %x\n", IrpContext, UnsafeSegmentNumber,
//                   IrpContext->FileRecordCache + IrpContext->CacheCount ));
        IrpContext->FileRecordCache[IrpContext->CacheCount].UnsafeSegmentNumber =
            UnsafeSegmentNumber;
        IrpContext->FileRecordCache[IrpContext->CacheCount].FileRecordBcb =
            NtfsRemapBcb( IrpContext, FileRecordBcb );
        IrpContext->FileRecordCache[IrpContext->CacheCount].FileRecord = FileRecord;
        IrpContext->CacheCount++;
    }
}

#endif

INLINE
VOID
NtfsPurgeFileRecordCache (
    IN PIRP_CONTEXT IrpContext
    )
{
    while (IrpContext->CacheCount) {

        IrpContext->CacheCount --;
//        DebugTrace( 0, 0, ("Context %08x purging %x\n", IrpContext, IrpContext->FileRecordCache + IrpContext->CacheCount ));
        NtfsUnpinBcb( IrpContext, &IrpContext->FileRecordCache[IrpContext->CacheCount].FileRecordBcb );
    }
}

#if DBG
extern ULONG FileRecordCacheHitArray[IRP_FILE_RECORD_MAP_CACHE_SIZE];
#endif  //  DBG

INLINE
BOOLEAN
NtfsFindCachedFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord
    )
{
    PIRP_FILE_RECORD_CACHE_ENTRY Entry =
        NtfsFindFileRecordCacheEntry( IrpContext, UnsafeSegmentNumber );

//    DebugTrace( 0, 0, ("Context %x finding %x = %x\n", IrpContext, UnsafeSegmentNumber, Entry ));

    if (Entry == NULL) {

        return FALSE;

    }

    *Bcb = NtfsRemapBcb( IrpContext, Entry->FileRecordBcb );
    *FileRecord = Entry->FileRecord;

     return TRUE;
}


//
//  This routine may only be used to read the Base file record segment, and
//  it checks that this is true.
//

VOID
NtfsReadFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *BaseFileRecord,
    OUT PATTRIBUTE_RECORD_HEADER *FirstAttribute,
    OUT PLONGLONG MftFileOffset OPTIONAL
    );

//
//  These routines can read/pin any record in the MFT.
//

VOID
NtfsReadMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN CheckRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    );

VOID
NtfsPinMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN PreparingToWrite,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    );

//
//  The following routines are used to setup, allocate, and deallocate
//  file records in the Mft.
//

MFT_SEGMENT_REFERENCE
NtfsAllocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MftData
    );

VOID
NtfsInitializeMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PMFT_SEGMENT_REFERENCE MftSegment,
    IN OUT PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB Bcb,
    IN BOOLEAN Directory
    );

VOID
NtfsDeallocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FileNumber
    );

BOOLEAN
NtfsIsMftIndexInHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index,
    OUT PULONG HoleLength OPTIONAL
    );

VOID
NtfsFillMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index
    );

VOID
NtfsLogMftFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN LONGLONG MftOffset,
    IN PBCB FileRecordBcb,
    IN BOOLEAN RedoOperation
    );

BOOLEAN
NtfsDefragMft (
    IN PDEFRAG_MFT DefragMft
    );

VOID
NtfsCheckForDefrag (
    IN OUT PVCB Vcb
    );

VOID
NtfsInitializeMftHoleRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FirstIndex,
    IN ULONG RecordCount
    );


//
//  Name support routines, implemented in NameSup.c
//

typedef enum _PARSE_TERMINATION_REASON {

    EndOfPathReached,
    NonSimpleName,
    IllegalCharacterInName,
    MalFormedName,
    AttributeOnly,
    VersionNumberPresent

} PARSE_TERMINATION_REASON;

#define NtfsDissectName(Path,FirstName,RemainingName)   \
    ( FsRtlDissectName( Path, FirstName, RemainingName ) )

BOOLEAN
NtfsParseName (
    IN const UNICODE_STRING Name,
    IN BOOLEAN WildCardsPermissible,
    OUT PBOOLEAN FoundIllegalCharacter,
    OUT PNTFS_NAME_DESCRIPTOR ParsedName
    );

PARSE_TERMINATION_REASON
NtfsParsePath (
    IN UNICODE_STRING Path,
    IN BOOLEAN WildCardsPermissible,
    OUT PUNICODE_STRING FirstPart,
    OUT PNTFS_NAME_DESCRIPTOR Name,
    OUT PUNICODE_STRING RemainingPart
    );

VOID
NtfsPreprocessName (
    IN UNICODE_STRING InputString,
    OUT PUNICODE_STRING FirstPart,
    OUT PUNICODE_STRING AttributeCode,
    OUT PUNICODE_STRING AttributeName,
    OUT PBOOLEAN TrailingBackslash
    );

VOID
NtfsUpcaseName (
    IN PWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN OUT PUNICODE_STRING InputString
    );

FSRTL_COMPARISON_RESULT
NtfsCollateNames (
    IN PCWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN PCUNICODE_STRING Expression,
    IN PCUNICODE_STRING Name,
    IN FSRTL_COMPARISON_RESULT WildIs,
    IN BOOLEAN IgnoreCase
    );

#define NtfsIsNameInExpression(UC,EX,NM,IC)         \
    FsRtlIsNameInExpression( (EX), (NM), (IC), (UC) )

BOOLEAN
NtfsIsFileNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    );

BOOLEAN
NtfsIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    );

//
//  Ntfs works very hard to make sure that all names are kept in upper case
//  so that most comparisons are done case SENSITIVE.  Name testing for
//  case SENSITIVE can be very quick since RtlEqualMemory is an inline operation
//  on several processors.
//
//  NtfsAreNamesEqual is used when the caller does not know for sure whether
//  or not case is important.  In the case where IgnoreCase is a known value,
//  the compiler can easily optimize the relevant clause.
//

#define NtfsAreNamesEqual(UpcaseTable,Name1,Name2,IgnoreCase)                           \
    ((IgnoreCase) ? FsRtlAreNamesEqual( (Name1), (Name2), (IgnoreCase), (UpcaseTable) ) \
                  : ((Name1)->Length == (Name2)->Length &&                              \
                     RtlEqualMemory( (Name1)->Buffer, (Name2)->Buffer, (Name1)->Length )))


//
//  Object id support routines, implemented in ObjIdSup.c
//

VOID
NtfsInitializeObjectIdIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    );

NTSTATUS
NtfsSetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PFILE_OBJECTID_BUFFER ObjectIdBuffer
    );

NTSTATUS
NtfsCreateOrGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN GetExtendedInfo,
    OUT FILE_OBJECTID_BUFFER *OutputBuffer
    );

NTSTATUS
NtfsGetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR *ObjectId,
    IN OUT UCHAR *ExtendedInfo
    );

NTSTATUS
NtfsDeleteObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeleteObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN BOOLEAN DeleteFileAttribute
    );

VOID
NtfsRepairObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );


//
//  Mount point support routines, implemented in MountSup.c
//

VOID
NtfsInitializeReparsePointIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    );


//
//  Largest matching prefix searching routines, implemented in PrefxSup.c
//

VOID
NtfsInsertPrefix (
    IN PLCB Lcb,
    IN ULONG CreateFlags
    );

VOID
NtfsRemovePrefix (
    IN PLCB Lcb
    );

PLCB
NtfsFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB StartingScb,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    IN OUT UNICODE_STRING FullFileName,
    IN OUT PULONG CreateFlags,
    OUT PUNICODE_STRING RemainingName
    );

BOOLEAN
NtfsInsertNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    );

//
//  VOID
//  NtfsRemoveNameLink (
//      IN PRTL_SPLAY_LINKS *RootNode,
//      IN PNAME_LINK NameLink
//      );
//

#define NtfsRemoveNameLink(RN,NL) {      \
    *(RN) = RtlDelete( &(NL)->Links );      \
}

PNAME_LINK
NtfsFindNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    );

//
//  The following macro is useful for traversing the queue of Prefixes
//  attached to a given Lcb
//
//      PPREFIX_ENTRY
//      NtfsGetNextPrefix (
//          IN PIRP_CONTEXT IrpContext,
//          IN PLCB Lcb,
//          IN PPREFIX_ENTRY PreviousPrefixEntry
//          );
//

#define NtfsGetNextPrefix(IC,LC,PPE) ((PPREFIX_ENTRY)                                               \
    ((PPE) == NULL ?                                                                                \
        (IsListEmpty(&(LC)->PrefixQueue) ?                                                          \
            NULL                                                                                    \
        :                                                                                           \
            CONTAINING_RECORD((LC)->PrefixQueue.Flink, PREFIX_ENTRY, LcbLinks.Flink)                \
        )                                                                                           \
    :                                                                                               \
        ((PVOID)((PPREFIX_ENTRY)(PPE))->LcbLinks.Flink == &(LC)->PrefixQueue.Flink ?                \
            NULL                                                                                    \
        :                                                                                           \
            CONTAINING_RECORD(((PPREFIX_ENTRY)(PPE))->LcbLinks.Flink, PREFIX_ENTRY, LcbLinks.Flink) \
        )                                                                                           \
    )                                                                                               \
)


//
//  Resources support routines/macros, implemented in ResrcSup.c
//

//
//  Flags used in the acquire routines
//

#define ACQUIRE_NO_DELETE_CHECK         (0x00000001)
#define ACQUIRE_DONT_WAIT               (0x00000002)
#define ACQUIRE_HOLD_BITMAP             (0x00000004)
#define ACQUIRE_WAIT                    (0x00000008)

//
//  VOID
//  NtfsAcquireExclusiveGlobal (
//      IN PIRP_CONTEXT IrpContext,
//      IN BOOLEAN Wait
//      );
//
//  BOOLEAN
//  NtfsAcquireSharedGlobal (
//      IN PIRP_CONTEXT IrpContext,
//      IN BOOLEAN Wait
//      );
//


#define NtfsAcquireSharedGlobal( I, W ) ExAcquireResourceSharedLite( &NtfsData.Resource, (W) )

#define NtfsAcquireExclusiveGlobal( I, W ) ExAcquireResourceExclusiveLite( &NtfsData.Resource, (W) )

VOID
NtfsAcquireCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsReleaseCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  VOID
//  NtfsLockNtfsData (
//      );
//
//  VOID
//  NtfsUnlockNtfsData (
//      );
//

#define NtfsLockNtfsData() {                        \
    ExAcquireFastMutex( &NtfsData.NtfsDataLock );   \
}

#define NtfsUnlockNtfsData() {                      \
    ExReleaseFastMutex( &NtfsData.NtfsDataLock );   \
}

VOID
NtfsAcquireAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Exclusive,
    IN ULONG AcquirePagingIo,
    IN ULONG AcquireAndDrop
    );

VOID
NtfsReleaseAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN ReleasePagingIo
    );

BOOLEAN
NtfsAcquireExclusiveVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    );

BOOLEAN
NtfsAcquireSharedVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    );

#define NtfsAcquireExclusivePagingIo(IC,FCB) {                          \
    ASSERT((IC)->CleanupStructure == NULL);                             \
    ExAcquireResourceExclusiveLite(((PFCB)(FCB))->PagingIoResource, TRUE);  \
    (IC)->CleanupStructure = (FCB);                                     \
}

#define NtfsReleasePagingIo(IC,FCB) {                                   \
    ASSERT((IC)->CleanupStructure == (FCB));                            \
    ExReleaseResourceLite(((PFCB)(FCB))->PagingIoResource);                 \
    (IC)->CleanupStructure = NULL;                                      \
}

BOOLEAN
NtfsAcquireFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    );

VOID
NtfsReleaseFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsReleaseScbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

BOOLEAN
NtfsAcquireExclusiveFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    );

VOID
NtfsAcquireSharedFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    );

BOOLEAN
NtfsAcquireSharedFcbCheckWait (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    );

VOID
NtfsReleaseFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsAcquireExclusiveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

#ifdef NTFSDBG

BOOLEAN
NtfsAcquireResourceExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    );

#else

INLINE
BOOLEAN
NtfsAcquireResourceExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )
{
    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        return ExAcquireResourceExclusiveLite( ((PFCB)FcbOrScb)->Resource, Wait );
    } else {
        return ExAcquireResourceExclusiveLite( ((PSCB)(FcbOrScb))->Header.Resource, Wait );
    }
}

#endif

INLINE
BOOLEAN
NtfsAcquirePagingResourceSharedWaitForExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )
{
    BOOLEAN Result;

    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Result = ExAcquireSharedWaitForExclusive( ((PFCB)FcbOrScb)->PagingIoResource, Wait );
    } else {
        Result = ExAcquireSharedWaitForExclusive( ((PSCB)(FcbOrScb))->Header.PagingIoResource, Wait );
    }
    return Result;
}

#ifdef NTFSDBG
BOOLEAN
NtfsAcquireResourceShared (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   );
#else

INLINE
BOOLEAN
NtfsAcquireResourceShared (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   )
{
    BOOLEAN Result;

    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Result =  ExAcquireResourceSharedLite( ((PFCB)FcbOrScb)->Resource, Wait );
    } else {

        ASSERT_SCB( FcbOrScb );

        Result = ExAcquireResourceSharedLite( ((PSCB)(FcbOrScb))->Header.Resource, Wait );
    }
    return Result;
}

#endif

//
//  VOID
//  NtfsReleaseResource(
//      IN PIRP_CONTEXT IrpContext OPTIONAL,
//      IN PVOID FcbOrScb
//      };
//

#ifdef NTFSDBG

VOID
NtfsReleaseResource(
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb
    );

#else
#define NtfsReleaseResource( IC, F ) {                                        \
        if (NTFS_NTC_FCB == ((PFCB)(F))->NodeTypeCode) {                      \
            ExReleaseResourceLite( ((PFCB)(F))->Resource );                       \
        } else {                                                              \
            ExReleaseResourceLite( ((PSCB)(F))->Header.Resource );                \
        }                                                                     \
    }

#endif

VOID
NtfsAcquireSharedScbForTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
NtfsReleaseSharedResources (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsReleaseAllResources (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsAcquireIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb,
    IN PEOF_WAIT_BLOCK EofWaitBlock
    );

VOID
NtfsReleaseIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb
    );

//
//  VOID
//  NtfsAcquireSharedScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsReleaseScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsReleaseGlobal (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  NtfsAcquireFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      );
//
//  VOID
//  NtfsReleaseFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsLockVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsUnlockVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsLockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  NtfsUnlockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  NtfsAcquireFcbSecurity (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      );
//
//  VOID
//  NtfsReleaseFcbSecurity (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireHashTable (
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsReleaseHashTable (
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireCheckpoint (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      );
//
//  VOID
//  NtfsReleaseCheckpoint (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsWaitOnCheckpointNotify (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsSetCheckpointNotify (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsResetCheckpointNotify (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireReservedClusters (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsReleaseReservedClusters (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireUsnNotify (
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsDeleteUsnNotify (
//      IN PVCB Vcb
//      );
//
//  VOID NtfsAcquireFsrtlHeader (
//      IN PSCB Scb
//      );
//
//  VOID NtfsReleaseFsrtlHeader (
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsReleaseVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//

VOID
NtfsReleaseVcbCheckDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR MajorCode,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

#define NtfsAcquireSharedScb(IC,S) {                \
    NtfsAcquireSharedFcb((IC),(S)->Fcb, S, 0);      \
}

#define NtfsReleaseScb(IC,S) {     \
    NtfsReleaseFcb((IC),(S)->Fcb); \
}

#define NtfsReleaseGlobal(IC) {              \
    ExReleaseResourceLite( &NtfsData.Resource ); \
}

#define NtfsAcquireFcbTable(IC,V) {                         \
    ExAcquireFastMutexUnsafe( &(V)->FcbTableMutex );        \
}

#define NtfsReleaseFcbTable(IC,V) {                         \
    ExReleaseFastMutexUnsafe( &(V)->FcbTableMutex );        \
}

#define NtfsLockVcb(IC,V) {                                 \
    ExAcquireFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsUnlockVcb(IC,V) {                               \
    ExReleaseFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsLockFcb(IC,F) {                                 \
    ExAcquireFastMutex( (F)->FcbMutex );              \
}

#define NtfsUnlockFcb(IC,F) {                               \
    ExReleaseFastMutex( (F)->FcbMutex );              \
}

#define NtfsAcquireFcbSecurity(V) {                         \
    ExAcquireFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsReleaseFcbSecurity(V) {                         \
    ExReleaseFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsAcquireHashTable(V) {                           \
    ExAcquireFastMutexUnsafe( &(V)->HashTableMutex );       \
}

#define NtfsReleaseHashTable(V) {                           \
    ExReleaseFastMutexUnsafe( &(V)->HashTableMutex );       \
}

#define NtfsAcquireCheckpoint(IC,V) {                       \
    ExAcquireFastMutexUnsafe( &(V)->CheckpointMutex );      \
}

#define NtfsReleaseCheckpoint(IC,V) {                       \
    ExReleaseFastMutexUnsafe( &(V)->CheckpointMutex );      \
}

#define NtfsWaitOnCheckpointNotify(IC,V) {                          \
    NTSTATUS _Status;                                               \
    _Status = KeWaitForSingleObject( &(V)->CheckpointNotifyEvent,   \
                                     Executive,                     \
                                     KernelMode,                    \
                                     FALSE,                         \
                                     NULL );                        \
    if (!NT_SUCCESS( _Status )) {                                   \
        NtfsRaiseStatus( IrpContext, _Status, NULL, NULL );         \
    }                                                               \
}

#define NtfsSetCheckpointNotify(IC,V) {                             \
    (V)->CheckpointOwnerThread = NULL;                              \
    KeSetEvent( &(V)->CheckpointNotifyEvent, 0, FALSE );            \
}

#define NtfsResetCheckpointNotify(IC,V) {                           \
    (V)->CheckpointOwnerThread = (PVOID) PsGetCurrentThread();      \
    KeClearEvent( &(V)->CheckpointNotifyEvent );                    \
}

#define NtfsAcquireUsnNotify(V) {                           \
    ExAcquireFastMutex( &(V)->CheckpointMutex );            \
}

#define NtfsReleaseUsnNotify(V) {                           \
    ExReleaseFastMutex( &(V)->CheckpointMutex );            \
}

#define NtfsAcquireReservedClusters(V) {                    \
    ExAcquireFastMutexUnsafe( &(V)->ReservedClustersMutex );\
}

#define NtfsReleaseReservedClusters(V) {                    \
    ExReleaseFastMutexUnsafe( &(V)->ReservedClustersMutex );\
}

#define NtfsAcquireFsrtlHeader(S) {                         \
    ExAcquireFastMutex((S)->Header.FastMutex);              \
}

#define NtfsReleaseFsrtlHeader(S) {                         \
    ExReleaseFastMutex((S)->Header.FastMutex);              \
}

#ifdef NTFSDBG

VOID NtfsReleaseVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

#else

#define NtfsReleaseVcb(IC,V) {                              \
    ExReleaseResourceLite( &(V)->Resource );                    \
}

#endif

//
//  Macros to test resources for exclusivity.
//

#define NtfsIsExclusiveResource(R) (                            \
    ExIsResourceAcquiredExclusiveLite(R)                        \
)

#define NtfsIsExclusiveFcb(F) (                                 \
    (NtfsIsExclusiveResource((F)->Resource))                    \
)

#define NtfsIsExclusiveFcbPagingIo(F) (                         \
    (NtfsIsExclusiveResource((F)->PagingIoResource))            \
)

#define NtfsIsExclusiveScbPagingIo(S) (                         \
    (NtfsIsExclusiveFcbPagingIo((S)->Fcb))                      \
)

#define NtfsIsExclusiveScb(S) (                                 \
    (NtfsIsExclusiveFcb((S)->Fcb))                              \
)

#define NtfsIsExclusiveVcb(V) (                                 \
    (NtfsIsExclusiveResource(&(V)->Resource))                   \
)

//
//  Macros to test resources for shared acquire
//

#define NtfsIsSharedResource(R) (                               \
    ExIsResourceAcquiredSharedLite(R)                           \
)

#define NtfsIsSharedFcb(F) (                                    \
    (NtfsIsSharedResource((F)->Resource))                       \
)

#define NtfsIsSharedFcbPagingIo(F) (                            \
    (NtfsIsSharedResource((F)->PagingIoResource))               \
)

#define NtfsIsSharedScbPagingIo(S) (                            \
    (NtfsIsSharedFcbPagingIo((S)->Fcb))                         \
)

#define NtfsIsSharedScb(S) (                                    \
    (NtfsIsSharedFcb((S)->Fcb))                                 \
)

#define NtfsIsSharedVcb(V) (                                    \
    (NtfsIsSharedResource(&(V)->Resource))                      \
)

__inline
VOID
NtfsReleaseExclusiveScbIfOwned(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )
/*++

Routine Description:

    This routine is called release an Scb that may or may not be currently
    owned exclusive.

Arguments:

    IrpContext - Context of call

    Scb - Scb to be released

Return Value:

    None.

--*/
{
    if (Scb->Fcb->ExclusiveFcbLinks.Flink != NULL &&
        NtfsIsExclusiveScb( Scb )) {

        NtfsReleaseScb( IrpContext, Scb );
    }
}

//
//  The following are cache manager call backs.  They return FALSE
//  if the resource cannot be acquired with waiting and wait is false.
//

BOOLEAN
NtfsAcquireScbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
NtfsReleaseScbFromLazyWrite (
    IN PVOID Null
    );

NTSTATUS
NtfsAcquireFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsAcquireFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsReleaseFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
NtfsAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
NtfsReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    );


BOOLEAN
NtfsAcquireScbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
NtfsReleaseScbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
NtfsAcquireVolumeFileForLazyWrite (
    IN PVOID Vcb,
    IN BOOLEAN Wait
    );

VOID
NtfsReleaseVolumeFileFromLazyWrite (
    IN PVOID Vcb
    );


//
//  Ntfs Logging Routine interfaces in RestrSup.c
//

BOOLEAN
NtfsRestartVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PBOOLEAN UnrecognizedRestart
    );

VOID
NtfsAbortTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PTRANSACTION_ENTRY Transaction OPTIONAL
    );

NTSTATUS
NtfsCloseAttributesFromRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );


//
//  Security support routines, implemented in SecurSup.c
//

//
//  VOID
//  NtfsTraverseCheck (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB ParentFcb,
//      IN PIRP Irp
//      );
//
//  VOID
//  NtfsOpenCheck (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFCB ParentFcb OPTIONAL,
//      IN PIRP Irp
//      );
//
//  VOID
//  NtfsCreateCheck (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB ParentFcb,
//      IN PIRP Irp
//      );
//

#define NtfsTraverseCheck(IC,F,IR) { \
    NtfsAccessCheck( IC,             \
                     F,              \
                     NULL,           \
                     IR,             \
                     FILE_TRAVERSE,  \
                     TRUE );         \
}

#define NtfsOpenCheck(IC,F,PF,IR) {                                                                      \
    NtfsAccessCheck( IC,                                                                                 \
                     F,                                                                                  \
                     PF,                                                                                 \
                     IR,                                                                                 \
                     IoGetCurrentIrpStackLocation(IR)->Parameters.Create.SecurityContext->DesiredAccess, \
                     FALSE );                                                                            \
}

#define NtfsCreateCheck(IC,PF,IR) {                                                                              \
    NtfsAccessCheck( IC,                                                                                         \
                     PF,                                                                                         \
                     NULL,                                                                                       \
                     IR,                                                                                         \
                     (FlagOn(IoGetCurrentIrpStackLocation(IR)->Parameters.Create.Options, FILE_DIRECTORY_FILE) ? \
                        FILE_ADD_SUBDIRECTORY : FILE_ADD_FILE),                                                  \
                     TRUE );                                                                                     \
}

VOID
NtfsAssignSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PIRP Irp,
    IN PFCB NewFcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB FileRecordBcb,
    IN LONGLONG FileOffset,
    IN OUT PBOOLEAN LogIt
    );

NTSTATUS
NtfsModifySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
NtfsQuerySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG SecurityDescriptorLength
    );

VOID
NtfsAccessCheck (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PIRP Irp,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN CheckOnly
    );

BOOLEAN
NtfsCanAdministerVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR TestSecurityDescriptor OPTIONAL,
    IN PULONG TestDesiredAccess OPTIONAL
    );

NTSTATUS
NtfsCheckFileForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN FcbExisted,
    IN PINDEX_ENTRY IndexEntry
    );

VOID
NtfsCheckIndexForAddOrDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreatePrivileges
    );

VOID
NtfsSetFcbSecurityFromDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    );

INLINE
VOID
RemoveReferenceSharedSecurityUnsafe (
    IN OUT PSHARED_SECURITY *SharedSecurity
    )
/*++

Routine Description:

    This routine is called to manage the reference count on a shared security
    descriptor.  If the reference count goes to zero, the shared security is
    freed.

Arguments:

    SharedSecurity - security that is being dereferenced.

Return Value:

    None.

--*/
{
    DebugTrace( 0, (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX),
                ( "RemoveReferenceSharedSecurityUnsafe( %08x )\n", *SharedSecurity ));
    //
    //  Note that there will be one less reference shortly
    //

    ASSERT( (*SharedSecurity)->ReferenceCount != 0 );

    (*SharedSecurity)->ReferenceCount--;

    if ((*SharedSecurity)->ReferenceCount == 0) {
        DebugTrace( 0, (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX),
                    ( "RemoveReferenceSharedSecurityUnsafe freeing\n" ));
        NtfsFreePool( *SharedSecurity );
    }
    *SharedSecurity = NULL;
}

BOOLEAN
NtfsNotifyTraverseCheck (
    IN PCCB Ccb,
    IN PFCB Fcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

VOID
NtfsLoadSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsStoreSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN LogIt
    );

VOID
NtfsInitializeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    );

VOID
NtOfsPurgeSecurityCache (
    IN PVCB Vcb
    );

PSHARED_SECURITY
NtfsCacheSharedSecurityBySecurityId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId
    );

PSHARED_SECURITY
NtfsCacheSharedSecurityForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb
    );

SECURITY_ID
GetSecurityIdFromSecurityDescriptorUnsafe (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    );

FSRTL_COMPARISON_RESULT
NtOfsCollateSecurityHash (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    );

#ifdef NTFS_CACHE_RIGHTS
VOID
NtfsGetCachedRightsById (
    IN PVCB Vcb,
    IN PLUID TokenId,
    IN PLUID ModifiedId,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PACCESS_MASK Rights
    );

NTSTATUS
NtfsGetCachedRights (
    IN PVCB Vcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PACCESS_MASK Rights,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PLUID TokenId OPTIONAL,
    OUT PLUID ModifiedId OPTIONAL
    );
#endif


//
//  In-memory structure support routine, implemented in StrucSup.c
//

//
//  Routines to create and destroy the Vcb
//

VOID
NtfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    );

BOOLEAN
NtfsDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB *Vcb
    );

//
//  Routines to create and destroy the Fcb
//

PFCB
NtfsCreateRootFcb (                         //  also creates the root lcb
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

PFCB
NtfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_REFERENCE FileReference,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN LargeFcb,
    OUT PBOOLEAN ReturnedExistingFcb OPTIONAL
    );

VOID
NtfsDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *Fcb,
    OUT PBOOLEAN AcquiredFcbTable
    );

PFCB
NtfsGetNextFcbTableEntry (
    IN PVCB Vcb,
    IN PVOID *RestartKey
    );

//
//  Routines to create and destroy the Scb
//

PSCB
NtfsCreateScb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PCUNICODE_STRING AttributeName,
    IN BOOLEAN ReturnExistingOnly,
    OUT PBOOLEAN ReturnedExistingScb OPTIONAL
    );

PSCB
NtfsCreatePrerestartScb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN ULONG BytesPerIndexBuffer
    );

VOID
NtfsFreeScbAttributeName (
    IN PWSTR AttributeNameBuffer
    );

VOID
NtfsDeleteScb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb
    );

BOOLEAN
NtfsUpdateNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PSCB Scb,
    IN PFILE_NAME FileName OPTIONAL,
    IN BOOLEAN CheckBufferSizeOnly
    );

VOID
NtfsDeleteNormalizedName (
    IN PSCB Scb
    );

typedef
NTSTATUS
(*NTFSWALKUPFUNCTION)(
    PIRP_CONTEXT IrpContext,
    PFCB Fcb,
    PSCB Scb,
    PFILE_NAME FileName,
    PVOID Context );

NTSTATUS
NtfsWalkUpTree (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN NTFSWALKUPFUNCTION WalkUpFunction,
    IN OUT PVOID Context
    );

typedef struct {
    UNICODE_STRING Name;
    FILE_REFERENCE Scope;
    BOOLEAN IsRoot;
#ifdef BENL_DBG
    PFCB StartFcb;
#endif
} SCOPE_CONTEXT, *PSCOPE_CONTEXT;

NTSTATUS
NtfsBuildRelativeName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN OUT PVOID Context
    );

VOID
NtfsBuildNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB IndexScb OPTIONAL,
    OUT PUNICODE_STRING FileName
    );

VOID
NtfsSnapshotScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
NtfsUpdateScbSnapshots (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsRestoreScbSnapshots (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Higher
    );

VOID
NtfsMungeScbSnapshot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileSize
    );

VOID
NtfsFreeSnapshotsForFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

BOOLEAN
NtfsCreateFileLock (
    IN PSCB Scb,
    IN BOOLEAN RaiseOnError
    );

//
//
//  A general purpose teardown routine that helps cleanup the
//  the Fcb/Scb structures
//

VOID
NtfsTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID FcbOrScb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedFcb OPTIONAL
    );

//
//  Routines to create, destroy and walk through the Lcbs
//

PLCB
NtfsCreateLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN UNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN OUT PBOOLEAN ReturnedExistingLcb OPTIONAL
    );

VOID
NtfsDeleteLcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PLCB *Lcb
    );

VOID
NtfsMoveLcb (   //  also munges the ccb and fileobjects filenames
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PUNICODE_STRING TargetDirectoryName,
    IN PUNICODE_STRING LastComponentName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    );

VOID
NtfsRenameLcb ( //  also munges the ccb and fileobjects filenames
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PUNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    );

VOID
NtfsCombineLcbs (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB PrimaryLcb,
    IN PLCB AuxLcb
    );

PLCB
NtfsLookupLcbByFlags (
    IN PFCB Fcb,
    IN UCHAR FileNameFlags
    );

ULONG
NtfsLookupNameLengthViaLcb (
    IN PFCB Fcb,
    OUT PBOOLEAN LeadingBackslash
    );

VOID
NtfsFileNameViaLcb (
    IN PFCB Fcb,
    IN PWCHAR FileName,
    ULONG Length,
    ULONG BytesToCopy
    );

//
//      VOID
//      NtfsLinkCcbToLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PCCB Ccb,
//          IN PLCB Lcb
//          );
//

#define NtfsLinkCcbToLcb(IC,C,L) {                    \
    InsertTailList( &(L)->CcbQueue, &(C)->LcbLinks ); \
    (C)->Lcb = (L);                                   \
}

//
//      VOID
//      NtfsUnlinkCcbFromLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PCCB Ccb
//          );
//

#define NtfsUnlinkCcbFromLcb(IC,C) {            \
    if ((C)->Lcb != NULL) {                     \
        RemoveEntryList( &(C)->LcbLinks );      \
        (C)->Lcb = NULL;                        \
    }                                           \
}

//
//  Routines to create and destroy the Ccb
//

PCCB
NtfsCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN BOOLEAN Indexed,
    IN USHORT EaModificationCount,
    IN ULONG Flags,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset
    );

VOID
NtfsDeleteCcb (
    IN PFCB Fcb,
    IN OUT PCCB *Ccb
    );

//
//  Routines to create and destroy the IrpContext
//

VOID
NtfsInitializeIrpContext (
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN Wait,
    IN OUT PIRP_CONTEXT *IrpContext
    );

VOID
NtfsCleanupIrpContext (
    IN OUT PIRP_CONTEXT IrpContext,
    IN ULONG Retry
    );

//
//  Routine for scanning the Fcbs within the graph hierarchy
//

PSCB
NtfsGetNextScb (
    IN PSCB Scb,
    IN PSCB TerminationScb
    );

//
//  The following macros are useful for traversing the queues interconnecting
//  fcbs, scb, and lcbs.
//
//      PSCB
//      NtfsGetNextChildScb (
//          IN PFCB Fcb,
//          IN PSCB PreviousChildScb
//          );
//
//      PLCB
//      NtfsGetNextParentLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFCB Fcb,
//          IN PLCB PreviousParentLcb
//          );
//
//      PLCB
//      NtfsGetNextChildLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PSCB Scb,
//          IN PLCB PreviousChildLcb
//          );
//
//      PLCB
//      NtfsGetPrevChildLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PSCB Scb,
//          IN PLCB PreviousChildLcb
//          );
//
//      PLCB
//      NtfsGetNextParentLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFCB Fcb,
//          IN PLCB PreviousChildLcb
//          );
//
//      PCCB
//      NtfsGetNextCcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PLCB Lcb,
//          IN PCCB PreviousCcb
//          );
//

#define NtfsGetNextChildScb(F,P) ((PSCB)                                        \
    ((P) == NULL ?                                                              \
        (IsListEmpty(&(F)->ScbQueue) ?                                          \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD((F)->ScbQueue.Flink, SCB, FcbLinks.Flink)         \
        )                                                                       \
    :                                                                           \
        ((PVOID)((PSCB)(P))->FcbLinks.Flink == &(F)->ScbQueue.Flink ?           \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD(((PSCB)(P))->FcbLinks.Flink, SCB, FcbLinks.Flink) \
        )                                                                       \
    )                                                                           \
)

#define NtfsGetNextParentLcb(F,P) ((PLCB)                                       \
    ((P) == NULL ?                                                              \
        (IsListEmpty(&(F)->LcbQueue) ?                                          \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD((F)->LcbQueue.Flink, LCB, FcbLinks.Flink)         \
        )                                                                       \
    :                                                                           \
        ((PVOID)((PLCB)(P))->FcbLinks.Flink == &(F)->LcbQueue.Flink ?           \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD(((PLCB)(P))->FcbLinks.Flink, LCB, FcbLinks.Flink) \
        )                                                                       \
    )                                                                           \
)

#define NtfsGetNextChildLcb(S,P) ((PLCB)                                              \
    ((P) == NULL ?                                                                    \
        ((((NodeType(S) == NTFS_NTC_SCB_DATA) || (NodeType(S) == NTFS_NTC_SCB_MFT))   \
          || IsListEmpty(&(S)->ScbType.Index.LcbQueue)) ?                             \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD((S)->ScbType.Index.LcbQueue.Flink, LCB, ScbLinks.Flink) \
        )                                                                             \
    :                                                                                 \
        ((PVOID)((PLCB)(P))->ScbLinks.Flink == &(S)->ScbType.Index.LcbQueue.Flink ?   \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD(((PLCB)(P))->ScbLinks.Flink, LCB, ScbLinks.Flink)       \
        )                                                                             \
    )                                                                                 \
)

#define NtfsGetPrevChildLcb(S,P) ((PLCB)                                              \
    ((P) == NULL ?                                                                    \
        ((((NodeType(S) == NTFS_NTC_SCB_DATA) || (NodeType(S) == NTFS_NTC_SCB_MFT))   \
          || IsListEmpty(&(S)->ScbType.Index.LcbQueue)) ?                             \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD((S)->ScbType.Index.LcbQueue.Blink, LCB, ScbLinks.Flink) \
        )                                                                             \
    :                                                                                 \
        ((PVOID)((PLCB)(P))->ScbLinks.Blink == &(S)->ScbType.Index.LcbQueue.Flink ?   \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD(((PLCB)(P))->ScbLinks.Blink, LCB, ScbLinks.Flink)       \
        )                                                                             \
    )                                                                                 \
)

#define NtfsGetNextParentLcb(F,P) ((PLCB)                                             \
    ((P) == NULL ?                                                                    \
        (IsListEmpty(&(F)->LcbQueue) ?                                                \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD((F)->LcbQueue.Flink, LCB, FcbLinks.Flink)               \
        )                                                                             \
    :                                                                                 \
        ((PVOID)((PLCB)(P))->FcbLinks.Flink == &(F)->LcbQueue.Flink ?                 \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD(((PLCB)(P))->FcbLinks.Flink, LCB, FcbLinks.Flink)       \
        )                                                                             \
    )                                                                                 \
)

#define NtfsGetNextCcb(L,P) ((PCCB)                                             \
    ((P) == NULL ?                                                              \
        (IsListEmpty(&(L)->CcbQueue) ?                                          \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD((L)->CcbQueue.Flink, CCB, LcbLinks.Flink)         \
        )                                                                       \
    :                                                                           \
        ((PVOID)((PCCB)(P))->LcbLinks.Flink == &(L)->CcbQueue.Flink ?           \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD(((PCCB)(P))->LcbLinks.Flink, CCB, LcbLinks.Flink) \
        )                                                                       \
    )                                                                           \
)


#define NtfsGetFirstCcbEntry(S)                                                 \
    (IsListEmpty( &(S)->CcbQueue )                                              \
        ? NULL                                                                  \
        : CONTAINING_RECORD( (S)->CcbQueue.Flink, CCB, CcbLinks.Flink ))

#define NtfsGetNextCcbEntry(S,C)                                                \
    ( (PVOID)&(S)->CcbQueue.Flink == (PVOID)(C)->CcbLinks.Flink                 \
        ? NULL                                                                  \
        : CONTAINING_RECORD( (C)->CcbLinks.Flink, CCB, CcbLinks.Flink ))


//
//      VOID
//      NtfsDeleteFcbTableEntry (
//          IN PVCB Vcb,
//          IN FILE_REFERENCE FileReference
//          );
//

#if (defined( NTFS_FREE_ASSERTS ))
#define NtfsDeleteFcbTableEntry(V,FR) {                                     \
    FCB_TABLE_ELEMENT _Key;                                                 \
    BOOLEAN _RemovedEntry;                                                  \
    _Key.FileReference = FR;                                                \
    _RemovedEntry = RtlDeleteElementGenericTable( &(V)->FcbTable, &_Key );  \
    ASSERT( _RemovedEntry );                                                \
}
#else
#define NtfsDeleteFcbTableEntry(V,FR) {                                     \
    FCB_TABLE_ELEMENT _Key;                                                 \
    _Key.FileReference = FR;                                                \
    RtlDeleteElementGenericTable( &(V)->FcbTable, &_Key );                  \
}
#endif

//
//  Routines for allocating and deallocating the compression synchronization structures.
//

PVOID
NtfsAllocateCompressionSync (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NtfsDeallocateCompressionSync (
    IN PVOID CompressionSync
    );

//
//  The following four routines are for incrementing and decrementing the cleanup
//  counts and the close counts.  In all of the structures
//

VOID
NtfsIncrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    );

VOID
NtfsIncrementCloseCounts (
    IN PSCB Scb,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly
    );

VOID
NtfsDecrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    );

BOOLEAN
NtfsDecrementCloseCounts (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN DecrementCountsOnly
    );

PERESOURCE
NtfsAllocateEresource (
    );

VOID
NtfsFreeEresource (
    IN PERESOURCE Eresource
    );

PVOID
NtfsAllocateFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    );

VOID
NtfsFreeFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    );

VOID
NtfsPostToNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
NtfsProcessNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CleanupOnly
    );

//
//  Useful debug routines
//

VOID
NtfsTestStatusProc (
    );

//
//  Usn Support routines in UsnSup.c
//

NTSTATUS
NtfsReadUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN ProbeInput
    );

ULONG
NtfsPostUsnChange (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID ScborFcb,
    IN ULONG Reason
    );

VOID
NtfsWriteUsnJournalChanges (
    PIRP_CONTEXT IrpContext
    );

VOID
NtfsSetupUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA JournalData
    );

VOID
NtfsTrimUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeleteUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsDeleteUsnSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

//
//  NtOfs support routines in vattrsup.c
//

NTFSAPI
NTSTATUS
NtfsHoldIrpForNewLength (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PIRP Irp,
    IN LONGLONG Length,
    IN PDRIVER_CANCEL CancelRoutine,
    IN PVOID CapturedData OPTIONAL,
    OUT PVOID *CopyCapturedData OPTIONAL,
    IN ULONG CapturedDataLength
    );


//
//  Time conversion support routines, implemented as a macro
//
//      VOID
//      NtfsGetCurrentTime (
//          IN PIRP_CONTEXT IrpContext,
//          IN LONGLONG Time
//          );
//

#define NtfsGetCurrentTime(_IC,_T) {            \
    ASSERT_IRP_CONTEXT(_IC);                    \
    KeQuerySystemTime((PLARGE_INTEGER)&(_T));   \
}

//
//  Time routine to check if last access should be updated.
//
//      BOOLEAN
//      NtfsCheckLastAccess (
//          IN PIRP_CONTEXT IrpContext,
//          IN OUT PFCB Fcb
//          );
//

#define NtfsCheckLastAccess(_IC,_FCB)  (                                            \
    ((NtfsLastAccess + (_FCB)->Info.LastAccessTime) < (_FCB)->CurrentLastAccess) || \
    ((_FCB)->CurrentLastAccess < (_FCB)->Info.LastAccessTime)                       \
)


//
//  Macro and #defines to decide whether a given feature is supported on a
//  given volume version.  Currently, all features either work on all Ntfs
//  volumes, or work on all volumes with major version greater than 1.  In
//  some future version, some features may require version 4.x volumes, etc.
//
//  This macro is used to decide whether to fail a user request with
//  STATUS_VOLUME_NOT_UPGRADED, and also helps us set the FILE_SUPPORTS_xxx
//  flags correctly in NtfsQueryFsAttributeInfo.
//

#define NTFS_ENCRYPTION_VERSION         2
#define NTFS_OBJECT_ID_VERSION          2
#define NTFS_QUOTA_VERSION              2
#define NTFS_REPARSE_POINT_VERSION      2
#define NTFS_SPARSE_FILE_VERSION        2

#define NtfsVolumeVersionCheck(VCB,VERSION) ( \
    ((VCB)->MajorVersion >= VERSION)          \
)

//
//  Low level verification routines, implemented in VerfySup.c
//

BOOLEAN
NtfsPerformVerifyOperation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsPerformDismountOnVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DoCompleteDismount,
    OUT PVPB *NewVpbReturn OPTIONAL
    );

BOOLEAN
NtfsPingVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PBOOLEAN OwnsVcb OPTIONAL
    );

VOID
NtfsVolumeCheckpointDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NtfsCheckpointAllVolumes (
    PVOID Parameter
    );

VOID
NtfsUsnTimeOutDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NtfsCheckUsnTimeOut (
    PVOID Parameter
    );

NTSTATUS
NtfsIoCallSelf (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction
    );

BOOLEAN
NtfsLogEvent (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    );

VOID
NtfsMarkVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN UpdateWithinTransaction
    );

VOID
NtfsSetVolumeInfoFlagState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FlagsToSet,
    IN BOOLEAN NewState,
    IN BOOLEAN UpdateWithinTransaction
    );

BOOLEAN
NtfsUpdateVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR DiskMajorVersion,
    IN UCHAR DiskMinorVersion
    );

VOID
NtfsPostVcbIsCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS  Status OPTIONAL,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    );

VOID
NtOfsCloseAttributeSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

NTSTATUS
NtfsDeviceIoControlAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG BufferSize
    );


//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
NtfsOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
NtfsPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL
    );

VOID
NtfsAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    );

NTSTATUS
NtfsPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    );


//
//  Miscellaneous support macros.
//
//      ULONG_PTR
//      WordAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      LongAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      QuadAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      UCHAR
//      CopyUchar1 (
//          IN PUCHAR Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar2 (
//          IN PUSHORT Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar4 (
//          IN PULONG Destination,
//          IN PUCHAR Source
//          );
//
//      PVOID
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define WordAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 1) & (-2)) \
)

#define LongAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 3) & (-4)) \
)

#define QuadAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 7) & (-8)) \
)

#define WordAlign(P) (             \
    ((((P)) + 1) & (-2)) \
)

#define LongAlign(P) (             \
    ((((P)) + 3) & (-4)) \
)

#define QuadAlign(P) (             \
    ((((P)) + 7) & (-8)) \
)

#define IsWordAligned(P)    ((ULONG_PTR)(P) == WordAlign( (ULONG_PTR)(P) ))

#define IsLongAligned(P)    ((ULONG_PTR)(P) == LongAlign( (ULONG_PTR)(P) ))

#define IsQuadAligned(P)    ((ULONG_PTR)(P) == QuadAlign( (ULONG_PTR)(P) ))

//
// A note on structure alignment checking:
//
// In a perfect world, we would just use TYPE_ALIGNMENT straight out of the box
// to check the alignment requirements for a given structure.
//
// On 32-bit platforms including Alpha, alignment faults are handled by the
// OS.  There are many places in the NTFS code where a structure requires
// quadword alignment (on Alpha) but only dword alignment is enforced.  To
// change this on Alpha32 would introduce compatibility problems, so on 32-bit
// platforms we do not want to use an alignment value greater than 4.
//
// In other places, enforcing ULONG alignment is more restrictive than
// necessary.  For example, a structure that contains nothing bigger than a
// USHORT can get by with 16-bit alignment.  However, there is no reason to
// relax these alignment restrictions, so on all platforms we do not want to
// use an alignment value of less than 4.
//
// This means that NTFS_TYPE_ALIGNMENT always resolves to 4 on 32-bit platforms,
// and to at least four on 64-bit platforms.
//

#ifdef _WIN64

#define NTFS_TYPE_ALIGNMENT(T) \
    ((TYPE_ALIGNMENT( T ) < TYPE_ALIGNMENT(ULONG)) ? TYPE_ALIGNMENT( ULONG ) : TYPE_ALIGNMENT( T ))

#else

#define NTFS_TYPE_ALIGNMENT(T) TYPE_ALIGNMENT( ULONG )

#endif

//
//  BlockAlign(): Aligns P on the next V boundary.
//  BlockAlignTruncate(): Aligns P on the prev V boundary.
//

#define BlockAlign(P,V) (((P)) + (V-1) & (-(V)))
#define BlockAlignTruncate(P,V) ((P) & (-(V)))

//
//  BlockOffset(): Calculates offset within V of P
//

#define BlockOffset(P,V) ((P) & (V-1))

//
//  TypeAlign(): Aligns P according to the alignment requirements of type T
//

#define TypeAlign(P,T) BlockAlign( P, NTFS_TYPE_ALIGNMENT(T) )

//
// IsTypeAligned(): Determines whether P is aligned according to the
// requirements of type T
//

#define IsTypeAligned(P,T) \
    ((ULONG_PTR)(P) == TypeAlign( (ULONG_PTR)(P), T ))

//
//  Conversions between bytes and clusters.  Typically we will round up to the
//  next cluster unless the macro specifies trucate.
//

#define ClusterAlign(V,P) (                                       \
    ((((ULONG)(P)) + (V)->ClusterMask) & (V)->InverseClusterMask) \
)

#define ClusterOffset(V,P) (          \
    (((ULONG)(P)) & (V)->ClusterMask) \
)

#define ClustersFromBytes(V,P) (                           \
    (((ULONG)(P)) + (V)->ClusterMask) >> (V)->ClusterShift \
)

#define ClustersFromBytesTruncate(V,P) (    \
    ((ULONG)(P)) >> (V)->ClusterShift       \
)

#define BytesFromClusters(V,P) (      \
    ((ULONG)(P)) << (V)->ClusterShift \
)

#define LlClustersFromBytes(V,L) (                                                  \
    Int64ShraMod32(((L) + (LONGLONG) (V)->ClusterMask), (CCHAR)(V)->ClusterShift)   \
)

#define LlClustersFromBytesTruncate(V,L) (                  \
    Int64ShraMod32((L), (CCHAR)(V)->ClusterShift)           \
)

#define LlBytesFromClusters(V,C) (                  \
    Int64ShllMod32((C), (CCHAR)(V)->ClusterShift)   \
)

//
//  Conversions between bytes and file records
//

#define BytesFromFileRecords(V,B) (                 \
    ((ULONG)(B)) << (V)->MftShift                   \
)

#define FileRecordsFromBytes(V,F) (                 \
    ((ULONG)(F)) >> (V)->MftShift                   \
)

#define LlBytesFromFileRecords(V,F) (               \
    Int64ShllMod32((F), (CCHAR)(V)->MftShift)       \
)

#define LlFileRecordsFromBytes(V,B) (               \
    Int64ShraMod32((B), (CCHAR)(V)->MftShift)       \
)

//
//  Conversions between bytes and index blocks
//

#define BytesFromIndexBlocks(B,S) (     \
    ((ULONG)(B)) << (S)                 \
)

#define LlBytesFromIndexBlocks(B,S) (   \
    Int64ShllMod32((B), (S))            \
)

//
//  Conversions between bytes and log blocks (512 byte blocks)
//

#define BytesFromLogBlocks(B) (                     \
    ((ULONG) (B)) << DEFAULT_INDEX_BLOCK_BYTE_SHIFT \
)

#define LogBlocksFromBytesTruncate(B) (             \
    ((ULONG) (B)) >> DEFAULT_INDEX_BLOCK_BYTE_SHIFT \
)

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

#define PtrOffset(B,O) ((ULONG)((ULONG_PTR)(O) - (ULONG_PTR)(B)))

//
//  The following support macros deal with dir notify support.
//
//      ULONG
//      NtfsBuildDirNotifyFilter (
//          IN PIRP_CONTEXT IrpContext,
//          IN ULONG Flags
//          );
//
//      VOID
//      NtfsReportDirNotify (
//          IN PIRP_CONTEXT IrpContext,
//          IN PVCB Vcb,
//          IN PUNICODE_STRING FullFileName,
//          IN USHORT TargetNameOffset,
//          IN PUNICODE_STRING StreamName OPTIONAL,
//          IN PUNICODE_STRING NormalizedParentName OPTIONAL,
//          IN ULONG Filter,
//          IN ULONG Action,
//          IN PFCB ParentFcb OPTIONAL
//          );
//
//      VOID
//      NtfsUnsafeReportDirNotify (
//          IN PIRP_CONTEXT IrpContext,
//          IN PVCB Vcb,
//          IN PUNICODE_STRING FullFileName,
//          IN USHORT TargetNameOffset,
//          IN PUNICODE_STRING StreamName OPTIONAL,
//          IN PUNICODE_STRING NormalizedParentName OPTIONAL,
//          IN ULONG Filter,
//          IN ULONG Action,
//          IN PFCB ParentFcb OPTIONAL
//          );
//

#define NtfsBuildDirNotifyFilter(IC,F) (                                        \
    FlagOn( (F), FCB_INFO_CHANGED_ALLOC_SIZE ) ?                                \
    (FlagOn( (F), FCB_INFO_VALID_NOTIFY_FLAGS ) | FILE_NOTIFY_CHANGE_SIZE) :    \
    FlagOn( (F), FCB_INFO_VALID_NOTIFY_FLAGS )                                  \
)

#define NtfsReportDirNotify(IC,V,FN,O,SN,NPN,F,A,PF)    {       \
    try {                                                       \
        FsRtlNotifyFilterReportChange( (V)->NotifySync,         \
                                       &(V)->DirNotifyList,     \
                                       (PSTRING) (FN),          \
                                       (USHORT) (O),            \
                                       (PSTRING) (SN),          \
                                       (PSTRING) (NPN),         \
                                       F,                       \
                                       A,                       \
                                       PF,                      \
                                       NULL );                  \
    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?   \
              EXCEPTION_EXECUTE_HANDLER :                       \
              EXCEPTION_CONTINUE_SEARCH) {                      \
        NOTHING;                                                \
    }                                                           \
}

#define NtfsUnsafeReportDirNotify(IC,V,FN,O,SN,NPN,F,A,PF) {    \
    FsRtlNotifyFilterReportChange( (V)->NotifySync,             \
                                   &(V)->DirNotifyList,         \
                                   (PSTRING) (FN),              \
                                   (USHORT) (O),                \
                                   (PSTRING) (SN),              \
                                   (PSTRING) (NPN),             \
                                   F,                           \
                                   A,                           \
                                   PF,                          \
                                   NULL );                      \
}


//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(D,S) {                                \
    *((UCHAR1 *)(D)) = *((UNALIGNED UCHAR1 *)(S)); \
}

#define CopyUchar2(D,S) {                                \
    *((UCHAR2 *)(D)) = *((UNALIGNED UCHAR2 *)(S)); \
}

#define CopyUchar4(D,S) {                                \
    *((UCHAR4 *)(D)) = *((UNALIGNED UCHAR4 *)(S)); \
}

//
//  The following routines are used to set up and restore the top level
//  irp field in the local thread.  They are contained in ntfsdata.c
//


PTOP_LEVEL_CONTEXT
NtfsInitializeTopLevelIrp (
    IN PTOP_LEVEL_CONTEXT TopLevelContext,
    IN BOOLEAN ForceTopLevel,
    IN BOOLEAN SetTopLevel
    );

//
//  BOOLEAN
//  NtfsIsTopLevelRequest (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  BOOLEAN
//  NtfsIsTopLevelNtfs (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  NtfsRestoreTopLevelIrp (
//      );
//
//  PTOP_LEVEL_CONTEXT
//  NtfsGetTopLevelContext (
//      );
//
//  PSCB
//  NtfsGetTopLevelHotFixScb (
//      );
//
//  VCN
//  NtfsGetTopLevelHotFixVcn (
//      );
//
//  BOOLEAN
//  NtfsIsTopLevelHotFixScb (
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsUpdateIrpContextWithTopLevel (
//      IN PIRP_CONTEXT IrpContext,
//      IN PTOP_LEVEL_CONTEXT TopLevelContext
//      );
//

#define NtfsRestoreTopLevelIrp() {                      \
    PTOP_LEVEL_CONTEXT TLC;                             \
    TLC = (PTOP_LEVEL_CONTEXT) IoGetTopLevelIrp();      \
    ASSERT( (TLC)->ThreadIrpContext != NULL );          \
    (TLC)->Ntfs = 0;                                    \
    (TLC)->ThreadIrpContext = NULL;                     \
    IoSetTopLevelIrp( (PIRP) (TLC)->SavedTopLevelIrp ); \
}

#define NtfsGetTopLevelContext() (                      \
    (PTOP_LEVEL_CONTEXT) IoGetTopLevelIrp()             \
)

#define NtfsIsTopLevelRequest(IC) (                     \
    ((IC) == (IC)->TopLevelIrpContext) &&               \
    NtfsGetTopLevelContext()->TopLevelRequest           \
)

#define NtfsIsTopLevelNtfs(IC) (                        \
    (IC) == (IC)->TopLevelIrpContext                    \
)

#define NtfsGetTopLevelHotFixScb() (                    \
    (NtfsGetTopLevelContext())->ScbBeingHotFixed        \
)

#define NtfsGetTopLevelHotFixVcn() (                    \
    (NtfsGetTopLevelContext())->VboBeingHotFixed        \
)

#define NtfsIsTopLevelHotFixScb(S) (                    \
    ((BOOLEAN) (NtfsGetTopLevelHotFixScb() == (S)))     \
)

#define NtfsUpdateIrpContextWithTopLevel(IC,TLC) {                  \
    if ((TLC)->ThreadIrpContext == NULL) {                          \
        (TLC)->Ntfs = 0x5346544e;                                   \
        (TLC)->ThreadIrpContext = (IC);                             \
        SetFlag( (IC)->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );   \
        IoSetTopLevelIrp( (PIRP) (TLC) );                           \
    }                                                               \
    (IC)->TopLevelIrpContext = (TLC)->ThreadIrpContext;             \
}

BOOLEAN
NtfsSetCancelRoutine (
    IN PIRP Irp,
    IN PDRIVER_CANCEL CancelRoutine,
    IN ULONG_PTR IrpInformation,
    IN ULONG Async
    );

BOOLEAN
NtfsClearCancelRoutine (
    IN PIRP Irp
    );

#ifdef NTFS_CHECK_BITMAP
VOID
NtfsBadBitmapCopy (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BadBit,
    IN ULONG Length
    );

BOOLEAN
NtfsCheckBitmap (
    IN PVCB Vcb,
    IN ULONG Lcn,
    IN ULONG Count,
    IN BOOLEAN Set
    );
#endif


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//
//  They each accept as input a pointer to a device object (actually most
//  expect a volume device object, with the exception of the file system
//  control function which can also take a file system device object), and
//  a pointer to the IRP.  They either perform the function at the FSD level
//  or post the request to the FSP work queue for FSP level processing.
//


NTSTATUS
NtfsFsdDispatch (                       // implemented in ntfsdata.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdDispatchWait (                   // implemented in ntfsdata.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdCleanup (                        //  implemented in Cleanup.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdClose (                          //  implemented in Close.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdCreate (                         //  implemented in Create.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeviceIoControl (                   //  implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG_PTR IosbInformation OPTIONAL
    );

NTSTATUS
NtfsFsdDirectoryControl (               //  implemented in DirCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdPnp (                            //  implemented in Pnp.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdFlushBuffers (                   //  implemented in Flush.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFlushUserStream (                   //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length
    );

NTSTATUS
NtfsFlushVolume (                       //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN FlushCache,
    IN BOOLEAN PurgeFromCache,
    IN BOOLEAN ReleaseAllFiles,
    IN BOOLEAN MarkFilesForDismount
    );

NTSTATUS
NtfsFlushLsnStreams (                   //  implemented in Flush.c
    IN PVCB Vcb
    );

VOID
NtfsFlushAndPurgeFcb (                  //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsFlushAndPurgeScb (                  //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PSCB ParentScb OPTIONAL
    );

NTSTATUS
NtfsFsdFileSystemControl (              //  implemented in FsCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdLockControl (                    //  implemented in LockCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdRead (                           //  implemented in Read.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdSetInformation (                 //  implemented in FileInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdShutdown (                       //  implemented in Shutdown.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdQueryVolumeInformation (         //  implemented in VolInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdSetVolumeInformation (           //  implemented in VolInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdWrite (                          //  implemented in Write.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//
//
//      BOOLEAN
//      CanFsdWait (
//          IN PIRP Irp
//          );
//

#define CanFsdWait(I) IoIsOperationSynchronous(I)


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
NtfsFspDispatch (                       //  implemented in FspDisp.c
    IN PVOID Context
    );

//
//  The following routines are the FSP work routines that are called
//  by the preceding NtfsFspDispath routine.  Each takes as input a pointer
//  to the IRP, perform the function, and return a pointer to the volume
//  device object that they just finished servicing (if any).  The return
//  pointer is then used by the main Fsp dispatch routine to check for
//  additional IRPs in the volume's overflow queue.
//
//  Each of the following routines is also responsible for completing the IRP.
//  We moved this responsibility from the main loop to the individual routines
//  to allow them the ability to complete the IRP and continue post processing
//  actions.
//

NTSTATUS
NtfsCommonCleanup (                     //  implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

LONG
NtfsCleanupExceptionFilter (            //  implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    OUT PNTSTATUS Status
    );

VOID
NtfsFspClose (                          //  implemented in Close.c
    IN PVCB ThisVcb OPTIONAL
    );

BOOLEAN
NtfsAddScbToFspClose (                  //  implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN DelayClose
    );

BOOLEAN
NtfsNetworkOpenCreate (                 //  implemented in Create.c
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

NTSTATUS
NtfsCommonCreate (                      //  implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN IN POPLOCK_CLEANUP OplockCleanup,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInfo OPTIONAL
    );

VOID
NtfsInitializeFcbAndStdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN BOOLEAN Directory,
    IN BOOLEAN ViewIndex,
    IN BOOLEAN Compressed,
    IN ULONG FileAttributes,
    IN PNTFS_TUNNELED_DATA SetTunnelData OPTIONAL
    );

NTSTATUS
NtfsCommonVolumeOpen (                  //  implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonDeviceControl (               //  implemented in DevCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonDirectoryControl (            //  implemented in DirCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsReportViewIndexNotify (             //  implemented in DirCtrl.c
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID ChangeInfoBuffer,
    IN USHORT ChangeInfoBufferLength
    );

NTSTATUS
NtfsCommonQueryEa (                     //  implemented in Ea.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetEa (                       //  implemented in Ea.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonQueryInformation (            //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetInformation (              //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                //  implemented in FsCtrl.c
NtfsGetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PNTFS_TUNNELED_DATA TunneledData
    );

NTSTATUS                                //  implemented in FsCtrl.c
NtfsSetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PNTFS_TUNNELED_DATA TunneledData
    );

NTSTATUS
NtfsCommonQueryQuota (                  //  implemented in Quota.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetQuota (                    //  implemented in Quota.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonFlushBuffers (                //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonFileSystemControl (           //  implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonLockControl (                 //  implemented in LockCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonRead (                        //  implemented in Read.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN AcquireScb
    );

NTSTATUS
NtfsCommonQuerySecurityInfo (           //  implemented in SeInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetSecurityInfo (             //  implemented in SeInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsQueryViewIndex (                    //  implemented in ViewSup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsCommonQueryVolumeInfo (             //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetVolumeInfo (               //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonWrite (                       //  implemented in Write.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.  Either the Irp or IrpContext may be NULL depending on whether
//  this is being done for a user or for a FS service.
//
//  This would typically be done in order to pass a "naked" IrpContext off to
//  the Fsp for post processing, such as read ahead.
//

VOID
NtfsCompleteRequest (
    IN OUT PIRP_CONTEXT IrpContext OPTIONAL,
    IN OUT PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    );

//
//  Here are the callbacks used by the I/O system for checking for fast I/O or
//  doing a fast query info call, or doing fast lock calls.
//

BOOLEAN
NtfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastQueryNetworkOpenInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

VOID
NtfsFastIoQueryCompressionInfo (
    IN PFILE_OBJECT FileObject,
    OUT PFILE_COMPRESSION_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
NtfsFastIoQueryCompressedSize (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    OUT PULONG CompressedSize
    );

//
//  The following macro is used by the dispatch routines to determine if
//  an operation is to be done with or without WriteThrough.
//
//      BOOLEAN
//      IsFileWriteThrough (
//          IN PFILE_OBJECT FileObject,
//          IN PVCB Vcb
//          );
//

#define IsFileWriteThrough(FO,V) (          \
    FlagOn((FO)->Flags, FO_WRITE_THROUGH)   \
)

//
//  The following macro is used to set the is fast i/o possible field in
//  the common part of the non paged fcb
//
//      NotPossible     -   Volume not mounted
//                      -   Oplock state prevents it
//
//      Possible        -   Not compressed or sparse
//                      -   No file locks
//                      -   Not a read only volume
//                      -   No Usn journal for this volume
//
//      Questionable    -   All other cases
//
//
//      BOOLEAN
//      NtfsIsFastIoPossible (
//          IN PSCB Scb
//          );
//

#define NtfsIsFastIoPossible(S) (BOOLEAN) (                                     \
    (!FlagOn((S)->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED) ||                   \
     !FsRtlOplockIsFastIoPossible( &(S)->ScbType.Data.Oplock )) ?               \
                                                                                \
        FastIoIsNotPossible :                                                   \
                                                                                \
        ((((S)->CompressionUnit == 0) &&                                        \
          (((S)->ScbType.Data.FileLock == NULL) ||                              \
           !FsRtlAreThereCurrentFileLocks( (S)->ScbType.Data.FileLock ))  &&    \
          !NtfsIsVolumeReadOnly( (S)->Vcb ) &&                                  \
          ((S)->Vcb->UsnJournal == NULL))   ?                                   \
                                                                                \
            FastIoIsPossible :                                                  \
                                                                                \
            FastIoIsQuestionable)                                               \
)

//
//  The following macro is used to detemine if the file object is opened
//  for read only access (i.e., it is not also opened for write access or
//  delete access).
//
//      BOOLEAN
//      IsFileObjectReadOnly (
//          IN PFILE_OBJECT FileObject
//          );
//

#define IsFileObjectReadOnly(FO) (!((FO)->WriteAccess | (FO)->DeleteAccess))


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }


//
//  Simple initialization for a name pair
//
//  VOID
//  NtfsInitializeNamePair(PNAME_PAIR PNp);
//

#define NtfsInitializeNamePair(PNp) {                           \
    (PNp)->Short.Buffer = (PNp)->ShortBuffer;                   \
    (PNp)->Long.Buffer = (PNp)->LongBuffer;                     \
    (PNp)->Short.Length = 0;                                    \
    (PNp)->Long.Length = 0;                                     \
    (PNp)->Short.MaximumLength = sizeof((PNp)->ShortBuffer);    \
    (PNp)->Long.MaximumLength = sizeof((PNp)->LongBuffer);      \
}

//
//  Copy a length of WCHARs into a side of a name pair. Only copy the first name
//  that fits to avoid useless work if more than three links are encountered (per
//  BrianAn), very rare case. We use the filename flags to figure out what kind of
//  name we have.
//
//  VOID
//  NtfsCopyNameToNamePair(
//              PNAME_PAIR PNp,
//              WCHAR Source,
//              ULONG SourceLen,
//              UCHAR NameFlags);
//

#define NtfsCopyNameToNamePair(PNp, Source, SourceLen, NameFlags) {                          \
    if (!FlagOn((NameFlags), FILE_NAME_DOS)) {                                               \
        if ((PNp)->Long.Length == 0) {                                                       \
            if ((PNp)->Long.MaximumLength < ((SourceLen)*sizeof(WCHAR))) {                   \
                if ((PNp)->Long.Buffer != (PNp)->LongBuffer) {                               \
                    NtfsFreePool((PNp)->Long.Buffer);                                        \
                    (PNp)->Long.Buffer = (PNp)->LongBuffer;                                  \
                    (PNp)->Long.MaximumLength = sizeof((PNp)->LongBuffer);                   \
                }                                                                            \
                (PNp)->Long.Buffer = NtfsAllocatePool(PagedPool,(SourceLen)*sizeof(WCHAR));  \
                (PNp)->Long.MaximumLength = (SourceLen)*sizeof(WCHAR);                       \
            }                                                                                \
            RtlCopyMemory((PNp)->Long.Buffer, (Source), (SourceLen)*sizeof(WCHAR));          \
            (PNp)->Long.Length = (SourceLen)*sizeof(WCHAR);                                  \
        }                                                                                    \
    } else {                                                                                 \
        ASSERT((PNp)->Short.Buffer == (PNp)->ShortBuffer);                                   \
        if ((PNp)->Short.Length == 0) {                                                      \
            RtlCopyMemory((PNp)->Short.Buffer, (Source), (SourceLen)*sizeof(WCHAR));         \
            (PNp)->Short.Length = (SourceLen)*sizeof(WCHAR);                                 \
        }                                                                                    \
    }                                                                                        \
}

//
//  Set up a previously used name pair for reuse.
//
//  VOID
//  NtfsResetNamePair(PNAME_PAIR PNp);
//

#define NtfsResetNamePair(PNp) {                    \
    if ((PNp)->Long.Buffer != (PNp)->LongBuffer) {  \
        NtfsFreePool((PNp)->Long.Buffer);             \
    }                                               \
    NtfsInitializeNamePair(PNp);                    \
}

//
// Cairo support stuff.
//

typedef NTSTATUS
(*FILE_RECORD_WALK) (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PVOID Context
    );

NTSTATUS
NtfsIterateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PFILE_REFERENCE FileReference,
    IN FILE_RECORD_WALK FileRecordFunction,
    IN PVOID Context
    );

VOID
NtfsPostSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN POST_SPECIAL_CALLOUT PostSpecialCallout,
    IN PVOID Context
    );

VOID
NtfsSpecialDispatch (
    PVOID Context
    );

VOID
NtfsLoadAddOns (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PVOID Context,
    IN ULONG Count
    );

NTSTATUS
NtfsTryOpenFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PFCB *CurrentFcb,
    IN FILE_REFERENCE FileReference
    );

//
//  The following define controls whether quota operations are done
//  on this FCB.
//

#define NtfsPerformQuotaOperation(FCB) ((FCB)->QuotaControl != NULL)

VOID
NtfsAcquireQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    );

VOID
NtfsCalculateQuotaAdjustment (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PLONGLONG Delta
    );

VOID
NtfsDereferenceQuotaControlBlock (
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK *QuotaControl
    );

VOID
NtfsFixupQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

NTSTATUS
NtfsFsQuotaQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingId,
    IN BOOLEAN ReturnSingleEntry,
    IN PFILE_QUOTA_INFORMATION *FileQuotaInfo,
    IN OUT PULONG Length,
    IN OUT PCCB Ccb OPTIONAL
    );

NTSTATUS
NtfsFsQuotaSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN ULONG Length
    );

VOID
NtfsGetRemainingQuota (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG OwnerId,
    OUT PULONGLONG RemainingQuota,
    OUT PULONGLONG TotalQuota,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
    );

ULONG
NtfsGetCallersUserId (
    IN PIRP_CONTEXT IrpContext
    );

ULONG
NtfsGetOwnerId (
    IN PIRP_CONTEXT IrpContext,
    IN PSID Sid,
    IN BOOLEAN CreateNew,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo OPTIONAL
    );

PQUOTA_CONTROL_BLOCK
NtfsInitializeQuotaControlBlock (
    IN PVCB Vcb,
    IN ULONG OwnerId
    );

VOID
NtfsInitializeQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    );

VOID
NtfsMarkQuotaCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

VOID
NtfsMoveQuotaOwner (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR Security
    );


VOID
NtfsPostRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryQuotaUserSidList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_GET_QUOTA_INFORMATION SidList,
    OUT PFILE_QUOTA_INFORMATION QuotaBuffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN ReturnSingleEntry
    );

VOID
NtfsReleaseQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    );

VOID
NtfsUpdateFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLONGLONG Delta,
    IN LOGICAL LogIt,
    IN LOGICAL CheckQuota
    );

VOID
NtfsUpdateQuotaDefaults (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION FileQuotaInfo
    );

INLINE
VOID
NtfsConditionallyFixupQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )
{
    if (FlagOn( Fcb->Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED )) {
        NtfsFixupQuota ( IrpContext, Fcb );
    }
}

INLINE
VOID
NtfsConditionallyUpdateQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLONGLONG Delta,
    IN LOGICAL LogIt,
    IN LOGICAL CheckQuota
    )
{
    if (NtfsPerformQuotaOperation( Fcb ) &&
        !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_QUOTA_DISABLE )) {
        NtfsUpdateFileQuota( IrpContext, Fcb, Delta, LogIt, CheckQuota );
    }
}

extern BOOLEAN NtfsAllowFixups;

INLINE
VOID
NtfsReleaseQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Acquired
    )
{
    if (Acquired) {
        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }
}

//
// Define the quota charge for resident streams.
//

#define NtfsResidentStreamQuota( Vcb ) ((LONG) Vcb->BytesPerFileRecordSegment)


//
//  The following macro tests to see if it is ok for an internal routine to
//  write to the volume.
//

#define NtfsIsVcbAvailable( Vcb ) (FlagOn( Vcb->VcbState,                   \
                             VCB_STATE_VOLUME_MOUNTED |                     \
                             VCB_STATE_FLAG_SHUTDOWN |                      \
                             VCB_STATE_PERFORMED_DISMOUNT |                 \
                             VCB_STATE_LOCKED) == VCB_STATE_VOLUME_MOUNTED)

//
//  Test to see if the volume is mounted read only.
//

#define NtfsIsVolumeReadOnly( Vcb ) (FlagOn( (Vcb)->VcbState, VCB_STATE_MOUNT_READ_ONLY ))

//
//  Processing required so reg. exception filter works if another one is being used
//  to handle an exception that could be raise via NtfsRaiseStatus. If its always
//  rethrown this is not necc.
//

#define NtfsMinimumExceptionProcessing(I) {                                \
    if((I) != NULL) {                                                      \
        ClearFlag( (I)->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS );           \
    }                                                                      \
}

#ifdef NTFSDBG

BOOLEAN
NtfsChangeResourceOrderState(
    IN PIRP_CONTEXT IrpContext,
    IN NTFS_RESOURCE_NAME NewResource,
    IN BOOLEAN Release,
    IN ULONG UnsafeTransition
    );

NTFS_RESOURCE_NAME
NtfsIdentifyFcb (
    IN PVCB Vcb,
    IN PFCB Fcb
    );

#endif

//
//  Size of a normalized name which is long enough to be freed at cleanup
//

#define LONGNAME_THRESHOLD 0x200

VOID
NtfsTrimNormalizedNames (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb
    );

#define NtfsSnapshotFileSizesTest( I, S ) (FlagOn( (S)->ScbState, SCB_STATE_MODIFIED_NO_WRITE | SCB_STATE_CONVERT_UNDERWAY ) || \
                                           ((S) == (I)->CleanupStructure) ||                                                    \
                                           ((S)->Fcb == (I)->CleanupStructure))

//
//  Reservation needed =  AllocationSize
//                        largest transfer size - this is because in a single transfer we cannot reuse clusters we freed from the totalallocated piece of the calculation
//                        metadata charge for new clusters
//                        minus the already allocated space
//


//
//  One problem with the reservation strategy, is that we cannot precisely reserve
//  for metadata.  If we reserve too much, we will return premature disk full, if
//  we reserve too little, the Lazy Writer can get an error.  As we add compression
//  units to a file, large files will eventually require additional File Records.
//  If each compression unit required 0x20 bytes of run information (fairly pessimistic)
//  then a 0x400 size file record would fill up with less than 0x20 runs requiring
//  (worst case) two additional clusters for another file record.  So each 0x20
//  compression units require 0x200 reserved clusters, and a separate 2 cluster
//  file record.  0x200/2 = 0x100.  So the calculations below tack a 1/0x100 (about
//  .4% "surcharge" on the amount reserved both in the Scb and the Vcb, to solve
//  the Lazy Writer popups like the ones Alan Morris gets in the print lab.
//

#define NtfsCalculateNeededReservedSpace( S )                               \
    ((S)->Header.AllocationSize.QuadPart +                                  \
     MM_MAXIMUM_DISK_IO_SIZE +                                              \
     (S)->CompressionUnit -                                                 \
     (FlagOn( (S)->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ?         \
       (S)->Header.AllocationSize.QuadPart :                                \
       (S)->TotalAllocated) +                                               \
     (Int64ShraMod32( (S)->ScbType.Data.TotalReserved, 8 )))


PDEALLOCATED_CLUSTERS
NtfsGetDeallocatedClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Dynamically allocate stack space for local variables.
//

#define NtfsAllocateFromStack(S) _alloca(S)

//
//  Common Create Flag definitions
//

#define CREATE_FLAG_DOS_ONLY_COMPONENT          (0x00000001)
#define CREATE_FLAG_CREATE_FILE_CASE            (0x00000002)
#define CREATE_FLAG_DELETE_ON_CLOSE             (0x00000004)
#define CREATE_FLAG_TRAILING_BACKSLASH          (0x00000008)
#define CREATE_FLAG_TRAVERSE_CHECK              (0x00000010)
#define CREATE_FLAG_IGNORE_CASE                 (0x00000020)
#define CREATE_FLAG_OPEN_BY_ID                  (0x00000040)
#define CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX    (0x00000080)
#define CREATE_FLAG_BACKOUT_FAILED_OPENS        (0x00000100)
#define CREATE_FLAG_INSPECT_NAME_FOR_REPARSE    (0x00000200)
#define CREATE_FLAG_SHARED_PARENT_FCB           (0x00000400)
#define CREATE_FLAG_ACQUIRED_VCB                (0x00000800)
#define CREATE_FLAG_CHECK_FOR_VALID_NAME        (0x00001000)
#define CREATE_FLAG_FIRST_PASS                  (0x00002000)
#define CREATE_FLAG_FOUND_ENTRY                 (0x00004000)

#endif // _NTFSPROC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfsstru.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsStru.h

Abstract:

    This module defines the data structures that make up the major
    internal part of the Ntfs file system.

    The global data structures start with the NtfsData record.  It
    contains a pointer to a File System Device object, and a queue of
    Vcb's.  There is a Vcb for every currently mounted volume.  The
    Vcb's are allocated as the extension to a volume device object.

        +--------+
        |NtfsData|     +--------+
        |        | --> |FilSysDo|
        |        |     |        |
        |        | <+  +--------+
        +--------+  |
                    |
                    |  +--------+     +--------+
                    |  |VolDo   |     |VolDo   |
                    |  |        |     |        |
                    |  +--------+     +--------+
                    +> |Vcb     | <-> |Vcb     | <-> ...
                       |        |     |        |
                       +--------+     +--------+

    The File System Device Object contains the global work queue for
    NTFS while each volume device object contains an overflow work queue.

    Each Vcb contains a table of all Fcbs for the volume indexed by their
    file reference (Called the FcbTable).  And each Vcb contains a pointer
    a root Lcb for the volume.  An Lcb is used to connect an indexed Scb
    (i.e., a directory) to an Fcb and give it a name.

    The following diagram shows the root structure.

        +--------+
        |Vcb     |
        |        |  +---+   +--------+
        |        | -|Lcb|-> |RootFcb |
        +--------+  |'\'|   |        |
                    +---+   |        |
                            +--------+

    Each Scb will only have one parent Fcb but multiple Fcb children (each
    connected via an Lcb).  An Fcb can have multiple Scb parents (via
    Lcbs) and multiple Scb Children.

    Now associated with each Fcb is potentially many Scbs.  An Scb
    is allocated for each opened stream file object (i.e., an attribute
    that the file system is manipulating as a stream file).  Each Scb
    contains a common fsrtl header and information necessary for doing
    I/O to the stream.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+

    In the following diagram we have two index scb (Scb1 and Scb2).  The
    are two file opened under Scb1 both for the same File.  The file was
    opened once with the name LcbA and another time with the name LcbB.
    Scb2 also has two opened file one is Fcb1 and named LcbC and the other
    is Fcb2 and named LcbD.  Fcb1 has two opened Scbs under it (Scb3 and
    Scb4), and Fcb2 has one opened Scb underneath it (Scb5).


           +--------+                +--------+
           |Scb     |                |Scb     |
           |    1   |                |    2   |
           |        |                |        |
           +--------+                +--------+

             |    |                    |    |

            Lcb  Lcb                  Lcb  Lcb
             A    B                    C    D

             |    |     +--------+     |    |     +--------+
             |    +---> |Fcb     | <---+    +---> |Fcb     |
             |          |    1   |                |    2   |
             +--------> |        |                |        |
                        +--------+                +--------+
                          ^    ^                    ^    ^
             +------------+    +------------+  +----+    +----+
             |                              |  |              |
             |  +--------+      +--------+  |  |  +--------+  |
             +> |Scb     | <--> |Scb     | <+  +> |Scb     | <+
                |    3   |      |    4   |        |    5   |
                |        |      |        |        |        |
                +--------+      +--------+        +--------+

    In addition off of each Lcb is a list of Ccb and Prefix entries.  The
    Ccb list is for each ccb that has opened that File (fcb) via the name.
    The Prefix list contains the prefix table entries that we are caching.


    The NtfsData, all Vcbs, and the paging file Fcb, and all Scbs are
    allocated out of nonpaged pool.  The Fcbs are allocated out of paged
    pool.

    The resources protecting the NTFS memory structures are setup as
    follows:

    1. There is a global resource in the NtfsData record.  This resource
       protects the NtfsData record which includes any changes to its
       Vcb queue.

    2. There is a resource per Vcb.  This resource pretects the Vcb record
       which includes adding and removing Fcbs, and Scbs

    3. There is a single resource protecting an Fcb and its assigned
       Scbs.  This resource protects any changes to the Fcb, and Scb
       records.  The way this one works is that each Fcb, and Scb point
       to the resource.  The Scb also contain back pointers to their
       parent Fcb but we cannot use this pointer to get the resource
       because the Fcb might be in nonpaged pool.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+
               |
               |           |            |
               |           v            |
               |                        |
               |       +--------+       |
               +-----> |Resource| <-----+
                       |        |
                       +--------+



    There are several types of opens possible for each file object handled by
    NTFS.  They are UserFileOpen, UserDirectoryOpen, UserVolumeOpen, StreamFileOpen,
    UserViewIndexOpen, and UserProperytSetOpen.  The first three types correspond
    to user opens on files, directories, and dasd respectively.  UserViewIndexOpen
    indicates that a user mode application has opened a view index stream such
    as the quota or object id index.  The last type of open is for any file object
    created by NTFS for its stream I/O (e.g., the volume bitmap).  The file system
    uses the FsContext and FsContext2 fields of the file object to store the
    fcb/scb/ccb associated with the file object.

        Type of open                FsContext                   FsContext2
        ------------                ---------                   ----------

        UserFileOpen                Pointer to Scb              Pointer to Ccb

        UserDirectoryOpen           Pointer to Scb              Pointer to Ccb

        UserVolumeOpen              Pointer to Scb              Pointer to Ccb

        StreamFileOpen              Pointer to Scb              null

    The only part of the NTFS code that actually needs to know this
    information is in FilObSup.c.  But we talk about it here to help
    developers debug the system.


    To mount a new NTFS volume requires a bit of juggling.  The idea is
    to have as little setup in memory as necessary to recoginize the
    volume, call a restart routine that will recover the volume, and then
    precede with the mounting.  To aid in this the regular directory
    structures of the Fcb is bypassed.  In its place we have a linked list
    of Fcbs off of the Vcb.  This is done because during recovery we do
    not know where an Fcb belongs in the directory hierarchy.  So at
    restart time all new fcbs get put in this prerestart Fcb list.  Then
    after restart whenever we create a new Fcb we search this list for a
    match (on file reference).  If we find one we remove the fcb from this
    list and move it to the proper place in the directory hierarchy tree
    (fcb tree).

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:

--*/

#ifndef _NTFSSTRU_
#define _NTFSSTRU_

//
//  Forward typedefs
//

typedef struct _SCB *PSCB;

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module

typedef enum _NTFS_OWNERSHIP_STATE NTFS_OWNERSHIP_STATE;
typedef enum _NTFS_RESOURCE_NAME NTFS_RESOURCE_NAME;

//
//  Define how many freed structures we are willing to keep around
//

#define FREE_FCB_TABLE_SIZE              (8)

#define MAX_DELAYED_CLOSE_COUNT         (0x10)
#define ASYNC_CLOSE_POST_THRESHOLD      (500)
#define INITIAL_DIRTY_TABLE_HINT        (0x20)

//
//  Checkpoint activity status.  There are used to control number of outstanding
//  checkpoints.  We only want one to be posted at a time so they don't swallow
//  up the worker threads in case the current checkpoint is not completed before
//  the checkpoint timer fires.
//

#define CHECKPOINT_POSTED               (0x00000001)
#define CHECKPOINT_PENDING              (0x00000002)

//
//  Timer status types.  These are used in NtfsSetDirtyBcb synchronization with
//  checkpoint-all-volumes activity.
//

typedef enum TIMER_STATUS {
    TIMER_SET = 0,
    TIMER_NOT_SET = 1,
} TIMER_STATUS;


//
//  The NTFS_DATA record is the top record in the NTFS file system
//  in-memory data structure.  This structure must be allocated from
//  non-paged pool.
//

typedef struct _NTFS_DATA {

    //
    //  The type and size of this record (must be NTFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A queue of all the devices that are mounted by the file system.
    //  Corresponds to the field Vcb->VcbLinks;
    //

    LIST_ENTRY VcbQueue;

    //
    //  A resource variable to control access to the global NTFS data
    //  record
    //

    ERESOURCE Resource;

    //
    //  The following list entry is used for performing closes that can't
    //  be done in the context of the original caller.
    //

    LIST_ENTRY AsyncCloseList;

    BOOLEAN AsyncCloseActive;
    BOOLEAN ReduceDelayedClose;

    ULONG AsyncCloseCount;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  The following fields describe the deferred close file objects.
    //

    ULONG DelayedCloseCount;

    LIST_ENTRY DelayedCloseList;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    WORK_QUEUE_ITEM NtfsCloseItem;

    UCHAR FreeFcbTableSize;
    UCHAR UnusedUchar[3];

    PVOID *FreeFcbTableArray[ FREE_FCB_TABLE_SIZE ];
    //
    //  Free arrays are dynamically sized
    //

    ULONG FreeEresourceSize;
    ULONG FreeEresourceTotal;
    ULONG FreeEresourceMiss;
    PERESOURCE *FreeEresourceArray;

    //
    //  Cache manager call back structures, which must be passed on each
    //  call to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  The following fields are used for the CheckpointVolumes()
    //  callback.
    //

    KDPC VolumeCheckpointDpc;
    KTIMER VolumeCheckpointTimer;
    ULONG VolumeCheckpointStatus;

    WORK_QUEUE_ITEM VolumeCheckpointItem;
    TIMER_STATUS TimerStatus;

    KDPC UsnTimeOutDpc;
    KTIMER UsnTimeOutTimer;
    WORK_QUEUE_ITEM UsnTimeOutItem;

    //
    //  Flags.  These are the flags for the volume.
    //

    USHORT Flags;

    //
    //  This is a list of all of the threads currently doing read ahead.
    //  We will not hot fix for these threads.
    //

    LIST_ENTRY ReadAheadThreads;

    //
    //  The following table of unicode values is the case mapping, with
    //  the size in number of Unicode characters.  We keep a global copy
    //  and let each Vcb use this copy if the upcase table for the volume
    //  matches.
    //

    PWCH UpcaseTable;
    ULONG UpcaseTableSize;

    //
    //  Pointer to a default security descriptor.
    //

    PSECURITY_DESCRIPTOR DefaultDescriptor;
    ULONG DefaultDescriptorLength;

    //
    //  Mutex to serialize internal NtfsData structures.
    //

    FAST_MUTEX NtfsDataLock;

    //
    //  Service and callback table for encryption.
    //

    ENCRYPTION_CALL_BACK EncryptionCallBackTable;

    //
    //  Useful information when debugging dismount memory leakage, etc.
    //

#ifdef DISMOUNT_DBG
    ULONG DismountCount;
#endif

    ULONG VolumeNameLookupsInProgress;

} NTFS_DATA;
typedef NTFS_DATA *PNTFS_DATA;

#define NTFS_FLAGS_SMALL_SYSTEM                 (0x0001)
#define NTFS_FLAGS_MEDIUM_SYSTEM                (0x0002)
#define NTFS_FLAGS_LARGE_SYSTEM                 (0x0004)
#define NTFS_FLAGS_CREATE_8DOT3_NAMES           (0X0010)
#define NTFS_FLAGS_ALLOW_EXTENDED_CHAR          (0x0020)
#define NTFS_FLAGS_DISABLE_LAST_ACCESS          (0x0040)
#define NTFS_FLAGS_ENCRYPTION_DRIVER            (0x0080)
#define NTFS_FLAGS_DISABLE_UPGRADE              (0x0100)
#define NTFS_FLAGS_PERSONAL                     (0x0200)


//
//  The record allocation context structure is used by the routines that
//  allocate and deallocate records based on a bitmap (for example the mft
//  bitmap or the index bitmap).  The context structure needs to be
//  defined here because the mft bitmap context is declared as part of the
//  vcb.
//

typedef struct _RECORD_ALLOCATION_CONTEXT {

    //
    //  The following field is a pointer to the scb for the data part of
    //  the file that this bitmap controls.  For example, it is a pointer
    //  to the data attribute for the MFT.
    //
    //  NOTE !!!!  The Data Scb must remain the first entry in this
    //  structure.  If we need to uninitialize and reinitialize this
    //  structure in the running system we don't want to touch this field.
    //
    //  NOTE !!!!  The code that clears the record allocation context
    //  expects the BitmapScb field to follow the Data Scb field.
    //

    PSCB DataScb;

    //
    //  The following field is used to indicate if the bitmap attribute is
    //  in a resident form or a nonresident form.  If the bitmap is in a
    //  resident form then the pointer is null, and whenever a bitmap
    //  routine is called it must also be passed an attribute enumeration
    //  context to be able to read the bitmap.  If the field is not null
    //  then it points to the scb for the non resident bitmap attribute
    //

    PSCB BitmapScb;

    //
    //  The following two fields describe the current size of the bitmap
    //  (in bits) and the number of free bits currently in the bitmap.
    //  A value of MAXULONG in the CurrentBitmapSize indicates that we
    //  need to reinitialize the record context structure.
    //

    ULONG CurrentBitmapSize;
    ULONG NumberOfFreeBits;

    //
    //  The following field contains the index of last bit that we know
    //  to be set.  This is used for truncation purposes.
    //

    LONG IndexOfLastSetBit;

    //
    //  The following three fields are used to indicate the allocation
    //  size for the bitmap (i.e., each bit in the bitmap represents how
    //  many bytes in the data attribute).  Also it indicates the
    //  granularity with which we will either extend or shrink the bitmap.
    //

    ULONG BytesPerRecord;

    ULONG ExtendGranularity;
    ULONG TruncateGranularity;

    //
    //  Scanning a large bitmap can be inefficient.  Use the following fields
    //  to quickly locate a likely starting position.
    //

    ULONG StartingHint;
    ULONG LowestDeallocatedIndex;

} RECORD_ALLOCATION_CONTEXT;
typedef RECORD_ALLOCATION_CONTEXT *PRECORD_ALLOCATION_CONTEXT;


//
//  The Vcb (Volume control Block) record corresponds to every volume
//  mounted by the file system.  They are ordered in a queue off of
//  NtfsData.VcbQueue.  This structure must be allocated from non-paged
//  pool
//

#define DEFAULT_ATTRIBUTE_TABLE_SIZE     (32)
#define DEFAULT_TRANSACTION_TABLE_SIZE   (32)
#define DEFAULT_DIRTY_PAGES_TABLE_SIZE   (64)

//
//  The Restart Pointers structure is the actual structure supported by
//  routines and macros to get at a Restart Table.  This structure is
//  required since the restart table itself may move, so one must first
//  acquire the resource to synchronize, then follow the pointer to the
//  table.
//

typedef struct _RESTART_POINTERS {

    //
    //  Resource to synchronize with table moves.  This resource must
    //  be held shared while dealing with pointers to table entries,
    //  and exclusive to move the table.
    //

    ERESOURCE Resource;

    //
    //  Pointer to the actual Restart Table.
    //

    struct _RESTART_TABLE *Table;

    //
    //  Spin Lock synchronizing allocates and deletes of entries in the
    //  table.  The resource must be held at least shared.
    //

    KSPIN_LOCK SpinLock;

    //
    //  Remember if the resource was initialized.
    //

    BOOLEAN ResourceInitialized;

    //
    //  For quad & cache line alignment
    //

    UCHAR Unused[7];

} RESTART_POINTERS, *PRESTART_POINTERS;

#define NtfsInitializeRestartPointers(P) {          \
    RtlZeroMemory( (P), sizeof(RESTART_POINTERS) ); \
    KeInitializeSpinLock( &(P)->SpinLock );         \
    ExInitializeResourceLite( &(P)->Resource );         \
    (P)->ResourceInitialized = TRUE;                \
}

//
//  Our Advanced FCB common header which includes all the normal fields +
//  the NTFS specific pending eof advances, compressed fileobject and
//  section object ptrs. This used to all be in the FSRTL_ADVANCED_FCB_HEADER
//

#ifdef __cplusplus
typedef struct _NTFS_ADVANCED_FCB_HEADER:FSRTL_ADVANCED_FCB_HEADER {
#else   // __cplusplus
typedef struct _NTFS_ADVANCED_FCB_HEADER {

    //
    //  Put in the standard FsRtl header fields
    //

    FSRTL_ADVANCED_FCB_HEADER ;

#endif  // __cplusplus

    //
    //  This is a pointer to a list head which may be used to queue
    //  up advances to EOF (end of file), via calls to the appropriate
    //  FsRtl routines.  This listhead may be paged.
    //

    PLIST_ENTRY PendingEofAdvances;

    //
    //  When FSRTL_FLAG_ADVANCED_HEADER is set, the following fields
    //  are present in the header.  If the compressed stream has not
    //  been initialized, all of the following fields will be NULL.
    //

#ifdef  COMPRESS_ON_WIRE
    //
    //  This is the FileObect for the stream in which data is cached
    //  in its compressed form.
    //

    PFILE_OBJECT FileObjectC;
#endif

} NTFS_ADVANCED_FCB_HEADER, *PNTFS_ADVANCED_FCB_HEADER;


//
//  The NTFS MCB structure is a super set of the FsRtl Large Mcb package
//
//  This structure is ideally aligned on an odd quadword (address ends in 8).
//

typedef struct _NTFS_MCB_ENTRY {

    LIST_ENTRY LruLinks;
    struct _NTFS_MCB *NtfsMcb;
    struct _NTFS_MCB_ARRAY *NtfsMcbArray;
    LARGE_MCB LargeMcb;

} NTFS_MCB_ENTRY;
typedef NTFS_MCB_ENTRY *PNTFS_MCB_ENTRY;

typedef struct _NTFS_MCB_ARRAY {

    VCN StartingVcn;
    VCN EndingVcn;
    PNTFS_MCB_ENTRY NtfsMcbEntry;
    PVOID Unused;

} NTFS_MCB_ARRAY;
typedef NTFS_MCB_ARRAY *PNTFS_MCB_ARRAY;

typedef struct _NTFS_MCB {

    PNTFS_ADVANCED_FCB_HEADER FcbHeader;
    POOL_TYPE PoolType;
    ULONG NtfsMcbArraySizeInUse;
    ULONG NtfsMcbArraySize;
    PNTFS_MCB_ARRAY NtfsMcbArray;
    PFAST_MUTEX FastMutex;

} NTFS_MCB;
typedef NTFS_MCB *PNTFS_MCB;

//
//  Define some additional Ntfs Mcb structures to accomodate small to
//  medium files with fewer pool allocations.  This space will be
//  unused for large files (more than three ranges).
//

#define MCB_ARRAY_PHASE1_SIZE 1
#define MCB_ARRAY_PHASE2_SIZE 3

typedef union {

    //
    //  For the first phase, embed one array element and its Mcb entry.
    //

    struct {

        NTFS_MCB_ARRAY SingleMcbArrayEntry;

        NTFS_MCB_ENTRY McbEntry;

    } Phase1;

    //
    //  For the second phase, we can at least store three entries in
    //  the Mcb Array.
    //

    struct {

        NTFS_MCB_ARRAY ThreeMcbArrayEntries[MCB_ARRAY_PHASE2_SIZE];

    } Phase2;

} NTFS_MCB_INITIAL_STRUCTS;
typedef NTFS_MCB_INITIAL_STRUCTS *PNTFS_MCB_INITIAL_STRUCTS;


//
//  Structure used to track the deallocated clusters.
//

//
//  How many pairs maximum we want stored in an mcb before starting a new one
//

#define NTFS_DEALLOCATED_MCB_LIMIT (PAGE_SIZE / sizeof( LONGLONG ))

typedef struct _DEALLOCATED_CLUSTERS {

    LIST_ENTRY Link;
    LARGE_MCB Mcb;
    LSN Lsn;
    LONGLONG ClusterCount;

} DEALLOCATED_CLUSTERS, *PDEALLOCATED_CLUSTERS;


//
//  The Ntfs ReservedBitmapRange is used to describe the reserved
//  clusters in a range of the file.  This data structure comes in
//  several forms.
//
//  The basic unit is an RtlBitmap and bitmap embedded
//  in a single pool block.  The entire structure is reallocated
//  as it grows past its current size.  This is meant to handle
//  small files.
//
//  As the file gets larger we will allocate a fixed size block
//  which descibes a set range in the file.
//
//  As the file continues to grow then we will link fixed size
//  ranges together.  Only the ranges being accessed will need a
//  bitmap.  We will only allocate the needed space for the
//  bitmap.
//

//
//  RANGE_SIZE - number of compression units per range.
//  RANGE_SHIFT - shift value to convert from compression unit to range.
//

#define NTFS_BITMAP_RANGE_SIZE              (0x2000)
#define NTFS_BITMAP_RANGE_MASK              (NTFS_BITMAP_RANGE_SIZE - 1)
#define NTFS_BITMAP_RANGE_SHIFT             (13)
#define NTFS_BITMAP_MAX_BASIC_SIZE          (NTFS_BITMAP_RANGE_SIZE - ((sizeof( RTL_BITMAP ) + sizeof( LIST_ENTRY )) * 8))

//
//  Grow the basic bitmap in full pool blocks so we don't constantly reallocate
//  as the bitmap grows.  Add the requested bits (converted to bytes) to
//  the pool header and the header of the bitmap
//

#define NtfsBasicBitmapSize(Size)       (                                                               \
    ((((Size + 7) / 8) + 8 + sizeof( LIST_ENTRY ) + sizeof( RTL_BITMAP ) + 0x20 - 1) & ~(0x20 - 1)) -8  \
)

#define NtfsBitmapSize(Size)            (                   \
    ((((Size + 7) / 8) + 8 + 0x20 - 1) & ~(0x20 - 1)) - 8   \
)

typedef struct _RESERVED_BITMAP_RANGE {

    //
    //  Overload the first field.  The Flink field is NULL if we are using
    //  the basic structure.  The Blink field will be the count of dirty
    //  bits for the basic case.  Keeping track of the dirty bits will allow
    //  us to cut off the scan if there are no dirty bits.
    //

    union {

        //
        //  Links for the separate ranges.  A NULL in the Flink
        //  field indicates that this the basic unit and the
        //  bitmap is integrated into the structure.
        //

        LIST_ENTRY Links;

        struct {

            ULONG_PTR Flink;
            USHORT BasicDirtyBits;
            USHORT BasicUnused;
        };
    };

    //
    //  Bitmap structure for this range.
    //

    RTL_BITMAP Bitmap;

    //
    //  The following fields are only valid if this is not
    //  the basic structure.  In the basic structure the
    //  buffer for the bitmap will begin at the following
    //  location.
    //

    //
    //  Range offset.  The size of the bitmap range is
    //  determined by the range shift and mask values above.
    //  Each range will describe a certain number of compression
    //  units.  The range offset is the position of this range
    //  in the file.
    //

    ULONG RangeOffset;

    //
    //  Number of dirty bits.  A zero value indicates that this
    //  range can be reused.
    //

    USHORT DirtyBits;

    //
    //  Unused at this point.
    //

    USHORT Unused;

} RESERVED_BITMAP_RANGE, *PRESERVED_BITMAP_RANGE;


//
//  Following structure is embedded in the Vcb to control the Usn delete operation.
//

typedef struct _NTFS_DELETE_JOURNAL_DATA {

    FILE_REFERENCE DeleteUsnFileReference;

    PSCB PriorJournalScb;
    ULONG DeleteState;
    NTSTATUS FinalStatus;

} NTFS_DELETE_JOURNAL_DATA, *PNTFS_DELETE_JOURNAL_DATA;

#define DELETE_USN_RESET_MFT                (0x00000001)
#define DELETE_USN_REMOVE_JOURNAL           (0x00000002)
#define DELETE_USN_FINAL_CLEANUP            (0x00000004)


//
//  Local structures to manage the cached free clusters.
//

#define NTFS_INITIAL_CACHED_RUNS        (0x20)
#define NTFS_MAX_CACHED_RUNS_DELTA      (0x200)

//
//  Define the maximum run index
//

#define NTFS_CACHED_RUNS_MAX_INDEX      (MAXSHORT)

//
//  Define a run index that will be used to identify an entry whose
//  corresponding entry in the other sorted list no longer refers
//  to it.  This is used when an entry is deleted from one sorted
//  list and hasn't yet been removed from the other.
//

#define NTFS_CACHED_RUNS_DEL_INDEX      (MAXUSHORT)

//
//  Define the number of bins of run lengths to keep track of.
//

#define NTFS_CACHED_RUNS_BIN_COUNT          (32)

//
//  Define the number of windows of deleted entries to keep track of for
//  each sort table.
//

#define NTFS_CACHED_RUNS_MAX_DEL_WINDOWS    (64)

typedef struct _NTFS_LCN_CLUSTER_RUN {

    //
    //  The cluster number where the free run begins
    //

    LCN Lcn;

    //
    //  The number of clusters in the free run starting at Lcn.
    //

    LONGLONG RunLength;

    //
    //  This is the index of the corresponding entry in the length-sorted list
    //

    USHORT LengthIndex;

    //
    //  Pad the structure out to 64-bit alignment
    //

    USHORT Pad0;
    ULONG Pad1;

} NTFS_LCN_CLUSTER_RUN, *PNTFS_LCN_CLUSTER_RUN;

typedef struct _NTFS_DELETED_RUNS {

    //
    //  The starting and ending indices of a window of cached runs that have
    //  been deleted.  These are indices into the Lcn-sorted or length-sorted
    //  arrays.
    //

    USHORT StartIndex;
    USHORT EndIndex;

} NTFS_DELETED_RUNS, *PNTFS_DELETED_RUNS;

typedef struct _NTFS_CACHED_RUNS {

    //
    //  Pointer to the array of free runs sorted by Lcn
    //

    PNTFS_LCN_CLUSTER_RUN LcnArray;

    //
    //  Pointer to an array of indices of the Lcn-sorted array
    //  above, sorted by RunLength, and sub-sorted by Lcn.
    //

    PUSHORT LengthArray;

    //
    //  Pointer to an array of bins.  Each bin contains the number of
    //  entries in LengthArray of a given run length.  BinArray[0] contains
    //  the count of entries with run length 1.  BinArray[1] contains run
    //  length 2, and so on.
    //
    //  This array is used to keep track of how many small free runs are
    //  cached so that we keep a sufficient number of them around.
    //

    PUSHORT BinArray;

    //
    //  An array of windows of cached runs in LcnArray that have been
    //  deleted.
    //

    PNTFS_DELETED_RUNS DeletedLcnWindows;

    //
    //  An array of windows of cached runs in LengthArray that have been
    //  deleted.
    //

    PNTFS_DELETED_RUNS DeletedLengthWindows;

    //
    //  The longest freed run so far.
    //

    LONGLONG LongestFreedRun;

    //
    //  The maximum number of entries to which LcnArray should grow.  The same
    //  limit applies to LengthArray.
    //

    USHORT MaximumSize;

    //
    //  The desired number of small length free runs to keep cached for
    //  each size.
    //

    USHORT MinCount;

    //
    //  The allocated number of entries in LcnArray.  The same number are
    //  available in LengthArray.
    //

    USHORT Avail;

    //
    //  The number of entries used in LcnArray.  The same number are used
    //  in LengthArray.
    //

    USHORT Used;

    //
    //  The number of entries in DeletedLcnWindows.
    //

    USHORT DelLcnCount;

    //
    //  The number of entries in DeletedLengthWindows.
    //

    USHORT DelLengthCount;

    //
    //  The number of entries in BinArray.
    //

    USHORT Bins;

} NTFS_CACHED_RUNS, *PNTFS_CACHED_RUNS;


//
//  The following structures are used for the filename hash table.
//

//
//  Constants controlling the total number of buckets
//

#define HASH_MAX_SEGMENT_COUNT          (32)
#define HASH_SEGMENT_SHIFT              (5)
#define HASH_MAX_INDEX_COUNT            (1024)
#define HASH_INDEX_SHIFT                (10)
#define HASH_MAX_BUCKET_COUNT           (HASH_MAX_SEGMENT_COUNT * HASH_MAX_INDEX_COUNT)

//
//  This is the basic structure for a hash entry.  A hash entry is described by the
//  the hash value computed from a full path name.  We will only store hash entries
//  for files without DOS-only components.
//
//  We will only allow one entry in the table for each (Lcb, string length, hash value)
//  triplet.  We don't want to store the full string in the table for each entry.
//  After a lookup it will be up to the caller to verify the string.
//
//  We keep a loose coherency between the hash table and the Lcb.  The hash table
//  points definitively back to an Lcb but the Lcb only suggests that there is an
//  entry in the table.  This way if we remove an entry from the table we won't
//  have to track down the Lcb.
//

typedef struct _NTFS_HASH_ENTRY {

    //
    //  Pointer to the next entry in the same bucket.  Note that the chain
    //  of entries in the same bucket don't all have the hash value.
    //

    struct _NTFS_HASH_ENTRY *NextEntry;

    //
    //  The entry is described by the hash value, filename length and the Lcb for the
    //  last component.
    //

    struct _LCB *HashLcb;
    ULONG HashValue;
    ULONG FullNameLength;

} NTFS_HASH_ENTRY, *PNTFS_HASH_ENTRY;

//
//  The hash segments consists of an array of hash entry pointers.
//

typedef PNTFS_HASH_ENTRY NTFS_HASH_SEGMENT[ HASH_MAX_INDEX_COUNT ];
typedef NTFS_HASH_SEGMENT *PNTFS_HASH_SEGMENT;

//
//  The basic table consists of an array of segments.  Each segment contains a fixed
//  number of buckets.  Once the initial segment has buckets which are deeper than
//  our max optimal depth then we will double the number of segments and split the
//  existing entries across the new segments.  The process of splitting is done bucket
//  by bucket until we reach the new size.  During this process we need to keep track
//  of whether the new entry belongs to a bucket which has already been split.
//

//
//  Table state value
//

#define TABLE_STATE_STABLE              (0x00000000)
#define TABLE_STATE_EXPANDING           (0x00000001)
#define TABLE_STATE_REDUCING            (0x00000002)

typedef struct _NTFS_HASH_TABLE {

    //
    //  Max bucket is always 2^n.  When we grow the table we double the number of buckets
    //  but need to split the existing buckets to find which entries should be moved
    //  to the expanded region.  The SplitPoint is our current position to do this
    //  work.
    //

    ULONG MaxBucket;
    ULONG SplitPoint;

    ULONG TableState;

#ifdef NTFS_HASH_DATA
    ULONG HashLookupCount;
    ULONG SkipHashLookupCount;
    ULONG FileMatchCount;
    ULONG ParentMatchCount;

    ULONG CreateNewFileInsert;
    ULONG OpenFileInsert;
    ULONG OpenExistingInsert;
    ULONG ParentInsert;

    ULONG OpenFileConflict;
    ULONG OpenExistingConflict;
    ULONG ParentConflict;

    ULONG CreateScbFails;
    ULONG CreateLcbFails;

    ULONG Histogram[16];
    ULONG ExtendedHistogram[16];

#endif

    PNTFS_HASH_SEGMENT HashSegments[ HASH_MAX_SEGMENT_COUNT ];

} NTFS_HASH_TABLE, *PNTFS_HASH_TABLE;

//
//  Scrambling values for generating hash
//

#define HASH_STRING_CONVERT_CONSTANT        (314159269)
#define HASH_STRING_PRIME                   (1000000007)

//
//  Build an intermediate hash based on processing a number of WCHAR characters
//  pointed to by an input string.  In most cases this will be a UNICODE_STRING.
//  It might also be a pointer though.
//

//
//  VOID
//  NtfsConvertNameToHash (
//      IN PWCHAR Buffer,
//      IN ULONG Length,
//      IN PWCH UpcaseTable,
//      IN OUT PULONG Hash
//      );
//

#define NtfsConvertNameToHash(B,L,U,H) {        \
    PWCHAR _Current = (B);                      \
    PWCHAR _End = Add2Ptr( _Current, (L) );     \
    ULONG _Hash = *(H);                         \
    do {                                        \
                                                \
        _Hash = 37 * _Hash + (U)[*(_Current)];  \
        _Current += 1;                          \
                                                \
    } while (_Current != _End);                 \
    *(H) = _Hash;                               \
}

//
//  ULONG
//  NtfsGenerateHashFromUlong (
//      IN ULONG Ulong
//      );
//

#define NtfsGenerateHashFromUlong(U) (                              \
    abs( HASH_STRING_CONVERT_CONSTANT * (U) ) % HASH_STRING_PRIME   \
)


//
//  The Vcb structure corresponds to every mounted NTFS volume in the
//  system
//

#define VCB_SECURITY_CACHE_BY_ID_SIZE   31
#define VCB_SECURITY_CACHE_BY_HASH_SIZE 31

//
//  Default Minimum Usn Journal Size.
//

#define MINIMUM_USN_JOURNAL_SIZE        (0x100000)

typedef struct _VCB {

    //
    //  The type and size of this record (must be NTFS_NTC_VCB)
    //
    //  Assumption here is that this structure is embedded within a
    //  device object and the base of this structure in on an even
    //  64-bit boundary.  We will put the embedded structures on
    //  the same boundaries they would be on if allocated from pool
    //  (odd 64-bit boundary) except if the structure would fit
    //  within a 16 byte cache line.
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The internal state of the volume.  The VcbState is synchronized with the Vcb resource.
    //

    ULONG VcbState;

    //
    //  The links for the queue of all the Vcbs in the system.
    //  Corresponds to the filld NtfsData.VcbQueue
    //

    LIST_ENTRY VcbLinks;

    //
    //  Pointer to the Scb for the special system file.  If the field is
    //  null then we haven't yet built the scb for that system file.  Also
    //  the pointer to the stream file object is located in the scb.
    //
    //  NOTE: AcquireExclusiveFiles depends on this order.  Any change
    //  here should be checked with the code there.
    //

    PSCB RootIndexScb;
    PSCB UsnJournal;
    PSCB MftScb;
    PSCB Mft2Scb;
    PSCB LogFileScb;
    PSCB VolumeDasdScb;
    PSCB BitmapScb;
    PSCB AttributeDefTableScb;
    PSCB UpcaseTableScb;
    PSCB BadClusterFileScb;
    PSCB ExtendDirectory;
    PSCB QuotaTableScb;
    PSCB ReparsePointTableScb;
    PSCB OwnerIdTableScb;
    PSCB SecurityDescriptorStream;
    PSCB SecurityIdIndex;
    PSCB SecurityDescriptorHashIndex;
    PSCB ObjectIdTableScb;
    PSCB MftBitmapScb;

    //
    //  File object for log file.  We always dereference the file object for the
    //  log file last.  This will allow us to synchronize when the Vpb for the
    //  volume is deleted.
    //

    PFILE_OBJECT LogFileObject;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to
    //  when it needs to do any I/O (e.g., the disk stripper device
    //  object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  Lfs Log Handle for this volume
    //

    LFS_LOG_HANDLE LogHandle;

    //
    //  The root Lcb for this volume.
    //

    struct _LCB *RootLcb;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume. And a count of the number of special system
    //  files that we have open
    //

    CLONG CleanupCount;
    CLONG CloseCount;
    CLONG ReadOnlyCloseCount;
    CLONG SystemFileCloseCount;

    //
    //  The following fields are used by the BitmpSup routines.  The first
    //  value contains the total number of clusters on the volume, this
    //  is computed from the boot sector information.  The second value
    //  is the current number of free clusters available for allocation on
    //  the volume.  Allocation is handled by using a free space mcb that
    //  describes some small window of known clusters that are free.
    //
    //  The last field is for storing local volume specific data needed by
    //  the bitmap routines
    //

    LONGLONG TotalClusters;
    LONGLONG FreeClusters;
    LONGLONG DeallocatedClusters;

    //
    //  Total number of reserved clusters on the volume, must be less than
    //  or equal to FreeClusters.  Use the security fast mutex as a
    //  convenient end resource for this field.
    //

    LONGLONG TotalReserved;

    //
    //  If we are growing the volume bitmap then we need to restore the total number of
    //  clusters.
    //

    LONGLONG PreviousTotalClusters;

    //
    //  This field contains a calculated value which determines when an
    //  individual attribute is large enough to be moved to free up file
    //  record space.  (The calculation of this variable must be
    //  considered in conjunction with the constant
    //  MAX_MOVEABLE_ATTRIBUTES below.)
    //

    ULONG BigEnoughToMove;

    //
    //  The following volume-specific parameters are extracted from the
    //  Boot Sector.
    //

    ULONG DefaultBlocksPerIndexAllocationBuffer;
    ULONG DefaultBytesPerIndexAllocationBuffer;

    ULONG BytesPerSector;
    ULONG BytesPerCluster;
    ULONG BytesPerFileRecordSegment;

    //
    //  Zero clusters per file record segment indicates that clusters are larger than
    //  file records.  Zero file record segments per clusters indicates that
    //  file records are larger than clusters.
    //

    ULONG ClustersPerFileRecordSegment;
    ULONG FileRecordsPerCluster;

    ULONG ClustersPer4Gig;

    //
    //  Clusters per page will be 1 if the cluster size is larger than the page size
    //

    ULONG ClustersPerPage;

    LCN MftStartLcn;
    LCN Mft2StartLcn;
    LONGLONG NumberSectors;

    //
    //  The following fields are used to verify that an NTFS volume hasn't
    //  changed.  The serial number is stored in the boot sector on disk,
    //  and the four times are from the standard information field of the
    //  volume file.
    //

    LONGLONG VolumeSerialNumber;

    LONGLONG VolumeCreationTime;
    LONGLONG VolumeLastModificationTime;
    LONGLONG VolumeLastChangeTime;
    LONGLONG VolumeLastAccessTime;

    //
    //  Convenient constants for the conversion macros.  Shift and mask values are for
    //
    //      Clusters <=> Bytes
    //      FileRecords <=> Bytes
    //      FileRecords <=> Clusters
    //
    //  Note that you must know whether to shift right or left when using the
    //  file record/cluster shift value.
    //

    ULONG ClusterMask;              //  BytesPerCluster - 1
    LONG InverseClusterMask;        //  ~ClusterMask - signed for 64-bit system
    ULONG ClusterShift;             //  2**ClusterShift == BytesPerCluster

    ULONG MftShift;                 //  2**MftShift == BytesPerFileRecord
    ULONG MftToClusterShift;        //  2**MftClusterShift == ClusterPerFileRecordSegment
                                    //  2**MftToClusterShift == FileRecordsPerCluster

    ULONG MftReserved;
    ULONG MftCushion;

    //
    //  Synchronization objects for checkpoint operations.
    //

    ULONG CheckpointFlags;
    FAST_MUTEX CheckpointMutex;
    KEVENT CheckpointNotifyEvent;

    //
    //  Mutex to synchronize access to the Fcb table.
    //

    FAST_MUTEX FcbTableMutex;

    //
    //  Mutex to synchronize access to the security descriptors.
    //

    FAST_MUTEX FcbSecurityMutex;

    //
    //  Mutex to synchronize access to reserved clusters.
    //

    FAST_MUTEX ReservedClustersMutex;

    //
    //  Mutex for the hash table.
    //

    FAST_MUTEX HashTableMutex;

    //
    //  We don't allow compression on a system with a cluster size greater than
    //  4k.  Use a mask value here to quickly check allowed compression on
    //  this volume.
    //

    USHORT AttributeFlagsMask;

    //
    //  Remember what version this volume is so we can selectively enable
    //  certain features.
    //

    UCHAR MajorVersion;
    UCHAR MinorVersion;

    //
    //  The count of free records is based on the size of the Mft and the
    //  allocated records.  The hole count is the count of how many file
    //  records are not allocated.
    //

    ULONG MftHoleGranularity;

    ULONG MftFreeRecords;
    ULONG MftHoleRecords;

    //
    //  Variables for Mft hole calculations.
    //

    ULONG MftHoleMask;
    LONG MftHoleInverseMask;

    //
    //  The count of the bitmap bits per hole.  This is the number of file
    //  records per hole.  Must be converted to clusters to find a hole in
    //  the Mft Mcb.
    //

    ULONG MftClustersPerHole;
    ULONG MftHoleClusterMask;
    ULONG MftHoleClusterInverseMask;

    //
    //  The following table of unicode values is the case mapping, with
    //  the size in number of Unicode characters.  If the upcase table
    //  that is stored in NtfsData matches the one for the volume then
    //  we'll simply use that one and not allocate a special one for the
    //  volume.
    //

    ULONG UpcaseTableSize;
    PWCH UpcaseTable;

    //
    //  A pointer to an array of structs to hold performance counters,
    //  one array element for each processor.  The array is allocated
    //  from non-paged pool.  If this member is deleted, replace with
    //  padding.
    //

    struct _FILE_SYSTEM_STATISTICS *Statistics;

    //
    //  Open attribute table.
    //

    LSN LastRestartArea;
    RESTART_POINTERS OpenAttributeTable;

    //
    //  Transaction table.
    //

    LSN LastBaseLsn;
    RESTART_POINTERS TransactionTable;

    //
    //  LSNs of the end of the last checkpoint and the last RestartArea.
    //  Normally the RestartArea Lsn is greater than the other one,
    //  however if the VcbState indicates that a checkpoint is in
    //  progress, then these Lsns are in flux.
    //

    LSN EndOfLastCheckpoint;

    //
    //  Current Lsn we used at mount time
    //

    LSN CurrentLsnAtMount;

    //
    //  The following string contains the device name for this partition.
    //

    UNICODE_STRING DeviceName;

    //
    //  A table of all the fcb that have been created for this volume.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  The following is the head of a list of notify Irps for directories.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  The following is the head of a list of notify Irps for view indices.
    //

    LIST_ENTRY ViewIndexNotifyList;

    //
    //  The following is used to synchronize the dir notify lists.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following field is a pointer to the file object that has the
    //  volume locked. if the VcbState has the locked flag set.
    //

    PFILE_OBJECT FileObjectWithVcbLocked;

    //
    //  The following two fields are used by the bitmap routines to
    //  determine what is called the mft zone.  The Mft zone are those
    //  clusters on the disk were we will try and put the mft and only the
    //  mft unless the disk is getting too full.
    //

    LCN MftZoneStart;
    LCN MftZoneEnd;

    //
    //  Information to track activity in the volume bitmap.  If we are extending
    //  the Mft we don't want to constantly force a rescan of the bitmap if
    //  there is no activity.
    //

    LONGLONG ClustersRecentlyFreed;

    //
    //  The following are used to track the deallocated clusters waiting
    //  for a checkpoint.  The pointers are used so we can toggle the
    //  use of the structures.
    //

    LIST_ENTRY DeallocatedClusterListHead;

    DEALLOCATED_CLUSTERS DeallocatedClusters1;
    DEALLOCATED_CLUSTERS DeallocatedClusters2;

    //
    //  Fields associated with the Usn Journal.  MaximumSize is the size in
    //  bytes that the Journal is allowed to occupy.  StartUsn is the lowest Usn
    //  in the allocated range of the Journal.  LowestOpenUsn remembers a Usn
    //  from restart from which a scan for Fcbs not closed at the time of a
    //  crash must be done.  ModifiedOpenFiles is a listhead of Fcbs with
    //  active Usn records but have not written the final cleanup record.
    //  These fields and the list are synchronized by the UsnJournal resource.
    //

    USN_JOURNAL_INSTANCE UsnJournalInstance;
    USN FirstValidUsn;                      //  Synchronized by main file resource
    USN LowestOpenUsn;
    FILE_REFERENCE UsnJournalReference;
    LONGLONG UsnCacheBias;
    LIST_ENTRY ModifiedOpenFiles;           //  Synchronized by the NtfsLockFcb on UsnJournal
    LIST_ENTRY NotifyUsnDeleteIrps;         //  Synchronized with NtfsLock/UnlockUsnNotify.

    PLIST_ENTRY CurrentTimeOutFiles;
    PLIST_ENTRY AgedTimeOutFiles;

    LIST_ENTRY TimeOutListA;
    LIST_ENTRY TimeOutListB;

    NTFS_DELETE_JOURNAL_DATA DeleteUsnData;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  Resource to manage mft lazywrite flushes and mft defrag
    //

    ERESOURCE MftFlushResource;

    //
    //  Log header reservation.  This is the amount to add to the reservation
    //  amount to compensate for the commit record.  Lfs reserves differently
    //  for its log record header and the body of a log record.
    //

    ULONG LogHeaderReservation;

    //
    //  Count of outstanding notify handles.  If zero we can noop the notify calls.
    //

    ULONG NotifyCount;

    //
    //  Count of outstanding view index notify handles.  If zero we can noop view
    //  index notify calls.
    //

    ULONG ViewIndexNotifyCount;

    //
    //  Count of media changes before this volume was mounted.  Helps NtfsPingVolume
    //  notice when we've missed a media change notification.
    //

    ULONG DeviceChangeCount;

    struct _SHARED_SECURITY **SecurityCacheById[VCB_SECURITY_CACHE_BY_ID_SIZE];
    struct _SHARED_SECURITY *SecurityCacheByHash[VCB_SECURITY_CACHE_BY_HASH_SIZE];

    SECURITY_ID NextSecurityId;

    //
    //  Quota state and flags are protected by the QuotaControlLock above
    //

    ULONG QuotaState;

    //
    //  QuotaFlags are a copy of the flags from default user index entry.
    //

    ULONG QuotaFlags;

    //
    // The next owner Id to be allocated.
    //

    ULONG QuotaOwnerId;

    //
    //  Delete sequence number.  The value gets incremented each time
    //  an owner id is marked for deletion.
    //

    ULONG QuotaDeleteSecquence;

    //
    //  Quota control delete sequence. This values gets incremented each time
    //  a quota control block is removed from table.
    //

    ULONG QuotaControlDeleteCount;

    //
    // The following items are for Quota support.
    // The QuotaControlTable is the root of the quota control blocks.
    //

    RTL_GENERIC_TABLE QuotaControlTable;

    //
    // Lock used for QuotaControlTable;
    //

    FAST_MUTEX QuotaControlLock;

    //
    //  Current file reference used by the quota repair code.
    //

    FILE_REFERENCE QuotaFileReference;

    //
    // Administrator Owner Id.
    //

    ULONG AdministratorId;

    //
    //  ObjectIdState indicates the state of the object id index.
    //

    ULONG ObjectIdState;

    //
    // Quota Control template used addin entry to the quota control table.
    //

    struct _QUOTA_CONTROL_BLOCK *QuotaControlTemplate;

    //
    //  This is a pointer to the attribute definitions for the volume
    //  which are loaded into nonpaged pool.
    //

    PATTRIBUTE_DEFINITION_COLUMNS AttributeDefinitions;

    //
    //  File property (shortname/longname/createtime) tunneling structure
    //

    TUNNEL Tunnel;

    //
    //  Size and number of clusters in the sparse file unit.
    //  Initially this is 64K.
    //

    ULONG SparseFileUnit;
    ULONG SparseFileClusters;

    //
    //  Save away the maximum cluster count for this volume (limit to
    //  MAXFILESIZE).
    //

    LONGLONG MaxClusterCount;

    //
    //  Embed the Lfs WRITE_DATA structure so we can trim the writes
    //  from MM.
    //

    LFS_WRITE_DATA LfsWriteData;

    //
    //  Count of AcquireAllFiles.
    //

    ULONG AcquireFilesCount;

    ULONG LogFileFullCount;
    ULONG CleanCheckpointMark;

    //
    //  What restart version are we currently using.
    //

    ULONG RestartVersion;
    ULONG OatEntrySize;

    //
    //  Total number of entries on the async and delayed close queues for this Vcb.
    //

    CLONG QueuedCloseCount;

    //
    //  Spare Vpb for dismount.  Avoid using MustSucceed pool by preallocating
    //  the Vpb that might be needed for a dismount.
    //

    PVPB SpareVpb;

    //
    //  Open attribute table to store on disk.  It may point to the embedded
    //  open attribute table if the on-disk and in-memory version are the same.
    //

    PRESTART_POINTERS OnDiskOat;

    //
    //  Linked list of OpenAttribute extended data structures.
    //

    LIST_ENTRY OpenAttributeData;

    //
    //  The volume object id, if any.  This can only be set for upgraded volumes.
    //

    UCHAR VolumeObjectId[OBJECT_ID_KEY_LENGTH];

    NTFS_CACHED_RUNS CachedRuns;

    //
    //  Last Lcn used for fresh allocation
    //

    LCN LastBitmapHint;

    //
    //  File name hash table.
    //

    NTFS_HASH_TABLE HashTable;

    //
    //  The MftDefragState is synchronized with the CheckpointEvent.
    //  The MftReserveFlags are sychronized with the MftScb.
    //

    ULONG MftReserveFlags;
    ULONG MftDefragState;

    //
    //  Hint for dirty page table size
    //

    ULONG DirtyPageTableSizeHint;

    //
    //  Checkpoint owner thread.
    //

    PVOID CheckpointOwnerThread;

#ifdef NTFS_CHECK_BITMAP
    PRTL_BITMAP BitmapCopy;
    ULONG BitmapPages;
#endif

#ifdef BENL_DBG
    LIST_ENTRY RestartRedoHead;
    LIST_ENTRY RestartUndoHead;
#endif

#ifdef SYSCACHE_DEBUG
    PSCB SyscacheScb;
#endif

} VCB;
typedef VCB *PVCB;

//
//  These are the VcbState flags.  Synchronized with the Vcb resource.
//

#define VCB_STATE_VOLUME_MOUNTED            (0x00000001)
#define VCB_STATE_LOCKED                    (0x00000002)
#define VCB_STATE_REMOVABLE_MEDIA           (0x00000004)
#define VCB_STATE_VOLUME_MOUNTED_DIRTY      (0x00000008)
#define VCB_STATE_RESTART_IN_PROGRESS       (0x00000010)
#define VCB_STATE_FLAG_SHUTDOWN             (0x00000020)
#define VCB_STATE_NO_SECONDARY_AVAILABLE    (0x00000040)
#define VCB_STATE_RELOAD_FREE_CLUSTERS      (0x00000080)
#define VCB_STATE_PRELOAD_MFT               (0x00000100)
#define VCB_STATE_VOL_PURGE_IN_PROGRESS     (0x00000200)
#define VCB_STATE_TEMP_VPB                  (0x00000400)
#define VCB_STATE_PERFORMED_DISMOUNT        (0x00000800)
#define VCB_STATE_VALID_LOG_HANDLE          (0x00001000)
#define VCB_STATE_DELETE_UNDERWAY           (0x00002000)
#define VCB_STATE_REDUCED_MFT               (0x00004000)
#define VCB_STATE_EXPLICIT_LOCK             (0x00008000)
#define VCB_STATE_DISALLOW_DISMOUNT         (0x00010000)
#define VCB_STATE_VALID_OBJECT_ID           (0x00020000)
#define VCB_STATE_OBJECT_ID_CLEANUP         (0x00040000)

#define VCB_STATE_USN_JOURNAL_ACTIVE        (0x00080000)
#define VCB_STATE_USN_DELETE                (0x00100000)
#define VCB_STATE_USN_JOURNAL_PRESENT       (0x00200000)
#define VCB_STATE_INCOMPLETE_USN_DELETE     (0x00400000)

#define VCB_STATE_EXPLICIT_DISMOUNT         (0x00800000)
#define VCB_STATE_LOCK_IN_PROGRESS          (0x01000000)
#define VCB_STATE_MOUNT_READ_ONLY           (0x02000000)
#define VCB_STATE_FLUSH_VOLUME_ON_IO        (0x04000000)
#define VCB_STATE_TARGET_DEVICE_STOPPED     (0x08000000)
#define VCB_STATE_MOUNT_COMPLETED           (0x10000000)

#define VCB_STATE_BAD_RESTART               (0x20000000)

//
//  These are the flags for the Mft and the reserveration state.
//  Although these are in the Vcb they are synchronized with
//  the resource in the MftScb.
//

#define VCB_MFT_RECORD_RESERVED             (0x00000001)
#define VCB_MFT_RECORD_15_USED              (0x00000002)

//
//  These are the MftDefragState flags.  Synchronized with the
//  CheckpointEvent.
//

#define VCB_MFT_DEFRAG_PERMITTED            (0x00000001)
#define VCB_MFT_DEFRAG_ENABLED              (0x00000002)
#define VCB_MFT_DEFRAG_TRIGGERED            (0x00000004)
#define VCB_MFT_DEFRAG_ACTIVE               (0x00000008)
#define VCB_MFT_DEFRAG_EXCESS_MAP           (0x00000010)

//
//  These are the Checkpoint flags.  Synchronized with the
//  CheckpointEvent.  These flags are in the CheckpointFlags
//  field.
//

#define VCB_DUMMY_CHECKPOINT_POSTED         (0x00000001)
#define VCB_CHECKPOINT_IN_PROGRESS          (0x00000002)
#define VCB_LAST_CHECKPOINT_CLEAN           (0x00000004)
#define VCB_DEREFERENCED_LOG_FILE           (0x00000008)
#define VCB_STOP_LOG_CHECKPOINT             (0x00000010)

#define VCB_CHECKPOINT_SYNC_FLAGS           (VCB_CHECKPOINT_IN_PROGRESS | VCB_STOP_LOG_CHECKPOINT)

//
//  These are Vcb quota state flags.  Synchronized with the
//  QuotaControlLock.  These flags are in the QuotaState field.
//

#define VCB_QUOTA_REPAIR_POSTED             (0x00000100)
#define VCB_QUOTA_CLEAR_RUNNING             (0x00000200)
#define VCB_QUOTA_INDEX_REPAIR              (0x00000300)
#define VCB_QUOTA_OWNER_VERIFY              (0x00000400)
#define VCB_QUOTA_RECALC_STARTED            (0x00000500)
#define VCB_QUOTA_DELETEING_IDS             (0x00000600)
#define VCB_QUOTA_REPAIR_RUNNING            (0x00000700)
#define VCB_QUOTA_SAVE_QUOTA_FLAGS          (0x00001000)

//
//  These are Vcb object id state flags.  Synchronized with the
//  ObjectIdTableScb->Resource.  These flags are in the ObjectIdState field.
//

#define VCB_OBJECT_ID_CORRUPT               (0x00000001)
#define VCB_OBJECT_ID_REPAIR_RUNNING        (0x00000002)

//
//  This is the maximum number of attributes in a file record which could
//  be considered for moving.  This value should be changed only in
//  conjunction with the initialization of the BigEnoughToMove field
//  above.
//

#define MAX_MOVEABLE_ATTRIBUTES          (3)

//
//  Define the file system statistics struct.  Vcb->Statistics points to an
//  array of these (one per processor) and they must be 64 byte aligned to
//  prevent cache line tearing.
//

typedef struct _FILE_SYSTEM_STATISTICS {

        //
        //  This contains the actual data.
        //

        FILESYSTEM_STATISTICS Common;
        NTFS_STATISTICS Ntfs;

        //
        //  Pad this structure to a multiple of 64 bytes.
        //

        UCHAR Pad[64-(sizeof(FILESYSTEM_STATISTICS)+sizeof(NTFS_STATISTICS))%64];

} FILE_SYSTEM_STATISTICS;

typedef FILE_SYSTEM_STATISTICS *PFILE_SYSTEM_STATISTICS;


//
//  The Volume Device Object is an I/O system device object with a
//  workqueue and an VCB record appended to the end.  There are multiple
//  of these records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload
//  of work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow
    //  queue.  The Overflow queue is a list of IRP's linked via the IRP's
    //  ListEntry field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  Event used to synchronize entry into the queue when its heavily used
    //

    KEVENT OverflowQueueEvent;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;



//
//  The following structure is used to perform a quick lookup of an
//  index entry for the update duplicate information call.
//

typedef struct _QUICK_INDEX {

    //
    //  Change count for the Scb Index stream when this snapshot is made.
    //

    ULONG ChangeCount;

    //
    //  This is the offset of the entry in the buffer.  A value of zero is
    //  used for an entry in the root index.
    //

    ULONG BufferOffset;

    //
    //  Captured Lsn for page containing this entry.
    //

    LSN CapturedLsn;

    //
    //  This is the IndexBlock for the index bucket.
    //

    LONGLONG IndexBlock;

} QUICK_INDEX;

typedef QUICK_INDEX *PQUICK_INDEX;

//
//  This structure is used to contain a link name and connections into
//  the splay tree for the parent.
//

typedef struct _NAME_LINK {

    UNICODE_STRING LinkName;
    RTL_SPLAY_LINKS Links;

} NAME_LINK, *PNAME_LINK;

//
//  The Lcb record corresponds to every open path between an Scb and an
//  Fcb.  It denotes the name which was used to go from the scb to the fcb
//  and it also contains a queue of ccbs that have opened the fcb via that
//  name and also a queue of Prefix Entries that will get us to this lcb
//

typedef struct _OVERLAY_LCB {

    //
    //  We will need a FILE_NAME_ATTR in order to lookup the entry
    //  for the UpdateDuplicateInfo calls.  We would like to keep
    //  one around but there are 0x38 bytes in it which will be unused.
    //  Instead we will overlay the Lcb with one of these.  Then we can
    //  store other data within the unused bytes.
    //
    //  NOTE - This will save an allocation but the sizes must match exactly
    //  or the name will be in the wrong location.  This structure will
    //  overlay a FILE_NAME attribute exactly.  The fields below which are
    //  prefaced with 'Overlay' correspond to the fields in the filename
    //  attribute which are being used with this structure.
    //
    //  We will put an assert in NtfsInit to verify this.
    //

    FILE_REFERENCE OverlayParentDirectory;

    //
    // On 32-bit systems the remainder of the structure members up to the
    // overlay entries previously occupied exactly the required amount of
    // space for the DUPLICATE_INFOMATION structure. On 64-bit systems,
    // this is not true and a little difference layout must be used.
    //

    union {

        DUPLICATED_INFORMATION Alignment;

        struct {

            //
            //  This is used for lookups in the directory containing this link.
            //

            QUICK_INDEX QuickIndex;

            //
            //  This is the number of references to this link.  The parent
            //  Scb must be owned to modify this count.
            //

            ULONG ReferenceCount;

            //
            //  These are the flags for the changes to this link and the
            //  change count for the duplicated information on this link.
            //

            ULONG InfoFlags;

            //
            //  Hash value for this Lcb.  Note - it is not guaranteed to be in the table.
            //

            ULONG HashValue;

            //
            //  This is the number of unclean handles on this link.
            //

            ULONG CleanupCount;

            //
            //  Internal reference to FileName attribute either embedded in overlay or external
            //  allocation (if size doesn't fit into storage).  On Win64 systems this will
            //  fill the overlay.  On Win32 systems we waste 4 bytes.
            //

            PFILE_NAME FileNameAttr;
        };
    };

    UCHAR OverlayFileNameLength;

    UCHAR OverlayFlags;

    WCHAR OverlayFileName[1];

} OVERLAY_LCB, *POVERLAY_LCB;

typedef struct _LCB {

    //
    //  Type and size of this record must be NTFS_NTC_LCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Internal state of the Lcb
    //

    ULONG LcbState;

    //
    //  The links for all the Lcbs that emminate out of an Scb and a
    //  pointer back to the Scb.  Corresponds to Scb->LcbQueue.
    //

    LIST_ENTRY ScbLinks;
    PSCB Scb;

    //
    //  The links for all the Lcbs that go into an Fcb and a pointer
    //  back to the Fcb.  Corresponds to Fcb->LcbQueue.
    //

    struct _FCB *Fcb;
    LIST_ENTRY FcbLinks;

    //
    //  The following is the case-insensitive name link.
    //

    NAME_LINK IgnoreCaseLink;

    //
    //  The following is the case-sensitive name link.
    //
    //  This field is here on the 64-bit system and in the overlay lcb
    //  structure on the 32-bit system.
    //

    NAME_LINK ExactCaseLink;

    //
    //  A queue of Ccbs that have the Fcb (via this edge) opened.
    //  Corresponds to Ccb->LcbLinks
    //

    LIST_ENTRY CcbQueue;

    //
    //  We will need a FILE_NAME_ATTR in order to lookup the entry
    //  for the UpdateDuplicateInfo calls.  We would like to keep
    //  one around but there are 0x38 bytes in it which will be unused.
    //  Instead we will overlay the Lcb with one of these.  Then we can
    //  store other data within the unused bytes.
    //
    //  NOTE - This will save an allocation but the sizes much match exactly
    //  or the name will be in the wrong location.
    //

    union {

        FILE_NAME;
        OVERLAY_LCB;
    };

} LCB;
typedef LCB *PLCB;

#define LCB_STATE_DELETE_ON_CLOSE        (0x00000001)
#define LCB_STATE_LINK_IS_GONE           (0x00000002)
#define LCB_STATE_EXACT_CASE_IN_TREE     (0x00000004)
#define LCB_STATE_IGNORE_CASE_IN_TREE    (0x00000008)
#define LCB_STATE_DESIGNATED_LINK        (0x00000010)
#define LCB_STATE_VALID_HASH_VALUE       (0x00000020)

#define LcbSplitPrimaryLink( LCB )                      \
    ((LCB)->FileNameAttr->Flags == FILE_NAME_NTFS       \
     || (LCB)->FileNameAttr->Flags == FILE_NAME_DOS )

#define LcbSplitPrimaryComplement( LCB )                \
    (((LCB)->FileNameAttr->Flags == FILE_NAME_NTFS) ?   \
     FILE_NAME_DOS : FILE_NAME_NTFS)

#define LcbLinkIsDeleted( LCB )                                                 \
    ((FlagOn( (LCB)->LcbState, LCB_STATE_DELETE_ON_CLOSE ))                     \
    || ((FlagOn( (LCB)->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ))  \
    && (FlagOn((LCB)->Fcb->FcbState,FCB_STATE_PRIMARY_LINK_DELETED ))))

#define SIZEOF_LCB              (FIELD_OFFSET( LCB, FileName ) + sizeof( WCHAR ))

//
//  This structure serves as a Usn record buffer for a file, and also is linked
//  into the list of ModifiedOpenFiles to capture the lowest Modified Usn that has
//  not been through cleanup yet.
//
//  This structure is synchronized by the NtfsLockFcb for the file, however see
//  comments below for Fcb->FcbUsnRecord field.  The ModifiedOpenFiles list is
//  synchronized by NtfsLockFcb on the UsnJournal.
//

typedef struct _FCB_USN_RECORD {

    //
    //  Type and size of this record must be NTFS_NTC_USN
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer back to the Fcb
    //

    struct _FCB *Fcb;

    //
    //  Links for the aged OpenFiles queue.  This is used to generate close records
    //  for files which are idle but have pending changes to report.  Prime example is
    //  mapped page write where MM doesn't dereference the file object for an extended
    //  period of time.  A NULL flink indicates it is not in this queue.
    //

    LIST_ENTRY TimeOutLinks;

    //
    //  Links for the Vcb ModifiedOpenFiles list.
    //

    LIST_ENTRY ModifiedOpenFilesLinks;

    //
    //  The Usn Record buffer.
    //

    USN_RECORD UsnRecord;

} FCB_USN_RECORD;
typedef FCB_USN_RECORD *PFCB_USN_RECORD;


//
//  The Fcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//
//  The structure is really divided into two parts.  FCB can be allocated
//  from paged pool while the SCB must be allocated from non-paged
//  pool.  There is an SCB for every file stream associated with the Fcb.
//
//  Note that the Fcb, multiple Scb records all use the same resource so
//  if we need to grab exclusive access to the Fcb we only need to grab
//  one resource and we've blocked all the scbs
//

typedef struct _FCB {

    //
    //  Type and size of this record must be NTFS_NTC_FCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The internal state of the Fcb.
    //  Sync: Some flags are set on creation and then left.  Safe to test at any time.
    //        Otherwise use Fcb X | Fcb S with Fcb mutex to change.  Critical flags which
    //        reflect state of file (DELETED, etc) will always be changed with Fcb X.
    //

    ULONG FcbState;

    //
    //  The following field contains the file reference for the Fcb
    //

    FILE_REFERENCE FileReference;

    //
    //  A count of the number of file objects that have been opened for
    //  this file, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //  Sync: Vcb X | Vcb S and Fcb X.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this file.
    //  Sync: Use InterlockedIncrement/Decrement to change.  Critical users
    //  have Vcb X | Vcb S and Fcb X.  Other callers will temporarily increment
    //  and decrement this value but they always start at a non-zero value.
    //

    CLONG CloseCount;

    //
    //  A count of other references to this Fcb.
    //  Sync: Use the FcbTable mutex in Vcb.
    //

    CLONG ReferenceCount;

    //
    //  Relevant counts for delete checking.
    //

    ULONG FcbDenyDelete;
    ULONG FcbDeleteFile;

    //
    //  This is the count of the number of times the current transaction
    //  has acquired the main resource.
    //

    USHORT BaseExclusiveCount;

    //
    //  This counts the number of times the Ea's on this file have been
    //  modified.
    //

    USHORT EaModificationCount;

    //
    //  The Queue of all the Lcb that we are part of.  The list is
    //  actually ordered in a small sense.  The get next scb routine that
    //  traverses the Fcb/Scb graph always will put the current lcb edge
    //  that it is traversing into the front of this queue.
    //

    LIST_ENTRY LcbQueue;

    //
    //  A queue of Scb associated with the fcb.  Corresponds to Scb->FcbLinks.
    //  Sync: Must own Fcb X | Fcb S with FcbMutex.
    //

    LIST_ENTRY ScbQueue;

    //
    //  These are the links for the list of exclusively-owned Scbs off of
    //  the IrpContext.  We need to keep track of the exclusive count
    //  in the Fcb before our acquire so we know how many times to release
    //  it.
    //

    LIST_ENTRY ExclusiveFcbLinks;

    //
    //  A pointer to the Vcb containing this Fcb
    //

    PVCB Vcb;

    //
    //  Fast Mutex used to synchronize access to Fcb fields.  This is also used as
    //  the fast mutex for the individual Scb's except for those that may need their
    //  own (Mft, PagingFile, AttributeList).
    //

    PFAST_MUTEX FcbMutex;

    //
    //  The following field is used to store a pointer to the resource
    //  protecting the Fcb
    //

    PERESOURCE Resource;

    //
    //  The following field contains a pointer to the resource
    //  synchronizing a changing FileSize with paging Io.
    //

    PERESOURCE PagingIoResource;

    //
    //  Copy of the duplicated information for this Fcb.
    //  Also a flags field to tell us what has changed in the structure.
    //

    DUPLICATED_INFORMATION Info;
    ULONG InfoFlags;

    //
    //  LinkCount is the number of non deleted links to the file
    //  TotalLinks is the number of total links - including deleted ones
    //

    USHORT LinkCount;
    USHORT TotalLinks;

    //
    //  This is the actual last access for the main stream of this file.
    //  We don't store it in the duplicated information until we are ready
    //  to write it out to disk.  Whenever we update the standard
    //  information we will copy the data out of the this field into the
    //  duplicate information.
    //

    LONGLONG CurrentLastAccess;

    //
    //  The following fields contains a pointer to the security descriptor
    //  for this file.  The field can start off null and later be loaded
    //  in by any of the security support routines.  On delete Fcb the
    //  field pool should be deallocated when the fcb goes away
    //

    struct _SHARED_SECURITY *SharedSecurity;

    //
    //  Pointer to the Quota Control block for the file.
    //

    struct _QUOTA_CONTROL_BLOCK *QuotaControl;

    //
    //  The Lsn to flush to before allowing any data to hit the disk.  Synchronized
    //  by NtfsLockFcb on this file.
    //

    LSN UpdateLsn;

    //
    //  Id for file owner, from bidir security index
    //

    ULONG OwnerId;

    //
    //  This is the count of file objects for this Fcb on the delayed
    //  close queue.  Used to determine whether we need to dereference
    //  a file object we create in the compressed write path.
    //  Synchronize this field with the interlocked routines.
    //

    ULONG DelayedCloseCount;

    //
    //  SecurityId for the file - translates via bidir index to
    //  granted access Acl.
    //

    ULONG SecurityId;

    //
    //  Update sequence number for this file.
    //

    USN Usn;

    //
    //  Pointer to the Usn Record buffer for this Fcb, or NULL if none is
    //  yet allocated.  To test or dereference this field, you must either
    //  have the main file resource at least shared (because NtfsSetRenameInfo
    //  will reallocate this structure.), or else NtfsLockFcb on the file.  To
    //  modify the fields of this record, see comments above.
    //

    PFCB_USN_RECORD FcbUsnRecord;

    //
    //  Pointer to a context pointer to track operations in recursive calls.
    //  Lifespan of this pointer is typically a single request.
    //

    struct _FCB_CONTEXT *FcbContext;

} FCB;
typedef FCB *PFCB;

#define FCB_STATE_FILE_DELETED           (0x00000001)
#define FCB_STATE_NONPAGED               (0x00000002)
#define FCB_STATE_PAGING_FILE            (0x00000004)
#define FCB_STATE_DUP_INITIALIZED        (0x00000008)
#define FCB_STATE_UPDATE_STD_INFO        (0x00000010)
#define FCB_STATE_PRIMARY_LINK_DELETED   (0x00000020)
#define FCB_STATE_IN_FCB_TABLE           (0x00000040)
#define FCB_STATE_SYSTEM_FILE            (0x00000100)
#define FCB_STATE_COMPOUND_DATA          (0x00000200)
#define FCB_STATE_COMPOUND_INDEX         (0x00000400)
#define FCB_STATE_LARGE_STD_INFO         (0x00000800)
#define FCB_STATE_MODIFIED_SECURITY      (0x00001000)
#define FCB_STATE_DIRECTORY_ENCRYPTED    (0x00002000)
#define FCB_STATE_VALID_USN_NAME         (0x00004000)
#define FCB_STATE_USN_JOURNAL            (0x00008000)
#define FCB_STATE_ENCRYPTION_PENDING     (0x00010000)

#define FCB_INFO_CHANGED_CREATE          FILE_NOTIFY_CHANGE_CREATION        //  (0x00000040)
#define FCB_INFO_CHANGED_LAST_MOD        FILE_NOTIFY_CHANGE_LAST_WRITE      //  (0x00000010)
#define FCB_INFO_CHANGED_LAST_CHANGE     (0x80000000)
#define FCB_INFO_CHANGED_LAST_ACCESS     FILE_NOTIFY_CHANGE_LAST_ACCESS     //  (0x00000020)
#define FCB_INFO_CHANGED_ALLOC_SIZE      (0x40000000)
#define FCB_INFO_CHANGED_FILE_SIZE       FILE_NOTIFY_CHANGE_SIZE            //  (0x00000008)
#define FCB_INFO_CHANGED_FILE_ATTR       FILE_NOTIFY_CHANGE_ATTRIBUTES      //  (0x00000004)
#define FCB_INFO_CHANGED_EA_SIZE         FILE_NOTIFY_CHANGE_EA              //  (0x00000080)

#define FCB_INFO_MODIFIED_SECURITY       FILE_NOTIFY_CHANGE_SECURITY        //  (0x00000100)
#define FCB_INFO_UPDATE_LAST_ACCESS      (0x20000000)

//
//  Subset of the Fcb Info flags used to track duplicate info.
//

#define FCB_INFO_DUPLICATE_FLAGS         (FCB_INFO_CHANGED_CREATE      | \
                                          FCB_INFO_CHANGED_LAST_MOD    | \
                                          FCB_INFO_CHANGED_LAST_CHANGE | \
                                          FCB_INFO_CHANGED_LAST_ACCESS | \
                                          FCB_INFO_CHANGED_ALLOC_SIZE  | \
                                          FCB_INFO_CHANGED_FILE_SIZE   | \
                                          FCB_INFO_CHANGED_FILE_ATTR   | \
                                          FCB_INFO_CHANGED_EA_SIZE )

//
//  Subset of the Fcb Info flags used to track notifies.
//

#define FCB_INFO_NOTIFY_FLAGS            (FCB_INFO_CHANGED_CREATE      | \
                                          FCB_INFO_CHANGED_LAST_MOD    | \
                                          FCB_INFO_CHANGED_LAST_ACCESS | \
                                          FCB_INFO_CHANGED_ALLOC_SIZE  | \
                                          FCB_INFO_CHANGED_FILE_SIZE   | \
                                          FCB_INFO_CHANGED_FILE_ATTR   | \
                                          FCB_INFO_CHANGED_EA_SIZE     | \
                                          FCB_INFO_MODIFIED_SECURITY )

//
//  Subset of the Fcb Info flags used to track notifies.  The allocation flag
//  is removed from the full notify flags because dir notify overloads
//  the file size flag for allocation and file size.
//

#define FCB_INFO_VALID_NOTIFY_FLAGS      (FCB_INFO_CHANGED_CREATE      | \
                                          FCB_INFO_CHANGED_LAST_MOD    | \
                                          FCB_INFO_CHANGED_LAST_ACCESS | \
                                          FCB_INFO_CHANGED_FILE_SIZE   | \
                                          FCB_INFO_CHANGED_FILE_ATTR   | \
                                          FCB_INFO_CHANGED_EA_SIZE     | \
                                          FCB_INFO_MODIFIED_SECURITY )

#define FCB_CREATE_SECURITY_COUNT        (5)
#define FCB_LARGE_ACL_SIZE               (512)

//
//  Fcb Context structure.  If a pointer to one of these is in the Fcb then recursive calls will update
//  it as appropriate.
//

typedef struct _FCB_CONTEXT {

    BOOLEAN FcbDeleted;

} FCB_CONTEXT, *PFCB_CONTEXT;


//
//  The following three structures are the separate union structures for
//  Scb structure.
//

typedef enum _RWC_OPERATION {

    SetDirty = 0,
    FullOverwrite,
    StartOfWrite,
    StartOfRead,
    EndOfRead,
    ReadUncompressed,
    ReadZeroes,
    PartialBcb,
    WriteCompressed,
    FaultIntoUncompressed,
    TrimCopyRead,
    ZeroCompressedRead,
    TrimCompressedRead,
    TrimCompressedWrite

} RWC_OPERATION;

#ifdef NTFS_RWC_DEBUG
typedef struct _RWC_HISTORY_ENTRY {

    ULONG Operation;
    ULONG Information;
    ULONG FileOffset;
    ULONG Length;

} RWC_HISTORY_ENTRY, *PRWC_HISTORY_ENTRY;

#define MAX_RWC_HISTORY_INDEX       (300)
#endif

typedef struct _SCB_DATA {

    //
    //  Total number of reserved bytes
    //

    LONGLONG TotalReserved;

    //
    //  Mask to remember which compression units were written
    //  in a stream.
    //

#ifdef SYSCACHE
    PULONG WriteMask;
    ULONG WriteSequence;
    LIST_ENTRY SyscacheEventList;
#endif

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //

    PFILE_LOCK FileLock;

    //
    //  List of wait for length blocks, for threads waiting for the
    //  file to exceed the specified length.
    //

    LIST_ENTRY WaitForNewLength;

    //
    //  List of compression synchronization objects.
    //

    LIST_ENTRY CompressionSyncList;

    //
    //  Pointer to an Mcb describing the reserved space for
    //  dirty compression units in compressed files which do
    //  not currently have a user section.
    //

    PRESERVED_BITMAP_RANGE ReservedBitMap;

#ifdef NTFS_RWC_DEBUG

    ULONG RwcIndex;
    PRWC_HISTORY_ENTRY HistoryBuffer;
#endif

} SCB_DATA, *PSCB_DATA;

typedef struct _SCB_INDEX {

    //
    //  This is a list of records within the index allocation stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  Record allocation context, for managing the allocation of the
    //  INDEX_ALLOCATION_ATTRIBUTE, if one exists.
    //

    RECORD_ALLOCATION_CONTEXT RecordAllocationContext;

    //
    //  A queue of all the lcbs that are opened under this Scb.
    //  Corresponds to Lcb->ScbLinks
    //

    LIST_ENTRY LcbQueue;

    //
    //  The following are the splay links of Lcbs opened under this
    //  Scb.  Note that not all of the Lcb in the list above may
    //  be in the splay links below.
    //

    PRTL_SPLAY_LINKS ExactCaseNode;
    PRTL_SPLAY_LINKS IgnoreCaseNode;

    //
    //  Normalized name.  This is the path from the root to this directory
    //  without any of the short-name-only links.  The hash value is based
    //  on this NormalizedName.
    //
    //  The normalized name can be in an indeterminant state.  If the length is zero
    //  then the name is invalid (there should be no hash value at that point).  However
    //  the MaximumLength and Buffer could still be present.  A non-NULL buffer indicates
    //  that there is cleanup that needs to be done.  Anybody changing this field should
    //  hold the hash mutex, this means swapping the buffers or changing the length field.
    //  Anyone changing the name on the file should hold the main resource exclusive of
    //  course.
    //

    UNICODE_STRING NormalizedName;

#ifdef BENL_DBG
    UNICODE_STRING NormalizedRelativeName;
    ULONG FullNormalizedPathLength;
#endif

    ULONG HashValue;

    //
    //  A change count incremented every time an index buffer is deleted.
    //

    ULONG ChangeCount;

    //
    //  Define a union to distinguish directory indices from view indices
    //

    union {

        //
        //  For directories we store the following.
        //

        struct {

            //
            //  Type of attribute being indexed.
            //

            union {
                ATTRIBUTE_TYPE_CODE AttributeBeingIndexed;
                PVOID Alignment;
            };

            //
            //  Collation rule, for how the indexed attribute is collated.
            //

            ULONG_PTR CollationRule;
        };

        //
        //  For view indexes we store the CollationFunction and data.
        //

        struct {

            PCOLLATION_FUNCTION CollationFunction;
            PVOID CollationData;
        };
    };

    //
    //  Size of Index Allocation Buffer in bytes, or 0 if not yet
    //  initialized.
    //

    ULONG BytesPerIndexBuffer;

    //
    //  Size of Index Allocation Buffers in units of blocks, or 0
    //  if not yet initialized.
    //

    UCHAR BlocksPerIndexBuffer;

    //
    //  Shift value when converting from index blocks to bytes.
    //

    UCHAR IndexBlockByteShift;

    //
    //  Flag to indicate whether the RecordAllocationContext has been
    //  initialized or not.  If it is not initialized, this means
    //  either that there is no external index allocation, or that
    //  it simply has not been initialized yet.
    //

    BOOLEAN AllocationInitialized;

    UCHAR PadUchar;

    //
    //  Index Depth Hint
    //

    USHORT IndexDepthHint;

    USHORT PadUshort;

} SCB_INDEX, *PSCB_INDEX;

typedef struct _SCB_MFT {

    //
    //  NOTE - The following fields must be in the same positions in the Index and Mft
    //  specific extensions.
    //
    //      RecentlyDeallocatedQueue
    //      RecordAllocationContext
    //

    //
    //  This is a list of records within the Mft Scb stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  Record allocation context, for managing the allocation of the
    //  INDEX_ALLOCATION_ATTRIBUTE, if one exists.
    //

    RECORD_ALLOCATION_CONTEXT RecordAllocationContext;

    //
    //  The following Mcb's are used to track clusters being added and
    //  removed from the Mcb for the Scb.  This Scb must always be fully
    //  loaded after an abort.  We can't depend on reloading on the next
    //  LookupAllocation call.  Instead we keep one Mcb with the clusters
    //  added and one Mcb with the clusters removed.  During the restore
    //  phase of abort we will adjust the Mft Mcb by reversing the
    //  operations done during the transactions.
    //

    LARGE_MCB AddedClusters;
    LARGE_MCB RemovedClusters;

    //
    //  The following are the changes made to the Mft file as file records
    //  are added, freed or allocated.  Also the change in the number of
    //  file records which are part of holes.
    //

    LONG FreeRecordChange;
    LONG HoleRecordChange;

    //
    //  The following field contains the index of a reserved free record.  To
    //  keep us out of the chicken & egg problem of the Mft being able to
    //  be self mapping we added the ability to reserve an mft record
    //  to describe additional mft data allocation within previous mft
    //  run.  A value of zero means that index has not been reserved.
    //

    ULONG ReservedIndex;

    ULONG PadUlong;

} SCB_MFT, *PSCB_MFT;

//
//  The following is the non-paged part of the scb.
//

typedef struct _SCB_NONPAGED {

    //
    //  Type and size of this record must be NTFS_NTC_SCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Index allocated for this file in the Open Attribute Table.
    //

    ULONG OpenAttributeTableIndex;
    ULONG OnDiskOatIndex;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to
    //  point to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  Copy of the Vcb pointer so we can find the Vcb in the dirty page
    //  callback routine.
    //

    PVCB Vcb;
#ifdef  COMPRESS_ON_WIRE
    SECTION_OBJECT_POINTERS SegmentObjectC;
#endif

} SCB_NONPAGED, *PSCB_NONPAGED;


//
//  The following are structures used only in syscache debugging privates
//


#define SCE_VDL_CHANGE          0
#define SCE_ZERO_NC             1
#define SCE_ZERO_C              2
#define SCE_READ                3
#define SCE_WRITE               4
#define SCE_ZERO_CAV            5
#define SCE_ZERO_MF             6
#define SCE_ZERO_FST            7
#define SCE_CC_FLUSH            8
#define SCE_CC_FLUSH_AND_PURGE  9
#define SCE_WRITE_FILE_SIZES   10
#define SCE_ADD_ALLOCATION     11
#define SCE_ADD_SP_ALLOCATION  12
#define SCE_SETCOMP_ADD_ALLOCATION     13
#define SCE_SETSPARSE_ADD_ALLOCATION   14
#define SCE_MOD_ATTR_ADD_ALLOCATION    15
#define SCE_REALLOC1                   16
#define SCE_REALLOC2                   17
#define SCE_REALLOC3                   18
#define SCE_SETCOMPRESS                19
#define SCE_SETSPARSE                  20
#define SCE_ZERO_STREAM                21
#define SCE_VDD_CHANGE                 22
#define SCE_CC_SET_SIZE                23
#define SCE_ZERO_TAIL_COMPRESSED       24
#define SCE_ZERO_HEAD_COMPRESSED       25
#define SCE_TRIM_WRITE                 26
#define SCE_DISK_FULL                  27
#define SCE_SKIP_PURGE                 28

#define SCE_MAX_EVENT           29


#define SCE_FLAG_WRITE 0x1
#define SCE_FLAG_READ  0x2
#define SCE_FLAG_PAGING 0x4
#define SCE_FLAG_ASYNC  0x8
#define SCE_FLAG_SET_ALLOC 0x10
#define SCE_FLAG_SET_EOF   0x20
#define SCE_FLAG_CANT_WAIT 0x40
#define SCE_FLAG_SYNC_PAGING 0x80
#define SCE_FLAG_LAZY_WRITE 0x100
#define SCE_FLAG_CACHED 0x200
#define SCE_FLAG_ON_DISK_READ 0x400
#define SCE_FLAG_RECURSIVE  0x800
#define SCE_FLAG_NON_CACHED  0x1000
#define SCE_FLAG_UPDATE_FROM_DISK  0x2000
#define SCE_FLAG_SET_VDL 0x4000
#define SCE_FLAG_COMPLETION 0x8000
#define SCE_FLAG_COMPRESSED 0x10000
#define SCE_FLAG_FASTIO 0x20000
#define SCE_FLAG_ZERO 0x40000

#define SCE_MAX_FLAG   0x80000

#define NUM_SC_EVENTS 600
#define NUM_SC_LOGSETS 14

typedef struct _SYSCACHE_LOG {
    int            Event;
    int            Flags;
    LONGLONG       Start;
    LONGLONG       Range;
    LONGLONG       Result;
//    ULONG          ulDump;
} SYSCACHE_LOG, *PSYSCACHE_LOG;

typedef struct _ON_DISK_SYSCACHE_LOG {
    ULONG  SegmentNumberUnsafe;
    SYSCACHE_LOG;
} ON_DISK_SYSCACHE_LOG, *PON_DISK_SYSCACHE_LOG;

typedef struct _SYSCACHE_LOG_SET {
    PSCB            Scb;
    PSYSCACHE_LOG   SyscacheLog;
    ULONG           SegmentNumberUnsafe;
} SYSCACHE_LOG_SET, PSYSCACHE_LOG_SET;


#ifdef SYSCACHE_DEBUG

//
//  Global set of syscache logs
//

SYSCACHE_LOG_SET NtfsSyscacheLogSet[NUM_SC_LOGSETS];
LONG             NtfsCurrentSyscacheLogSet;
LONG             NtfsCurrentSyscacheOnDiskEntry;

#endif


//
//  The following structure is the stream control block.  There can
//  be multiple records per fcb.  One is created for each attribute being
//  handled as a stream file.
//

typedef struct _SCB {

    //
    //  The following field is used for fast I/O.  It contains the node
    //  type code and size, indicates if fast I/O is possible, contains
    //  allocation, file, and valid data size, a resource, and call back
    //  pointers for FastIoRead and FastMdlRead.
    //
    //  The node type codes for the Scb must be either NTFS_NTC_SCB_INDEX,
    //  NTFS_NTC_SCB_ROOT_INDEX, or NTFS_NTC_SCB_DATA.  Which one it is
    //  determines the state of the union below.
    //

    NTFS_ADVANCED_FCB_HEADER Header;

    //
    //  The links for the queue of Scb off of a given Fcb.  And a pointer
    //  back to the Fcb.  Corresponds to Fcb->ScbQueue
    //

    LIST_ENTRY FcbLinks;
    PFCB Fcb;

    //
    //  A pointer to the Vcb containing this Scb
    //

    PVCB Vcb;

    //
    //  The internal state of the Scb.
    //

    ULONG ScbState;

    //
    //  A count of the number of file objects opened on this stream
    //  which represent user non-cached handles.  We use this count to
    //  determine when to flush and purge the data section in only
    //  non-cached handles remain on the file.
    //

    CLONG NonCachedCleanupCount;

    //
    //  A count of the number of file objects that have been opened for
    //  this attribute, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this attribute.
    //

    CLONG CloseCount;

    //
    //  Share Access structure for this stream.
    //

    SHARE_ACCESS ShareAccess;

    //
    //  The following two fields identify the actual attribute for this
    //  Scb with respect to its file.   We identify the attribute by
    //  its type code and name.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;

    //
    //  Stream File Object for internal use.  This field is NULL if the
    //  file stream is not being accessed internally.
    //

    PFILE_OBJECT FileObject;

    //
    //  These pointers are used to detect writes that eminated from the
    //  cache manager's worker thread.  It prevents lazy writer threads,
    //  who already have the Fcb shared, from trying to acquire it
    //  exclusive, and thus causing a deadlock.  We have to store two
    //  threads, because the second thread could be writing the compressed
    //  stream
    //

    PVOID LazyWriteThread[2];

    //
    //  Pointer to the non-paged section objects and open attribute
    //  table index.
    //

    PSCB_NONPAGED NonpagedScb;

    //
    //  The following field contains the mcb for this Scb and some initial
    //  structures for small and medium files.
    //

    NTFS_MCB Mcb;
    NTFS_MCB_INITIAL_STRUCTS McbStructs;

    //
    //  Compression unit from attribute record.
    //

    ULONG CompressionUnit;

    //
    //  AttributeFlags and CompressionUnitShift from attribute record
    //

    USHORT AttributeFlags;
    UCHAR CompressionUnitShift;
    UCHAR PadUchar;

    //
    //  Valid Data to disk - as updated by NtfsPrepareBuffers
    //

    LONGLONG ValidDataToDisk;

    //
    //  Actual allocated bytes for this file.
    //

    LONGLONG TotalAllocated;

    //
    //  Used by advanced Scb Header
    //

    LIST_ENTRY EofListHead;

    //
    //  Link of all Ccb's that were created for this Scb
    //

    LIST_ENTRY CcbQueue;

    //
    //  Pointer to structure containing snapshotted Scb values, or NULL
    //  if the values have not been snapshotted.
    //

    struct _SCB_SNAPSHOT * ScbSnapshot;

    //
    //  Pointer to encryption context and length.
    //

    PVOID EncryptionContext;
    ULONG EncryptionContextLength;

    //
    //  Persistent Scb flags.  These are set and cleared synchronized with
    //  the main resource and tend to remain in the same state.
    //

    ULONG ScbPersist;

#if (DBG || defined( NTFS_FREE_ASSERTS ))

    //
    //  Keep the thread ID of the thread owning IO at EOF.
    //

    PERESOURCE_THREAD IoAtEofThread;
#endif

#ifdef  SYSCACHE_DEBUG

    int            SyscacheLogEntryCount;
    LONG           CurrentSyscacheLogEntry;
    SYSCACHE_LOG * SyscacheLog;
    LONG           LogSetNumber;

#endif

    //
    //  Scb Type union, for different types of Scbs
    //

    union {

        SCB_DATA Data;
        SCB_INDEX Index;
        SCB_MFT Mft;

    } ScbType;

} SCB;
typedef SCB *PSCB;

#define SIZEOF_SCB_DATA \
    (FIELD_OFFSET(SCB,ScbType)+sizeof(SCB_DATA))

#define SIZEOF_SCB_INDEX      \
    (FIELD_OFFSET(SCB,ScbType)+sizeof(SCB_INDEX))

#define SIZEOF_SCB_MFT        \
    (FIELD_OFFSET(SCB,ScbType)+sizeof(SCB_MFT))

//
//  The following flags are bits in the ScbState field.
//

#define SCB_STATE_TRUNCATE_ON_CLOSE         (0x00000001)
#define SCB_STATE_DELETE_ON_CLOSE           (0x00000002)
#define SCB_STATE_CHECK_ATTRIBUTE_SIZE      (0x00000004)
#define SCB_STATE_ATTRIBUTE_RESIDENT        (0x00000008)
#define SCB_STATE_UNNAMED_DATA              (0x00000010)
#define SCB_STATE_HEADER_INITIALIZED        (0x00000020)
#define SCB_STATE_NONPAGED                  (0x00000040)
#define SCB_STATE_USA_PRESENT               (0x00000080)
#define SCB_STATE_ATTRIBUTE_DELETED         (0x00000100)
#define SCB_STATE_FILE_SIZE_LOADED          (0x00000200)
#define SCB_STATE_MODIFIED_NO_WRITE         (0x00000400)
#define SCB_STATE_SUBJECT_TO_QUOTA          (0x00000800)
#define SCB_STATE_UNINITIALIZE_ON_RESTORE   (0x00001000)
#define SCB_STATE_RESTORE_UNDERWAY          (0x00002000)
#define SCB_STATE_NOTIFY_ADD_STREAM         (0x00004000)
#define SCB_STATE_NOTIFY_REMOVE_STREAM      (0x00008000)
#define SCB_STATE_NOTIFY_RESIZE_STREAM      (0x00010000)
#define SCB_STATE_NOTIFY_MODIFY_STREAM      (0x00020000)
#define SCB_STATE_TEMPORARY                 (0x00040000)
#define SCB_STATE_WRITE_COMPRESSED          (0x00080000)
#define SCB_STATE_REALLOCATE_ON_WRITE       (0x00100000)
#define SCB_STATE_DELAY_CLOSE               (0x00200000)
#define SCB_STATE_WRITE_ACCESS_SEEN         (0x00400000)
#define SCB_STATE_CONVERT_UNDERWAY          (0x00800000)
#define SCB_STATE_VIEW_INDEX                (0x01000000)
#define SCB_STATE_DELETE_COLLATION_DATA     (0x02000000)
#define SCB_STATE_VOLUME_DISMOUNTED         (0x04000000)
#define SCB_STATE_PROTECT_SPARSE_MCB        (0x08000000)
#define SCB_STATE_MULTIPLE_OPENS            (0x10000000)
#define SCB_STATE_COMPRESSION_CHANGE        (0x20000000)
#define SCB_STATE_WRITE_FILESIZE_ON_CLOSE   (0x40000000)

//
//  The following flags are bits in the ScbPersist field.
//

#define SCB_PERSIST_USN_JOURNAL             (0x00000001)
#define SCB_PERSIST_DENY_DEFRAG             (0x00000002)

#ifdef SYSCACHE_DEBUG
#define SCB_PERSIST_SYSCACHE_DIR            (0x80000000)
#endif

#ifdef SYSCACHE

//
//  Note: this flag's value is now superseded by SCB_STATE_WRITE_FILESIZE_ON_CLOSE
//  code must be modified if this is to be used again
//

#define SCB_STATE_SYSCACHE_FILE             (0x80000000)

#define SYSCACHE_SET_FILE_SIZE              (0x00000001)
#define SYSCACHE_SET_ALLOCATION_SIZE        (0x00000002)
#define SYSCACHE_PAGING_WRITE               (0x00000003)
#define SYSCACHE_NORMAL_WRITE               (0x00000004)

//
//  Syscache event list element.
//

typedef struct _SYSCACHE_EVENT {

    //
    //  Corresponds to scb_data's SyscacheEventList
    //

    LIST_ENTRY EventList;

    //
    //  Choose from SYSCACHE_PAGING_WRITE, etc.
    //

    ULONG EventTypeCode;

    ULONG Pad;

    //
    //  Write start & size, or truncate point & junk, etc.  Unionize?
    //

    LONGLONG Data1;
    LONGLONG Data2;

} SYSCACHE_EVENT;

typedef SYSCACHE_EVENT *PSYSCACHE_EVENT;
#endif

//
//  Determine whether an attribute type code can be compressed.  The current
//  implementation of Ntfs does not allow logged streams to be compressed.
//

#define NtfsIsTypeCodeCompressible(C)   ((C) == $DATA)

//
//  Determine whether an attribute type code can be encrypted.  The current
//  implementation of Ntfs does not allow logged streams to be encrypted.
//

#define NtfsIsTypeCodeEncryptible(C)    ((C) == $DATA)

//
//  Detect whether an attribute contains user data
//

#define NtfsIsTypeCodeUserData(C)       ((C) == $DATA)


//
//  Detect whether an attribute should be subject to quota enforcement
//

#define NtfsIsTypeCodeSubjectToQuota(C) NtfsIsTypeCodeUserData(C)

//
//  Detect whether an attribute is a logged utility stream
//

#define NtfsIsTypeCodeLoggedUtilityStream(C)   ((C) == $LOGGED_UTILITY_STREAM)

//
//  Define FileObjectFlags flags that should be propagated to stream files
//  so that the Cache Manager will see them.
//

#define NTFS_FO_PROPAGATE_TO_STREAM         (FO_SEQUENTIAL_ONLY | FO_TEMPORARY_FILE)


//
//  Structure to contain snapshotted Scb values for error recovery.
//

typedef struct _SCB_SNAPSHOT {

    //
    //  Links for list snapshot structures off of IrpContext
    //

    LIST_ENTRY SnapshotLinks;

    //
    //  Saved values of the corresponding Scb (or FsRtl Header) fields
    //  The low bit of allocation size is set to remember when the
    //  attribute was resident.  The next bit, bit 1, is set to remember
    //  when the attribute was compressed.
    //

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;
    LONGLONG ValidDataToDisk;
    LONGLONG TotalAllocated;

    VCN LowestModifiedVcn;
    VCN HighestModifiedVcn;

    //
    //  Pointer to the Scb which has been snapped.
    //

    PSCB Scb;

    //
    // Used to hold the Scb State.
    //

    ULONG ScbState;

    //
    //  IrpContext that owns the snapshot and can use it to rollback the values
    //

    PIRP_CONTEXT OwnerIrpContext;

} SCB_SNAPSHOT;
typedef SCB_SNAPSHOT *PSCB_SNAPSHOT;


//
//  The Ccb record is allocated for every file object.  This is the full
//  CCB including the index-specific fields.
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be NTFS_NTC_CCB_DATA or
    //  NTFS_NTC_CCB_INDEX)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Ccb flags.
    //

    ULONG Flags;

    //
    //  This is a unicode string for the full filename used to
    //  open this file.
    //  We use InterlockedExchange of pointers to synchronize this
    //  field between NtfsFsdClose and NtfsUpdateFileDupInfo.
    //

    UNICODE_STRING FullFileName;
    USHORT LastFileNameOffset;

    //
    //  This is the Ccb Ea modification count.  If this count is in
    //  sync with the Fcb value, then the above offset is valid.
    //

    USHORT EaModificationCount;

    //
    //  This is the offset of the next Ea to return to the user.
    //

    ULONG NextEaOffset;

    //
    //  The links for the queue of Ccb off of a given Lcb and a pointer
    //  back to the Lcb.  Corresponds to Lcb->CcbQueue
    //

    LIST_ENTRY LcbLinks;
    PLCB Lcb;

    //
    //  The links for the queue of Ccb's off a given Scb.  Corresponds to
    //  Scb->CcbQueue
    //

    LIST_ENTRY CcbLinks;

    //
    //  Type of Open for this Ccb
    //

    UCHAR TypeOfOpen;
    UCHAR Reserved;

    //
    //  Count of the number of times this handle has extended the stream through
    //  writes.
    //

    USHORT WriteExtendCount;

    //
    //  Keeps the owner id of the opener.  Used by quota to determine the
    //  amount of free space.
    //

    ULONG OwnerId;

    //
    //  Last returned owner id.  Used by QueryQuotaInformationFile.
    //

    ULONG LastOwnerId;

    //
    //  Usn source information for this handle.
    //

    ULONG UsnSourceInfo;

    //
    //  Flags specifying the type of access granted for this handle.
    //  The flags, such as BACKUP_ACCESS, are defined in ntfsexp.h.
    //

    USHORT AccessFlags;

    USHORT Alignment;

#ifdef CCB_FILE_OBJECT
    PFILE_OBJECT FileObject;
    PEPROCESS Process;
#endif

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    //  READ BELOW BEFORE CHANGING THIS STRUCTURE                           //
    //                                                                      //
    //  All of the enumeration fields must be after this point.  Otherwise  //
    //  we will waste space in the CCB_DATA defined below.                  //
    //                                                                      //
    //  Also - The first defined field past this point must be used in      //
    //  defining the CCB_DATA structure below.                              //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    //
    //  Pointer to the index context structure for enumerations.
    //

    struct _INDEX_CONTEXT *IndexContext;

    //
    //  The query template is used to filter directory query requests.
    //  It originally is set to null and on the first call the
    //  NtQueryDirectory it is set the the input filename or "*" if no
    //  name is supplied.  All subsquent queries then use this template.
    //

    ULONG QueryLength;
    PVOID QueryBuffer;

    //
    //  The last returned value.  A copy of an IndexEntry is saved.  We
    //  only grow this buffer, to avoid always deallocating and
    //  reallocating.
    //

    ULONG IndexEntryLength;
    PINDEX_ENTRY IndexEntry;

    //
    //  File reference for file record we need to read for another name,
    //  and for which Fcb should be found and acquired when restarting
    //  an enumeration.
    //

    union {

        LONGLONG LongValue;

        FILE_REFERENCE FileReference;

    } FcbToAcquire;

    //
    //  File reference for next file reference to consider when doing a
    //  Mft scan looking for the next file owned by a specified Sid
    //

    FILE_REFERENCE MftScanFileReference;

    //
    //  Lists of waiters on this Ccb.  A NULL value indicates no waiters.
    //

    LIST_ENTRY EnumQueue;

} CCB;
typedef CCB *PCCB;

//
//  The size of the CCB_DATA is the quadaligned size of the common
//  header.
//
//  NOTE - This define assumes the first field of the index portion is the
//  IndexContext field.
//

typedef struct _CCB_DATA {

    LONGLONG Opaque[ (FIELD_OFFSET( CCB, IndexContext ) + 7) / 8 ];

} CCB_DATA;
typedef CCB_DATA *PCCB_DATA;

#define CCB_FLAG_IGNORE_CASE                (0x00000001)
#define CCB_FLAG_OPEN_AS_FILE               (0x00000002)
#define CCB_FLAG_WILDCARD_IN_EXPRESSION     (0x00000004)
#define CCB_FLAG_OPEN_BY_FILE_ID            (0x00000008)

#define CCB_FLAG_USER_SET_LAST_MOD_TIME     (0x00000010)
#define CCB_FLAG_USER_SET_LAST_CHANGE_TIME  (0x00000020)
#define CCB_FLAG_USER_SET_LAST_ACCESS_TIME  (0x00000040)
#define CCB_FLAG_TRAVERSE_CHECK             (0x00000080)

#define CCB_FLAG_RETURN_DOT                 (0x00000100)
#define CCB_FLAG_RETURN_DOTDOT              (0x00000200)
#define CCB_FLAG_DOT_RETURNED               (0x00000400)
#define CCB_FLAG_DOTDOT_RETURNED            (0x00000800)

#define CCB_FLAG_DELETE_FILE                (0x00001000)
#define CCB_FLAG_DENY_DELETE                (0x00002000)
#define CCB_FLAG_ALLOCATED_FILE_NAME        (0x00004000)
#define CCB_FLAG_CLEANUP                    (0x00008000)

#define CCB_FLAG_SYSTEM_HIVE                (0x00010000)
#define CCB_FLAG_PARENT_HAS_DOS_COMPONENT   (0x00020000)
#define CCB_FLAG_DELETE_ON_CLOSE            (0x00040000)
#define CCB_FLAG_CLOSE                      (0x00080000)

#define CCB_FLAG_UPDATE_LAST_MODIFY         (0x00100000)
#define CCB_FLAG_UPDATE_LAST_CHANGE         (0x00200000)
#define CCB_FLAG_SET_ARCHIVE                (0x00400000)
#define CCB_FLAG_DIR_NOTIFY                 (0x00800000)

#define CCB_FLAG_ALLOW_XTENDED_DASD_IO      (0x01000000)
#define CCB_FLAG_READ_CONTEXT_ALLOCATED     (0x02000000)
#define CCB_FLAG_DELETE_ACCESS              (0x04000000)
#define CCB_FLAG_DENY_DEFRAG                (0x08000000)

//
//  Reusing a bit from the file name index enumeration path for the view index path
//
#define CCB_FLAG_LAST_INDEX_ROW_RETURNED    (0x00000800)


//
//  We will attempt to allocate the following out of a single pool block
//  on a per file basis.
//
//      FCB, LCB, SCB, CCB, FILE_NAME
//
//  The following compound Fcb's will be allocated and then the individual
//  components can be allocated out of them.  The FCB will never be allocated
//  individually but it is possible that the embedded structures may be.
//  A zero in the node type field means these are available.  These sizes are
//  selected to fill the Fcb out to a pool block boundary (0x20) bytes.
//  Note that we leave room for both the exact and ignore case names.
//

#define MAX_DATA_FILE_NAME                  (17)
#define MAX_INDEX_FILE_NAME                 (17)

typedef struct _FCB_DATA {

    FCB Fcb;
    UCHAR Scb[SIZEOF_SCB_DATA];
    CCB_DATA Ccb;
    UCHAR Lcb[SIZEOF_LCB];
    WCHAR FileName[(2*MAX_DATA_FILE_NAME) - 1];

} FCB_DATA;
typedef FCB_DATA *PFCB_DATA;

typedef struct _FCB_INDEX {

    FCB Fcb;
    UCHAR Scb[SIZEOF_SCB_INDEX];
    CCB Ccb;
    UCHAR Lcb[SIZEOF_LCB];
    WCHAR FileName[(2*MAX_INDEX_FILE_NAME) - 1];

} FCB_INDEX;
typedef FCB_INDEX *PFCB_INDEX;


typedef VOID
(*POST_SPECIAL_CALLOUT) (
    IN struct _IRP_CONTEXT *IrpContext,
    IN OUT PVOID Context
    );

//
//  The IrpContext contains a cache of file records mapped within the current
//  call.  These are used to reduce the number of maps that take place
//

typedef struct _IRP_FILE_RECORD_CACHE_ENTRY {
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PBCB FileRecordBcb;
    ULONG UnsafeSegmentNumber;
} IRP_FILE_RECORD_CACHE_ENTRY, *PIRP_FILE_RECORD_CACHE_ENTRY;

#define IRP_FILE_RECORD_MAP_CACHE_SIZE  4

//
//  Chained Usn Fcbs.  The IrpContext has a built-in UsnFcb but some requests require more than
//  one.  In that case we will allocate and chain these together.
//
//  The flags field has the following flags
//
//      USN_FCB_FLAG_NEW_REASON - Indicates that we have something to report via
//          WriteUsnJournalChanges.  We need something to indicate whether we have any
//          new reasons since we don't clear out the NewReasons field when writing the
//          USN record so the presence of the reasons isn't enough.
//

typedef struct _USN_FCB {

    struct _USN_FCB *NextUsnFcb;
    PFCB CurrentUsnFcb;
    ULONG NewReasons;
    ULONG RemovedSourceInfo;
    ULONG UsnFcbFlags;

} USN_FCB, *PUSN_FCB;

#define USN_FCB_FLAG_NEW_REASON         (0x00000001)

//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the
//  NtfsComplete request routine.
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be NTFS_NTC_IRP_CONTEXT)
    //
    //  Assumption here is that this structure is allocated from pool so
    //  base of structure is on an odd 64-bit boundary.
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  State of the operation.  These flags describe the current state of a request and
    //  are reset on either retry or post.
    //

    ULONG Flags;

    //
    //  State of the IrpContext.  These are persistent through the life of a request and
    //  are explicitly set and cleared.
    //

    ULONG State;

    //
    //  The following field contains the NTSTATUS value used when we are
    //  unwinding due to an exception.  We will temporarily store the Ccb
    //  for a delayed or deferred close here while the request is queued.
    //

    NTSTATUS ExceptionStatus;

    //
    //  Transaction Id for this request, which must be qualified by Vcb.
    //  We will store the type of open for a delayed or async close here
    //  while the request is queued.
    //

    TRANSACTION_ID TransactionId;

    //
    //  Major and minor function codes copied from the Irp
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Length of Scb array for transactions below.  Zero indicates unused.  One indicates
    //  to treat it as a pointer to an Scb.  Greater than one indicates it is an allocated
    //  pool block with an array of Scb's.
    //

    USHORT SharedScbSize;

    //
    //  Pointer to Scb acquired shared for transaction or pointer to array of Scb's acquired
    //  shared for transaction.  Use the SharedScbSize field above to determine
    //  meaning of this pointer.
    //

    PVOID SharedScb;

    //
    //  This is a pointer to a structure which requires further cleanup when we cleanup the
    //  IrpContext.  Currently it can be either an Fcb or Scb.
    //
    //      Fcb - We need to release the paging Io resource for this.
    //      Scb - We need to clear the IOAtEof flag.
    //

    PVOID CleanupStructure;

    //
    //  Vcb for the operation this IrpContext is processing.
    //

    PVCB Vcb;

    //
    //  A pointer to the originating Irp.  We will store the Scb for
    //  delayed or async closes here while the request is queued.
    //

    PIRP OriginatingIrp;

    //
    //  This is the IrpContext for the top level request.
    //

    struct _IRP_CONTEXT *TopLevelIrpContext;

    //
    //  A context value needs to be preserved throughout an encyrpted file create.
    //  Given the importance of making creates fast, adding one more pointer to
    //  this struct is better than making create push another parameter to its
    //  various local routines like NtfsOpenExistingPrefixFcb.  This field and
    //  the next are only used during create operations are can potentially be
    //  unionized with some other field(s).
    //

    PVOID EfsCreateContext;

    //
    //  This is a list of exclusively-owned Scbs which may only be
    //  released after the transaction is committed.
    //

    LIST_ENTRY ExclusiveFcbList;

    //
    //  The following field is used to maintain a queue of records that
    //  have been deallocated while processing this irp context.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  The following is the number of clusters deallocated in the current
    //  request.  We want to ignore them when figuring if a request for
    //  clusters (NtfsAllocateClusters) should free the clusters in the
    //  recently deallocated queue.
    //

    LONGLONG DeallocatedClusters;

    //
    //  This is the Last Restart Area Lsn captured from the Vcb at
    //  the time log file full was raised.  The caller will force
    //  a checkpoint if this has not changed by the time he gets
    //  the global resource exclusive.
    //

    LSN LastRestartArea;

    //
    //  This is the change in the free clusters on the volume during the
    //  transaction for this IrpContext.  If we abort the current request
    //  we will subtract these from the current count of free clusters
    //  in the Vcb.  This is signed because we may be allocating or
    //  deallocating the clusters.
    //

    LONGLONG FreeClusterChange;

    //
    //  The following union contains pointers to the IoContext for I/O
    //  based requests and a pointer to a security context for requests
    //  which need to capture the subject context in the calling thread.
    //

    union {

        //
        //  The following context block is used for non-cached Io.
        //

        struct _NTFS_IO_CONTEXT *NtfsIoContext;

        //
        //  The following field is used for cached compressed reads/writes
        //

        PFSRTL_AUXILIARY_BUFFER AuxiliaryBuffer;

        //
        //  The following is the captured subject context.
        //

        PSECURITY_SUBJECT_CONTEXT SubjectContext;

        //
        //  The following is used during create for oplock cleanup.
        //

        struct _OPLOCK_CLEANUP *OplockCleanup;

        //
        //  The following is used by NtfsPostSpecial to pass the
        //  function to be called.
        //

        POST_SPECIAL_CALLOUT PostSpecialCallout;

        //
        //  The following is used by NtfsReadFileRecordUsnData for cleanup
        //

        PMDL MdlToCleanup;

    } Union;

    //
    //  Collect all of the streams which have been extended which may have waiters
    //  on the new length.
    //

    PVOID CheckNewLength;

    //
    //  The Fcb for which some new Usn reasons must be journalled, and the reasons.
    //

    USN_FCB Usn;
    ULONG SourceInfo;

    //
    //  This structure contains the first ScbSnapshot for a modifying
    //  request which acquires files exclusive and snaps Scb values.
    //  If the SnapshotLinks field contains NULLs, then no data has
    //  been snapshot for this request, and the list is empty.  If
    //  the links are not NULL, then this snapshot structure is in
    //  use.  If the SnapshotLinks are not NULL, and do not represent
    //  an empty list, then there are addtional dynamically allocated
    //  snapshot structures in this list.
    //

    SCB_SNAPSHOT ScbSnapshot;

    //
    //  A combination of FILE_NEW, etc. to be passed to the encryption callout and
    //  to assist in cleaning up after creates that fail in the PostCreate callout.
    //

    ULONG EncryptionFileDirFlags;

    //
    //  Some calls require reading the base file record for the specified file
    //  multiple times.  We cache the pointer to the base file record and the
    //  BCB for that file record.
    //

    ULONG CacheCount;
    IRP_FILE_RECORD_CACHE_ENTRY FileRecordCache[IRP_FILE_RECORD_MAP_CACHE_SIZE];

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

#ifdef NTFS_LOG_FULL_TEST
    //
    //  Debugging field for breadth-first verification of log-file-full.  When the
    //  NextFailCount is non-zero, we decrement the CurrentFailCount.  When
    //  CurrentFailCount goes to zero, we increment NextFailCount, set
    //  CurrentFailCount to NextFailCount and raise STATUS_LOG_FILE_FULL.
    //

    ULONG CurrentFailCount;
    ULONG NextFailCount;
#endif

#ifdef MAPCOUNT_DBG
    ULONG MapCount;
#endif

#ifdef NTFSDBG
    ULONG FilesOwnedCount;
    NTFS_OWNERSHIP_STATE OwnershipState;
#endif

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

//
//  The following are the Irp Context flags.  They will be cleared
//  on either retry or post.  If we start to run out of bits then we
//  can combine some of these because they are only tested locally and
//  have the same behavior on retry or post.
//

#define IRP_CONTEXT_FLAG_LARGE_ALLOCATION   (0x00000001)
#define IRP_CONTEXT_FLAG_WRITE_SEEN         (0x00000002)
#define IRP_CONTEXT_FLAG_CREATE_MOD_SCB     (0x00000004)
#define IRP_CONTEXT_FLAG_DEFERRED_WRITE     (0x00000008)
#define IRP_CONTEXT_FLAG_EXCESS_LOG_FULL    (0x00000010)
#define IRP_CONTEXT_FLAG_WROTE_LOG          (0x00000020)
#define IRP_CONTEXT_FLAG_MFT_REC_15_USED    (0x00000040)
#define IRP_CONTEXT_FLAG_MFT_REC_RESERVED   (0x00000080)
#define IRP_CONTEXT_FLAG_RAISED_STATUS      (0x00000100)
#define IRP_CONTEXT_FLAG_CALL_SELF          (0x00000200)
#define IRP_CONTEXT_FLAG_DONT_DELETE        (0x00000400)
#define IRP_CONTEXT_FLAG_FORCE_POST         (0X00000800)
#define IRP_CONTEXT_FLAG_MODIFIED_BITMAP    (0x00001000)
#define IRP_CONTEXT_FLAG_RELEASE_USN_JRNL   (0x00002000)
#define IRP_CONTEXT_FLAG_RELEASE_MFT        (0x00004000)
#define IRP_CONTEXT_FLAG_DEFERRED_PUSH      (0x00008000)
#define IRP_CONTEXT_FLAG_ACQUIRE_PAGING     (0x00010000)
#define IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY    (0x00020000)
#define IRP_CONTEXT_FLAG_RETAIN_FLAGS       (0x00040000)

//
//  The following flags need to be cleared when a request is posted.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_POST   \
    (IRP_CONTEXT_FLAG_LARGE_ALLOCATION  | \
     IRP_CONTEXT_FLAG_WRITE_SEEN        | \
     IRP_CONTEXT_FLAG_CREATE_MOD_SCB    | \
     IRP_CONTEXT_FLAG_EXCESS_LOG_FULL   | \
     IRP_CONTEXT_FLAG_WROTE_LOG         | \
     IRP_CONTEXT_FLAG_MFT_REC_15_USED   | \
     IRP_CONTEXT_FLAG_MFT_REC_RESERVED  | \
     IRP_CONTEXT_FLAG_RAISED_STATUS     | \
     IRP_CONTEXT_FLAG_CALL_SELF         | \
     IRP_CONTEXT_FLAG_DONT_DELETE       | \
     IRP_CONTEXT_FLAG_FORCE_POST        | \
     IRP_CONTEXT_FLAG_MODIFIED_BITMAP   | \
     IRP_CONTEXT_FLAG_RELEASE_USN_JRNL  | \
     IRP_CONTEXT_FLAG_RELEASE_MFT       | \
     IRP_CONTEXT_FLAG_DEFERRED_PUSH     | \
     IRP_CONTEXT_FLAG_ACQUIRE_PAGING    | \
     IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY   | \
     IRP_CONTEXT_FLAG_RETAIN_FLAGS)

//
//  The following flags need to be cleared when a request is retried.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY  \
    (IRP_CONTEXT_FLAG_LARGE_ALLOCATION  | \
     IRP_CONTEXT_FLAG_WRITE_SEEN        | \
     IRP_CONTEXT_FLAG_CREATE_MOD_SCB    | \
     IRP_CONTEXT_FLAG_DEFERRED_WRITE    | \
     IRP_CONTEXT_FLAG_EXCESS_LOG_FULL   | \
     IRP_CONTEXT_FLAG_WROTE_LOG         | \
     IRP_CONTEXT_FLAG_MFT_REC_15_USED   | \
     IRP_CONTEXT_FLAG_MFT_REC_RESERVED  | \
     IRP_CONTEXT_FLAG_RAISED_STATUS     | \
     IRP_CONTEXT_FLAG_CALL_SELF         | \
     IRP_CONTEXT_FLAG_DONT_DELETE       | \
     IRP_CONTEXT_FLAG_FORCE_POST        | \
     IRP_CONTEXT_FLAG_MODIFIED_BITMAP   | \
     IRP_CONTEXT_FLAG_RELEASE_USN_JRNL  | \
     IRP_CONTEXT_FLAG_RELEASE_MFT       | \
     IRP_CONTEXT_FLAG_DEFERRED_PUSH     | \
     IRP_CONTEXT_FLAG_ACQUIRE_PAGING    | \
     IRP_CONTEXT_FLAG_RETAIN_FLAGS)

//
//  State flags.  IrpContext flags which span the life of an IrpContext
//  and must be explicitly set and cleared.  If we start to run out
//  of these some of them can be shared be they are only tested
//  in specific operations.
//

#define IRP_CONTEXT_STATE_WAIT                          (0x00000001)        //  Specifically 1 so we don't have to cast to boolean.
#define IRP_CONTEXT_STATE_EFS_CREATE                    (0x00000002)
#define IRP_CONTEXT_STATE_FAILED_CLOSE                  (0x00000004)
#define IRP_CONTEXT_STATE_WRITE_THROUGH                 (0x00000008)
#define IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT              (0x00000010)
#define IRP_CONTEXT_STATE_ALLOC_SECURITY                (0x00000020)
#define IRP_CONTEXT_STATE_IN_FSP                        (0x00000040)
#define IRP_CONTEXT_STATE_IN_TEARDOWN                   (0x00000080)
#define IRP_CONTEXT_STATE_ACQUIRE_EX                    (0x00000100)
#define IRP_CONTEXT_STATE_DASD_OPEN                     (0x00000200)
#define IRP_CONTEXT_STATE_DASD_UNLOCK                   (0x00000200)  // overloaded
#define IRP_CONTEXT_STATE_QUOTA_DISABLE                 (0x00000400)
#define IRP_CONTEXT_STATE_LAZY_WRITE                    (0x00000800)
#define IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE             (0x00001000)
#define IRP_CONTEXT_STATE_FORCE_PUSH                    (0x00002000)
#define IRP_CONTEXT_STATE_READ_ONLY_FO                  (0x00004000)
#define IRP_CONTEXT_STATE_VOL_UPGR_FAILED               (0x00008000)
#define IRP_CONTEXT_STATE_PERSISTENT                    (0x00010000)
#define IRP_CONTEXT_STATE_WRITING_AT_EOF                (0x00020000)
#define IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH            (0x00040000)
#define IRP_CONTEXT_STATE_ALLOC_FROM_POOL               (0x00080000)
#define IRP_CONTEXT_STATE_OWNS_TOP_LEVEL                (0x00100000)
#define IRP_CONTEXT_STATE_ENCRYPTION_RETRY              (0x00200000)
#define IRP_CONTEXT_STATE_ALLOC_MDL                     (0x00400000)
#define IRP_CONTEXT_STATE_BAD_RESTART                   (0x00800000)


//
//  The top level context is used to determine whether this request has
//  other requests below it on the stack.
//

typedef struct _TOP_LEVEL_CONTEXT {

    BOOLEAN TopLevelRequest;
    BOOLEAN ValidSavedTopLevel;
    BOOLEAN OverflowReadThread;

    ULONG Ntfs;

    VCN VboBeingHotFixed;

    PSCB ScbBeingHotFixed;

    PIRP SavedTopLevelIrp;

    PIRP_CONTEXT ThreadIrpContext;

} TOP_LEVEL_CONTEXT;
typedef TOP_LEVEL_CONTEXT *PTOP_LEVEL_CONTEXT;


//
//  The found attribute part of the attribute enumeration context
//  describes an attribute record that had been located or created.  It
//  may refer to either a base or attribute list.
//

typedef struct _FOUND_ATTRIBUTE {

    //
    //  The following identify the attribute which was mapped.  These are
    //  necessary if forcing the range of bytes into memory by pinning.
    //  These include the Bcb on which the attribute was read (if this
    //  field is NULL, this is the initial attribute) and the offset of
    //  the record segment in the Mft.
    //

    LONGLONG MftFileOffset;

    //
    //  Pointer to the Attribute Record
    //

    PATTRIBUTE_RECORD_HEADER Attribute;

    //
    //  Pointer to the containing record segment.
    //

    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    //
    //  Bcb for mapped/pinned FileRecord
    //

    PBCB Bcb;

    //
    //  Some state information.
    //

    BOOLEAN AttributeDeleted;

} FOUND_ATTRIBUTE;
typedef FOUND_ATTRIBUTE *PFOUND_ATTRIBUTE;

//
//  The structure guides enumeration through the attribute list.
//

typedef struct _ATTRIBUTE_LIST_CONTEXT {

    //
    //  This points to the first attribute list entry; it is advanced
    //  when we are searching for a particular exteral attribute.
    //

    PATTRIBUTE_LIST_ENTRY Entry;

    //
    //  A Bcb for the attribute list.
    //

    PBCB Bcb;

    //
    //  This field is used to remember the location of the Attribute
    //  List attribute within the base file record, if existent.
    //

    PATTRIBUTE_RECORD_HEADER AttributeList;

    //
    //  This points to the first entry in the attribute list.  This is
    //  needed when the attribute list is non-resident.
    //

    PATTRIBUTE_LIST_ENTRY FirstEntry;

    //
    //  This points just beyond the final attribute list entry.
    //

    PATTRIBUTE_LIST_ENTRY BeyondFinalEntry;

    //
    //  This is the Bcb for the data portion of a non-resident attribute.
    //

    PBCB NonresidentListBcb;

} ATTRIBUTE_LIST_CONTEXT;
typedef ATTRIBUTE_LIST_CONTEXT *PATTRIBUTE_LIST_CONTEXT;

//
//  The Attribute Enumeration Context structure returns information on an
//  attribute which has been found by one of the Attribute Lookup or
//  Creation routines.  It is also used as an IN OUT structure to perform
//  further lookups/modifications to attributes.  It does not have a node
//  type code and size since it is usually allocated on the caller's
//  stack.
//

typedef struct _ATTRIBUTE_ENUMERATION_CONTEXT {

    //
    //  Contains the actual attribute we found.
    //

    FOUND_ATTRIBUTE FoundAttribute;

    //
    //  Allows enumeration through the attribute list.
    //

    ATTRIBUTE_LIST_CONTEXT AttributeList;

} ATTRIBUTE_ENUMERATION_CONTEXT;
typedef ATTRIBUTE_ENUMERATION_CONTEXT *PATTRIBUTE_ENUMERATION_CONTEXT;


//
//  Define struct which will be used to remember the path that was
//  followed to locate a given INDEX_ENTRY or insertion point for an
//  INDEX_ENTRY.  This structure is always filled in by LookupIndexEntry.
//
//  The Index Lookup Stack is generally allocated as a local variable in
//  one of the routines in this module that may be called from another
//  module.  A pointer to this stack is then passed in to some of the
//  internal routines.
//
//  The first entry in the stack describes context in the INDEX attribute
//  in the file record, and all subsequent stack entries refer to Index
//  buffers in the INDEX_ALLOCATION attribute.
//
//  Outside of indexsup.c, this structure should only be passed as an
//  "opaque" context, and individual fields should not be referenced.
//

typedef struct _INDEX_LOOKUP_STACK {

    //
    //  Bcb pointer for the Index Buffer.  In the "bottom" (first entry)
    //  of the stack this field contains a NULL, and the Bcb must be found
    //  via the Attribute Enumeration Context.
    //

    PBCB Bcb;

    //
    //  Pointer to the start of the File Record or Index Buffer
    //

    PVOID StartOfBuffer;

    //
    //  Pointer to Index Header in the File Record or Index Buffer
    //

    PINDEX_HEADER IndexHeader;

    //
    //  Pointer to to the current INDEX_ENTRY on search path
    //

    PINDEX_ENTRY IndexEntry;

    //
    //  Index block of the index buffer
    //

    LONGLONG IndexBlock;

    //
    //  Saved Lsn for faster enumerations
    //

    LSN CapturedLsn;

} INDEX_LOOKUP_STACK;

typedef INDEX_LOOKUP_STACK *PINDEX_LOOKUP_STACK;

#define INDEX_LOOKUP_STACK_SIZE      (3)

//
//  Index Context structure.
//
//  This structure maintains a context which describes the lookup stack to
//  a given index entry.  It includes the Attribute Enumeration Context
//  for the Index Root, the Index lookup stack remembering the path to the
//  index entry, and the current stack pointer within the stack pointing
//  to the stack entry for the current index entry or where we are at in a
//  bucket split or delete operation.
//
//  Outside of indexsup.c, this structure should only be passed as an
//  "opaque" context, and individual fields should not be referenced.
//

typedef struct _INDEX_CONTEXT {

    //
    //  Attribute Enumeration Context for the Index Root
    //

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    //
    //  Captured Lsn of file record containing Index Root.  We capture the Lsn
    //  of the file record when we find the Index Root.  Later, we can
    //  check to see if the file record had changed (compare Lsn's) before
    //  doing the expensive attribute lookup
    //

    LSN IndexRootFileRecordLsn;

    //
    //  Base of dynamically allocated lookup stack - either points
    //  to the one above or a dynamically allocated larger one.
    //

    PINDEX_LOOKUP_STACK Base;

    //
    //  Stack pointer to top of Lookup Stack.  This field essentially
    //  remembers how deep the index Btree is.
    //

    PINDEX_LOOKUP_STACK Top;

    //
    //  Index lookup stack.
    //

    INDEX_LOOKUP_STACK LookupStack[INDEX_LOOKUP_STACK_SIZE];

    //
    //  Stack pointer within the Index Lookup Stack
    //

    PINDEX_LOOKUP_STACK Current;

    //
    //  Captured Scb (Index type) change count
    //

    ULONG ScbChangeCount;

    //
    //  This field remembers where the index root attribute was last
    //  seen, to support correct operation of FindMoveableIndexRoot.
    //

    PATTRIBUTE_RECORD_HEADER OldAttribute;

    //
    //  Number of entries allocated in the lookup stack.
    //

    USHORT NumberEntries;

    //
    //  Flags
    //

    USHORT Flags;

    //
    //  For enumerations via NtOfsReadRecords, the MatchFunction and MatchData
    //  are stored here.
    //

    PMATCH_FUNCTION MatchFunction;
    PVOID MatchData;

    //
    //  Fcb which was acquired and must be released.
    //

    PFCB AcquiredFcb;

    //
    //  Add field to preserve quad & cache line alignment
    //

    ULONG Unused;

} INDEX_CONTEXT;

typedef INDEX_CONTEXT *PINDEX_CONTEXT;

//
//  Fcb table is acquired and must be freed.
//

#define INDX_CTX_FLAG_FCB_TABLE_ACQUIRED (01)


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the Read/Write Multiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _NTFS_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;
    UCHAR IrpSpFlags;
    BOOLEAN AllocatedContext;
    BOOLEAN PagingIo;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;

        } Async;

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;

    } Wait;

} NTFS_IO_CONTEXT;

typedef NTFS_IO_CONTEXT *PNTFS_IO_CONTEXT;

//
//  An array of these structures is passed to NtfsMultipleAsync describing
//  a set of runs to execute in parallel.  Risc compilers will add an
//  unused long word anyway to align each array entry.
//

typedef struct _IO_RUN {

    VBO StartingVbo;
    LBO StartingLbo;
    ULONG BufferOffset;
    ULONG ByteCount;
    PIRP SavedIrp;
    ULONG Unused;

} IO_RUN;
typedef IO_RUN *PIO_RUN;


//
//  This structure is used by the name manipulation routines to described
//  a parsed file name componant.
//

typedef struct _NTFS_NAME_DESCRIPTOR {

    //
    //  The follow flag tells which fields were present in the name.
    //

    ULONG FieldsPresent;

    UNICODE_STRING FileName;
    UNICODE_STRING AttributeType;
    UNICODE_STRING AttributeName;
    ULONG VersionNumber;

} NTFS_NAME_DESCRIPTOR;
typedef NTFS_NAME_DESCRIPTOR *PNTFS_NAME_DESCRIPTOR;

//
//  Define the bits in FieldsPresent above.
//

#define FILE_NAME_PRESENT_FLAG          (1)
#define ATTRIBUTE_TYPE_PRESENT_FLAG     (2)
#define ATTRIBUTE_NAME_PRESENT_FLAG     (4)
#define VERSION_NUMBER_PRESENT_FLAG     (8)


//
//  The following is used to perform Ea related routines.
//

typedef struct _EA_LIST_HEADER {

    //
    //  The size of buffer needed to pack these Ea's
    //

    ULONG PackedEaSize;

    //
    //  This is the count of Ea's with their NEED_EA
    //  bit set.
    //

    USHORT NeedEaCount;

    //
    //  The size of the buffer needed to return all Ea's
    //  in their unpacked form.
    //

    ULONG UnpackedEaSize;

    //
    //  This is the size of the buffer used to store the ea's
    //

    ULONG BufferSize;

    //
    //  This is the pointer to the first entry in the list.
    //

    PFILE_FULL_EA_INFORMATION FullEa;

} EA_LIST_HEADER;
typedef EA_LIST_HEADER *PEA_LIST_HEADER;


//
//  The following structure is used to maintain a list of recently
//  deallocated records so that the file system will not reuse a recently
//  deallocated record until it is safe to do so.  Each instance of this
//  structure is placed on two queues.  One queue is per index SCB and the
//  other queue is per Irp Context.
//
//  Whenever we delete a record we allocate a new structure if necessary
//  and add it to the scb queue and the irp context queue.  We indicate in
//  the structure the index of the record we just deallocated.
//
//  Whenever we need to allocate a new record we filter out any canidate
//  we want to allocate to avoid allocating one in the scb's recently
//  deallocated queue.
//
//  Whenever we delete an irp context we scan through its recently
//  deallocated queue removing it from the scb queue.
//

#define DEALLOCATED_RECORD_ENTRIES          32

typedef struct _DEALLOCATED_RECORDS {

    //
    //  The following field links this structure into the
    //  Scb->RecentlyDeallocatedQueue
    //

    LIST_ENTRY ScbLinks;

    //
    //  The following field links this structure into the
    //  IrpContext->RecentlyDeallocatedQueue
    //

    LIST_ENTRY IrpContextLinks;

    //
    //  This is a pointer to the Scb that this record is part of
    //

    PSCB Scb;

    //
    //  The following two fields describe the total size of this structure
    //  and the number of entries actually being used.  NumberOfEntries is
    //  the size of the Index array and NextFreeEntryis the index of the
    //  next free slot.  If NumberOfEntries is equal to NextFreeEntry then
    //  this structure is full
    //

    ULONG NumberOfEntries;
    ULONG NextFreeEntry;

    //
    //  This is an array of indices that have been dealloated.
    //

    ULONG Index[DEALLOCATED_RECORD_ENTRIES];

} DEALLOCATED_RECORDS;
typedef DEALLOCATED_RECORDS *PDEALLOCATED_RECORDS;

#define DEALLOCATED_RECORDS_HEADER_SIZE \
    (FIELD_OFFSET( DEALLOCATED_RECORDS, Index ))

#pragma pack(8)
typedef struct _FCB_TABLE_ELEMENT {

    FILE_REFERENCE FileReference;
    PFCB Fcb;

} FCB_TABLE_ELEMENT;
typedef FCB_TABLE_ELEMENT *PFCB_TABLE_ELEMENT;
#pragma pack()

#ifdef NTFS_CACHE_RIGHTS

//
//  Computed access rights information.  This structure is used to cache
//  what access rights a given security token is granted relative to a
//  security descriptors.
//

typedef struct _COMPUTED_ACCESS_RIGHTS {

    //
    //  The token id.  Note that a specific TokenId will only appear once
    //  in the cache.
    //

    LUID TokenId;

    //
    //  The modification id of the token.  This changes whenever the token
    //  is updated such that the access rights might change.
    //

    LUID ModifiedId;

    //
    //  All of the access rights held by this token that do not require
    //  privileges. The rights will also not include MAXIMUM_ALLOWED.
    //  Note that we don't include rights that require privileges
    //  because we wouldn't be able to determine in a future
    //  use of the cached information whether the privileges were needed
    //  or not to gain a desired set of rights.  The use of privileges
    //  affects auditing.
    //

    ACCESS_MASK Rights;

} COMPUTED_ACCESS_RIGHTS, *PCOMPUTED_ACCESS_RIGHTS;


//
//  Cached access rights information.  This structure is used to cache
//  what access rights are known to be available for all security tokens
//  and for the most recently used specific security tokens.
//

#define NTFS_MAX_CACHED_RIGHTS 2

typedef struct _CACHED_ACCESS_RIGHTS {

    //
    //  The list of computed access rights for specific tokens.
    //

    COMPUTED_ACCESS_RIGHTS TokenRights[NTFS_MAX_CACHED_RIGHTS];

    //
    //  The access rights that all users are known to have.
    //  The rights will not include MAXIMUM_ALLOWED.
    //

    ACCESS_MASK EveryoneRights;

    //
    //  The number of valid entries in TokenRights.
    //

    UCHAR Count;

    //
    //  The index of the next entry to add to TokenRights.
    //

    UCHAR NextInsert;

    //
    //  This indicates whether we have acquired EveryoneRights.
    //

    BOOLEAN HaveEveryoneRights;

} CACHED_ACCESS_RIGHTS, *PCACHED_ACCESS_RIGHTS;
#endif


//
//  Security descriptor information.  This structure is used to allow
//  Fcb's to share security descriptors.
//

typedef struct _SHARED_SECURITY {

#ifdef NTFS_CACHE_RIGHTS
    CACHED_ACCESS_RIGHTS CachedRights;
#endif
    ULONG ReferenceCount;
    SECURITY_DESCRIPTOR_HEADER Header;
    UCHAR SecurityDescriptor[1];

} SHARED_SECURITY, *PSHARED_SECURITY;

#define GetSharedSecurityLength(SS)         (GETSECURITYDESCRIPTORLENGTH( &(SS)->Header ))
#define SetSharedSecurityLength(SS,LENGTH)  (SetSecurityDescriptorLength( &(SS)->Header,(LENGTH) ))


//
//  The following structure is used to store the state of an Scb to use
//  during unwind operations.  We keep a copy of all of the file sizes.
//

typedef struct _OLD_SCB_SNAPSHOT {

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;
    LONGLONG TotalAllocated;

    UCHAR CompressionUnit;
    BOOLEAN Resident;
    USHORT AttributeFlags;

} OLD_SCB_SNAPSHOT, *POLD_SCB_SNAPSHOT;

//
//  Structure used to track the number of threads doing read ahead, so
//  that we do not hot fix for them.
//

typedef struct _READ_AHEAD_THREAD {

    //
    //  Links of read ahead structures.
    //

    LIST_ENTRY Links;

    //
    //  Thread Id
    //

    PVOID Thread;

} READ_AHEAD_THREAD, *PREAD_AHEAD_THREAD;

//
//  Structure used to post to Defrag Mft routine.
//

typedef struct _DEFRAG_MFT {

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    PVCB Vcb;

    BOOLEAN DeallocateWorkItem;

} DEFRAG_MFT, *PDEFRAG_MFT;

//
//  Structure for remembering file records to delete.
//

typedef struct _NUKEM {

    struct _NUKEM *Next;
    ULONG RecordNumbers[4];

} NUKEM, *PNUKEM;

//
//  Structure for picking up file name pairs for property tunneling. Space is allocated for
//  the names so that this can be used on the stack. The size of LongBuffer should be sized
//  so that it will capture the vast majority of long names. Fallback code can go to pool
//  if required - but rarely.
//


typedef struct _NAME_PAIR {

    //
    //  The FILE_NAME_DOS component
    //

    UNICODE_STRING Short;

    //
    //  The FILE_NAME_NTFS component
    //

    UNICODE_STRING Long;

    //  Allocate space for an 8.3 name and a 26 char name. 26 isn't quite random -
    //  it puts this structure at 96 bytes.
    //

    WCHAR ShortBuffer[8+1+3];
    WCHAR LongBuffer[26];

} NAME_PAIR, *PNAME_PAIR;

//
//  The following is used to synchronize the create path.  It is passed to the completion
//  callback to restore the top level context and signal any waiting thread.
//

typedef struct _NTFS_COMPLETION_CONTEXT {

    PIRP_CONTEXT IrpContext;
    KEVENT Event;

} NTFS_COMPLETION_CONTEXT, *PNTFS_COMPLETION_CONTEXT;

//
//  Following structure is used at the time a request is posted to the oplock package
//  to perform any cleanup to do at that time.
//

typedef struct _OPLOCK_CLEANUP {

    //
    //  This is the original name and any allocated name buffer used during create.
    //  We must restore the original name in the file object on error.
    //
    //  We also store information about the original lengths of the attribute name
    //  and attribute code (or type) name.
    //

    UNICODE_STRING OriginalFileName;
    UNICODE_STRING FullFileName;
    UNICODE_STRING ExactCaseName;
    PFILE_OBJECT FileObject;
    ACCESS_MASK RemainingDesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    ACCESS_MASK DesiredAccess;
    PNTFS_COMPLETION_CONTEXT CompletionContext;
    USHORT AttributeNameLength;
    USHORT AttributeCodeNameLength;

} OPLOCK_CLEANUP, *POPLOCK_CLEANUP;

//
//  The following structure is used to serialize the compressed IO path.
//

typedef struct _COMPRESSION_SYNC {

    //
    //  Links of synchronization objects, attached to Scb.
    //  NOTE - this field must appear first.  We make this assumption
    //  when walking the links.
    //

    LIST_ENTRY CompressionLinks;

    //
    //  Offset in the file for the link.  Rounded down to cache manager views.
    //

    LONGLONG FileOffset;

    //
    //  Resource for synchronization.  Allows shared or exclusive access to view.
    //

    ERESOURCE Resource;

    //
    //  Backpointer to Scb.
    //

    PSCB Scb;

    //
    //  Reference count for number of users of this view.  Someone waiting
    //  for the offset wants to make sure it doesn't go away when
    //  another thread is finished with it.
    //

    ULONG ReferenceCount;

} COMPRESSION_SYNC, *PCOMPRESSION_SYNC;


//
//  This is the quota control block which are stored as table elments in the quota
//  control table.
//

typedef struct _QUOTA_CONTROL_BLOCK {
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    ULONG OwnerId;
    ULONG Flags;
    LONG ReferenceCount;
    QUICK_INDEX_HINT QuickIndexHint;
    PFAST_MUTEX QuotaControlLock;
} QUOTA_CONTROL_BLOCK, *PQUOTA_CONTROL_BLOCK;

//
//  Define the quota control flags.
//

#define QUOTA_FLAG_LIMIT_POSTED            (0x00000001)

//
//  Define the minimum amount of time between quota events.  Currently this is
//  1 hour.
//

#define MIN_QUOTA_NOTIFY_TIME (60i64 * 60 * 1000 * 1000 * 10)


//
//  NTFS_TUNNELED_DATA is a structure for keeping the information which is
//  preserved when a file is tunneled.  This is the structure that we pass to
//  and get back from the tunneling routines in FsRtl.
//

typedef struct _NTFS_TUNNELED_DATA {
    LONGLONG CreationTime;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    BOOLEAN HasObjectId;
} NTFS_TUNNELED_DATA, *PNTFS_TUNNELED_DATA;

//
//  Following macro is used to initialize UNICODE strings
//

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }

#define USN_PAGE_BOUNDARY               (0x2000)
#define USN_JOURNAL_CACHE_BIAS          (0x0000000000400000)
#define USN_MAXIMUM_JOURNAL_SIZE        (0x0000000100000000)

#ifdef NTFS_RWCMP_TRACE
extern ULONG NtfsCompressionTrace;

#define IsSyscache(H) (FlagOn(((PSCB)(H))->ScbState, SCB_STATE_SYSCACHE_FILE))
#endif


#ifdef BENL_DBG
typedef struct {
    LIST_ENTRY Links;
    LSN Lsn;
    ULONG Data;
    ULONG OldData;
    ULONG Length;
} RESTART_LOG, *PRESTART_LOG;
#endif

//
//  Maximum entries in the overflow queue at one time
//

#define OVERFLOW_QUEUE_LIMIT 1000

#endif // _NTFSSTRU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\pnp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Pnp.c

Abstract:

    This module implements the Pnp routines for Ntfs called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]        29-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_PNP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_PNP)

//
//  Local procedure prototypes
//

NTSTATUS
NtfsCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP *Irp
    );

NTSTATUS
NtfsPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PNTFS_COMPLETION_CONTEXT CompletionContext
    );

VOID
NtfsPerformSurpriseRemoval(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonPnp)
#pragma alloc_text(PAGE, NtfsFsdPnp)
#pragma alloc_text(PAGE, NtfsPerformSurpriseRemoval)
#endif

NTSTATUS
NtfsFsdPnp (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD entry point for plug and play (Pnp).

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    PIRP_CONTEXT IrpContext = NULL;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

#ifdef NTFSPNPDBG
    if (NtfsDebugTraceLevel != 0) SetFlag( NtfsDebugTraceLevel, DEBUG_TRACE_PNP );
#endif

    DebugTrace( +1, Dbg, ("NtfsFsdPnp\n") );

    //
    //  Call the common Pnp routine
    //

    FsRtlEnterFileSystem();

    switch( IoGetCurrentIrpStackLocation( Irp )->MinorFunction ) {

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_SURPRISE_REMOVAL:
    
        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );
        break;
        
    default:
        
        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );
        break;
    }
    
    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //
    
                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            Status = NtfsCommonPnp( IrpContext, &Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdPnp -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP *Irp
    )

/*++

Routine Description:

    This is the common routine for PnP called by the fsd thread.

Arguments:

    Irp - Supplies the Irp to process.  WARNING!  THIS IRP HAS NO
          FILE OBJECT IN OUR IRP STACK LOCATION!!!

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    NTSTATUS FlushStatus;
    PIO_STACK_LOCATION IrpSp;
    NTFS_COMPLETION_CONTEXT CompletionContext;
    PVOLUME_DEVICE_OBJECT OurDeviceObject;

    PVCB Vcb;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN CheckpointAcquired = FALSE;
    BOOLEAN DecrementCloseCount = FALSE;
    
#ifdef SYSCACHE_DEBUG
    ULONG SystemHandleCount = 0;
#endif

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( *Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( *Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //

    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject;

    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.  Then we
    //  check if it is actually one of ours, just to be perfectly paranoid.
    //

    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType(&OurDeviceObject->Vcb) != NTFS_NTC_VCB) {

        NtfsCompleteRequest( IrpContext, *Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    Vcb = &OurDeviceObject->Vcb;
    KeInitializeEvent( &CompletionContext.Event, NotificationEvent, FALSE );

    //
    //  Anyone who is flushing the volume or setting Vcb bits needs to get the
    //  vcb exclusively.  
    //

    switch ( IrpSp->MinorFunction ) {

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_SURPRISE_REMOVAL:

        //
        //  Lock volume / dismount synchs with checkpoint - we need to do this first before
        //  acquiring the vcb to preserve locking order since we're going to do a lock in
        //  the query remove case and a dismount in the surprise removal
        // 

        NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );
        CheckpointAcquired = TRUE;
        
        // fall through

    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    
        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;
        break;
    }    

    try {

        switch ( IrpSp->MinorFunction ) {

        case IRP_MN_QUERY_REMOVE_DEVICE:

            DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE\n") );

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                Status = STATUS_VOLUME_DISMOUNTED;
                break;
            } 

            //
            //  If we already know we don't want to dismount this volume, don't bother
            //  flushing now.  If there's a nonzero cleanup count, flushing won't get 
            //  the close count down to zero, so we might as well get out now.
            //
            
#ifdef SYSCACHE_DEBUG
            if (Vcb->SyscacheScb != NULL) {
                SystemHandleCount = Vcb->SyscacheScb->CleanupCount;
            }
            if ((Vcb->CleanupCount > SystemHandleCount) ||
#else
            if ((Vcb->CleanupCount > 0) ||
#endif
                FlagOn(Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT)) {

                DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE --> cleanup count still %x \n", Vcb->CleanupCount) );
            
                //
                //  We don't want the device to get removed or stopped if this volume has files
                //  open.  We'll fail this query, and we won't bother calling the driver(s) below us.
                //

                Status = STATUS_UNSUCCESSFUL;
                
            } else {

                //
                //  We might dismount this volume soon, so let's try to flush and purge
                //  everything we can right now.
                //

                FlushStatus = NtfsFlushVolume( IrpContext,
                                               Vcb,
                                               TRUE,
                                               TRUE,
                                               TRUE,
                                               FALSE );

                //
                //  We need to make sure the cache manager is done with any lazy writes
                //  that might be keeping the close count up.  Since Cc might need to 
                //  close some streams, we need to release the vcb.  We'd hate to have
                //  the Vcb go away, so we'll bias the close count temporarily.
                //

                Vcb->CloseCount += 1;
                DecrementCloseCount = TRUE;
                
                NtfsReleaseVcb( IrpContext, Vcb );
                CcWaitForCurrentLazyWriterActivity();
                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

                Vcb->CloseCount -= 1;
                DecrementCloseCount = FALSE;

                //
                //  Since we dropped the Vcb, we need to redo any tests we've done.
                //
                
                if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                    Status = STATUS_VOLUME_DISMOUNTED;
                    break;
                } 


#ifdef SYSCACHE_DEBUG
                if (Vcb->SyscacheScb != NULL) {
                    SystemHandleCount = Vcb->SyscacheScb->CleanupCount;
                }
                
                if ((Vcb->CleanupCount > SystemHandleCount) ||
#else
                if ((Vcb->CleanupCount > 0) ||
#endif
                    FlagOn(Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT)) {

                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                if ((Vcb->CloseCount - (Vcb->SystemFileCloseCount + Vcb->QueuedCloseCount)) > 0) {

                    DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE --> %x user files still open \n", (Vcb->CloseCount - Vcb->SystemFileCloseCount)) );
                
                    //
                    //  We don't want the device to get removed or stopped if this volume has files
                    //  open.  We'll fail this query, and we won't bother calling the driver(s) below us.
                    //

                    Status = STATUS_UNSUCCESSFUL;
                    
                } else {

                    //
                    //  We've already done all we can to clear up any open files, so there's 
                    //  no point in retrying if this lock volume fails.  We'll just tell 
                    //  NtfsLockVolumeInternal we're already retrying.
                    //

                    ULONG Retrying = 1;
                    
                    DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE --> No user files, Locking volume \n") );
                
                    Status = NtfsLockVolumeInternal( IrpContext, 
                                                     Vcb, 
                                                     ((PFILE_OBJECT) 1),
                                                     &Retrying );

                    //
                    //  Remember not to send any irps to the target device now.
                    //
                    
                    if (NT_SUCCESS( Status )) {

                        ASSERT_EXCLUSIVE_RESOURCE( &Vcb->Resource );
                        SetFlag( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED );
                    }
                }
            }
            
            break;
            
        case IRP_MN_REMOVE_DEVICE:

            DebugTrace( 0, Dbg, ("IRP_MN_REMOVE_DEVICE\n") );
            
            //
            //  If remove_device is preceded by query_remove, we treat this just 
            //  like a cancel_remove and unlock the volume and pass the irp to 
            //  the driver(s) below the filesystem.  
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {
            
                DebugTrace( 0, Dbg, ("IRP_MN_REMOVE_DEVICE --> Volume locked \n") );                
                Status = NtfsUnlockVolumeInternal( IrpContext, Vcb );
                
            } else {

                //  
                //  The only other possibility is for remove_device to be prededed 
                //  by surprise_remove, in which case we treat this as a failed verify.
                //  
                
                // **** TODO **** ADD CODE TO TREAT THIS LIKE A FAILED VERIFY
            
                DebugTrace( 0, Dbg, ("IRP_MN_REMOVE_DEVICE --> Volume _not_ locked \n") );                
                Status = STATUS_SUCCESS;
            }
            
            break;

        case IRP_MN_SURPRISE_REMOVAL:

            DebugTrace( 0, Dbg, ("IRP_MN_SURPRISE_REMOVAL\n") );
            
            //
            //  For surprise removal, we call the driver(s) below us first, then do
            //  our processing. Let us also remember that we can't send any more
            //  IRPs to the target device.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED );
            
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            
            Status = STATUS_SUCCESS;
            break;
            
        default:

            DebugTrace( 0, Dbg, ("Some other PnP IRP_MN_ %x\n", IrpSp->MinorFunction) );
            Status = STATUS_SUCCESS;
            break;
        }

        //
        //  We only pass this irp down if we didn't have some reason to fail it ourselves.
        //  We want to keep the IrpContext around for our own cleanup.
        //
        
        if (!NT_SUCCESS( Status )) {

            NtfsCompleteRequest( NULL, *Irp, Status );
            try_return( NOTHING );
        } 
        
        //
        //  Get the next stack location, and copy over the stack location
        //

        IoCopyCurrentIrpStackLocationToNext( *Irp );

        //
        //  Set up the completion routine
        //        

        CompletionContext.IrpContext = IrpContext;
        IoSetCompletionRoutine( *Irp,
                                NtfsPnpCompletionRoutine,
                                &CompletionContext,
                                TRUE,
                                TRUE,
                                TRUE );
                                
        //
        //  Send the request to the driver(s) below us. - We don't own it anymore
        //  so null it out
        //

        Status = IoCallDriver( Vcb->TargetDeviceObject, *Irp );
        *Irp = NULL;

        //
        //   Wait for the driver to definitely complete
        // 

        if (Status == STATUS_PENDING) {

            KeWaitForSingleObject( &CompletionContext.Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            KeClearEvent( &CompletionContext.Event );
        }

        //
        //  Post processing - these are items that need to be done after the lower
        //  storage stack has processed the request. 
        // 

        switch (IrpContext->MinorFunction) {
        
        case IRP_MN_SURPRISE_REMOVAL:

            //
            //  Start the tear-down process irrespective of the status
            //  the driver below us sent back. There's no turning back here.
            //
            
            if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                NtfsPerformSurpriseRemoval( IrpContext, Vcb );
            }
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            //
            //  Since we cancelled and have told the driver we can now safely unlock
            //  the volume and send ioctls to the drive (unlock media)
            //
    
            ClearFlag( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED );
    
            if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {
    
                DebugTrace( 0, Dbg, ("IRP_MN_CANCEL_REMOVE_DEVICE --> Volume locked \n") );                
                NtfsUnlockVolumeInternal( IrpContext, Vcb );                
    
            }            
            break;
        }
        
    try_exit: NOTHING;        
    } finally {

        if (DecrementCloseCount) {

            if (!VcbAcquired) {

                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                VcbAcquired = TRUE;
            }
            
            Vcb->CloseCount -= 1;
        }

        if (VcbAcquired) {

            //
            //  All 4 paths query / remove / surprise remove / cancel remove
            //  come through here. For the 3 except query we want the vcb to go away
            //  if possible. In the query remove path - dismount won't be complete 
            //  even if the close count is 0 (since the dismount is incomplete) 
            //  so this will only release
            //

            NtfsReleaseVcbCheckDelete( IrpContext, Vcb, IrpContext->MajorFunction, NULL );
        }

        if (CheckpointAcquired) {
            NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
        }
    }
    
    //
    //  Cleanup our IrpContext;  The underlying driver completed the Irp.
    //
    
    DebugTrace( -1, Dbg, ("NtfsCommonPnp -> %08lx\n", Status ) );    
    NtfsCompleteRequest( IrpContext, NULL, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PNTFS_COMPLETION_CONTEXT CompletionContext
    )
{
    PIO_STACK_LOCATION IrpSp;
    PIRP_CONTEXT IrpContext;
    PVOLUME_DEVICE_OBJECT OurDeviceObject;

    PVCB Vcb;
    BOOLEAN VcbAcquired = FALSE;

    ASSERT_IRP( Irp );
    
    IrpContext = CompletionContext->IrpContext;
    ASSERT_IRP_CONTEXT( IrpContext );
    
    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //

    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) DeviceObject;

    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.  Then we
    //  check if it is actually one of ours, just to be perfectly paranoid.
    //

    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType(&OurDeviceObject->Vcb) != NTFS_NTC_VCB) {

        return STATUS_INVALID_PARAMETER;
    }

    Vcb = &OurDeviceObject->Vcb;
    
    KeSetEvent( &CompletionContext->Event, 0, FALSE );   

    //
    //  Propagate the Irp pending state.
    //

    if (Irp->PendingReturned) {
    
        IoMarkIrpPending( Irp );        
    }

    return STATUS_SUCCESS;
}

//
// Local utility routine
//

VOID
NtfsPerformSurpriseRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

    Performs further processing on SURPRISE_REMOVAL notifications.

--*/

{    
    ASSERT(ExIsResourceAcquiredExclusiveLite( &Vcb->Resource ));

    //
    //  Flush and purge and mark all files as dismounted.  
    //  Since there may be outstanding handles, we could still see any 
    //  operation (read, write, set info, etc.) happen for files on the 
    //  volume after surprise_remove.  Since all the files will be marked
    //  for dismount, we will fail these operations gracefully.  All 
    //  operations besides cleanup & close on the volume will fail from 
    //  this time on.  
    //
    
    if (!FlagOn( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT )) {
    
        (VOID)NtfsFlushVolume( IrpContext, 
                               Vcb,
                               FALSE,
                               TRUE,
                               TRUE,
                               TRUE );
    
        NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
    }
        
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\quotasup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Quota.c

Abstract:

    This module implements the quota support routines for Ntfs

Author:

    Jeff Havens     [JHavens]        29-Feb-1996

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg DEBUG_TRACE_QUOTA


//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('QFtN')

#define MAXIMUM_SID_LENGTH \
    (FIELD_OFFSET( SID, SubAuthority ) + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES)

#define MAXIMUM_QUOTA_ROW (SIZEOF_QUOTA_USER_DATA + MAXIMUM_SID_LENGTH + sizeof( ULONG ))

//
//  Local quota support routines.
//

VOID
NtfsClearAndVerifyQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsClearPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

VOID
NtfsDeleteUnsedIds (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsMarkUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

NTSTATUS
NtfsPackQuotaInfo (
    IN PSID Sid,
    IN PQUOTA_USER_DATA QuotaUserData OPTIONAL,
    IN PFILE_QUOTA_INFORMATION OutBuffer,
    IN OUT PULONG OutBufferSize
    );

VOID
NtfsPostUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    );

NTSTATUS
NtfsPrepareForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSID Sid
    );

VOID
NtfsRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

NTSTATUS
NtfsRepairPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

VOID
NtfsSaveQuotaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsSaveQuotaFlagsSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsVerifyOwnerIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

RTL_GENERIC_COMPARE_RESULTS
NtfsQuotaTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

PVOID
NtfsQuotaTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

VOID
NtfsQuotaTableFree (
    IN PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

#if (DBG || defined( NTFS_FREE_ASSERTS ) || defined( NTFSDBG ))
BOOLEAN NtfsAllowFixups = 1;
BOOLEAN NtfsCheckQuota = 0;
#endif // DBG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAcquireQuotaControl)
#pragma alloc_text(PAGE, NtfsCalculateQuotaAdjustment)
#pragma alloc_text(PAGE, NtfsClearAndVerifyQuotaIndex)
#pragma alloc_text(PAGE, NtfsClearPerFileQuota)
#pragma alloc_text(PAGE, NtfsDeleteUnsedIds)
#pragma alloc_text(PAGE, NtfsDereferenceQuotaControlBlock)
#pragma alloc_text(PAGE, NtfsFixupQuota)
#pragma alloc_text(PAGE, NtfsFsQuotaQueryInfo)
#pragma alloc_text(PAGE, NtfsFsQuotaSetInfo)
#pragma alloc_text(PAGE, NtfsGetCallersUserId)
#pragma alloc_text(PAGE, NtfsGetOwnerId)
#pragma alloc_text(PAGE, NtfsGetRemainingQuota)
#pragma alloc_text(PAGE, NtfsInitializeQuotaControlBlock)
#pragma alloc_text(PAGE, NtfsInitializeQuotaIndex)
#pragma alloc_text(PAGE, NtfsMarkQuotaCorrupt)
#pragma alloc_text(PAGE, NtfsMarkUserLimit)
#pragma alloc_text(PAGE, NtfsMoveQuotaOwner)
#pragma alloc_text(PAGE, NtfsPackQuotaInfo)
#pragma alloc_text(PAGE, NtfsPostUserLimit)
#pragma alloc_text(PAGE, NtfsPostRepairQuotaIndex)
#pragma alloc_text(PAGE, NtfsPrepareForDelete)
#pragma alloc_text(PAGE, NtfsReleaseQuotaControl)
#pragma alloc_text(PAGE, NtfsRepairQuotaIndex)
#pragma alloc_text(PAGE, NtfsSaveQuotaFlags)
#pragma alloc_text(PAGE, NtfsSaveQuotaFlagsSafe)
#pragma alloc_text(PAGE, NtfsQueryQuotaUserSidList)
#pragma alloc_text(PAGE, NtfsQuotaTableCompare)
#pragma alloc_text(PAGE, NtfsQuotaTableAllocate)
#pragma alloc_text(PAGE, NtfsQuotaTableFree)
#pragma alloc_text(PAGE, NtfsUpdateFileQuota)
#pragma alloc_text(PAGE, NtfsUpdateQuotaDefaults)
#pragma alloc_text(PAGE, NtfsVerifyOwnerIndex)
#pragma alloc_text(PAGE, NtfsRepairPerFileQuota)
#endif


VOID
NtfsAcquireQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    )

/*++

Routine Description:

    Acquire the quota control block and quota index for shared update.  Multiple
    transactions can update then index, but only one thread can update a
    particular index.

Arguments:

    QuotaControl - Quota control block to be acquired.

Return Value:

    None.

--*/

{
    PVOID *Position;
    PVOID *ScbArray;
    ULONG Count;

    PAGED_CODE();

    ASSERT( QuotaControl->ReferenceCount > 0 );

    //
    //  Make sure we have a free spot in the Scb array in the IrpContext.
    //

    if (IrpContext->SharedScb == NULL) {

        Position = &IrpContext->SharedScb;
        IrpContext->SharedScbSize = 1;

    //
    //  Too bad the first one is not available.  If the current size is one then allocate a
    //  new block and copy the existing value to it.
    //

    } else if (IrpContext->SharedScbSize == 1) {

        if (IrpContext->SharedScb == QuotaControl) {

            //
            //  The quota block has already been aquired.
            //

            return;
        }

        ScbArray = NtfsAllocatePool( PagedPool, sizeof( PVOID ) * 4 );
        RtlZeroMemory( ScbArray, sizeof( PVOID ) * 4 );
        *ScbArray = IrpContext->SharedScb;
        IrpContext->SharedScb = ScbArray;
        IrpContext->SharedScbSize = 4;
        Position = ScbArray + 1;

    //
    //  Otherwise look through the existing array and look for a free spot.  Allocate a larger
    //  array if we need to grow it.
    //

    } else {

        Position = IrpContext->SharedScb;
        Count = IrpContext->SharedScbSize;

        do {

            if (*Position == NULL) {

                break;
            }

            if (*Position == QuotaControl) {

                //
                //  The quota block has already been aquired.
                //

                return;
            }

            Count -= 1;
            Position += 1;

        } while (Count != 0);

        //
        //  If we didn't find one then allocate a new structure.
        //

        if (Count == 0) {

            ScbArray = NtfsAllocatePool( PagedPool, sizeof( PVOID ) * IrpContext->SharedScbSize * 2 );
            RtlZeroMemory( ScbArray, sizeof( PVOID ) * IrpContext->SharedScbSize * 2 );
            RtlCopyMemory( ScbArray,
                           IrpContext->SharedScb,
                           sizeof( PVOID ) * IrpContext->SharedScbSize );

            NtfsFreePool( IrpContext->SharedScb );
            IrpContext->SharedScb = ScbArray;
            Position = ScbArray + IrpContext->SharedScbSize;
            IrpContext->SharedScbSize *= 2;
        }
    }

    //
    //  The following assert is bougus, but I want know if we hit the case
    //  where create is acquiring the scb stream shared.
    //  Then make sure that the resource is released in create.c
    //

    ASSERT( IrpContext->MajorFunction != IRP_MJ_CREATE || IrpContext->OriginatingIrp != NULL || NtfsIsExclusiveScb( IrpContext->Vcb->QuotaTableScb ));

    //
    //  Increase the reference count so the quota control block is not deleted
    //  while it is in the shared list.
    //

    ASSERT( QuotaControl->ReferenceCount > 0 );
    InterlockedIncrement( &QuotaControl->ReferenceCount );

    //
    //  The quota index must be acquired before the mft scb is acquired.
    //

    ASSERT(!NtfsIsExclusiveScb( IrpContext->Vcb->MftScb ) ||
           ExIsResourceAcquiredSharedLite( IrpContext->Vcb->QuotaTableScb->Header.Resource ));

    NtfsAcquireResourceShared( IrpContext, IrpContext->Vcb->QuotaTableScb, TRUE );
    ExAcquireFastMutexUnsafe( QuotaControl->QuotaControlLock );

    *Position = QuotaControl;

    return;
}


VOID
NtfsCalculateQuotaAdjustment (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PLONGLONG Delta
    )

/*++

Routine Description:

    This routine scans the user data streams in a file and determines
    by how much the quota needs to be adjusted.

Arguments:

    Fcb - Fcb whose quota usage is being modified.

    Delta - Returns the amount of quota adjustment required for the file.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;
    VCN StartVcn = 0;

    PAGED_CODE();

    ASSERT_EXCLUSIVE_FCB( Fcb );

    //
    //  There is nothing to do if the standard infor has not been
    //  expanded yet.
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {
        *Delta = 0;
        return;
    }

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to cleanup the enumeration structure.
    //

    try {

        //
        //  Start with the $STANDARD_INFORMATION.  This must be the first one found.
        //

        if (!NtfsLookupAttribute( IrpContext, Fcb, &Fcb->FileReference, &Context )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        Attribute = NtfsFoundAttribute( &Context );

        if (Attribute->TypeCode != $STANDARD_INFORMATION) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Initialize quota amount to the value current in the standard information structure.
        //

        *Delta = -(LONGLONG) ((PSTANDARD_INFORMATION) NtfsAttributeValue( Attribute ))->QuotaCharged;

        //
        //  Now continue while there are more attributes to find.
        //

        while (NtfsLookupNextAttributeByVcn( IrpContext, Fcb, &StartVcn, &Context )) {

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  For all user data streams charge for a file record plus any non-resident allocation.
            //  For index streams charge for a file record for the INDEX_ROOT.
            //
            //  For user data look for a resident attribute or the first attribute of a non-resident stream.
            //  Otherwise look for a $I30 stream.
            //

            if (NtfsIsTypeCodeSubjectToQuota( Attribute->TypeCode ) ||
                ((Attribute->TypeCode == $INDEX_ROOT) &&
                 ((Attribute->NameLength * sizeof( WCHAR )) == NtfsFileNameIndex.Length) &&
                 RtlEqualMemory( Add2Ptr( Attribute, Attribute->NameOffset ),
                                 NtfsFileNameIndex.Buffer,
                                 NtfsFileNameIndex.Length ))) {

                //
                //  Always charge for at least one file record.
                //

                *Delta += NtfsResidentStreamQuota( Fcb->Vcb );

                //
                //  Charge for the allocated length for non-resident.
                //

                if (!NtfsIsAttributeResident( Attribute )) {

                    *Delta += Attribute->Form.Nonresident.AllocatedLength;
                }
            }
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    return;
}


VOID
NtfsClearAndVerifyQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine iterates over the quota user data index and verifies the back
    pointer to the owner id index.  It also zeros the quota used field for
    each owner.

Arguments:

    Vcb - Pointer to the volume control block whose index is to be operated
          on.

Return Value:

    None

--*/

{
    INDEX_KEY IndexKey;
    INDEX_ROW OwnerRow;
    MAP_HANDLE MapHandle;
    PQUOTA_USER_DATA UserData;
    PINDEX_ROW QuotaRow;
    PVOID RowBuffer;
    NTSTATUS Status;
    ULONG OwnerId;
    ULONG Count;
    ULONG i;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;
    PINDEX_ROW IndexRow = NULL;
    PREAD_CONTEXT ReadContext = NULL;
    BOOLEAN IndexAcquired = FALSE;

    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Allocate a buffer lager enough for several rows.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

    try {

        //
        //  Allocate a bunch of index row entries.
        //

        Count = PAGE_SIZE / sizeof( QUOTA_USER_DATA );

        IndexRow = NtfsAllocatePool( PagedPool,
                                     Count * sizeof( INDEX_ROW ) );

        //
        //  Iterate through the quota entries.  Start where we left off.
        //

        OwnerId = Vcb->QuotaFileReference.SegmentNumberLowPart;
        IndexKey.KeyLength = sizeof( OwnerId );
        IndexKey.Key = &OwnerId;

        Status = NtOfsReadRecords( IrpContext,
                                   QuotaScb,
                                   &ReadContext,
                                   &IndexKey,
                                   NtOfsMatchAll,
                                   NULL,
                                   &Count,
                                   IndexRow,
                                   PAGE_SIZE,
                                   RowBuffer );


        while (NT_SUCCESS( Status )) {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
            NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
            IndexAcquired = TRUE;

            //
            //  The following assert must be done while the quota resource
            //  held; otherwise a lingering transaction may cause it to
            //

            ASSERT( RtlIsGenericTableEmpty( &Vcb->QuotaControlTable ));

            QuotaRow = IndexRow;

            for (i = 0; i < Count; i += 1, QuotaRow += 1) {

                UserData = QuotaRow->DataPart.Data;

                //
                //  Validate the record is long enough for the Sid.
                //

                IndexKey.KeyLength = RtlLengthSid( &UserData->QuotaSid );

                if ((IndexKey.KeyLength + SIZEOF_QUOTA_USER_DATA > QuotaRow->DataPart.DataLength) ||
                    !RtlValidSid( &UserData->QuotaSid )) {

                    ASSERT( FALSE );

                    //
                    //  The sid is bad delete the record.
                    //

                    NtOfsDeleteRecords( IrpContext,
                                        QuotaScb,
                                        1,
                                        &QuotaRow->KeyPart );

                    continue;
                }

                IndexKey.Key = &UserData->QuotaSid;

                //
                //  Look up the Sid is in the owner id index.
                //

                Status = NtOfsFindRecord( IrpContext,
                                          OwnerIdScb,
                                          &IndexKey,
                                          &OwnerRow,
                                          &MapHandle,
                                          NULL );

                ASSERT( NT_SUCCESS( Status ));

                if (!NT_SUCCESS( Status )) {

                    //
                    //  The owner id entry is missing.  Add one back in.
                    //

                    OwnerRow.KeyPart = IndexKey;
                    OwnerRow.DataPart.DataLength = QuotaRow->KeyPart.KeyLength;
                    OwnerRow.DataPart.Data = QuotaRow->KeyPart.Key;

                    NtOfsAddRecords( IrpContext,
                                     OwnerIdScb,
                                     1,
                                     &OwnerRow,
                                     FALSE );


                } else {

                    //
                    //  Verify that the owner id's match.
                    //

                    if (*((PULONG) QuotaRow->KeyPart.Key) != *((PULONG) OwnerRow.DataPart.Data)) {

                        ASSERT( FALSE );

                        //
                        //  Keep the quota record with the lower
                        //  quota id.  Delete the one with the higher
                        //  quota id.  Note this is the simple approach
                        //  and not best case of the lower id does not
                        //  exist.  In that case a user entry will be delete
                        //  and be reassigned a default quota.
                        //

                        if (*((PULONG) QuotaRow->KeyPart.Key) < *((PULONG) OwnerRow.DataPart.Data)) {

                            //
                            //  Make the ownid's match.
                            //

                            OwnerRow.KeyPart = IndexKey;
                            OwnerRow.DataPart.DataLength = QuotaRow->KeyPart.KeyLength;
                            OwnerRow.DataPart.Data = QuotaRow->KeyPart.Key;

                            NtOfsUpdateRecord( IrpContext,
                                               OwnerIdScb,
                                               1,
                                               &OwnerRow,
                                               NULL,
                                               NULL );

                        } else {

                            //
                            // Delete this record and proceed.
                            //


                            NtOfsDeleteRecords( IrpContext,
                                                QuotaScb,
                                                1,
                                                &QuotaRow->KeyPart );

                            NtOfsReleaseMap( IrpContext, &MapHandle );
                            continue;
                        }
                    }

                    NtOfsReleaseMap( IrpContext, &MapHandle );
                }

                //
                //  Set the quota used to zero.
                //

                UserData->QuotaUsed = 0;
                QuotaRow->DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

                NtOfsUpdateRecord( IrpContext,
                                   QuotaScb,
                                   1,
                                   QuotaRow,
                                   NULL,
                                   NULL );
            }

            //
            //  Release the indexes and commit what has been done so far.
            //

            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
            IndexAcquired = FALSE;

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            //
            //  Remember how far we got so we can restart correctly.
            //

            Vcb->QuotaFileReference.SegmentNumberLowPart = *((PULONG) IndexRow[Count - 1].KeyPart.Key);

            //
            //  Make sure the next free id is beyond the current ids.
            //

            if (Vcb->QuotaOwnerId <= Vcb->QuotaFileReference.SegmentNumberLowPart) {

                ASSERT( Vcb->QuotaOwnerId > Vcb->QuotaFileReference.SegmentNumberLowPart );
                Vcb->QuotaOwnerId = Vcb->QuotaFileReference.SegmentNumberLowPart + 1;
            }

            //
            //  Look up the next set of entries in the quota index.
            //

            Count = PAGE_SIZE / sizeof( QUOTA_USER_DATA );
            Status = NtOfsReadRecords( IrpContext,
                                       QuotaScb,
                                       &ReadContext,
                                       NULL,
                                       NtOfsMatchAll,
                                       NULL,
                                       &Count,
                                       IndexRow,
                                       PAGE_SIZE,
                                       RowBuffer );
        }

        ASSERT( (Status == STATUS_NO_MORE_MATCHES) || (Status == STATUS_NO_MATCH) );

    } finally {

        NtfsFreePool( RowBuffer );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        if (IndexAcquired) {
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (IndexRow != NULL) {
            NtfsFreePool( IndexRow );
        }

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return;
}


NTSTATUS
NtfsClearPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine clears the quota charged field in each file on the volume.  The
    Quata control block is also released in fcb.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Unsed.

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONGLONG NewQuota;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PSTANDARD_INFORMATION StandardInformation;
    PQUOTA_CONTROL_BLOCK QuotaControl = Fcb->QuotaControl;
    PVCB Vcb = Fcb->Vcb;

    UNREFERENCED_PARAMETER( Context);

    PAGED_CODE();

    //
    //  There is nothing to do if the standard info has not been
    //  expanded yet.
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {
        return STATUS_SUCCESS;
    }

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        ASSERT( NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION ));

        NewQuota = 0;

        //
        //  Call to change the attribute value.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  FIELD_OFFSET( STANDARD_INFORMATION, QuotaCharged ),
                                  &NewQuota,
                                  sizeof( StandardInformation->QuotaCharged ),
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  &AttrContext );

        //
        //  Release the quota control block for this fcb.
        //

        if (QuotaControl != NULL) {
            NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return STATUS_SUCCESS;
}


VOID
NtfsDeleteUnsedIds (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine iterates over the quota user data index and removes any
    entries still marked as deleted.

Arguments:

    Vcb - Pointer to the volume control block whoes index is to be operated
          on.

Return Value:

    None

--*/

{
    INDEX_KEY IndexKey;
    PINDEX_KEY KeyPtr;
    PQUOTA_USER_DATA UserData;
    PINDEX_ROW QuotaRow;
    PVOID RowBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG OwnerId;
    ULONG Count;
    ULONG i;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;
    PINDEX_ROW IndexRow = NULL;
    PREAD_CONTEXT ReadContext = NULL;
    BOOLEAN IndexAcquired = FALSE;

    //
    //  Allocate a buffer large enough for several rows.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

    try {

        //
        //  Allocate a bunch of index row entries.
        //

        Count = PAGE_SIZE / sizeof( QUOTA_USER_DATA );

        IndexRow = NtfsAllocatePool( PagedPool,
                                     Count * sizeof( INDEX_ROW ) );

        //
        //  Iterate through the quota entries.  Start where we left off.
        //

        OwnerId = Vcb->QuotaFileReference.SegmentNumberLowPart;
        IndexKey.KeyLength = sizeof( OwnerId );
        IndexKey.Key = &OwnerId;
        KeyPtr = &IndexKey;

        while (NT_SUCCESS( Status )) {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
            NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            IndexAcquired = TRUE;

            //
            //  Make sure the delete secquence number has not changed since
            //  the scan was delete.
            //

            if (ULongToPtr( Vcb->QuotaDeleteSecquence ) != IrpContext->Union.NtfsIoContext) {

                //
                //  The scan needs to be restarted. Set the state to posted
                //  and raise status can not wait which will cause us to retry.
                //

                ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
                SetFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_POSTED );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            Status = NtOfsReadRecords( IrpContext,
                                       QuotaScb,
                                       &ReadContext,
                                       KeyPtr,
                                       NtOfsMatchAll,
                                       NULL,
                                       &Count,
                                       IndexRow,
                                       PAGE_SIZE,
                                       RowBuffer );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            QuotaRow = IndexRow;

            for (i = 0; i < Count; i += 1, QuotaRow += 1) {

                PQUOTA_CONTROL_BLOCK QuotaControl;

                UserData = QuotaRow->DataPart.Data;

                if (!FlagOn( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {
                    continue;
                }

                //
                //  Check to see if there is a quota control entry
                //  for this id.
                //

                ASSERT( FIELD_OFFSET( QUOTA_CONTROL_BLOCK, OwnerId ) <= FIELD_OFFSET( INDEX_ROW, KeyPart.Key ));

                QuotaControl = RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                             CONTAINING_RECORD( &QuotaRow->KeyPart.Key,
                                                                                QUOTA_CONTROL_BLOCK,
                                                                                OwnerId ));

                //
                //  If there is a quota control entry or there is now
                //  some quota charged, then clear the deleted flag
                //  and update the entry.
                //

                if ((QuotaControl != NULL) || (UserData->QuotaUsed != 0)) {

                    ASSERT( (QuotaControl == NULL) && (UserData->QuotaUsed == 0) );

                    ClearFlag( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED );

                    QuotaRow->DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

                    IndexKey.KeyLength = sizeof( OwnerId );
                    IndexKey.Key = &OwnerId;
                    NtOfsUpdateRecord( IrpContext,
                                       QuotaScb,
                                       1,
                                       QuotaRow,
                                       NULL,
                                       NULL );

                    continue;
                }

                //
                //  Delete the user quota data record.
                //

                IndexKey.KeyLength = sizeof( OwnerId );
                IndexKey.Key = &OwnerId;
                NtOfsDeleteRecords( IrpContext,
                                    QuotaScb,
                                    1,
                                    &QuotaRow->KeyPart );

                //
                // Delete the owner id record.
                //

                IndexKey.Key = &UserData->QuotaSid;
                IndexKey.KeyLength = RtlLengthSid( &UserData->QuotaSid );
                NtOfsDeleteRecords( IrpContext,
                                    OwnerIdScb,
                                    1,
                                    &IndexKey );
            }

            //
            //  Release the indexes and commit what has been done so far.
            //

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
            IndexAcquired = FALSE;

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            //
            //  Remember how far we got so we can restart correctly.
            //

            Vcb->QuotaFileReference.SegmentNumberLowPart = *((PULONG) IndexRow[Count - 1].KeyPart.Key);

            KeyPtr = NULL;
        }

        ASSERT( (Status == STATUS_NO_MORE_MATCHES) || (Status == STATUS_NO_MATCH) );

    } finally {

        NtfsFreePool( RowBuffer );

        if (IndexAcquired) {
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (IndexRow != NULL) {
            NtfsFreePool( IndexRow );
        }

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return;
}


VOID
NtfsDereferenceQuotaControlBlock (
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK *QuotaControl
    )

/*++

Routine Description:

    This routine dereferences the quota control block.
    If reference count is now zero the block will be deallocated.

Arguments:

    Vcb - Vcb for the volume that own the quota contorl block.

    QuotaControl - Quota control block to be derefernece.

Return Value:

    None.

--*/

{
    PQUOTA_CONTROL_BLOCK TempQuotaControl;
    LONG ReferenceCount;
    ULONG OwnerId;
    ULONG QuotaControlDeleteCount;

    PAGED_CODE();

    //
    //  Capture the owner id and delete count;
    //

    OwnerId = (*QuotaControl)->OwnerId;
    QuotaControlDeleteCount = Vcb->QuotaControlDeleteCount;

    //
    //  Update the reference count.
    //

    ReferenceCount = InterlockedDecrement( &(*QuotaControl)->ReferenceCount );

    ASSERT( ReferenceCount >= 0 );

    //
    // If the reference count is not zero we are done.
    //

    if (ReferenceCount != 0) {

        //
        //  Clear the pointer from the FCB and return.
        //

        *QuotaControl = NULL;
        return;
    }

    //
    //  Lock the quota table.
    //

    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        //
        //  Now things get messy.  Check the delete count.
        //

        if (QuotaControlDeleteCount != Vcb->QuotaControlDeleteCount) {

            //
            //  This is a bogus assert, but I want to see if this ever occurs.
            //

            ASSERT( QuotaControlDeleteCount != Vcb->QuotaControlDeleteCount );

            //
            //  Something has already been deleted, the old quota control
            //  block may have been deleted already.  Look it up again.
            //

            TempQuotaControl = RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                             CONTAINING_RECORD( &OwnerId,
                                                                                QUOTA_CONTROL_BLOCK,
                                                                                OwnerId ));

            //
            //  The block was already deleted we are done.
            //

            if (TempQuotaControl == NULL) {
                leave;
            }

        } else {

            TempQuotaControl = *QuotaControl;
            ASSERT( TempQuotaControl == RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                                      CONTAINING_RECORD( &OwnerId,
                                                                                         QUOTA_CONTROL_BLOCK,
                                                                                         OwnerId )));
        }

        //
        //  Verify the reference count is still zero.  The reference count
        //  cannot transision from zero to one while the quota table lock is
        //  held.
        //

        if (TempQuotaControl->ReferenceCount != 0) {
            leave;
        }

        //
        //  Increment the delete count.
        //

        InterlockedIncrement( &Vcb->QuotaControlDeleteCount );

        NtfsFreePool( TempQuotaControl->QuotaControlLock );
        RtlDeleteElementGenericTable( &Vcb->QuotaControlTable,
                                      TempQuotaControl );

    } finally {

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        *QuotaControl = NULL;
    }

    return;
}


VOID
NtfsFixupQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine ensures that the charged field is correct in the
    standard information attribute of a file.  If there is a problem
    the it is fixed.

Arguments:

    Fcb - Pointer to the FCB of the file being opened.

Return Value:

    NONE

--*/

{
    LONGLONG Delta = 0;

    PAGED_CODE();

    ASSERT( FlagOn( Fcb->Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED ));
    ASSERT( NtfsIsExclusiveFcb( Fcb ));

    if (Fcb->OwnerId != QUOTA_INVALID_ID) {

        ASSERT( Fcb->QuotaControl == NULL );

        Fcb->QuotaControl = NtfsInitializeQuotaControlBlock( Fcb->Vcb, Fcb->OwnerId );
    }

    if ((NtfsPerformQuotaOperation( Fcb )) && (!NtfsIsVolumeReadOnly( Fcb->Vcb ))) {

        NtfsCalculateQuotaAdjustment( IrpContext, Fcb, &Delta );

        ASSERT( NtfsAllowFixups || FlagOn( Fcb->Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING ) || (Delta == 0) );

        if (Delta != 0) {
#if DBG

            if (IrpContext->OriginatingIrp != NULL ) {
                PFILE_OBJECT FileObject;

                FileObject = IoGetCurrentIrpStackLocation(
                                IrpContext->OriginatingIrp )->FileObject;

                if (FileObject != NULL && FileObject->FileName.Buffer != NULL) {
                    DebugTrace( 0, Dbg, ( "NtfsFixupQuota: Quota fix up required on %Z of %I64x bytes\n",
                              &FileObject->FileName,
                              Delta ));
                }
            }
#endif

            NtfsUpdateFileQuota( IrpContext, Fcb, &Delta, TRUE, FALSE );
        }
    }

    return;
}


NTSTATUS
NtfsFsQuotaQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingId,
    IN BOOLEAN ReturnSingleEntry,
    IN OUT PFILE_QUOTA_INFORMATION *QuotaInfoOutBuffer,
    IN OUT PULONG Length,
    IN OUT PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine returns the quota information for the volume.

Arguments:

    Vcb - Volume control block for the volume to be quered.

    StartingId - Owner Id after which to start the listing.

    ReturnSingleEntry - Indicates only one entry should be returned.

    QuotaInfoOutBuffer - Buffer to return the data. On return, points at the
    last good entry copied.

    Length - In the size of the buffer. Out the amount of space remaining.

    Ccb - Optional Ccb which is updated with the last returned owner id.

Return Value:

    Returns the status of the operation.

--*/

{
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    PINDEX_KEY KeyPtr;
    PQUOTA_USER_DATA UserData;
    PVOID RowBuffer;
    NTSTATUS Status;
    ULONG OwnerId;
    ULONG Count = 1;
    PREAD_CONTEXT ReadContext = NULL;
    ULONG UserBufferLength = *Length;
    PFILE_QUOTA_INFORMATION OutBuffer = *QuotaInfoOutBuffer;

    PAGED_CODE();

    if (UserBufferLength < sizeof(FILE_QUOTA_INFORMATION)) {

        //
        //  The user buffer is way too small.
        //

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Return nothing if quotas are not enabled.
    //

    if (Vcb->QuotaTableScb == NULL) {

        return STATUS_SUCCESS;
    }

    //
    //  Allocate a buffer large enough for the largest quota entry and key.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, MAXIMUM_QUOTA_ROW );

    //
    //  Look up each entry in the quota index start with the next
    //  requested owner id.
    //

    OwnerId = StartingId + 1;

    if (OwnerId < QUOTA_FISRT_USER_ID) {
        OwnerId = QUOTA_FISRT_USER_ID;
    }

    IndexKey.KeyLength = sizeof( OwnerId );
    IndexKey.Key = &OwnerId;
    KeyPtr = &IndexKey;

    try {

        while (NT_SUCCESS( Status = NtOfsReadRecords( IrpContext,
                                                      Vcb->QuotaTableScb,
                                                      &ReadContext,
                                                      KeyPtr,
                                                      NtOfsMatchAll,
                                                      NULL,
                                                      &Count,
                                                      &IndexRow,
                                                      MAXIMUM_QUOTA_ROW,
                                                      RowBuffer ))) {

            ASSERT( Count == 1 );

            KeyPtr = NULL;
            UserData = IndexRow.DataPart.Data;

            //
            //  Skip this entry if it has been deleted.
            //

            if (FlagOn( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {
                continue;
            }

            if (!NT_SUCCESS( Status = NtfsPackQuotaInfo(&UserData->QuotaSid,
                                                        UserData,
                                                        OutBuffer,
                                                        &UserBufferLength ))) {
                break;
            }

            //
            //  Remember the owner id of the last entry returned.
            //

            OwnerId = *((PULONG) IndexRow.KeyPart.Key);

            if (ReturnSingleEntry) {
                break;
            }

            *QuotaInfoOutBuffer = OutBuffer;
            OutBuffer = Add2Ptr( OutBuffer, OutBuffer->NextEntryOffset );
        }

        //
        //  If we're returning at least one entry, it's a SUCCESS.
        //

        if (UserBufferLength != *Length) {

            Status =  STATUS_SUCCESS;

            //
            //  Set the next entry offset to zero to
            //  indicate list termination. If we are only returning a
            //  single entry, it makes more sense to let the caller
            //  take care of it.
            //

            if (!ReturnSingleEntry) {

                (*QuotaInfoOutBuffer)->NextEntryOffset = 0;
            }

            if (Ccb != NULL) {
                Ccb->LastOwnerId = OwnerId;
            }

            //
            //  Return how much of the buffer was used up.
            //  QuotaInfoOutBuffer already points at the last good entry.
            //

            *Length = UserBufferLength;

        } else if (Status != STATUS_BUFFER_OVERFLOW) {

            //
            //  We return NO_MORE_ENTRIES if we aren't returning any
            //  entries (even when the buffer was large enough).
            //

            Status = STATUS_NO_MORE_ENTRIES;
        }

    } finally {

        NtfsFreePool( RowBuffer );

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return Status;
}


NTSTATUS
NtfsFsQuotaSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine sets the quota information on the volume for the
    owner pasted in from the user buffer.

Arguments:

    Vcb - Volume control block for the volume to be changed.

    FileQuotaInfo - Buffer to return the data.

    Length - The size of the buffer in bytes.

Return Value:

    Returns the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LengthUsed = 0;

    PAGED_CODE();

    //
    //  Return nothing if quotas are not enabled.
    //

    if (Vcb->QuotaTableScb == NULL) {

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    //  Validate the entire buffer before doing any work.
    //

    Status = IoCheckQuotaBufferValidity( FileQuotaInfo,
                                         Length,
                                         &LengthUsed );

    IrpContext->OriginatingIrp->IoStatus.Information = LengthUsed;

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    LengthUsed = 0;

    //
    //  Perform the requested updates.
    //

    while (TRUE) {

        //
        //  Make sure that the administrator limit is not being changed.
        //

        if (RtlEqualSid( SeExports->SeAliasAdminsSid, &FileQuotaInfo->Sid ) &&
            (FileQuotaInfo->QuotaLimit.QuadPart != -1)) {

            //
            //  Reject the request with access denied.
            //

            NtfsRaiseStatus( IrpContext, STATUS_ACCESS_DENIED, NULL, NULL );

        }

        if (FileQuotaInfo->QuotaLimit.QuadPart == -2) {

            Status = NtfsPrepareForDelete( IrpContext,
                                           Vcb,
                                           &FileQuotaInfo->Sid );

            if (!NT_SUCCESS( Status )) {
                break;
            }

        } else {

            NtfsGetOwnerId( IrpContext,
                            &FileQuotaInfo->Sid,
                            TRUE,
                            FileQuotaInfo );
        }

        if (FileQuotaInfo->NextEntryOffset == 0) {
            break;
        }

        //
        //  Advance to the next entry.
        //

        FileQuotaInfo = Add2Ptr( FileQuotaInfo, FileQuotaInfo->NextEntryOffset);
    }

    //
    //  If the quota tracking has been requested and the quotas need to be
    //  repaired then try to repair them now.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED ) &&
        FlagOn( Vcb->QuotaFlags,
                (QUOTA_FLAG_OUT_OF_DATE |
                 QUOTA_FLAG_CORRUPT |
                 QUOTA_FLAG_PENDING_DELETES) )) {

        NtfsPostRepairQuotaIndex( IrpContext, Vcb );
    }

    return Status;
}


NTSTATUS
NtfsQueryQuotaUserSidList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_GET_QUOTA_INFORMATION SidList,
    IN OUT PFILE_QUOTA_INFORMATION QuotaInfoOutBuffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine query for the quota data for each user specified in the
    user provided sid list.

Arguments:

    Vcb - Supplies a pointer to the volume control block.

    SidList - Supplies a pointer to the Sid list.  The list has already
              been validated.

    QuotaInfoOutBuffer - Indicates where the retrived query data should be placed.

    BufferLength - Indicates that size of the buffer, and is updated with the
                  amount of data actually placed in the buffer.

    ReturnSingleEntry - Indicates if just one entry should be returned.

Return Value:

    Returns the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesRemaining = *BufferLength;
    PFILE_QUOTA_INFORMATION LastEntry = QuotaInfoOutBuffer;
    ULONG OwnerId;

    PAGED_CODE( );

    //
    //  Loop through each of the entries.
    //

    while (TRUE) {

        //
        //  Get the owner id.
        //

        OwnerId = NtfsGetOwnerId( IrpContext,
                                  &SidList->Sid,
                                  FALSE,
                                  NULL );

       if (OwnerId != QUOTA_INVALID_ID) {

            //
            //  Send ownerid and ask for a single entry.
            //

            Status = NtfsFsQuotaQueryInfo( IrpContext,
                                           Vcb,
                                           OwnerId - 1,
                                           TRUE,
                                           &QuotaInfoOutBuffer,
                                           &BytesRemaining,
                                           NULL );

        } else {

            //
            //  Send back zeroed data alongwith the Sid.
            //

            Status = NtfsPackQuotaInfo( &SidList->Sid,
                                        NULL,
                                        QuotaInfoOutBuffer,
                                        &BytesRemaining );
        }

        //
        //  Bail out if we got a real error.
        //

        if (!NT_SUCCESS( Status ) && (Status != STATUS_NO_MORE_ENTRIES)) {

            break;
        }

        if (ReturnSingleEntry) {

            break;
        }

        //
        //  Make a note of the last entry filled in.
        //

        LastEntry = QuotaInfoOutBuffer;

        //
        //  If we've exhausted the SidList, we're done
        //

        if (SidList->NextEntryOffset == 0) {
            break;
        }

        SidList =  Add2Ptr( SidList, SidList->NextEntryOffset );

        ASSERT(QuotaInfoOutBuffer->NextEntryOffset > 0);
        QuotaInfoOutBuffer = Add2Ptr( QuotaInfoOutBuffer,
                                      QuotaInfoOutBuffer->NextEntryOffset );
    }

    //
    //  Set the next entry offset to zero to
    //  indicate list termination.
    //

    if (BytesRemaining != *BufferLength) {

        LastEntry->NextEntryOffset = 0;
        Status =  STATUS_SUCCESS;
    }

    //
    //  Update the buffer length to reflect what's left.
    //  If we've copied anything at all, we must return SUCCESS.
    //

    ASSERT( (BytesRemaining == *BufferLength) || (Status == STATUS_SUCCESS ) );
    *BufferLength = BytesRemaining;

    return Status;
}


NTSTATUS
NtfsPackQuotaInfo (
    IN PSID Sid,
    IN PQUOTA_USER_DATA QuotaUserData OPTIONAL,
    IN PFILE_QUOTA_INFORMATION OutBuffer,
    IN OUT PULONG OutBufferSize
    )

/*++
Routine Description:

    This is an internal routine that fills a given FILE_QUOTA_INFORMATION
    structure with information from a given QUOTA_USER_DATA structure.

Arguments:

    Sid - SID to be copied. Same as the one embedded inside the USER_DATA struct.
    This routine doesn't care if it's a valid sid.

    QuotaUserData - Source of data

    QuotaInfoBufferPtr - Buffer to have user data copied in to.

    OutBufferSize - IN size of the buffer, OUT size of the remaining buffer.
--*/

{
    ULONG SidLength;
    ULONG NextOffset;
    ULONG EntrySize;

    SidLength = RtlLengthSid( Sid );
    EntrySize = SidLength +  FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid );

    //
    //  Abort if this entry won't fit in the buffer.
    //

    if (*OutBufferSize < EntrySize) {

        return STATUS_BUFFER_OVERFLOW;
    }

    if (ARGUMENT_PRESENT(QuotaUserData)) {

        //
        //  Fill in the user buffer for this entry.
        //

        OutBuffer->ChangeTime.QuadPart = QuotaUserData->QuotaChangeTime;
        OutBuffer->QuotaUsed.QuadPart = QuotaUserData->QuotaUsed;
        OutBuffer->QuotaThreshold.QuadPart = QuotaUserData->QuotaThreshold;
        OutBuffer->QuotaLimit.QuadPart = QuotaUserData->QuotaLimit;

    } else {

        //
        //  Return all zeros for the data, up until the Sid.
        //

        RtlZeroMemory( OutBuffer, FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid) );
    }

    OutBuffer->SidLength = SidLength;
    RtlCopyMemory( &OutBuffer->Sid,
                   Sid,
                   SidLength );

    //
    //  Calculate the next offset.
    //

    NextOffset = QuadAlign( EntrySize );

    //
    //  Add the offset to the amount used.
    //  NextEntryOffset may be sligthly larger than Length due to
    //  rounding of the previous entry size to longlong.
    //

    if (*OutBufferSize > NextOffset) {

        *OutBufferSize -= NextOffset;
        OutBuffer->NextEntryOffset = NextOffset;

    } else {

        //
        //  We did have enough room for this entry, but quad-alignment made
        //  it look like we didn't. Return the last few bytes left
        //  (what we lost in rounding up) just for correctness, although
        //  those really won't be of much use. The NextEntryOffset will be
        //  zeroed subsequently by the caller.
        //  Note that the OutBuffer is pointing at the _beginning_ of the
        //  last entry returned in this case.
        //

        ASSERT( *OutBufferSize >= EntrySize );
        *OutBufferSize -= EntrySize;
        OutBuffer->NextEntryOffset = EntrySize;
    }

    return STATUS_SUCCESS;
}


ULONG
NtfsGetOwnerId (
    IN PIRP_CONTEXT IrpContext,
    IN PSID Sid,
    IN BOOLEAN CreateNew,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo OPTIONAL
    )

/*++

Routine Description:

    This routine determines the owner id for the requested SID.  First the
    Sid is looked up in the Owner Id index.  If the entry exists, then that
    owner id is returned.  If the sid does not exist then  new entry is
    created in the owner id index.

Arguments:

    Sid - Security id to determine the owner id.

    CreateNew - Create a new id if necessary.

    FileQuotaInfo - Optional quota data to update quota index with.

Return Value:

    ULONG - Owner Id for the security id. QUOTA_INVALID_ID is returned if id
        did not exist and CreateNew was FALSE.

--*/

{
    ULONG OwnerId;
    ULONG DefaultId;
    ULONG SidLength;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    PQUOTA_USER_DATA NewQuotaData = NULL;
    QUICK_INDEX_HINT QuickIndexHint;
    PSCB QuotaScb;
    PVCB Vcb = IrpContext->Vcb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;

    BOOLEAN ExistingRecord;

    PAGED_CODE();

    //
    //  Determine the Sid length.
    //

    SidLength = RtlLengthSid( Sid );

    IndexKey.KeyLength = SidLength;
    IndexKey.Key = Sid;

    //
    //  If there is quota information to update or there are pending deletes
    //  then long path must be taken where the user quota entry is found.
    //

    if (FileQuotaInfo == NULL) {

        //
        //  Acquire the owner id index shared.
        //

        NtfsAcquireSharedScb( IrpContext, OwnerIdScb );

        try {

            //
            //  Assume the Sid is in the index.
            //

            Status = NtOfsFindRecord( IrpContext,
                                      OwnerIdScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      NULL );

            //
            //  If the sid was found then capture is value.
            //

            if (NT_SUCCESS( Status )) {

                ASSERT( IndexRow.DataPart.DataLength == sizeof( ULONG ));
                OwnerId = *((PULONG) IndexRow.DataPart.Data);

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );
            }

        } finally {
            NtfsReleaseScb( IrpContext, OwnerIdScb );
        }

        //
        //  If the sid was found and there are no pending deletes, we are done.
        //

        if (NT_SUCCESS(Status)) {

            if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {
                return OwnerId;
            }

            //
            //  Look up the actual record to see if it is deleted.
            //

            QuotaScb = Vcb->QuotaTableScb;
            NtfsAcquireSharedScb( IrpContext, QuotaScb );

            try {

                IndexKey.KeyLength = sizeof(ULONG);
                IndexKey.Key = &OwnerId;

                Status = NtOfsFindRecord( IrpContext,
                                          QuotaScb,
                                          &IndexKey,
                                          &IndexRow,
                                          &MapHandle,
                                          NULL );

                if (!NT_SUCCESS( Status )) {

                    ASSERT( NT_SUCCESS( Status ));
                    NtfsMarkQuotaCorrupt( IrpContext, Vcb );
                    OwnerId = QUOTA_INVALID_ID;
                    leave;
                }

                if (FlagOn( ((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaFlags,
                            QUOTA_FLAG_ID_DELETED )) {

                    //
                    //  Return invalid user.
                    //

                    OwnerId = QUOTA_INVALID_ID;
                }

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );

            } finally {

                NtfsReleaseScb( IrpContext, QuotaScb );
            }

            //
            //  If an active id was found or caller does not want a new
            //  created then return.
            //

            if ((OwnerId != QUOTA_INVALID_ID) || !CreateNew) {
                return OwnerId;
            }

        } else if (!CreateNew) {

            //
            //  Just return QUOTA_INVALID_ID.
            //

            return QUOTA_INVALID_ID;
        }
    }

    //
    //  If we have the quotatable resource, we should have it exclusively.
    //

    ASSERT( CreateNew );
    ASSERT( !ExIsResourceAcquiredSharedLite( Vcb->QuotaTableScb->Fcb->Resource ) ||
            ExIsResourceAcquiredExclusiveLite( Vcb->QuotaTableScb->Fcb->Resource ));

    //
    //  Acquire Owner id and quota index exclusive.
    //

    QuotaScb = Vcb->QuotaTableScb;
    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );

    NtOfsInitializeMapHandle( &MapHandle );

    try {

        //
        //  Verify that the sid is still not in the index.
        //

        IndexKey.KeyLength = SidLength;
        IndexKey.Key = Sid;

        Status = NtOfsFindRecord( IrpContext,
                                  OwnerIdScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        //
        //  If the sid was found then capture the owner id.
        //

        ExistingRecord = NT_SUCCESS(Status);

        if (ExistingRecord) {

            ASSERT( IndexRow.DataPart.DataLength == sizeof( ULONG ));
            OwnerId = *((PULONG) IndexRow.DataPart.Data);

            if ((FileQuotaInfo == NULL) &&
                !FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

                leave;
            }

            //
            //  Release the index map handle.
            //

            NtOfsReleaseMap( IrpContext, &MapHandle );

        } else {

            //
            //  Allocate a new owner id and update the owner index.
            //

            OwnerId = Vcb->QuotaOwnerId;
            Vcb->QuotaOwnerId += 1;

            IndexRow.KeyPart.KeyLength = SidLength;
            IndexRow.KeyPart.Key = Sid;
            IndexRow.DataPart.Data = &OwnerId;
            IndexRow.DataPart.DataLength = sizeof(OwnerId);

            NtOfsAddRecords( IrpContext,
                             OwnerIdScb,
                             1,
                             &IndexRow,
                             FALSE );
        }

        //
        //  Allocate space for the new quota user data.
        //

        NewQuotaData = NtfsAllocatePool( PagedPool,
                                         SIZEOF_QUOTA_USER_DATA + SidLength);

        if (ExistingRecord) {

            //
            //  Find the existing record and update it.
            //

            IndexKey.KeyLength = sizeof( ULONG );
            IndexKey.Key = &OwnerId;

            RtlZeroMemory( &QuickIndexHint, sizeof( QuickIndexHint ));

            Status = NtOfsFindRecord( IrpContext,
                                      QuotaScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      &QuickIndexHint );

            if (!NT_SUCCESS( Status )) {

                ASSERT( NT_SUCCESS( Status ));
                NtfsMarkQuotaCorrupt( IrpContext, Vcb );
                OwnerId = QUOTA_INVALID_ID;
                leave;
            }

            ASSERT( IndexRow.DataPart.DataLength == SIZEOF_QUOTA_USER_DATA + SidLength );

            RtlCopyMemory( NewQuotaData, IndexRow.DataPart.Data, IndexRow.DataPart.DataLength );

            ASSERT( RtlEqualMemory( &NewQuotaData->QuotaSid, Sid, SidLength ));

            //
            //  Update the changed fields in the record.
            //

            if (FileQuotaInfo != NULL) {

                ClearFlag( NewQuotaData->QuotaFlags, QUOTA_FLAG_DEFAULT_LIMITS );
                NewQuotaData->QuotaThreshold = FileQuotaInfo->QuotaThreshold.QuadPart;
                NewQuotaData->QuotaLimit = FileQuotaInfo->QuotaLimit.QuadPart;
                KeQuerySystemTime( (PLARGE_INTEGER) &NewQuotaData->QuotaChangeTime );

            } else if (!FlagOn( NewQuotaData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {

                //
                //  There is nothing to update just return.
                //

                leave;
            }

            //
            //  Always clear the deleted flag.
            //

            ClearFlag( NewQuotaData->QuotaFlags, QUOTA_FLAG_ID_DELETED );
            ASSERT( (OwnerId != Vcb->AdministratorId) || (NewQuotaData->QuotaLimit == -1) );

            //
            // The key length does not change.
            //

            IndexRow.KeyPart.Key = &OwnerId;
            ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
            IndexRow.DataPart.Data = NewQuotaData;
            IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

            NtOfsUpdateRecord( IrpContext,
                               QuotaScb,
                               1,
                               &IndexRow,
                               &QuickIndexHint,
                               &MapHandle );

            leave;
        }

        if (FileQuotaInfo == NULL) {

            //
            //  Look up the default quota limits.
            //

            DefaultId = QUOTA_DEFAULTS_ID;
            IndexKey.KeyLength = sizeof( ULONG );
            IndexKey.Key = &DefaultId;

            Status = NtOfsFindRecord( IrpContext,
                                      QuotaScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      NULL );

            if (!NT_SUCCESS( Status )) {

                ASSERT( NT_SUCCESS( Status ));
                NtfsRaiseStatus( IrpContext,
                                 STATUS_QUOTA_LIST_INCONSISTENT,
                                 NULL,
                                 Vcb->QuotaTableScb->Fcb );
            }

            ASSERT( IndexRow.DataPart.DataLength >= SIZEOF_QUOTA_USER_DATA );

            //
            //  Initialize the new quota entry with the defaults.
            //

            RtlCopyMemory( NewQuotaData,
                           IndexRow.DataPart.Data,
                           SIZEOF_QUOTA_USER_DATA );

            ClearFlag( NewQuotaData->QuotaFlags, ~QUOTA_FLAG_USER_MASK );

        } else {

            //
            //  Initialize the new record with the new data.
            //

            RtlZeroMemory( NewQuotaData, SIZEOF_QUOTA_USER_DATA );

            NewQuotaData->QuotaVersion = QUOTA_USER_VERSION;
            NewQuotaData->QuotaThreshold = FileQuotaInfo->QuotaThreshold.QuadPart;
            NewQuotaData->QuotaLimit = FileQuotaInfo->QuotaLimit.QuadPart;
        }

        ASSERT( !RtlEqualSid( SeExports->SeAliasAdminsSid, Sid ) ||
                (NewQuotaData->QuotaThreshold == -1) );

        //
        //  Copy the Sid into the new record.
        //

        RtlCopyMemory( &NewQuotaData->QuotaSid, Sid, SidLength );
        KeQuerySystemTime( (PLARGE_INTEGER) &NewQuotaData->QuotaChangeTime );

        //
        //  Add the new quota data record to the index.
        //

        IndexRow.KeyPart.KeyLength = sizeof( ULONG );
        IndexRow.KeyPart.Key = &OwnerId;
        IndexRow.DataPart.Data = NewQuotaData;
        IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA + SidLength;

        NtOfsAddRecords( IrpContext,
                         QuotaScb,
                         1,
                         &IndexRow,
                         TRUE );

    } finally {

        if (NewQuotaData != NULL) {
            NtfsFreePool( NewQuotaData );
        }

        //
        //  Release the index map handle and index resources.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, QuotaScb );
        NtfsReleaseScb( IrpContext, OwnerIdScb );
    }

    return OwnerId;
}


VOID
NtfsGetRemainingQuota (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG OwnerId,
    OUT PULONGLONG RemainingQuota,
    OUT PULONGLONG TotalQuota,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
    )

/*++

Routine Description:

    This routine returns the remaining amount of quota a user has before a
    the quota limit is reached.

Arguments:

    Fcb - Fcb whose quota usage is being checked.

    OwnerId - Supplies the owner id to look up.

    RemainingQuota - Returns the remaining amount of quota in bytes.

    TotalQuota - Returns the total amount of quota in bytes for the given sid.

    QuickIndexHint - Supplies an optional hint where to look of the value.

Return Value:

    None

--*/

{
    PQUOTA_USER_DATA UserData;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    NTSTATUS Status;
    PVCB Vcb = IrpContext->Vcb;

    PAGED_CODE();

    //
    //  Initialize the map handle.
    //

    NtOfsInitializeMapHandle( &MapHandle );
    NtfsAcquireSharedScb( IrpContext, Vcb->QuotaTableScb );

    try {

        IndexKey.KeyLength = sizeof(ULONG);
        IndexKey.Key = &OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  QuickIndexHint );

        if (!NT_SUCCESS( Status )) {

            //
            //  This look up should not fail.
            //

            ASSERT( NT_SUCCESS( Status ));

            //
            //  There is one case where this could occur.  That is a
            //  owner id could be deleted while this ccb was in use.
            //

            *RemainingQuota = 0;
            *TotalQuota = 0;
            leave;
        }

        UserData = IndexRow.DataPart.Data;

        if (UserData->QuotaUsed >= UserData->QuotaLimit) {

            *RemainingQuota = 0;

        } else {

            *RemainingQuota = UserData->QuotaLimit - UserData->QuotaUsed;
        }

        *TotalQuota = UserData->QuotaLimit;

    } finally {

        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }

    return;
}


PQUOTA_CONTROL_BLOCK
NtfsInitializeQuotaControlBlock (
    IN PVCB Vcb,
    IN ULONG OwnerId
    )

/*++

Routine Description:

    This routine returns the quota control block field specified owner.  First
    a lookup is done in the quota control table for an existing quota control
    block.  If there is no quota control block, then a new one is created.

Arguments:

    Vcb - Supplies the volume control block.

    OwnerId - Supplies the requested owner id.

Return Value:

    Returns a quota control block for the owner.

--*/

{
    PQUOTA_CONTROL_BLOCK QuotaControl;
    BOOLEAN NewEntry;
    PQUOTA_CONTROL_BLOCK InitQuotaControl;
    PFAST_MUTEX Lock = NULL;
    PVOID NodeOrParent;
    TABLE_SEARCH_RESULT SearchResult;

    PAGED_CODE();

    ASSERT( OwnerId != 0 );

    //
    //  Lock the quota table.
    //

    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        InitQuotaControl = Vcb->QuotaControlTemplate;
        InitQuotaControl->OwnerId = OwnerId;

        QuotaControl = RtlLookupElementGenericTableFull( &Vcb->QuotaControlTable,
                                                         InitQuotaControl,
                                                         &NodeOrParent,
                                                         &SearchResult );

        if (QuotaControl == NULL) {

            //
            //  Allocate and initialize the lock.
            //

            Lock = NtfsAllocatePoolWithTag( NonPagedPool,
                                            sizeof( FAST_MUTEX ),
                                            'QftN' );

            ExInitializeFastMutex( Lock );

            //
            //  Insert table element into table.
            //

            QuotaControl = RtlInsertElementGenericTableFull( &Vcb->QuotaControlTable,
                                                             InitQuotaControl,
                                                             sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA,
                                                             &NewEntry,
                                                             NodeOrParent,
                                                             SearchResult );

            ASSERT( IsQuadAligned( &QuotaControl->QuickIndexHint ));

            QuotaControl->QuotaControlLock = Lock;
            Lock = NULL;
        }

        //
        //  Update the reference count and add set the pointer in the Fcb.
        //

        InterlockedIncrement( &QuotaControl->ReferenceCount );

        ASSERT( OwnerId == QuotaControl->OwnerId );

    } finally {

        //
        //  Clean up.
        //

        if (Lock != NULL) {
            NtfsFreePool( Lock );
        }

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

    }

    return QuotaControl;
}


VOID
NtfsInitializeQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the quota index for the volume.  If the index does not
    exist it is created and initialized.

Arguments:

    Fcb - Pointer to Fcb for the quota file.

    Vcb - Volume control block for volume be mounted.

Return Value:

    None

--*/

{
    ULONG Key;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    MAP_HANDLE MapHandle;
    QUOTA_USER_DATA QuotaData;
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$Q" );

    PAGED_CODE();

    //
    //  Initialize quota table and fast mutex.
    //

    ExInitializeFastMutex( &Vcb->QuotaControlLock );

    RtlInitializeGenericTable( &Vcb->QuotaControlTable,
                               NtfsQuotaTableCompare,
                               NtfsQuotaTableAllocate,
                               NtfsQuotaTableFree,
                               NULL );

ReInitializeQuotaIndex:

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      IndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_ULONG,
                      NtOfsCollateUlong,
                      NULL,
                      &Vcb->QuotaTableScb );

    IndexName.Buffer = L"$O";

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      IndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_SID,
                      NtOfsCollateSid,
                      NULL,
                      &Vcb->OwnerIdTableScb );

    //
    //  Find the next owner id to allocate.
    //

    NtfsAcquireExclusiveScb( IrpContext, Vcb->QuotaTableScb );

    try {

        //
        //  Initialize quota delete secquence number.
        //

        Vcb->QuotaDeleteSecquence = 1;

        //
        //  Load the quota flags.
        //

        Key = QUOTA_DEFAULTS_ID;
        IndexRow.KeyPart.KeyLength = sizeof( ULONG );
        IndexRow.KeyPart.Key = &Key;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexRow.KeyPart,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL);

        if (NT_SUCCESS( Status )) {

            //
            //  Make sure this is the correct version.
            //

            if (((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaVersion > QUOTA_USER_VERSION) {

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );

                //
                //  Wrong version close the quota index this will
                //  pervent use from doing anything with quotas.
                //

                NtOfsCloseIndex( IrpContext, Vcb->QuotaTableScb );
                Vcb->QuotaTableScb = NULL;

                leave;
            }

            //
            //  If this is an old version delete it.
            //

            if (((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaVersion < QUOTA_USER_VERSION) {

                DebugTrace( 0, Dbg, ( "NtfsInitializeQuotaIndex: Deleting version 1 quota index\n" ));

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );

                //
                // Increment the cleanup count so the FCB does not
                // go away.
                //

                Fcb->CleanupCount += 1;

                //
                //  This is an old version of the quota file
                //  delete it the owner id index and start over again.
                //

                NtOfsDeleteIndex( IrpContext, Fcb, Vcb->QuotaTableScb );

                NtOfsCloseIndex( IrpContext, Vcb->QuotaTableScb );
                Vcb->QuotaTableScb = NULL;

                //
                //  Delete the owner index too.
                //

                NtOfsDeleteIndex( IrpContext, Fcb, Vcb->OwnerIdTableScb );

                NtOfsCloseIndex( IrpContext, Vcb->OwnerIdTableScb );
                Vcb->OwnerIdTableScb = NULL;

                NtfsCommitCurrentTransaction( IrpContext );

                //
                // Restore the cleanup count
                //

                Fcb->CleanupCount -= 1;

                IndexName.Buffer = L"$Q";

                goto ReInitializeQuotaIndex;
            }

            //
            //  The index already exists, just initialize the quota
            //  fields in the VCB.
            //

            Vcb->QuotaFlags = ((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaFlags;

            //
            //  Release the index map handle.
            //

            NtOfsReleaseMap( IrpContext, &MapHandle );

        } else if (Status == STATUS_NO_MATCH) {

            //
            //  The index was newly created.
            //  Create a default quota data row.
            //

            Key = QUOTA_DEFAULTS_ID;

            RtlZeroMemory( &QuotaData, sizeof( QUOTA_USER_DATA ));

            //
            //  Indicate that the quota needs to be rebuilt.
            //

            QuotaData.QuotaVersion = QUOTA_USER_VERSION;

            QuotaData.QuotaFlags = QUOTA_FLAG_DEFAULT_LIMITS;

            QuotaData.QuotaThreshold = MAXULONGLONG;
            QuotaData.QuotaLimit = MAXULONGLONG;
            KeQuerySystemTime( (PLARGE_INTEGER) &QuotaData.QuotaChangeTime );

            IndexRow.KeyPart.KeyLength = sizeof( ULONG );
            IndexRow.KeyPart.Key = &Key;
            IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;
            IndexRow.DataPart.Data = &QuotaData;

            NtOfsAddRecords( IrpContext,
                             Vcb->QuotaTableScb,
                             1,
                             &IndexRow,
                             TRUE );

            Vcb->QuotaOwnerId = QUOTA_FISRT_USER_ID;

            Vcb->QuotaFlags = QuotaData.QuotaFlags;
        }

        Key = MAXULONG;
        IndexRow.KeyPart.KeyLength = sizeof( ULONG );
        IndexRow.KeyPart.Key = &Key;

        Status = NtOfsFindLastRecord( IrpContext,
                                      Vcb->QuotaTableScb,
                                      &IndexRow.KeyPart,
                                      &IndexRow,
                                      &MapHandle );

        if (!NT_SUCCESS( Status )) {

            //
            //  This call should never fail.
            //

            ASSERT( NT_SUCCESS( Status) );
            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_CORRUPT);
            leave;
        }

        Key = *((PULONG) IndexRow.KeyPart.Key) + 1;

        if (Key < QUOTA_FISRT_USER_ID) {
            Key = QUOTA_FISRT_USER_ID;
        }

        Vcb->QuotaOwnerId = Key;

        //
        //  Release the index map handle.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );

        //
        //  Get the administrator ID so it can be protected from quota
        //  limits.
        //

        Vcb->AdministratorId = NtfsGetOwnerId( IrpContext,
                                               SeExports->SeAliasAdminsSid,
                                               TRUE,
                                               NULL );

        if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED )) {

            //
            //  Allocate and initialize the template control block.
            //  Allocate enough space in the quota control block for the index
            //  data part. This is used as the new record when calling update
            //  record.  This template is only allocated once and then it is
            //  saved in the vcb.
            //

            Vcb->QuotaControlTemplate = NtfsAllocatePoolWithTag( PagedPool,
                                                                 sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA,
                                                                 'QftN' );

            RtlZeroMemory( Vcb->QuotaControlTemplate,
                           sizeof( QUOTA_CONTROL_BLOCK ) +
                           SIZEOF_QUOTA_USER_DATA );

            Vcb->QuotaControlTemplate->NodeTypeCode = NTFS_NTC_QUOTA_CONTROL;
            Vcb->QuotaControlTemplate->NodeByteSize = sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA;
        }

        //
        //  Fix up the quota on the root directory.
        //

        NtfsConditionallyFixupQuota( IrpContext, Vcb->RootIndexScb->Fcb );

    } finally {

        if (Vcb->QuotaTableScb != NULL) {
            NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
        }
    }

    //
    //  If the quota tracking has been requested and the quotas need to be
    //  repaired then try to repair them now.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED) &&
        FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE | QUOTA_FLAG_CORRUPT | QUOTA_FLAG_PENDING_DELETES )) {
        NtfsPostRepairQuotaIndex( IrpContext, Vcb );
    }

    return;
}


VOID
NtfsMarkUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine marks a user's quota data entry to indicate that the user
    has exceeded quota.  The event is also logged.

Arguments:

    Context - Supplies a pointer to the referenced quota control block.

Return Value:

    None.

--*/

{
    PQUOTA_CONTROL_BLOCK QuotaControl = Context;
    PVCB Vcb = IrpContext->Vcb;
    LARGE_INTEGER CurrentTime;
    PQUOTA_USER_DATA UserData;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    NTSTATUS Status;
    BOOLEAN QuotaTableAcquired = FALSE;

    PAGED_CODE();

    DebugTrace( 0, Dbg, ( "NtfsMarkUserLimit: Quota limit called for owner id = %lx\n", QuotaControl->OwnerId ));

    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Acquire the VCB shared and check whether we should
    //  continue.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        if (!NtfsIsVcbAvailable( Vcb )) {

            //
            //  The volume is going away, bail out.
            //

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        NtfsAcquireExclusiveScb( IrpContext, Vcb->QuotaTableScb );
        QuotaTableAcquired = TRUE;

        //
        //  Get the user's quota data entry.
        //

        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &QuotaControl->OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuotaControl->QuickIndexHint );

        if (!NT_SUCCESS( Status ) ||
            (IndexRow.DataPart.DataLength < SIZEOF_QUOTA_USER_DATA + FIELD_OFFSET( SID, SubAuthority )) ||
             ((ULONG) SeLengthSid( &(((PQUOTA_USER_DATA) (IndexRow.DataPart.Data))->QuotaSid)) + SIZEOF_QUOTA_USER_DATA !=
                IndexRow.DataPart.DataLength)) {

            //
            //  This look up should not fail.
            //

            ASSERT( NT_SUCCESS( Status ));
            ASSERTMSG(( "NTFS: corrupt quotasid\n" ), FALSE);

            NtfsMarkQuotaCorrupt( IrpContext, IrpContext->Vcb );
            leave;
        }

        //
        //  Space is allocated for the new record after the quota control
        //  block.
        //

        UserData = (PQUOTA_USER_DATA) (QuotaControl + 1);
        ASSERT( IndexRow.DataPart.DataLength >= SIZEOF_QUOTA_USER_DATA );

        RtlCopyMemory( UserData,
                       IndexRow.DataPart.Data,
                       SIZEOF_QUOTA_USER_DATA );

        KeQuerySystemTime( &CurrentTime );
        UserData->QuotaChangeTime = CurrentTime.QuadPart;

        //
        //  Indicate that user exceeded quota.
        //

        UserData->QuotaExceededTime = CurrentTime.QuadPart;
        SetFlag( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED );

        //
        //  Log the limit event.  If this fails then leave.
        //

        if (!NtfsLogEvent( IrpContext,
                           IndexRow.DataPart.Data,
                           IO_FILE_QUOTA_LIMIT,
                           STATUS_DISK_FULL )) {
            leave;
        }

        //
        // The key length does not change.
        //

        IndexRow.KeyPart.Key = &QuotaControl->OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
        IndexRow.DataPart.Data = UserData;
        IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

        NtOfsUpdateRecord( IrpContext,
                           Vcb->QuotaTableScb,
                           1,
                           &IndexRow,
                           &QuotaControl->QuickIndexHint,
                           &MapHandle );

    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    //
    //  The request will be retied if the status is can't wait or log file full.
    //

    if ((Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL)) {

        //
        //  If we will not be called back, then no matter what happened
        //  dereference the quota control block and clear the post flag.
        //

        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
        ASSERT( FlagOn( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED ));
        ClearFlag( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED );
        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

        NtfsDereferenceQuotaControlBlock( Vcb, &QuotaControl );
    }

    //
    //  Release the index map handle.
    //

    NtOfsReleaseMap( IrpContext, &MapHandle );

    if (QuotaTableAcquired) {

        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }

    NtfsReleaseVcb( IrpContext, Vcb );

    if (!NT_SUCCESS( Status )) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    return;
}


VOID
NtfsMoveQuotaOwner (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR Security
    )

/*++

Routine Description:

    This routine changes the owner id and quota charged for a file when the
    file owner is changed.

Arguments:

    Fcb - Pointer to fcb being opened.

    Security - Pointer to the new security descriptor

Return Value:

    None.

--*/

{
    LONGLONG QuotaCharged;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PSTANDARD_INFORMATION StandardInformation;
    PSID Sid = NULL;
    ULONG OwnerId;
    NTSTATUS Status;
    BOOLEAN OwnerDefaulted;

    PAGED_CODE();

    if (!NtfsPerformQuotaOperation(Fcb)) {
        return;
    }

    //
    //  Extract the security id from the security descriptor.
    //

    Status = RtlGetOwnerSecurityDescriptor( Security,
                                            &Sid,
                                            &OwnerDefaulted );

    if (!NT_SUCCESS( Status )) {
        NtfsRaiseStatus( IrpContext, Status, NULL, Fcb );
    }

    //
    //  If we didn't get a SID then we can't move the owner.
    //

    if (Sid == NULL) {

        return;
    }

    //
    //  Generate a owner id for the Fcb.
    //

    OwnerId = NtfsGetOwnerId( IrpContext, Sid, TRUE, NULL );

    if (OwnerId == Fcb->OwnerId) {

        //
        //  The owner is not changing so just return.
        //

        return;
    }

    //
    //  Initialize the context structure and map handle.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Preacquire the quota index exclusive since an entry may need to
    //  be added.
    //

    NtfsAcquireExclusiveScb( IrpContext, Fcb->Vcb->QuotaTableScb );

    try {

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        QuotaCharged = -((LONGLONG) StandardInformation->QuotaCharged);

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  Remove the quota from the old owner.
        //

        NtfsUpdateFileQuota( IrpContext,
                             Fcb,
                             &QuotaCharged,
                             TRUE,
                             FALSE );

        //
        //  Set the new owner id.
        //

        Fcb->OwnerId = OwnerId;

        //
        //  Note the old quota block is kept around until the operation is
        //  complete.  This is so the recovery code does not have allocate
        //  a memory if the old quota block is needed.  This is done in
        //  NtfsCommonSetSecurityInfo.
        //

        Fcb->QuotaControl = NtfsInitializeQuotaControlBlock( Fcb->Vcb, OwnerId );

        QuotaCharged = -QuotaCharged;

        //
        //  Try to charge the quota to the new owner.
        //

        NtfsUpdateFileQuota( IrpContext,
                     Fcb,
                     &QuotaCharged,
                     TRUE,
                     TRUE );

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsReleaseScb( IrpContext, Fcb->Vcb->QuotaTableScb );
    }

    return;
}


VOID
NtfsMarkQuotaCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine attempts to mark the quota index corrupt.  It will
    also attempt post a request to rebuild the quota index.

Arguments:

    Vcb - Supplies a pointer the the volume who quota data is corrupt.

Return Value:

    None

--*/

{

    DebugTrace( 0, Dbg, ( "NtfsMarkQuotaCorrupt: Marking quota dirty on Vcb = %lx\n", Vcb));

    if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_CORRUPT )) {

        //
        //  If the quota were not previous corrupt then log an event
        //  so others know this occured.
        //

        NtfsLogEvent( IrpContext,
                      NULL,
                      IO_FILE_QUOTA_CORRUPT,
                      STATUS_FILE_CORRUPT_ERROR );
    }

    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_CORRUPT );
    SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS );

    //
    //  Since the index is corrupt there is no point in tracking the
    //  quota usage.
    //

    ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED );

    ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

    //
    //  Do not save the flags here since the quota scb may be acquired
    //  shared.  The repair will save the flags when it runs.
    //  Try to fix the problems.
    //

    NtfsPostRepairQuotaIndex( IrpContext, Vcb );

    return;
}


VOID
NtfsPostRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine posts a request to recalculate all of the user quota data.

Arguments:

    Vcb - Volume control block for volume whos quota needs to be fixed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    try {

        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

        if (FlagOn( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING)) {
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            leave;
        }

        if (Vcb->QuotaControlTemplate == NULL) {

            //
            //  Allocate and initialize the template control block.
            //  Allocate enough space in the quota control block for the index
            //  data part. This is used as the new record when calling update
            //  record.  This template is only allocated once and then it is
            //  saved in the vcb.
            //

            Vcb->QuotaControlTemplate = NtfsAllocatePoolWithTag( PagedPool,
                                                                 sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA,
                                                                 'QftN' );

            RtlZeroMemory( Vcb->QuotaControlTemplate,
                           sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA );

            Vcb->QuotaControlTemplate->NodeTypeCode = NTFS_NTC_QUOTA_CONTROL;
            Vcb->QuotaControlTemplate->NodeByteSize = sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA;

        }

        SetFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_POSTED );
        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

        //
        //  Post this special request.
        //

        NtfsPostSpecial( IrpContext,
                         Vcb,
                         NtfsRepairQuotaIndex,
                         NULL );


    } finally {

        if (AbnormalTermination()) {

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_POSTED);
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        }
    }

    return;
}


VOID
NtfsPostUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    )

/*++

Routine Description:

    This routine posts a request to save the fact that the user has exceeded
    their limit.

Arguments:

    Vcb - Volume control block for volume whos quota needs to be fixed.

    QuotaControl - Quota control block for the user.

Return Value:

    None

--*/

{

    PAGED_CODE();

    try {

        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

        if (FlagOn( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED )) {
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            leave;
        }

        SetFlag( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED );

        //
        //  Reference the quota control block so it does not go away.
        //

        ASSERT( QuotaControl->ReferenceCount > 0 );
        InterlockedIncrement( &QuotaControl->ReferenceCount );

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

        //
        //  Post this special request.
        //

        NtfsPostSpecial( IrpContext,
                         Vcb,
                         NtfsMarkUserLimit,
                         QuotaControl );

    } finally {

        if (AbnormalTermination()) {

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED );
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        }
    }

    return;
}


NTSTATUS
NtfsPrepareForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine determines if an owner id is a candidate for deletion.  If
    the id appears deletable its user data is reset to the defaults and the
    entry is marked as deleted.  Later a worker thread will do the actual
    deletion.

Arguments:

    Vcb - Supplies a pointer to the volume containing the entry to be deleted.

    Sid - Security id to to be deleted.

Return Value:

    Returns a status indicating of the id was deletable at this time.

--*/
{
    ULONG OwnerId;
    ULONG DefaultOwnerId;
    NTSTATUS Status = STATUS_SUCCESS;
    INDEX_ROW IndexRow;
    INDEX_ROW NewIndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    PQUOTA_CONTROL_BLOCK QuotaControl;
    QUOTA_USER_DATA NewQuotaData;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;

    PAGED_CODE();

    //
    //  Determine the Sid length.
    //

    IndexKey.KeyLength = RtlLengthSid( Sid );
    IndexKey.Key = Sid;

    //
    //  Acquire Owner id and quota index exclusive.
    //

    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    NtOfsInitializeMapHandle( &MapHandle );

    try {

        //
        //  Look up the SID in the owner index.
        //

        Status = NtOfsFindRecord( IrpContext,
                                  OwnerIdScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {
            leave;
        }

        //
        //  If the sid was found then capture the owner id.
        //

        ASSERT( IndexRow.DataPart.DataLength == sizeof( ULONG ));
        OwnerId = *((PULONG) IndexRow.DataPart.Data);

        //
        //  Release the index map handle.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );

        //
        //  Find the existing record and update it.
        //

        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {

            ASSERT( NT_SUCCESS( Status ));
            NtfsMarkQuotaCorrupt( IrpContext, Vcb );
            leave;
        }

        RtlCopyMemory( &NewQuotaData, IndexRow.DataPart.Data, SIZEOF_QUOTA_USER_DATA );

        //
        //  Check to see if there is a quota control entry
        //  for this id.
        //

        ASSERT( FIELD_OFFSET( QUOTA_CONTROL_BLOCK, OwnerId ) <= FIELD_OFFSET( INDEX_ROW, KeyPart.Key ));

        QuotaControl = RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                     CONTAINING_RECORD( &IndexRow.KeyPart.Key,
                                                                        QUOTA_CONTROL_BLOCK,
                                                                        OwnerId ));

        //
        //  If there is a quota control entry or there is now
        //  some quota charged, then the entry cannot be deleted.
        //

        if ((QuotaControl != NULL) || (NewQuotaData.QuotaUsed != 0)) {

            Status = STATUS_CANNOT_DELETE;
            leave;
        }

        //
        //  Find the default quota record.
        //

        DefaultOwnerId = QUOTA_DEFAULTS_ID;
        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &DefaultOwnerId;

        NtOfsReleaseMap( IrpContext, &MapHandle );

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, STATUS_QUOTA_LIST_INCONSISTENT, NULL, QuotaScb->Fcb );
        }

        //
        //  Set the user entry to the current defaults. Then if the entry
        //  is really inuse it will appear that is came back after the delete.
        //

        RtlCopyMemory( &NewQuotaData,
                       IndexRow.DataPart.Data,
                       SIZEOF_QUOTA_USER_DATA );

        ClearFlag( NewQuotaData.QuotaFlags, ~QUOTA_FLAG_USER_MASK );

        //
        //  Set the deleted flag.
        //

        SetFlag( NewQuotaData.QuotaFlags, QUOTA_FLAG_ID_DELETED );

        //
        // The key length does not change.
        //

        NewIndexRow.KeyPart.Key = &OwnerId;
        NewIndexRow.KeyPart.KeyLength = sizeof( ULONG );
        NewIndexRow.DataPart.Data = &NewQuotaData;
        NewIndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

        NtOfsUpdateRecord( IrpContext,
                           QuotaScb,
                           1,
                           &NewIndexRow,
                           NULL,
                           NULL );

        //
        //  Update the delete secquence number this is used to indicate
        //  another id has been deleted.  If the repair code is in the
        //  middle of its scan it must restart the scan.
        //

        Vcb->QuotaDeleteSecquence += 1;

        //
        //  Indicate there are pending deletes.
        //

        if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES );

            ASSERT( IndexRow.DataPart.DataLength <= sizeof( QUOTA_USER_DATA ));

            RtlCopyMemory( &NewQuotaData,
                           IndexRow.DataPart.Data,
                           IndexRow.DataPart.DataLength );

            //
            //  Update the changed fields in the record.
            //

            NewQuotaData.QuotaFlags = Vcb->QuotaFlags;

            //
            //  Note the sizes in the IndexRow stay the same.
            //

            IndexRow.KeyPart.Key = &DefaultOwnerId;
            ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
            IndexRow.DataPart.Data = &NewQuotaData;

            NtOfsUpdateRecord( IrpContext,
                               QuotaScb,
                               1,
                               &IndexRow,
                               NULL,
                               NULL );
        }

    } finally {

        //
        //  Release the index map handle and index resources.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );
        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtfsReleaseScb( IrpContext, QuotaScb );
    }

    return Status;
}


VOID
NtfsRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called by a worker thread to fix the quota indexes
    and recalculate all of the quota values.

Arguments:

    Context - Unused.

Return Value:

    None

--*/

{
    PVCB Vcb = IrpContext->Vcb;
    ULONG State;
    NTSTATUS Status;
    ULONG RetryCount = 0;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( Context );

    try {

        DebugTrace( 0, Dbg, ( "NtfsRepairQuotaIndex: Starting quota repair. Vcb = %lx\n", Vcb ));

        //
        //  The volume could've gotten write-protected by now.
        //

        if (NtfsIsVolumeReadOnly( Vcb )) {

            NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
        }

        //
        //  Acquire the volume exclusive and the quota lock.
        //

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

        Status = STATUS_SUCCESS;

        if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED )) {

            //
            //  There is no point in doing any of this work if tracking
            //  is not requested.
            //

            Status = STATUS_INVALID_PARAMETER;

        } else if (FlagOn( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING ) == VCB_QUOTA_REPAIR_POSTED) {

            if (FlagOn( Vcb->QuotaFlags,
                        (QUOTA_FLAG_OUT_OF_DATE |
                         QUOTA_FLAG_CORRUPT |
                         QUOTA_FLAG_PENDING_DELETES) ) == QUOTA_FLAG_PENDING_DELETES) {

                //
                //  Only the last to phases need to be run.
                //

                ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );

                SetFlag( Vcb->QuotaState, VCB_QUOTA_RECALC_STARTED );

                State = VCB_QUOTA_RECALC_STARTED;

                //
                //  Capture the delete secquence number.  If it changes
                //  before the actual deletes are done then we have to
                //  start over.
                //

                IrpContext->Union.NtfsIoContext = ULongToPtr( Vcb->QuotaDeleteSecquence );

            } else {

                //
                //  We are starting just starting.  Clear the quota tracking
                //  flags and indicate the current state.
                //

                ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );

                SetFlag( Vcb->QuotaState, VCB_QUOTA_CLEAR_RUNNING | VCB_QUOTA_SAVE_QUOTA_FLAGS);

                ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED );

                SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE );

                State = VCB_QUOTA_CLEAR_RUNNING;
            }

            //
            //  Initialize the File reference to the root index.
            //

            NtfsSetSegmentNumber( &Vcb->QuotaFileReference,
                                  0,
                                  ROOT_FILE_NAME_INDEX_NUMBER );

            Vcb->QuotaFileReference.SequenceNumber = 0;

            NtfsLogEvent( IrpContext,
                          NULL,
                          IO_FILE_QUOTA_STARTED,
                          STATUS_SUCCESS );

        }  else {

            State = FlagOn( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING);
        }

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtfsReleaseVcb( IrpContext, Vcb );

        if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {

            NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
        }

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        //
        //  Determine the current state
        //

        switch (State) {

        case VCB_QUOTA_CLEAR_RUNNING:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting clear per file quota.\n" ));

            //
            //  Clear the quota charged field in each file and clear
            //  all of the quota control blocks from the fcbs.
            //

            Status = NtfsIterateMft( IrpContext,
                                      Vcb,
                                      &Vcb->QuotaFileReference,
                                      NtfsClearPerFileQuota,
                                      NULL );

            if (Status == STATUS_END_OF_FILE) {
                Status = STATUS_SUCCESS;
            }

            if (!NT_SUCCESS( Status )) {
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

RestartVerifyQuotaIndex:

            //
            //  Update the state to the next phase.
            //

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_INDEX_REPAIR);
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            //
            //  NtfsClearAndVerifyQuotaIndex uses the low part of the
            //  file reference to store the current owner id.
            //  Intialize this to the first user id.
            //

            Vcb->QuotaFileReference.SegmentNumberLowPart = QUOTA_FISRT_USER_ID;

            //
            //  Fall through.
            //

        case VCB_QUOTA_INDEX_REPAIR:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting clear quota index.\n" ));

            //
            //  Clear the quota used for each owner id.
            //

            NtfsClearAndVerifyQuotaIndex( IrpContext, Vcb );

            //
            //  Update the state to the next phase.
            //

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_OWNER_VERIFY);
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            //
            //  Note NtfsVerifyOwnerIndex does not use any restart state,
            //  since it normally does not preform any transactions.
            //

            //
            //  Fall through.
            //

        case VCB_QUOTA_OWNER_VERIFY:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting verify owner index.\n" ));

            //
            //  Verify the owner's id points to quota user data.
            //

            Status = NtfsVerifyOwnerIndex( IrpContext, Vcb );

            //
            //  Restart the rebuild with the quota index phase.
            //

            if (!NT_SUCCESS( Status ) ) {

                if (RetryCount < 2) {

                    RetryCount += 1;
                    goto RestartVerifyQuotaIndex;

                } else {

                    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                }
            }

            //
            //  Update the state to the next phase.
            //  Start tracking quota and do enforcement as requested.
            //

            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_RECALC_STARTED | VCB_QUOTA_SAVE_QUOTA_FLAGS);

            if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED)) {

                SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED);
                Status = STATUS_SUCCESS;

            } else {

                //
                //  There is no point in doing any of this work if tracking
                //  is not requested.
                //

                Status = STATUS_INVALID_PARAMETER;
            }

            //
            //  Capture the delete secquence number.  If it changes
            //  before the actual deletes are done then we have to
            //  start over.
            //

            IrpContext->Union.NtfsIoContext = ULongToPtr( Vcb->QuotaDeleteSecquence );

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            NtfsReleaseVcb( IrpContext, Vcb );

            if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {

                NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
            }

            if (!NT_SUCCESS( Status )) {
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            //
            //  Initialize the File reference to the first user file.
            //

            NtfsSetSegmentNumber( &Vcb->QuotaFileReference,
                                  0,
                                  ROOT_FILE_NAME_INDEX_NUMBER );
            Vcb->QuotaFileReference.SequenceNumber = 0;

            //
            //  Fall through.
            //

        case VCB_QUOTA_RECALC_STARTED:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting per file quota usage.\n" ));

            //
            //  Fix the user files.
            //

            Status = NtfsIterateMft( IrpContext,
                                      Vcb,
                                      &Vcb->QuotaFileReference,
                                      NtfsRepairPerFileQuota,
                                      NULL );

            if (Status == STATUS_END_OF_FILE) {
                Status = STATUS_SUCCESS;
            }

            //
            //  Everything is done indicate we are up to date.
            //

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS);

            if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

                //
                //  Need to actually delete the ids.
                //

                SetFlag( Vcb->QuotaState, VCB_QUOTA_DELETEING_IDS );
                State = VCB_QUOTA_DELETEING_IDS;

                //
                //  NtfsDeleteUnsedIds uses the low part of the
                //  file reference to store the current owner id.
                //  Intialize this to the first user id.
                //

                Vcb->QuotaFileReference.SegmentNumberLowPart = QUOTA_FISRT_USER_ID;

            }

            ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE | QUOTA_FLAG_CORRUPT );

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {
                NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
            }

            if (State != VCB_QUOTA_DELETEING_IDS) {
                break;
            }

        case VCB_QUOTA_DELETEING_IDS:

            //
            //  Remove and ids which are marked for deletion.
            //

            NtfsDeleteUnsedIds( IrpContext, Vcb );

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS);
            ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES );

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {
                NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
            }

            break;

        default:

            ASSERT( FALSE );
            Status = STATUS_INVALID_PARAMETER;
            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        if (NT_SUCCESS( Status )) {
            NtfsLogEvent( IrpContext,
                          NULL,
                          IO_FILE_QUOTA_SUCCEEDED,
                          Status );
        }

    } except(NtfsExceptionFilter(IrpContext, GetExceptionInformation())) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    DebugTrace( 0, Dbg, ( "NtfsRepairQuotaIndex: Quota repair done. Status = %8lx Context = %lx\n", Status, (ULONG) NtfsSegmentNumber( &Vcb->QuotaFileReference )));

    if (!NT_SUCCESS( Status )) {

        //
        //  If we will not be called back then clear the running state bits.
        //

        if ((Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL)) {

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            //
            //  Only log if we attempted to do work - which is only the case
            //  if tracking is on
            //

            if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED)) {
                NtfsLogEvent( IrpContext, NULL, IO_FILE_QUOTA_FAILED, Status );
            }

        }

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    return;
}


VOID
NtfsReleaseQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    )

/*++

Routine Description:

    This function is called by transcation control to release the quota control
    block and quota index after a transcation has been completed.

Arguments:

    QuotaControl - Quota control block to be released.

Return Value:

    None.

--*/

{
    PVCB Vcb = IrpContext->Vcb;
    PAGED_CODE();

    ExReleaseFastMutexUnsafe( QuotaControl->QuotaControlLock );
    NtfsReleaseResource( IrpContext, Vcb->QuotaTableScb );

    NtfsDereferenceQuotaControlBlock( Vcb, &QuotaControl );

    return;
}


NTSTATUS
NtfsRepairPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine calculate the quota used by a file and update the
    update QuotaCharged field in the standard info as well as QuotaUsed
    in the user's index structure.  If the owner id is not set this is
    also updated at this time.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Unsed.

Return Value:

    STATUS_SUCCESS

--*/

{
    LONGLONG Delta;
    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    PREAD_CONTEXT ReadContext = NULL;
    ULONG Count;
    PSID Sid;
    PVCB Vcb = Fcb->Vcb;
    NTSTATUS Status;
    BOOLEAN OwnerDefaulted;
    BOOLEAN SetOwnerId = FALSE;
    BOOLEAN StdInfoGrown = FALSE;

    PAGED_CODE( );

    UNREFERENCED_PARAMETER( Context);

    //
    //  Preacquire the security stream and  quota index in case the
    //  mft has to be grown.
    //

    ASSERT(!NtfsIsExclusiveScb( Vcb->MftScb ) || NtfsIsExclusiveScb( Vcb->QuotaTableScb ));

    NtfsAcquireExclusiveScb( IrpContext, Vcb->QuotaTableScb );

    try {

        //
        //  Always clear the owner ID so that the SID is retrived from
        //  the security descriptor.
        //

        Fcb->OwnerId = QUOTA_INVALID_ID;

        if (Fcb->QuotaControl != NULL) {

            //
            //  If there is a quota control block it is now bougus
            //  Free it up a new one will be generated below.
            //

            NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
        }

        if (Fcb->OwnerId != QUOTA_INVALID_ID) {

            //
            //  Verify the id actually exists in the index.
            //

            Count = 0;
            IndexKey.Key = &Fcb->OwnerId;
            IndexKey.KeyLength = sizeof( Fcb->OwnerId );
            Status = NtOfsReadRecords( IrpContext,
                                       Vcb->QuotaTableScb,
                                       &ReadContext,
                                       &IndexKey,
                                       NtOfsMatchUlongExact,
                                       &IndexKey,
                                       &Count,
                                       &IndexRow,
                                       0,
                                       NULL );

            if (!NT_SUCCESS( Status )) {

                ASSERT( NT_SUCCESS( Status ));

                //
                //  There is no user quota data for this id assign a
                //  new one to the file.
                //

                Fcb->OwnerId = QUOTA_INVALID_ID;

                if (Fcb->QuotaControl != NULL) {

                    //
                    //  If there is a quota control block it is now bougus
                    //  Free it up a new one will be generated below.
                    //

                    NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
                }
            }

            NtOfsFreeReadContext( ReadContext );
        }

        if (Fcb->OwnerId == QUOTA_INVALID_ID) {

            if (Fcb->SharedSecurity == NULL) {
                NtfsLoadSecurityDescriptor ( IrpContext, Fcb  );
            }

            ASSERT( Fcb->SharedSecurity != NULL );

            //
            //  Extract the security id from the security descriptor.
            //

            Status = RtlGetOwnerSecurityDescriptor( Fcb->SharedSecurity->SecurityDescriptor,
                                                    &Sid,
                                                    &OwnerDefaulted );

            if (!NT_SUCCESS(Status)) {
                NtfsRaiseStatus( IrpContext, Status, NULL, Fcb);
            }

            //
            // Generate a owner id for the Fcb.
            //

            Fcb->OwnerId = NtfsGetOwnerId( IrpContext,
                                           Sid,
                                           TRUE,
                                           NULL );

            SetOwnerId = TRUE;

            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {

                NtfsUpdateStandardInformation( IrpContext, Fcb );

            } else {

                //
                //  Grow the standard information.
                //

                StdInfoGrown = TRUE;
                NtfsGrowStandardInformation( IrpContext, Fcb );
            }
        }

        //
        //  Initialize the quota control block.
        //

        if (Fcb->QuotaControl == NULL) {
            Fcb->QuotaControl = NtfsInitializeQuotaControlBlock( Vcb, Fcb->OwnerId );
        }

        NtfsCalculateQuotaAdjustment( IrpContext, Fcb, &Delta );

        ASSERT( NtfsAllowFixups || FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE ) || (Delta == 0));

        if ((Delta != 0) || FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

            NtfsUpdateFileQuota( IrpContext, Fcb, &Delta, TRUE, FALSE );
        }

        if (SetOwnerId) {

            //
            //  If the owner id was set then commit the transaction now.
            //  That way if a raise occurs the OwnerId can be cleared before
            //  the function returns. No resources are released.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );
        }

    } finally {

        //
        //  Clear any Fcb changes if the operation failed.
        //  This is so when a retry occurs the necessary
        //  operations are done.
        //

        if (AbnormalTermination()) {

            if (StdInfoGrown) {
                ClearFlag( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO );
            }

            if (SetOwnerId) {

                Fcb->OwnerId = QUOTA_INVALID_ID;

                if (Fcb->QuotaControl != NULL) {
                    NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
                }
            }
        }

        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }

    return STATUS_SUCCESS;
}


VOID
NtfsUpdateFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLONGLONG Delta,
    IN LOGICAL LogIt,
    IN LOGICAL CheckQuota
    )

/*++

Routine Description:

    This routine updates the quota amount for a file and owner by the
    requested amount. If quota is being increated and the CheckQuota is true
    than the new quota amount will be tested for quota violations. If the
    hard limit is exceeded an error is raised.  If the LogIt flags is not set
    then changes to the standard information structure are not logged.
    Changes to the user quota data are always logged.

Arguments:

    Fcb - Fcb whose quota usage is being modified.

    Delta - Supplies the signed amount to change the quota for the file.

    LogIt - Indicates whether we should log this change.

    CheckQuota - Indicates whether we should check for quota violations.

Return Value:

    None.

--*/

{

    ULONGLONG NewQuota;
    LARGE_INTEGER CurrentTime;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PSTANDARD_INFORMATION StandardInformation;
    PQUOTA_USER_DATA UserData;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    NTSTATUS Status;
    PQUOTA_CONTROL_BLOCK QuotaControl = Fcb->QuotaControl;
    PVCB Vcb = Fcb->Vcb;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFileQuota:  Entered\n") );

    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO ));


    //
    //  Readonly volumes shouldn't proceed.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        ASSERT( FALSE );
        NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
    }

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure and map handle.
        //

        NtfsInitializeAttributeContext( &AttrContext );
        NtOfsInitializeMapHandle( &MapHandle );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        ASSERT( NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION ));

        NewQuota = StandardInformation->QuotaCharged + *Delta;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        if ((LONGLONG) NewQuota < 0) {

            //
            //  Do not let the quota data go negitive.
            //

            NewQuota = 0;
        }

        if (LogIt) {

            //
            //  Call to change the attribute value.
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      FIELD_OFFSET(STANDARD_INFORMATION, QuotaCharged),
                                      &NewQuota,
                                      sizeof( StandardInformation->QuotaCharged),
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      &AttrContext );
        } else {

            //
            //  Just update the value in the standard information
            //  it will be logged later.
            //

            StandardInformation->QuotaCharged = NewQuota;
        }

        //
        //  Update the quota information block.
        //

        NtfsAcquireQuotaControl( IrpContext, QuotaControl );

        IndexKey.KeyLength = sizeof(ULONG);
        IndexKey.Key = &QuotaControl->OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuotaControl->QuickIndexHint );

        if (!(NT_SUCCESS( Status )) ||
            (IndexRow.DataPart.DataLength < SIZEOF_QUOTA_USER_DATA + FIELD_OFFSET( SID, SubAuthority )) ||
             ((ULONG)SeLengthSid( &(((PQUOTA_USER_DATA)(IndexRow.DataPart.Data))->QuotaSid)) + SIZEOF_QUOTA_USER_DATA !=
                IndexRow.DataPart.DataLength)) {

            //
            //  This look up should not fail.
            //

            ASSERT( NT_SUCCESS( Status ));
            ASSERTMSG(( "NTFS: corrupt quotasid\n" ), FALSE);

            NtfsMarkQuotaCorrupt( IrpContext, IrpContext->Vcb );
            leave;
        }

        //
        //  Space is allocated for the new record after the quota control
        //  block.
        //

        UserData = (PQUOTA_USER_DATA) (QuotaControl + 1);
        ASSERT( IndexRow.DataPart.DataLength >= SIZEOF_QUOTA_USER_DATA );

        RtlCopyMemory( UserData,
                       IndexRow.DataPart.Data,
                       SIZEOF_QUOTA_USER_DATA );

        ASSERT( (LONGLONG) UserData->QuotaUsed >= -*Delta );

        UserData->QuotaUsed += *Delta;

        if ((LONGLONG) UserData->QuotaUsed < 0) {

            //
            //  Do not let the quota data go negative.
            //

            UserData->QuotaUsed = 0;
        }

        //
        //  Indicate only the quota used field has been set so far.
        //

        Length = FIELD_OFFSET( QUOTA_USER_DATA, QuotaChangeTime );

        //
        //  Only update the quota modified time if this is the last cleanup
        //  for the owner.
        //

        if (IrpContext->MajorFunction == IRP_MJ_CLEANUP) {

            KeQuerySystemTime( &CurrentTime );
            UserData->QuotaChangeTime = CurrentTime.QuadPart;

            ASSERT( Length <= FIELD_OFFSET( QUOTA_USER_DATA, QuotaThreshold ));
            Length = FIELD_OFFSET( QUOTA_USER_DATA, QuotaThreshold );
        }

        if (CheckQuota && (*Delta > 0)) {

            if ((UserData->QuotaUsed > UserData->QuotaLimit) &&
                (UserData->QuotaUsed >= (UserData->QuotaLimit + Vcb->BytesPerCluster))) {

                KeQuerySystemTime( &CurrentTime );
                UserData->QuotaChangeTime = CurrentTime.QuadPart;

                if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_LOG_LIMIT ) &&
                    (!FlagOn( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED ) ||
                     ((ULONGLONG) CurrentTime.QuadPart > UserData->QuotaExceededTime + NtfsMaxQuotaNotifyRate))) {

                    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED) &&
                        (Vcb->AdministratorId != QuotaControl->OwnerId)) {

                        //
                        //  The operation to mark the user's quota data entry
                        //  must be posted since any changes to the entry
                        //  will be undone by the following raise.
                        //

                        NtfsPostUserLimit( IrpContext, Vcb, QuotaControl );
                        NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, Fcb );

                    } else {

                        //
                        //  Log the fact that quota was exceeded.
                        //

                        if (NtfsLogEvent( IrpContext,
                                          IndexRow.DataPart.Data,
                                          IO_FILE_QUOTA_LIMIT,
                                          STATUS_SUCCESS )) {

                            //
                            //  The event was successfuly logged.  Do not log
                            //  another for a while.
                            //

                            DebugTrace( 0, Dbg, ("NtfsUpdateFileQuota: Quota Limit exceeded. OwnerId = %lx\n", QuotaControl->OwnerId));

                            UserData->QuotaExceededTime = CurrentTime.QuadPart;
                            SetFlag( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED );

                            //
                            //  Log all of the changed data.
                            //

                            Length = SIZEOF_QUOTA_USER_DATA;
                        }
                    }

                } else if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED) &&
                           (Vcb->AdministratorId != QuotaControl->OwnerId)) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, Fcb );
                }

            }

            if (UserData->QuotaUsed > UserData->QuotaThreshold) {

                KeQuerySystemTime( &CurrentTime );
                UserData->QuotaChangeTime = CurrentTime.QuadPart;

                if ((ULONGLONG) CurrentTime.QuadPart >
                    (UserData->QuotaExceededTime + NtfsMaxQuotaNotifyRate)) {

                    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_LOG_THRESHOLD)) {

                        if (NtfsLogEvent( IrpContext,
                                          IndexRow.DataPart.Data,
                                          IO_FILE_QUOTA_THRESHOLD,
                                          STATUS_SUCCESS )) {

                            //
                            //  The event was successfuly logged.  Do not log
                            //  another for a while.
                            //

                            DebugTrace( 0, Dbg, ("NtfsUpdateFileQuota: Quota threshold exceeded. OwnerId = %lx\n", QuotaControl->OwnerId));

                            UserData->QuotaExceededTime = CurrentTime.QuadPart;

                            //
                            //  Log all of the changed data.
                            //

                            Length = SIZEOF_QUOTA_USER_DATA;
                        }
                    }

                    //
                    //  Now is a good time to clear the limit reached flag.
                    //

                    ClearFlag( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED );
                }
            }
        }

        //
        //  Always clear the deleted flag.
        //

        ClearFlag( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED );

        //
        // Only log the part that changed.
        //

        IndexRow.KeyPart.Key = &QuotaControl->OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof(ULONG) );
        IndexRow.DataPart.Data = UserData;
        IndexRow.DataPart.DataLength = Length;

        NtOfsUpdateRecord( IrpContext,
                         Vcb->QuotaTableScb,
                         1,
                         &IndexRow,
                         &QuotaControl->QuickIndexHint,
                         &MapHandle );

    } finally {

        DebugUnwind( NtfsUpdateFileQuota );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        DebugTrace( -1, Dbg, ("NtfsUpdateFileQuota:  Exit\n") );
    }

    return;
}


VOID
NtfsSaveQuotaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine saves the quota flags in the defaults quota entry.

Arguments:

    Vcb - Volume control block for volume be query.

Return Value:

    None.

--*/

{
    ULONG OwnerId;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    QUICK_INDEX_HINT QuickIndexHint;
    QUOTA_USER_DATA NewQuotaData;
    PSCB QuotaScb;

    PAGED_CODE();

    //
    //  Acquire quota index exclusive.
    //

    QuotaScb = Vcb->QuotaTableScb;
    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtOfsInitializeMapHandle( &MapHandle );
    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        //
        //  Find the default quota record and update it.
        //

        OwnerId = QUOTA_DEFAULTS_ID;
        IndexKey.KeyLength = sizeof(ULONG);
        IndexKey.Key = &OwnerId;

        RtlZeroMemory( &QuickIndexHint, sizeof( QuickIndexHint ));

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuickIndexHint );

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, STATUS_QUOTA_LIST_INCONSISTENT, NULL, QuotaScb->Fcb );
        }

        ASSERT( IndexRow.DataPart.DataLength <= sizeof( QUOTA_USER_DATA ));

        RtlCopyMemory( &NewQuotaData,
                       IndexRow.DataPart.Data,
                       IndexRow.DataPart.DataLength );

        //
        //  Update the changed fields in the record.
        //

        NewQuotaData.QuotaFlags = Vcb->QuotaFlags;

        //
        //  Note the sizes in the IndexRow stay the same.
        //

        IndexRow.KeyPart.Key = &OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof(ULONG) );
        IndexRow.DataPart.Data = &NewQuotaData;

        NtOfsUpdateRecord( IrpContext,
                           QuotaScb,
                           1,
                           &IndexRow,
                           &QuickIndexHint,
                           &MapHandle );

        ClearFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS);

    } finally {

        //
        //  Release the index map handle and scb.
        //

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, QuotaScb );
    }

    return;
}


VOID
NtfsSaveQuotaFlagsSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine safely saves the quota flags in the defaults quota entry.
    It acquires the volume shared, checks to see if it is ok to write,
    updates the flags and finally commits the transaction.

Arguments:

    Vcb - Volume control block for volume be query.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT( IrpContext->TransactionId == 0);

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        //
        //  Acquire the VCB shared and check whether we should
        //  continue.
        //

        if (!NtfsIsVcbAvailable( Vcb )) {

            //
            //  The volume is going away, bail out.
            //

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Do the work.
        //

        NtfsSaveQuotaFlags( IrpContext, Vcb );

        //
        //  Set the irp context flags to indicate that we are in the
        //  fsp and that the irp context should not be deleted when
        //  complete request or process exception are called. The in
        //  fsp flag keeps us from raising in a few places.  These
        //  flags must be set inside the loop since they are cleared
        //  under certain conditions.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP);

        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    } finally {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    return;
}


VOID
NtfsUpdateQuotaDefaults (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION FileControlInfo
    )

/*++

Routine Description:

    This function updates the default settings index entry for quotas.

Arguments:

    Vcb - Volume control block for volume be query.

    FileQuotaInfo - Optional quota data to update quota index with.

Return Value:

    None.

--*/

{
    ULONG OwnerId;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    QUOTA_USER_DATA NewQuotaData;
    QUICK_INDEX_HINT QuickIndexHint;
    ULONG Flags;
    PSCB QuotaScb;

    PAGED_CODE();

    //
    //  Acquire quota index exclusive.
    //

    QuotaScb = Vcb->QuotaTableScb;
    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtOfsInitializeMapHandle( &MapHandle );
    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        //
        //  Find the default quota record and update it.
        //

        OwnerId = QUOTA_DEFAULTS_ID;
        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &OwnerId;

        RtlZeroMemory( &QuickIndexHint, sizeof( QuickIndexHint ));

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuickIndexHint );

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, STATUS_QUOTA_LIST_INCONSISTENT, NULL, QuotaScb->Fcb );
        }

        ASSERT( IndexRow.DataPart.DataLength == SIZEOF_QUOTA_USER_DATA );

        RtlCopyMemory( &NewQuotaData,
                       IndexRow.DataPart.Data,
                       IndexRow.DataPart.DataLength );

        //
        //  Update the changed fields in the record.
        //

        NewQuotaData.QuotaThreshold = FileControlInfo->DefaultQuotaThreshold.QuadPart;
        NewQuotaData.QuotaLimit = FileControlInfo->DefaultQuotaLimit.QuadPart;
        KeQuerySystemTime( (PLARGE_INTEGER) &NewQuotaData.QuotaChangeTime );

        //
        //  Update the quota flags.
        //

        Flags = FlagOn( FileControlInfo->FileSystemControlFlags,
                        FILE_VC_QUOTA_MASK );

        switch (Flags) {

        case FILE_VC_QUOTA_NONE:

            //
            //  Disable quotas
            //

            ClearFlag( Vcb->QuotaFlags,
                       (QUOTA_FLAG_TRACKING_ENABLED |
                        QUOTA_FLAG_ENFORCEMENT_ENABLED |
                        QUOTA_FLAG_TRACKING_REQUESTED) );

            break;

        case FILE_VC_QUOTA_TRACK:

            //
            //  Clear the enforment flags.
            //

            ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED );

            //
            //  Request tracking be enabled.
            //

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED );
            break;

        case FILE_VC_QUOTA_ENFORCE:

            //
            //  Set the enforcement and tracking enabled flags.
            //

            SetFlag( Vcb->QuotaFlags,
                     QUOTA_FLAG_ENFORCEMENT_ENABLED | QUOTA_FLAG_TRACKING_REQUESTED);

            break;
        }

        //
        //  If quota tracking is not now
        //  enabled then the quota data will need
        //  to be rebuild so indicate quotas are out of date.
        //  Note the out of date flags always set of quotas
        //  are disabled.
        //

        if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED )) {
            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE );
        }

        //
        //  Track the logging flags.
        //

        ClearFlag( Vcb->QuotaFlags,
                   QUOTA_FLAG_LOG_THRESHOLD | QUOTA_FLAG_LOG_LIMIT );

        if (FlagOn( FileControlInfo->FileSystemControlFlags, FILE_VC_LOG_QUOTA_THRESHOLD )) {

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_LOG_THRESHOLD );
        }

        if (FlagOn( FileControlInfo->FileSystemControlFlags, FILE_VC_LOG_QUOTA_LIMIT )) {

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_LOG_LIMIT );
        }

        SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS );

        //
        //  Save the new flags in the new index entry.
        //

        NewQuotaData.QuotaFlags = Vcb->QuotaFlags;

        //
        //  Note the sizes in the IndexRow stays the same.
        //

        IndexRow.KeyPart.Key = &OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
        IndexRow.DataPart.Data = &NewQuotaData;

        NtOfsUpdateRecord( IrpContext,
                           QuotaScb,
                           1,
                           &IndexRow,
                           &QuickIndexHint,
                           &MapHandle );

        ClearFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS );

    } finally {

        //
        //  Release the index map handle and scb.
        //

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, QuotaScb );
    }

    //
    //  If the quota tracking has been requested and the quotas need to be
    //  repaired then try to repair them now.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED ) &&
        FlagOn( Vcb->QuotaFlags,
                QUOTA_FLAG_OUT_OF_DATE | QUOTA_FLAG_CORRUPT | QUOTA_FLAG_PENDING_DELETES )) {

        NtfsPostRepairQuotaIndex( IrpContext, Vcb );
    }

    return;
}


NTSTATUS
NtfsVerifyOwnerIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine iterates over the owner id index and verifies the pointer
    to the quota user data index.

Arguments:

    Vcb - Pointer to the volume control block whoes index is to be operated
          on.

Return Value:

    Returns a status indicating if the owner index was ok.

--*/

{
    INDEX_KEY IndexKey;
    INDEX_ROW QuotaRow;
    MAP_HANDLE MapHandle;
    PQUOTA_USER_DATA UserData;
    PINDEX_ROW OwnerRow;
    PVOID RowBuffer;
    NTSTATUS Status;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    ULONG Count;
    ULONG i;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;
    PINDEX_ROW IndexRow = NULL;
    PREAD_CONTEXT ReadContext = NULL;
    BOOLEAN IndexAcquired = FALSE;

    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Allocate a buffer lager enough for several rows.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

    try {

        //
        //  Allocate a bunch of index row entries.
        //

        Count = PAGE_SIZE / sizeof( SID );

        IndexRow = NtfsAllocatePool( PagedPool,
                                     Count * sizeof( INDEX_ROW ));

        //
        //  Iterate through the owner id entries.  Start with a zero sid.
        //

        RtlZeroMemory( IndexRow, sizeof( SID ));
        IndexKey.KeyLength = sizeof( SID );
        IndexKey.Key = IndexRow;

        Status = NtOfsReadRecords( IrpContext,
                                   OwnerIdScb,
                                   &ReadContext,
                                   &IndexKey,
                                   NtOfsMatchAll,
                                   NULL,
                                   &Count,
                                   IndexRow,
                                   PAGE_SIZE,
                                   RowBuffer );

        while (NT_SUCCESS( Status )) {

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
            NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
            IndexAcquired = TRUE;

            OwnerRow = IndexRow;

            for (i = 0; i < Count; i += 1, OwnerRow += 1) {

                IndexKey.KeyLength = OwnerRow->DataPart.DataLength;
                IndexKey.Key = OwnerRow->DataPart.Data;

                //
                //  Look up the Owner id in the quota index.
                //

                Status = NtOfsFindRecord( IrpContext,
                                          QuotaScb,
                                          &IndexKey,
                                          &QuotaRow,
                                          &MapHandle,
                                          NULL );


                ASSERT( NT_SUCCESS( Status ));

                if (!NT_SUCCESS( Status )) {

                    //
                    //  The quota entry is missing just delete this row;
                    //

                    NtOfsDeleteRecords( IrpContext,
                                        OwnerIdScb,
                                        1,
                                        &OwnerRow->KeyPart );

                    continue;
                }

                UserData = QuotaRow.DataPart.Data;

                ASSERT( (OwnerRow->KeyPart.KeyLength == QuotaRow.DataPart.DataLength - SIZEOF_QUOTA_USER_DATA) &&
                        RtlEqualMemory( OwnerRow->KeyPart.Key, &UserData->QuotaSid, OwnerRow->KeyPart.KeyLength ));

                if ((OwnerRow->KeyPart.KeyLength != QuotaRow.DataPart.DataLength - SIZEOF_QUOTA_USER_DATA) ||
                    !RtlEqualMemory( OwnerRow->KeyPart.Key,
                                     &UserData->QuotaSid,
                                     OwnerRow->KeyPart.KeyLength )) {

                    NtOfsReleaseMap( IrpContext, &MapHandle );

                    //
                    //  The Sids do not match delete both of these records.
                    //  This causes the user whatever their Sid is to get
                    //  the defaults.
                    //


                    NtOfsDeleteRecords( IrpContext,
                                        OwnerIdScb,
                                        1,
                                        &OwnerRow->KeyPart );

                    NtOfsDeleteRecords( IrpContext,
                                        QuotaScb,
                                        1,
                                        &IndexKey );

                    ReturnStatus = STATUS_QUOTA_LIST_INCONSISTENT;
                }

                NtOfsReleaseMap( IrpContext, &MapHandle );
            }

            //
            //  Release the indexes and commit what has been done so far.
            //

            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
            IndexAcquired = FALSE;

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            //
            //  Look up the next set of entries in the quota index.
            //

            Count = PAGE_SIZE / sizeof( SID );
            Status = NtOfsReadRecords( IrpContext,
                                       OwnerIdScb,
                                       &ReadContext,
                                       NULL,
                                       NtOfsMatchAll,
                                       NULL,
                                       &Count,
                                       IndexRow,
                                       PAGE_SIZE,
                                       RowBuffer );
        }

        ASSERT( (Status == STATUS_NO_MORE_MATCHES) || (Status == STATUS_NO_MATCH) );

    } finally {

        NtfsFreePool( RowBuffer );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        if (IndexAcquired) {
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (IndexRow != NULL) {
            NtfsFreePool( IndexRow );
        }

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return ReturnStatus;
}


RTL_GENERIC_COMPARE_RESULTS
NtfsQuotaTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

    This is a generic table support routine to compare two quota table elements

Arguments:

    Table - Supplies the generic table being queried.  Not used.

    FirstStruct - Supplies the first quota table element to compare

    SecondStruct - Supplies the second quota table element to compare

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/
{
    ULONG Key1 = ((PQUOTA_CONTROL_BLOCK) FirstStruct)->OwnerId;
    ULONG Key2 = ((PQUOTA_CONTROL_BLOCK) SecondStruct)->OwnerId;

    PAGED_CODE();

    if (Key1 < Key2) {

        return GenericLessThan;
    }

    if (Key1 > Key2) {

        return GenericGreaterThan;
    }

    return GenericEqual;

    UNREFERENCED_PARAMETER( Table );
}

PVOID
NtfsQuotaTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    Table - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    PAGED_CODE();

    return NtfsAllocatePoolWithTag( PagedPool, ByteSize, 'QftN' );

    UNREFERENCED_PARAMETER( Table );
}

VOID
NtfsQuotaTableFree (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine to free memory

Arguments:

    Table - Supplies the generic table being used

    Buffer - Supplies pointer to the buffer to be freed

Return Value:

    None

--*/

{
    PAGED_CODE();

    NtfsFreePool( Buffer );

    UNREFERENCED_PARAMETER( Table );
}


ULONG
NtfsGetCallersUserId (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine finds the calling thread's SID and translates it to an
    owner id.

Arguments:

Return Value:

    Returns the owner id.

--*/

{
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    PACCESS_TOKEN Token;
    PTOKEN_USER UserToken = NULL;
    NTSTATUS Status;
    ULONG OwnerId;

    PAGED_CODE();

    SeCaptureSubjectContext( &SubjectContext );

    try {

        Token = SeQuerySubjectContextToken( &SubjectContext );

        Status = SeQueryInformationToken( Token, TokenOwner, &UserToken );


        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }


        OwnerId = NtfsGetOwnerId( IrpContext, UserToken->User.Sid, FALSE, NULL );

        if (OwnerId == QUOTA_INVALID_ID) {

            //
            //  If the user does not currently have an id on this
            //  system just use the current defaults.
            //

            OwnerId = QUOTA_DEFAULTS_ID;
        }

    } finally {

        if (UserToken != NULL) {
            NtfsFreePool( UserToken);
        }

        SeReleaseSubjectContext( &SubjectContext );
    }

    return OwnerId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\prefxsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Ntfs Prefix support routines

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_PREFXSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_PREFXSUP)

//
//  Local procedures
//

#ifdef NTFS_CHECK_SPLAY
VOID
NtfsCheckSplay (
    IN PRTL_SPLAY_LINKS Root
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsFindPrefix)
#pragma alloc_text(PAGE, NtfsFindNameLink)
#pragma alloc_text(PAGE, NtfsInsertNameLink)
#pragma alloc_text(PAGE, NtfsInsertPrefix)
#pragma alloc_text(PAGE, NtfsRemovePrefix)

#ifdef NTFS_CHECK_SPLAY
#pragma alloc_text(PAGE, NtfsCheckSplay)
#endif
#endif


VOID
NtfsInsertPrefix (
    IN PLCB Lcb,
    IN ULONG CreateFlags
    )

/*++

Routine Description:

    This routine inserts the names in the given Lcb into the links for the
    parent.

Arguments:

    Lcb - This is the link to insert.

    CreateFlags - Indicates if we should insert the case-insensitive name.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT( (Lcb->Scb == NULL) ||
            NtfsIsExclusiveScb( Lcb->Scb ) );
    //
    //  Attempt to insert the case-insensitive name.  It is possible that
    //  we can't enter this name.
    //

    if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

        if (!FlagOn( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE ) &&
            NtfsInsertNameLink( &Lcb->Scb->ScbType.Index.IgnoreCaseNode,
                                &Lcb->IgnoreCaseLink )) {

            SetFlag( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE );
        }

    } else if (!FlagOn( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE )) {

        if (!NtfsInsertNameLink( &Lcb->Scb->ScbType.Index.ExactCaseNode,
                                 &Lcb->ExactCaseLink )) {

            NtfsBugCheck( 0, 0, 0 );
        }

        SetFlag( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE );
    }

    return;
}


VOID
NtfsRemovePrefix (
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine deletes all of the Prefix entries that exist for the input
    Lcb.

Arguments:

    Lcb - Supplies the Lcb whose prefixes are to be removed

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Remove the case-insensitive link.
    //

    if (FlagOn( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE )) {

        NtfsRemoveNameLink( &Lcb->Scb->ScbType.Index.IgnoreCaseNode,
                            &Lcb->IgnoreCaseLink );

        ClearFlag( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE );
    }

    //
    //  Now do the same for the exact case name.
    //

    if (FlagOn( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE )) {

        NtfsRemoveNameLink( &Lcb->Scb->ScbType.Index.ExactCaseNode,
                            &Lcb->ExactCaseLink );

        ClearFlag( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE );
    }

    return;
}


PLCB
NtfsFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB StartingScb,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    IN OUT UNICODE_STRING FullFileName,
    IN OUT PULONG CreateFlags,
    OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine begins from the given Scb and walks through all of
    components of the name looking for the longest match in the prefix
    splay trees.  The search is relative to the starting Scb so the
    full name may not begin with a '\'.  On return this routine will
    update Current Fcb with the lowest point it has travelled in the
    tree.  It will also hold only that resource on return and it must
    hold that resource.

Arguments:

    StartingScb - Supplies the Scb to start the search from.

    CurrentFcb - Address to store the lowest Fcb we find on this search.
        On return we will have acquired this Fcb.

    LcbForTeardown - If we encounter an Lcb we must teardown on error we
        store it here.

    FullFileName - Supplies the input string to search for.  After the search the
        buffer for this string will be modified so that for the characters that did
        match will be the exact case of what we found.
        
    CreateFlags - Flags for the create option - we are interested in whether
        this is a case-insensitive compare and we also will set the dos only component flag

    RemainingName - Returns the string when the prefix no longer matches.
        For example, if the input string is "alpha\beta" only matches the
        root directory then the remaining string is "alpha\beta".  If the
        same string matches an LCB for "alpha" then the remaining string is
        "beta".

Return Value:

    PLCB - Returns a pointer to the Lcb corresponding to the longest match
        in the splay tree.  NULL if we didn't even find one entry.

--*/

{
    PSCB LastScb = NULL;
    PLCB LastLcb = NULL;
    PLCB ThisLcb;
    PNAME_LINK NameLink;
    UNICODE_STRING NextComponent;
    UNICODE_STRING Tail;
    BOOLEAN DroppedParent;
    BOOLEAN NeedSnapShot = FALSE;

    PAGED_CODE();

    //
    //  Start by setting the remaining name to the full name to be parsed.
    //

    *RemainingName = FullFileName;

    //
    //  If there are no characters left or the starting Scb is not an index
    //  or the name begins with a ':' or the Fcb denotes a reparse point
    //  then return without looking up the name.
    //

    if (RemainingName->Length == 0 ||
        StartingScb->AttributeTypeCode != $INDEX_ALLOCATION ||
        RemainingName->Buffer[0] == L':' ||
        FlagOn( (StartingScb->Fcb)->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

        return NULL;
    }

    //
    //  Loop until we find the longest matching prefix.
    //

    while (TRUE) {

        ASSERT( NtfsIsExclusiveScb( StartingScb ) );

        //
        //  Get the next component off of the list.
        //

        NtfsDissectName( *RemainingName,
                         &NextComponent,
                         &Tail );

        //
        //  Check if this name is in the splay tree for this Scb.
        //

        if (FlagOn( *CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

            NameLink = NtfsFindNameLink( &StartingScb->ScbType.Index.IgnoreCaseNode,
                                         &NextComponent );

            ThisLcb = CONTAINING_RECORD( NameLink, LCB, IgnoreCaseLink );

        } else {

            NameLink = NtfsFindNameLink( &StartingScb->ScbType.Index.ExactCaseNode,
                                         &NextComponent );

            ThisLcb = CONTAINING_RECORD( NameLink, LCB, ExactCaseLink );
        }

        //
        //  If we didn't find a match then return the Fcb for the current Scb.
        //

        if (NameLink == NULL) {

            if (NeedSnapShot) {

                //
                // NtfsCreateScb was not called on the StartingScb so take a
                // snapshot now.
                //

                NtfsSnapshotScb( IrpContext, StartingScb );
            }

            return LastLcb;
        }

        //
        //  If this is a case-insensitive match then copy the exact case of the name into
        //  the input buffer.
        //

        if (FlagOn( *CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

            RtlCopyMemory( NextComponent.Buffer,
                           ThisLcb->ExactCaseLink.LinkName.Buffer,
                           NextComponent.Length );
        }

        //
        //  Update the caller's remaining name string to reflect the fact that we found
        //  a match.
        //

        *RemainingName = Tail;

        //
        //  Before we give up the previous Lcb check if the name was a DOS-ONLY
        //  name and set the return boolean if so.
        //

        if (LastLcb != NULL &&
            LastLcb->FileNameAttr->Flags == FILE_NAME_DOS) {

            SetFlag( *CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
        }

        //
        //  Update the pointers to the Lcb.
        //

        LastLcb = ThisLcb;

        DroppedParent = FALSE;

        //
        //  We want to acquire the next Fcb and release the one we currently
        //  have.  Try to do a fast acquire.
        //

        if (!NtfsAcquireFcbWithPaging( IrpContext, ThisLcb->Fcb, ACQUIRE_DONT_WAIT )) {

            //
            //  Reference the link and Fcb so they don't go away.
            //

            ThisLcb->ReferenceCount += 1;

            NtfsAcquireFcbTable( IrpContext, StartingScb->Vcb );
            ThisLcb->Fcb->ReferenceCount += 1;
            NtfsReleaseFcbTable( IrpContext, StartingScb->Vcb );

            //
            //  Set the IrpContext to acquire paging io resources if our target
            //  has one.  This will lock the MappedPageWriter out of this file.
            //

            if (ThisLcb->Fcb->PagingIoResource != NULL) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }

            NtfsReleaseScbWithPaging( IrpContext, StartingScb );

            NtfsAcquireFcbWithPaging( IrpContext, ThisLcb->Fcb, 0 );

            NtfsAcquireExclusiveScb( IrpContext, StartingScb );
            ThisLcb->ReferenceCount -= 1;
            NtfsReleaseScb( IrpContext, StartingScb );

            NtfsAcquireFcbTable( IrpContext, StartingScb->Vcb );
            ThisLcb->Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, StartingScb->Vcb );

            DroppedParent = TRUE;

        } else {

            //
            //  Don't forget to release the starting Scb.
            //

            NtfsReleaseScbWithPaging( IrpContext, StartingScb );
        }

        *LcbForTeardown = ThisLcb;
        *CurrentFcb = ThisLcb->Fcb;

        //
        //  It is possible that the Lcb we just found could have been removed
        //  from the prefix table in the window where we dropped the parent Scb.
        //  In that case we need to check that it is still in the prefix
        //  table.  If not then raise CANT_WAIT to force a rescan through the
        //  prefix table.
        //

        if (DroppedParent &&
            !FlagOn( ThisLcb->LcbState,
                     LCB_STATE_IGNORE_CASE_IN_TREE | LCB_STATE_EXACT_CASE_IN_TREE )) {

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If we found a match but the Fcb is uninitialized or is not a directory
        //  then we are done.  Also finished if the remaining name length is 0.
        //

        if (!FlagOn( ThisLcb->Fcb->FcbState, FCB_STATE_DUP_INITIALIZED ) ||
            !IsDirectory( &ThisLcb->Fcb->Info ) ||
            RemainingName->Length == 0) {

            return LastLcb;
        }

        //
        //  Get the Scb for the $INDEX_ALLOCATION for this Fcb.
        //

        LastScb = StartingScb;

        // Since the SCB is usually track on the end of the SCB look
        // for it in the FCB first.

        if (FlagOn( ThisLcb->Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
            (SafeNodeType( &((PFCB_INDEX) ThisLcb->Fcb)->Scb ) == NTFS_NTC_SCB_INDEX)) {

            NeedSnapShot = TRUE;

            StartingScb = (PSCB) &((PFCB_INDEX) ThisLcb->Fcb)->Scb;

            ASSERT(!FlagOn( StartingScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED) &&
                   (StartingScb->AttributeTypeCode == $INDEX_ALLOCATION) &&
                   NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable, &StartingScb->AttributeName, &NtfsFileNameIndex, FALSE ));

        } else {

            NeedSnapShot = FALSE;

            StartingScb = NtfsCreateScb( IrpContext,
                                         ThisLcb->Fcb,
                                         $INDEX_ALLOCATION,
                                         &NtfsFileNameIndex,
                                         FALSE,
                                         NULL );
        }

        //
        //  If there is no normalized name in this Scb, find it now.
        //

        if ((StartingScb->ScbType.Index.NormalizedName.Length == 0) &&
            (LastScb->ScbType.Index.NormalizedName.Length != 0)) {

            NtfsUpdateNormalizedName( IrpContext, LastScb, StartingScb, NULL, FALSE );
        }
    }
}


BOOLEAN
NtfsInsertNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

    The name could already exist in this tree for a case-insensitive tree.
    In that case we simply return FALSE and do nothing.

Arguments:

    RootNode - Supplies a pointer to the table.

    NameLink - Contains the new link to enter.

Return Value:

    BOOLEAN - TRUE if the name is inserted, FALSE otherwise.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PNAME_LINK Node;

    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    RtlInitializeSplayLinks( &NameLink->Links );

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &NameLink->Links;

        return TRUE;
    }

#ifdef NTFS_CHECK_SPLAY
    NtfsCheckSplay( *RootNode );      
#endif

    Node = CONTAINING_RECORD( *RootNode, NAME_LINK, Links );

    while (TRUE) {

        //
        //  Lets assume that we are appending to a directory and are greater than
        //  all entries.
        //

        Comparison = LessThan;

        //
        //  If the first characters match then we need to do a full string compare.
        //

        if (Node->LinkName.Buffer[0] == NameLink->LinkName.Buffer[0]) {

            //
            //  Figure out the minimum of the two lengths
            //

            if (Node->LinkName.Length < NameLink->LinkName.Length) {

                MinLength = Node->LinkName.Length;

            } else {

                MinLength = NameLink->LinkName.Length;
            }

            //
            //  Loop through looking at all of the characters in both strings
            //  testing for equalilty, less than, and greater than
            //

            i = (ULONG) RtlCompareMemory( Node->LinkName.Buffer, NameLink->LinkName.Buffer, MinLength );

            //
            //  Check if we didn't match up to the length of the shorter name.
            //

            if (i < MinLength) {

                if (Node->LinkName.Buffer[i / sizeof( WCHAR )] > NameLink->LinkName.Buffer[i / sizeof( WCHAR )]) {

                    Comparison = GreaterThan;
                }

            //
            //  We match up to the length of the shorter string.  If the lengths are different
            //  then move down the splay tree.
            //

            } else if (Node->LinkName.Length > NameLink->LinkName.Length) {

                Comparison = GreaterThan;

            //
            //  Exit if the strings are the same length.
            //

            } else if (Node->LinkName.Length == NameLink->LinkName.Length) {

                return FALSE;
            }

        //
        //  Compare the first characters to figure out the comparison value.
        //

        } else if (Node->LinkName.Buffer[0] > NameLink->LinkName.Buffer[0]) {

            Comparison = GreaterThan;
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == GreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild( &Node->Links ) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                *RootNode = RtlSplay( &NameLink->Links );

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases as less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild( &Node->Links ) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                *RootNode = RtlSplay( &NameLink->Links );

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }
        }
    }

#ifdef NTFS_CHECK_SPLAY
    NtfsCheckSplay( *RootNode );      
#endif
    return TRUE;
}


PNAME_LINK
NtfsFindNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine searches through a splay link tree looking for a match for the
    input name.  If we find the corresponding name we will rebalance the
    tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - This is the name to search for.  Note if we are doing a case
        insensitive search the name would have been upcased already.

Return Value:

    PNAME_LINK - The name link found or NULL if there is no match.

--*/

{
    PNAME_LINK Node;
    PRTL_SPLAY_LINKS Links;

    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    Links = *RootNode;

#ifdef NTFS_CHECK_SPLAY
    if (Links != NULL) {

        NtfsCheckSplay( Links );      
    }
#endif

    while (Links != NULL) {

        Node = CONTAINING_RECORD( Links, NAME_LINK, Links );

        //
        //  If the first characters are equal then compare the full strings.
        //

        if (Node->LinkName.Buffer[0] == Name->Buffer[0]) {

            //
            //  Figure out the minimum of the two lengths
            //

            if (Node->LinkName.Length < Name->Length) {

                MinLength = Node->LinkName.Length;

            } else {

                MinLength = Name->Length;
            }

            //
            //  Loop through looking at all of the characters in both strings
            //  testing for equalilty, less than, and greater than
            //

            i = (ULONG) RtlCompareMemory( Node->LinkName.Buffer, Name->Buffer, MinLength );

            //
            //  Check if we didn't match up to the length of the shorter name.
            //

            if (i < MinLength) {

                if (Node->LinkName.Buffer[i / sizeof( WCHAR )] < Name->Buffer[i / sizeof( WCHAR )]) {

                    //
                    //  The prefix is less than the full name
                    //  so we go down the right child
                    //

                    Links = RtlRightChild( Links );

                } else {

                    //
                    //  The prefix is greater than the full name
                    //  so we go down the left child
                    //

                    Links = RtlLeftChild( Links );
                }

            //
            //  We match up to the length of the shorter string.  If the lengths are different
            //  then move down the splay tree.
            //

            } else if (Node->LinkName.Length < Name->Length) {

                //
                //  The prefix is less than the full name
                //  so we go down the right child
                //

                Links = RtlRightChild( Links );

            } else if (Node->LinkName.Length > Name->Length) {

                //
                //  The prefix is greater than the full name
                //  so we go down the left child
                //

                Links = RtlLeftChild( Links );

            //
            //  The strings are of equal lengths.
            //

            } else {

                *RootNode = RtlSplay( Links );

#ifdef NTFS_CHECK_SPLAY
                NtfsCheckSplay( *RootNode );      
#endif
                return Node;
            }

        //
        //  The first characters are different.  Use them as a key for which
        //  way to branch.
        //

        } else if (Node->LinkName.Buffer[0] < Name->Buffer[0]) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild( Links );

        } else {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild( Links );
        }
    }

    //
    //  We didn't find the Link.
    //

    return NULL;
}



//
//  Local support routine
//

FSRTL_COMPARISON_RESULT
NtfsFullCompareNames (
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive we can do a direct memory comparison.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        LessThan    if NameA < NameB lexicalgraphically,
        GreaterThan if NameA > NameB lexicalgraphically,
        EqualTo     if NameA is equal to NameB

--*/

{
    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    //
    //  Figure out the minimum of the two lengths
    //

    if (NameA->Length < NameB->Length) {

        MinLength = NameA->Length;

    } else {

        MinLength = NameB->Length;
    }

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = (ULONG) RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );


    if (i < MinLength) {

        return (NameA->Buffer[i / sizeof( WCHAR )] < NameB->Buffer[i / sizeof( WCHAR )] ?
                LessThan :
                GreaterThan);
    }

    if (NameA->Length < NameB->Length) {

        return LessThan;
    }

    if (NameA->Length > NameB->Length) {

        return GreaterThan;
    }

    return EqualTo;
}

#ifdef NTFS_CHECK_SPLAY

VOID
NtfsCheckSplay (
    IN PRTL_SPLAY_LINKS Root
    )

{
    PRTL_SPLAY_LINKS Current;

    PAGED_CODE();

    Current = Root;

    //
    //  Root must point to itself.
    //

    if (Current->Parent != Current) {

        KdPrint(("NTFS: Bad splay root\n", 0));
        DbgBreakPoint();
    }

    goto LeftChild;
    while (TRUE) {

    LeftChild:

        //
        //  If there is a left child then verify it. 
        //

        if (Current->LeftChild != NULL) {

            //
            //  The child can't point to itself and
            //  the current node must be the parent of the
            //  child.
            //

            if ((Current->LeftChild == Current) ||
                (Current->LeftChild->Parent != Current)) {

                KdPrint(("NTFS: Bad left child\n", 0));
                DbgBreakPoint();
            }

            //
            //  Go to the left child and verify it.
            //

            Current = Current->LeftChild;
            goto LeftChild;
        }

        //
        //  If there is no left child then check for a right child.
        //

        goto RightChild;

    RightChild:

        //
        //  If there is a right child then verify it.
        //

        if (Current->RightChild != NULL) {

            //
            //  The child can't point to itself and
            //  the current node must be the parent of the
            //  child.
            //

            if ((Current->RightChild == Current) ||
                (Current->RightChild->Parent != Current)) {

                KdPrint(("NTFS: Bad Right child\n", 0));
                DbgBreakPoint();
            }

            //
            //  Go to the right child and verify it.  We always
            //  start in the left child of a new node.
            //

            Current = Current->RightChild;
            goto LeftChild;
        }

        //
        //  There is no right child.  If we are a right child then move up to
        //  the parent and keep going until we reach the root or reach a left child.
        //

        goto Parent;

    Parent:

        //
        //  We may be in the root now.
        //

        if (Current == Root) {

            return;
        }

        //
        //  If we are a left child then go to the parent and look for a right child.
        //

        if (Current == Current->Parent->LeftChild) {

            Current = Current->Parent;
            goto RightChild;
        }

        //
        //  We are a right child.  Go to the parent and check again.
        //

        Current = Current->Parent;
        goto Parent;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\quota.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Quota.c

Abstract:

    This module implements the File set and query Quota routines for Ntfs called
    by the dispatch driver.

Author:

    Jeff Havens       [Jhavens]         12-Jul-1996

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_QUOTA)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('QFtN')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonQueryQuota)
#pragma alloc_text(PAGE, NtfsCommonSetQuota)
#endif


NTSTATUS
NtfsCommonQueryQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query Quota called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_GET_QUOTA_INFORMATION UserSidList;
    PFILE_QUOTA_INFORMATION QuotaBuffer = NULL;
    PFILE_QUOTA_INFORMATION MappedQuotaBuffer = NULL;
    PFILE_QUOTA_INFORMATION OriginalQuotaBuffer;
    ULONG OriginalBufferLength;
    ULONG UserBufferLength;
    ULONG UserSidListLength;
    PSID UserStartSid;
    ULONG OwnerId;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;
    BOOLEAN TempBufferAllocated = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryQuota\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("SystemBuffer       = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.QueryQuota.Length) );
    DebugTrace( 0, Dbg, ("SidList            = %08lx\n", IrpSp->Parameters.QueryQuota.SidList) );
    DebugTrace( 0, Dbg, ("SidListLength      = %08lx\n", IrpSp->Parameters.QueryQuota.SidListLength) );
    DebugTrace( 0, Dbg, ("StartSid           = %08lx\n", IrpSp->Parameters.QueryQuota.StartSid) );
    DebugTrace( 0, Dbg, ("RestartScan        = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, ("ReturnSingleEntry  = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, ("IndexSpecified     = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED)) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    UserBufferLength = IrpSp->Parameters.QueryQuota.Length;
    UserSidList = IrpSp->Parameters.QueryQuota.SidList;
    UserSidListLength = IrpSp->Parameters.QueryQuota.SidListLength;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This must be a user file or directory and the Ccb must indicate that
    //  the caller opened the entire file. We don't like zero length user buffers or SidLists either.
    //

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen) &&
         (TypeOfOpen != UserVolumeOpen) &&
         (TypeOfOpen != UserViewIndexOpen)) ||
         (UserBufferLength == 0) ||
         ((UserSidList != NULL) && (UserSidListLength == 0)) ||
        (Ccb == NULL) ||
        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryQuota -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Return nothing if quotas are not enabled.
    //

    if (Vcb->QuotaTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Acquire the Vcb Shared.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Reference our input parameters to make things easier
        //

        UserStartSid = IrpSp->Parameters.QueryQuota.StartSid;
        RestartScan = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
        ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
        IndexSpecified = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

        //
        //  Initialize our local variables.
        //

        Status = STATUS_SUCCESS;

        //
        //  Map the user's buffer.
        //

        QuotaBuffer = NtfsMapUserBuffer( Irp );

        //
        //  Allocate our own output buffer out of paranoia.
        //

        if (Irp->RequestorMode != KernelMode) {

            MappedQuotaBuffer = QuotaBuffer;
            QuotaBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );
            TempBufferAllocated = TRUE;
        }

        OriginalBufferLength = UserBufferLength;
        OriginalQuotaBuffer = QuotaBuffer;

        //
        //  Let's clear the output buffer.
        //

        RtlZeroMemory( QuotaBuffer, UserBufferLength );

        //
        //  We now satisfy the user's request depending on whether he
        //  specified an Quota name list, an Quota index or restarting the
        //  search.
        //

        //
        //  The user has supplied a list of Quota names.
        //

        if (UserSidList != NULL) {

            Status = NtfsQueryQuotaUserSidList( IrpContext,
                                                Vcb,
                                                UserSidList,
                                                QuotaBuffer,
                                                &UserBufferLength,
                                                ReturnSingleEntry );

        } else {

            //
            //  The user supplied an index into the Quota list.
            //

            if (IndexSpecified) {

                OwnerId = NtfsGetOwnerId( IrpContext,
                                          UserStartSid,
                                          FALSE,
                                          NULL );

                if (OwnerId == QUOTA_INVALID_ID) {

                    //
                    //  Fail the request.
                    //

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

            } else {

                //
                //  Start at the begining of the list if restart specified.
                //

                OwnerId = RestartScan ? QUOTA_FISRT_USER_ID - 1 : Ccb->LastOwnerId;

            }

            Status = NtfsFsQuotaQueryInfo( IrpContext,
                                           Vcb,
                                           OwnerId,
                                           ReturnSingleEntry,
                                           &QuotaBuffer,
                                           &UserBufferLength,
                                           Ccb );

            //
            //  If we specified SingleEntry, NextEntryOffset would still be uninitialized.
            //

            if (NT_SUCCESS( Status ) && ReturnSingleEntry) {

                QuotaBuffer->NextEntryOffset = 0;
            }

        }

        //
        //  Copy the data onto the user buffer if we ended up allocating
        //  a temporary buffer to work on. Check if there's anything to copy, too.
        //  UserBufferLength reflects how much of the buffer is left.
        //

        if (TempBufferAllocated &&
            (UserBufferLength < OriginalBufferLength)) {

            try {

                RtlCopyMemory( MappedQuotaBuffer, OriginalQuotaBuffer,
                               OriginalBufferLength - UserBufferLength );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                try_return( Status = STATUS_INVALID_USER_BUFFER );
            }
        }

        if (UserBufferLength <= OriginalBufferLength) {

            Irp->IoStatus.Information = OriginalBufferLength - UserBufferLength;

        } else {

            ASSERT( FALSE );
            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsCommonQueryQuota );

        //
        //  Release the Vcb.
        //

        NtfsReleaseVcb( IrpContext, Vcb );

        if (TempBufferAllocated) {

            NtfsFreePool( OriginalQuotaBuffer );
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsCommonQueryQuota -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsCommonSetQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set Quota called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_QUOTA_INFORMATION Buffer;
    PFILE_QUOTA_INFORMATION SafeBuffer = NULL;
    ULONG UserBufferLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetQuota\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Initialize the IoStatus values.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    UserBufferLength = IrpSp->Parameters.SetQuota.Length;

    //
    //  Check that the file object is associated with either a user file or
    //  user directory open or an open by file ID.
    //

    if ((Ccb == NULL) ||

        (!FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS) &&
         ((TypeOfOpen != UserViewIndexOpen) || (Fcb != Vcb->QuotaTableScb->Fcb))) ||

        (UserBufferLength == 0) ||

        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        if (UserBufferLength != 0) {

            Status = STATUS_ACCESS_DENIED;

        } else {

            Status = STATUS_INVALID_PARAMETER;
        }

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryQuota -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We must be writable.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonSetQuota -> %08lx\n", Status) );
        return Status;
    }

    //
    //  We must be waitable.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsCommonSetQuota -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Acquire the vcb shared.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Map the user's Quota buffer.
        //

        Buffer = NtfsMapUserBuffer( Irp );

        //
        // Be paranoid and copy the user buffer into kernel space.
        //

        if (Irp->RequestorMode != KernelMode) {

            SafeBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );

            try {

                RtlCopyMemory( SafeBuffer, Buffer, UserBufferLength );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            Buffer = SafeBuffer;
        }

        //
        //  Update the caller's Iosb.
        //

        Irp->IoStatus.Information = 0;
        Status = STATUS_SUCCESS;

        Status = NtfsFsQuotaSetInfo( IrpContext,
                                     Vcb,
                                     Buffer,
                                     UserBufferLength );

        //
        //  Check if there are transactions to cleanup.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonSetQuota );

        //
        //  Release the Vcb.
        //

        NtfsReleaseVcb( IrpContext, Vcb );

        //
        // If we allocated a temporary buffer, free it.
        //

        if (SafeBuffer != NULL) {

            NtfsFreePool( SafeBuffer );
        }

        //
        //  Complete the Irp.
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonSetQuota -> %08lx\n", Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\reparsup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    MountSup.c

Abstract:

    This module implements the support routines in Ntfs for reparse points.

Author:

    Felipe Cabrera     [cabrera]        30-Jun-1997

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg DEBUG_TRACE_FSCTRL

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('PFtN')



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsInitializeReparsePointIndex)
#endif



VOID
NtfsInitializeReparsePointIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the mount points index for the volume.  If the index does not
    exist it is created and initialized.

Arguments:

    Fcb - Pointer to Fcb for the object id file.

    Vcb - Volume control block for volume being mounted.

Return Value:

    None

--*/

{
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$R" );

    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        NtOfsCreateIndex( IrpContext,
                          Fcb,
                          IndexName,
                          CREATE_OR_OPEN,
                          0,
                          COLLATION_NTOFS_ULONGS,
                          NtOfsCollateUlongs,
                          NULL,
                          &Vcb->ReparsePointTableScb );
    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\resrcsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Ntfs Resource acquisition routines

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

#undef _NTFSLOCKORDER_
#define _NTFS_NTFSDBG_DEFINITIONS_
#include "lockorder.h"

#ifdef NTFSDBG
ULONG NtfsAssertOnLockProb = TRUE;
ULONG NtfsPrintOnLockProb = FALSE;
LONG  NtfsBreakOnState = -1;
PIRP_CONTEXT NtfsBreakOnIrpContext = NULL;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAcquireAllFiles)
#pragma alloc_text(PAGE, NtfsAcquireCheckpointSynchronization)
#pragma alloc_text(PAGE, NtfsAcquireIndexCcb)
#pragma alloc_text(PAGE, NtfsReleaseIndexCcb)
#pragma alloc_text(PAGE, NtfsAcquireExclusiveFcb)
#pragma alloc_text(PAGE, NtfsAcquireSharedFcbCheckWait)
#pragma alloc_text(PAGE, NtfsAcquireExclusiveScb)
#pragma alloc_text(PAGE, NtfsAcquireSharedScbForTransaction)
#pragma alloc_text(PAGE, NtfsAcquireExclusiveVcb)
#pragma alloc_text(PAGE, NtfsAcquireFcbWithPaging)
#pragma alloc_text(PAGE, NtfsAcquireForCreateSection)
#pragma alloc_text(PAGE, NtfsAcquireScbForLazyWrite)
#pragma alloc_text(PAGE, NtfsAcquireFileForCcFlush)
#pragma alloc_text(PAGE, NtfsAcquireFileForModWrite)
#pragma alloc_text(PAGE, NtfsAcquireSharedVcb)
#pragma alloc_text(PAGE, NtfsAcquireVolumeFileForLazyWrite)
#pragma alloc_text(PAGE, NtfsReleaseAllFiles)
#pragma alloc_text(PAGE, NtfsReleaseCheckpointSynchronization)
#pragma alloc_text(PAGE, NtfsReleaseFcbWithPaging)
#pragma alloc_text(PAGE, NtfsReleaseFileForCcFlush)
#pragma alloc_text(PAGE, NtfsReleaseForCreateSection)
#pragma alloc_text(PAGE, NtfsReleaseScbFromLazyWrite)
#pragma alloc_text(PAGE, NtfsReleaseScbWithPaging)
#pragma alloc_text(PAGE, NtfsReleaseSharedResources)
#pragma alloc_text(PAGE, NtfsReleaseVolumeFileFromLazyWrite)
#endif


VOID
NtfsAcquireAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Exclusive,
    IN ULONG AcquirePagingIo,
    IN ULONG AcquireAndDrop
    )

/*++

Routine Description:

    This routine non-recursively requires all files on a volume.

Arguments:

    Vcb - Supplies the volume

    Exclusive - Indicates if we should be acquiring all the files exclusively.
        If FALSE then we acquire all the files shared except for files with
        streams which could be part of transactions.

    AcquirePagingIo - Indicates if we need to acquire the paging io resource
        exclusively.  Only needed if a future call will flush the volume
        (i.e. shutdown)

    AcquireAndDrop - Indicates that we only want to acquire and drop each resource.
        Used in cases where we just want to set some state in the Vcb and then
        know that everyone has seen it before proceeding (i.e. Clearing the journal active
        flag).  Should only be TRUE if we want to get the resources exclusive.

Return Value:

    None

--*/

{
    PFCB Fcb;
    PSCB *Scb;
    PSCB NextScb;
    PVOID RestartKey;

    PAGED_CODE();

    //
    //  Check for the correct combination of flags.
    //

    ASSERT( !AcquireAndDrop || Exclusive );

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    RestartKey = NULL;
    while (TRUE) {

        NtfsAcquireFcbTable( IrpContext, Vcb );
        Fcb = NtfsGetNextFcbTableEntry(Vcb, &RestartKey);
        NtfsReleaseFcbTable( IrpContext, Vcb );

        if (Fcb == NULL) {

            break;
        }

        ASSERT_FCB( Fcb );

        //
        //  We can skip over the Fcb's for any of the Scb's in the Vcb.
        //  We delay acquiring those to avoid deadlocks.
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

            //
            //  If there is a paging Io resource then acquire this if required.
            //

            if (AcquirePagingIo && (Fcb->PagingIoResource != NULL)) {

                ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );

                if (AcquireAndDrop) {

                    ExReleaseResourceLite( Fcb->PagingIoResource );
                }
            }

            //
            //  Acquire this Fcb whether or not the underlying file has been deleted.
            //

            if (Exclusive ||
                IsDirectory( &Fcb->Info )) {

                if (AcquireAndDrop) {

                    NtfsAcquireResourceExclusive( IrpContext, Fcb, TRUE );
                    NtfsReleaseResource( IrpContext, Fcb );

                } else {

                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }

            } else {

                //
                //  Assume that we only need this file shared.  We will then
                //  look for Lsn related streams.
                //

                NtfsAcquireSharedFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );

                //
                //  Walk through all of the Scb's for the file and look for
                //  an Lsn protected stream.
                //

                NtfsLockFcb( IrpContext, Fcb );

                NextScb = NULL;

                while (NextScb = NtfsGetNextChildScb( Fcb, NextScb )) {

                    if (NextScb->AttributeTypeCode != $DATA) {
                        break;
                    }
                }

                NtfsUnlockFcb( IrpContext, Fcb );

                //
                //  If we found a protected Scb then release and reacquire the Fcb
                //  exclusively.
                //

                if (NextScb != NULL) {

                    NtfsReleaseFcb( IrpContext, Fcb );
                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }
            }
        }
    }

    //
    //  Now acquire the Fcb's in the Vcb.
    //

    Scb = &Vcb->MftBitmapScb;

    //
    //  Ordering dependent on the fact we acquired root up above because its not a system file
    //

    ASSERT( (NULL == Vcb->RootIndexScb) || !FlagOn( Vcb->RootIndexScb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE  ) );

    while (TRUE) {

        if (Scb == &Vcb->UsnJournal) {

            break;
        }

        Scb -= 1;

        if ((*Scb != NULL)
            && (*Scb != Vcb->BitmapScb)) {

            if (AcquireAndDrop) {

                if (AcquirePagingIo && ((*Scb)->Fcb->PagingIoResource != NULL)) {

                    ExAcquireResourceExclusiveLite( (*Scb)->Fcb->PagingIoResource, TRUE );
                    ExReleaseResourceLite( (*Scb)->Fcb->PagingIoResource );
                }

                NtfsAcquireResourceExclusive( IrpContext, (*Scb), TRUE );
                NtfsReleaseResource( IrpContext, (*Scb) );

            } else {

                if (AcquirePagingIo && ((*Scb)->Fcb->PagingIoResource != NULL)) {

                    ExAcquireResourceExclusiveLite( (*Scb)->Fcb->PagingIoResource, TRUE );
                }

                NtfsAcquireExclusiveFcb( IrpContext, (*Scb)->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
            }
        }
    }

    //
    //  Treat the bitmap as an end resource and acquire it last.
    //

    if (Vcb->BitmapScb != NULL) {

        ULONG AcquireFlags = ACQUIRE_NO_DELETE_CHECK;

        if (AcquireAndDrop) {

            if (AcquirePagingIo && (Vcb->BitmapScb->Fcb->PagingIoResource != NULL)) {

                ExAcquireResourceExclusiveLite( Vcb->BitmapScb->Fcb->PagingIoResource, TRUE );
                ExReleaseResourceLite( Vcb->BitmapScb->Fcb->PagingIoResource );
            }

            NtfsAcquireResourceExclusive( IrpContext, Vcb->BitmapScb, TRUE );
            NtfsReleaseResource( IrpContext, Vcb->BitmapScb );

        } else {

            if (AcquirePagingIo && (Vcb->BitmapScb->Fcb->PagingIoResource != NULL)) {

                ExAcquireResourceExclusiveLite( Vcb->BitmapScb->Fcb->PagingIoResource, TRUE );
            }

            NtfsAcquireExclusiveFcb( IrpContext, Vcb->BitmapScb->Fcb, NULL, AcquireFlags );
        }
    }

    //
    //  If we don't have to release the files then don't bump this number.
    //

    if (!AcquireAndDrop) {

        Vcb->AcquireFilesCount += 1;

    } else {

        NtfsReleaseVcb( IrpContext, Vcb );
    }
    return;
}


VOID
NtfsReleaseAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN ReleasePagingIo
    )

/*++

Routine Description:

    This routine non-recursively requires all files on a volume.

Arguments:

    Vcb - Supplies the volume

    ReleasePagingIo - Indicates whether we should release the paging io resources
        as well.

Return Value:

    None

--*/

{
    PFCB Fcb;
    PSCB *Scb;
    PVOID RestartKey;

    PAGED_CODE();

    ASSERT( Vcb->AcquireFilesCount != 0 );
    Vcb->AcquireFilesCount -= 1;

    //
    //  Loop to flush all of the prerestart streams, to do the loop
    //  we cycle through the Fcb Table and for each fcb we acquire it.
    //

    RestartKey = NULL;
    while (TRUE) {

        NtfsAcquireFcbTable( IrpContext, Vcb );
        Fcb = NtfsGetNextFcbTableEntry(Vcb, &RestartKey);
        NtfsReleaseFcbTable( IrpContext, Vcb );

        if (Fcb == NULL) {

            break;
        }

        ASSERT_FCB( Fcb );

        if (!FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

            //
            //  Release the file.
            //

            if (ReleasePagingIo && (Fcb->PagingIoResource != NULL)) {

                ExReleaseResourceLite( Fcb->PagingIoResource );
            }

            NtfsReleaseFcb( IrpContext, Fcb );
        }
    }

    //
    //  Now release the Fcb's in the Vcb.
    //

    Scb = &Vcb->RootIndexScb;

    while (TRUE) {

        if (Scb == &Vcb->ObjectIdTableScb) {

            break;
        }

        Scb += 1;

        if (*Scb != NULL) {

            if (ReleasePagingIo && ((*Scb)->Fcb->PagingIoResource != NULL)) {

                ExReleaseResourceLite( (*Scb)->Fcb->PagingIoResource );
            }

            NtfsReleaseFcb( IrpContext, (*Scb)->Fcb );
        }
    }

    NtfsReleaseVcb( IrpContext, Vcb );

    return;
}


VOID
NtfsAcquireCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    Synchronize with checkpointing - this blocks out all fuzzy / clean checkpoints

Arguments:

    Vcb - Supplies the Vcb to synchronize with

Return Value:

--*/

{
    PAGED_CODE();

    NtfsAcquireCheckpoint( IrpContext, Vcb );

    while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

        //
        //  Release the checkpoint event because we cannot checkpoint now.
        //

        NtfsReleaseCheckpoint( IrpContext, Vcb );
        NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
        NtfsAcquireCheckpoint( IrpContext, Vcb );
    }

    SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
    NtfsResetCheckpointNotify( IrpContext, Vcb );
    NtfsReleaseCheckpoint( IrpContext, Vcb );
}



VOID
NtfsReleaseCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    Synchronize with checkpointing - this blocks out all fuzzy / clean checkpoints

Arguments:

    Vcb - Supplies the Vcb to synchronize with

Return Value:

--*/

{
    PAGED_CODE();

    NtfsAcquireCheckpoint( IrpContext, Vcb );
    ClearFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
    NtfsSetCheckpointNotify( IrpContext, Vcb );
    NtfsReleaseCheckpoint( IrpContext, Vcb );

    UNREFERENCED_PARAMETER( IrpContext );
}


BOOLEAN
NtfsAcquireExclusiveVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Vcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Vcb - Supplies the Vcb to acquire

    RaiseOnCantWait - Indicates if we should raise on an acquisition error
        or simply return a BOOLEAN indicating that we couldn't get the
        resource.

Return Value:

    BOOLEAN - Indicates if we were able to acquire the resource.  This is really
        only meaningful if the RaiseOnCantWait value is FALSE.

--*/

{
    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_VCB(Vcb);

    PAGED_CODE();

    if (ExAcquireResourceExclusiveLite( &Vcb->Resource, (BOOLEAN) FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT))) {

#ifdef NTFSDBG
        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
            if (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource )) {
                NtfsChangeResourceOrderState( IrpContext, NtfsResourceExVcb, FALSE, (BOOLEAN) !FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );
            }
        }
#endif

        return TRUE;
    }

    if (RaiseOnCantWait) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    return FALSE;
}


BOOLEAN
NtfsAcquireSharedVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    )

/*++

Routine Description:

    This routine acquires shared access to the Vcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Vcb - Supplies the Vcb to acquire

    RaiseOnCantWait - Indicates if we should raise on an acquisition error
        or simply return a BOOLEAN indicating that we couldn't get the
        resource.

        N.B. -- If you pass FALSE for this parameter you ABSOLUTELY MUST
                test the return value.  Otherwise you aren't certain that
                you hold the Vcb, and you don't know if it's safe to free it.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_VCB(Vcb);

    PAGED_CODE();

    if (ExAcquireResourceSharedLite( &Vcb->Resource, (BOOLEAN) FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT))) {

#ifdef NTFSDBG
        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
            if (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource )) {
                NtfsChangeResourceOrderState( IrpContext, NtfsResourceSharedVcb, FALSE, (BOOLEAN) !FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );
            }
        }
#endif

        return TRUE;
    }

    if (RaiseOnCantWait) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

    } else {

        return FALSE;
    }
}

#ifdef NTFSDBG


VOID
NtfsReleaseVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )
/*++

Routine Description:

    This routine will release the Vcb. Normally its a define for lock_order testing
    we use a function so we can easily change the owernship state

Arguments:

    Vcb - Supplies the Vcb to release


Return Value:

    None.
--*/

{
    if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
        if ((ExIsResourceAcquiredExclusiveLite( &Vcb->Resource)) &&
            (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource ))) {
            NtfsChangeResourceOrderState( IrpContext, NtfsResourceExVcb, TRUE, FALSE );
        } else if (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource )) {
            NtfsChangeResourceOrderState( IrpContext, NtfsResourceSharedVcb, TRUE, FALSE );
        }
    } else {
        IrpContext->OwnershipState = None;
    }
    ExReleaseResourceLite( &Vcb->Resource );
}
#endif


VOID
NtfsReleaseVcbCheckDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR MajorCode,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine will release the Vcb.  We will also test here whether we should
    teardown the Vcb at this point.  If this is the last open queued to a dismounted
    volume or the last close from a failed mount or the failed mount then we will
    want to test the Vcb for a teardown.

Arguments:

    Vcb - Supplies the Vcb to release

    MajorCode - Indicates what type of operation we were called from.

    FileObject - Optionally supplies the file object whose VPB pointer we need to
        zero out

Return Value:

    None.

--*/

{
    BOOLEAN ReleaseVcb = TRUE;

    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_VCB(Vcb);

    if (FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT ) &&
        (Vcb->CloseCount == 0)) {

        ULONG ReferenceCount;
        ULONG ResidualCount;

        KIRQL SavedIrql;
        BOOLEAN DeleteVcb = FALSE;

        ASSERT_EXCLUSIVE_RESOURCE( &Vcb->Resource );

        //
        //  The volume has gone through dismount.  Now we need to decide if this
        //  release of the Vcb is the last reference for this volume.  If so we
        //  can tear the volume down.
        //
        //  We compare the reference count in the Vpb with the state of the volume
        //  and the type of operation.  We also need to check if there is a
        //  referenced log file object.
        //
        //  If the temp vpb flag isn't set then we already let the iosubsys
        //  delete it during dismount
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_TEMP_VPB )) {

            IoAcquireVpbSpinLock( &SavedIrql );
            ReferenceCount = Vcb->Vpb->ReferenceCount;
            IoReleaseVpbSpinLock( SavedIrql );

        } else {

            ReferenceCount = 0;
        }


        ResidualCount = 0;

        if ((Vcb->LogFileObject != NULL) &&
            !FlagOn( Vcb->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE )) {

            ResidualCount = 1;
        }

        if (MajorCode == IRP_MJ_CREATE) {

            ResidualCount += 1;
        }

        //
        //  If the residual count is the same as the count in the Vpb then we
        //  can delete the Vpb.
        //

        if ((ResidualCount == ReferenceCount) &&
            !FlagOn( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY )) {

            SetFlag( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY );

            //
            //  Release the vcb before we grab the global
            //

#ifdef NTFSDBG
            if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                if (1 == ExIsResourceAcquiredExclusiveLite( &Vcb->Resource) ) {
                    NtfsChangeResourceOrderState( IrpContext, NtfsResourceExVcb, TRUE, FALSE );
                }
            }
#endif
            ExReleaseResourceLite( &Vcb->Resource );
            ReleaseVcb = FALSE;

            //
            //  Never delete the Vcb unless this is the last release of
            //  this Vcb.
            //

            if (ExIsResourceAcquiredSharedLite( &Vcb->Resource ) ==  0) {

                if (ARGUMENT_PRESENT(FileObject)) { FileObject->Vpb = NULL; }

                //
                //  If this is a create then the IO system will handle the
                //  Vpb.
                //

                if (MajorCode == IRP_MJ_CREATE) {

                    ClearFlag( Vcb->VcbState, VCB_STATE_TEMP_VPB );
                }

                //
                //  Use the global resource to synchronize the DeleteVcb process.
                //

                NtfsAcquireExclusiveGlobal( IrpContext, TRUE );
                RemoveEntryList( &Vcb->VcbLinks );
                NtfsReleaseGlobal( IrpContext );

                //
                //  Try to delete the Vcb, reinsert into the queue if
                //  the delete is blocked.
                //

                if (!NtfsDeleteVcb( IrpContext, &Vcb )) {

                    ClearFlag( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY );

                    NtfsAcquireExclusiveGlobal( IrpContext, TRUE );
                    InsertHeadList( &NtfsData.VcbQueue, &Vcb->VcbLinks );
                    NtfsReleaseGlobal( IrpContext );
                }
            } else {

                //
                //  From test above we must still own the vcb so its safe to change the flag
                //

                ClearFlag( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY );
            }
        }
    }

    if (ReleaseVcb) {

#ifdef NTFSDBG
        if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
            if (1 == ExIsResourceAcquiredExclusiveLite( &Vcb->Resource) ) {
                NtfsChangeResourceOrderState( IrpContext, NtfsResourceExVcb, TRUE, FALSE );
            }
        }
#endif
        ExReleaseResourceLite( &Vcb->Resource );
    }
}


BOOLEAN
NtfsAcquireFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine is used in the create path, fsctl path and close path .  It acquires the Fcb
    and also the paging IO resource if it exists but only if the irpcontext flag is set.
    i.e during a create  supersede/overwrite operation.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Fcb - Supplies the Fcb to acquire

    AcquireFlags - ACQUIRE_DONT_WAIT overrides the wait value in the IrpContext.
        We won't wait for the resource and return whether the resource
        was acquired.

Return Value:

    BOOLEAN - TRUE if acquired.  FALSE otherwise.

--*/

{
    BOOLEAN Status = FALSE;
    BOOLEAN Wait = FALSE;
    BOOLEAN PagingIoAcquired = FALSE;

    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_FCB(Fcb);

    PAGED_CODE();

    //
    //  Sanity check that this is create.  The supersede flag is only
    //  set in the create path and only tested here.
    //

    ASSERT( IrpContext->MajorFunction == IRP_MJ_CREATE ||
            IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL ||
            IrpContext->MajorFunction == IRP_MJ_CLOSE ||
            IrpContext->MajorFunction == IRP_MJ_SET_INFORMATION ||
            IrpContext->MajorFunction == IRP_MJ_SET_VOLUME_INFORMATION ||
            IrpContext->MajorFunction == IRP_MJ_SET_EA );

    if (!FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT ) && FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Wait = TRUE;
    }

    //
    //  Free any exclusive paging I/O resource, we currently have, which
    //  must presumably be from a directory with a paging I/O resource.
    //
    //  We defer releasing the paging io resource when we have logged
    //  changes against a stream.  The only transaction that should be
    //  underway at this point is the create file case where we allocated
    //  a file record.  In this case it is OK to release the paging io
    //  resource for the parent.
    //

    if (IrpContext->CleanupStructure != NULL) {

        ASSERT( IrpContext->CleanupStructure != Fcb );

        //  ASSERT(IrpContext->TransactionId == 0);
        NtfsReleasePagingIo( IrpContext, IrpContext->CleanupStructure );
    }

    //
    //  Loop until we get it right - worst case is twice through loop.
    //

    while (TRUE) {

        //
        //  Acquire Paging I/O first.  Testing for the PagingIoResource
        //  is not really safe without holding the main resource, so we
        //  correct for that below.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) &&
            (Fcb->PagingIoResource != NULL)) {
            if (!ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, Wait )) {
                break;
            }
            IrpContext->CleanupStructure = Fcb;
            PagingIoAcquired = TRUE;
        }

        //
        //  Let's acquire this Fcb exclusively.
        //

        if (!NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK | AcquireFlags )) {

            if (PagingIoAcquired) {
                ASSERT(IrpContext->TransactionId == 0);
                NtfsReleasePagingIo( IrpContext, Fcb );
            }
            break;
        }

        //
        //  If we now do not see a paging I/O resource we are golden,
        //  othewise we can absolutely release and acquire the resources
        //  safely in the right order, since a resource in the Fcb is
        //  not going to go away.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) ||
            PagingIoAcquired ||
            (Fcb->PagingIoResource == NULL)) {

            Status = TRUE;
            break;
        }

        NtfsReleaseFcb( IrpContext, Fcb );
    }

    return Status;
}


VOID
NtfsReleaseFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine releases access to the Fcb, including its
    paging I/O resource if it exists.

Arguments:

    Fcb - Supplies the Fcb to acquire

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_FCB(Fcb);

    PAGED_CODE();

    //
    //  We test that we currently hold the paging Io exclusive before releasing
    //  it. Checking the ExclusivePagingFcb in the IrpContext tells us if
    //  it is ours.
    //

    if ((IrpContext->TransactionId == 0) &&
        (IrpContext->CleanupStructure == Fcb)) {
        NtfsReleasePagingIo( IrpContext, Fcb );
    }

    NtfsReleaseFcb( IrpContext, Fcb );
}


VOID
NtfsReleaseScbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine releases access to the Scb, including its
    paging I/O resource if it exists.

Arguments:

    Scb - Supplies the Fcb to acquire

Return Value:

    None.

--*/

{
    PFCB Fcb = Scb->Fcb;

    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_SCB(Scb);

    PAGED_CODE();

    //
    //  Release the paging Io resource in the Scb under the following
    //  conditions.
    //
    //      - No transaction underway
    //      - This paging Io resource is in the IrpContext
    //          (This last test insures there is a paging IO resource
    //           and we own it).
    //

    if ((IrpContext->TransactionId == 0) &&
        (IrpContext->CleanupStructure == Fcb)) {
        NtfsReleasePagingIo( IrpContext, Fcb );
    }

    NtfsReleaseScb( IrpContext, Scb );
}


BOOLEAN
NtfsAcquireExclusiveFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Fcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Fcb - Supplies the Fcb to acquire

    Scb - This is the Scb for which we are acquiring the Fcb

    AcquireFlags - Indicating whether to override the wait value in the IrpContext.  Also whether
        to noop the check for a deleted file.

Return Value:

    BOOLEAN - TRUE if acquired.  FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOLEAN Wait;

    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_FCB(Fcb);

    PAGED_CODE();

    Status = STATUS_CANT_WAIT;

    if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {
        Wait = FALSE;
    } else if (FlagOn( AcquireFlags, ACQUIRE_WAIT )) {
        Wait = TRUE;
    } else {
        Wait = BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }

    if (NtfsAcquireResourceExclusive( IrpContext, Fcb, Wait )) {

        //
        //  The link count should be non-zero or the file has been
        //  deleted.  We allow deleted files to be acquired for close and
        //  also allow them to be acquired recursively in case we
        //  acquire them a second time after marking them deleted (i.e. rename)
        //

        if (FlagOn( AcquireFlags, ACQUIRE_NO_DELETE_CHECK )

            ||

            (!FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )
             && (!ARGUMENT_PRESENT( Scb )
                 || !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )))

            ||

            (IrpContext->MajorFunction == IRP_MJ_CLOSE)

            ||

            (IrpContext->MajorFunction == IRP_MJ_CREATE)

            ||

            (IrpContext->MajorFunction == IRP_MJ_CLEANUP)) {

            //
            //  Put Fcb in the exclusive Fcb list for this IrpContext,
            //  excluding the bitmap for the volume, since we do not need
            //  to modify its file record and do not want unnecessary
            //  serialization/deadlock problems.
            //
            //  If we are growing the volume bitmap then we do want to put
            //  it on the list and maintain the BaseExclusiveCount.  Also
            //  need to do this in the case where we see the volume bitmap
            //  during close (it can happen during restart if we have log
            //  records for the volume bitmap).
            //

            //
            //  If Fcb already acquired then bump the count.
            //

            if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

                Fcb->BaseExclusiveCount += 1;

            //
            //  The fcb is not currently on an exclusive list.
            //  Put it on a list if this is not the volume
            //  bitmap or we explicitly want to put the volume
            //  bitmap on the list.
            //

            } else if (FlagOn( AcquireFlags, ACQUIRE_HOLD_BITMAP ) ||
                       (Fcb->Vcb->BitmapScb == NULL) ||
                       (Fcb->Vcb->BitmapScb->Fcb != Fcb)) {

                ASSERT( Fcb->BaseExclusiveCount == 0 );

                InsertHeadList( &IrpContext->ExclusiveFcbList,
                                &Fcb->ExclusiveFcbLinks );

                Fcb->BaseExclusiveCount += 1;
            }

            return TRUE;
        }

        //
        //  We need to release the Fcb and remember the status code.
        //

        NtfsReleaseResource( IrpContext, Fcb );
        Status = STATUS_FILE_DELETED;

    } else if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {

        return FALSE;
    }

    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
}


VOID
NtfsAcquireSharedFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine acquires shared access to the Fcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Fcb - Supplies the Fcb to acquire

    Scb - This is the Scb for which we are acquiring the Fcb

    AcquireFlags - Indicates if we should acquire the file even if it has been
        deleted.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_FCB(Fcb);

    Status = STATUS_CANT_WAIT;

    if (NtfsAcquireResourceShared( IrpContext, Fcb, (BOOLEAN) FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT))) {

        //
        //  The link count should be non-zero or the file has been
        //  deleted.
        //

        if (FlagOn( AcquireFlags, ACQUIRE_NO_DELETE_CHECK ) ||
            (!FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) &&
             (!ARGUMENT_PRESENT( Scb ) ||
              !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )))) {

            //
            //  It's possible that this is a recursive shared aquisition of an
            //  Fcb we own exclusively at the top level.  In that case we
            //  need to bump the acquisition count.
            //

            if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

                Fcb->BaseExclusiveCount += 1;
            }

            return;
        }

        //
        //  We need to release the Fcb and remember the status code.
        //

        NtfsReleaseResource( IrpContext, Fcb );
        Status = STATUS_FILE_DELETED;
    }

    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
}


BOOLEAN
NtfsAcquireSharedFcbCheckWait (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine acquires shared access to the Fcb but checks whether to wait.

Arguments:

    Fcb - Supplies the Fcb to acquire

    AcquireFlags - Indicates if we should override the wait value in the IrpContext.
        We won't wait for the resource and return whether the resource
        was acquired.

Return Value:

    BOOLEAN - TRUE if acquired.  FALSE otherwise.

--*/

{
    BOOLEAN Wait;
    PAGED_CODE();

    if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {
        Wait = FALSE;
    } else if (FlagOn( AcquireFlags, ACQUIRE_WAIT )) {
        Wait = TRUE;
    } else {
        Wait = BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }

    if (NtfsAcquireResourceShared( IrpContext, Fcb, Wait )) {

        //
        //  It's possible that this is a recursive shared aquisition of an
        //  Fcb we own exclusively at the top level.  In that case we
        //  need to bump the acquisition count.
        //

        if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

            Fcb->BaseExclusiveCount += 1;
        }

        return TRUE;

    } else {

        return FALSE;
    }
}


VOID
NtfsReleaseFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine releases the specified Fcb resource.  If the Fcb is acquired
    exclusive, and a transaction is still active, then the release is nooped
    in order to preserve two-phase locking.  If there is no longer an active
    transaction, then we remove the Fcb from the Exclusive Fcb List off the
    IrpContext, and clear the Flink as a sign.  Fcbs are released when the
    transaction is commited.

Arguments:

    Fcb - Fcb to release

Return Value:

    None.

--*/

{
    //
    //  Check if this resource is owned exclusively and we are at the last
    //  release for this transaction.
    //

    if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

        if (Fcb->BaseExclusiveCount == 1) {

            //
            //  If there is a transaction then noop this request.
            //

            if (IrpContext->TransactionId != 0) {

                return;
            }

            RemoveEntryList( &Fcb->ExclusiveFcbLinks );
            Fcb->ExclusiveFcbLinks.Flink = NULL;

            //
            //  This is a good time to free any Scb snapshots for this Fcb.
            //

            NtfsFreeSnapshotsForFcb( IrpContext, Fcb );
        }

        Fcb->BaseExclusiveCount -= 1;
    }

    ASSERT((Fcb->ExclusiveFcbLinks.Flink == NULL && Fcb->BaseExclusiveCount == 0) ||
           (Fcb->ExclusiveFcbLinks.Flink != NULL && Fcb->BaseExclusiveCount != 0));

    NtfsReleaseResource( IrpContext, Fcb );
}


VOID
NtfsAcquireExclusiveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Scb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Scb - Scb to acquire

Return Value:

    None.

--*/

{
    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Scb->Fcb, Scb, 0 );

    ASSERT( Scb->Fcb->ExclusiveFcbLinks.Flink != NULL
            || (Scb->Vcb->BitmapScb != NULL
                && Scb->Vcb->BitmapScb == Scb) );

    if (FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

        NtfsSnapshotScb( IrpContext, Scb );
    }
}


VOID
NtfsAcquireSharedScbForTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to acquire an Scb shared in order to perform updates to
    the an Scb stream.  This is used if the transaction writes to a range of the
    stream without changing the size or position of the data.  The caller must
    already provide synchronization to the data itself.

    There is no corresponding Scb release.  It will be released when the transaction commits.
    We will acquire the Scb exclusive if it is not yet in the open attribute table.

Arguments:

    Scb - Scb to acquire

Return Value:

    None.

--*/

{
    PSCB *Position;
    PSCB *ScbArray;
    ULONG Count;

    PAGED_CODE();

    //
    //  Make sure we have a free spot in the Scb array in the IrpContext.
    //

    if (IrpContext->SharedScb == NULL) {

        Position = (PSCB *) &IrpContext->SharedScb;
        IrpContext->SharedScbSize = 1;

    //
    //  Too bad the first one is not available.  If the current size is one then allocate a
    //  new block and copy the existing value to it.
    //

    } else if (IrpContext->SharedScbSize == 1) {

        ScbArray = NtfsAllocatePool( PagedPool, sizeof( PSCB ) * 4 );
        RtlZeroMemory( ScbArray, sizeof( PSCB ) * 4 );
        *ScbArray = IrpContext->SharedScb;
        IrpContext->SharedScb = ScbArray;
        IrpContext->SharedScbSize = 4;
        Position = ScbArray + 1;

    //
    //  Otherwise look through the existing array and look for a free spot.  Allocate a larger
    //  array if we need to grow it.
    //

    } else {

        Position = IrpContext->SharedScb;
        Count = IrpContext->SharedScbSize;

        do {

            if (*Position == NULL) {

                break;
            }

            Count -= 1;
            Position += 1;

        } while (Count != 0);

        //
        //  If we didn't find one then allocate a new structure.
        //

        if (Count == 0) {

            ScbArray = NtfsAllocatePool( PagedPool, sizeof( PSCB ) * IrpContext->SharedScbSize * 2 );
            RtlZeroMemory( ScbArray, sizeof( PSCB ) * IrpContext->SharedScbSize * 2 );
            RtlCopyMemory( ScbArray,
                           IrpContext->SharedScb,
                           sizeof( PSCB ) * IrpContext->SharedScbSize );

            NtfsFreePool( IrpContext->SharedScb );
            IrpContext->SharedScb = ScbArray;
            Position = ScbArray + IrpContext->SharedScbSize;
            IrpContext->SharedScbSize *= 2;
        }
    }

    NtfsAcquireResourceShared( IrpContext, Scb, TRUE );

    if (Scb->NonpagedScb->OpenAttributeTableIndex == 0) {

        NtfsReleaseResource( IrpContext, Scb );
        NtfsAcquireResourceExclusive( IrpContext, Scb, TRUE );
    }

    *Position = Scb;

    return;
}


VOID
NtfsReleaseSharedResources (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    The routine releases all of the resources acquired shared for
    transaction.  The SharedScb structure is freed if necessary and
    the Irp Context field is cleared.

Arguments:


Return Value:

    None.

--*/
{

    PAGED_CODE();

    //
    //  If only one then free the Scb main resource.
    //

    if (IrpContext->SharedScbSize == 1) {

        if (SafeNodeType(IrpContext->SharedScb) == NTFS_NTC_QUOTA_CONTROL) {
            NtfsReleaseQuotaControl( IrpContext,
                              (PQUOTA_CONTROL_BLOCK) IrpContext->SharedScb );
        } else {

            NtfsReleaseResource( IrpContext, ((PSCB) IrpContext->SharedScb) );
        }

    //
    //  Otherwise traverse the array and look for Scb's to release.
    //

    } else {

        PSCB *NextScb;
        ULONG Count;

        NextScb = IrpContext->SharedScb;
        Count = IrpContext->SharedScbSize;

        do {

            if (*NextScb != NULL) {

                if (SafeNodeType(*NextScb) == NTFS_NTC_QUOTA_CONTROL) {

                    NtfsReleaseQuotaControl( IrpContext,
                                      (PQUOTA_CONTROL_BLOCK) *NextScb );
                } else {

                    NtfsReleaseResource( IrpContext, (*NextScb) );
                }
                *NextScb = NULL;
            }

            Count -= 1;
            NextScb += 1;

        } while (Count != 0);

        NtfsFreePool( IrpContext->SharedScb );
    }

    IrpContext->SharedScb = NULL;
    IrpContext->SharedScbSize = 0;

}


VOID
NtfsReleaseAllResources (
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine release all resources tracked in the irpcontext including
    exclusive fcb, paging / locked headers in the cleanup structure / cached file records
    shared resources / quota blocks acquired for transactions

    Does not release the vcb since this is hand-tracked.
    Not paged since called by NtfsCleanupIrpContext which is not paged


Arguments:


Return Value:

    None

--*/

{
    PFCB Fcb;

    //
    //  Release the cached file record map
    //

    NtfsPurgeFileRecordCache( IrpContext );


#ifdef MAPCOUNT_DBG
    //
    //  Check all mapping are gone now that we cleaned out cache
    //

    ASSERT( IrpContext->MapCount == 0 );

#endif

    //
    //  Go through and free any Scb's in the queue of shared Scb's for transactions.
    //

    if (IrpContext->SharedScb != NULL) {

        NtfsReleaseSharedResources( IrpContext );
    }

    //
    //  Free any exclusive paging I/O resource, or IoAtEof condition,
    //  this field is overlayed, minimally in write.c.
    //

    Fcb = IrpContext->CleanupStructure;
    if (Fcb != NULL) {

        if (Fcb->NodeTypeCode == NTFS_NTC_FCB) {

            NtfsReleasePagingIo( IrpContext, Fcb );

        } else {

            FsRtlUnlockFsRtlHeader( (PNTFS_ADVANCED_FCB_HEADER) Fcb );
            IrpContext->CleanupStructure = NULL;
        }
    }

    //
    //  Finally, now that we have written the forget record, we can free
    //  any exclusive Scbs that we have been holding.
    //

    ASSERT( IrpContext->TransactionId == 0 );

    while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

        Fcb = (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                       FCB,
                                       ExclusiveFcbLinks );

        NtfsReleaseFcb( IrpContext, Fcb );
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                  IRP_CONTEXT_FLAG_RELEASE_MFT );
}


VOID
NtfsAcquireIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb,
    IN PEOF_WAIT_BLOCK EofWaitBlock
    )

/*++

Routine Description:

    This routine is called to serialize access to a Ccb for a directory.
    We must serialize access to the index context or we will corrupt
    the data structure.

Arguments:

    Scb - Scb for the directory to enumerate.

    Ccb - Pointer to the Ccb for the handle.

    EofWaitBlock - Uninitialized structure used only to serialize Eof updates.  Our
        caller will put this on the stack.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Acquire the mutex for serialization.
    //

    NtfsAcquireFsrtlHeader( Scb );

    //
    //  Typical case is that we are the only active handle.
    //

    if (Ccb->EnumQueue.Flink == NULL) {

        InitializeListHead( &Ccb->EnumQueue );
        NtfsReleaseFsrtlHeader( Scb );

    } else {

        //
        //  Initialize our event an put ourselves on the stack.
        //

        KeInitializeEvent( &EofWaitBlock->Event, NotificationEvent, FALSE );
        InsertTailList( &Ccb->EnumQueue, &EofWaitBlock->EofWaitLinks );

        //
        //  Free the mutex and wait.  When the wait is satisfied then we are
        //  the active handle.
        //

        NtfsReleaseFsrtlHeader( Scb );

        KeWaitForSingleObject( &EofWaitBlock->Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    }

    return;
}


VOID
NtfsReleaseIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine is called to release a Ccb for other people to access.

Arguments:

    Scb - Scb for the directory to enumerate.
    Ccb - Pointer to the Ccb for the handle.

Return Value:

    None

--*/

{
    PEOF_WAIT_BLOCK EofWaitBlock;
    PAGED_CODE();

    //
    //  Acquire the header and wake the next waiter or clear the list if it
    //  is now empty.
    //

    NtfsAcquireFsrtlHeader( Scb );

    ASSERT( Ccb->EnumQueue.Flink != NULL );
    if (IsListEmpty( &Ccb->EnumQueue )) {

        Ccb->EnumQueue.Flink = NULL;

    } else {

        EofWaitBlock = (PEOF_WAIT_BLOCK) RemoveHeadList( &Ccb->EnumQueue );
        KeSetEvent( &EofWaitBlock->Event, 0, FALSE );
    }

    NtfsReleaseFsrtlHeader( Scb );
    return;
}


BOOLEAN
NtfsAcquireScbForLazyWrite (
    IN PVOID OpaqueScb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing lazy writes to the file.  This callback is necessary to
    avoid deadlocks with the Lazy Writer.  (Note that normal writes
    acquire the Fcb, and then call the Cache Manager, who must acquire
    some of his internal structures.  If the Lazy Writer could not call
    this routine first, and were to issue a write after locking Caching
    data structures, then a deadlock could occur.)

Arguments:

    OpaqueScb - The Scb which was specified as a context parameter for this
                routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Scb has been acquired

--*/

{
    BOOLEAN AcquiredFile = FALSE;

    ULONG CompressedStream = (ULONG)((ULONG_PTR)OpaqueScb & 1);
    PSCB Scb = (PSCB)((ULONG_PTR)OpaqueScb & ~1);
    PFCB Fcb = Scb->Fcb;

    ASSERT_SCB(Scb);

    PAGED_CODE();

    //
    //  Acquire the Scb only for those files that the write will
    //  acquire it for, i.e., not the first set of system files.
    //  Otherwise we can deadlock, for example with someone needing
    //  a new Mft record.
    //

    if (NtfsSegmentNumber( &Fcb->FileReference ) <= MASTER_FILE_TABLE2_NUMBER) {

        //
        //  We need to synchronize the lazy writer with the clean volume
        //  checkpoint.  We do this by acquiring and immediately releasing this
        //  Scb.  This is to prevent the lazy writer from flushing the log file
        //  when the space may be at a premium.
        //

        if (NtfsAcquireResourceShared( NULL, Scb, Wait )) {

            if (ExAcquireResourceSharedLite( &Scb->Vcb->MftFlushResource, Wait )) {
                //
                //  The mft bitmap will reacquire the mft resource in LookupAllocation
                //  if its not loaded during a write - this would deadlock with allocating
                //  a mft record.  bcb exclusive - mft main vs mft main - bcb shared
                //

                ASSERT( (Scb != Scb->Vcb->MftBitmapScb) ||

                        ((Scb->Mcb.NtfsMcbArraySizeInUse > 0) &&
                         ((Scb->Mcb.NtfsMcbArray[ Scb->Mcb.NtfsMcbArraySizeInUse - 1].EndingVcn + 1) ==
                          LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ))) );

                AcquiredFile = TRUE;
            }
            NtfsReleaseResource( NULL, Scb );
        }
    //
    //  Now acquire either the main or paging io resource depending on the
    //  state of the file.
    //

    } else if (Scb->Header.PagingIoResource != NULL) {
        AcquiredFile = ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, Wait );
    } else {

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_CONVERT_UNDERWAY )) {

            AcquiredFile = NtfsAcquireResourceExclusive( NULL, Scb, Wait );

        } else {

            AcquiredFile = NtfsAcquireResourceShared( NULL, Scb, Wait );
        }
    }

    if (AcquiredFile) {

        //
        // We assume the Lazy Writer only acquires this Scb once.  When he
        // has acquired it, then he has eliminated anyone who would extend
        // valid data, since they must take out the resource exclusive.
        // Therefore, it should be guaranteed that this flag is currently
        // clear (the ASSERT), and then we will set this flag, to insure
        // that the Lazy Writer will never try to advance Valid Data, and
        // also not deadlock by trying to get the Fcb exclusive.
        //

        ASSERT( Scb->LazyWriteThread[CompressedStream] == NULL );

        Scb->LazyWriteThread[CompressedStream] = PsGetCurrentThread();

        //
        //  Make Cc top level, so that we will not post or retry on errors.
        //  (If it is not NULL, it must be one of our internal calls to this
        //  routine, such as from Restart or Hot Fix.)
        //

        if (IoGetTopLevelIrp() == NULL) {
            IoSetTopLevelIrp( (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP );
        }
    }

    return AcquiredFile;
}


VOID
NtfsReleaseScbFromLazyWrite (
    IN PVOID OpaqueScb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    performing lazy writes to the file.

Arguments:

    Scb - The Scb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    ULONG CompressedStream = (ULONG)((ULONG_PTR)OpaqueScb & 1);
    PSCB Scb = (PSCB)((ULONG_PTR)OpaqueScb & ~1);
    PFCB Fcb = Scb->Fcb;
    ULONG CleanCheckpoint = 0;

    ASSERT_SCB(Scb);

    PAGED_CODE();

    //
    //  Clear the toplevel at this point, if we set it above.
    //

    if ((((ULONG_PTR) IoGetTopLevelIrp()) & ~0x80000000) == FSRTL_CACHE_TOP_LEVEL_IRP) {

        //
        //  We use the upper bit of this field to indicate that we need to
        //  do a clean checkpoint.
        //

        CleanCheckpoint = (ULONG)FlagOn( (ULONG_PTR) IoGetTopLevelIrp(), 0x80000000 );
        IoSetTopLevelIrp( NULL );
    }

    Scb->LazyWriteThread[CompressedStream] = NULL;

    if (NtfsSegmentNumber( &Fcb->FileReference ) <= MASTER_FILE_TABLE2_NUMBER) {

        ExReleaseResourceLite( &Scb->Vcb->MftFlushResource );

    } else if (Scb->Header.PagingIoResource != NULL) {
        ExReleaseResourceLite( Scb->Header.PagingIoResource );
    } else {
        NtfsReleaseResource( NULL, Scb );
    }

    //
    //  Do a clean checkpoint if necessary.
    //

    if (CleanCheckpoint) {

        NtfsCleanCheckpoint( Scb->Vcb );
    }

    return;
}


NTSTATUS
NtfsAcquireFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease,
    IN PDEVICE_OBJECT DeviceObject
    )

{
    BOOLEAN AcquiredFile = FALSE;

    PSCB Scb = (PSCB) (FileObject->FsContext);
    PFCB Fcb = Scb->Fcb;

    ASSERT_SCB( Scb );

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //  All files should not be mod-no-write and have paging resource
    //

    ASSERT( NtfsSegmentNumber( &Fcb->FileReference ) >= MASTER_FILE_TABLE2_NUMBER );
    ASSERT( Scb->Header.PagingIoResource != NULL );

    AcquiredFile = NtfsAcquirePagingResourceSharedWaitForExclusive( NULL, Scb, FALSE );

    //
    //  If we got the resource, check if he is possibly trying to extend
    //  ValidDataLength.  If so that will cause us to go into useless mode
    //  possibly doing actual I/O writing zeros out to the file past actual
    //  valid data in the cache.  This is so inefficient that it is better
    //  to tell MM not to do this write.
    //

    if (AcquiredFile) {
        *ResourceToRelease = Scb->Fcb->PagingIoResource;
        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
            NtfsAcquireFsrtlHeader( Scb );
            if ((EndingOffset->QuadPart > Scb->ValidDataToDisk) &&
                (EndingOffset->QuadPart < Scb->Header.FileSize.QuadPart) &&
                !FlagOn(Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE)) {

                ExReleaseResourceLite( *ResourceToRelease );
                AcquiredFile = FALSE;
                *ResourceToRelease = NULL;
            }
            NtfsReleaseFsrtlHeader( Scb );
        }
    } else {
        *ResourceToRelease = NULL;
    }

    return (AcquiredFile ? STATUS_SUCCESS : STATUS_CANT_WAIT);
}

NTSTATUS
NtfsAcquireFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

    PAGED_CODE();

    if (Header->PagingIoResource != NULL) {
        ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
NtfsReleaseFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PSCB Scb = (PSCB) FileObject->FsContext;
    BOOLEAN CleanCheckpoint = FALSE;

    PAGED_CODE();

    if (Scb->Header.PagingIoResource != NULL) {

        //
        //  If we are getting repeated log file fulls then we want to process that before retrying
        //  this request.  This will prevent a section flush from failing and returning
        //  STATUS_FILE_LOCK_CONFLICT to the user.
        //

        if (Scb->Vcb->CleanCheckpointMark + 3 < Scb->Vcb->LogFileFullCount) {

            CleanCheckpoint = TRUE;
        }

        ExReleaseResourceLite( Scb->Header.PagingIoResource );

        //
        //  We may be be in a recursive acquisition callback in that case even
        //  after releasing the resource we may still own it and be unable to
        //  checkpoint
        //

        if (CleanCheckpoint &&
            (IoGetTopLevelIrp() == NULL) &&
            !NtfsIsExclusiveScbPagingIo( Scb )) {

            NtfsCleanCheckpoint( Scb->Vcb );
        }
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}

VOID
NtfsAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    PSCB Scb = (PSCB)FileObject->FsContext;

    PAGED_CODE();

    if (Scb->Header.PagingIoResource != NULL) {

        //
        //  Use an unsafe test to see if a dummy checkpoint has been posted.
        //  We can use an unsafe test, since the top level caller must retry
        //  if a STATUS_FILE_LOCK_CONFLICT is returned.
        //

        if (FlagOn( Scb->Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED )) {

            NtfsCleanCheckpoint( Scb->Vcb );
        }

        ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );
    }
}

VOID
NtfsReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    PSCB Scb = (PSCB)FileObject->FsContext;

    PAGED_CODE();

    if (Scb->Header.PagingIoResource != NULL) {

        ExReleaseResourceLite( Scb->Header.PagingIoResource );
    }
}


BOOLEAN
NtfsAcquireScbForReadAhead (
    IN PVOID OpaqueScb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing read ahead to the file.

Arguments:

    Scb - The Scb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Scb has been acquired

--*/

{
    PREAD_AHEAD_THREAD ReadAheadThread;
    PVOID CurrentThread;
    KIRQL OldIrql;
    PSCB Scb = (PSCB)OpaqueScb;
    PFCB Fcb = Scb->Fcb;
    BOOLEAN AcquiredFile = FALSE;

    ASSERT_SCB(Scb);

    //
    //  Acquire the Scb only for those files that the read wil
    //  acquire it for, i.e., not the first set of system files.
    //  Otherwise we can deadlock, for example with someone needing
    //  a new Mft record.
    //

    if ((Scb->Header.PagingIoResource == NULL) ||
        ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, Wait )) {

        AcquiredFile = TRUE;

        //
        //  Add our thread to the read ahead list.
        //

        OldIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

        CurrentThread = (PVOID)PsGetCurrentThread();
        ReadAheadThread = (PREAD_AHEAD_THREAD)NtfsData.ReadAheadThreads.Flink;

        while ((ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) &&
               (ReadAheadThread->Thread != NULL)) {

            //
            //  We better not already see ourselves.
            //

            ASSERT( ReadAheadThread->Thread != CurrentThread );

            ReadAheadThread = (PREAD_AHEAD_THREAD)ReadAheadThread->Links.Flink;
        }

        //
        //  If we hit the end of the list, then allocate a new one.  Note we
        //  should have at most one entry per critical worker thread in the
        //  system.
        //

        if (ReadAheadThread == (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) {

            ReadAheadThread = NtfsAllocatePoolWithTagNoRaise( NonPagedPool, sizeof(READ_AHEAD_THREAD), 'RftN' );

            //
            //  If we failed to allocate an entry, clean up and raise.
            //

            if (ReadAheadThread == NULL) {

                KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );

                if (NtfsSegmentNumber( &Fcb->FileReference ) > VOLUME_DASD_NUMBER) {

                    if (Scb->Header.PagingIoResource != NULL) {
                        ExReleaseResourceLite( Scb->Header.PagingIoResource );
                    }
                }

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
            InsertTailList( &NtfsData.ReadAheadThreads, &ReadAheadThread->Links );
        }

        ReadAheadThread->Thread = CurrentThread;

        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );
    }

    return AcquiredFile;
}


VOID
NtfsReleaseScbFromReadAhead (
    IN PVOID OpaqueScb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    read ahead.

Arguments:

    Scb - The Scb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    PREAD_AHEAD_THREAD ReadAheadThread;
    PVOID CurrentThread;
    KIRQL OldIrql;
    PSCB Scb = (PSCB)OpaqueScb;
    PFCB Fcb = Scb->Fcb;

    ASSERT_SCB(Scb);

    //
    //  Free our read ahead entry.
    //

    OldIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

    CurrentThread = (PVOID)PsGetCurrentThread();
    ReadAheadThread = (PREAD_AHEAD_THREAD)NtfsData.ReadAheadThreads.Flink;

    while ((ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) &&
           (ReadAheadThread->Thread != CurrentThread)) {

        ReadAheadThread = (PREAD_AHEAD_THREAD)ReadAheadThread->Links.Flink;
    }

    ASSERT(ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads);

    ReadAheadThread->Thread = NULL;

    //
    //  Move him to the end of the list so all the allocated entries are at
    //  the front, and we simplify our scans.
    //

    RemoveEntryList( &ReadAheadThread->Links );
    InsertTailList( &NtfsData.ReadAheadThreads, &ReadAheadThread->Links );

    KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );

    if (Scb->Header.PagingIoResource != NULL) {
        ExReleaseResourceLite( Scb->Header.PagingIoResource );
    }

    return;
}


BOOLEAN
NtfsAcquireVolumeFileForLazyWrite (
    IN PVOID Vcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    the volume file.  It is subsequently called by the Lazy Writer prior to its
    performing lazy writes to the volume file.  This callback may one day be
    necessary to avoid deadlocks with the Lazy Writer, however, now
    NtfsCommonWrite does not need to acquire any resource for the volume file,
    so this routine is simply a noop.

Arguments:

    Vcb - The Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER( Vcb );
    UNREFERENCED_PARAMETER( Wait );

    PAGED_CODE();

    return TRUE;
}


VOID
NtfsReleaseVolumeFileFromLazyWrite (
    IN PVOID Vcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    performing lazy writes to the file.

Arguments:

    Vcb - The Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( Vcb );

    PAGED_CODE();

    return;
}


NTFS_RESOURCE_NAME
NtfsIdentifyFcb (
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    Identifies the resource type of a given FCB. I.e is it the mft. Used for
    lock order identification.

Arguments:

    Vcb - The vcb for the volume

    Fcb - The fcb to identify

Return Value:

    TRUE

--*/

{

    if ((NtfsSegmentNumber( &Fcb->FileReference ) == MASTER_FILE_TABLE_NUMBER)) {
        return NtfsResourceMft;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == MASTER_FILE_TABLE2_NUMBER)) {
        return NtfsResourceMft2;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == VOLUME_DASD_NUMBER)) {
        return NtfsResourceVolume;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == LOG_FILE_NUMBER)) {
        return NtfsResourceLogFile;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == BAD_CLUSTER_FILE_NUMBER)) {
        return NtfsResourceBadClust;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == SECURITY_FILE_NUMBER)) {
        return NtfsResourceSecure;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER)) {
        return NtfsResourceRootDir;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == BIT_MAP_FILE_NUMBER)) {
        return NtfsResourceBitmap;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == BOOT_FILE_NUMBER)) {
        return NtfsResourceBoot;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == EXTEND_NUMBER)) {
        return NtfsResourceExtendDir;
    } else if ((Vcb->UsnJournal && (Fcb == Vcb->UsnJournal->Fcb)) ||
               FlagOn( Fcb->FcbState, FCB_STATE_USN_JOURNAL)) {
        return NtfsResourceUsnJournal;
    } else if (Vcb->QuotaTableScb && (Fcb == Vcb->QuotaTableScb->Fcb)) {
        return NtfsResourceQuotaTable;
    } else if (Vcb->ObjectIdTableScb && (Fcb == Vcb->ObjectIdTableScb->Fcb)) {
        return NtfsResourceObjectIdTable;
    } else if (Vcb->ReparsePointTableScb && (Fcb == Vcb->ReparsePointTableScb->Fcb)) {
        return NtfsResourceReparseTable;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == UPCASE_TABLE_NUMBER)) {
        return NtfsResourceUpCase;
    } else if (Vcb->AttributeDefTableScb && (Fcb == Vcb->AttributeDefTableScb->Fcb)) {
        return NtfsResourceAttrDefTable;
    } else {
        return NtfsResourceFile;
    }
}

#ifdef NTFSDBG

BOOLEAN
NtfsChangeResourceOrderState(
    IN PIRP_CONTEXT IrpContext,
    IN NTFS_RESOURCE_NAME NewResource,
    IN BOOLEAN Release,
    IN ULONG UnsafeTransition
    )

/*++

Routine Description:

    Update the state table because of the new acquired resource

Arguments:

    IrpContext -- contains the state table

    NewResource -- The new resource acquired

Return Value:

    TRUE if this is a valid transition

--*/

{
    PTOP_LEVEL_CONTEXT TopLevelContext;
    PIRP_CONTEXT TopIrpContext = IrpContext;
    ULONG_PTR StackBottom;
    ULONG_PTR StackTop;
    LONG Index;
    LONG NumTransitions =  sizeof( OwnershipTransitionTable ) / sizeof( NTFS_OWNERSHIP_TRANSITION );

    //
    //  Work around the forced top level context of reads to find the real top level
    //

    IoGetStackLimits( &StackTop, &StackBottom );

    TopLevelContext = NtfsGetTopLevelContext();
    if ((TopLevelContext != NULL)  && (TopLevelContext->SavedTopLevelIrp != NULL)) {
        TopLevelContext = (PTOP_LEVEL_CONTEXT)TopLevelContext->SavedTopLevelIrp;

        if (((ULONG_PTR) TopLevelContext <= StackBottom - sizeof( TOP_LEVEL_CONTEXT )) &&
            ((ULONG_PTR) TopLevelContext >= StackTop) &&
            !FlagOn( (ULONG_PTR) TopLevelContext, 0x3 ) &&
            (TopLevelContext->Ntfs == 0x5346544e)) {

            TopIrpContext = TopLevelContext->ThreadIrpContext;
        }
    }

    TopIrpContext = TopIrpContext->TopLevelIrpContext;

    //
    //  Skip verification on mounts
    //

    if ((TopIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
         (TopIrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME)) {

        return TRUE;
    }

    //
    //  Keep track of how many normal files we own
    //

    if (NtfsResourceFile == NewResource) {

        if (Release) {

            TopIrpContext->FilesOwnedCount -= 1;

            //
            //  Only change state if back to 0 for files
            //

            if (TopIrpContext->FilesOwnedCount) {
                return TRUE;
            }

        } else {

            TopIrpContext->FilesOwnedCount += 1;

            //
            //  Only change state if fwd to 0 for files
            //

            if (TopIrpContext->FilesOwnedCount > 1) {
                return TRUE;
            }
        }
    }

    for (Index=0; Index < NumTransitions; Index += 1) {

        if ((!Release &&
             (OwnershipTransitionTable[Index].Begin == TopIrpContext->OwnershipState) &&
             ((OwnershipTransitionTable[Index].Acquired == NewResource) ||
              (OwnershipTransitionTable[Index].Acquired == NtfsResourceAny))) ||

            ((OwnershipTransitionTable[Index].End == TopIrpContext->OwnershipState) &&
             (OwnershipTransitionTable[Index].Acquired == NewResource))) {

            if (Release) {
                TopIrpContext->OwnershipState = OwnershipTransitionTable[Index].Begin;

            } else {
                TopIrpContext->OwnershipState = OwnershipTransitionTable[Index].End;
            }

#ifdef NTFSDBG
            if (TopIrpContext->OwnershipState == NtfsBreakOnState) {
                if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                    KdPrint(( "NTFS: Breaking for matched state\n" ));
                    DbgBreakPoint();
                }
            }

            if (NtfsPrintOnLockProb) {
                if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                    KdPrint(( "NTFS: change context: 0x%x to 0x%x for 0x%x during 0x%x\n", TopIrpContext, TopIrpContext->OwnershipState, NewResource, Release ));
                }
            }
#endif
            return TRUE;
        }
    }

    //
    //  If an unsafe transition (not blocking) check the extra table
    //

    if (UnsafeTransition && !Release) {
        NumTransitions = sizeof( OwnershipTransitionTableUnsafe ) / sizeof( NTFS_OWNERSHIP_TRANSITION );

        for (Index=0; Index < NumTransitions; Index += 1) {

            if (((OwnershipTransitionTableUnsafe[Index].Begin == TopIrpContext->OwnershipState) &&
                 ((OwnershipTransitionTableUnsafe[Index].Acquired == NewResource) ||
                  (OwnershipTransitionTableUnsafe[Index].Acquired == NtfsResourceAny))))  {

                TopIrpContext->OwnershipState = OwnershipTransitionTableUnsafe[Index].End;

#ifdef NTFSDBG
                if (TopIrpContext->OwnershipState == NtfsBreakOnState) {
                    if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                        KdPrint(( "NTFS: Breaking for matched state\n" ));
                        DbgBreakPoint();
                    }
                }

                if (NtfsPrintOnLockProb) {
                    if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                        KdPrint(( "NTFS: change context: 0x%x to 0x%x for 0x%x during 0x%x\n", TopIrpContext, TopIrpContext->OwnershipState, NewResource, Release ));
                    }
                }
#endif
                return TRUE;
            }
        }
    }

    //
    //  Check the one way transtions for release and acquire
    //

    if (Release) {

        NumTransitions =  sizeof( OwnershipTransitionTableRelease ) / sizeof( NTFS_OWNERSHIP_TRANSITION );

        for (Index=0; Index < NumTransitions; Index += 1) {

            if ((OwnershipTransitionTableRelease[Index].Begin == TopIrpContext->OwnershipState) &&
                ((OwnershipTransitionTableRelease[Index].Acquired == NewResource) ||
                 (OwnershipTransitionTableRelease[Index].Acquired == NtfsResourceAny))) {

                TopIrpContext->OwnershipState = OwnershipTransitionTableRelease[Index].End;

#ifdef NTFSDBG
                if (TopIrpContext->OwnershipState == NtfsBreakOnState) {
                    if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                        KdPrint(( "NTFS: Breaking for matched state\n" ));
                        DbgBreakPoint();
                    }
                }

                if (NtfsPrintOnLockProb) {
                    if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                        KdPrint(( "NTFS: change context: 0x%x to 0x%x for 0x%x during 0x%x\n", TopIrpContext, TopIrpContext->OwnershipState, NewResource, Release ));
                    }
                }
#endif

                return TRUE;
            }
        }
    } else {

        NumTransitions =  sizeof( OwnershipTransitionTableAcquire ) / sizeof( NTFS_OWNERSHIP_TRANSITION );

        for (Index=0; Index < NumTransitions; Index += 1) {

            if ((OwnershipTransitionTableAcquire[Index].Begin == TopIrpContext->OwnershipState) &&
                ((OwnershipTransitionTableAcquire[Index].Acquired == NewResource) ||
                 (OwnershipTransitionTableAcquire[Index].Acquired == NtfsResourceAny))) {

                TopIrpContext->OwnershipState = OwnershipTransitionTableAcquire[Index].End;

#ifdef NTFSDBG
                if (TopIrpContext->OwnershipState == NtfsBreakOnState) {
                    if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                        KdPrint(( "NTFS: Breaking for matched state\n" ));
                        DbgBreakPoint();
                    }
                }

                if (NtfsPrintOnLockProb) {
                    if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
                        KdPrint(( "NTFS: change context: 0x%x to 0x%x for 0x%x during 0x%x\n", TopIrpContext, TopIrpContext->OwnershipState, NewResource, Release ));
                    }
                }
#endif

                return TRUE;
            }
        }
    }

#ifdef NTFSDBG
    if (NtfsAssertOnLockProb) {
        KdPrint(( "NTFS: unknown transition from state: 0x%x resource: 0x%x release: %d unsafe: %d\n", TopIrpContext->OwnershipState, NewResource, Release, UnsafeTransition ));
        ASSERT( FALSE );
    }
#endif

    return FALSE;
}


BOOLEAN
NtfsAcquireResourceExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine acquires the main resource of the specified structure useing the specified wait
    flag.  It will update the resource state in the IrpContext if present.

Arguments:

    FcbOrScb - Data structure on which we are synchronizing.

    Wait - Indicates if we can wait for the resource.

Return Value:

    BOOLEAN - TRUE if the resource was acquired, FALSE otherwise.

--*/

{
    NTFS_RESOURCE_NAME ResourceName;
    PFCB Fcb;
    BOOLEAN Result;

    //
    //  Find the Fcb for either input structure.
    //

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Fcb = (PFCB)FcbOrScb;

    } else {
        Fcb = ((PSCB)FcbOrScb)->Fcb;

        ASSERT( Fcb->Resource == ((PSCB)FcbOrScb)->Header.Resource );
    }

    //
    //  For blocking calls check 1st
    //

    if (Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (0 == ExIsResourceAcquiredSharedLite( Fcb->Resource ))) {

        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, FALSE );
    }

    Result = ExAcquireResourceExclusiveLite( Fcb->Resource, Wait );

    //
    //  For nonblocking calls afterwards when own the resource
    //

    if (Result &&
        !Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (1 == ExIsResourceAcquiredSharedLite( Fcb->Resource))) {

        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, TRUE );
    }

    return Result;
}


BOOLEAN
NtfsAcquireResourceShared (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   )

/*++

Routine Description:

    This routine is called to acquire the main resource of the specified structure shared using the
    specified wait flag.  It will also update the resource state in the IrpContext if present.

Arguments:

    FcbOrScb - Data structure on which we are synchronizing.

    Wait - Indicates if we can wait for the resource.

Return Value:

    BOOLEAN - TRUE if the resource was acquired, FALSE otherwise.

--*/

{
    NTFS_RESOURCE_NAME ResourceName;
    BOOLEAN Result;
    PFCB Fcb;

    //
    //  Find the Fcb for either input structure.
    //

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Fcb = (PFCB)FcbOrScb;

    } else {
        Fcb = ((PSCB)FcbOrScb)->Fcb;

        ASSERT( Fcb->Resource == ((PSCB)FcbOrScb)->Header.Resource );
    }

    //
    //  For blocking calls check 1st
    //

    if (Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (0 == ExIsResourceAcquiredSharedLite( Fcb->Resource))) {

        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, FALSE );
    }

    Result = ExAcquireResourceSharedLite( Fcb->Resource, Wait );

    //
    //  For nonblocking calls afterwards when own the resource
    //

    if (Result &&
        !Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (1 == ExIsResourceAcquiredSharedLite( Fcb->Resource ))) {

        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, TRUE );
    }

    return Result;
}


VOID
NtfsReleaseResource (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb
    )

/*++

Routine Description:

    This routine is called to release the main resource of the specified structure and update the
    resource state in the IrpContext if present.

Arguments:

    FcbOrScb - Data structure on which we are synchronizing.

Return Value:

    None

--*/

{
    NTFS_RESOURCE_NAME ResourceName;
    PFCB Fcb;

    //
    //  Find the Fcb for either input structure.
    //

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Fcb = (PFCB)FcbOrScb;

    } else {
        Fcb = ((PSCB)FcbOrScb)->Fcb;

        ASSERT( Fcb->Resource == ((PSCB)FcbOrScb)->Header.Resource );
    }

    if (ARGUMENT_PRESENT( IrpContext )) {
        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );

            //
            //  Only change ownership state if we are really releasing the resource
            //

            if (1 == ExIsResourceAcquiredSharedLite( Fcb->Resource )) {
                NtfsChangeResourceOrderState( IrpContext, ResourceName, TRUE, FALSE );
            }

        } else {

            IrpContext->OwnershipState = None;
        }
    }

    ExReleaseResourceLite( Fcb->Resource );
}

#endif //  NTFSDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\read.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Ntfs called by the
    dispatch driver.

Author:

    Brian Andrew    BrianAn         15-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"
#include "lockorder.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

#ifdef NTFS_RWC_DEBUG
PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );
BOOLEAN NtfsBreakOnConflict = TRUE;
#endif

//
//  Define stack overflow read threshhold.
//

#ifdef _X86_
#if DBG
#define OVERFLOW_READ_THRESHHOLD         (0xD00)
#else
#define OVERFLOW_READ_THRESHHOLD         (0xA00)
#endif
#else
#define OVERFLOW_READ_THRESHHOLD         (0x1000)
#endif // _X86_

//
//  Local procedure prototypes
//

//
//  The following procedure is used to handling read stack overflow operations.
//

VOID
NtfsStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

VOID 
NtfsNonCachedResidentRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    );

//
//  VOID
//  SafeZeroMemory (
//      IN PUCHAR At,
//      IN ULONG ByteCount
//      );
//

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(AT,BYTE_COUNT) {                            \
    try {                                                          \
        RtlZeroMemory((AT), (BYTE_COUNT));                         \
    } except(EXCEPTION_EXECUTE_HANDLER) {                          \
         NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );\
    }                                                              \
}

#define CollectReadStats(VCB,OPEN_TYPE,SCB,FCB,BYTE_COUNT) {                             \
    PFILE_SYSTEM_STATISTICS FsStats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()]; \
    if (!FlagOn( (FCB)->FcbState, FCB_STATE_SYSTEM_FILE)) {                              \
        if (NtfsIsTypeCodeUserData( (SCB)->AttributeTypeCode )) {                        \
            FsStats->Common.UserFileReads += 1;                                          \
            FsStats->Common.UserFileReadBytes += (ULONG)(BYTE_COUNT);                    \
        } else {                                                                         \
            FsStats->Ntfs.UserIndexReads += 1;                                           \
            FsStats->Ntfs.UserIndexReadBytes += (ULONG)(BYTE_COUNT);                     \
        }                                                                                \
    } else {                                                                             \
        if ((SCB) != (VCB)->LogFileScb) {                                                \
            FsStats->Common.MetaDataReads += 1;                                          \
            FsStats->Common.MetaDataReadBytes += (ULONG)(BYTE_COUNT);                    \
        } else {                                                                         \
            FsStats->Ntfs.LogFileReads += 1;                                             \
            FsStats->Ntfs.LogFileReadBytes += (ULONG)(BYTE_COUNT);                       \
        }                                                                                \
                                                                                         \
        if ((SCB) == (VCB)->MftScb) {                                                    \
            FsStats->Ntfs.MftReads += 1;                                                 \
            FsStats->Ntfs.MftReadBytes += (ULONG)(BYTE_COUNT);                           \
        } else if ((SCB) == (VCB)->RootIndexScb) {                                       \
            FsStats->Ntfs.RootIndexReads += 1;                                           \
            FsStats->Ntfs.RootIndexReadBytes += (ULONG)(BYTE_COUNT);                     \
        } else if ((SCB) == (VCB)->BitmapScb) {                                          \
            FsStats->Ntfs.BitmapReads += 1;                                              \
            FsStats->Ntfs.BitmapReadBytes += (ULONG)(BYTE_COUNT);                        \
        } else if ((SCB) == (VCB)->MftBitmapScb) {                                       \
            FsStats->Ntfs.MftBitmapReads += 1;                                           \
            FsStats->Ntfs.MftBitmapReadBytes += (ULONG)(BYTE_COUNT);                     \
        }                                                                                \
    }                                                                                    \
}


NTSTATUS
NtfsFsdRead (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    For synchronous requests, the CommonRead is called with Wait == TRUE,
    which means the request will always be completed in the current thread,
    and never passed to the Fsp.  If it is not a synchronous request,
    CommonRead is called with Wait == FALSE, which means the request
    will be passed to the Fsp only if there is a need to block.

Arguments:

    IrpContext - If present this an IrpContext put on the caller's stack
        to avoid having to allocate it from pool.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;
    ULONG RetryCount = 0;

    ASSERT_IRP( Irp );

    DebugTrace( +1, Dbg, ("NtfsFsdRead\n") );

    //
    //  Call the common Read routine
    //

    FsRtlEnterFileSystem();

    //
    //  Always make the reads appear to be top level.  As long as we don't have
    //  log file full we won't post these requests.  This will prevent paging
    //  reads from trying to attach to uninitialized top level requests.
    //    

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );

    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {
                                                                             
                //
                //  Allocate the Irp and update the top level storage. For synchronous
                //  paging io allocate the irp on the stack
                //

                if (CanFsdWait( Irp ) && FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                    IrpContext = (PIRP_CONTEXT) NtfsAllocateFromStack( sizeof( IRP_CONTEXT ));
                }

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                if (ThreadTopLevelContext->ScbBeingHotFixed != NULL) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY );
                }

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            //
            //  If this is an Mdl complete request, don't go through
            //  common read.
            //

            ASSERT(!FlagOn( IrpContext->MinorFunction, IRP_MN_DPC ));

            if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                DebugTrace( 0, Dbg, ("Calling NtfsCompleteMdl\n") );

                Status = NtfsCompleteMdl( IrpContext, Irp );

            //
            //  Check if we have enough stack space to process this request.  If there
            //  isn't enough then we will create a new thread to process this single
            //  request
            //

            } else if (IoGetRemainingStackSize() < OVERFLOW_READ_THRESHHOLD) {

                KEVENT Event;
                PFILE_OBJECT FileObject;
                TYPE_OF_OPEN TypeOfOpen;
                PVCB Vcb;
                PFCB Fcb;
                PSCB Scb;
                PCCB Ccb;
                PERESOURCE Resource;

                DebugTrace( 0, Dbg, ("Getting too close to stack limit pass request to Fsp\n") );

                //
                //  Decode the file object to get the Scb
                //

                FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

                TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );
                if ((TypeOfOpen != UserFileOpen) &&
                    (TypeOfOpen != StreamFileOpen) &&
                    (TypeOfOpen != UserVolumeOpen)) {

                    NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }

                //
                //  We cannot post any compressed reads, because that would interfere
                //  with our reserved buffer strategy.  We may currently own
                //  NtfsReservedBufferResource, and it is important for our read to
                //  be able to get a buffer.
                //

                ASSERT( (Scb->CompressionUnit == 0) ||
                        !ExIsResourceAcquiredExclusiveLite(&NtfsReservedBufferResource) );

                //
                //  To avoid deadlocks we only should post recursive paging file and mft requests
                //  o.w we might need to do lockups for example and reacquire the main in a diff. thread
                //  from where it was preacquired
                //

//                ASSERT( (Scb == Vcb->MftScb) || (FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) );

                //
                //  Allocate an event and get shared on the scb.  We won't grab the
                //  Scb for the paging file path or for non-cached io for our
                //  system files.
                //

                KeInitializeEvent( &Event, NotificationEvent, FALSE );

                if ((FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )
                     && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) ||
                    (NtfsLeqMftRef( &Fcb->FileReference, &VolumeFileReference ))) {

                    //
                    //  There is nothing to release in this case.
                    //

                    Resource = NULL;

                } else {

                    NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                    Resource = Scb->Header.Resource;

                }

                try {

                    //
                    //  Make the Irp just like a regular post request and
                    //  then send the Irp to the special overflow thread.
                    //  After the post we will wait for the stack overflow
                    //  read routine to set the event that indicates we can
                    //  now release the scb resource and return.
                    //

                    NtfsPrePostIrp( IrpContext, Irp );

                    if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                        FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        FsRtlPostPagingFileStackOverflow( IrpContext, &Event, NtfsStackOverflowRead );

                    } else {

                        FsRtlPostStackOverflow( IrpContext, &Event, NtfsStackOverflowRead );
                    }

                    //
                    //  And wait for the worker thread to complete the item
                    //

                    (VOID) KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

                    Status = STATUS_PENDING;

                } finally {

                    if (Resource != NULL) {

                        NtfsReleaseResource( IrpContext, Scb );
                    }
                }

            //
            //  Identify read requests which can't wait and post them to the
            //  Fsp.
            //

            } else {

                //
                //  Capture the auxiliary buffer and clear its address if it
                //  is not supposed to be deleted by the I/O system on I/O completion.
                //

                if (Irp->Tail.Overlay.AuxiliaryBuffer != NULL) {

                    IrpContext->Union.AuxiliaryBuffer =
                      (PFSRTL_AUXILIARY_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

                    if (!FlagOn(IrpContext->Union.AuxiliaryBuffer->Flags,
                                FSRTL_AUXILIARY_FLAG_DEALLOCATE)) {

                        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
                    }
                }

                Status = NtfsCommonRead( IrpContext, Irp, TRUE );
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode;

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            ExceptionCode = GetExceptionCode();

            if (ExceptionCode == STATUS_FILE_DELETED) {
                IrpContext->ExceptionStatus = ExceptionCode = STATUS_END_OF_FILE;

                Irp->IoStatus.Information = 0;
            }

            Status = NtfsProcessException( IrpContext,
                                           Irp,
                                           ExceptionCode );
        }

    //
    //  Retry if this is a top level request, and the Irp was not completed due
    //  to a retryable error.
    //

    RetryCount += 1;

    } while ((Status == STATUS_CANT_WAIT || Status == STATUS_LOG_FILE_FULL) &&
             TopLevelContext.TopLevelRequest);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdRead -> %08lx\n", Status) );

    return Status;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );
}


//
//  Internal support routine
//

VOID
NtfsStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine processes a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    Context - Supplies the IrpContext being processed

    Event - Supplies the event to be signaled when we are done processing this
        request.

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    PIRP_CONTEXT IrpContext = Context;

    //
    //  Make it now look like we can wait for I/O to complete
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );

    //
    //  Do the read operation protected by a try-except clause
    //

    try {

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        //
        //  Set the flag to indicate that we are in the overflow thread.
        //

        ThreadTopLevelContext->OverflowReadThread = TRUE;

        (VOID) NtfsCommonRead( IrpContext, IrpContext->OriginatingIrp, FALSE );

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        NTSTATUS ExceptionCode;

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        ExceptionCode = GetExceptionCode();

        if (ExceptionCode == STATUS_FILE_DELETED) {

            IrpContext->ExceptionStatus = ExceptionCode = STATUS_END_OF_FILE;
            IrpContext->OriginatingIrp->IoStatus.Information = 0;
        }

        (VOID) NtfsProcessException( IrpContext, IrpContext->OriginatingIrp, ExceptionCode );
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  Set the stack overflow item's event to tell the original
    //  thread that we're done and then go get another work item.
    //

    KeSetEvent( Event, 0, FALSE );
}


NTSTATUS
NtfsCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN AcquireScb
    )

/*++

Routine Description:

    This is the common routine for Read called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

    AcquireScb - Indicates if this routine should acquire the scb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PNTFS_ADVANCED_FCB_HEADER Header;

    PTOP_LEVEL_CONTEXT TopLevelContext;

    VBO StartingVbo;
    LONGLONG ByteCount;
    LONGLONG ByteRange;
    ULONG RequestedByteCount;

    BOOLEAN PostIrp = FALSE;
    BOOLEAN OplockPostIrp = FALSE;

    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN ReleaseScb;
    BOOLEAN PagingIoAcquired = FALSE;
    BOOLEAN DoingIoAtEof = FALSE;

    BOOLEAN Wait;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN SynchronousIo;
#ifdef  COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
    BOOLEAN CompressedIo = FALSE;
#endif

    NTFS_IO_CONTEXT LocalContext;

    //
    // A system buffer is only used if we have to access the
    // buffer directly from the Fsp to clear a portion or to
    // do a synchronous I/O, or a cached transfer.  It is
    // possible that our caller may have already mapped a
    // system buffer, in which case we must remember this so
    // we do not unmap it on the way out.
    //

    PVOID SystemBuffer = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonRead\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("ByteCount  = %08lx\n", IrpSp->Parameters.Read.Length) );
    DebugTrace( 0, Dbg, ("ByteOffset = %016I64x\n", IrpSp->Parameters.Read.ByteOffset) );
    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Let's kill invalid read requests.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != StreamFileOpen) &&
        (TypeOfOpen != UserVolumeOpen)) {

        DebugTrace( 0, Dbg, ("Invalid file object for read\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Initialize the appropriate local variables.
    //

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = BooleanFlagOn( Irp->Flags,IRP_NOCACHE );
    SynchronousIo = BooleanFlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO );

#ifdef COMPRESS_ON_WIRE
    if (FileObject->SectionObjectPointer == &Scb->NonpagedScb->SegmentObjectC) {

        CompressedIo = TRUE;
    }
#endif

    //
    //  Extract starting Vbo and offset.
    //

    StartingVbo = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    ByteCount = (LONGLONG)IrpSp->Parameters.Read.Length;

    //
    // Check for overflow and underflow.
    //

    if (MAXLONGLONG - StartingVbo < ByteCount) {

        ASSERT( !PagingIo );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    ByteRange = StartingVbo + ByteCount;
    RequestedByteCount = (ULONG)ByteCount;

    //
    //  Check for a null request, and return immediately
    //

    if ((ULONG)ByteCount == 0) {

        DebugTrace( 0, Dbg, ("No bytes to read\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", STATUS_SUCCESS) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Convert all paging i/o against a usa_protected_sequence or compressed file
    //  to synchrnonous because we must do the transform after finishing the i/o
    //  If the header isn't initialized just do the op synchronous rather than
    //  trying to figure out if its compressed by resyncing with disk
    //

    if (!Wait &&
        PagingIo &&
        (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) ||
         Scb->CompressionUnit != 0 ||
         Scb->EncryptionContext) ||
         !FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

        Wait = TRUE;
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }


    //
    //  Make sure there is an initialized NtfsIoContext block.
    //

    if (TypeOfOpen == UserVolumeOpen
        || NonCachedIo) {

        //
        //  If there is a context pointer, we need to make sure it was
        //  allocated and not a stale stack pointer.
        //

        if (IrpContext->Union.NtfsIoContext == NULL
            || !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT )) {

            //
            //  If we can wait, use the context on the stack.  Otherwise
            //  we need to allocate one.
            //

            if (Wait) {

                IrpContext->Union.NtfsIoContext = &LocalContext;
                ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

            } else {

                IrpContext->Union.NtfsIoContext = (PNTFS_IO_CONTEXT)ExAllocateFromNPagedLookasideList( &NtfsIoContextLookasideList );
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );
            }
        }

        RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

        //
        //  Store whether we allocated this context structure in the structure
        //  itself.
        //

        IrpContext->Union.NtfsIoContext->AllocatedContext =
            BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

        if (Wait) {

            KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                               NotificationEvent,
                               FALSE );

        } else {

            IrpContext->Union.NtfsIoContext->PagingIo = PagingIo;
            IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId =
                ExGetCurrentResourceThread();

            IrpContext->Union.NtfsIoContext->Wait.Async.RequestedByteCount =
                (ULONG)ByteCount;
        }
    }

    //
    //  Handle volume Dasd here.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        NTSTATUS Status;

        //
        //  If the caller has not asked for extended DASD IO access then
        //  limit with the volume size.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_XTENDED_DASD_IO )) {

            //
            //  If the starting vbo is past the end of the volume, we are done.
            //

            if (Scb->Header.FileSize.QuadPart <= StartingVbo) {

                DebugTrace( 0, Dbg, ("No bytes to read\n") );
                DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", STATUS_END_OF_FILE) );

                NtfsCompleteRequest( IrpContext, Irp, STATUS_END_OF_FILE );
                return STATUS_END_OF_FILE;

            //
            //  If the write extends beyond the end of the volume, truncate the
            //  bytes to write.
            //

            } else if (Scb->Header.FileSize.QuadPart < ByteRange) {

                ByteCount = Scb->Header.FileSize.QuadPart - StartingVbo;

                if (!Wait) {

                    IrpContext->Union.NtfsIoContext->Wait.Async.RequestedByteCount =
                        (ULONG)ByteCount;
                }
            }
        }

        Status = NtfsVolumeDasdIo( IrpContext,
                                   Irp,
                                   Vcb,
                                   StartingVbo,
                                   (ULONG)ByteCount );

        //
        //  If the volume was opened for Synchronous IO, update the current
        //  file position.
        //

        if (SynchronousIo && !PagingIo &&
            NT_SUCCESS(Status)) {

            IrpSp->FileObject->CurrentByteOffset.QuadPart = StartingVbo + Irp->IoStatus.Information;
        }

        DebugTrace( 0, Dbg, ("Complete with %08lx bytes read\n", Irp->IoStatus.Information) );
        DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", Status) );

        if (Wait) {
            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        return Status;
    }

    //
    //  Keep a pointer to the common fsrtl header.
    //

    Header = &Scb->Header;

    //
    //  If this is a paging file, just send it to the device driver.
    //  We assume Mm is a good citizen.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )
        && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

        if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
        }

        //
        //  Do the usual STATUS_PENDING things.
        //

        IoMarkIrpPending( Irp );

        //
        //  Perform the actual IO, it will be completed when the io finishes.
        //

        NtfsPagingFileIo( IrpContext,
                          Irp,
                          Scb,
                          StartingVbo,
                          (ULONG)ByteCount );

        //
        //  We, nor anybody else, need the IrpContext any more.
        //

        NtfsCompleteRequest( IrpContext, NULL, 0 );
        return STATUS_PENDING;
    }

    //
    //  Accumulate interesting statistics.
    //

    if (PagingIo) {
        CollectReadStats( Vcb, TypeOfOpen, Scb, Fcb, ByteCount );
    }


    //
    //  Use a try-finally to free Scb and buffers on the way out.
    //  At this point we can treat all requests identically since we
    //  have a usable Scb for each of them.  (Volume, User or Stream file)
    //

    try {

        //
        // This case corresponds to a non-directory file read.
        //

        LONGLONG FileSize;
        LONGLONG ValidDataLength;

        //
        //  If this is a noncached transfer and is not a paging I/O, and
        //  the file has a data section, then we will do a flush here
        //  to avoid stale data problems.  Note that we must flush before
        //  acquiring the Fcb shared since the write may try to acquire
        //  it exclusive.  This is not necessary for compressed files, since
        //  we will turn user noncached writes into cached writes.
        //

        if (!PagingIo &&
            NonCachedIo &&
            (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {
            
            //
            //  Acquire the paging exclusive to avoid collided flushes
            //  

            ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                //
                //  It is possible that this read is part of a top level request or
                //  is being called by MM to create an image section.  We will update
                //  the top-level context to reflect this.  All of the exception
                //  handling will correctly handle the log file full in this case.
                //

                TopLevelContext = NtfsGetTopLevelContext();

                if (TopLevelContext->SavedTopLevelIrp != NULL) {

                    TopLevelContext->TopLevelRequest = FALSE;
                }

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags = SCE_FLAG_READ;

                    if (PagingIo)
                    {
                        Flags |= SCE_FLAG_PAGING;
                    }
                    if (!SynchronousIo)
                    {
                        Flags |= SCE_FLAG_ASYNC;
                    }

                    FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH, Flags, StartingVbo, ByteCount, 0 );
                }
#endif


                CcFlushCache( FileObject->SectionObjectPointer,
                              (PLARGE_INTEGER)&StartingVbo,
                              (ULONG)ByteCount,
                              &Irp->IoStatus );


                ExReleaseResourceLite( Scb->Header.PagingIoResource );

                //
                //  Check for errors in the flush.
                //

                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                    &Irp->IoStatus.Status,
                                                    TRUE,
                                                    STATUS_UNEXPECTED_IO_ERROR );

            } else {

                ExReleaseResourceLite( Scb->Header.PagingIoResource );
            }

        }

#ifdef  COMPRESS_ON_WIRE

        //
        //  For top-level noncached reads (including page reads and read-ahead paged reads),
        //  to the normal data section when a compressed section exists, we have to flush the
        //  range in the compressed section first.  Note that NtfsSynchronizeUncompressedIo
        //  is used to synchronize the cached case below.
        //
        //  Currently only cached access is supported to the compressed section, and the
        //  coherency to that section is synchronized in rwcmpsup.c.  You do not see a similar
        //  block of code in write.c, which would only be concerned about user-mapped files,
        //  since user-mapping is incompatible with writes to the compressed stream, and in
        //  fact the user mapper would break the oplocks that allow the only compressed stream
        //  access supported at this time.
        //

        if ((Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) &&
            !CompressedIo &&
            NonCachedIo &&
            (NtfsGetTopLevelContext()->SavedTopLevelIrp == NULL)) {

            LONGLONG LocalVbo;
            ULONG LocalCount;

            ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );

            LocalVbo = StartingVbo & ~((ULONG_PTR)Scb->CompressionUnit - 1);
            LocalCount = (ULONG)(ByteCount + (StartingVbo - LocalVbo));
            LocalCount = (LocalCount + Scb->CompressionUnit - 1) & ~(Scb->CompressionUnit - 1);

            CcFlushCache( &Scb->NonpagedScb->SegmentObjectC,
                          (PLARGE_INTEGER)&LocalVbo,
                          LocalCount,
                          &Irp->IoStatus );

            ExReleaseResourceLite( Scb->Header.PagingIoResource );

#ifdef NTFS_RWC_DEBUG
            ASSERT( !NtfsBreakOnConflict ||
                    (IrpContext->TopLevelIrpContext->ExceptionStatus != STATUS_CANT_WAIT) );
#endif

            //
            //  Check for errors in the flush.
            //

            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                &Irp->IoStatus.Status,
                                                TRUE,
                                                STATUS_UNEXPECTED_IO_ERROR );

        }
#endif
        //
        //  We need shared access to the Scb before proceeding.
        //  We won't acquire the Scb for a non-cached read of the first 4
        //  file records.
        //

        if (AcquireScb &&

            (!NonCachedIo || NtfsGtrMftRef( &Fcb->FileReference, &VolumeFileReference))) {

            //
            //  Figure out if we have been entered during the posting
            //  of a top level request.
            //

            TopLevelContext = NtfsGetTopLevelContext();

            //
            //  Initially we always force reads to appear to be top level
            //  requests.  If we reach this point the read not to the paging
            //  file so it is safe to determine if we are really a top level
            //  request.  If there is an Ntfs request above us we will clear
            //  the TopLevelRequest field in the TopLevelContext.
            //

            if (TopLevelContext->ValidSavedTopLevel) {
                TopLevelContext->TopLevelRequest = FALSE;
            }

            //
            //  If this is not a paging I/O (cached or user noncached I/O),
            //  then acquire the paging I/O resource.  (Note, you can only
            //  do cached I/O to user streams, and they always have a paging
            //  I/O resource.
            //

            if (!PagingIo) {

                //
                //  If we cannot acquire the resource, then raise.
                //

                if (!ExAcquireSharedWaitForExclusive( Scb->Header.PagingIoResource, Wait )) {
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }
                PagingIoAcquired = TRUE;

                //
                //  If this is async I/O save away the async resource.
                //

                if (!Wait && NonCachedIo) {

                    IrpContext->Union.NtfsIoContext->Wait.Async.Resource = Scb->Header.PagingIoResource;
                }

                //
                //  Check if we have already gone through cleanup on this handle.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_CLEANUP )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CLOSED, NULL, NULL );
                }

                //
                //  The reason that we always handle the user requests through the cache,
                //  is that there is no better way to deal with alignment issues, for
                //  the frequent case where the user noncached I/O is not an integral of
                //  the Compression Unit.  Also, the way we synchronize the case where
                //  a compression unit is being moved to a different spot on disk during
                //  a write, is to keep the pages locked in memory during the write, so
                //  that there will be no need to read the disk at the same time.  (If
                //  we allowed real noncached I/O, then we would somehow have to synchronize
                //  the noncached read with the write of the same data.)
                //
                //  Bottom line is we can only really support cached reads to compresed
                //  files.
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) && NonCachedIo) {

                    NonCachedIo = FALSE;

                    if (Scb->FileObject == NULL) {

                        //
                        //  Make sure we are serialized with the FileSizes, and
                        //  will remove this condition if we abort.
                        //

                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;

                        NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }

                    FileObject = Scb->FileObject;
                }

                //
                //  Now check if the attribute has been deleted or if the
                //  volume has been dismounted.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                    } else {
                        NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                    }
                }

            //
            //  If this is a paging I/O, and there is a paging I/O resource, then
            //  we acquire the main resource here.  Note that for most paging I/Os
            //  (like faulting for cached I/O), we already own the paging I/O resource,
            //  so we acquire nothing here!  But, for other cases like user-mapped files,
            //  we do check if paging I/O is acquired, and acquire the main resource if
            //  not.  The point is, we need some guarantee still that the file will not
            //  be truncated.
            //

            } else if ((Scb->Header.PagingIoResource != NULL) &&
                        !NtfsIsSharedScbPagingIo( Scb )) {

                //
                //  If we cannot acquire the resource, then raise.
                //

                if (!NtfsAcquireResourceShared( IrpContext, Scb, Wait )) {
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                ScbAcquired = TRUE;

                //
                //  If this is async I/O save away the async resource.
                //

                if (!Wait && NonCachedIo) {
                    IrpContext->Union.NtfsIoContext->Wait.Async.Resource = Scb->Header.Resource;
                }


                //
                //  Now check if the attribute has been deleted or if the
                //  volume has been dismounted.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED )) {
                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                    } else {
                        NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                    }
                }
            }
        }

        //
        //  If the Scb is uninitialized, we initialize it now.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

            ReleaseScb = FALSE;

            if (AcquireScb && !ScbAcquired) {

                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                ReleaseScb = TRUE;
            }

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

            if (ReleaseScb) {

                NtfsReleaseResource( IrpContext, Scb );
                ScbAcquired = FALSE;
            }
        }

        //
        //  We check whether we can proceed
        //  based on the state of the file oplocks.
        //

        if (TypeOfOpen == UserFileOpen) {

            Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsPrePostIrp );

            if (Status != STATUS_SUCCESS) {

                OplockPostIrp = TRUE;
                PostIrp = TRUE;
                try_return( NOTHING );
            }

            //
            //  This oplock call can affect whether fast IO is possible.
            //  We may have broken an oplock to no oplock held.  If the
            //  current state of the file is FastIoIsNotPossible then
            //  recheck the fast IO state.
            //

            if (Scb->Header.IsFastIoPossible == FastIoIsNotPossible) {

                NtfsAcquireFsrtlHeader( Scb );
                Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                NtfsReleaseFsrtlHeader( Scb );
            }

            //
            // We have to check for read access according to the current
            // state of the file locks.
            //

            if (!PagingIo
                && Scb->ScbType.Data.FileLock != NULL
                && !FsRtlCheckLockForReadAccess( Scb->ScbType.Data.FileLock,
                                                 Irp )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }

        //
        //  Now synchronize with the FsRtl Header
        //

        NtfsAcquireFsrtlHeader( (PSCB) Header );
        
        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.  We only need to block
        //  on nonrecursive I/O (cached or page fault to user section, because
        //  if it is paging I/O, we must be part of a reader or writer who is
        //  synchronized.
        //

        if ((ByteRange > Header->ValidDataLength.QuadPart) && !PagingIo) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.  If our caller has already serialized
            //  with EOF then there is nothing for us to do here.
            //

            if ((IrpContext->TopLevelIrpContext->CleanupStructure == Fcb) ||
                (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

                DoingIoAtEof = TRUE;

            } else {

                DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                               NtfsWaitForIoAtEof( Header,
                                                   (PLARGE_INTEGER)&StartingVbo,
                                                   (ULONG)ByteCount );

                //
                //  Set the Flag if we are in fact beyond ValidDataLength.
                //

                if (DoingIoAtEof) {
                    SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
                    IrpContext->CleanupStructure = Scb;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

                } else {

                    ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                }
            }
        }

        //
        //  Get file sizes from the Scb.
        //
        //  We must get ValidDataLength first since it is always
        //  increased second (the case we are unprotected) and
        //  we don't want to capture ValidDataLength > FileSize.
        //

        ValidDataLength = Header->ValidDataLength.QuadPart;
        FileSize = Header->FileSize.QuadPart;

        NtfsReleaseFsrtlHeader( (PSCB) Header );
        
        //
        //  Optimize for the case where we are trying to fault in an entire
        //  compression unit, even if past the end of the file.  Go ahead
        //  and round the local FileSize to a compression unit boundary.
        //  This will allow all of these pages to come into memory when
        //  CC touches the first page out of memory.  Otherwise CC will
        //  force them into memory one page at a time.
        //

        if (PagingIo) {

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                !FlagOn(Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT)) {

                FileSize += (Scb->CompressionUnit - 1);
                ((PLARGE_INTEGER) &FileSize)->LowPart &= ~(Scb->CompressionUnit - 1);
            }

#ifdef  COMPRESS_ON_WIRE
            
            //
            //  If we are reading the compressed stream then we may need the
            //  data past file size.
            //

            if (CompressedIo) {

                ValidDataLength += (Scb->CompressionUnit - 1);
                ((PLARGE_INTEGER) &ValidDataLength)->LowPart &= ~(Scb->CompressionUnit - 1);
            }
#endif

            //
            //  If this is the Usn Journal then bias the Io to the correct location in the
            //  file.
            //

            if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

                StartingVbo += Vcb->UsnCacheBias;
                ByteRange = StartingVbo + (LONGLONG) IrpSp->Parameters.Read.Length;
            }
        }

        //
        // If the read starts beyond End of File, return EOF.
        //

        if (StartingVbo >= FileSize) {

            DebugTrace( 0, Dbg, ("End of File\n") );

            try_return ( Status = STATUS_END_OF_FILE );
        }

        //
        //  If the read extends beyond EOF, truncate the read
        //

        if (ByteRange > FileSize) {

#ifdef NTFS_RWC_DEBUG
#ifdef  COMPRESS_ON_WIRE
            if (CompressedIo &&
                (StartingVbo < NtfsRWCHighThreshold) &&
                (ByteRange > NtfsRWCLowThreshold)) {

                PRWC_HISTORY_ENTRY NextBuffer;

                NextBuffer = NtfsGetHistoryEntry( Scb );

                NextBuffer->Operation = TrimCompressedRead;
                NextBuffer->Information = Scb->Header.FileSize.LowPart;
                NextBuffer->FileOffset = (ULONG) StartingVbo;
                NextBuffer->Length = (ULONG) ByteRange;
            }
#endif
#endif
            ByteCount = FileSize - StartingVbo;
            ByteRange = StartingVbo + ByteCount;

            RequestedByteCount = (ULONG)ByteCount;

            if (NonCachedIo && !Wait) {

                IrpContext->Union.NtfsIoContext->Wait.Async.RequestedByteCount =
                    (ULONG)ByteCount;
            }
        }


        //
        //  HANDLE THE NONCACHED RESIDENT ATTRIBUTE CASE
        //
        //  We let the cached case take the normal path for the following
        //  reasons:
        //
        //    o To insure data coherency if a user maps the file
        //    o To get a page in the cache to keep the Fcb around
        //    o So the data can be accessed via the Fast I/O path
        //
        //  The disadvantage is the overhead to fault the data in the
        //  first time, but we may be able to do this with asynchronous
        //  read ahead.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_CONVERT_UNDERWAY ) && NonCachedIo) {

            ReleaseScb = FALSE;

            if (AcquireScb && !ScbAcquired) {
                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                ReleaseScb = TRUE;
            }

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {
                
                NtfsNonCachedResidentRead( IrpContext, Irp, Scb, (ULONG)StartingVbo, (ULONG)ByteCount );
                try_return( Status = STATUS_SUCCESS );

            } else {

                if (ReleaseScb) {
                    NtfsReleaseResource( IrpContext, Scb );
                    ScbAcquired = FALSE;
                }
            }
        }


        //
        //  HANDLE THE NON-CACHED CASE
        //

        if (NonCachedIo) {

            ULONG BytesToRead;

            ULONG SectorSize;

            ULONG ZeroOffset;
            ULONG ZeroLength = 0;

            DebugTrace( 0, Dbg, ("Non cached read.\n") );

            //
            //  For a compressed stream, which is user-mapped, reserve space
            //  as pages come in.
            //

            if (FlagOn( Header->Flags, FSRTL_FLAG_USER_MAPPED_FILE ) &&
                FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                !NtfsReserveClusters( IrpContext, Scb, StartingVbo, (ULONG)ByteCount )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
            }

            //
            //  If this is a read of an encrypted file then make it synchronous.  We
            //  need to do this so that the encryption driver has a thread to run in.
            //

            if ((Scb->EncryptionContext != NULL) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) &&
                (NtfsData.EncryptionCallBackTable.AfterReadProcess != NULL) &&
                NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

                //
                //  Store whether we allocated this context structure in the structure
                //  itself.
                //

                IrpContext->Union.NtfsIoContext->AllocatedContext =
                    BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                   NotificationEvent,
                                   FALSE );
            }

            //
            //  Start by zeroing any part of the read after Valid Data
            //

            if (ByteRange > ValidDataLength) {

                ReleaseScb = FALSE;

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    //
                    //  For compressed files we need to look at ValidDataToDisk, because it could be higher.
                    //  This requires the main resource
                    //

                    if (AcquireScb && !ScbAcquired) {
                        NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                        ScbAcquired = TRUE;
                        ReleaseScb = TRUE;
                    }

                    //
                    //  If ValidDataToDisk is actually greater than
                    //  ValidDataLength, then we must have lost a page
                    //  during the middle of a write, and we should not
                    //  zero that data on the way back in!
                    //

                    if (ValidDataLength < Scb->ValidDataToDisk) {
                        ValidDataLength = Scb->ValidDataToDisk;
                    }
                }

                if (ByteRange > ValidDataLength) {

                    SystemBuffer = NtfsMapUserBuffer( Irp );

                    if (StartingVbo < ValidDataLength) {

                        //
                        //  Assume we will zero the entire amount.
                        //

                        ZeroLength = (ULONG)ByteCount;

                        //
                        //  The new byte count and the offset to start filling with zeroes.
                        //

                        ByteCount = ValidDataLength - StartingVbo;
                        ZeroOffset = (ULONG)ByteCount;

                        //
                        //  Now reduce the amount to zero by the zero offset.
                        //

                        ZeroLength -= ZeroOffset;

                        //
                        //  If this was non-cached I/O then convert it to synchronous.
                        //  This is because we don't want to zero the buffer now or
                        //  we will lose the data when the driver purges the cache.
                        //

                        if (!Wait) {

                            Wait = TRUE;
                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                            RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

                            //
                            //  Store whether we allocated this context structure in the structure
                            //  itself.
                            //

                            IrpContext->Union.NtfsIoContext->AllocatedContext =
                                BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                            KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                               NotificationEvent,
                                               FALSE );
                        }

                        //
                        //  Reserve the clusters in the range beyond VDL
                        //

                        if ((PagingIo) &&
                            (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) &&
                            (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE)) {

                            if (!NtfsReserveClusters( IrpContext,
                                                      Scb,
                                                      ZeroOffset,
                                                      ZeroLength )) {

                                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                            }
                        }


                    } else {

                        //
                        //  Reserve space for mapped sparse files which would normally be
                        //  done in NtfsPrepareBuffers
                        //

                        if ((PagingIo) &&
                            (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) &&
                            (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE)) {

                            if (!NtfsReserveClusters( IrpContext,
                                                      Scb,
                                                      StartingVbo,
                                                      (ULONG)ByteCount )) {

                                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                            }
                        }

                        //
                        //  All we have to do now is sit here and zero the
                        //  user's buffer, no reading is required.
                        //

                        SafeZeroMemory( (PUCHAR)SystemBuffer, (ULONG)ByteCount );

#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            ULONG Flags = SCE_FLAG_READ;

                            if (PagingIo)
                            {
                                Flags |= SCE_FLAG_PAGING;
                            }
                            if (!SynchronousIo)
                            {
                                Flags |= SCE_FLAG_ASYNC;
                            }

                            ASSERT( Scb->NonpagedScb->SegmentObject.ImageSectionObject == NULL );

                            FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, StartingVbo, ByteCount, ValidDataLength );
                        }
#endif


                        Irp->IoStatus.Information = (ULONG)ByteCount;

                        try_return ( Status = STATUS_SUCCESS );
                    }
                }

                //
                //  Now free the Scb if we only acquired it here.
                //

                if (ReleaseScb) {
                    NtfsReleaseResource( IrpContext, Scb );
                    ScbAcquired = FALSE;
                }
            }

            //
            //  Get the sector size
            //

            SectorSize = Vcb->BytesPerSector;

            //
            //  Round up to a sector boundry
            //

            BytesToRead = ((ULONG)ByteCount + (SectorSize - 1)) & ~(SectorSize - 1);

            //
            //  Call a special routine if we do not have sector alignment
            //  and the file is not compressed.
            //

            if (((((ULONG) StartingVbo) & (SectorSize - 1)) ||
                 (BytesToRead > IrpSp->Parameters.Read.Length))

                         &&

                !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                //
                //  If we can't wait, we must post this.
                //

                if (!Wait) {

                    try_return( PostIrp = TRUE );
                }

                //
                //  Do the physical read.
                //

#ifdef  COMPRESS_ON_WIRE
                ASSERT( !CompressedIo );
#endif
                ASSERT( Wait );

                NtfsNonCachedNonAlignedIo( IrpContext,
                                           Irp,
                                           Scb,
                                           StartingVbo,
                                           (ULONG)ByteCount );

                BytesToRead = (ULONG)ByteCount;

            } else {

                //
                //  Just to help reduce confusion.  At this point:
                //
                //  RequestedByteCount - is the number of bytes originally
                //                       taken from the Irp, but constrained
                //                       to filesize.
                //
                //  ByteCount -          is RequestedByteCount constrained to
                //                       ValidDataLength.
                //
                //  BytesToRead -        is ByteCount rounded up to sector
                //                       boundry.  This is the number of bytes
                //                       that we must physically read.
                //

                //
                //  Perform the actual IO - all resources will be released by
                //  the completion routine after this point if its successful
                //

                if (NtfsNonCachedIo( IrpContext,
                                     Irp,
                                     Scb,
                                     StartingVbo,
                                     BytesToRead,
#ifdef  COMPRESS_ON_WIRE
                                     (CompressedIo ? COMPRESSED_STREAM : 0)
#else
                                    0 
#endif
                                    ) == STATUS_PENDING ) {

                    IrpContext->Union.NtfsIoContext = NULL;
                    PagingIoAcquired = FALSE;
#ifdef NTFSDBG
                    //
                    //  Reflect transfer of main ownership to completion routine
                    //

                    if (ScbAcquired) {

                        NTFS_RESOURCE_NAME ResourceName;

                        ResourceName = NtfsIdentifyFcb( Vcb, Scb->Fcb );
                        NtfsChangeResourceOrderState( IrpContext, ResourceName, TRUE, FALSE );
                    }
#endif

                    ScbAcquired = FALSE;
                    Irp = NULL;

                    try_return( Status = STATUS_PENDING );
                }
            }

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                NtfsNormalizeAndRaiseStatus( IrpContext,
                                             Status,
                                             STATUS_UNEXPECTED_IO_ERROR );
            }

            //
            //  Else set the Irp information field to reflect the
            //  entire desired read.
            //

            ASSERT( Irp->IoStatus.Information == BytesToRead );

            Irp->IoStatus.Information = RequestedByteCount;

            //
            //  If we rounded up to a sector boundry before, zero out
            //  the other garbage we read from the disk.
            //

            if (BytesToRead > (ULONG)ByteCount) {

                if (SystemBuffer == NULL) {

                    SystemBuffer = NtfsMapUserBuffer( Irp );
                }

#ifdef NTFS_RWC_DEBUG
                if (CompressedIo &&
                    (StartingVbo + ByteCount < NtfsRWCHighThreshold) &&
                    (StartingVbo + BytesToRead > NtfsRWCLowThreshold)) {

                    PRWC_HISTORY_ENTRY NextBuffer;

                    NextBuffer = NtfsGetHistoryEntry( Scb );

                    NextBuffer->Operation = ZeroCompressedRead;
                    NextBuffer->Information = Scb->Header.ValidDataLength.LowPart;
                    NextBuffer->FileOffset = (ULONG) StartingVbo + (ULONG) ByteCount;
                    NextBuffer->Length = (ULONG) BytesToRead - (ULONG) ByteCount;
                }
#endif

                SafeZeroMemory( (PUCHAR)SystemBuffer + (ULONG)ByteCount,
                                BytesToRead - (ULONG)ByteCount );

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags = SCE_FLAG_READ;

                    if (PagingIo)
                    {
                        Flags |= SCE_FLAG_PAGING;
                    }
                    if (!SynchronousIo)
                    {
                        Flags |= SCE_FLAG_ASYNC;
                    }

                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, ByteCount + StartingVbo, BytesToRead - ByteCount, 0 );
                }
#endif

            }

            //
            //  If we need to zero the tail of the buffer because of valid data
            //  then do so now.
            //

            if (ZeroLength != 0) {

                if (SystemBuffer == NULL) {

                    SystemBuffer = NtfsMapUserBuffer( Irp );
                }

#ifdef  COMPRESS_ON_WIRE
#ifdef NTFS_RWC_DEBUG
                if ((Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) &&
                    PagingIo &&
                    !CompressedIo &&
                    (StartingVbo < NtfsRWCHighThreshold) &&
                    (StartingVbo + BytesToRead > NtfsRWCLowThreshold)) {

                    PRWC_HISTORY_ENTRY NextBuffer;

                    NextBuffer = NtfsGetHistoryEntry( Scb );

                    NextBuffer->Operation = FaultIntoUncompressed;
                    NextBuffer->Information = 0;
                    NextBuffer->FileOffset = (ULONG) StartingVbo;
                    NextBuffer->Length = (ULONG) BytesToRead;
                }
#endif
#endif
                SafeZeroMemory( Add2Ptr( SystemBuffer, ZeroOffset ), ZeroLength );

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags = SCE_FLAG_READ;

                    if (PagingIo)
                    {
                        Flags |= SCE_FLAG_PAGING;
                    }
                    if (!SynchronousIo)
                    {
                        Flags |= SCE_FLAG_ASYNC;
                    }

                    ASSERT( Scb->NonpagedScb->SegmentObject.ImageSectionObject == NULL );
                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, ZeroOffset + StartingVbo, ZeroLength, 0 );
                }
#endif

            }

            //
            // The transfer is complete.
            //

            try_return( Status );

        }   // if No Intermediate Buffering


        //
        //  HANDLE THE CACHED CASE
        //

        else {

            //
            //  We need to go through the cache for this
            //  file object.  First handle the noncompressed calls.
            //

#ifdef  COMPRESS_ON_WIRE
            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED)) {
#endif

                //
                // We delay setting up the file cache until now, in case the
                // caller never does any I/O to the file, and thus
                // FileObject->PrivateCacheMap == NULL.
                //

                if (FileObject->PrivateCacheMap == NULL) {

                    DebugTrace( 0, Dbg, ("Initialize cache mapping.\n") );

                    //
                    //  Now initialize the cache map.
                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    CcInitializeCacheMap( FileObject,
                                          (PCC_FILE_SIZES)&Header->AllocationSize,
                                          FALSE,
                                          &NtfsData.CacheManagerCallbacks,
                                          Scb );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }

                    CcSetReadAheadGranularity( FileObject, READ_AHEAD_GRANULARITY );
                }

                //
                // DO A NORMAL CACHED READ, if the MDL bit is not set,
                //

                DebugTrace( 0, Dbg, ("Cached read.\n") );

                //
                //  If there is a compressed section, we have to do cache coherency for
                //  that stream, and loop here to do a Cache Manager view at a time.
                //

#ifdef  COMPRESS_ON_WIRE
                if (Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                    LONGLONG LocalOffset = StartingVbo;
                    ULONG LocalLength;
                    ULONG LengthLeft = (ULONG) ByteCount;

                    //
                    //  Create the compressed stream if not there.
                    //

                    if (Header->FileObjectC == NULL) {
                        NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );
                    }

                    if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                        //
                        //  Get hold of the user's buffer.
                        //

                        SystemBuffer = NtfsMapUserBuffer( Irp );
                    }

                    //
                    //  We must loop to do a view at a time, because that is how much
                    //  we synchronize at once below.
                    //

                    do {

                        ULONG PageCount;
                        ULONG ViewOffset;

                        //
                        //  Calculate length left in view.
                        //

                        LocalLength = LengthLeft;
                        if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                            LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                        }

                        //
                        //  Trim the read so we don't inadvertently go beyond the end of the
                        //  view because of the MM read ahead.
                        //

                        ViewOffset = ((ULONG) LocalOffset & (VACB_MAPPING_GRANULARITY - 1));
                        PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(((PVOID)(ULONG_PTR)((ULONG)LocalOffset)), LocalLength);

                        if (LocalLength > (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset)) {

#ifdef NTFS_RWC_DEBUG
                            if ((LocalOffset < NtfsRWCHighThreshold) &&
                                (LocalOffset + LocalLength > NtfsRWCLowThreshold)) {

                                PRWC_HISTORY_ENTRY NextBuffer;

                                NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                                NextBuffer->Operation = TrimCopyRead;
                                NextBuffer->Information = PageCount;
                                NextBuffer->FileOffset = (ULONG) LocalOffset;
                                NextBuffer->Length = (ULONG) LocalLength;
                            }
#endif
                            LocalLength = (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset);
                        }

                        Status = NtfsSynchronizeUncompressedIo( Scb,
                                                                &LocalOffset,
                                                                LocalLength,
                                                                FALSE,
                                                                &CompressionSync );

                        //
                        //  If we successfully synchronized, then do a piece of the transfer.
                        //

                        if (NT_SUCCESS(Status)) {

                            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                                //
                                // Now try to do the copy.
                                //

                                if (!CcCopyRead( FileObject,
                                                 (PLARGE_INTEGER)&LocalOffset,
                                                 LocalLength,
                                                 Wait,
                                                 SystemBuffer,
                                                 &Irp->IoStatus )) {

                                    DebugTrace( 0, Dbg, ("Cached Read could not wait\n") );

                                    try_return( PostIrp = TRUE );
                                }

                                SystemBuffer = Add2Ptr( SystemBuffer, LocalLength );

                            //
                            //  HANDLE A MDL READ
                            //

                            } else {

                                DebugTrace( 0, Dbg, ("MDL read.\n") );

                                ASSERT( Wait );

#ifdef NTFS_RWCMP_TRACE
                                if (NtfsCompressionTrace && IsSyscache(Header)) {
                                    DbgPrint("CcMdlRead: FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                                }
#endif

                                CcMdlRead( FileObject,
                                           (PLARGE_INTEGER)&LocalOffset,
                                           LocalLength,
                                           &Irp->MdlAddress,
                                           &Irp->IoStatus );
                            }

                            Status = Irp->IoStatus.Status;

                            LocalOffset += LocalLength;
                            LengthLeft -= LocalLength;
                        }

                    } while ((LengthLeft != 0) && NT_SUCCESS(Status));

                    //
                    //  Make sure to return the total of all of the IOs.
                    //

                    Irp->IoStatus.Information = (ULONG) ByteCount;
                    try_return( Status );
                }
#endif

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = NtfsMapUserBuffer( Irp );

                    //
                    // Now try to do the copy.
                    //

                    if (!CcCopyRead( FileObject,
                                     (PLARGE_INTEGER)&StartingVbo,
                                     (ULONG)ByteCount,
                                     Wait,
                                     SystemBuffer,
                                     &Irp->IoStatus )) {

                        DebugTrace( 0, Dbg, ("Cached Read could not wait\n") );

                        try_return( PostIrp = TRUE );
                    }

                //
                //  HANDLE A MDL READ
                //

                } else {

                    DebugTrace( 0, Dbg, ("MDL read.\n") );

                    ASSERT( Wait );

#ifdef NTFS_RWCMP_TRACE
                    if (NtfsCompressionTrace && IsSyscache(Header)) {
                        DbgPrint("CcMdlRead: FO = %08lx, Len = %08lx\n", (ULONG)StartingVbo, (ULONG)ByteCount );
                    }
#endif

                    CcMdlRead( FileObject,
                               (PLARGE_INTEGER)&StartingVbo,
                               (ULONG)ByteCount,
                               &Irp->MdlAddress,
                               &Irp->IoStatus );
                }

                Status = Irp->IoStatus.Status;

                ASSERT( NT_SUCCESS( Status ));

                try_return( Status );

#ifdef  COMPRESS_ON_WIRE

            //
            //  Handle the compressed calls.
            //

            } else {

                PCOMPRESSED_DATA_INFO CompressedDataInfo;
                PMDL *NewMdl;

                ASSERT((StartingVbo & (NTFS_CHUNK_SIZE - 1)) == 0);

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_REALLOCATE_ON_WRITE )) {
                    try_return( Status = STATUS_INVALID_READ_MODE );
                }

                //
                //  Get out if COW is not supported.
                //

                if (!NtfsEnableCompressedIO) {

                    try_return( Status = STATUS_INVALID_READ_MODE );
                }

                if ((Header->FileObjectC == NULL) ||
                    (Header->FileObjectC->PrivateCacheMap == NULL)) {

                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }
                }

                //
                //  Assume success.
                //

                Irp->IoStatus.Status = Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG)(ByteRange - StartingVbo);

                //
                //  Based on the Mdl minor function, set up the appropriate
                //  parameters for the call below.
                //

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = NtfsMapUserBuffer( Irp );
                    NewMdl = NULL;

                } else {

                    //
                    //  We will deliver the Mdl directly to the Irp.
                    //

                    SystemBuffer = NULL;
                    NewMdl = &Irp->MdlAddress;
                }

                CompressedDataInfo = (PCOMPRESSED_DATA_INFO)IrpContext->Union.AuxiliaryBuffer->Buffer;

                CompressedDataInfo->CompressionFormatAndEngine =
                    (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1);
                CompressedDataInfo->CompressionUnitShift = (UCHAR)(Scb->CompressionUnitShift + Vcb->ClusterShift);
                CompressedDataInfo->ChunkShift = NTFS_CHUNK_SHIFT;
                CompressedDataInfo->ClusterShift = (UCHAR)Vcb->ClusterShift;
                CompressedDataInfo->Reserved = 0;

                //
                //  Do the compressed read in common code with the Fast Io path.
                //  We do it from a loop because we may need to create the other
                //  data stream.
                //

                while (TRUE) {

                    //
                    //  Make sure to reset this if we pass through the loop again.
                    //

                    CompressedDataInfo->NumberOfChunks = 0;

                    Status = NtfsCompressedCopyRead( FileObject,
                                                     (PLARGE_INTEGER)&StartingVbo,
                                                     (ULONG)ByteCount,
                                                     SystemBuffer,
                                                     NewMdl,
                                                     CompressedDataInfo,
                                                     IrpContext->Union.AuxiliaryBuffer->Length,
                                                     IoGetRelatedDeviceObject(FileObject),
                                                     Header,
                                                     Scb->CompressionUnit,
                                                     NTFS_CHUNK_SIZE );

                    //
                    //  On successful Mdl requests we hang on to the PagingIo resource.
                    //

                    if ((NewMdl != NULL) && NT_SUCCESS(Status) && (*NewMdl != NULL)) {
                        PagingIoAcquired = FALSE;
                    }

                    //
                    //  Check for the status that says we need to create the normal
                    //  data stream, else we are done.
                    //

                    if (Status != STATUS_NOT_MAPPED_DATA) {
                        break;
                    }

                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    //
                    //  Create the normal data stream and loop back to try again.
                    //

                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }
                }
            }
#endif

        }

    try_exit: NOTHING;

        //
        //  If the request was not posted, deal with it.
        //

        if (Irp) {

            if (!PostIrp) {

                DebugTrace( 0, Dbg, ("Completing request with status = %08lx\n",
                            Status));

                DebugTrace( 0, Dbg, ("                   Information = %08lx\n",
                            Irp->IoStatus.Information));

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position.  Make sure to use the original file object
                //  not an internal stream we may use within this routine.
                //  Information field contains the actual bytes read
                //

                if (!PagingIo) {

                    if (SynchronousIo) {

                        IrpSp->FileObject->CurrentByteOffset.QuadPart = StartingVbo + Irp->IoStatus.Information;
                    }

                    //
                    //  On success, do the following to let us update last access time.
                    //

                    if (NT_SUCCESS( Status )) {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );
                    }
                }

                //
                //  Abort transaction on error by raising.
                //

                NtfsCleanupTransaction( IrpContext, Status, FALSE );

            }
        }

    } finally {

        DebugUnwind( NtfsCommonRead );

#ifdef  COMPRESS_ON_WIRE
        //
        //  Clean up any Bcb from read/synchronize compressed.
        //

        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

        //
        // If the Scb has been acquired, release it.
        //

        if (PagingIoAcquired) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        if (Irp) {

            if (ScbAcquired) {

                NtfsReleaseResource( IrpContext, Scb );
            }
        }
    }

    //
    //  Complete the request if we didn't post it and no exception
    //
    //  Note that NtfsCompleteRequest does the right thing if either
    //  IrpContext or Irp are NULL
    //

    if (!PostIrp) {

        NtfsCompleteRequest( IrpContext, Irp, Status );

    } else if (!OplockPostIrp) {

        Status = NtfsPostRequest( IrpContext, Irp );
    }


    return Status;
}


VOID 
NtfsNonCachedResidentRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    Read a resident file record directly for the non cached path. This is 
    done separately to scope the attribute enumeration context so its not present
    in most of the read path and for simplicity

Arguments:

    IrpContext - If present this an IrpContext put on the caller's stack
        to avoid having to allocate it from pool.

    Irp - Supplies the Irp being processed
    
    Scb -  scb to read from
    
    StartingVbo - start offset in the file - since its resident can be stored in a ulong
    
    ByteCount - bytes to read  - since its resident can be stored in a ulong

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    PVOID SystemBuffer;
    PUCHAR AttrValue;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    //
    //  Get hold of the user's buffer.
    //

    SystemBuffer = NtfsMapUserBuffer( Irp );

    //
    //  This is a resident attribute, we need to look it up
    //  and copy the desired range of bytes to the user's
    //  buffer.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    try {
        
        NtfsLookupAttributeForScb( IrpContext,
                                   Scb,
                                   NULL,
                                   &AttrContext );

        AttrValue = NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        RtlCopyMemory( SystemBuffer,
                       Add2Ptr( AttrValue, StartingVbo ),
                       ByteCount );

        Irp->IoStatus.Information = ByteCount;
   
    } finally {
        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\rwcmpsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RwCmpSup.c

Abstract:

    This module implements the fast I/O routines for read/write compressed.

Author:

    Tom Miller      [TomM]          14-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

VOID
NtfsAddToCompressedMdlChain (
    IN OUT PMDL *MdlChain,
    IN PVOID MdlBuffer,
    IN ULONG MdlLength,
    IN PERESOURCE ResourceToRelease OPTIONAL,
    IN PBCB Bcb,
    IN LOCK_OPERATION Operation,
    IN ULONG IsCompressed
    );

VOID
NtfsSetMdlBcbOwners (
    IN PMDL MdlChain
    );

VOID
NtfsCleanupCompressedMdlChain (
    IN PMDL MdlChain,
    IN ULONG Error
    );

#ifdef NTFS_RWC_DEBUG

PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsGetHistoryEntry)
#endif

#define CACHE_NTC_BCB                    (0x2FD)
#define CACHE_NTC_OBCB                   (0x2FA)

typedef struct _OBCB {

    //
    //  Type and size of this record
    //

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    //  Byte FileOffset and and length of entire buffer
    //

    ULONG ByteLength;
    LARGE_INTEGER FileOffset;

    //
    //  Vector of Bcb pointers.
    //

    PPUBLIC_BCB Bcbs[ANYSIZE_ARRAY];

} OBCB;
typedef OBCB *POBCB;

PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    )
{
    ULONG NextIndex;

    PAGED_CODE();

    //
    //  Store and entry in the history buffer.
    //

    if (Scb->ScbType.Data.HistoryBuffer == NULL) {

        PVOID NewBuffer;

        NewBuffer = NtfsAllocatePool( PagedPool,
                                      sizeof( RWC_HISTORY_ENTRY ) * MAX_RWC_HISTORY_INDEX );

        RtlZeroMemory( NewBuffer, sizeof( RWC_HISTORY_ENTRY ) * MAX_RWC_HISTORY_INDEX );
        NtfsAcquireFsrtlHeader( Scb );

        if (Scb->ScbType.Data.HistoryBuffer == NULL) {

            Scb->ScbType.Data.HistoryBuffer = NewBuffer;

        } else {

            NtfsFreePool( NewBuffer );
        }

        NtfsReleaseFsrtlHeader( Scb );
    }

    NextIndex = InterlockedIncrement( &Scb->ScbType.Data.RwcIndex );
    if (NextIndex >= MAX_RWC_HISTORY_INDEX) {

        NextIndex = 0;
        InterlockedExchange( &Scb->ScbType.Data.RwcIndex, 0);
    }

    return Scb->ScbType.Data.HistoryBuffer + NextIndex;
}
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCopyReadC)
#pragma alloc_text(PAGE, NtfsCompressedCopyRead)
#pragma alloc_text(PAGE, NtfsCopyWriteC)
#pragma alloc_text(PAGE, NtfsCompressedCopyWrite)
#pragma alloc_text(PAGE, NtfsAddToCompressedMdlChain)
#pragma alloc_text(PAGE, NtfsSetMdlBcbOwners)
#pragma alloc_text(PAGE, NtfsSynchronizeCompressedIo)
#pragma alloc_text(PAGE, NtfsSynchronizeUncompressedIo)
#pragma alloc_text(PAGE, NtfsAcquireCompressionSync)
#pragma alloc_text(PAGE, NtfsReleaseCompressionSync)
#endif

#ifdef NTFS_RWCMP_TRACE
ULONG NtfsCompressionTrace = 0;
#endif


BOOLEAN
NtfsCopyReadC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               the data in the cache.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    CompressedDataInfoLength - Supplies the size of the info buffer in bytes.

    DeviceObject - Standard Fast I/O Device object input.

Return Value:

    FALSE - if the data was not delivered for any reason

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LONGLONG LocalOffset;
    PFAST_IO_DISPATCH FastIoDispatch;
    FILE_COMPRESSION_INFORMATION CompressionInformation;
    ULONG CompressionUnitSize, ChunkSize;
    BOOLEAN Status = TRUE;
    BOOLEAN DoingIoAtEof = FALSE;

    PAGED_CODE();

    //
    //  You cannot have both a buffer to copy into and an MdlChain.
    //

    ASSERT((Buffer == NULL) || (MdlChain == NULL));

    //
    //  Get out immediately if COW is not supported.
    //

    if (!NtfsEnableCompressedIO) { return FALSE; }

    //
    //  Assume success.
    //

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = Length;
    CompressedDataInfo->NumberOfChunks = 0;

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Get a real pointer to the common fcb header
        //

        Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

#ifdef NTFS_RWCMP_TRACE
        if (NtfsCompressionTrace && IsSyscache(Header)) {
            DbgPrint("NtfsCopyReadC: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
        }
#endif

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Make our best guess on whether we need the file exclusive
        //  or shared.  Note that we do not check FileOffset->HighPart
        //  until below.
        //

        Status = ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((Header->FileObjectC == NULL) ||
            (Header->FileObjectC->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            Status = FALSE;
            goto Done;
        }

        //
        //  Get the address of the driver object's Fast I/O dispatch structure.
        //

        FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

        //
        //  Get the compression information for this file and return those fields.
        //

        NtfsFastIoQueryCompressionInfo( FileObject, &CompressionInformation, IoStatus );
        CompressedDataInfo->CompressionFormatAndEngine = CompressionInformation.CompressionFormat;
        CompressedDataInfo->CompressionUnitShift = CompressionInformation.CompressionUnitShift;
        CompressionUnitSize = 1 << CompressionInformation.CompressionUnitShift;
        CompressedDataInfo->ChunkShift = CompressionInformation.ChunkShift;
        CompressedDataInfo->ClusterShift = CompressionInformation.ClusterShift;
        CompressedDataInfo->Reserved = 0;
        ChunkSize = 1 << CompressionInformation.ChunkShift;

        //
        //  If we either got an error in the call above, or the file size is less than
        //  one chunk, then return an error.  (Could be an Ntfs resident attribute.)

        if (!NT_SUCCESS(IoStatus->Status) || (Header->FileSize.QuadPart < ChunkSize)) {
            Status = FALSE;
            goto Done;
        }

        ASSERT((FileOffset->LowPart & (ChunkSize - 1)) == 0);

        //
        //  If there is a normal cache section, flush that first, flushing integral
        //  compression units so we don't write them twice.
        //

        if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

            LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);

            CcFlushCache( FileObject->SectionObjectPointer,
                          (PLARGE_INTEGER)&LocalOffset,
                          (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + ChunkSize - 1) & ~(ChunkSize - 1),
                          NULL );
        }

        //
        //  Now synchronize with the FsRtl Header
        //

        ExAcquireFastMutex( Header->FastMutex );

        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.
        //

        LocalOffset = FileOffset->QuadPart + (LONGLONG)Length;
        if (LocalOffset > Header->ValidDataLength.QuadPart) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.
            //

            DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                           NtfsWaitForIoAtEof( Header, FileOffset, Length );

            //
            //  Set the Flag if we are in fact beyond ValidDataLength.
            //

            if (DoingIoAtEof) {
                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

            } else {

                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
            }
        }

        ExReleaseFastMutex( Header->FastMutex );

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        TRUE,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        DeviceObject )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                Status = FALSE;
                goto Done;
            }
        }

        //
        //  Check for read past file size.
        //

        IoStatus->Information = Length;
        if ( LocalOffset > Header->FileSize.QuadPart ) {

            if (FileOffset->QuadPart >= Header->FileSize.QuadPart) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;
                goto Done;
            }

            IoStatus->Information =
            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );

        if (NT_SUCCESS(IoStatus->Status)) {

            //
            //  Don't do the sychronize flush if we currently own Eof.  The recursive
            //  flush may try to reacquire.
            //

            if (DoingIoAtEof &&
                (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                IoStatus->Status = STATUS_FILE_LOCK_CONFLICT;

            } else {

                IoStatus->Status = NtfsCompressedCopyRead( FileObject,
                                                           FileOffset,
                                                           Length,
                                                           Buffer,
                                                           MdlChain,
                                                           CompressedDataInfo,
                                                           CompressedDataInfoLength,
                                                           DeviceObject,
                                                           Header,
                                                           CompressionUnitSize,
                                                           ChunkSize );
            }
        }

        Status = (BOOLEAN)NT_SUCCESS(IoStatus->Status);


        IoSetTopLevelIrp( NULL );
        
        Done: NOTHING;

        if (DoingIoAtEof) {
            ExAcquireFastMutex( Header->FastMutex );
            NtfsFinishIoAtEof( Header );
            ExReleaseFastMutex( Header->FastMutex );
        }

        //
        //  For the Mdl case, we must keep the resource unless
        //  we are past the end of the file or had nothing to write.
        //

        if ((MdlChain == NULL) || !Status || (*MdlChain == NULL)) {
            ExReleaseResourceLite( Header->PagingIoResource );
        }

        FsRtlExitFileSystem();
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("Return Status = %08lx\n", Status);
    }
#endif

    return Status;
}


NTSTATUS
NtfsCompressedCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This is a common routine for doing compressed copy or Mdl reads in
    the compressed stream.  It is called both by the FastIo entry for
    this function, as well as by read.c if a compressed read Irp is received.
    The caller must be correctly synchronized for the stream.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               the data in the cache.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    CompressedDataInfoLength - Supplies the size of the info buffer in bytes.

    DeviceObject - Standard Fast I/O Device object input.

    Header - Pointer to FsRtl header for file (also is our Scb)

    CompressionUnitSize - Size of Compression Unit in bytes.

    ChunkSize - ChunkSize in bytes.

Return Value:

    NTSTATUS for operation.  If STATUS_NOT_MAPPED_USER_DATA, then the caller
    should map the normal uncompressed data stream and call back.

--*/

{
    PFILE_OBJECT LocalFileObject;
    PULONG NextReturnChunkSize;
    PUCHAR CompressedBuffer, EndOfCompressedBuffer, ChunkBuffer, StartOfCompressionUnit;
    LONGLONG LocalOffset;
    ULONG CuCompressedSize;
    PVOID MdlBuffer;
    ULONG MdlLength;
    ULONG PinFlags;
    BOOLEAN IsCompressed;
    BOOLEAN LastCompressionUnit;
    NTSTATUS Status = STATUS_SUCCESS;
    PCOMPRESSION_SYNC CompressionSync = NULL;
    PBCB Bcb = NULL;
    PBCB UncompressedBcb = NULL;

    ULONG ClusterSize = ((PSCB)Header)->Vcb->BytesPerCluster;

#ifdef NTFS_RWC_DEBUG
    PRWC_HISTORY_ENTRY ReadHistoryBuffer;
#endif
    
    UNREFERENCED_PARAMETER( CompressedDataInfoLength );
    UNREFERENCED_PARAMETER( DeviceObject );

    ASSERT(CompressedDataInfoLength >= (sizeof(COMPRESSED_DATA_INFO) +
                                        (((Length >> CompressedDataInfo->ChunkShift) - 1) *
                                          sizeof(ULONG))));
    ASSERT((FileOffset->QuadPart & (ChunkSize - 1)) == 0);
    ASSERT((((FileOffset->QuadPart + Length) & (ChunkSize - 1)) == 0) ||
           ((FileOffset->QuadPart + Length) == Header->FileSize.QuadPart));
    ASSERT((MdlChain == NULL) || (*MdlChain == NULL));

    // 
    //  if we start after vdl we will never pin the compressed buffer 
    // 

    ASSERT( FileOffset->QuadPart < Header->ValidDataLength.QuadPart );

    //
    //  Return an error if the file is not compressed.
    //

    if (((PSCB)Header)->CompressionUnit == 0) {
        return STATUS_UNSUPPORTED_COMPRESSION;
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("  CompressedCopyRead: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
    }
#endif

#ifdef NTFS_RWC_DEBUG
    if ((FileOffset->QuadPart < NtfsRWCHighThreshold) &&
        (FileOffset->QuadPart + Length > NtfsRWCLowThreshold)) {

        PRWC_HISTORY_ENTRY NextBuffer;

        ReadHistoryBuffer = 
        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

        NextBuffer->Operation = StartOfRead;
        NextBuffer->Information = Header->ValidDataLength.LowPart;
        NextBuffer->FileOffset = (ULONG) FileOffset->QuadPart;
        NextBuffer->Length = (ULONG) Length;
    }
#endif

    try {

        //
        //  Get ready to loop through all of the compression units.
        //

        LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);
        Length = (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + ChunkSize - 1) & ~(ChunkSize - 1);

        NextReturnChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

        //
        //  Loop through desired compression units
        //

        while (TRUE) {

            //
            //  Free any Bcb from previous loop.
            //

            if (Bcb != NULL) {

                ASSERT( (UncompressedBcb == NULL) ||
                        (UncompressedBcb == Bcb ) );

                CcUnpinData( Bcb );
                UncompressedBcb = Bcb = NULL;

            } else if (UncompressedBcb != NULL) {

                CcUnpinData( UncompressedBcb );
                UncompressedBcb = NULL;
            }

            //
            //  If there is an uncompressed stream, then we have to synchronize with that.
            //

            if (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL) {

                Status = NtfsSynchronizeCompressedIo( (PSCB)Header,
                                                      &LocalOffset,
                                                      Length,
                                                      FALSE,
                                                      &CompressionSync );

                if (!NT_SUCCESS(Status)) {
                    ASSERT( Status == STATUS_USER_MAPPED_FILE );
                    leave;
                }
            }

            //
            //  Loop to get the correct data pinned.
            //
            //  The synchronize call above has guaranteed that no data can written through
            //  the uncompressed section (barring the loop back below), and it has also flushed
            //  any dirty data that may have already been in the uncompressed section.  Here we
            //  are basically trying to figure out how much data we should pin and then get it
            //  pinned.
            //
            //  We use the following steps:
            //
            //      1.  Query the current compressed size (derived from the allocation state).
            //          If the size is neither 0-allocated nor fully allocated, then we will
            //          simply pin the data in the compressed section - this is the normal case.
            //      2.  However, the first time we see one of these special sizes, we do not
            //          know if could be the case that there is dirty data sitting in the compressed
            //          cache.  Therefore, we set up to pin just one page with PIN_IF_BCB.  This
            //          will only pin something if there is aleady a Bcb for it.
            //      3.  Now we determine if we think the data is compressed or not, counting the
            //          special cases from the previous point as compressed.  This determines
            //          which section to read from.
            //      4.  Now, if we think there is/may be data to pin, we call Cc.  If he comes
            //          back with no data (only possible if we set PIN_IF_BCB), then we know we
            //          can loop back to the top and trust the allocation state on disk now.
            //          (That is because we flushed the uncompressed stream and found no Bcb in
            //          the compressed stream.)  On the second time through we should correctly
            //          handle the 0-allocated or fully-allocated cases.  (The careful reader
            //          will note that if there is no uncompressed section, then indeed writers
            //          to the compressed section could be going on in parallel with this read,
            //          and we could handle the 0- or fully-allocated case while there is
            //          new compressed data in the cache.  However on the second loop we know
            //          there really was all 0's in the file at one point which it is correct
            //          to return, and it is always correct to go to the uncompressed cache
            //          if we still see fully-allocated.  More importantly, we have an
            //          unsynchronized reader and writer, and the reader's result is therefore
            //          nondeterministic anyway.
            //

            PinFlags = PIN_WAIT;

            do {

                //
                //  If we are beyond ValidDataLength, then the CompressedSize is 0!
                //

                if (LocalOffset >= Header->ValidDataLength.QuadPart) {

                    CuCompressedSize = 0;
                    ClearFlag( PinFlags, PIN_IF_BCB );

                //
                //  Otherwise query the compressed size.
                //

                } else {

                    NtfsFastIoQueryCompressedSize( FileObject,
                                                   (PLARGE_INTEGER)&LocalOffset,
                                                   &CuCompressedSize );

                    //
                    //  If it looks uncompressed, we are probably trying to read data
                    //  that has not been written out yet.  Also if the space is not yet
                    //  allocated, then we also need to try to hit the data in the compressed
                    //  cache.
                    //

                    if (((CuCompressedSize == CompressionUnitSize) || (CuCompressedSize == 0)) &&
                        !FlagOn(PinFlags, PIN_IF_BCB)) {

                        CuCompressedSize = 0x1000;
                        SetFlag( PinFlags, PIN_IF_BCB );

                    //
                    //  Make sure we really read the data if this is the second time through.
                    //

                    } else {

                        //
                        //  If the range is dirty and there is no Bcb in the compressed stream
                        //  then always go to the uncompressed stream.
                        //

                        if (FlagOn( PinFlags, PIN_IF_BCB ) &&
                            (CuCompressedSize != CompressionUnitSize)) {

                            LONGLONG ClusterCount = 1 << ((PSCB) Header)->CompressionUnitShift;

                            if (NtfsCheckForReservedClusters( (PSCB) Header,
                                                              LlClustersFromBytesTruncate( ((PSCB) Header)->Vcb, LocalOffset ),
                                                              &ClusterCount )) {

                                CuCompressedSize = CompressionUnitSize;
                            }
                        }

                        ClearFlag( PinFlags, PIN_IF_BCB );
                    }
                }

                ASSERT( CuCompressedSize <= CompressionUnitSize );
                IsCompressed = (BOOLEAN)((CuCompressedSize != CompressionUnitSize) &&
                                         (CompressedDataInfo->CompressionFormatAndEngine != 0));

                //
                //  Figure out which FileObject to use.
                //

                LocalFileObject = Header->FileObjectC;
                if (!IsCompressed) {
                    LocalFileObject = ((PSCB)Header)->FileObject;
                    if (LocalFileObject == NULL) {
                        Status = STATUS_NOT_MAPPED_DATA;
                        goto Done;
                    }
                }

                //
                //  If the compression unit is not (yet) allocated, then there is
                //  no need to synchronize - we will return 0-lengths for chunk sizes.
                //

                if (CuCompressedSize != 0) {

                    //
                    //  Map the compression unit in the compressed or uncompressed
                    //  stream.
                    //

                    CcPinRead( LocalFileObject,
                               (PLARGE_INTEGER)&LocalOffset,
                               CuCompressedSize,
                               PinFlags,
                               &Bcb,
                               &CompressedBuffer );

                    //
                     //  If there is no Bcb it means we were assuming the data was in
                    //  the compressed buffer and only wanted to wait if it was
                    //  present.  Well it isn't there so force ourselved to go
                    //  back and look in the uncompressed section.
                    //

                    if (Bcb == NULL) {

                        ASSERT( FlagOn( PinFlags, PIN_IF_BCB ));
                        continue;
                    }

                    //
                    //  Now that the data is pinned (we are synchronized with the
                    //  CompressionUnit), we have to get the size again since it could
                    //  have changed.
                    //

                    if (IsCompressed) {

                        //
                        //  Now, we know the data where we are about to read is compressed,
                        //  but we cannot really tell for sure how big it is since there may
                        //  be dirty data in the cache.
                        //
                        //  We will say the size is (CompressionUnitSize - ClusterSize)
                        //  which is the largest possible compressed size, and we will normally
                        //  just hit on the existing dirty Bcb and/or resident pages anyway.
                        //  (If we do not, then we will just fault those pages in one at a
                        //  time anyway.  This looks bad having to do this twice, but it
                        //  is only until the dirty data finally gets flushed out.)  This also
                        //  means we may walk off the range we pinned in a read-only mode, but
                        //  that should be benign.
                        //
                        //  Of course in the main line case, we figured out exactly how much
                        //  data to read in and we did so when we pinned it above.
                        //

                        CuCompressedSize = CompressionUnitSize - ClusterSize;

                    //
                    //  Otherwise remember to release this Bcb.
                    //

                    } else {

                        UncompressedBcb = Bcb;
                    }
                }

            } while ((Bcb == NULL) && (CuCompressedSize != 0));

            //
            //  Now that we are synchronized with the buffer, see if someone snuck
            //  in behind us and created the noncached stream since we last checked
            //  for that stream.  If so we have to loop back to synchronize with the
            //  compressed stream again.
            //

            if ((CompressionSync == NULL) &&
                (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                continue;
            }

            EndOfCompressedBuffer = Add2Ptr( CompressedBuffer, CuCompressedSize );
            StartOfCompressionUnit = CompressedBuffer;

            //
            //  Remember if we may go past the end of the file.
            //

            LastCompressionUnit = FALSE;

            if (LocalOffset + CuCompressedSize > Header->FileSize.QuadPart) {

                LastCompressionUnit = TRUE;
            }

            //
            //  Now loop through desired chunks
            //

            MdlLength = 0;

            do {

                //
                //  Assume current chunk does not compress, else get current
                //  chunk size.
                //

                if (IsCompressed) {

                    if (CuCompressedSize != 0) {

                        PUCHAR PrevCompressedBuffer;

                        //
                        //  We have to do a careful check to see if the return value is
                        //  greater than or equal to the chunk size AND the data is in fact
                        //  compressed.  We don't have anyway to pass this data back to
                        //  the server so he can interpret it correctly.
                        //

                        PrevCompressedBuffer = CompressedBuffer;

                        Status = RtlDescribeChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                   &CompressedBuffer,
                                                   EndOfCompressedBuffer,
                                                   &ChunkBuffer,
                                                   NextReturnChunkSize );

                        if (!NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES)) {
                            ExRaiseStatus(Status);
                        }

                        //
                        //  If the size is greater or equal to the chunk size AND the data is compressed
                        //  then force this to the uncompressed path.  Note that the Rtl package has
                        //  been changed so that this case shouldn't happen on new disks but it is
                        //  possible that it could exist on exiting disks.
                        //

                        if ((*NextReturnChunkSize >= ChunkSize) &&
                            (PrevCompressedBuffer == ChunkBuffer)) {

                            //
                            //  Raise an error code that causes the server to reissue in
                            //  the uncompressed path.
                            //

                            ExRaiseStatus( STATUS_UNSUPPORTED_COMPRESSION );
                        }

                        //
                        //  Another unusual case is where the compressed data extends past the containing
                        //  file size.  We don't have anyway to prevent the next page from being zeroed.
                        //  Ask the server to go the uncompressed path.
                        //

                        if (LastCompressionUnit) {

                            LONGLONG EndOfPage;

                            EndOfPage = LocalOffset + PtrOffset( StartOfCompressionUnit, CompressedBuffer ) + PAGE_SIZE - 1;
                            ((PLARGE_INTEGER) &EndOfPage)->LowPart &= ~(PAGE_SIZE - 1);
                            
                            if (EndOfPage > Header->FileSize.QuadPart) {

                                //
                                //  Raise an error code that causes the server to reissue in
                                //  the uncompressed path.
                                //
    
                                ExRaiseStatus( STATUS_UNSUPPORTED_COMPRESSION );
                            }
                        }

                        ASSERT( *NextReturnChunkSize <= ChunkSize );

                    //
                    //  If the entire CompressionUnit is empty, do this.
                    //

                    } else {
                        *NextReturnChunkSize = 0;
#ifdef NTFS_RWC_DEBUG
                        if ((LocalOffset < NtfsRWCHighThreshold) &&
                            (LocalOffset + CompressionUnitSize > NtfsRWCLowThreshold)) {

                            PRWC_HISTORY_ENTRY NextBuffer;

                            NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                            NextBuffer->Operation = ReadZeroes;
                            NextBuffer->Information = 0;
                            NextBuffer->FileOffset = (ULONG) LocalOffset;
                            NextBuffer->Length = 0;
                        }
#endif
                    }

                //
                //  If the file is not compressed, we have to fill in
                //  the appropriate chunk size and buffer, and advance
                //  CompressedBuffer.
                //

                } else {
#ifdef NTFS_RWC_DEBUG
                    if ((LocalOffset < NtfsRWCHighThreshold) &&
                        (LocalOffset + ChunkSize > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                        NextBuffer->Operation = ReadUncompressed;
                        NextBuffer->Information = (LocalFileObject == ((PSCB)Header)->FileObject);
                        NextBuffer->FileOffset = (ULONG) LocalOffset;
                        NextBuffer->Length = 0;
                    }
#endif
                    *NextReturnChunkSize = ChunkSize;
                    ChunkBuffer = CompressedBuffer;
                    CompressedBuffer = Add2Ptr( CompressedBuffer, ChunkSize );
                }
                Status = STATUS_SUCCESS;

                //
                //  We may not have reached the first chunk yet.
                //

                if (LocalOffset >= FileOffset->QuadPart) {

                    if (MdlChain != NULL) {

                        //
                        //  If we have not started remembering an Mdl buffer,
                        //  then do so now.
                        //

                        if (MdlLength == 0) {

                            MdlBuffer = ChunkBuffer;

                        //
                        //  Otherwise we just have to increase the length
                        //  and check for an uncompressed chunk, because that
                        //  forces us to emit the previous Mdl since we do
                        //  not transmit the chunk header in this case.
                        //

                        } else {

                            //
                            //  In the rare case that we hit an individual chunk
                            //  that did not compress or is all zeros, we have to
                            //  emit what we had (which captures the Bcb pointer),
                            //  and start a new Mdl buffer.
                            //

                            if ((*NextReturnChunkSize == ChunkSize) || (*NextReturnChunkSize == 0)) {

                                NtfsAddToCompressedMdlChain( MdlChain,
                                                             MdlBuffer,
                                                             MdlLength,
                                                             Header->PagingIoResource,
                                                             Bcb,
                                                             IoReadAccess,
                                                             IsCompressed );
                                Bcb = NULL;
                                MdlBuffer = ChunkBuffer;
                                MdlLength = 0;
                            }
                        }

                        MdlLength += *NextReturnChunkSize;

                    //
                    //  Else copy next chunk (compressed or not).
                    //

                    } else {

                        //
                        //  Copy next chunk (compressed or not).
                        //

                        RtlCopyBytes( Buffer,
                                      ChunkBuffer,
                                      (IsCompressed || (Length >= *NextReturnChunkSize)) ?
                                        *NextReturnChunkSize : Length );

                        //
                        //  Advance output buffer by bytes copied.
                        //

                        Buffer = (PCHAR)Buffer + *NextReturnChunkSize;
                    }

                    NextReturnChunkSize += 1;
                    CompressedDataInfo->NumberOfChunks += 1;
                }

                //
                //  Reduce length by chunk copied, and check if we are done.
                //

                if (Length > ChunkSize) {
                    Length -= ChunkSize;
                } else {
                    goto Done;
                }

                LocalOffset += ChunkSize;

            } while ((LocalOffset & (CompressionUnitSize - 1)) != 0);


            //
            //  If this is an Mdl call, then it is time to add to the MdlChain
            //  before moving to the next compression unit.
            //

            if (MdlLength != 0) {

                NtfsAddToCompressedMdlChain( MdlChain,
                                             MdlBuffer,
                                             MdlLength,
                                             Header->PagingIoResource,
                                             Bcb,
                                             IoReadAccess,
                                             IsCompressed );
                Bcb = NULL;
                MdlLength = 0;
            }
        }

    Done:

        FileObject->Flags |= FO_FILE_FAST_IO_READ;

        if (NT_SUCCESS(Status) && (MdlLength != 0)) {
            NtfsAddToCompressedMdlChain( MdlChain,
                                         MdlBuffer,
                                         MdlLength,
                                         Header->PagingIoResource,
                                         Bcb,
                                         IoReadAccess,
                                         IsCompressed );
            Bcb = NULL;
        }

    } except( FsRtlIsNtstatusExpected(Status = GetExceptionCode())
                                    ? EXCEPTION_EXECUTE_HANDLER
                                    : EXCEPTION_CONTINUE_SEARCH ) {

        NOTHING;
    }

    //
    //  Unpin any Bcbs we still have.
    //

    if (Bcb != NULL) {
        CcUnpinData( Bcb );

    } else if (UncompressedBcb != NULL) {
        CcUnpinData( UncompressedBcb );
    }

    if (CompressionSync != NULL) {
        NtfsReleaseCompressionSync( CompressionSync );
    }

    //
    //  Perform Mdl-specific processing.
    //

    if (MdlChain != NULL) {

        //
        //  On error, cleanup any MdlChain we built up
        //

        if (!NT_SUCCESS(Status)) {

            NtfsCleanupCompressedMdlChain( *MdlChain, TRUE );
            *MdlChain = NULL;

        //
        //  Change owner Id for the Scb and Bcbs we are holding.
        //

        } else if (*MdlChain != NULL) {

            NtfsSetMdlBcbOwners( *MdlChain );
            ExSetResourceOwnerPointer( Header->PagingIoResource, (PVOID)((PCHAR)*MdlChain + 3) );
        }
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {

        ULONG ci;

        if (NT_SUCCESS(Status)) {
            DbgPrint("  Chunks:");
            for (ci = 0; ci < CompressedDataInfo->NumberOfChunks; ci++) {
                DbgPrint("  %lx", CompressedDataInfo->CompressedChunkSizes[ci]);
            }
            DbgPrint("\n");
        }
        DbgPrint("  Return Status = %08lx\n", Status);
    }
#endif

#ifdef NTFS_RWC_DEBUG
    if ((Status == STATUS_SUCCESS) &&
        (FileOffset->QuadPart < NtfsRWCHighThreshold) &&
        (FileOffset->QuadPart + Length > NtfsRWCLowThreshold)) {

        PRWC_HISTORY_ENTRY NextBuffer;

        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

        NextBuffer->Operation = EndOfRead;
        NextBuffer->Information = (ULONG) ReadHistoryBuffer;
        NextBuffer->FileOffset = 0;
        NextBuffer->Length = 0;

        if (ReadHistoryBuffer != NULL) {
            SetFlag( ReadHistoryBuffer->Operation, 0x80000000 );
        }
    }
#endif

    return Status;
}


BOOLEAN
NtfsMdlReadCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine frees resources and the Mdl Chain after a compressed read.

Arguments:

    FileObject - pointer to the file object for the request.

    MdlChain - as returned from compressed copy read.

    DeviceObject - As required for a fast I/O routine.

Return Value:

    TRUE - if fast path succeeded

    FALSE -  if an Irp is required

--*/

{
    PERESOURCE ResourceToRelease;

    if (MdlChain != NULL) {

        ResourceToRelease = *(PERESOURCE *)Add2Ptr( MdlChain, MdlChain->Size + sizeof( PBCB ));
    }

    NtfsCleanupCompressedMdlChain( MdlChain, FALSE );

    //
    //  If the server tried to read past the end of the file in the
    //  fast path then he calls us with NULL for the MDL.  We already
    //  released the thread in that case.
    //

    if (MdlChain != NULL) {

        ExReleaseResourceForThread( ResourceToRelease, (ERESOURCE_THREAD)((PCHAR)MdlChain + 3) );
    }

    return TRUE;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( FileObject );
}


BOOLEAN
NtfsCopyWriteC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               where the data may be written in the cache.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    CompressedDataInfoLength - Supplies the size of the info buffer in bytes.

Return Value:

    FALSE - if there is an error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    FILE_COMPRESSION_INFORMATION CompressionInformation;
    ULONG CompressionUnitSize, ChunkSize;
    ULONG EngineMatches;
    LARGE_INTEGER NewFileSize;
    LARGE_INTEGER OldFileSize;
    LONGLONG LocalOffset;
    PFAST_IO_DISPATCH FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;
    ULONG DoingIoAtEof = FALSE;
    BOOLEAN Status = TRUE;

    UNREFERENCED_PARAMETER( CompressedDataInfoLength );

    PAGED_CODE();

    //
    //  You cannot have both a buffer to copy into and an MdlChain.
    //

    ASSERT((Buffer == NULL) || (MdlChain == NULL));

    //
    //  Get out immediately if COW is not supported.
    //

    if (!NtfsEnableCompressedIO) { return FALSE; }

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("NtfsCopyWriteC: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
    }
#endif

    //
    //  See if it is ok to handle this in the fast path.
    //

    if (CcCanIWrite( FileObject, Length, TRUE, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Calculate the compression unit and chunk sizes.
            //

            CompressionUnitSize = 1 << CompressedDataInfo->CompressionUnitShift;
            ChunkSize = 1 << CompressedDataInfo->ChunkShift;

            //
            //  If there is a normal cache section, flush that first, flushing integral
            //  compression units so we don't write them twice.
            //
            //

            if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

                ULONG FlushLength;

                ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                CompressionUnitSize = ((PSCB) Header)->CompressionUnit;

                LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);

                FlushLength = (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + CompressionUnitSize - 1) &
                                                ~(CompressionUnitSize - 1);

                CcFlushCache( FileObject->SectionObjectPointer,
                              (PLARGE_INTEGER)&LocalOffset,
                              FlushLength,
                              NULL );
                CcPurgeCacheSection( FileObject->SectionObjectPointer,
                                     (PLARGE_INTEGER)&LocalOffset,
                                     FlushLength,
                                     FALSE );
                ExReleaseResourceLite( Header->PagingIoResource );
            }

            NewFileSize.QuadPart = FileOffset->QuadPart + Length;

            //
            //  Prevent truncates by acquiring paging I/O
            //

            ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

            //
            //  Get the compression information for this file and return those fields.
            //

            NtfsFastIoQueryCompressionInfo( FileObject, &CompressionInformation, IoStatus );
            CompressionUnitSize = ((PSCB) Header)->CompressionUnit;

            //
            //  See if the engine matches, so we can pass that on to the
            //  compressed write routine.
            //

            EngineMatches =
              ((CompressedDataInfo->CompressionFormatAndEngine == CompressionInformation.CompressionFormat) &&
               (CompressedDataInfo->ChunkShift == CompressionInformation.ChunkShift));

            //
            //  If we either got an error in the call above, or the file size is less than
            //  one chunk, then return an error.  (Could be an Ntfs resident attribute.)
            //

            if (!NT_SUCCESS(IoStatus->Status) || (Header->FileSize.QuadPart < ChunkSize)) {
                goto ErrOut;
            }

            //
            //  Now synchronize with the FsRtl Header
            //

            ExAcquireFastMutex( Header->FastMutex );

            //
            //  Now see if we will change FileSize.  We have to do it now
            //  so that our reads are not nooped.  Note we do not allow
            //  FileOffset to be WRITE_TO_EOF.
            //

            ASSERT((FileOffset->LowPart & (ChunkSize - 1)) == 0);

            if (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart) {

                //
                //  We can change FileSize and ValidDataLength if either, no one
                //  else is now, or we are still extending after waiting.
                //

                DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                               NtfsWaitForIoAtEof( Header, FileOffset, Length );

                //
                //  Set the Flag if we are changing FileSize or ValidDataLength,
                //  and save current values.
                //

                if (DoingIoAtEof) {

                    SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

                    //
                    //  Now calculate the new FileSize and see if we wrapped the
                    //  32-bit boundary.
                    //

                    NewFileSize.QuadPart = FileOffset->QuadPart + Length;

                    //
                    //  Update Filesize now so that we do not truncate reads.
                    //

                    OldFileSize.QuadPart = Header->FileSize.QuadPart;
                    if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                        //
                        //  If we are beyond AllocationSize, go to ErrOut
                        //

                        if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                            ExReleaseFastMutex( Header->FastMutex );
                            goto ErrOut;
                        } else {
                            Header->FileSize.QuadPart = NewFileSize.QuadPart;
                        }
                    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                } else {

                    ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                }
            }

            ExReleaseFastMutex( Header->FastMutex );

            //
            //  Now that the File is acquired shared, we can safely test if it
            //  is really cached and if we can do fast i/o and if not, then
            //  release the fcb and return.
            //
            //  Note, we do not want to call CcZeroData here,
            //  but rather defer zeroing to the file system, due to
            //  the need for exclusive resource acquisition.  Therefore
            //  we get out if we are beyond ValidDataLength.
            //

            if ((Header->FileObjectC == NULL) ||
                (Header->FileObjectC->PrivateCacheMap == NULL) ||
                (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                (FileOffset->QuadPart > Header->ValidDataLength.QuadPart)) {

                goto ErrOut;
            }

            //
            //  Check if fast I/O is questionable and if so then go ask
            //  the file system the answer
            //

            if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

                //
                //  All file system then set "Is Questionable" had better
                //  support fast I/O
                //

                ASSERT(FastIoDispatch != NULL);
                ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                //
                //  Call the file system to check for fast I/O.  If the
                //  answer is anything other than GoForIt then we cannot
                //  take the fast I/O path.
                //


                if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                            FileOffset,
                                                            Length,
                                                            TRUE,
                                                            LockKey,
                                                            FALSE, // write operation
                                                            IoStatus,
                                                            DeviceObject )) {

                    //
                    //  Fast I/O is not possible so cleanup and return.
                    //

                    goto ErrOut;
                }
            }

            //
            //  Update both caches with EOF.
            //

            if (DoingIoAtEof) {
                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Header->AllocationSize,
                                       (PSCB)Header );
            }

            //
            //  We can do fast i/o so call the cc routine to do the work
            //  and then release the fcb when we've done.  If for whatever
            //  reason the copy write fails, then return FALSE to our
            //  caller.
            //
            //  Also mark this as the top level "Irp" so that lower file
            //  system levels will not attempt a pop-up
            //

            IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );

            ASSERT(CompressedDataInfoLength >= (sizeof(COMPRESSED_DATA_INFO) +
                                                (((Length >> CompressedDataInfo->ChunkShift) - 1) *
                                                  sizeof(ULONG))));

            if (NT_SUCCESS(IoStatus->Status)) {

                if (DoingIoAtEof &&
                    (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                    IoStatus->Status = STATUS_FILE_LOCK_CONFLICT;

                } else {

                    IoStatus->Status = NtfsCompressedCopyWrite( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                Buffer,
                                                                MdlChain,
                                                                CompressedDataInfo,
                                                                DeviceObject,
                                                                Header,
                                                                CompressionUnitSize,
                                                                ChunkSize,
                                                                EngineMatches );
                }
            }

            IoSetTopLevelIrp( NULL );
            
            Status = (BOOLEAN)NT_SUCCESS(IoStatus->Status);

            //
            //  If we succeeded, see if we have to update FileSize ValidDataLength.
            //

            if (Status) {

                //
                //  Set this handle as having modified the file.
                //

                FileObject->Flags |= FO_FILE_MODIFIED;

                if (DoingIoAtEof) {

                    CC_FILE_SIZES CcFileSizes;

                    ExAcquireFastMutex( Header->FastMutex );
                    FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    Header->ValidDataLength = NewFileSize;
                    CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
                    NtfsVerifySizes( Header );
                    NtfsFinishIoAtEof( Header );

                    //
                    //  Update the normal cache with ValidDataLength.
                    //

                    if (((PSCB)Header)->FileObject != NULL) {
                        CcSetFileSizes( ((PSCB)Header)->FileObject, &CcFileSizes );
                    }
                    ExReleaseFastMutex( Header->FastMutex );
                }

                goto Done1;
            }

        ErrOut: NOTHING;

            Status = FALSE;
            if (DoingIoAtEof) {
                ExAcquireFastMutex( Header->FastMutex );
                if (CcIsFileCached(FileObject)) {
                    *CcGetFileSizePointer(FileObject) = OldFileSize;
                }
                if (Header->FileObjectC != NULL) {
                    *CcGetFileSizePointer(Header->FileObjectC) = OldFileSize;
                }
                Header->FileSize = OldFileSize;
                NtfsFinishIoAtEof( Header );
                ExReleaseFastMutex( Header->FastMutex );
            }

        Done1: NOTHING;

            //
            //  For the Mdl case, we must keep the resource.
            //

            if ((MdlChain == NULL) || !Status || (*MdlChain == NULL)) {
                ExReleaseResourceLite( Header->PagingIoResource );
            }

            FsRtlExitFileSystem();
        }

    } else {

        //
        // We could not do the I/O now.
        //

        Status = FALSE;
    }


#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("Return Status = %08lx\n", Status);
    }
#endif
    return Status;
}


NTSTATUS
NtfsCompressedCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize,
    IN ULONG EngineMatches
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               where the data may be written in the cache.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    DeviceObject - Standard Fast I/O Device object input.

    Header - Pointer to FsRtl header for file (also is our Scb)

    CompressionUnitSize - Size of Compression Unit in bytes.

    ChunkSize - ChunkSize in bytes.

    EngineMatches - TRUE if the caller has determined that the compressed
                    data format matches the compression engine for the file.

Return Value:

    NTSTATUS for operation.  If STATUS_NOT_MAPPED_USER_DATA, then the caller
    should map the normal uncompressed data stream and call back.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PUCHAR StartOfPin;
    ULONG SizeToPin;

    LONGLONG LocalOffset;
    PULONG NextChunkSize, TempChunkSize;
    PUCHAR ChunkBuffer;
    PUCHAR CacheBuffer;
    PUCHAR EndOfCacheBuffer;

    ULONG SavedLength;
    PUCHAR SavedBuffer;

    ULONG ChunkOfZeros;
    ULONG UncompressedChunkHeader;

    ULONG ChunkSizes[17];
    ULONG i, ChunksSeen;

    ULONG TempUlong;

    PVOID MdlBuffer;
    ULONG MdlLength = 0;

    ULONG ClusterSize = ((PSCB)Header)->Vcb->BytesPerCluster;

    PBCB Bcb = NULL;
    PBCB TempBcb = NULL;
    PCOMPRESSION_SYNC CompressionSync = NULL;

    BOOLEAN FullOverwrite = FALSE;
    BOOLEAN IsCompressed;

    ASSERT((FileOffset->QuadPart & (ChunkSize - 1)) == 0);
    ASSERT((((FileOffset->QuadPart + Length) & (ChunkSize - 1)) == 0) ||
           ((FileOffset->QuadPart + Length) == Header->FileSize.QuadPart));
    ASSERT((MdlChain == NULL) || (*MdlChain == NULL));

    //
    //  Return an error if the file is not compressed.
    //

    if (!EngineMatches || ((PSCB)Header)->CompressionUnit == 0) {
        return STATUS_UNSUPPORTED_COMPRESSION;
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {

        ULONG ci;

        DbgPrint("  CompressedWrite: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
        DbgPrint("  Chunks:");
        for (ci = 0; ci < CompressedDataInfo->NumberOfChunks; ci++) {
            DbgPrint("  %lx", CompressedDataInfo->CompressedChunkSizes[ci]);
        }
        DbgPrint("\n");
    }
#endif

#ifdef NTFS_RWC_DEBUG
    if ((FileOffset->QuadPart < NtfsRWCHighThreshold) &&
        (FileOffset->QuadPart + Length > NtfsRWCLowThreshold)) {

        PRWC_HISTORY_ENTRY NextBuffer;

        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

        NextBuffer->Operation = StartOfWrite;
        NextBuffer->Information = CompressedDataInfo->NumberOfChunks;
        NextBuffer->FileOffset = (ULONG) FileOffset->QuadPart;
        NextBuffer->Length = (ULONG) Length;
    }
#endif
    try {

        //
        //  Get ready to loop through all of the compression units.
        //

        LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);
        Length = (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + ChunkSize - 1) & ~(ChunkSize - 1);

        NextChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

        //
        //  Get the overhead for zero chunks and uncompressed chunks.
        //
        //  ****    temporary solution awaits Rtl routine.
        //

        ASSERT(CompressedDataInfo->CompressionFormatAndEngine == COMPRESSION_FORMAT_LZNT1);
        ChunkOfZeros = 6;
        UncompressedChunkHeader = 2;
        //  Status = RtlGetSpecialChunkSizes( CompressedDataInfo->CompressionFormatAndEngine,
        //                                    &ChunkOfZeros,
        //                                    &UncompressedChunkHeader );
        //
        //  ASSERT(NT_SUCCESS(Status));
        //

        //
        //  Loop through desired compression units
        //

        while (TRUE) {

            //
            //  Free any Bcb from previous pass
            //

            if (Bcb != NULL) {
                CcUnpinData( Bcb );
                Bcb = NULL;
            }

            //
            //  If there is an uncompressed stream, then we have to synchronize with that.
            //

            if (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL) {
                Status = NtfsSynchronizeCompressedIo( (PSCB)Header,
                                                      &LocalOffset,
                                                      Length,
                                                      TRUE,
                                                      &CompressionSync );

                if (!NT_SUCCESS(Status)) {
                    ASSERT( Status == STATUS_USER_MAPPED_FILE );
                    leave;
                }
            }

            //
            //  Determine whether or not this is a full overwrite of a
            //  compression unit.
            //

            FullOverwrite = (LocalOffset >= Header->ValidDataLength.QuadPart)

                                ||

                            ((LocalOffset >= FileOffset->QuadPart) &&
                             (Length >= CompressionUnitSize));


            //
            //  Calculate how much of current compression unit is being
            //  written, uncompressed.
            //

            SavedLength = Length;
            if (SavedLength > CompressionUnitSize) {
                SavedLength = CompressionUnitSize;
            }

            //
            //  If we are not at the start of a compression unit, calculate the
            //  index of the chunk we will be working on, and reduce SavedLength
            //  accordingly.
            //

            i = 0;
            if (LocalOffset < FileOffset->QuadPart) {
                i = (ULONG)(FileOffset->QuadPart - LocalOffset);
                SavedLength -= i;
                i >>= CompressedDataInfo->ChunkShift;
            }

            //
            //  Loop to calculate sum of chunk sizes being written, handling both empty
            //  and uncompressed chunk cases.  We will remember the nonzero size of each
            //  chunk being written so we can merge this info with the sizes of any chunks
            //  not being overwritten below.
            //  Reserve space for a chunk of zeroes for each chunk ahead of the first one
            //  being written.
            //

            SizeToPin = ChunkOfZeros * i;
            TempUlong = SavedLength >> CompressedDataInfo->ChunkShift;
            TempChunkSize = NextChunkSize;
            RtlZeroMemory( ChunkSizes, sizeof( ChunkSizes ));

            while (TempUlong--) {

                ChunkSizes[i] = *TempChunkSize;
                if (*TempChunkSize == 0) {
                    ChunkSizes[i] += ChunkOfZeros;
                    ASSERT(ChunkOfZeros != 0);
                } else if (*TempChunkSize == ChunkSize) {
                    ChunkSizes[i] += UncompressedChunkHeader;
                }
                SizeToPin += ChunkSizes[i];
                TempChunkSize++;
                i += 1;
            }

            //
            //  If this is not a full overwrite, get the current compression unit
            //  size and make sure we pin at least that much.  Don't bother to check
            //  the allocation if this range of the file has not been written yet.
            //

            if (!FullOverwrite && (LocalOffset < ((PSCB)Header)->ValidDataToDisk)) {

                NtfsFastIoQueryCompressedSize( FileObject,
                                               (PLARGE_INTEGER)&LocalOffset,
                                               &TempUlong );

                ASSERT( TempUlong <= CompressionUnitSize );

                if (TempUlong > SizeToPin) {
                    SizeToPin = TempUlong;
                }
            }

            //
            //  At this point we are ready to overwrite data in the compression
            //  unit.  See if the data is really compressed.
            //
            //  If it looks like we are beyond ValidDataToDisk, then assume it is compressed
            //  for now, and we will see for sure later when we get the data pinned.  This
            //  is actually an unsafe test that will occassionally send us down the "wrong"
            //  path.  However, it is always safe to take the uncompressed path, and if we
            //  think the data is compressed, we always check again below.
            //

            IsCompressed = (BOOLEAN)(((SizeToPin <= (CompressionUnitSize - ClusterSize)) ||
                                      (LocalOffset >= ((PSCB)Header)->ValidDataToDisk)) &&
                                     EngineMatches);

            //
            //  Possibly neither the new nor old data for this CompressionUnit is
            //  nonzero, so we must pin something so that we can cause any old allocation
            //  to get deleted.  This code relies on any compression algorithm being
            //  able to express an entire compression unit of 0's in one page or less.
            //

            if (SizeToPin == 0) {
                SizeToPin = PAGE_SIZE;

            } else {

                //
                //  Add a ulong for the null terminator.
                //

                SizeToPin += sizeof( ULONG );
            }

            Status = STATUS_SUCCESS;

            //
            //  Round the pin size to a page boundary.  Then we can tell when we need to pin a larger range.
            //

            SizeToPin = (SizeToPin + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

            //
            //  Save current length in case we have to restart our work in
            //  the uncompressed stream.
            //

            TempChunkSize = NextChunkSize;
            SavedLength = Length;
            SavedBuffer = Buffer;

            if (IsCompressed) {

                //
                //  Map the compression unit in the compressed stream.
                //

                if (FullOverwrite) {

                    //
                    //  If we are overwriting the entire compression unit, then
                    //  call CcPreparePinWrite so that empty pages may be used
                    //  instead of reading the file.  Also force the byte count
                    //  to integral pages, so no one thinks we need to read the
                    //  last page.
                    //

                    CcPreparePinWrite( Header->FileObjectC,
                                       (PLARGE_INTEGER)&LocalOffset,
                                       SizeToPin,
                                       FALSE,
                                       PIN_WAIT | PIN_EXCLUSIVE,
                                       &Bcb,
                                       &CacheBuffer );

                    //
                    //  Now that we are synchronized with the buffer, see if someone snuck
                    //  in behind us and created the noncached stream since we last checked
                    //  for that stream.  If so we have to go back and get correctly synchronized.
                    //

                    if ((CompressionSync == NULL) &&
                        (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                        continue;
                    }

                    //
                    //  If it is a full overwrite, we need to initialize an empty
                    //  buffer.  ****  This is not completely correct, we otherwise
                    //  need a routine to initialize an empty compressed data buffer.
                    //

                    *(PULONG)CacheBuffer = 0;

#ifdef NTFS_RWC_DEBUG
                    if ((LocalOffset < NtfsRWCHighThreshold) &&
                        (LocalOffset + SizeToPin > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        //
                        //  Check for the case where we don't have a full Bcb.
                        //

                        if (SafeNodeType( Bcb ) == CACHE_NTC_OBCB) {

                            PPUBLIC_BCB NextBcb;

                            NextBcb = ((POBCB) Bcb)->Bcbs[0];

                            NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                            NextBuffer->Operation = PartialBcb;
                            NextBuffer->Information = 0;
                            NextBuffer->FileOffset = (ULONG) NextBcb->MappedFileOffset.QuadPart;
                            NextBuffer->Length = NextBcb->MappedLength;

                            ASSERT( NextBuffer->Length <= SizeToPin );

                        } else {

                            PPUBLIC_BCB NextBcb;
                            ASSERT( SafeNodeType( Bcb ) == CACHE_NTC_BCB );

                            NextBcb = (PPUBLIC_BCB) Bcb;

                            ASSERT( LocalOffset + SizeToPin <= NextBcb->MappedFileOffset.QuadPart + NextBcb->MappedLength );
                        }

                        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                        NextBuffer->Operation = FullOverwrite;
                        NextBuffer->Information = 0;
                        NextBuffer->FileOffset = (ULONG) LocalOffset;
                        NextBuffer->Length = (ULONG) SizeToPin;

                    }
#endif

                } else {

                    //
                    //  Read the data from the compressed stream that we will combine
                    //  with the chunks being written.
                    //

                    CcPinRead( Header->FileObjectC,
                               (PLARGE_INTEGER)&LocalOffset,
                               SizeToPin,
                               PIN_WAIT | PIN_EXCLUSIVE,
                               &Bcb,
                               &CacheBuffer );

                    //
                    //  Now that we are synchronized with the buffer, see if someone snuck
                    //  in behind us and created the noncached stream since we last checked
                    //  for that stream.  If so we have to go back and get correctly synchronized.
                    //

                    if ((CompressionSync == NULL) &&
                        (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                        continue;
                    }

                    //
                    //  Now that the data is pinned (we are synchronized with the
                    //  CompressionUnit), we need to recalculate how much should be
                    //  pinned.  We do this by summing up all the sizes of the chunks
                    //  that are being written with the sizes of the existing chunks
                    //  that will remain.
                    //

                    StartOfPin = CacheBuffer;
                    EndOfCacheBuffer = Add2Ptr( CacheBuffer, CompressionUnitSize - ClusterSize );

                    i = 0;

                    //
                    //  Loop through to find all the existing chunks, and remember their
                    //  sizes if they are not being overwritten.  (Remember if we overwrite
                    //  with a chunk of all zeros, it takes nonzero bytes to do it!)
                    //
                    //  This loop completes the formation of an array of chunksizes.  The
                    //  start of the array is guaranteed to be nonzero, and it terminates
                    //  with a chunk size of 0.  Note if fewer chunks are filled in than
                    //  exist in the compression unit, that is ok - we do not need to write
                    //  trailing chunks of 0's.
                    //

                    ChunksSeen = FALSE;
                    while (i < 16) {

                        Status = RtlDescribeChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                   &StartOfPin,
                                                   EndOfCacheBuffer,
                                                   &ChunkBuffer,
                                                   &TempUlong );

                        //
                        //  If there are no more entries, see if we are done, else treat
                        //  it as a chunk of 0's.
                        //

                        if (!NT_SUCCESS(Status)) {

                            ASSERT(Status == STATUS_NO_MORE_ENTRIES);

                            if (ChunksSeen) {
                                break;
                            }

                            TempUlong = ChunkOfZeros;

                        //
                        //  Make sure we enter the length for a chunk of zeroes.
                        //

                        } else if (TempUlong == 0) {

                            TempUlong = ChunkOfZeros;
                        }

                        if (ChunkSizes[i] == 0) {
                            ChunkSizes[i] = TempUlong;
                        } else {
                            ChunksSeen = TRUE;
                        }

                        i += 1;
                    }

                    //
                    //  Now sum up the sizes of the chunks we will write.
                    //

                    i = 0;
                    TempUlong = 0;
                    while (ChunkSizes[i] != 0) {
                        TempUlong += ChunkSizes[i];
                        i += 1;
                    }

                    //
                    //  If the existing data is larger, pin that range.
                    //

                    if (TempUlong < PtrOffset(CacheBuffer, StartOfPin)) {
                        TempUlong = PtrOffset(CacheBuffer, StartOfPin);
                    }

                    IsCompressed = (TempUlong <= (CompressionUnitSize - ClusterSize));

                    //
                    //  We now know if we will really end up with compressed data, so
                    //  get out now stop processing if the data is not compressed.
                    //

                    if (IsCompressed) {

                        TempUlong += sizeof(ULONG);

                        //
                        //  Now we have to repin if we actually need more space.
                        //

                        if (TempUlong > SizeToPin) {

                            SizeToPin = (TempUlong + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

                            TempBcb = Bcb;
                            Bcb = NULL;

                            //
                            //  Read the data from the compressed stream that we will combine
                            //  with the chunks being written.
                            //

                            CcPinRead( Header->FileObjectC,
                                       (PLARGE_INTEGER)&LocalOffset,
                                       SizeToPin,
                                       PIN_WAIT | PIN_EXCLUSIVE,
                                       &Bcb,
                                       &CacheBuffer );

                            CcUnpinData( TempBcb );
                            TempBcb = NULL;
                        }

                        ASSERT( TempUlong <= CompressionUnitSize );

                        //
                        //  Really make the data dirty by physically modifying a byte
                        //  in each page.
                        //

                        TempUlong = 0;

                        while (TempUlong < SizeToPin) {

                            volatile PULONG NextBuffer;

                            NextBuffer = Add2Ptr( CacheBuffer, TempUlong );

                            *NextBuffer = *NextBuffer;
                            TempUlong += PAGE_SIZE;
                        }

#ifdef NTFS_RWC_DEBUG
                        if ((LocalOffset < NtfsRWCHighThreshold) &&
                            (LocalOffset + SizeToPin > NtfsRWCLowThreshold)) {

                            PRWC_HISTORY_ENTRY NextBuffer;

                            NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                            NextBuffer->Operation = SetDirty;
                            NextBuffer->Information = 0;
                            NextBuffer->FileOffset = (ULONG) LocalOffset;
                            NextBuffer->Length = (ULONG) SizeToPin;
                        }
#endif

                        CcSetDirtyPinnedData( Bcb, NULL );
                    }
                }

                EndOfCacheBuffer = Add2Ptr( CacheBuffer, CompressionUnitSize - ClusterSize );

                //
                //  Now loop through desired chunks (if it is still compressed)
                //

                if (IsCompressed) {

                    do {

                        //
                        //  We may not have reached the first chunk yet.
                        //

                        if (LocalOffset >= FileOffset->QuadPart) {

                            //
                            //  Reserve space for the current chunk.
                            //

                            Status = RtlReserveChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                      &CacheBuffer,
                                                      EndOfCacheBuffer,
                                                      &ChunkBuffer,
                                                      *TempChunkSize );

                            if (!NT_SUCCESS(Status)) {
                                break;
                            }

                            //
                            //  If the caller wants an MdlChain, then handle the Mdl
                            //  processing here.
                            //

                            if (MdlChain != NULL) {

                                //
                                //  If we have not started remembering an Mdl buffer,
                                //  then do so now.
                                //

                                if (MdlLength == 0) {

                                    MdlBuffer = ChunkBuffer;

                                //
                                //  Otherwise we just have to increase the length
                                //  and check for an uncompressed chunk, because that
                                //  forces us to emit the previous Mdl since we do
                                //  not transmit the chunk header in this case.
                                //

                                } else {

                                    //
                                    //  In the rare case that we hit an individual chunk
                                    //  that did not compress or is all 0's, we have to
                                    //  emit what we had (which captures the Bcb pointer),
                                    //  and start a new Mdl buffer.
                                    //

                                    if ((*TempChunkSize == ChunkSize) || (*TempChunkSize == 0)) {

                                        NtfsAddToCompressedMdlChain( MdlChain,
                                                                     MdlBuffer,
                                                                     MdlLength,
                                                                     Header->PagingIoResource,
                                                                     Bcb,
                                                                     IoWriteAccess,
                                                                     TRUE );
                                        Bcb = NULL;
                                        MdlBuffer = ChunkBuffer;
                                        MdlLength = 0;
                                    }
                                }

                                MdlLength += *TempChunkSize;

                            //
                            //  Else copy next chunk (compressed or not).
                            //

                            } else {

                                RtlCopyBytes( ChunkBuffer, Buffer, *TempChunkSize );

                                //
                                //  Advance input buffer by bytes copied.
                                //

                                Buffer = (PCHAR)Buffer + *TempChunkSize;
                            }

                            TempChunkSize += 1;

                        //
                        //  If we are skipping over a nonexistant chunk, then we have
                        //  to reserve a chunk of zeros.
                        //

                        } else {

                            //
                            //  If we have not reached our chunk, then describe the current
                            //  chunk in order to skip over it.
                            //

                            Status = RtlDescribeChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                       &CacheBuffer,
                                                       EndOfCacheBuffer,
                                                       &ChunkBuffer,
                                                       &TempUlong );

                            //
                            //  If there is not current chunk, we must insert a chunk of zeros.
                            //

                            if (Status == STATUS_NO_MORE_ENTRIES) {

                                Status = RtlReserveChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                          &CacheBuffer,
                                                          EndOfCacheBuffer,
                                                          &ChunkBuffer,
                                                          0 );

                                if (!NT_SUCCESS(Status)) {
                                    ASSERT(NT_SUCCESS(Status));
                                    break;
                                }

                            //
                            //  Get out if we got some other kind of unexpected error.
                            //

                            } else if (!NT_SUCCESS(Status)) {
                                ASSERT(NT_SUCCESS(Status));
                                break;
                            }
                        }

                        //
                        //  Reduce length by chunk copied, and check if we are done.
                        //

                        if (Length > ChunkSize) {
                            Length -= ChunkSize;
                        } else {
                            goto Done;
                        }

                        LocalOffset += ChunkSize;

                    } while ((LocalOffset & (CompressionUnitSize - 1)) != 0);

                    //
                    //  If this is an Mdl call, then it is time to add to the MdlChain
                    //  before moving to the next compression unit.
                    //

                    if (MdlLength != 0) {
                        NtfsAddToCompressedMdlChain( MdlChain,
                                                     MdlBuffer,
                                                     MdlLength,
                                                     Header->PagingIoResource,
                                                     Bcb,
                                                     IoWriteAccess,
                                                     TRUE );
                        Bcb = NULL;
                        MdlLength = 0;
                    }
                }
            }

            //
            //  Uncompressed loop.
            //

            if (!IsCompressed || !NT_SUCCESS(Status)) {

                //
                //  If we get here for an Mdl request, just tell him to send
                //  it uncompressed!
                //

                if (MdlChain != NULL) {
                    if (NT_SUCCESS(Status)) {
                        Status = STATUS_BUFFER_OVERFLOW;
                    }
                    goto Done;

                //
                //  If we are going to write the uncompressed stream,
                //  we have to make sure it is there.
                //

                } else if (((PSCB)Header)->FileObject == NULL) {
                    Status = STATUS_NOT_MAPPED_DATA;
                    goto Done;
                }

                //
                //  Restore sizes and pointers to the beginning of the
                //  current compression unit, and we will handle the
                //  data uncompressed.
                //

                LocalOffset -= SavedLength - Length;
                Length = SavedLength;
                Buffer = SavedBuffer;
                TempChunkSize = NextChunkSize;

                //
                //  We may have a Bcb from the above loop to unpin.
                //  Then we must flush and purge the compressed
                //  stream before proceding.
                //

                if (Bcb != NULL) {
                    CcUnpinData(Bcb);
                    Bcb = NULL;
                }

                //
                //  We must first flush and purge the compressed stream
                //  since we will be writing into the uncompressed stream.
                //  The flush is actually only necessary if we are not doing
                //  a full overwrite anyway.
                //

                if (!FullOverwrite) {
                    CcFlushCache( Header->FileObjectC->SectionObjectPointer,
                                  (PLARGE_INTEGER)&LocalOffset,
                                  CompressionUnitSize,
                                  NULL );
                }

                CcPurgeCacheSection( Header->FileObjectC->SectionObjectPointer,
                                     (PLARGE_INTEGER)&LocalOffset,
                                     CompressionUnitSize,
                                     FALSE );

                //
                //  If LocalOffset was rounded down to a compression
                //  unit boundary (must have failed in the first
                //  compression unit), then start from the actual
                //  starting FileOffset.
                //

                if (LocalOffset < FileOffset->QuadPart) {
                    Length -= (ULONG)(FileOffset->QuadPart - LocalOffset);
                    LocalOffset = FileOffset->QuadPart;
                }

                //
                //  Map the compression unit in the uncompressed
                //  stream.
                //

                SizeToPin = (((Length < CompressionUnitSize) ? Length : CompressionUnitSize) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

                CcPinRead( ((PSCB)Header)->FileObject,
                           (PLARGE_INTEGER)&LocalOffset,
                           SizeToPin,
                           TRUE,
                           &Bcb,
                           &CacheBuffer );

                CcSetDirtyPinnedData( Bcb, NULL );

                //
                //  Now loop through desired chunks
                //

                do {

                    //
                    //  If this chunk is compressed, then decompress it
                    //  into the cache.
                    //

                    if (*TempChunkSize != ChunkSize) {

                        Status = RtlDecompressBuffer( CompressedDataInfo->CompressionFormatAndEngine,
                                                      CacheBuffer,
                                                      ChunkSize,
                                                      Buffer,
                                                      *TempChunkSize,
                                                      &SavedLength );

                        //
                        //  See if the data is ok.
                        //

                        if (!NT_SUCCESS(Status)) {
                            ASSERT(NT_SUCCESS(Status));
                            goto Done;
                        }

                        //
                        //  Zero to the end of the chunk if it was not all there.
                        //

                        if (SavedLength != ChunkSize) {
                            RtlZeroMemory( Add2Ptr(CacheBuffer, SavedLength),
                                           ChunkSize - SavedLength );
                        }

                    } else {

                        //
                        //  Copy next chunk (it's not compressed).
                        //

                        RtlCopyBytes( CacheBuffer, Buffer, ChunkSize );
                    }

                    //
                    //  Advance input buffer by bytes copied.
                    //

                    Buffer = (PCHAR)Buffer + *TempChunkSize;
                    CacheBuffer = (PCHAR)CacheBuffer + ChunkSize;
                    TempChunkSize += 1;

                    //
                    //  Reduce length by chunk copied, and check if we are done.
                    //

                    if (Length > ChunkSize) {
                        Length -= ChunkSize;
                    } else {
                        goto Done;
                    }

                    LocalOffset += ChunkSize;

                } while ((LocalOffset & (CompressionUnitSize - 1)) != 0);
            }

            //
            //  Now we can finally advance our pointer into the chunk sizes.
            //

            NextChunkSize = TempChunkSize;
        }

    Done: NOTHING;

        if ((MdlLength != 0) && NT_SUCCESS(Status)) {
            NtfsAddToCompressedMdlChain( MdlChain,
                                         MdlBuffer,
                                         MdlLength,
                                         Header->PagingIoResource,
                                         Bcb,
                                         IoWriteAccess,
                                         TRUE );
            Bcb = NULL;
        }

    } except( FsRtlIsNtstatusExpected((Status = GetExceptionCode()))
                                    ? EXCEPTION_EXECUTE_HANDLER
                                    : EXCEPTION_CONTINUE_SEARCH ) {

        NOTHING;
    }

    //
    //  Unpin the Bcbs we still have.
    //

    if (TempBcb != NULL) {
        CcUnpinData( TempBcb );
    }
    if (Bcb != NULL) {
        CcUnpinData( Bcb );
    }
    if (CompressionSync != NULL) {
        NtfsReleaseCompressionSync( CompressionSync );
    }

    //
    //  Perform Mdl-specific processing.
    //

    if (MdlChain != NULL) {

        //
        //  On error, cleanup any MdlChain we built up
        //

        if (!NT_SUCCESS(Status)) {

            NtfsCleanupCompressedMdlChain( *MdlChain, TRUE );
            *MdlChain = NULL;

        //
        //  Change owner Id for the Scb and Bcbs we are holding.
        //

        } else if (*MdlChain != NULL) {

            NtfsSetMdlBcbOwners( *MdlChain );
            ExSetResourceOwnerPointer( Header->PagingIoResource, (PVOID)((PCHAR)*MdlChain + 3) );
        }
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("  Return Status = %08lx\n", Status);
    }
#endif
    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}


BOOLEAN
NtfsMdlWriteCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine frees resources and the Mdl Chain after a compressed write.

Arguments:

    FileObject - pointer to the file object for the request.

    MdlChain - as returned from compressed write.

    DeviceObject - As required for a fast I/O routine.

Return Value:

    TRUE - if fast path succeeded

    FALSE -  if an Irp is required

--*/

{
    PERESOURCE ResourceToRelease;

    if (MdlChain != NULL) {

        ResourceToRelease = *(PERESOURCE *)Add2Ptr( MdlChain, MdlChain->Size + sizeof( PBCB ));

        NtfsCleanupCompressedMdlChain( MdlChain, FALSE );

        //
        //  Release the held resource.
        //

        ExReleaseResourceForThread( ResourceToRelease, (ERESOURCE_THREAD)((PCHAR)MdlChain + 3) );
    }
    return TRUE;

    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( FileOffset );
}


VOID
NtfsAddToCompressedMdlChain (
    IN OUT PMDL *MdlChain,
    IN PVOID MdlBuffer,
    IN ULONG MdlLength,
    IN PERESOURCE ResourceToRelease OPTIONAL,
    IN PBCB Bcb,
    IN LOCK_OPERATION Operation,
    IN ULONG IsCompressed
    )

/*++


Routine Description:

    This routine creates and Mdl for the described buffer and adds it to
    the chain.

Arguments:

    MdlChain - MdlChain pointer to append the first/new Mdl to.

    MdlBuffer - Buffer address for this Mdl.

    MdlLength - Length of buffer in bytes.

    ResourceToRelease - Indicates which resource to release, only specified for compressed IO.

    Bcb - Bcb to remember with this Mdl, to be freed when Mdl completed

    Operation - IoReadAccess or IoWriteAccess

    IsCompressed - Supplies TRUE if the Bcb is in the compressed stream

Return Value:

    None.

--*/

{
    PMDL Mdl, MdlTemp;

    ASSERT(sizeof(ULONG) == sizeof(PBCB));

    //
    //  Now attempt to allocate an Mdl to describe the mapped data.
    //  We "lie" about the length of the buffer by one page, in order
    //  to get an extra field to store a pointer to the Bcb in.
    //

    Mdl = IoAllocateMdl( MdlBuffer,
                         (MdlLength + (2 * PAGE_SIZE)),
                         FALSE,
                         FALSE,
                         NULL );

    if (Mdl == NULL) {
        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Now subtract out the space we reserved for our Bcb pointer
    //  and then store it.
    //

    Mdl->Size -= 2 * sizeof(ULONG);
    Mdl->ByteCount -= 2 * PAGE_SIZE;

    //
    //  Note that this probe should never fail, because we can
    //  trust the address returned from CcPinFileData.  Therefore,
    //  if we succeed in allocating the Mdl above, we should
    //  manage to elude any expected exceptions through the end
    //  of this loop.
    //

    if (Mdl->ByteCount != 0) {
        MmProbeAndLockPages( Mdl, KernelMode, Operation );
    }

    //
    //  Only store the Bcb if this is the compressed stream.
    //

    if (!IsCompressed && (Bcb != NULL)) {
        Bcb = NULL;
    }
    *(PBCB *)Add2Ptr( Mdl, Mdl->Size ) = Bcb;
    *(PERESOURCE *)Add2Ptr( Mdl, Mdl->Size + sizeof( PBCB )) = ResourceToRelease;

    //
    //  Now link the Mdl into the caller's chain
    //

    if ( *MdlChain == NULL ) {
        *MdlChain = Mdl;
    } else {
        MdlTemp = CONTAINING_RECORD( *MdlChain, MDL, Next );
        while (MdlTemp->Next != NULL) {
            MdlTemp = MdlTemp->Next;
        }
        MdlTemp->Next = Mdl;
    }
}

VOID
NtfsSetMdlBcbOwners (
    IN PMDL MdlChain
    )

/*++

Routine Description:

    This routine may be called to set all of the Bcb resource owners in an Mdl
    to be equal to the address of the first element in the MdlChain, so that they
    can be freed in the context of a different thread.

Arguments:

    MdlChain - Supplies the MdlChain to process

Return Value:

    None.

--*/

{
    PBCB Bcb;

    while (MdlChain != NULL) {

        //
        //  Unpin the Bcb we saved away, and restore the Mdl counts
        //  we altered.
        //

        Bcb = *(PBCB *)Add2Ptr(MdlChain, MdlChain->Size);
        if (Bcb != NULL) {
            CcSetBcbOwnerPointer( Bcb, (PVOID)((PCHAR)MdlChain + 3) );
        }

        MdlChain = MdlChain->Next;
    }
}

VOID
NtfsCleanupCompressedMdlChain (
    IN PMDL MdlChain,
    IN ULONG Error
    )

/*++

Routine Description:

    This routine is called to free all of the resources associated with a
    compressed Mdl chain.  It may be called for an error in the processing
    of a request or when a request completes.

Arguments:

    MdlChain - Supplies the address of the first element in the chain to clean up.

    Error - Supplies TRUE on error (resources are still owned by current thread) or
            FALSE on a normal completion (resources owned by MdlChain).

Return Value:

    None.

--*/

{
    PMDL MdlTemp;
    PBCB Bcb;

    while (MdlChain != NULL) {

        //
        //  Save a pointer to the next guy in the chain.
        //

        MdlTemp = MdlChain->Next;

        //
        //  Unlock the pages.
        //

        if (MdlChain->ByteCount != 0) {
            MmUnlockPages( MdlChain );
        }

        //
        //  Unpin the Bcb we saved away, and restore the Mdl counts
        //  we altered.
        //

        Bcb = *(PBCB *)Add2Ptr(MdlChain, MdlChain->Size);
        if (Bcb != NULL) {
            if (Error) {
                CcUnpinData( Bcb );
            } else {

                CcUnpinDataForThread( Bcb, (ERESOURCE_THREAD)((PCHAR)MdlChain + 3) );
            }
        }

        MdlChain->Size += 2 * sizeof(ULONG);
        MdlChain->ByteCount += 2 * PAGE_SIZE;

        IoFreeMdl( MdlChain );

        MdlChain = MdlTemp;
    }
}


NTSTATUS
NtfsSynchronizeUncompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    )

/*++

Routine Description:

    This routine attempts to synchronize with the compressed data cache,
    for an I/O in the uncompressed cache.  The view in the compressed cache
    is locked shared or exclusive without reading.  Then the compressed cache
    is flushed and purged as appropriate.

    We will allocate a COMPRESSION_SYNC structure to serialize each cache
    manager view and use that for the locking granularity.

Arguments:

    Scb - Supplies the Scb for the stream.

    FileOffset - Byte offset in file for desired data.  NULL if we are to
        flush and purge the entire file.

    Length - Length of desired data in bytes.

    WriteAccess - Supplies TRUE if the caller plans to do a write, or FALSE
                  for a read.

    CompressionSync - Synchronization object to serialize access to the view.
        The caller's routine is responsible for releasing this.

Return Value:

    Status of the flush operation, or STATUS_UNSUCCESSFUL for a WriteAccess
    where the purge failed.

--*/

{
    ULONG Change = 0;
    IO_STATUS_BLOCK IoStatus;
    PSECTION_OBJECT_POINTERS SectionObjectPointers = &Scb->NonpagedScb->SegmentObjectC;
    LONGLONG LocalFileOffset;
    PLONGLONG LocalOffsetPtr;

    if (ARGUMENT_PRESENT( FileOffset )) {

        LocalFileOffset = *FileOffset & ~(VACB_MAPPING_GRANULARITY - 1);
        LocalOffsetPtr = &LocalFileOffset;
        ASSERT( ((*FileOffset & (VACB_MAPPING_GRANULARITY - 1)) + Length) <= VACB_MAPPING_GRANULARITY );

    } else {

        LocalFileOffset = 0;
        LocalOffsetPtr = NULL;
        Length = 0;
    }

    IoStatus.Status = STATUS_SUCCESS;
    if ((*CompressionSync == NULL) || ((*CompressionSync)->FileOffset != LocalFileOffset)) {

        if (*CompressionSync != NULL) {

            NtfsReleaseCompressionSync( *CompressionSync );
            *CompressionSync = NULL;
        }

        *CompressionSync = NtfsAcquireCompressionSync( LocalFileOffset, Scb, WriteAccess );

        //
        //  Always flush the remainder of the Vacb.  This is to prevent a problem if MM reads additional
        //  pages into section because of the page fault clustering.
        //

        if (ARGUMENT_PRESENT( FileOffset )) {

            LocalFileOffset = *FileOffset & ~((ULONG_PTR)Scb->CompressionUnit - 1);
            Length = VACB_MAPPING_GRANULARITY - (((ULONG) LocalFileOffset) & (VACB_MAPPING_GRANULARITY - 1));
        }

        //
        //  We must always flush the other cache.
        //

        CcFlushCache( SectionObjectPointers,
                      (PLARGE_INTEGER) LocalOffsetPtr,
                      Length,
                      &IoStatus );

#ifdef NTFS_RWCMP_TRACE
        if (NtfsCompressionTrace && IsSyscache(Scb)) {
            DbgPrint("  CcFlushCache: FO = %08lx, Len = %08lx, IoStatus = %08lx, Scb = %08lx\n",
                     (ULONG)LocalFileOffset,
                     Length,
                     IoStatus.Status,
                     Scb );
        }
#endif

        //
        //  On writes, we purge the other cache after a successful flush.
        //

        if (WriteAccess && NT_SUCCESS(IoStatus.Status)) {

            if (!CcPurgeCacheSection( SectionObjectPointers,
                                      (PLARGE_INTEGER) LocalOffsetPtr,
                                      Length,
                                      FALSE )) {

                return STATUS_UNSUCCESSFUL;
            }
        }
    }

    return IoStatus.Status;
}


NTSTATUS
NtfsSynchronizeCompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    )

/*++

Routine Description:

    This routine attempts to synchronize with the uncompressed data cache,
    for an I/O in the compressed cache.  The range in the compressed cache
    is assumed to already be locked by the caller.  Then the uncompressed cache
    is flushed and purged as appropriate.

    We will allocate a COMPRESSION_SYNC structure to serialize each cache
    manager view and use that for the locking granularity.

Arguments:

    Scb - Supplies the Scb for the stream.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    WriteAccess - Supplies TRUE if the caller plans to do a write, or FALSE
                  for a read.

    CompressionSync - Synchronization object to serialize access to the view.
        The caller's routine is responsible for releasing this.

Return Value:

    Status of the flush operation, or STATUS_USER_MAPPED_FILE for a WriteAccess
    where the purge failed.  (This is the only expected case where a purge would
    fail.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    PSECTION_OBJECT_POINTERS SectionObjectPointers = &Scb->NonpagedScb->SegmentObject;
    LONGLONG LocalFileOffset = *FileOffset & ~(VACB_MAPPING_GRANULARITY - 1);

    IoStatus.Status = STATUS_SUCCESS;
    if ((*CompressionSync == NULL) || ((*CompressionSync)->FileOffset != LocalFileOffset)) {

        //
        //  Release any previous view and Lock the current view.
        //

        if (*CompressionSync != NULL) {

            NtfsReleaseCompressionSync( *CompressionSync );
            *CompressionSync = NULL;
        }

        *CompressionSync = NtfsAcquireCompressionSync( LocalFileOffset, Scb, WriteAccess );

        //
        //  Now that we are synchronized on a view, test for a write to a user-mapped file.
        //  In case we keep hitting this path, this is better than waiting for a purge to
        //  fail.
        //

        if (WriteAccess && 
            (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE ) ||
             FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ))) {
            return  STATUS_USER_MAPPED_FILE;
        }

        //
        //  Always flush the remainder of the Vacb.  This is to prevent a problem if MM reads additional
        //  pages into section because of the page fault clustering.
        //

        LocalFileOffset = *FileOffset & ~((ULONG_PTR)Scb->CompressionUnit - 1);
        Length = VACB_MAPPING_GRANULARITY - (((ULONG) LocalFileOffset) & (VACB_MAPPING_GRANULARITY - 1));

        //
        //  We must always flush the other cache.
        //

        CcFlushCache( SectionObjectPointers,
                      (PLARGE_INTEGER)&LocalFileOffset,
                      Length,
                      &IoStatus );

        //
        //  On writes, we purge the other cache after a successful flush.
        //

        if (WriteAccess && NT_SUCCESS(IoStatus.Status)) {

            if (!CcPurgeCacheSection( SectionObjectPointers,
                                      (PLARGE_INTEGER)&LocalFileOffset,
                                      Length,
                                      FALSE )) {

                return  STATUS_USER_MAPPED_FILE;
            }
        }
    }

    return IoStatus.Status;
}


PCOMPRESSION_SYNC
NtfsAcquireCompressionSync (
    IN LONGLONG FileOffset,
    IN PSCB Scb,
    IN ULONG WriteAccess
    )

/*++

Routine Description:

    This routine is called to lock a range of a stream to serialize the compressed and
    uncompressed IO.

Arguments:

    FileOffset - File offset to lock.  This will be rounded to a cache view boundary.

    Scb - Supplies the Scb for the stream.

    WriteAccess - Indicates if the user wants write access.  We will acquire the range
        exclusively in that case.

Return Value:

    PCOMPRESSION_SYNC - A pointer to the synchronization object for the range.  This routine may
        raise, typically if the structure can't be allocated.

--*/

{
    PCOMPRESSION_SYNC CompressionSync = NULL;
    PCOMPRESSION_SYNC NewCompressionSync;
    BOOLEAN FoundSync = FALSE;

    PAGED_CODE();

    //
    //  Round the file offset down to a view boundary.
    //

    ((PLARGE_INTEGER) &FileOffset)->LowPart &= ~(VACB_MAPPING_GRANULARITY - 1);

    //
    //  Acquire the mutex for the stream.  Then walk and look for a matching resource.
    //

    NtfsAcquireFsrtlHeader( Scb );

    CompressionSync = (PCOMPRESSION_SYNC) Scb->ScbType.Data.CompressionSyncList.Flink;

    while (CompressionSync != (PCOMPRESSION_SYNC) &Scb->ScbType.Data.CompressionSyncList) {

        //
        //  Continue if we haven't found our entry.
        //

        if (CompressionSync->FileOffset < FileOffset) {

            //
            //  Go to the next entry.
            //

            CompressionSync = (PCOMPRESSION_SYNC) CompressionSync->CompressionLinks.Flink;
            continue;
        }

        if (CompressionSync->FileOffset == FileOffset) {

            FoundSync = TRUE;
        }

        //
        //  Exit in any case.
        //

        break;
    }

    //
    //  If we didn't find the entry then attempt to allocate a new one.
    //

    if (!FoundSync) {

        NewCompressionSync = (PCOMPRESSION_SYNC) ExAllocateFromNPagedLookasideList( &NtfsCompressSyncLookasideList );

        //
        //  Release the mutex and raise an error if we couldn't allocate.
        //

        if (NewCompressionSync == NULL) {

            NtfsReleaseFsrtlHeader( Scb );
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  We have the new entry and know where it belongs in the list.  Do the final initialization
        //  and add it to the list.
        //

        NewCompressionSync->FileOffset = FileOffset;
        NewCompressionSync->Scb = Scb;

        //
        //  Add it just ahead of the entry we stopped at.
        //

        InsertTailList( &CompressionSync->CompressionLinks, &NewCompressionSync->CompressionLinks );
        CompressionSync = NewCompressionSync;
    }

    //
    //  We know have the structure.  Reference it so it can't go away.  Then drop the
    //  mutex and wait for it.
    //

    CompressionSync->ReferenceCount += 1;

    NtfsReleaseFsrtlHeader( Scb );

    if (WriteAccess) {

        ExAcquireResourceExclusiveLite( &CompressionSync->Resource, TRUE );

    } else {

        ExAcquireResourceSharedLite( &CompressionSync->Resource, TRUE );
    }

    return CompressionSync;
}


VOID
NtfsReleaseCompressionSync (
    IN PCOMPRESSION_SYNC CompressionSync
    )

/*++

Routine Description:

    This routine is called to release a range in a stream which was locked serial compressed and
    uncompressed IO.

Arguments:

    CompressionSync - Pointer to the synchronization object.

Return Value:

    None.

--*/

{
    PSCB Scb = CompressionSync->Scb;
    PAGED_CODE();

    //
    //  Release the resource and then acquire the mutext for the stream.  If we are the last
    //  reference then free the structure.
    //

    ExReleaseResourceLite( &CompressionSync->Resource );

    NtfsAcquireFsrtlHeader( Scb );

    CompressionSync->ReferenceCount -= 1;
    if (CompressionSync->ReferenceCount == 0) {

        RemoveEntryList( &CompressionSync->CompressionLinks );
        ExFreeToNPagedLookasideList( &NtfsCompressSyncLookasideList, CompressionSync );
    }

    NtfsReleaseFsrtlHeader( Scb );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\restrsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RestrSup.c

Abstract:

    This module implements the Ntfs routine to perform Restart on an
    Ntfs volume, i.e., to restore a consistent state to the volume that
    existed before the last failure.

Author:

    Tom Miller      [TomM]          24-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  ****    This is a way to disable a restart to get a volume going "as-is".
//

BOOLEAN NtfsDisableRestart = FALSE;

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOGSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('RFtN')

//
//  Size for initial in memory dirty page table
//

#define INITIAL_NUMBER_DIRTY_PAGES 32

//
//  The following macro returns the length of the log record header of
//  of log record.
//
//
//  ULONG
//  NtfsLogRecordHeaderLength (
//      IN PIRP_CONTEXT IrpContext,
//      IN PNTFS_LOG_RECORD_HEADER LogRecord
//      );
//

#define NtfsLogRecordHeaderLength( IC, LR )                     \
    (sizeof( NTFS_LOG_RECORD_HEADER )                           \
     + (((PNTFS_LOG_RECORD_HEADER) (LR))->LcnsToFollow > 1      \
        ? (((PNTFS_LOG_RECORD_HEADER) (LR))->LcnsToFollow - 1)  \
          * sizeof( LCN )                                       \
        : 0 ))

//
//
//  Local procedure prototypes
//

VOID
InitializeRestartState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PRESTART_POINTERS DirtyPageTable,
    OUT PATTRIBUTE_NAME_ENTRY *AttributeNames,
    OUT PLSN CheckpointLsn,
    OUT PBOOLEAN UnrecognizedRestart
    );

VOID
ReleaseRestartState (
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable,
    IN PATTRIBUTE_NAME_ENTRY AttributeNames,
    IN BOOLEAN ReleaseVcbTables
    );

VOID
AnalysisPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN CheckpointLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    OUT PLSN RedoLsn
    );

VOID
RedoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN RedoLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable
    );

VOID
UndoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
DoAction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN NTFS_LOG_OPERATION Operation,
    IN PVOID Data,
    IN ULONG Length,
    IN ULONG LogRecordLength,
    IN PLSN RedoLsn OPTIONAL,
    IN PSCB Scb OPTIONAL,
    OUT PBCB *Bcb,
    OUT PLSN *PageLsn
    );

VOID
PinMftRecordForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord
    );

VOID
OpenAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN OUT PSCB *Scb
    );

VOID
PinAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG Length OPTIONAL,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN OUT PSCB *Scb
    );

BOOLEAN
FindDirtyPage (
    IN PRESTART_POINTERS DirtyPageTable,
    IN ULONG TargetAttribute,
    IN VCN Vcn,
    OUT PDIRTY_PAGE_ENTRY *DirtyPageEntry
    );

VOID
PageUpdateAnalysis (
    IN PVCB Vcb,
    IN LSN Lsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    IN PNTFS_LOG_RECORD_HEADER LogRecord
    );

VOID
OpenAttributesForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AnalysisPass)
#pragma alloc_text(PAGE, DoAction)
#pragma alloc_text(PAGE, FindDirtyPage)
#pragma alloc_text(PAGE, InitializeRestartState)
#pragma alloc_text(PAGE, NtfsAbortTransaction)
#pragma alloc_text(PAGE, NtfsCloseAttributesFromRestart)
#pragma alloc_text(PAGE, NtfsRestartVolume)
#pragma alloc_text(PAGE, OpenAttributeForRestart)
#pragma alloc_text(PAGE, OpenAttributesForRestart)
#pragma alloc_text(PAGE, PageUpdateAnalysis)
#pragma alloc_text(PAGE, PinAttributeForRestart)
#pragma alloc_text(PAGE, PinMftRecordForRestart)
#pragma alloc_text(PAGE, RedoPass)
#pragma alloc_text(PAGE, ReleaseRestartState)
#pragma alloc_text(PAGE, UndoPass)
#endif


BOOLEAN
NtfsRestartVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PBOOLEAN UnrecognizedRestart
    )

/*++

Routine Description:

    This routine is called by the mount process after the log file has been
    started, to restart the volume.  Restarting the volume means restoring
    it to a consistent state as of the last request which was successfully
    completed and written to the log for this volume.

    The Restart process is a standard recovery from the Log File in three
    passes: Analysis Pass, Redo Pass and Undo pass.  Each one of these passes
    is implemented in a separate routine in this module.

Arguments:

    Vcb - Vcb for the volume which is to be restarted.

    UnrecognizedRestart - Indicates that this version of Ntfs doesn't recognize the
        restart area.  Chkdsk should run to repair the disk.

Return Value:

    FALSE - if no updates were applied during restart
    TRUE - if updates were applied

--*/

{
    RESTART_POINTERS DirtyPageTable;
    LSN CheckpointLsn;
    LSN RedoLsn;
    PATTRIBUTE_NAME_ENTRY AttributeNames = NULL;
    BOOLEAN UpdatesApplied = FALSE;
    BOOLEAN ReleaseVcbTables = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartVolume:\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );

#ifdef SYSCACHE
    DebugTrace( 0, Dbg, ("Syscache test build\n") );
#endif


    RtlZeroMemory( &DirtyPageTable, sizeof(RESTART_POINTERS) );

    //
    //  Use try-finally to insure cleanup on the way out.
    //

    try {

        //
        //  First we initialize the Open Attribute Table, Transaction Table,
        //  and Dirty Page Table from our last Checkpoint (as found from our
        //  Restart Area) in the log.
        //

        InitializeRestartState( IrpContext,
                                Vcb,
                                &DirtyPageTable,
                                &AttributeNames,
                                &CheckpointLsn,
                                UnrecognizedRestart );

        ReleaseVcbTables = TRUE;

        //
        //  If the CheckpointLsn is zero, then this is a freshly formattted
        //  disk and we have no work to do.
        //

        if (CheckpointLsn.QuadPart == 0) {

            LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
            try_return(NOTHING);
        }

#ifdef BENL_DBG
        {
            PRESTART_LOG RedoLog;

            RedoLog = (PRESTART_LOG) NtfsAllocatePoolNoRaise( NonPagedPool, sizeof( RESTART_LOG ) );
            RedoLog->Lsn = CheckpointLsn;
            InsertTailList( &(Vcb->RestartRedoHead), &(RedoLog->Links) );
        }
#endif


        //
        //  Start the analysis pass from the Checkpoint Lsn.  This pass potentially
        //  updates all of the tables, and returns the RedoLsn, which is the Lsn
        //  at which the Redo Pass is to begin.
        //

        if (!NtfsDisableRestart &&
            !FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART )) {
            AnalysisPass( IrpContext, Vcb, CheckpointLsn, &DirtyPageTable, &RedoLsn );
        }

        //
        //  Only proceed if the the Dirty Page Table or Transaction table are
        //  not empty.
        //
        //  REM: Once we implement the new USN journal restart optimization, this
        //  won't be a simple !empty test.
        //

        if (!IsRestartTableEmpty(&DirtyPageTable)

                ||

            !IsRestartTableEmpty(&Vcb->TransactionTable)) {

            //
            //  If the user wants to mount this readonly, we can't go on.
            //

            if (NtfsIsVolumeReadOnly( Vcb )) {

                LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
                NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
            }

            UpdatesApplied = TRUE;

            //
            //  Before starting the Redo Pass, we have to reopen all of the
            //  attributes with dirty pages, and preinitialize their Mcbs with the
            //  mapping information from the Dirty Page Table.
            //

            OpenAttributesForRestart( IrpContext, Vcb, &DirtyPageTable );

            //
            //  Perform the Redo Pass, to restore all of the dirty pages to the same
            //  contents that they had immediately before the crash.
            //

            RedoPass( IrpContext, Vcb, RedoLsn, &DirtyPageTable );

            //
            //  Finally, perform the Undo Pass to undo any updates which may exist
            //  for transactions which did not complete.
            //

            UndoPass( IrpContext, Vcb );

        } else {

            //
            //  We know that there's no restart work left to do.
            //  Hence, if the user has requested a readonly mount, go ahead.
            //

            if (NtfsIsVolumeReadOnly( Vcb )) {

                //
                //  REM: Make sure the USN journal is clean too.
                //

                //
                //  Make sure that the pagingfile isn't on this volume?

            }

        }

        //
        //  Now that we know that there is no one to abort, we can initialize our
        //  Undo requirements, to our standard starting point to include the size
        //  of our Restart Area (for a clean checkpoint) + a page, which is the
        //  worst case loss when flushing the volume causes Lfs to flush to Lsn.
        //

        LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );

    //
    //  If we got an exception, we can at least clean up on the way out.
    //

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsRestartVolume );

        //
        //  Free up any resources tied down with the Restart State.
        //

        ReleaseRestartState( Vcb,
                             &DirtyPageTable,
                             AttributeNames,
                             ReleaseVcbTables );
    }
    DebugTrace( -1, Dbg, ("NtfsRestartVolume -> %02lx\n", UpdatesApplied) );

    return UpdatesApplied;
}


VOID
NtfsAbortTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PTRANSACTION_ENTRY Transaction OPTIONAL
    )

/*++

Routine Description:

    This routine aborts a transaction by undoing all of its actions.

    The Undo actions are all performed in the common routine DoAction,
    which is also used by the Redo Pass.

Arguments:

    Vcb - Vcb for the Volume.  NOTE - This argument is not guaranteed to
          be valid if Transaction is NULL and there is no Transaction ID
          in the IrpContext.

    Transaction - Pointer to the transaction entry of the transaction to be
                  aborted, or NULL to abort current transaction (if there is
                  one).

Return Value:

    None.

--*/

{
    LFS_LOG_CONTEXT LogContext;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogRecordLength;
    PVOID Data;
    LONG Length;
    LSN LogRecordLsn;
    LSN UndoRecordLsn;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    TRANSACTION_ID SavedTransaction = IrpContext->TransactionId;

    DebugTrace( +1, Dbg, ("NtfsAbortTransaction:\n") );

    //
    //  If a transaction was specified, then we have to set our transaction Id
    //  into the IrpContext (it was saved above), since NtfsWriteLog requires
    //  it.
    //

    if (ARGUMENT_PRESENT(Transaction)) {

        IrpContext->TransactionId = GetIndexFromRestartEntry( &Vcb->TransactionTable,
                                                              Transaction );

        UndoNextLsn = Transaction->UndoNextLsn;

        //
        //  Set the flag in the IrpContext so we will always write the commit
        //  record.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG );

    //
    //  Otherwise, we are aborting the current transaction, and we must get the
    //  pointer to its transaction entry.
    //

    } else {

        if (IrpContext->TransactionId == 0) {

            DebugTrace( -1, Dbg, ("NtfsAbortTransaction->VOID (no transaction)\n") );

            return;
        }

        //
        //  Synchronize access to the transaction table in case the table
        //  is growing.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                          TRUE );

        Transaction = GetRestartEntryFromIndex( &Vcb->TransactionTable,
                                                IrpContext->TransactionId );

        UndoNextLsn = Transaction->UndoNextLsn;

        NtfsReleaseRestartTable( &Vcb->TransactionTable );
    }

    ASSERT(!NtfsIsVolumeReadOnly( Vcb ));

    //
    //  If we are aborting the current transaction (by default or explicit
    //  request), then restore 0 on return because he will be gone.
    //

    if (IrpContext->TransactionId == SavedTransaction) {

        SavedTransaction = 0;
    }

    DebugTrace( 0, Dbg, ("Transaction = %08lx\n", Transaction) );

    //
    //  We only have to do anything if the transaction has something in its
    //  UndoNextLsn field.
    //

    if (UndoNextLsn.QuadPart != 0) {

        PBCB PageBcb = NULL;

        //
        //  Read the first record to be undone by this transaction.
        //

        LfsReadLogRecord( Vcb->LogHandle,
                          UndoNextLsn,
                          LfsContextUndoNext,
                          &LogContext,
                          &RecordType,
                          &TransactionId,
                          &UndoNextLsn,
                          &PreviousLsn,
                          &LogRecordLength,
                          (PVOID *)&LogRecord );

        //
        //  Now loop to read all of our log records forwards, until we hit
        //  the end of the file, cleaning up at the end.
        //

        try {

            do {

                PLSN PageLsn;

                //
                //  Check that the log record is valid.
                //

                if (!NtfsCheckLogRecord( LogRecord,
                                         LogRecordLength,
                                         TransactionId,
                                         Vcb->OatEntrySize )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                DebugTrace( 0, Dbg, ("Undo of Log Record at: %08lx\n", LogRecord) );
                DebugTrace( 0, Dbg, ("Log Record Lsn = %016I64x\n", LogRecordLsn) );

                //
                //  Log the Undo operation as a CLR, i.e., it has no undo,
                //  and the UndoNext points to the UndoNext of the current
                //  log record.
                //
                //  Don't do this if the undo is a noop.  This is not only
                //  efficient, but in the case of a clean shutdown, there
                //  will be no Scb to pick up from the table below.
                //

                if (LogRecord->UndoOperation != Noop) {

                    ULONG i;
                    PSCB Scb;

                    VCN Vcn;
                    LONGLONG Size;

                    //
                    //  Acquire and release the restart table.  We must synchronize
                    //  even though our entry can't be removed because the table
                    //  could be growing (or shrinking) and the table pointer
                    //  could be changing.
                    //

                    NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable,
                                                      TRUE );

                    //
                    //  We are getting the attribute index from a log record on disk.  We
                    //  may have to go through the on-disk Oat.
                    //

                    if (Vcb->RestartVersion == 0) {

                        ULONG InMemoryIndex;

                        //
                        //  Go through the on-disk Oat.
                        //

                        InMemoryIndex = ((POPEN_ATTRIBUTE_ENTRY_V0) GetRestartEntryFromIndex( Vcb->OnDiskOat,
                                                                                              LogRecord->TargetAttribute ))->OatIndex;

                        ASSERT( InMemoryIndex != 0 );

                        Scb = ((POPEN_ATTRIBUTE_ENTRY) GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                                                 InMemoryIndex ))->OatData->Overlay.Scb;

                    } else {

                        ASSERT( Vcb->RestartVersion == 1 );
                        ASSERT( LogRecord->TargetAttribute != 0 );

                        Scb = ((POPEN_ATTRIBUTE_ENTRY)GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                                                LogRecord->TargetAttribute))->OatData->Overlay.Scb;


                    }
                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );

                    //
                    //  If we have Lcn's to process and restart is in progress,
                    //  then we need to check if this is part of a partial page.
                    //

                    if (FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                        (LogRecord->LcnsToFollow != 0)) {

                        LCN TargetLcn;
                        LONGLONG SectorCount, SectorsInRun;
                        BOOLEAN MappingInMcb;

                        //
                        //  If the mapping isn't already in the table or the
                        //  mapping corresponds to a hole in the mapping, we
                        //  need to make sure there is no partial page already
                        //  in memory.
                        //

                        if (!(MappingInMcb = NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                                                     LogRecord->TargetVcn,
                                                                     &TargetLcn,
                                                                     &SectorCount,
                                                                     NULL,
                                                                     &SectorsInRun,
                                                                     NULL,
                                                                     NULL )) ||
                            (TargetLcn == UNUSED_LCN) ||
                            ((ULONG)SectorCount) < LogRecord->LcnsToFollow) {

                            VCN StartingPageVcn;
                            ULONG ClusterOffset;
                            BOOLEAN FlushAndPurge;

                            FlushAndPurge = FALSE;

                            //
                            //  Remember the Vcn at the start of the containing
                            //  page.
                            //

                            ClusterOffset = ((ULONG)LogRecord->TargetVcn) & (Vcb->ClustersPerPage - 1);

                            StartingPageVcn = LogRecord->TargetVcn;
                            ((PLARGE_INTEGER) &StartingPageVcn)->LowPart &= ~(Vcb->ClustersPerPage - 1);

                            //
                            //  If this mapping was not in the Mcb, then if the
                            //  Mcb is empty or the last entry is not in this page
                            //  then there is nothing to do.
                            //

                            if (!MappingInMcb) {

                                LCN LastLcn;
                                VCN LastVcn;

                                if ((ClusterOffset != 0) &&
                                    NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                                &LastVcn,
                                                                &LastLcn ) &&
                                    (LastVcn >= StartingPageVcn)) {

                                    FlushAndPurge = TRUE;
                                }

                            //
                            //  If the mapping showed a hole, then the entire
                            //  page needs to be a hole.  We know that this mapping
                            //  can't be the last mapping on the page.  We just
                            //  need to starting point and the number of clusters
                            //  required for the run.
                            //

                            } else if (TargetLcn == UNUSED_LCN) {

                                if (((ClusterOffset + (ULONG) SectorCount) < Vcb->ClustersPerPage) ||
                                    ((ClusterOffset + (ULONG) SectorCount) > (ULONG) SectorsInRun)) {

                                    FlushAndPurge = TRUE;
                                }

                            //
                            //  In the rare case where we are extending an existing mapping
                            //  let's flush and purge.
                            //

                            } else {

                                FlushAndPurge = TRUE;
                            }

                            if (FlushAndPurge) {

                                LONGLONG StartingOffset;
                                IO_STATUS_BLOCK Iosb;

                                StartingOffset = LlBytesFromClusters( Vcb, StartingPageVcn );
                                StartingOffset += BytesFromLogBlocks( LogRecord->ClusterBlockOffset );

                                CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                                              (PLARGE_INTEGER)&StartingOffset,
                                              PAGE_SIZE,
                                              &Iosb );

                                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                    &Iosb.Status,
                                                                    TRUE,
                                                                    STATUS_UNEXPECTED_IO_ERROR );

                                if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                          (PLARGE_INTEGER)&StartingOffset,
                                                          PAGE_SIZE,
                                                          FALSE )) {

                                    KdPrint(("NtfsUndoPass:  Unable to purge page\n"));

                                    NtfsRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR, NULL, NULL );
                                }
                            }
                        }
                    }

                    //
                    //  Loop to add the allocated Vcns.  Note that the page
                    //  may not have been dirty, which means we may not have
                    //  added the run information in the Redo Pass, so we
                    //  add it here.
                    //

                    for (i = 0, Vcn = LogRecord->TargetVcn, Size = LlBytesFromClusters( Vcb, Vcn + 1 );
                         i < (ULONG)LogRecord->LcnsToFollow;
                         i++, Vcn = Vcn + 1, Size = Size + Vcb->BytesPerCluster ) {

                        //
                        //  Add this run to the Mcb if the Vcn has not been deleted,
                        //  and it is not for the fixed part of the Mft.
                        //

                        if ((LogRecord->LcnsForPage[i] != 0)

                                &&

                            (NtfsSegmentNumber( &Scb->Fcb->FileReference ) > MASTER_FILE_TABLE2_NUMBER ||
                             (Size >= ((VOLUME_DASD_NUMBER + 1) * Vcb->BytesPerFileRecordSegment)) ||
                             (Scb->AttributeTypeCode != $DATA))) {

                            //
                            //  We test here if we are performing restart.  In that case
                            //  we need to test if the Lcn's are already in the Mcb.
                            //  If not, then we want to flush and purge the page in
                            //  case we have zeroed any half pages.
                            //

                            while (!NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                                         Vcn,
                                                         LogRecord->LcnsForPage[i],
                                                         (LONGLONG)1,
                                                         FALSE )) {

                                NtfsRemoveNtfsMcbEntry( &Scb->Mcb,
                                                        Vcn,
                                                        1 );
                            }
                        }

                        if (Size > Scb->Header.AllocationSize.QuadPart) {

                            Scb->Header.AllocationSize.QuadPart =
                            Scb->Header.FileSize.QuadPart =
                            Scb->Header.ValidDataLength.QuadPart = Size;

                            //
                            //  Update the Cache Manager if we have a file object.
                            //

                            if (Scb->FileObject != NULL) {

                                ASSERT( !FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL ) );

                                CcSetFileSizes( Scb->FileObject,
                                                (PCC_FILE_SIZES)&Scb->Header.AllocationSize );
                            }
                        }
                    }

                    //
                    //  Point to the Redo Data and get its length.
                    //

                    Data = (PVOID)((PCHAR)LogRecord + LogRecord->UndoOffset);
                    Length = LogRecord->UndoLength;

                    //
                    //  Once we have logged the Undo operation, it is time to apply
                    //  the undo action.
                    //

                    DoAction( IrpContext,
                              Vcb,
                              LogRecord,
                              LogRecord->UndoOperation,
                              Data,
                              Length,
                              LogRecordLength,
                              NULL,
                              Scb,
                              &PageBcb,
                              &PageLsn );

                    UndoRecordLsn =
                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  PageBcb,
                                  LogRecord->UndoOperation,
                                  Data,
                                  Length,
                                  CompensationLogRecord,
                                  (PVOID)&UndoNextLsn,
                                  LogRecord->RedoLength,
                                  LlBytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset ),
                                  LogRecord->RecordOffset,
                                  LogRecord->AttributeOffset,
                                  BytesFromClusters( Vcb, LogRecord->LcnsToFollow ));

                    if (PageLsn != NULL) {
                        *PageLsn = UndoRecordLsn;
                    }

                    NtfsUnpinBcb( IrpContext, &PageBcb );
                }

            //
            //  Keep reading and looping back until we have read the last record
            //  for this transaction.
            //

            } while (LfsReadNextLogRecord( Vcb->LogHandle,
                                           LogContext,
                                           &RecordType,
                                           &TransactionId,
                                           &UndoNextLsn,
                                           &PreviousLsn,
                                           &LogRecordLsn,
                                           &LogRecordLength,
                                           (PVOID *)&LogRecord ));

            //
            //  Now "commit" this guy, just to clean up the transaction table and
            //  make sure we do not try to abort him again.  Also don't wake any
            //  waiters.
            //

            if (IrpContext->CheckNewLength != NULL) {
                NtfsProcessNewLengthQueue( IrpContext, TRUE );
            }

            NtfsCommitCurrentTransaction( IrpContext );

        } finally {

            NtfsUnpinBcb( IrpContext, &PageBcb );

            //
            //  Finally we can kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );

            //
            //  If we raised out of this routine, we want to be sure to remove
            //  this entry from the transaction table.  Otherwise it will
            //  be written to disk with the transaction table.
            //

            if (AbnormalTermination()
                && IrpContext->TransactionId != 0) {

                NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                                  TRUE );

                NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                           IrpContext->TransactionId );

                NtfsReleaseRestartTable( &Vcb->TransactionTable );
            }
        }

    //
    //  This is a wierd case where we are aborting a guy who has not written anything.
    //  Either his empty transaction entry was captured during a checkpoint and we are
    //  in restart, or he failed to write his first log record.  The important thing
    //  is to at least go ahead and free his transaction entry.
    //

    } else {

        //
        //  We can now free the transaction table index, because we are
        //  done with it now.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                          TRUE );

        NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                   IrpContext->TransactionId );

        NtfsReleaseRestartTable( &Vcb->TransactionTable );
    }

    IrpContext->TransactionId = SavedTransaction;

    DebugTrace( -1, Dbg, ("NtfsAbortTransaction->VOID\n") );
}


//
//  Internal support routine
//

VOID
InitializeRestartState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PRESTART_POINTERS DirtyPageTable,
    OUT PATTRIBUTE_NAME_ENTRY *AttributeNames,
    OUT PLSN CheckpointLsn,
    OUT PBOOLEAN UnrecognizedRestart
    )

/*++

Routine Description:

    This routine initializes the volume state for restart, as a first step
    in performing restart on the volume.  Essentially it reads the last
    Ntfs Restart Area on the volume, and then loads all of the Restart
    Tables.  The Open Attribute Table and Transaction Table are allocated,
    read in, and linked to the Vcb in the normal way.  (The names for the
    Open Attribute Table are separately read into pool, in order to fix
    up the Unicode Name Strings in the Attribute Entries, for the duration
    of Restart, after which they must switch over to use the same name as
    in the Scb as they do in the running system.)  In addition, the Dirty
    Pages Table is read and returned directly, since it is only during
    Restart anyway.

    The Checkpoint Lsn is also returned.  This is the Lsn at which the
    Analysis Pass should start.

Arguments:

    Vcb - Vcb for volume which is being restarted.

    DirtyPageTable - Returns the Dirty Page Table read from the log.

    AttributeNames - Returns pointer to AttributeNames buffer, which should
                     be deleted at the end of Restart, if not NULL

    CheckpointLsn - Returns the Checkpoint Lsn to be passed to the
                    Analysis Pass.

    UnrecognizedRestart - Indicates that this version of Ntfs doesn't recognize the
        restart area.  Chkdsk should run to repair the disk.

Return Value:

    None.

--*/

{
    PRESTART_AREA RestartArea;
    RESTART_AREA RestartAreaBuffer[2];
    LFS_LOG_CONTEXT LogContext;
    LSN RestartAreaLsn;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogHeaderLength;
    PATTRIBUTE_NAME_ENTRY Name;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    ULONG RestartAreaLength = 2 * sizeof(RESTART_AREA);
    BOOLEAN CleanupLogContext = FALSE;
    BOOLEAN ReleaseTransactionTable = FALSE;
    BOOLEAN ReleaseAttributeTable = FALSE;
    BOOLEAN ReleaseDirtyPageTable = FALSE;
    PRESTART_POINTERS NewTable = NULL;
    LOG_FILE_INFORMATION LogFileInformation;
    ULONG InfoLength = sizeof(LogFileInformation);
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("InitializeRestartState:\n") );
    DebugTrace( 0, Dbg, ("DirtyPageTable = %08lx\n", DirtyPageTable) );

    *AttributeNames = NULL;
    *CheckpointLsn = Li0;

    //
    //  Use the correct version for the dirty pages.
    //

    NtfsInitializeRestartTable( sizeof( DIRTY_PAGE_ENTRY ) + ((Vcb->ClustersPerPage - 1) * sizeof( LCN )),
                                INITIAL_NUMBER_DIRTY_PAGES,
                                DirtyPageTable );

    //
    //  Read our Restart Area.  Use a larger buffer than this version understands
    //  in case a later version of Ntfs wants to tack some information to
    //  the end of the restart area.
    //

    RestartArea = &RestartAreaBuffer[0];

    if (!NtfsDisableRestart &&
        !FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART )) {
        Status = LfsReadRestartArea( Vcb->LogHandle,
                                     &RestartAreaLength,
                                     RestartArea,
                                     &RestartAreaLsn );

        if (STATUS_BUFFER_TOO_SMALL == Status) {

            RestartArea = NtfsAllocatePool( PagedPool , RestartAreaLength );
            Status = LfsReadRestartArea( Vcb->LogHandle,
                                         &RestartAreaLength,
                                         RestartArea,
                                         &RestartAreaLsn );
        }

        ASSERT( NT_SUCCESS( Status ) );

        DebugTrace( 0, Dbg, ("RestartArea read at %08lx\n", &RestartArea) );
    }

    //
    //  Record the current lsn at this point
    //

    LfsReadLogFileInformation( Vcb->LogHandle,
                               &LogFileInformation,
                               &InfoLength );

    ASSERT( InfoLength != 0 );
    Vcb->CurrentLsnAtMount = LogFileInformation.LastLsn;


    //
    //  If we get back zero for Restart Area Length, then zero it and proceed.
    //  Generally this will only happen on a virgin disk.
    //

    if ((RestartAreaLength == 0) ||
        NtfsDisableRestart ||
        FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART )) {

        RtlZeroMemory( RestartArea, sizeof(RESTART_AREA) );
        RestartAreaLength = sizeof(RESTART_AREA);

    //
    //  If the restart version is unrecognized then use the default.
    //

    } else if ((RestartArea->MajorVersion != 1) &&
               ((RestartArea->MajorVersion != 0) || (RestartArea->MinorVersion != 0))) {

        *UnrecognizedRestart = TRUE;
        RtlZeroMemory( RestartArea, sizeof(RESTART_AREA) );
        RestartAreaLength = sizeof(RESTART_AREA);
        RestartAreaLsn.QuadPart = 0;

    } else {

        //
        //  Use the Restart version number from the disk.  Update the Vcb version if needed.
        //

        if (RestartArea->MajorVersion != Vcb->RestartVersion) {

            NtfsUpdateOatVersion( Vcb, RestartArea->MajorVersion );
        }

        //
        //  If the RestartArea does not include an LowestOpenUsn, then just set it to 0.
        //  Also default the Usn file reference and cache bias to zero.
        //

        if (RestartAreaLength == SIZEOF_OLD_RESTART_AREA) {
            RestartArea->LowestOpenUsn = 0;
            RestartAreaLength = sizeof(RESTART_AREA);

            *((PLONGLONG) &RestartArea->UsnJournalReference) = 0;
            RestartArea->UsnCacheBias = 0;
        }
    }

    Vcb->LowestOpenUsn = RestartArea->LowestOpenUsn;
    Vcb->UsnJournalReference = RestartArea->UsnJournalReference;
    Vcb->UsnCacheBias = 0;

    //
    //  Return the Start Of Checkpoint Lsn.  Typically we can use the value we stored
    //  in our restart area.  The exception is where we have never written a fuzzy
    //  checkpoint since mounting the volume.  In that case the CheckpointLsn will
    //  be zero but we may have log records on the disk.  Use our restart area
    //  Lsn in that case.
    //

    *CheckpointLsn = RestartArea->StartOfCheckpoint;

    if (RestartArea->StartOfCheckpoint.QuadPart == 0) {

        *CheckpointLsn = RestartAreaLsn;
    }

    try {

        //
        //  Allocate and Read in the Transaction Table.
        //

        if (RestartArea->TransactionTableLength != 0) {

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->TransactionTableLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now check that this is a valid restart table.
            //

            if (!NtfsCheckRestartTable( Add2Ptr( LogRecord, LogRecord->RedoOffset ),
                                        RestartAreaLength - LogRecord->RedoOffset)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->TransactionTableLength );

            //
            //  TEMPCODE    RESTART_DEBUG   There is already a buffer.
            //

            NtfsFreePool( Vcb->TransactionTable.Table );

            Vcb->TransactionTable.Table =
              NtfsAllocatePool( NonPagedPool, RestartAreaLength  );

            RtlCopyMemory( Vcb->TransactionTable.Table,
                           Add2Ptr( LogRecord, LogHeaderLength ),
                           RestartAreaLength  );

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;
        }

        //
        //  TEMPCODE    RESTART_DEBUG   There is already a structure.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
        ReleaseTransactionTable = TRUE;

        //
        //  The next record back should be the Dirty Pages Table.
        //

        if (RestartArea->DirtyPageTableLength != 0) {

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->DirtyPageTableLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now check that this is a valid restart table.
            //

            if (!NtfsCheckRestartTable( Add2Ptr( LogRecord, LogRecord->RedoOffset ),
                                        RestartAreaLength - LogRecord->RedoOffset)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->DirtyPageTableLength );

            //
            //  If the version number in the restart table is version 0 then
            //  we need to pull the entries out of the on-disk table and put them
            //  into in-memory version.
            //

            if (RestartArea->MajorVersion == 0) {

                RESTART_POINTERS OldTable;
                PDIRTY_PAGE_ENTRY_V0 OldEntry;
                PDIRTY_PAGE_ENTRY NewEntry;



                OldTable.Table = Add2Ptr( LogRecord, LogHeaderLength );

                //
                //  Check that our assumption about clusters per page matches the data on disk
                //  if not in sync reallocate the table using the number of on disk lcns
                //

                if (OldTable.Table->EntrySize - sizeof( DIRTY_PAGE_ENTRY_V0 ) > DirtyPageTable->Table->EntrySize - sizeof( DIRTY_PAGE_ENTRY )) {

                    DebugTrace(+1, Dbg, ("NTFS: resizing table in initrestartstate\n"));

                    NtfsFreeRestartTable( DirtyPageTable );
                    NtfsInitializeRestartTable( sizeof( DIRTY_PAGE_ENTRY ) + OldTable.Table->EntrySize - sizeof( DIRTY_PAGE_ENTRY_V0 ),
                            INITIAL_NUMBER_DIRTY_PAGES,
                            DirtyPageTable );
                }

                OldEntry = NtfsGetFirstRestartTable( &OldTable );

                while (OldEntry != NULL) {

                    ULONG PageIndex;

                    PageIndex = NtfsAllocateRestartTableIndex( DirtyPageTable, TRUE );
                    NewEntry = GetRestartEntryFromIndex( DirtyPageTable, PageIndex );

                    RtlCopyMemory( NewEntry, OldEntry, FIELD_OFFSET( DIRTY_PAGE_ENTRY_V0, Reserved ));
                    NewEntry->Vcn = OldEntry->Vcn;
                    NewEntry->OldestLsn = OldEntry->OldestLsn;
                    if (NewEntry->LcnsToFollow != 0) {

                        RtlCopyMemory( &NewEntry->LcnsForPage[0],
                                       &OldEntry->LcnsForPage[0],
                                       sizeof( LCN ) * NewEntry->LcnsToFollow );
                    }

                    OldEntry = NtfsGetNextRestartTable( &OldTable, OldEntry );
                }

            } else {

                //
                //  Simply copy the old data over.
                //

                NtfsFreePool( DirtyPageTable->Table );
                DirtyPageTable->Table = NULL;
                DirtyPageTable->Table =
                  NtfsAllocatePool( NonPagedPool, RestartAreaLength );

                RtlCopyMemory( DirtyPageTable->Table,
                               Add2Ptr( LogRecord, LogHeaderLength ),
                               RestartAreaLength );
            }

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;

            //
            //  If the cluster size is larger than the page size we may have
            //  multiple entries for the same Vcn.  Go through the table
            //  and remove the duplicates, remembering the oldest Lsn values.
            //

            if (Vcb->BytesPerCluster > PAGE_SIZE) {

                PDIRTY_PAGE_ENTRY CurrentEntry;
                PDIRTY_PAGE_ENTRY NextEntry;

                CurrentEntry = NtfsGetFirstRestartTable( DirtyPageTable );

                while (CurrentEntry != NULL) {

                    NextEntry = CurrentEntry;

                    while ((NextEntry = NtfsGetNextRestartTable( DirtyPageTable, NextEntry )) != NULL) {

                        if ((NextEntry->TargetAttribute == CurrentEntry->TargetAttribute) &&
                            (NextEntry->Vcn == CurrentEntry->Vcn)) {

                            if (NextEntry->OldestLsn.QuadPart < CurrentEntry->OldestLsn.QuadPart) {

                                CurrentEntry->OldestLsn.QuadPart = NextEntry->OldestLsn.QuadPart;
                            }

                            NtfsFreeRestartTableIndex( DirtyPageTable,
                                                       GetIndexFromRestartEntry( DirtyPageTable,
                                                                                 NextEntry ));
                        }
                    }

                    CurrentEntry = NtfsGetNextRestartTable( DirtyPageTable, CurrentEntry );
                }
            }
        }

        NtfsAcquireExclusiveRestartTable( DirtyPageTable, TRUE );
        ReleaseDirtyPageTable = TRUE;

        //
        //  The next record back should be the Attribute Names.
        //

        if (RestartArea->AttributeNamesLength != 0) {

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->AttributeNamesLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->AttributeNamesLength );

            *AttributeNames =
              NtfsAllocatePool( NonPagedPool, RestartAreaLength );

            RtlCopyMemory( *AttributeNames,
                           Add2Ptr( LogRecord, LogHeaderLength ),
                           RestartAreaLength );

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;
        }

        //
        //  The next record back should be the Attribute Table.
        //

        if (RestartArea->OpenAttributeTableLength != 0) {

            POPEN_ATTRIBUTE_ENTRY OpenEntry;

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->OpenAttributeTableLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now check that this is a valid restart table.
            //

            if (!NtfsCheckRestartTable( Add2Ptr( LogRecord, LogRecord->RedoOffset ),
                                        RestartAreaLength - LogRecord->RedoOffset)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->OpenAttributeTableLength );

            //
            //  If the restart version is version 0 then we need to create
            //  a corresponding in-memory structure and refer back to it.
            //

            if (RestartArea->MajorVersion == 0) {

                POPEN_ATTRIBUTE_ENTRY_V0 OldEntry;

                NewTable = NtfsAllocatePool( NonPagedPool, RestartAreaLength );

                NtfsFreePool( Vcb->OnDiskOat->Table );
                Vcb->OnDiskOat->Table = (PRESTART_TABLE) NewTable;
                NewTable = NULL;

                RtlCopyMemory( Vcb->OnDiskOat->Table,
                               Add2Ptr( LogRecord, LogHeaderLength ),
                               RestartAreaLength );

                //
                //  Now for each entry in this table create one in our in-memory version.
                //

                OldEntry = NtfsGetFirstRestartTable( Vcb->OnDiskOat );

                while (OldEntry != NULL) {

                    //
                    //  Allocate the attribute data structure.
                    //

                    NewTable = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    RtlZeroMemory( NewTable, sizeof( OPEN_ATTRIBUTE_DATA ));

                    //
                    //  Now get an new index for the data.
                    //

                    OldEntry->OatIndex = NtfsAllocateRestartTableIndex( &Vcb->OpenAttributeTable, TRUE );

                    //
                    //  Initialize the new entry with data from the on-disk entry.
                    //

                    OpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, OldEntry->OatIndex );
                    InsertTailList( &Vcb->OpenAttributeData, &((POPEN_ATTRIBUTE_DATA) NewTable)->Links );
                    OpenEntry->OatData = (POPEN_ATTRIBUTE_DATA) NewTable;
                    NewTable = NULL;

                    OpenEntry->OatData->OnDiskAttributeIndex = GetIndexFromRestartEntry( Vcb->OnDiskOat,
                                                                                         OldEntry );
                    OpenEntry->BytesPerIndexBuffer = OldEntry->BytesPerIndexBuffer;
                    OpenEntry->AttributeTypeCode = OldEntry->AttributeTypeCode;
                    OpenEntry->FileReference = OldEntry->FileReference;
                    OpenEntry->LsnOfOpenRecord.QuadPart = OldEntry->LsnOfOpenRecord.QuadPart;

                    OldEntry = NtfsGetNextRestartTable( Vcb->OnDiskOat, OldEntry );
                }

            //
            //  If the restart version is version 1 then simply copy it over.
            //  We also need to allocate the auxiliary data structure.
            //

            } else {

                //
                //  TEMPCODE    RESTART_DEBUG   There is already a buffer.
                //

                NewTable = NtfsAllocatePool( NonPagedPool, RestartAreaLength );
                NtfsFreePool( Vcb->OpenAttributeTable.Table );
                Vcb->OpenAttributeTable.Table = (PRESTART_TABLE) NewTable;
                NewTable = NULL;

                RtlCopyMemory( Vcb->OpenAttributeTable.Table,
                               Add2Ptr( LogRecord, LogHeaderLength ),
                               RestartAreaLength );


                //
                //  First loop to clear all of the Scb pointers in case we
                //  have a premature abort and want to clean up.
                //

                OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

                //
                //  Loop to end of table.
                //

                while (OpenEntry != NULL) {

                    //
                    //  Allocate the attribute data structure.
                    //

                    NewTable = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    RtlZeroMemory( NewTable, sizeof( OPEN_ATTRIBUTE_DATA ));

                    InsertTailList( &Vcb->OpenAttributeData, &((POPEN_ATTRIBUTE_DATA) NewTable)->Links );
                    OpenEntry->OatData = (POPEN_ATTRIBUTE_DATA) NewTable;
                    NewTable = NULL;

                    //
                    //  The on-disk index is the same as the in-memory index.
                    //

                    OpenEntry->OatData->OnDiskAttributeIndex = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                                                                         OpenEntry );
                    //
                    //  Point to next entry in table, or NULL.
                    //

                    OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                         OpenEntry );
                }
            }

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;
        }

        //
        //  Here is a case where there was no attribute table on disk.  Make sure we have the
        //  correct on-disk version in the Vcb if this is version 0.
        //

        ASSERT( (RestartArea->OpenAttributeTableLength != 0) ||
                (Vcb->RestartVersion != 0) ||
                (Vcb->OnDiskOat != NULL) );

        //
        //  TEMPCODE    RESTART_DEBUG   There is already a structure.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
        ReleaseAttributeTable = TRUE;

        //
        //  The only other thing we have to do before returning is patch up the
        //  Unicode String's in the Attribute Table to point to their respective
        //  attribute names.
        //

        if (RestartArea->AttributeNamesLength != 0) {

            Name = *AttributeNames;

            while (Name->Index != 0) {

                POPEN_ATTRIBUTE_ENTRY Entry;

                if (!IsRestartIndexWithinTable( Vcb->OnDiskOat, Name->Index )) {
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                Entry = GetRestartEntryFromIndex( Vcb->OnDiskOat, Name->Index );

                //
                //  Check if we have a level of indirection.
                //

                if (Vcb->RestartVersion == 0) {

                    if (!IsRestartIndexWithinTable( &Vcb->OpenAttributeTable, ((POPEN_ATTRIBUTE_ENTRY_V0) Entry)->OatIndex )) {
                        NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                    }

                    Entry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                      ((POPEN_ATTRIBUTE_ENTRY_V0) Entry)->OatIndex );
                }

                Entry->OatData->AttributeName.MaximumLength =
                Entry->OatData->AttributeName.Length = Name->NameLength;
                Entry->OatData->AttributeName.Buffer = (PWSTR)&Name->Name[0];

                Name = (PATTRIBUTE_NAME_ENTRY)((PCHAR)Name +
                                               sizeof(ATTRIBUTE_NAME_ENTRY) +
                                               (ULONG)Name->NameLength );
            }
        }

    } finally {

        //
        //  Release any transaction tables we acquired if we raised during
        //   this routine.
        //

        if (AbnormalTermination()) {

            if (ReleaseTransactionTable) {
                NtfsReleaseRestartTable( &Vcb->TransactionTable );
            }

            if (ReleaseAttributeTable) {
                NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
            }

            if (ReleaseDirtyPageTable) {
                NtfsReleaseRestartTable( DirtyPageTable );
            }
        }

        if (CleanupLogContext) {

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
        }

        //
        //  Did we fail to create the new table.
        //

        if (NewTable != NULL) {

            NtfsFreePool( NewTable );
        }

        //
        //  If we allocated a restart area rather than using the stack
        //  free it here
        //

        if (RestartArea != &RestartAreaBuffer[0]) {

            NtfsFreePool( RestartArea );
        }
    }

    DebugTrace( 0, Dbg, ("AttributeNames > %08lx\n", *AttributeNames) );
    DebugTrace( 0, Dbg, ("CheckpointLsn > %016I64x\n", *CheckpointLsn) );
    DebugTrace( -1, Dbg, ("NtfsInitializeRestartState -> VOID\n") );
}


VOID
ReleaseRestartState (
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable,
    IN PATTRIBUTE_NAME_ENTRY AttributeNames,
    IN BOOLEAN ReleaseVcbTables
    )

/*++

Routine Description:

    This routine releases all of the restart state.

Arguments:

    Vcb - Vcb for the volume being restarted.

    DirtyPageTable - pointer to the dirty page table, if one was allocated.

    AttributeNames - pointer to the attribute names buffer, if one was allocated.

    ReleaseVcbTables - TRUE if we are to release the restart tables in the Vcb,
        FALSE otherwise.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  If the caller successfully had a successful restart, then we must release
    //  the transaction and open attribute tables.
    //

    if (ReleaseVcbTables) {
        NtfsReleaseRestartTable( &Vcb->TransactionTable );
        NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
    }

    //
    //  Free the dirty page table, if there is one.
    //

    if (DirtyPageTable != NULL) {
        NtfsFreeRestartTable( DirtyPageTable );
    }

    //
    //  Free the temporary attribute names buffer, if there is one.
    //

    if (AttributeNames != NULL) {
        NtfsFreePool( AttributeNames );
    }
}


//
//  Internal support routine
//

VOID
AnalysisPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN CheckpointLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    OUT PLSN RedoLsn
    )

/*++

Routine Description:

    This routine performs the analysis phase of Restart.  Starting at
    the CheckpointLsn, it reads all records written by Ntfs, and takes
    the following actions:

        For all log records which create or update attributes, a check is
        made to see if the affected page(s) are already in the Dirty Pages
        Table.  For any page that is not, it is added, and the OldestLsn
        field is set to the Lsn of the log record.

        The transaction table is updated on transaction state changes,
        and also to maintain the PreviousLsn and UndoNextLsn fields.

        If any attributes are truncated or deleted (including delete of
        an entire file), then any corrsponding pages in the Dirty Page
        Table are deleted.

        When attributes or entire files are deleted, the respective entries
        are deleted from the Open Attribute Table.

        For Hot Fix records, the Dirty Pages Table is scanned for the HotFixed
        Vcn, and if one is found, the Lcn field in the table is updated to
        the new location.

    When the end of the log file is encountered, the Dirty Page Table is
    scanned for the Oldest of the OldestLsn fields.  This value is returned
    as the RedoLsn, i.e., the point at which the Redo Pass must occur.

Arguments:

    Vcb - Volume which is being restarted.

    CheckpointLsn - Lsn at which the Analysis Pass is to begin.

    DirtyPageTable - Pointer to a pointer to the Dirty Page Table, as
                     found from the last Restart Area.

    RedoLsn - Returns point at which the Redo Pass should begin.

Return Value:

    None.

--*/

{
    LFS_LOG_CONTEXT LogContext;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogRecordLength;
    LSN LogRecordLsn = CheckpointLsn;
    PRESTART_POINTERS TransactionTable = &Vcb->TransactionTable;
    PRESTART_POINTERS OpenAttributeTable = &Vcb->OpenAttributeTable;
    LFS_LOG_HANDLE LogHandle = Vcb->LogHandle;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    PTRANSACTION_ENTRY Transaction;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    POPEN_ATTRIBUTE_DATA OatData = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("AnalysisPass:\n") );
    DebugTrace( 0, Dbg, ("CheckpointLsn = %016I64x\n", CheckpointLsn) );

    *RedoLsn = Li0; //**** LfsZeroLsn;

    //
    //  Read the first Lsn.
    //

    LfsReadLogRecord( LogHandle,
                      CheckpointLsn,
                      LfsContextForward,
                      &LogContext,
                      &RecordType,
                      &TransactionId,
                      &UndoNextLsn,
                      &PreviousLsn,
                      &LogRecordLength,
                      (PVOID *)&LogRecord );

    //
    //  Use a try-finally to cleanup the query context.
    //

    try {

        //
        //  Since the checkpoint remembers the previous Lsn, not the one he wants to
        //  start at, we must always skip the first record.
        //
        //  Loop to read all subsequent records to the end of the log file.
        //

        while ( LfsReadNextLogRecord( LogHandle,
                                      LogContext,
                                      &RecordType,
                                      &TransactionId,
                                      &UndoNextLsn,
                                      &PreviousLsn,
                                      &LogRecordLsn,
                                      &LogRecordLength,
                                      (PVOID *)&LogRecord )) {

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     LogRecordLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  The first Lsn after the previous Lsn remembered in the checkpoint is
            //  the first candidate for the RedoLsn.
            //

            if (RedoLsn->QuadPart == 0) {
                *RedoLsn = LogRecordLsn;
            }

            if (RecordType != LfsClientRecord) {
                continue;
            }

            DebugTrace( 0, Dbg, ("Analysis of LogRecord at: %08lx\n", LogRecord) );
            DebugTrace( 0, Dbg, ("Log Record Lsn = %016I64x\n", LogRecordLsn) );
            DebugTrace( 0, Dbg, ("LogRecord->RedoOperation = %08lx\n", LogRecord->RedoOperation) );
            DebugTrace( 0, Dbg, ("TransactionId = %08lx\n", TransactionId) );

            //
            //  Now update the Transaction Table for this transaction.  If there is no
            //  entry present or it is unallocated we allocate the entry.
            //

            Transaction = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex( &Vcb->TransactionTable,
                                                                        TransactionId );

            if (!IsRestartIndexWithinTable( &Vcb->TransactionTable, TransactionId ) ||
                !IsRestartTableEntryAllocated( Transaction )) {

                Transaction = (PTRANSACTION_ENTRY) NtfsAllocateRestartTableFromIndex( &Vcb->TransactionTable,
                                                                                      TransactionId );

                Transaction->TransactionState = TransactionActive;
                Transaction->FirstLsn = LogRecordLsn;
            }

            Transaction->PreviousLsn =
            Transaction->UndoNextLsn = LogRecordLsn;

            //
            //  If this is a compensation log record (CLR), then change the UndoNextLsn to
            //  be the UndoNextLsn of this record.
            //

            if (LogRecord->UndoOperation == CompensationLogRecord) {

                Transaction->UndoNextLsn = UndoNextLsn;
            }

            //
            //  Dispatch to handle log record depending on type.
            //

            switch (LogRecord->RedoOperation) {

            //
            //  The following cases are performing various types of updates
            //  and need to make the appropriate updates to the Transaction
            //  and Dirty Page Tables.
            //

            case InitializeFileRecordSegment:
            case DeallocateFileRecordSegment:
            case WriteEndOfFileRecordSegment:
            case CreateAttribute:
            case DeleteAttribute:
            case UpdateResidentValue:
            case UpdateNonresidentValue:
            case UpdateMappingPairs:
            case SetNewAttributeSizes:
            case AddIndexEntryRoot:
            case DeleteIndexEntryRoot:
            case AddIndexEntryAllocation:
            case DeleteIndexEntryAllocation:
            case WriteEndOfIndexBuffer:
            case SetIndexEntryVcnRoot:
            case SetIndexEntryVcnAllocation:
            case UpdateFileNameRoot:
            case UpdateFileNameAllocation:
            case SetBitsInNonresidentBitMap:
            case ClearBitsInNonresidentBitMap:
            case UpdateRecordDataRoot:
            case UpdateRecordDataAllocation:

                PageUpdateAnalysis( Vcb,
                                    LogRecordLsn,
                                    DirtyPageTable,
                                    LogRecord );

                break;

            //
            //  This case is deleting clusters from a nonresident attribute,
            //  thus it deletes a range of pages from the Dirty Page Table.
            //  This log record is written each time a nonresident attribute
            //  is truncated, whether explicitly or as part of deletion.
            //
            //  Processing one of these records is pretty compute-intensive
            //  (three nested loops, where a couple of them can be large),
            //  but this is the code that prevents us from dropping, for example,
            //  index updates into the middle of user files, if the index stream
            //  is truncated and the sectors are reallocated to a user file
            //  and we crash after the user data has been written.
            //
            //  I.e., note the following sequence:
            //
            //      <checkpoint>
            //      <Index update>
            //      <Index page deleted>
            //      <Same cluster(s) reallocated to user file>
            //      <User data written>
            //
            //      CRASH!
            //
            //  Since the user data was not logged (else there would be no problem),
            //  It could get overwritten while applying the index update after a
            //  crash - Pisses off the user as well as the security dudes!
            //

            case DeleteDirtyClusters:

                {
                    PDIRTY_PAGE_ENTRY DirtyPage;
                    PLCN_RANGE LcnRange;
                    ULONG i, j;
                    LCN FirstLcn, LastLcn;
                    ULONG RangeCount = LogRecord->RedoLength / sizeof(LCN_RANGE);

                    //
                    //  Point to the Lcn range array.
                    //

                    LcnRange = Add2Ptr(LogRecord, LogRecord->RedoOffset);

                    //
                    //  Loop through all of the Lcn ranges in this log record.
                    //

                    for (i = 0; i < RangeCount; i++) {

                        FirstLcn = LcnRange[i].StartLcn;
                        LastLcn = FirstLcn + (LcnRange[i].Count - 1);

                        DebugTrace( 0, Dbg, ("Deleting from FirstLcn = %016I64x\n", FirstLcn));
                        DebugTrace( 0, Dbg, ("Deleting to LastLcn =  %016I64x\n", LastLcn ));

                        //
                        //  Point to first Dirty Page Entry.
                        //

                        DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

                        //
                        //  Loop to end of table.
                        //

                        while (DirtyPage != NULL) {

                            //
                            //  Loop through all of the Lcns for this dirty page.
                            //

                            for (j = 0; j < (ULONG)DirtyPage->LcnsToFollow; j++) {

                                if ((DirtyPage->LcnsForPage[j] >= FirstLcn) &&
                                    (DirtyPage->LcnsForPage[j] <= LastLcn)) {

                                    DirtyPage->LcnsForPage[j] = 0;
                                }
                            }

                            //
                            //  Point to next entry in table, or NULL.
                            //

                            DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                                                 DirtyPage );
                        }
                    }
                }

                break;

            //
            //  When a record is encountered for a nonresident attribute that
            //  was opened, we have to add an entry to the Open Attribute Table.
            //

            case OpenNonresidentAttribute:

                {
                    POPEN_ATTRIBUTE_ENTRY AttributeEntry;
                    ULONG NameSize;

                    //
                    //  If the table is not currently big enough, then we must
                    //  expand it.
                    //

                    if (!IsRestartIndexWithinTable( Vcb->OnDiskOat,
                                                    (ULONG)LogRecord->TargetAttribute )) {

                        ULONG NeededEntries;

                        //
                        //  Compute how big the table needs to be.  Add 10 extra entries
                        //  for some cushion.
                        //

                        NeededEntries = (LogRecord->TargetAttribute / Vcb->OnDiskOat->Table->EntrySize);
                        NeededEntries = (NeededEntries + 10 - Vcb->OnDiskOat->Table->NumberEntries);

                        NtfsExtendRestartTable( Vcb->OnDiskOat,
                                                NeededEntries,
                                                MAXULONG );
                    }

                    ASSERT( IsRestartIndexWithinTable( Vcb->OnDiskOat,
                                                       (ULONG)LogRecord->TargetAttribute ));

                    //
                    //  Calculate size of Attribute Name Entry, if there is one.
                    //

                    NameSize = LogRecord->UndoLength;

                    //
                    //  Point to the entry being opened.
                    //

                    OatData = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    RtlZeroMemory( OatData, sizeof( OPEN_ATTRIBUTE_DATA ));

                    OatData->OnDiskAttributeIndex = LogRecord->TargetAttribute;

                    AttributeEntry = NtfsAllocateRestartTableFromIndex( Vcb->OnDiskOat,
                                                                        LogRecord->TargetAttribute );

                    //
                    //  The attribute entry better either not be allocated or it must
                    //  be for the same file.
                    //

                    //  **** May eliminate this test.
                    //
                    //  ASSERT( !IsRestartTableEntryAllocated(AttributeEntry) ||
                    //          xxEql(AttributeEntry->FileReference,
                    //                ((POPEN_ATTRIBUTE_ENTRY)Add2Ptr(LogRecord,
                    //                                                LogRecord->RedoOffset))->FileReference));

                    //
                    //  Initialize this entry from the log record.
                    //

                    ASSERT( LogRecord->RedoLength == Vcb->OnDiskOat->Table->EntrySize );

                    RtlCopyMemory( AttributeEntry,
                                   (PCHAR)LogRecord + LogRecord->RedoOffset,
                                   LogRecord->RedoLength );

                    ASSERT( IsRestartTableEntryAllocated(AttributeEntry) );

                    //
                    //  Get a new entry for the in-memory copy if needed.
                    //

                    if (Vcb->RestartVersion == 0) {

                        POPEN_ATTRIBUTE_ENTRY_V0 OldEntry = (POPEN_ATTRIBUTE_ENTRY_V0) AttributeEntry;
                        ULONG NewIndex;

                        NewIndex = NtfsAllocateRestartTableIndex( &Vcb->OpenAttributeTable, TRUE );
                        AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, NewIndex );

                        AttributeEntry->BytesPerIndexBuffer = OldEntry->BytesPerIndexBuffer;

                        AttributeEntry->AttributeTypeCode = OldEntry->AttributeTypeCode;
                        AttributeEntry->FileReference = OldEntry->FileReference;
                        AttributeEntry->LsnOfOpenRecord.QuadPart = OldEntry->LsnOfOpenRecord.QuadPart;

                        OldEntry->OatIndex = NewIndex;

                    }

                    //
                    //  Finish initializing the AttributeData.
                    //

                    AttributeEntry->OatData = OatData;
                    InsertTailList( &Vcb->OpenAttributeData, &OatData->Links );
                    OatData = NULL;

                    //
                    //  If there is a name at the end, then allocate space to
                    //  copy it into, and do the copy.  We also set the buffer
                    //  pointer in the string descriptor, although note that the
                    //  lengths must be correct.
                    //

                    if (NameSize != 0) {

                        AttributeEntry->OatData->Overlay.AttributeName =
                          NtfsAllocatePool( NonPagedPool, NameSize );
                        RtlCopyMemory( AttributeEntry->OatData->Overlay.AttributeName,
                                       Add2Ptr(LogRecord, LogRecord->UndoOffset),
                                       NameSize );

                        AttributeEntry->OatData->AttributeName.Buffer = AttributeEntry->OatData->Overlay.AttributeName;

                        AttributeEntry->OatData->AttributeNamePresent = TRUE;

                    //
                    //  Otherwise, show there is no name.
                    //

                    } else {
                        AttributeEntry->OatData->Overlay.AttributeName = NULL;
                        AttributeEntry->OatData->AttributeName.Buffer = NULL;
                        AttributeEntry->OatData->AttributeNamePresent = FALSE;
                    }

                    AttributeEntry->OatData->AttributeName.MaximumLength =
                    AttributeEntry->OatData->AttributeName.Length = (USHORT) NameSize;
                }

                break;

            //
            //  For HotFix records, we need to update the Lcn in the Dirty Page
            //  Table.
            //

            case HotFix:

                {
                    PDIRTY_PAGE_ENTRY DirtyPage;

                    //
                    //  First see if the Vcn is currently in the Dirty Page
                    //  Table.  If not, there is nothing to do.
                    //

                    if (FindDirtyPage( DirtyPageTable,
                                       LogRecord->TargetAttribute,
                                       LogRecord->TargetVcn,
                                       &DirtyPage )) {

                        //
                        //  Index to the Lcn in question in the Dirty Page Entry
                        //  and rewrite it with the Hot Fixed Lcn from the log
                        //  record.  Note that it is ok to just use the LowPart
                        //  of the Vcns to calculate the array offset, because
                        //  any multiple of 2**32 is guaranteed to be on a page
                        //  boundary!
                        //

                        if (DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn)] != 0) {

                            DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn)] = LogRecord->LcnsForPage[0];
                        }
                    }
                }

                break;

            //
            //  For end top level action, we will just update the transaction
            //  table to skip the top level action on undo.
            //

            case EndTopLevelAction:

                {
                    PTRANSACTION_ENTRY Transaction;

                    //
                    //  Now update the Transaction Table for this transaction.
                    //

                    Transaction = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex( &Vcb->TransactionTable,
                                                                                TransactionId );

                    Transaction->PreviousLsn = LogRecordLsn;
                    Transaction->UndoNextLsn = UndoNextLsn;

                }

                break;

            //
            //  For Prepare Transaction, we just change the state of our entry.
            //

            case PrepareTransaction:

                {
                    PTRANSACTION_ENTRY CurrentEntry;

                    CurrentEntry = GetRestartEntryFromIndex( &Vcb->TransactionTable,
                                                             TransactionId );

                    ASSERT( !IsRestartTableEntryAllocated( CurrentEntry ));

                    CurrentEntry->TransactionState = TransactionPrepared;
                }

                break;

            //
            //  For Commit Transaction, we just change the state of our entry.
            //

            case CommitTransaction:

                {
                    PTRANSACTION_ENTRY CurrentEntry;

                    CurrentEntry = GetRestartEntryFromIndex( &Vcb->TransactionTable,
                                                             TransactionId );

                    ASSERT( !IsRestartTableEntryAllocated( CurrentEntry ));

                    CurrentEntry->TransactionState = TransactionCommitted;
                }

                break;

            //
            //  For forget, we can delete our transaction entry, since the transaction
            //  will not have to be aborted.
            //

            case ForgetTransaction:

                {
                    NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                               TransactionId );
                }

                break;

            //
            //  The following cases require no action in the Analysis Pass.
            //

            case Noop:
            case OpenAttributeTableDump:
            case AttributeNamesDump:
            case DirtyPageTableDump:
            case TransactionTableDump:

                break;

            //
            //  All codes will be explicitly handled.  If we see a code we
            //  do not expect, then we are in trouble.
            //

            default:

                DebugTrace( 0, Dbg, ("Unexpected Log Record Type: %04lx\n", LogRecord->RedoOperation) );
                DebugTrace( 0, Dbg, ("Record address: %08lx\n", LogRecord) );
                DebugTrace( 0, Dbg, ("Record length: %08lx\n", LogRecordLength) );

                ASSERTMSG( "Unknown Action!\n", FALSE );

                break;
            }
        }

    } finally {

        //
        //  Finally we can kill the log handle.
        //

        LfsTerminateLogQuery( LogHandle, LogContext );

        if (OatData != NULL) { NtfsFreePool( OatData ); }
    }

    //
    //  Now we just have to scan the Dirty Page Table and Transaction Table
    //  for the lowest Lsn, and return it as the Redo Lsn.
    //

    {
        PDIRTY_PAGE_ENTRY DirtyPage;

        //
        //  Point to first Dirty Page Entry.
        //

        DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

        //
        //  Loop to end of table.
        //

        while (DirtyPage != NULL) {

            //
            //  Update the Redo Lsn if this page has an older one.
            //

            if ((DirtyPage->OldestLsn.QuadPart != 0) &&
                (DirtyPage->OldestLsn.QuadPart < RedoLsn->QuadPart)) {

                *RedoLsn = DirtyPage->OldestLsn;
            }

            //
            //  Point to next entry in table, or NULL.
            //

            DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                                 DirtyPage );
        }
    }

    {
        PTRANSACTION_ENTRY Transaction;

        //
        //  Point to first Transaction Entry.
        //

        Transaction = NtfsGetFirstRestartTable( &Vcb->TransactionTable );

        //
        //  Loop to end of table.
        //

        while (Transaction != NULL) {

            //
            //  Update the Redo Lsn if this transaction has an older one.
            //

            if ((Transaction->FirstLsn.QuadPart != 0) &&
                (Transaction->FirstLsn.QuadPart < RedoLsn->QuadPart)) {

                *RedoLsn = Transaction->FirstLsn;
            }

            //
            //  Point to next entry in table, or NULL.
            //

            Transaction = NtfsGetNextRestartTable( &Vcb->TransactionTable,
                                                   Transaction );
        }
    }

    DebugTrace( 0, Dbg, ("RedoLsn > %016I64x\n", *RedoLsn) );
    DebugTrace( 0, Dbg, ("AnalysisPass -> VOID\n") );
}


//
//  Internal support routine
//

VOID
RedoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN RedoLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable
    )

/*++

Routine Description:

    This routine performs the Redo Pass of Restart.  Beginning at the
    Redo Lsn established during the Analysis Pass, the redo operations
    of all log records are applied, until the end of file is encountered.

    Updates are only applied to clusters in the dirty page table.  If a
    cluster was deleted, then its entry will have been deleted during the
    Analysis Pass.

    The Redo actions are all performed in the common routine DoAction,
    which is also used by the Undo Pass.

Arguments:

    Vcb - Volume which is being restarted.

    RedoLsn - Lsn at which the Redo Pass is to begin.

    DirtyPageTable - Pointer to the Dirty Page Table, as reconstructed
                     from the Analysis Pass.

Return Value:

    None.

--*/

{
    LFS_LOG_CONTEXT LogContext;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogRecordLength;
    PVOID Data;
    ULONG Length;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    ULONG i, SavedLength;

    LSN LogRecordLsn = RedoLsn;
    LFS_LOG_HANDLE LogHandle = Vcb->LogHandle;
    PBCB PageBcb = NULL;
    BOOLEAN GeneratedUsnBias = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("RedoPass:\n") );
    DebugTrace( 0, Dbg, ("RedoLsn = %016I64x\n", RedoLsn) );
    DebugTrace( 0, Dbg, ("DirtyPageTable = %08lx\n", DirtyPageTable) );

    //
    //  If the dirty page table is empty, then we can skip the entire Redo Pass.
    //

    if (IsRestartTableEmpty( DirtyPageTable )) {
        return;
    }

    //
    //  Read the record at the Redo Lsn, before falling into common code
    //  to handle each record.
    //

    LfsReadLogRecord( LogHandle,
                      RedoLsn,
                      LfsContextForward,
                      &LogContext,
                      &RecordType,
                      &TransactionId,
                      &UndoNextLsn,
                      &PreviousLsn,
                      &LogRecordLength,
                      (PVOID *)&LogRecord );

    //
    //  Now loop to read all of our log records forwards, until we hit
    //  the end of the file, cleaning up at the end.
    //

    try {

        do {

            PDIRTY_PAGE_ENTRY DirtyPage;
            PLSN PageLsn;
            BOOLEAN FoundPage;

            if (RecordType != LfsClientRecord) {
                continue;
            }

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     LogRecordLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            DebugTrace( 0, Dbg, ("Redo of LogRecord at: %08lx\n", LogRecord) );
            DebugTrace( 0, Dbg, ("Log Record Lsn = %016I64x\n", LogRecordLsn) );

            //
            //  Ignore log records that do not update pages.
            //

            if (LogRecord->LcnsToFollow == 0) {

                DebugTrace( 0, Dbg, ("Skipping log record (no update)\n") );

                continue;
            }

            //
            //  Consult Dirty Page Table to see if we have to apply this update.
            //  If the page is not there, or if the Lsn of this Log Record is
            //  older than the Lsn in the Dirty Page Table, then we do not have
            //  to apply the update.
            //

            FoundPage = FindDirtyPage( DirtyPageTable,
                                       LogRecord->TargetAttribute,
                                       LogRecord->TargetVcn,
                                       &DirtyPage );

            if (!FoundPage

                    ||

                (LogRecordLsn.QuadPart < DirtyPage->OldestLsn.QuadPart)) {

                DebugDoit(

                    DebugTrace( 0, Dbg, ("Skipping log record operation %08lx\n",
                                         LogRecord->RedoOperation ));

                    if (!FoundPage) {
                        DebugTrace( 0, Dbg, ("Page not in dirty page table\n") );
                    } else {
                        DebugTrace( 0, Dbg, ("Page Lsn more current: %016I64x\n",
                                              DirtyPage->OldestLsn) );
                    }
                );

                continue;

            //
            //  We also skip the update if the entry was never put in the Mcb for
            //  the file.

            } else {

                POPEN_ATTRIBUTE_ENTRY ThisEntry;
                PSCB TargetScb;
                LCN TargetLcn;

                //
                //  Check that the entry is within the table and is allocated.
                //

                if (!IsRestartIndexWithinTable( Vcb->OnDiskOat,
                                                LogRecord->TargetAttribute )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                ThisEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat, LogRecord->TargetAttribute );

                if (!IsRestartTableEntryAllocated( ThisEntry )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  Check if we need to go to a different restart table.
                //

                if (Vcb->RestartVersion == 0) {

                    ThisEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                          ((POPEN_ATTRIBUTE_ENTRY_V0) ThisEntry)->OatIndex );
                }

                TargetScb = ThisEntry->OatData->Overlay.Scb;

                //
                //  If there is no Scb it means that we don't have an entry in Open
                //  Attribute Table for this attribute.
                //

                if (TargetScb == NULL) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                if (!NtfsLookupNtfsMcbEntry( &TargetScb->Mcb,
                                             LogRecord->TargetVcn,
                                             &TargetLcn,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL ) ||

                    (TargetLcn == UNUSED_LCN)) {

                    DebugTrace( 0, Dbg, ("Clusters removed from page entry\n") );
                    continue;
                }

                //
                //  Check if we need to generate the usncachebias.
                //  Since we read log records fwd the usn offsets are also going to be
                //  monotonic - the 1st one we see will be the farthest back
                //

                if (FlagOn( TargetScb->ScbPersist, SCB_PERSIST_USN_JOURNAL ) &&
                    !GeneratedUsnBias) {

                    LONGLONG ClusterOffset;
                    LONGLONG FileOffset;

                    if (LogRecord->RedoLength > 0) {

                        ClusterOffset = BytesFromLogBlocks( LogRecord->ClusterBlockOffset );
                        FileOffset = LlBytesFromClusters( Vcb, LogRecord->TargetVcn ) + ClusterOffset;

                        ASSERT( FileOffset >= Vcb->UsnCacheBias );

                        Vcb->UsnCacheBias = FileOffset & ~(USN_JOURNAL_CACHE_BIAS - 1);
                        if (Vcb->UsnCacheBias != 0) {
                            Vcb->UsnCacheBias -= USN_JOURNAL_CACHE_BIAS;
                        }

#ifdef BENL_DBG
                        if (Vcb->UsnCacheBias != 0) {
                            KdPrint(( "Ntfs: vcb:0x%x restart cache bias: 0x%x\n", Vcb, Vcb->UsnCacheBias ));
                        }
#endif
                    }
                    GeneratedUsnBias = TRUE;
                }
            }

            //
            //  Point to the Redo Data and get its length.
            //

            Data = (PVOID)((PCHAR)LogRecord + LogRecord->RedoOffset);
            Length = LogRecord->RedoLength;

            //
            //  Shorten length by any Lcns which were deleted.
            //

            SavedLength = Length;

            for (i = (ULONG)LogRecord->LcnsToFollow; i != 0; i--) {

                ULONG AllocatedLength;
                ULONG VcnOffset;

                VcnOffset = BytesFromLogBlocks( LogRecord->ClusterBlockOffset ) + LogRecord->RecordOffset + LogRecord->AttributeOffset;

                //
                //  If the Vcn in question is allocated, we can just get out.
                //

                if (DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn) + i - 1] != 0) {
                    break;
                }

                //
                //  The only log records that update pages but have a length of zero
                //  are deleting things from Usa-protected structures.  If we hit such
                //  a log record and any Vcn has been deleted within the Usa structure,
                //  let us assume that the entire Usa structure has been deleted.  Change
                //  the SavedLength to be nonzero to cause us to skip this log record
                //  at the end of this for loop!
                //

                if (SavedLength == 0) {
                    SavedLength = 1;
                }

                //
                //  Calculate the allocated space left relative to the log record Vcn,
                //  after removing this unallocated Vcn.
                //

                AllocatedLength = BytesFromClusters( Vcb, i - 1 );

                //
                //  If the update described in this log record goes beyond the allocated
                //  space, then we will have to reduce the length.
                //

                if ((VcnOffset + Length) > AllocatedLength) {

                    //
                    //  If the specified update starts at or beyond the allocated length, then
                    //  we must set length to zero.
                    //

                    if (VcnOffset >= AllocatedLength) {

                        Length = 0;

                    //
                    //  Otherwise set the length to end exactly at the end of the previous
                    //  cluster.
                    //

                    } else {

                        Length = AllocatedLength - VcnOffset;
                    }
                }
            }

            //
            //  If the resulting Length from above is now zero, we can skip this log record.
            //

            if ((Length == 0) && (SavedLength != 0)) {
                continue;
            }

#ifdef BENL_DBG

            {
                PRESTART_LOG RedoLog;

                RedoLog = (PRESTART_LOG) NtfsAllocatePoolNoRaise( NonPagedPool, sizeof( RESTART_LOG ) );
                if (RedoLog) {
                    RedoLog->Lsn = LogRecordLsn;
                    InsertTailList( &(Vcb->RestartRedoHead), &(RedoLog->Links) );
                } else {
                    KdPrint(( "NTFS: out of memory during restart redo\n" ));
                }
            }
#endif

            //
            //  Apply the Redo operation in a common routine.
            //

            DoAction( IrpContext,
                      Vcb,
                      LogRecord,
                      LogRecord->RedoOperation,
                      Data,
                      Length,
                      LogRecordLength,
                      &LogRecordLsn,
                      NULL,
                      &PageBcb,
                      &PageLsn );


            if (PageLsn != NULL) {
                *PageLsn = LogRecordLsn;
            }

            if (PageBcb != NULL) {

                CcSetDirtyPinnedData( PageBcb, &LogRecordLsn );

                NtfsUnpinBcb( IrpContext, &PageBcb );
            }

        //
        //  Keep reading and looping back until end of file.
        //

        } while (LfsReadNextLogRecord( LogHandle,
                                       LogContext,
                                       &RecordType,
                                       &TransactionId,
                                       &UndoNextLsn,
                                       &PreviousLsn,
                                       &LogRecordLsn,
                                       &LogRecordLength,
                                       (PVOID *)&LogRecord ));

    } finally {

        NtfsUnpinBcb( IrpContext, &PageBcb );

        //
        //  Finally we can kill the log handle.
        //

        LfsTerminateLogQuery( LogHandle, LogContext );
    }

    DebugTrace( -1, Dbg, ("RedoPass -> VOID\n") );
}


//
//  Internal support routine
//

VOID
UndoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine performs the Undo Pass of Restart.  It does this by scanning
    the Transaction Table produced by the Analysis Pass.  For every transaction
    in this table which is in the active state, all of its Undo log records, as
    linked together by the UndoNextLsn, are applied to undo the logged operation.
    Note that all pages at this point should be uptodate with the contents they
    had at about the time of the crash.  The dirty page table is not consulted
    during the Undo Pass, all relevant Undo operations are unconditionally
    performed.

    The Undo actions are all performed in the common routine DoAction,
    which is also used by the Redo Pass.

Arguments:

    Vcb - Volume which is being restarted.

Return Value:

    None.

--*/

{
    PTRANSACTION_ENTRY Transaction;
    POPEN_ATTRIBUTE_ENTRY OpenEntry;
    PRESTART_POINTERS TransactionTable = &Vcb->TransactionTable;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("UndoPass:\n") );

    //
    //  Point to first Transaction Entry.
    //

    Transaction = NtfsGetFirstRestartTable( TransactionTable );

    //
    //  Loop to end of table.
    //

    while (Transaction != NULL) {

        if ((Transaction->TransactionState == TransactionActive)

                &&

            (Transaction->UndoNextLsn.QuadPart != 0)) {

                //
                //  Abort transaction if it is active and has undo work to do.
                //

                NtfsAbortTransaction( IrpContext, Vcb, Transaction );

#ifdef BENL_DBG
                {
                    PRESTART_LOG UndoLog;

                    UndoLog = (PRESTART_LOG) NtfsAllocatePoolNoRaise( NonPagedPool, sizeof( RESTART_LOG ) );
                    if (UndoLog) {
                        UndoLog->Lsn = Transaction->FirstLsn;
                        InsertTailList( &(Vcb->RestartUndoHead), &(UndoLog->Links) );
                    } else {
                        KdPrint(( "NTFS: out of memory during restart undo\n" ));
                    }
                }
#endif


        //
        //  Remove this entry from the transaction table.
        //

        } else {

            TRANSACTION_ID TransactionId = GetIndexFromRestartEntry( &Vcb->TransactionTable,
                                                                     Transaction );

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                              TRUE );

            NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                       TransactionId );

            NtfsReleaseRestartTable( &Vcb->TransactionTable );
        }

        //
        //  Point to next entry in table, or NULL.
        //

        Transaction = NtfsGetNextRestartTable( TransactionTable, Transaction );
    }

    //
    //  Now we will flush and purge all the streams to verify that the purges
    //  will work.
    //

    OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    //
    //  Loop to end of table.
    //

    while (OpenEntry != NULL) {

        IO_STATUS_BLOCK IoStatus;
        PSCB Scb;

        Scb = OpenEntry->OatData->Overlay.Scb;

        //
        //  We clean up the Scb only if it exists and this is index in the
        //  OpenAttributeTable that this Scb actually refers to.
        //  If this Scb has several entries in the table, this check will insure
        //  that it only gets cleaned up once.
        //

        if ((Scb != NULL) &&
            (Scb->NonpagedScb->OpenAttributeTableIndex == GetIndexFromRestartEntry( &Vcb->OpenAttributeTable, OpenEntry))) {

            //
            //  Now flush the file.  It is important to call the
            //  same routine the Lazy Writer calls, so that write.c
            //  will not decide to update file size for the attribute,
            //  since we really are working here with the wrong size.
            //
            //  We also now purge all pages, in case we go to update
            //  half of a page that was clean and read in as zeros in
            //  the Redo Pass.
            //

            NtfsPurgeFileRecordCache( IrpContext );

            NtfsAcquireScbForLazyWrite( (PVOID)Scb, TRUE );
            CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );
            NtfsReleaseScbFromLazyWrite( (PVOID)Scb );

            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                &IoStatus.Status,
                                                TRUE,
                                                STATUS_UNEXPECTED_IO_ERROR );

            if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject, NULL, 0, FALSE )) {

                KdPrint(("NtfsUndoPass:  Unable to purge volume\n"));

                NtfsRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR, NULL, NULL );
            }
        }

        //
        //  Point to next entry in table, or NULL.
        //

        OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                             OpenEntry );
    }

    DebugTrace( -1, Dbg, ("UndoPass -> VOID\n") );
}


//
//  Internal support routine
//

//
//  First define some "local" macros for Lsn in page manipulation.
//

//
//  Macro to check the Lsn and break (out of the switch statement in DoAction)
//  if the respective redo record need not be applied.  Note that if the structure's
//  clusters were deleted, then it will read as all zero's so we also check a field
//  which must be nonzero.
//

#define CheckLsn(PAGE) {                                                            \
    if (*(PULONG)((PMULTI_SECTOR_HEADER)(PAGE))->Signature ==                       \
        *(PULONG)BaadSignature) {                                                   \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
                                                                                    \
    if (ARGUMENT_PRESENT(RedoLsn) &&                                                \
        ((*(PULONG)((PMULTI_SECTOR_HEADER)(PAGE))->Signature ==                     \
        *(PULONG)HoleSignature) ||                                                  \
        (RedoLsn->QuadPart <= ((PFILE_RECORD_SEGMENT_HEADER)(PAGE))->Lsn.QuadPart))) {  \
                 /**** xxLeq(*RedoLsn,((PFILE_RECORD_SEGMENT_HEADER)(PAGE))->Lsn) ****/ \
        DebugTrace( 0, Dbg, ("Skipping Page with Lsn: %016I64x\n",                    \
                             ((PFILE_RECORD_SEGMENT_HEADER)(PAGE))->Lsn) );         \
                                                                                    \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  Macros for checking File Records and Index Buffers before and after the action
//  routines.  The after checks are only for debug.  The before check is not
//  always possible.
//

#define CheckFileRecordBefore {                                        \
    if (!NtfsCheckFileRecord( Vcb, FileRecord, NULL, &CorruptHint )) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                  \
        NtfsUnpinBcb( IrpContext, Bcb );                               \
        break;                                                         \
    }                                                                  \
}

#define CheckFileRecordAfter {                                            \
    DbgDoit(NtfsCheckFileRecord( Vcb, FileRecord, NULL, &CorruptHint ));  \
}

#define CheckIndexBufferBefore {                                    \
    if (!NtfsCheckIndexBuffer( Scb, IndexBuffer )) {                \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );               \
        NtfsUnpinBcb( IrpContext, Bcb );                            \
        break;                                                      \
    }                                                               \
}

#define CheckIndexBufferAfter {                                     \
    DbgDoit(NtfsCheckIndexBuffer( Scb, IndexBuffer ));              \
}

//
//  Checks if the record offset + length will fit into a file record.
//

#define CheckWriteFileRecord {                                                  \
    if (LogRecord->RecordOffset + Length > Vcb->BytesPerFileRecordSegment) {    \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE ) ;                          \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  Checks if the record offset in the log record points to an attribute.
//

#define CheckIfAttribute( ENDOK ) {                                             \
    _Length = FileRecord->FirstAttributeOffset;                                 \
    _AttrHeader = Add2Ptr( FileRecord, _Length );                               \
    while (_Length < LogRecord->RecordOffset) {                                 \
        if ((_AttrHeader->TypeCode == $END) ||                                  \
            (_AttrHeader->RecordLength == 0)) {                                 \
            break;                                                              \
        }                                                                       \
        _Length += _AttrHeader->RecordLength;                                   \
        _AttrHeader = NtfsGetNextRecord( _AttrHeader );                         \
    }                                                                           \
    if ((_Length != LogRecord->RecordOffset) ||                                 \
        (!(ENDOK) && (_AttrHeader->TypeCode == $END))) {                        \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                           \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  Checks if the attribute described by 'Data' fits within the log record
//  and will fit in the file record.
//

#define CheckInsertAttribute {                                                  \
    _AttrHeader = (PATTRIBUTE_RECORD_HEADER) Data;                              \
    if ((Length < (ULONG) SIZEOF_RESIDENT_ATTRIBUTE_HEADER) ||                  \
        (_AttrHeader->RecordLength & 7) ||                                      \
        ((ULONG_PTR) Add2Ptr( Data, _AttrHeader->RecordLength )                 \
           > (ULONG_PTR) Add2Ptr( LogRecord, LogRecordLength )) ||              \
        (Length > FileRecord->BytesAvailable - FileRecord->FirstFreeByte)) {    \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                           \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This checks
//      - the attribute fits if we are growing the attribute
//

#define CheckResidentFits {                                                         \
    _AttrHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset ); \
    _Length = LogRecord->AttributeOffset + Length;                                  \
    if ((LogRecord->RedoLength == LogRecord->UndoLength) ?                          \
        (LogRecord->AttributeOffset + Length > _AttrHeader->RecordLength) :         \
        ((_Length > _AttrHeader->RecordLength) &&                                   \
         ((_Length - _AttrHeader->RecordLength) >                                   \
          (FileRecord->BytesAvailable - FileRecord->FirstFreeByte)))) {             \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks that the data in this log record will fit into the
//  allocation described in the log record.
//

#define CheckNonResidentFits {                                                  \
    if (BytesFromClusters( Vcb, LogRecord->LcnsToFollow )                       \
        < (BytesFromLogBlocks( LogRecord->ClusterBlockOffset ) + LogRecord->RecordOffset + Length)) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                           \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This routine checks
//      - the attribute is non-resident.
//      - the data is beyond the mapping pairs offset.
//      - the new data begins within the current size of the attribute.
//      - the new data will fit in the file record.
//

#define CheckMappingFits {                                                      \
    _AttrHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset );\
    _Length = LogRecord->AttributeOffset + Length;                              \
    if ((_AttrHeader->TypeCode == $END) ||                                      \
        NtfsIsAttributeResident( _AttrHeader ) ||                               \
        (LogRecord->AttributeOffset < _AttrHeader->Form.Nonresident.MappingPairsOffset) ||  \
        (LogRecord->AttributeOffset > _AttrHeader->RecordLength) ||             \
        ((_Length > _AttrHeader->RecordLength) &&                               \
         ((_Length - _AttrHeader->RecordLength) >                               \
          (FileRecord->BytesAvailable - FileRecord->FirstFreeByte)))) {         \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                           \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This routine simply checks that the attribute is non-resident.
//

#define CheckIfNonResident {                                                        \
    if (NtfsIsAttributeResident( (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord,    \
                                                                     LogRecord->RecordOffset ))) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if the record offset points to an index_root attribute.
//

#define CheckIfIndexRoot {                                                          \
    _Length = FileRecord->FirstAttributeOffset;                                     \
    _AttrHeader = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );          \
    while (_Length < LogRecord->RecordOffset) {                                     \
        if ((_AttrHeader->TypeCode == $END) ||                                      \
            (_AttrHeader->RecordLength == 0)) {                                     \
            break;                                                                  \
        }                                                                           \
        _Length += _AttrHeader->RecordLength;                                       \
        _AttrHeader = NtfsGetNextRecord( _AttrHeader );                             \
    }                                                                               \
    if ((_Length != LogRecord->RecordOffset) ||                                     \
        (_AttrHeader->TypeCode != $INDEX_ROOT)) {                                   \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if the attribute offset points to a valid index entry.
//

#define CheckIfRootIndexEntry {                                                     \
    _Length = PtrOffset( Attribute, IndexHeader ) +                                 \
                     IndexHeader->FirstIndexEntry;                                  \
    _CurrentEntry = Add2Ptr( IndexHeader, IndexHeader->FirstIndexEntry );           \
    while (_Length < LogRecord->AttributeOffset) {                                  \
        if ((_Length >= Attribute->RecordLength) ||                                 \
            (_CurrentEntry->Length == 0)) {                                         \
            break;                                                                  \
        }                                                                           \
        _Length += _CurrentEntry->Length;                                           \
        _CurrentEntry = Add2Ptr( _CurrentEntry, _CurrentEntry->Length );            \
    }                                                                               \
    if (_Length != LogRecord->AttributeOffset) {                                    \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if the attribute offset points to a valid index entry.
//

#define CheckIfAllocationIndexEntry {                                               \
    ULONG _AdjustedOffset;                                                          \
    _Length = IndexHeader->FirstIndexEntry;                                         \
    _AdjustedOffset = FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader )          \
                      + IndexHeader->FirstIndexEntry;                               \
    _CurrentEntry = Add2Ptr( IndexHeader, IndexHeader->FirstIndexEntry );           \
    while (_AdjustedOffset < LogRecord->AttributeOffset) {                          \
        if ((_Length >= IndexHeader->FirstFreeByte) ||                              \
            (_CurrentEntry->Length == 0)) {                                         \
            break;                                                                  \
        }                                                                           \
        _AdjustedOffset += _CurrentEntry->Length;                                   \
        _Length += _CurrentEntry->Length;                                           \
        _CurrentEntry = Add2Ptr( _CurrentEntry, _CurrentEntry->Length );            \
    }                                                                               \
    if (_AdjustedOffset != LogRecord->AttributeOffset) {                            \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if we can safely add this index entry.
//      - The index entry must be within the log record
//      - There must be enough space in the attribute to insert this.
//

#define CheckIfRootEntryFits {                                                      \
    if (((ULONG_PTR) Add2Ptr( Data, IndexEntry->Length ) > (ULONG_PTR) Add2Ptr( LogRecord, LogRecordLength )) || \
        (IndexEntry->Length > FileRecord->BytesAvailable - FileRecord->FirstFreeByte)) {                 \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks that we can safely add this index entry.
//      - The entry must be contained in a log record.
//      - The entry must fit in the index buffer.
//

#define CheckIfAllocationEntryFits {                                                \
    if (((ULONG_PTR) Add2Ptr( Data, IndexEntry->Length ) >                              \
         (ULONG_PTR) Add2Ptr( LogRecord, LogRecordLength )) ||                          \
        (IndexEntry->Length > IndexHeader->BytesAvailable - IndexHeader->FirstFreeByte)) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                               \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine will check that the data will fit in the tail of an index buffer.
//

#define CheckWriteIndexBuffer {                                                 \
    if (LogRecord->AttributeOffset + Length >                                   \
        (FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader ) +                 \
         IndexHeader->BytesAvailable)) {                                        \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                           \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This routine verifies that the bitmap bits are contained in the Lcns described.
//

#define CheckBitmapRange {                                                      \
    if ((BytesFromLogBlocks( LogRecord->ClusterBlockOffset ) +                  \
         ((BitMapRange->BitMapOffset + BitMapRange->NumberOfBits + 7) / 8)) >   \
        BytesFromClusters( Vcb, LogRecord->LcnsToFollow )) {                    \
        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );                           \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

VOID
DoAction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN NTFS_LOG_OPERATION Operation,
    IN PVOID Data,
    IN ULONG Length,
    IN ULONG LogRecordLength,
    IN PLSN RedoLsn OPTIONAL,
    IN PSCB Scb OPTIONAL,
    OUT PBCB *Bcb,
    OUT PLSN *PageLsn
    )

/*++

Routine Description:

    This routine is a common routine for the Redo and Undo Passes, for performing
    the respective redo and undo operations.  All Redo- and Undo-specific
    processing is performed in RedoPass or UndoPass; in this routine all actions
    are treated identically, regardless of whether the action is undo or redo.
    Note that most actions are possible for both redo and undo, although some
    are only used for one or the other.


    Basically this routine is just a big switch statement dispatching on operation
    code.  The parameter descriptions provide some insight on how some of the
    parameters must be initialized differently for redo or undo.

Arguments:

    Vcb - Vcb for the volume being restarted.

    LogRecord - Pointer to the log record from which Redo or Undo is being executed.
                Only the common fields are accessed.

    Operation - The Redo or Undo operation to be performed.

    Data - Pointer to the Redo or Undo buffer, depending on the caller.

    Length - Length of the Redo or Undo buffer.

    LogRecordLength - Length of the entire log record.

    RedoLsn - For Redo this must be the Lsn of the Log Record for which the
              redo is being applied.  Must be NULL for transaction abort/undo.

    Scb - If specified this is the Scb for the stream to which this log record
        applies.  We have already looked this up (with proper synchronization) in
        the abort path.

    Bcb - Returns the Bcb of the page to which the action was performed, or NULL.

    PageLsn - Returns a pointer to where a new Lsn may be stored, or NULL.

Return Value:

    None.

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PINDEX_HEADER IndexHeader;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_ENTRY IndexEntry;

    //
    //  The following are used in the Check macros
    //

    PATTRIBUTE_RECORD_HEADER _AttrHeader;
    PINDEX_ENTRY _CurrentEntry;
    ULONG _Length;
    ULONG CorruptHint;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DoAction:\n") );
    DebugTrace( 0, Dbg, ("Operation = %08lx\n", Operation) );
    DebugTrace( 0, Dbg, ("Data = %08lx\n", Data) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );

    //
    //  Initially clear outputs.
    //

    *Bcb = NULL;
    *PageLsn = NULL;

    //
    //  Dispatch to handle log record depending on type.
    //

    switch (Operation) {

    //
    //  To initialize a file record segment, we simply do a prepare write and copy the
    //  file record in.
    //

    case InitializeFileRecordSegment:

        //
        //  Check the log record and that the data is a valid file record.
        //

        CheckWriteFileRecord;

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        *PageLsn = &FileRecord->Lsn;

        RtlCopyMemory( FileRecord, Data, Length );
        break;

    //
    //  To deallocate a file record segment, we do a prepare write (no need to read it
    //  to deallocate it), and clear FILE_RECORD_SEGMENT_IN_USE.
    //

    case DeallocateFileRecordSegment:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        *PageLsn = &FileRecord->Lsn;

        ASSERT( FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )
                || FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ));

        ClearFlag(FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE);

        FileRecord->SequenceNumber += 1;

        break;

    //
    //  To write the end of a file record segment, we calculate a pointer to the
    //  destination position (OldAttribute), and then call the routine to take
    //  care of it.
    //

    case WriteEndOfFileRecordSegment:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( TRUE );
        CheckWriteFileRecord;

        *PageLsn = &FileRecord->Lsn;

        Attribute = Add2Ptr( FileRecord, LogRecord->RecordOffset );

        NtfsRestartWriteEndOfFileRecord( FileRecord,
                                         Attribute,
                                         (PATTRIBUTE_RECORD_HEADER)Data,
                                         Length );
        CheckFileRecordAfter;

        break;

    //
    //  For Create Attribute, we read in the designated Mft record, and
    //  insert the attribute record from the log record.
    //

    case CreateAttribute:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( TRUE );
        CheckInsertAttribute;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartInsertAttribute( IrpContext,
                                    FileRecord,
                                    LogRecord->RecordOffset,
                                    (PATTRIBUTE_RECORD_HEADER)Data,
                                    NULL,
                                    NULL,
                                    0 );

        CheckFileRecordAfter;

        break;

    //
    //  To Delete an attribute, we read the designated Mft record and make
    //  a call to remove the attribute record.
    //

    case DeleteAttribute:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( FALSE );

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartRemoveAttribute( IrpContext,
                                    FileRecord,
                                    LogRecord->RecordOffset );

        CheckFileRecordAfter;

        break;

    //
    //  To update a resident attribute, we read the designated Mft record and
    //  call the routine to change its value.
    //

    case UpdateResidentValue:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( FALSE );
        CheckResidentFits;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartChangeValue( IrpContext,
                                FileRecord,
                                LogRecord->RecordOffset,
                                LogRecord->AttributeOffset,
                                Data,
                                Length,
                                (BOOLEAN)((LogRecord->RedoLength !=
                                           LogRecord->UndoLength) ?
                                             TRUE : FALSE) );

        CheckFileRecordAfter;

        break;

    //
    //  To update a nonresident value, we simply pin the attribute and copy
    //  the data in.  Log record will limit us to a page at a time.
    //

    case UpdateNonresidentValue:

        {
            PVOID Buffer;

            //
            //  Pin the desired index buffer, and check the Lsn.
            //

            ASSERT( Length <= PAGE_SIZE );

            PinAttributeForRestart( IrpContext,
                                    Vcb,
                                    LogRecord,
                                    Length,
                                    Bcb,
                                    &Buffer,
                                    &Scb );

            CheckNonResidentFits;
            RtlCopyMemory( (PCHAR)Buffer + LogRecord->RecordOffset, Data, Length );

            break;
        }

    //
    //  To update the mapping pairs in a nonresident attribute, we read the
    //  designated Mft record and call the routine to change them.
    //

    case UpdateMappingPairs:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( FALSE );
        CheckMappingFits;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartChangeMapping( IrpContext,
                                  Vcb,
                                  FileRecord,
                                  LogRecord->RecordOffset,
                                  LogRecord->AttributeOffset,
                                  Data,
                                  Length );

        CheckFileRecordAfter;

        break;

    //
    //  To set new attribute sizes, we read the designated Mft record, point
    //  to the attribute, and copy in the new sizes.
    //

    case SetNewAttributeSizes:

        {
            PNEW_ATTRIBUTE_SIZES Sizes;

            //
            //  Pin the desired Mft record.
            //

            PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

            CheckLsn( FileRecord );
            CheckFileRecordBefore;
            CheckIfAttribute( FALSE );
            CheckIfNonResident;

            *PageLsn = &FileRecord->Lsn;

            Sizes = (PNEW_ATTRIBUTE_SIZES)Data;

            Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                          LogRecord->RecordOffset);

            NtfsVerifySizesLongLong( Sizes );
            Attribute->Form.Nonresident.AllocatedLength = Sizes->AllocationSize;

            Attribute->Form.Nonresident.FileSize = Sizes->FileSize;

            Attribute->Form.Nonresident.ValidDataLength = Sizes->ValidDataLength;

            if (Length >= SIZEOF_FULL_ATTRIBUTE_SIZES) {

                Attribute->Form.Nonresident.TotalAllocated = Sizes->TotalAllocated;
            }

            CheckFileRecordAfter;

            break;
        }

    //
    //  To insert a new index entry in the root, we read the designated Mft
    //  record, point to the attribute and the insertion point, and call the
    //  same routine used in normal operation.
    //

    case AddIndexEntryRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                      LogRecord->RecordOffset);

        IndexEntry = (PINDEX_ENTRY)Data;
        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;

        CheckIfRootIndexEntry;
        CheckIfRootEntryFits;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartInsertSimpleRoot( IrpContext,
                                     IndexEntry,
                                     FileRecord,
                                     Attribute,
                                     Add2Ptr( Attribute, LogRecord->AttributeOffset ));

        CheckFileRecordAfter;

        break;

    //
    //  To insert a new index entry in the root, we read the designated Mft
    //  record, point to the attribute and the insertion point, and call the
    //  same routine used in normal operation.
    //

    case DeleteIndexEntryRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                      LogRecord->RecordOffset);

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;
        CheckIfRootIndexEntry;

        *PageLsn = &FileRecord->Lsn;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( Attribute,
                                             LogRecord->AttributeOffset);

        NtfsRestartDeleteSimpleRoot( IrpContext,
                                     IndexEntry,
                                     FileRecord,
                                     Attribute );

        CheckFileRecordAfter;

        break;

    //
    //  To insert a new index entry in the allocation, we read the designated index
    //  buffer, point to the insertion point, and call the same routine used in
    //  normal operation.
    //

    case AddIndexEntryAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexEntry = (PINDEX_ENTRY)Data;
        IndexHeader = &IndexBuffer->IndexHeader;

        CheckIfAllocationIndexEntry;
        CheckIfAllocationEntryFits;

        *PageLsn = &IndexBuffer->Lsn;

        NtfsRestartInsertSimpleAllocation( IndexEntry,
                                           IndexBuffer,
                                           Add2Ptr( IndexBuffer, LogRecord->AttributeOffset ));

        CheckIndexBufferAfter;

        break;

    //
    //  To delete an index entry in the allocation, we read the designated index
    //  buffer, point to the deletion point, and call the same routine used in
    //  normal operation.
    //

    case DeleteIndexEntryAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexBuffer + LogRecord->AttributeOffset);

        ASSERT( (0 == Length) || (Length == IndexEntry->Length) );
        ASSERT( (0 == Length) || (0 == RtlCompareMemory( IndexEntry, Data, Length)) );

        *PageLsn = &IndexBuffer->Lsn;

        NtfsRestartDeleteSimpleAllocation( IndexEntry, IndexBuffer );

        CheckIndexBufferAfter;

        break;

    case WriteEndOfIndexBuffer:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;
        CheckWriteIndexBuffer;

        *PageLsn = &IndexBuffer->Lsn;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexBuffer + LogRecord->AttributeOffset);

        NtfsRestartWriteEndOfIndex( IndexHeader,
                                    IndexEntry,
                                    (PINDEX_ENTRY)Data,
                                    Length );
        CheckIndexBufferAfter;

        break;

    //
    //  To set a new index entry Vcn in the root, we read the designated Mft
    //  record, point to the attribute and the index entry, and call the
    //  same routine used in normal operation.
    //

    case SetIndexEntryVcnRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset );

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;

        CheckIfRootIndexEntry;

        *PageLsn = &FileRecord->Lsn;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)Attribute +
                       LogRecord->AttributeOffset);

        NtfsRestartSetIndexBlock( IndexEntry,
                                  *((PLONGLONG) Data) );
        CheckFileRecordAfter;

        break;

    //
    //  To set a new index entry Vcn in the allocation, we read the designated index
    //  buffer, point to the index entry, and call the same routine used in
    //  normal operation.
    //

    case SetIndexEntryVcnAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        *PageLsn = &IndexBuffer->Lsn;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( IndexBuffer, LogRecord->AttributeOffset );

        NtfsRestartSetIndexBlock( IndexEntry,
                                  *((PLONGLONG) Data) );
        CheckIndexBufferAfter;

        break;

    //
    //  To update a file name in the root, we read the designated Mft
    //  record, point to the attribute and the index entry, and call the
    //  same routine used in normal operation.
    //

    case UpdateFileNameRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset );

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;
        CheckIfRootIndexEntry;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( Attribute, LogRecord->AttributeOffset );

        NtfsRestartUpdateFileName( IndexEntry,
                                   (PDUPLICATED_INFORMATION) Data );

        CheckFileRecordAfter;

        break;

    //
    //  To update a file name in the allocation, we read the designated index
    //  buffer, point to the index entry, and call the same routine used in
    //  normal operation.
    //

    case UpdateFileNameAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( IndexBuffer, LogRecord->AttributeOffset );

        NtfsRestartUpdateFileName( IndexEntry,
                                   (PDUPLICATED_INFORMATION) Data );

        CheckIndexBufferAfter;

        break;

    //
    //  To set a range of bits in the volume bitmap, we just read in the a hunk
    //  of the bitmap as described by the log record, and then call the restart
    //  routine to do it.
    //

    case SetBitsInNonresidentBitMap:

        {
            PBITMAP_RANGE BitMapRange;
            PVOID BitMapBuffer;
            ULONG BitMapSize;
            RTL_BITMAP Bitmap;

            //
            //  Open the attribute first to get the Scb.
            //

            OpenAttributeForRestart( IrpContext, Vcb, LogRecord, &Scb );

            //
            //  Pin the desired bitmap buffer.
            //

            ASSERT( Length <= PAGE_SIZE );

            PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, &BitMapBuffer, &Scb );

            BitMapRange = (PBITMAP_RANGE)Data;

            CheckBitmapRange;

            //
            //  Initialize our bitmap description, and call the restart
            //  routine with the bitmap Scb exclusive (assuming it cannot
            //  raise).
            //

            BitMapSize = BytesFromClusters( Vcb, LogRecord->LcnsToFollow ) * 8;

            RtlInitializeBitMap( &Bitmap, BitMapBuffer, BitMapSize );

            NtfsRestartSetBitsInBitMap( IrpContext,
                                        &Bitmap,
                                        BitMapRange->BitMapOffset,
                                        BitMapRange->NumberOfBits );

            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb)) {

                ULONGLONG ThisLcn;
                LONGLONG FoundLcn;
                LONGLONG FoundClusters;
                BOOLEAN FoundMatch = FALSE;
                PDEALLOCATED_CLUSTERS Clusters;

                ThisLcn = (ULONGLONG) ((BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8);
                ThisLcn += BitMapRange->BitMapOffset;

                //
                //  Best odds are that these are in the active deallocated clusters.
                //

                Clusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Flink;

                do {

                    if (FsRtlLookupLargeMcbEntry( &Clusters->Mcb,
                                                  ThisLcn,
                                                  &FoundLcn,
                                                  &FoundClusters,
                                                  NULL,
                                                  NULL,
                                                  NULL ) &&
                        (FoundLcn != UNUSED_LCN)) {

                        ASSERT( FoundClusters >= BitMapRange->NumberOfBits );

                        FsRtlRemoveLargeMcbEntry( &Clusters->Mcb,
                                                  ThisLcn,
                                                  BitMapRange->NumberOfBits );

                        //
                        //  Assume again that we will always be able to remove
                        //  the entries.  Even if we don't it just means that it won't be
                        //  available to allocate this cluster.  The counts should be in-sync
                        //  since they are changed together.
                        //

                        Clusters->ClusterCount -= BitMapRange->NumberOfBits;
                        Vcb->DeallocatedClusters -= BitMapRange->NumberOfBits;
                        FoundMatch = TRUE;
                        break;
                    }

                    Clusters = (PDEALLOCATED_CLUSTERS)Clusters->Link.Flink;
                } while ( &Clusters->Link != &Vcb->DeallocatedClusterListHead );
            }

#ifdef NTFS_CHECK_BITMAP
            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb) &&
                (Vcb->BitmapCopy != NULL)) {

                ULONG BitmapOffset;
                ULONG BitmapPage;
                ULONG StartBit;

                BitmapOffset = (BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8;

                BitmapPage = (BitmapOffset + BitMapRange->BitMapOffset) / (PAGE_SIZE * 8);
                StartBit = (BitmapOffset + BitMapRange->BitMapOffset) & ((PAGE_SIZE * 8) - 1);

                RtlSetBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitMapRange->NumberOfBits );
            }
#endif

            break;
        }

    //
    //  To clear a range of bits in the volume bitmap, we just read in the a hunk
    //  of the bitmap as described by the log record, and then call the restart
    //  routine to do it.
    //

    case ClearBitsInNonresidentBitMap:

        {
            PBITMAP_RANGE BitMapRange;
            PVOID BitMapBuffer;
            ULONG BitMapSize;
            RTL_BITMAP Bitmap;

            //
            //  Open the attribute first to get the Scb.
            //

            OpenAttributeForRestart( IrpContext, Vcb, LogRecord, &Scb );

            //
            //  Pin the desired bitmap buffer.
            //

            ASSERT( Length <= PAGE_SIZE );

            PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, &BitMapBuffer, &Scb );

            BitMapRange = (PBITMAP_RANGE)Data;

            CheckBitmapRange;

            BitMapSize = BytesFromClusters( Vcb, LogRecord->LcnsToFollow ) * 8;

            //
            //  Initialize our bitmap description, and call the restart
            //  routine with the bitmap Scb exclusive (assuming it cannot
            //  raise).
            //

            RtlInitializeBitMap( &Bitmap, BitMapBuffer, BitMapSize );

            NtfsRestartClearBitsInBitMap( IrpContext,
                                          &Bitmap,
                                          BitMapRange->BitMapOffset,
                                          BitMapRange->NumberOfBits );

            //
            //  Look and see if we can return these to the free cluster Mcb.
            //

            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb)) {

                ULONGLONG ThisLcn;

                ThisLcn = (ULONGLONG) ((BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8);
                ThisLcn += BitMapRange->BitMapOffset;

                //
                //  Use a try-finally to protect against failures.
                //

                try {

                    NtfsAddCachedRun( IrpContext,
                                      IrpContext->Vcb,
                                      ThisLcn,
                                      BitMapRange->NumberOfBits,
                                      RunStateFree );

                } except( (GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES) ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH ) {

                      NtfsMinimumExceptionProcessing( IrpContext );

                }
            }

#ifdef NTFS_CHECK_BITMAP
            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb) &&
                (Vcb->BitmapCopy != NULL)) {

                ULONG BitmapOffset;
                ULONG BitmapPage;
                ULONG StartBit;

                BitmapOffset = (BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8;

                BitmapPage = (BitmapOffset + BitMapRange->BitMapOffset) / (PAGE_SIZE * 8);
                StartBit = (BitmapOffset + BitMapRange->BitMapOffset) & ((PAGE_SIZE * 8) - 1);

                RtlClearBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitMapRange->NumberOfBits );
            }
#endif
            break;
        }

    //
    //  To update a file name in the root, we read the designated Mft
    //  record, point to the attribute and the index entry, and call the
    //  same routine used in normal operation.
    //

    case UpdateRecordDataRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                      LogRecord->RecordOffset);

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;
        CheckIfRootIndexEntry;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)Attribute +
                       LogRecord->AttributeOffset);

        NtOfsRestartUpdateDataInIndex( IndexEntry, Data, Length );

        CheckFileRecordAfter;

        break;

    //
    //  To update a file name in the allocation, we read the designated index
    //  buffer, point to the index entry, and call the same routine used in
    //  normal operation.
    //

    case UpdateRecordDataAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexBuffer +
                       LogRecord->AttributeOffset);

        NtOfsRestartUpdateDataInIndex( IndexEntry, Data, Length );

        CheckIndexBufferAfter;

        break;

    //
    //  The following cases require no action during the Redo or Undo Pass.
    //

    case Noop:
    case DeleteDirtyClusters:
    case HotFix:
    case EndTopLevelAction:
    case PrepareTransaction:
    case CommitTransaction:
    case ForgetTransaction:
    case CompensationLogRecord:
    case OpenNonresidentAttribute:
    case OpenAttributeTableDump:
    case AttributeNamesDump:
    case DirtyPageTableDump:
    case TransactionTableDump:

        break;

    //
    //  All codes will be explicitly handled.  If we see a code we
    //  do not expect, then we are in trouble.
    //

    default:

        DebugTrace( 0, Dbg, ("Record address: %08lx\n", LogRecord) );
        DebugTrace( 0, Dbg, ("Redo operation is: %04lx\n", LogRecord->RedoOperation) );
        DebugTrace( 0, Dbg, ("Undo operation is: %04lx\n", LogRecord->RedoOperation) );

        ASSERTMSG( "Unknown Action!\n", FALSE );

        break;
    }

    DebugDoit(
        if (*Bcb != NULL) {
            DebugTrace( 0, Dbg, ("**** Update applied\n") );
        }
    );

    DebugTrace( 0, Dbg, ("Bcb > %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("PageLsn > %08lx\n", *PageLsn) );
    DebugTrace( -1, Dbg, ("DoAction -> VOID\n") );
}


//
//  Internal support routine
//

VOID
PinMftRecordForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord
    )

/*++

Routine Description:

    This routine pins a record in the Mft for restart, as described
    by the current log record.

Arguments:

    Vcb - Supplies the Vcb pointer for the volume

    LogRecord - Supplies the pointer to the current log record.

    Bcb - Returns a pointer to the Bcb for the pinned record.

    FileRecord - Returns a pointer to the desired file record.

Return Value:

    None

--*/

{
    LONGLONG SegmentReference;

    PAGED_CODE();

    //
    //  Calculate the file number part of the segment reference.  Do this
    //  by obtaining the file offset of the file record and then convert to
    //  a file number.
    //

    SegmentReference = LlBytesFromClusters( Vcb, LogRecord->TargetVcn );
    SegmentReference += BytesFromLogBlocks( LogRecord->ClusterBlockOffset );
    SegmentReference = LlFileRecordsFromBytes( Vcb, SegmentReference );

    //
    //  Pin the Mft record.
    //

    NtfsPinMftRecord( IrpContext,
                      Vcb,
                      (PMFT_SEGMENT_REFERENCE)&SegmentReference,
                      TRUE,
                      Bcb,
                      FileRecord,
                      NULL );

    ASSERT( (*FileRecord)->MultiSectorHeader.Signature !=  BaadSignature );
}


//
//  Internal support routine
//

VOID
OpenAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine opens the desired attribute for restart, as described
    by the current log record.

Arguments:

    Vcb - Supplies the Vcb pointer for the volume

    LogRecord - Supplies the pointer to the current log record.

    Scb - On input points to an optional Scb.  On return it points to
        the Scb for the log record.  It is either the input Scb if specified
        or the Scb for the attribute entry.

Return Value:

    None

--*/

{
    POPEN_ATTRIBUTE_ENTRY AttributeEntry;

    PAGED_CODE();

    //
    //  Get a pointer to the attribute entry for the described attribute.
    //

    if (*Scb == NULL) {

        AttributeEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat, LogRecord->TargetAttribute );

        //
        //  Check if want to go to the other table.
        //

        if (Vcb->RestartVersion == 0) {

            AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                       ((POPEN_ATTRIBUTE_ENTRY_V0) AttributeEntry)->OatIndex );

        }

        *Scb = AttributeEntry->OatData->Overlay.Scb;
    }

    if ((*Scb)->FileObject == NULL) {
        NtfsCreateInternalAttributeStream( IrpContext, *Scb, TRUE, NULL );

        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

            CcSetAdditionalCacheAttributes( (*Scb)->FileObject, TRUE, TRUE );
        }
    }

    return;
}


//
//  Internal support routine
//

VOID
PinAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG Length OPTIONAL,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine pins the desired buffer for restart, as described
    by the current log record.

Arguments:

    Vcb - Supplies the Vcb pointer for the volume

    LogRecord - Supplies the pointer to the current log record.

    Length - If specified we will use this to determine the length
        to pin.  This will handle the non-resident streams which may
        change size (ACL, attribute lists).  The log record may have
        more clusters than are currently in the stream.

    Bcb - Returns a pointer to the Bcb for the pinned record.

    Buffer - Returns a pointer to the desired buffer.

    Scb - Returns a pointer to the Scb for the attribute

Return Value:

    None

--*/

{
    LONGLONG FileOffset;
    ULONG ClusterOffset;
    ULONG PinLength;

    PAGED_CODE();

    //
    //  First open the described atttribute.
    //

    OpenAttributeForRestart( IrpContext, Vcb, LogRecord, Scb );

    //
    //  Calculate the desired file offset and pin the buffer.
    //

    ClusterOffset = BytesFromLogBlocks( LogRecord->ClusterBlockOffset );
    FileOffset = LlBytesFromClusters( Vcb, LogRecord->TargetVcn ) + ClusterOffset;

    ASSERT((!FlagOn( (*Scb)->ScbPersist, SCB_PERSIST_USN_JOURNAL )) || (FileOffset >= Vcb->UsnCacheBias));

    //
    //  We only want to pin the requested clusters or to the end of
    //  a page, whichever is smaller.
    //

    if (Vcb->BytesPerCluster > PAGE_SIZE) {

        PinLength = PAGE_SIZE - (((ULONG) FileOffset) & (PAGE_SIZE - 1));

    } else if (Length != 0) {

        PinLength = Length;

    } else {

        PinLength = BytesFromClusters( Vcb, LogRecord->LcnsToFollow ) - ClusterOffset;
    }

    //
    //  We don't want to pin more than a page
    //

    NtfsPinStream( IrpContext,
                   *Scb,
                   FileOffset,
                   PinLength,
                   Bcb,
                   Buffer );

#if DBG

    //
    // Check index signature integrity
    //

    {
        PVOID AlignedBuffer;
        PINDEX_ALLOCATION_BUFFER AllocBuffer;

        AlignedBuffer = (PVOID) ((((ULONG_PTR)(*Buffer) + (0x1000)) & ~(0x1000 -1)) - 0x1000);
        AllocBuffer = (PINDEX_ALLOCATION_BUFFER) AlignedBuffer;

        if ((LogRecord->RedoOperation != UpdateNonresidentValue) &&
            (LogRecord->UndoOperation != UpdateNonresidentValue) &&
            ((*Scb)->AttributeTypeCode == $INDEX_ALLOCATION) &&
            ((*Scb)->AttributeName.Length == 8) &&
            (wcsncmp( (*Scb)->AttributeName.Buffer, L"$I30", 4 ) == 0)) {

            if (*(PULONG)AllocBuffer->MultiSectorHeader.Signature != *(PULONG)IndexSignature) {
                KdPrint(( "Ntfs: index signature is: %d %c%c%c%c for LCN: 0x%I64x\n",
                          *(PULONG)AllocBuffer->MultiSectorHeader.Signature,
                          AllocBuffer->MultiSectorHeader.Signature[0],
                          AllocBuffer->MultiSectorHeader.Signature[1],
                          AllocBuffer->MultiSectorHeader.Signature[2],
                          AllocBuffer->MultiSectorHeader.Signature[3],
                          LogRecord->LcnsForPage[0] ));

                if (*(PULONG)AllocBuffer->MultiSectorHeader.Signature != 0 &&
                    *(PULONG)AllocBuffer->MultiSectorHeader.Signature != *(PULONG)BaadSignature &&
                    *(PULONG)AllocBuffer->MultiSectorHeader.Signature != *(PULONG)HoleSignature) {

                    DbgBreakPoint();
                }
            } //endif signature fork
        } //endif index scb fork
    }
#endif

}


//
//  Internal support routine
//

BOOLEAN
FindDirtyPage (
    IN PRESTART_POINTERS DirtyPageTable,
    IN ULONG TargetAttribute,
    IN VCN Vcn,
    OUT PDIRTY_PAGE_ENTRY *DirtyPageEntry
    )

/*++

Routine Description:

    This routine searches for a Vcn to see if it is already in the Dirty Page
    Table, returning the Dirty Page Entry if it is.

Arguments:

    DirtyPageTable - pointer to the Dirty Page Table to search.

    TargetAttribute - Attribute for which the dirty Vcn is to be searched.

    Vcn - Vcn to search for.

    DirtyPageEntry - returns a pointer to the Dirty Page Entry if returning TRUE.

Return Value:

    TRUE if the page was found and is being returned, else FALSE.

--*/

{
    PDIRTY_PAGE_ENTRY DirtyPage;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("FindDirtyPage:\n") );
    DebugTrace( 0, Dbg, ("TargetAttribute = %08lx\n", TargetAttribute) );
    DebugTrace( 0, Dbg, ("Vcn = %016I64x\n", Vcn) );

    //
    //  If table has not yet been initialized, return.
    //

    if (DirtyPageTable->Table == NULL) {
        return FALSE;
    }

    //
    //  Loop through all of the dirty pages to look for a match.
    //

    DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

    //
    //  Loop to end of table.
    //

    while (DirtyPage != NULL) {

        if ((DirtyPage->TargetAttribute == TargetAttribute)

                &&

            (Vcn >= DirtyPage->Vcn)) {

            //
            //  Compute the Last Vcn outside of the comparison or the xxAdd and
            //  xxFromUlong will be called three times.
            //

            LONGLONG BeyondLastVcn;

            BeyondLastVcn = DirtyPage->Vcn + DirtyPage->LcnsToFollow;

            if (Vcn < BeyondLastVcn) {

                *DirtyPageEntry = DirtyPage;

                DebugTrace( 0, Dbg, ("DirtyPageEntry %08lx\n", *DirtyPageEntry) );
                DebugTrace( -1, Dbg, ("FindDirtypage -> TRUE\n") );

                return TRUE;
            }
        }

        //
        //  Point to next entry in table, or NULL.
        //

        DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                             DirtyPage );
    }
    *DirtyPageEntry = NULL;

    DebugTrace( -1, Dbg, ("FindDirtypage -> FALSE\n") );

    return FALSE;
}



//
//  Internal support routine
//

VOID
PageUpdateAnalysis (
    IN PVCB Vcb,
    IN LSN Lsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    IN PNTFS_LOG_RECORD_HEADER LogRecord
    )

/*++

Routine Description:

    This routine updates the Dirty Pages Table during the analysis phase
    for all log records which update a page.

Arguments:

    Vcb - Pointer to the Vcb for the volume.

    Lsn - The Lsn of the log record.

    DirtyPageTable - A pointer to the Dirty Page Table pointer, to be
                     updated and potentially expanded.

    LogRecord - Pointer to the Log Record being analyzed.

Return Value:

    None.

--*/

{
    PDIRTY_PAGE_ENTRY DirtyPage;
    ULONG i;
    RESTART_POINTERS NewDirtyPageTable;
    ULONG ClustersPerPage;
    ULONG PageIndex;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("PageUpdateAnalysis:\n") );

    //
    //  Calculate the number of clusters per page in the system which wrote
    //  the checkpoint, possibly creating the table.
    //

    if (DirtyPageTable->Table != NULL) {
        ClustersPerPage = ((DirtyPageTable->Table->EntrySize -
                            sizeof(DIRTY_PAGE_ENTRY)) / sizeof(LCN)) + 1;
    } else {
        ClustersPerPage = Vcb->ClustersPerPage;
        NtfsInitializeRestartTable( sizeof(DIRTY_PAGE_ENTRY) +
                                      (ClustersPerPage - 1) * sizeof(LCN),
                                    INITIAL_NUMBER_DIRTY_PAGES,
                                    DirtyPageTable );
    }

    //
    //  If the on disk number of lcns doesn't match our curent page size
    //  we need to reallocate the entire table to accomodate this
    //

    if((ULONG)LogRecord->LcnsToFollow > ClustersPerPage) {

        PDIRTY_PAGE_ENTRY OldDirtyPage;

        DebugTrace( +1, Dbg, ("Ntfs: resizing table in pageupdateanalysis\n") );

        //
        // Adjust clusters per page up to the number of clusters in this record
        //

        ClustersPerPage = (ULONG)LogRecord->LcnsToFollow;

        ASSERT( DirtyPageTable->Table->NumberEntries >= INITIAL_NUMBER_DIRTY_PAGES );

        NtfsInitializeRestartTable( sizeof(DIRTY_PAGE_ENTRY) +
                                      (ClustersPerPage - 1) * sizeof(LCN),
                                    DirtyPageTable->Table->NumberEntries,
                                    &NewDirtyPageTable );

        OldDirtyPage = (PDIRTY_PAGE_ENTRY) NtfsGetFirstRestartTable( DirtyPageTable );

        //
        // Loop to copy table entries
        //

        while (OldDirtyPage) {

            //
            //  Allocate a new dirty page entry.
            //

            PageIndex = NtfsAllocateRestartTableIndex( &NewDirtyPageTable, TRUE );

            //
            //  Get a pointer to the entry we just allocated.
            //

            DirtyPage = GetRestartEntryFromIndex( &NewDirtyPageTable, PageIndex );

            DirtyPage->TargetAttribute = OldDirtyPage->TargetAttribute;
            DirtyPage->LengthOfTransfer = BytesFromClusters( Vcb, ClustersPerPage );
            DirtyPage->LcnsToFollow = ClustersPerPage;
            DirtyPage->Vcn = OldDirtyPage->Vcn;
            ((ULONG)DirtyPage->Vcn) &= ~(ClustersPerPage - 1);
            DirtyPage->OldestLsn = OldDirtyPage->OldestLsn;

            for (i = 0; i < OldDirtyPage->LcnsToFollow; i++) {
                DirtyPage->LcnsForPage[i] = OldDirtyPage->LcnsForPage[i];
            }

            OldDirtyPage = (PDIRTY_PAGE_ENTRY) NtfsGetNextRestartTable( DirtyPageTable, OldDirtyPage );
        }

        //
        //  OldTable is really on the stack so swap the new restart table into it
        //  and free up the old one and the rest of the new restart pointers
        //

        NtfsFreePool( DirtyPageTable->Table );
        DirtyPageTable->Table = NewDirtyPageTable.Table;
        NewDirtyPageTable.Table = NULL;
        NtfsFreeRestartTable( &NewDirtyPageTable );
    }  //  endif table needed to be resized

    //
    //  Update the dirty page entry or create a new one
    //

    if (!FindDirtyPage( DirtyPageTable,
                        LogRecord->TargetAttribute,
                        LogRecord->TargetVcn,
                        &DirtyPage )) {

        //
        //  Allocate a dirty page entry.
        //

        PageIndex = NtfsAllocateRestartTableIndex( DirtyPageTable, TRUE );

        //
        //  Get a pointer to the entry we just allocated.
        //

        DirtyPage = GetRestartEntryFromIndex( DirtyPageTable, PageIndex );

        //
        //  Initialize the dirty page entry.
        //

        DirtyPage->TargetAttribute = LogRecord->TargetAttribute;
        DirtyPage->LengthOfTransfer = BytesFromClusters( Vcb, ClustersPerPage );
        DirtyPage->LcnsToFollow = ClustersPerPage;
        DirtyPage->Vcn = LogRecord->TargetVcn;
        ((ULONG)DirtyPage->Vcn) &= ~(ClustersPerPage - 1);
        DirtyPage->OldestLsn = Lsn;
    }

    //
    //  Copy the Lcns from the log record into the Dirty Page Entry.
    //
    //  *** for different page size support, must somehow make whole routine a loop,
    //  in case Lcns do not fit below.
    //

    for (i = 0; i < (ULONG)LogRecord->LcnsToFollow; i++) {

        DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn) + i] =
          LogRecord->LcnsForPage[i];
    }

    DebugTrace( -1, Dbg, ("PageUpdateAnalysis -> VOID\n") );
}


//
//  Internal support routine
//

VOID
OpenAttributesForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable
    )

/*++

Routine Description:

    This routine is called immediately after the Analysis Pass to open all of
    the attributes in the Open Attribute Table, and preload their Mcbs with
    any run information required to apply updates in the Dirty Page Table.
    With this trick we are effectively doing physical I/O directly to Lbns on
    the disk without relying on any of the file structure to be correct.

Arguments:

    Vcb - Vcb for the volume, for which the Open Attribute Table has been
          initialized.

    DirtyPageTable - Dirty Page table reconstructed from the Analysis Pass.

Return Value:

    None.

--*/

{
    POPEN_ATTRIBUTE_ENTRY OpenEntry;
    POPEN_ATTRIBUTE_ENTRY OldOpenEntry;
    PDIRTY_PAGE_ENTRY DirtyPage;
    ULONG i;
    PSCB TempScb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("OpenAttributesForRestart:\n") );

    //
    //  First we scan the Open Attribute Table to open all of the attributes.
    //

    OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    //
    //  Loop to end of table.
    //

    while (OpenEntry != NULL) {

        //
        //  Create the Scb from the data in the Open Attribute Entry.
        //

        TempScb = NtfsCreatePrerestartScb( IrpContext,
                                           Vcb,
                                           &OpenEntry->FileReference,
                                           OpenEntry->AttributeTypeCode,
                                           &OpenEntry->OatData->AttributeName,
                                           OpenEntry->BytesPerIndexBuffer );

        //
        //  If we dynamically allocated a name for this guy, then delete
        //  it here.
        //

        if (OpenEntry->OatData->Overlay.AttributeName != NULL) {
            NtfsFreePool( OpenEntry->OatData->Overlay.AttributeName );
            OpenEntry->OatData->AttributeNamePresent = FALSE;
        }

        OpenEntry->OatData->AttributeName = TempScb->AttributeName;

        //
        //  Now we can lay in the Scb.  We must say the header is initialized
        //  to keep anyone from going to disk yet.
        //

        SetFlag( TempScb->ScbState, SCB_STATE_HEADER_INITIALIZED );

        //
        //  Now store the index in the newly created Scb if its newer.
        //  precalc oldopenentry buts its only good if the scb's attributeindex is nonzero
        //

        OldOpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, TempScb->NonpagedScb->OpenAttributeTableIndex );

        if ((TempScb->NonpagedScb->OpenAttributeTableIndex == 0) ||
            (OldOpenEntry->LsnOfOpenRecord.QuadPart < OpenEntry->LsnOfOpenRecord.QuadPart)) {

            TempScb->NonpagedScb->OpenAttributeTableIndex = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable, OpenEntry );
            TempScb->NonpagedScb->OnDiskOatIndex = OpenEntry->OatData->OnDiskAttributeIndex;

        }

        OpenEntry->OatData->Overlay.Scb = TempScb;

        //
        //  Point to next entry in table, or NULL.
        //

        OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                             OpenEntry );
    }

    //
    //  Now loop through the dirty page table to extract all of the Vcn/Lcn
    //  Mapping that we have, and insert it into the appropriate Scb.
    //

    DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

    //
    //  Loop to end of table.
    //

    while (DirtyPage != NULL) {

        PSCB Scb;

        //
        //  Safety check
        //

        if (!IsRestartIndexWithinTable( Vcb->OnDiskOat, DirtyPage->TargetAttribute )) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        OpenEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat,
                                              DirtyPage->TargetAttribute );

        if (IsRestartTableEntryAllocated( OpenEntry )) {

            //
            //  Get the entry from the other table if necessary.
            //

            if (Vcb->RestartVersion == 0) {

                //
                //  Safety check
                //

                if (!IsRestartIndexWithinTable( &Vcb->OpenAttributeTable, ((POPEN_ATTRIBUTE_ENTRY_V0) OpenEntry)->OatIndex )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                OpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                      ((POPEN_ATTRIBUTE_ENTRY_V0) OpenEntry)->OatIndex );
            }

            Scb = OpenEntry->OatData->Overlay.Scb;

            //
            //  Loop to add the allocated Vcns.
            //

            for (i = 0; i < DirtyPage->LcnsToFollow; i++) {

                VCN Vcn;
                LONGLONG Size;

                Vcn = DirtyPage->Vcn + i;
                Size = LlBytesFromClusters( Vcb, Vcn + 1);

                //
                //  Add this run to the Mcb if the Vcn has not been deleted,
                //  and it is not for the fixed part of the Mft.
                //

                if ((DirtyPage->LcnsForPage[i] != 0)

                        &&

                    (NtfsSegmentNumber( &OpenEntry->FileReference ) > MASTER_FILE_TABLE2_NUMBER ||
                     (Size >= ((VOLUME_DASD_NUMBER + 1) * Vcb->BytesPerFileRecordSegment)) ||
                     (OpenEntry->AttributeTypeCode != $DATA))) {


                    if (!NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                         Vcn,
                                         DirtyPage->LcnsForPage[i],
                                         (LONGLONG)1,
                                         FALSE )) {

                        //
                        //  Replace with new entry if collision comes from
                        //  the newest attribute
                        //

                        if (DirtyPage->TargetAttribute == Scb->NonpagedScb->OnDiskOatIndex) {
#if DBG
                            BOOLEAN Result;
#endif
                            NtfsRemoveNtfsMcbEntry( &Scb->Mcb,
                                                    Vcn,
                                                    1 );
#if DBG
                            Result =
#endif
                            NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                                 Vcn,
                                                 DirtyPage->LcnsForPage[i],
                                                 (LONGLONG)1,
                                                 FALSE );
#if DBG
                            ASSERT( Result );
#endif
                        }
                    }

                    if (Size > Scb->Header.AllocationSize.QuadPart) {

                        Scb->Header.AllocationSize.QuadPart =
                        Scb->Header.FileSize.QuadPart =
                        Scb->Header.ValidDataLength.QuadPart = Size;
                    }
                }
            }
        }

        //
        //  Point to next entry in table, or NULL.
        //

        DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                             DirtyPage );
    }

    //
    //  Now we know how big all of the files have to be, and recorded that in the
    //  Scb.  We have not created streams for any of these Scbs yet, except for
    //  the Mft, Mft2 and LogFile.  The size should be correct for Mft2 and LogFile,
    //  but we have to inform the Cache Manager here of the final size of the Mft.
    //

    TempScb = Vcb->MftScb;

    ASSERT( !FlagOn( TempScb->ScbPersist, SCB_PERSIST_USN_JOURNAL ) );
    CcSetFileSizes( TempScb->FileObject,
                    (PCC_FILE_SIZES)&TempScb->Header.AllocationSize );

    DebugTrace( -1, Dbg, ("OpenAttributesForRestart -> VOID\n") );
}


NTSTATUS
NtfsCloseAttributesFromRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called at the end of a Restart to close any attributes
    that had to be opened for Restart purposes.  Actually what this does is
    delete all of the internal streams so that the attributes will eventually
    go away.  This routine cannot raise because it is called in the finally of
    MountVolume.  Raising in the main line path will leave the global resource
    acquired.

Arguments:

    Vcb - Vcb for the volume, for which the Open Attribute Table has been
          initialized.

Return Value:

    NTSTATUS - STATUS_SUCCESS if all of the I/O completed successfully.  Otherwise
        the error in the IrpContext or the first I/O error.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    POPEN_ATTRIBUTE_ENTRY OpenEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("CloseAttributesForRestart:\n") );

    //
    //  Set this flag again now, so we do not try to flush out the holes!
    //

    SetFlag(Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS);

    //
    //  Remove duplicate Scbs - in rare case no dirty pages the scb's were never
    //  opened at all
    //

   OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );
   while (OpenEntry != NULL) {
       if ((OpenEntry->OatData->Overlay.Scb != NULL) &&
           (!(OpenEntry->OatData->AttributeNamePresent)) &&
           (OpenEntry->OatData->Overlay.Scb->NonpagedScb->OpenAttributeTableIndex !=
            GetIndexFromRestartEntry( &Vcb->OpenAttributeTable, OpenEntry ))) {

           OpenEntry->OatData->Overlay.Scb = NULL;
       }

       //
       //  Point to next entry in table, or NULL.
       //

       OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                            OpenEntry );
   }

    //
    //  Scan the Open Attribute Table to close all of the open attributes.
    //

    OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    //
    //  Loop to end of table.
    //

    while (OpenEntry != NULL) {

        IO_STATUS_BLOCK IoStatus;
        PSCB Scb;

        if (OpenEntry->OatData->AttributeNamePresent) {

            NtfsFreePool( OpenEntry->OatData->Overlay.AttributeName );
            OpenEntry->OatData->Overlay.AttributeName = NULL;
        }

        Scb = OpenEntry->OatData->Overlay.Scb;

        //
        //  We clean up the Scb only if it exists and this is index in the
        //  OpenAttributeTable that this Scb actually refers to.
        //  If this Scb has several entries in the table, we nulled out older
        //  duplicates in the loop above
        //

        if (Scb != NULL) {

            FILE_REFERENCE FileReference;

            //
            //  Only shut it down if it is not the Mft or its mirror.
            //

            FileReference = Scb->Fcb->FileReference;
            if (NtfsSegmentNumber( &FileReference ) > LOG_FILE_NUMBER ||
                (Scb->AttributeTypeCode != $DATA)) {

                //
                //  Now flush the file.  It is important to call the
                //  same routine the Lazy Writer calls, so that write.c
                //  will not decide to update file size for the attribute,
                //  since we really are working here with the wrong size.
                //

                NtfsAcquireScbForLazyWrite( (PVOID)Scb, TRUE );
                CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );
                NtfsReleaseScbFromLazyWrite( (PVOID)Scb );

                if (NT_SUCCESS( Status )) {

                    if (!NT_SUCCESS( IrpContext->ExceptionStatus )) {

                        Status = IrpContext->ExceptionStatus;

                    } else if (!NT_SUCCESS( IoStatus.Status )) {

                        Status = FsRtlNormalizeNtstatus( IoStatus.Status,
                                                         STATUS_UNEXPECTED_IO_ERROR );
                    }
                }

                //
                //  If there is an Scb and it is not for a system file, then delete
                //  the stream file so it can eventually go away.
                //

                NtfsUninitializeNtfsMcb( &Scb->Mcb );
                NtfsInitializeNtfsMcb( &Scb->Mcb,
                                       &Scb->Header,
                                       &Scb->McbStructs,
                                       FlagOn( Scb->Fcb->FcbState,
                                               FCB_STATE_PAGING_FILE ) ? NonPagedPool :
                                                                         PagedPool );

                //
                //  Now that we are restarted, we must clear the header state
                //  so that we will go look up the sizes and load the Scb
                //  from disk.
                //

                ClearFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED |
                                          SCB_STATE_FILE_SIZE_LOADED );

                //
                //  Show the indexed portions are "uninitialized".
                //

                if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

                    Scb->ScbType.Index.BytesPerIndexBuffer = 0;
                }

                //
                //  If this Fcb is past the log file then remove it from the
                //  Fcb table.
                //

                if ((NtfsSegmentNumber( &FileReference ) > LOG_FILE_NUMBER) &&
                    FlagOn( Scb->Fcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

                    NtfsDeleteFcbTableEntry( Scb->Fcb->Vcb, FileReference );
                    ClearFlag( Scb->Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );
                }

                //
                //  If the Scb is a root index scb then change the type to INDEX_SCB.
                //  Otherwise the teardown routines will skip it.
                //

                if (SafeNodeType( Scb ) == NTFS_NTC_SCB_ROOT_INDEX) {

                    SafeNodeType( Scb ) = NTFS_NTC_SCB_INDEX;
                }

                if (Scb->FileObject != NULL) {

                    NtfsDeleteInternalAttributeStream( Scb, TRUE, FALSE );
                } else {

                    //
                    //  Make sure the Scb is acquired exclusively.
                    //

                    NtfsAcquireExclusiveFcb( IrpContext, Scb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    NtfsTeardownStructures( IrpContext,
                                            Scb,
                                            NULL,
                                            FALSE,
                                            0,
                                            NULL );
                }
            }

        } else {

            //
            //  We want to check whether there is also an entry in the other table.
            //

            if (Vcb->RestartVersion == 0) {

                NtfsFreeRestartTableIndex( Vcb->OnDiskOat, OpenEntry->OatData->OnDiskAttributeIndex );
            }

            NtfsFreeOpenAttributeData( OpenEntry->OatData );

            NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable,
                                       GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                                                 OpenEntry ));
        }

        //
        //  Point to next entry in table, or NULL.
        //

        OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                             OpenEntry );
    }

    //
    //  Resume normal operation.
    //

    ClearFlag(Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS);

    DebugTrace( -1, Dbg, ("CloseAttributesForRestart -> %08lx\n", Status) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\secursup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SecurSup.c

Abstract:

    This module implements the Ntfs Security Support routines

Author:

    Gary Kimura     [GaryKi]    27-Dec-1991

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg                              (DEBUG_TRACE_SECURSUP)
#define DbgAcl                           (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('SFtN')

UNICODE_STRING FileString = CONSTANT_UNICODE_STRING( L"File" );

//
//  Local procedure prototypes
//

PSHARED_SECURITY
NtfsCacheSharedSecurityByDescriptor (
    IN PIRP_CONTEXT IrpContext,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    );

VOID
NtfsStoreSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN LogIt
    );

PSHARED_SECURITY
FindCachedSharedSecurityByHashUnsafe (
    IN PVCB Vcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN ULONG Hash
    );

VOID
AddCachedSharedSecurityUnsafe (
    IN PVCB Vcb,
    PSHARED_SECURITY SharedSecurity
    );

BOOLEAN
MapSecurityIdToSecurityDescriptorHeaderUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId,
    OUT PSECURITY_DESCRIPTOR_HEADER *SecurityDescriptorHeader,
    OUT PBCB *Bcb
    );

NTSTATUS
NtOfsMatchSecurityHash (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    );

VOID
NtOfsLookupSecurityDescriptorInIndex (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    );

PSHARED_SECURITY
GetSharedSecurityFromDescriptorUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    );

#ifdef NTFS_CACHE_RIGHTS
//
//  Local procedure prototypes for access rights cache
//

VOID
NtfsAddCachedRights (
    IN PVCB Vcb,
    IN PSHARED_SECURITY SharedSecurity,
    IN ACCESS_MASK Rights,
    IN PLUID TokenId,
    IN PLUID ModifiedId
    );

INLINE ACCESS_MASK
NtfsGetCachedRightsWorld (
    IN PCACHED_ACCESS_RIGHTS CachedRights
    )
{
    return CachedRights->EveryoneRights;
}

INLINE VOID
NtfsSetCachedRightsWorld (
    IN PSHARED_SECURITY SharedSecurity
    )
{
    SeGetWorldRights( &SharedSecurity->SecurityDescriptor,
                      IoGetFileObjectGenericMapping(),
                      &SharedSecurity->CachedRights.EveryoneRights );

    //
    //  Make certain that MAXIMUM_ALLOWED is not in the rights.
    //

    ClearFlag( SharedSecurity->CachedRights.EveryoneRights, MAXIMUM_ALLOWED );

    return;
}
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAssignSecurity)
#pragma alloc_text(PAGE, NtfsCacheSharedSecurityByDescriptor)
#pragma alloc_text(PAGE, NtfsModifySecurity)
#pragma alloc_text(PAGE, NtfsQuerySecurity)
#pragma alloc_text(PAGE, NtfsAccessCheck)
#pragma alloc_text(PAGE, NtfsCheckFileForDelete)
#pragma alloc_text(PAGE, NtfsCheckIndexForAddOrDelete)
#pragma alloc_text(PAGE, GetSharedSecurityFromDescriptorUnsafe)
#pragma alloc_text(PAGE, NtfsSetFcbSecurityFromDescriptor)
#pragma alloc_text(PAGE, NtfsNotifyTraverseCheck)
#pragma alloc_text(PAGE, NtfsInitializeSecurity)
#pragma alloc_text(PAGE, NtfsCacheSharedSecurityBySecurityId)
#pragma alloc_text(PAGE, FindCachedSharedSecurityByHashUnsafe)
#pragma alloc_text(PAGE, AddCachedSharedSecurityUnsafe)
#pragma alloc_text(PAGE, NtOfsPurgeSecurityCache)
#pragma alloc_text(PAGE, MapSecurityIdToSecurityDescriptorHeaderUnsafe)
#pragma alloc_text(PAGE, NtfsLoadSecurityDescriptor)
#pragma alloc_text(PAGE, NtOfsMatchSecurityHash)
#pragma alloc_text(PAGE, NtOfsLookupSecurityDescriptorInIndex)
#pragma alloc_text(PAGE, GetSecurityIdFromSecurityDescriptorUnsafe)
#pragma alloc_text(PAGE, NtfsStoreSecurityDescriptor)
#pragma alloc_text(PAGE, NtfsCacheSharedSecurityForCreate)
#pragma alloc_text(PAGE, NtOfsCollateSecurityHash)
#pragma alloc_text(PAGE, NtfsCanAdministerVolume)
#endif

#ifdef NTFS_CACHE_RIGHTS
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsGetCachedRightsById)
#pragma alloc_text(PAGE, NtfsGetCachedRights)
#pragma alloc_text(PAGE, NtfsAddCachedRights)
#endif
#endif


VOID
NtfsAssignSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PIRP Irp,
    IN PFCB NewFcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB FileRecordBcb,
    IN LONGLONG FileOffset,
    IN OUT PBOOLEAN LogIt
    )

/*++

Routine Description:

    LEGACY NOTE - this routine disappears when all volumes go to Cairo.

    This routine constructs and assigns a new security descriptor to the
    specified file/directory.  The new security descriptor is placed both
    on the fcb and on the disk.

    This will only be called in the context of an open/create operation.
    It currently MUST NOT be called to store a security descriptor for
    an existing file, because it instructs NtfsStoreSecurityDescriptor
    to not log the change.

    If this is a large security descriptor then it is possible that
    AllocateClusters may be called twice within the call to AddAllocation
    when the attribute is created.  If so then the second call will always
    log the changes.  In that case we need to log all of the operations to
    create this security attribute and also we must log the current state
    of the file record.

    It is possible that our caller has already started logging operations against
    this log record.  In that case we always log the security changes.

Arguments:

    ParentFcb - Supplies the directory under which the new fcb exists

    Irp - Supplies the Irp being processed

    NewFcb - Supplies the fcb that is being assigned a new security descriptor

    FileRecord - Supplies the file record for this operation.  Used if we
        have to log against the file record.

    FileRecordBcb - Bcb for the file record above.

    FileOffset - File offset in the Mft for this file record.

    LogIt - On entry this indicates whether our caller wants this operation
        logged.  On exit we return TRUE if we logged the security change.

Return Value:

    None.

--*/

{
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    NTSTATUS Status;
    BOOLEAN IsDirectory;
    PACCESS_STATE AccessState;
    PIO_STACK_LOCATION IrpSp;
    ULONG SecurityDescLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( ParentFcb );
    ASSERT_IRP( Irp );
    ASSERT_FCB( NewFcb );

    PAGED_CODE();

    if (NewFcb->Vcb->SecurityDescriptorStream != NULL) {
        return;
    }

    DebugTrace( +1, Dbg, ("NtfsAssignSecurity...\n") );

    //
    //  First decide if we are creating a file or a directory
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (FlagOn(IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE)) {

        IsDirectory = TRUE;

    } else {

        IsDirectory = FALSE;
    }

    //
    //  Extract the parts of the Irp that we need to do our assignment
    //

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Check if we need to load the security descriptor for the parent.
    //

    if (ParentFcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );

    }

    ASSERT( ParentFcb->SharedSecurity != NULL );

    //
    //  Create a new security descriptor for the file and raise if there is
    //  an error
    //

    if (!NT_SUCCESS( Status = SeAssignSecurity( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                AccessState->SecurityDescriptor,
                                                &SecurityDescriptor,
                                                IsDirectory,
                                                &AccessState->SubjectSecurityContext,
                                                IoGetFileObjectGenericMapping(),
                                                PagedPool ))) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

    }

    //
    //  Load the security descriptor into the Fcb
    //

    SecurityDescLength = RtlLengthSecurityDescriptor( SecurityDescriptor );

    try {

        //
        //  Make sure the length is non-zero.
        //

        if (SecurityDescLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );

        }

        ASSERT( SeValidSecurityDescriptor( SecurityDescLength, SecurityDescriptor ));


        NtfsSetFcbSecurityFromDescriptor(
                               IrpContext,
                               NewFcb,
                               SecurityDescriptor,
                               SecurityDescLength,
                               TRUE );

    } finally {

        //
        //  Free the security descriptor created by Se
        //

        SeDeassignSecurity( &SecurityDescriptor );
    }

    //
    //  If the security descriptor is large enough that it may cause us to
    //  start logging in the StoreSecurity call below then make sure everything
    //  is logged.
    //

    if (!(*LogIt) &&
        (SecurityDescLength > BytesFromClusters( NewFcb->Vcb, MAXIMUM_RUNS_AT_ONCE ))) {

        //
        //  Log the current state of the file record.
        //

        FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                        NewFcb->Vcb->MftScb,
                                        FileRecordBcb,
                                        InitializeFileRecordSegment,
                                        FileRecord,
                                        FileRecord->FirstFreeByte,
                                        Noop,
                                        NULL,
                                        0,
                                        FileOffset,
                                        0,
                                        0,
                                        NewFcb->Vcb->BytesPerFileRecordSegment );

        *LogIt = TRUE;
    }

    //
    //  Write out the new security descriptor
    //

    NtfsStoreSecurityDescriptor( IrpContext, NewFcb, *LogIt );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAssignSecurity -> VOID\n") );

    return;
}


PSHARED_SECURITY
NtfsCacheSharedSecurityByDescriptor (
    IN PIRP_CONTEXT IrpContext,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    )

/*++

Routine Description:

    This routine finds or constructs a security id and SHARED_SECURITY from
    a specific file or directory.

Arguments:

    IrpContext - Context of the call

    SecurityDescriptor - the actual security descriptor being stored

    SecurityDescriptorLength - length of security descriptor

    RaiseIfInvalid - raise status if sd is invalid

Return Value:

    Referenced shared security.

--*/

{
    PSHARED_SECURITY SharedSecurity = NULL;
    SECURITY_ID SecurityId;
    ULONG FcbSecurityAcquired;
    ULONG OwnerCount;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  LEGACY NOTE - this goes away when all volumes become NT 5.0
    //

    if (IrpContext->Vcb->SecurityDescriptorStream == NULL) {
        return NULL;
    }

    DebugTrace( +1, DbgAcl, ("NtfsCacheSharedSecurityByDescriptor...\n") );

    //
    //  Serialize access to the security cache and use a try/finally to make
    //  sure we release it
    //

    NtfsAcquireFcbSecurity( IrpContext->Vcb );
    FcbSecurityAcquired = TRUE;

    //
    //  Capture our owner count on the mft - so we can release it if we acquired it later on
    //  growing the file record for the security stream
    //

    OwnerCount = NtfsIsSharedScb( IrpContext->Vcb->MftScb );

    try {

        //
        //  We have a security descriptor.  Create a shared security descriptor.
        //

        SharedSecurity = GetSharedSecurityFromDescriptorUnsafe( IrpContext,
                                                                SecurityDescriptor,
                                                                SecurityDescriptorLength,
                                                                RaiseIfInvalid );

        //
        //  Make sure the shared security doesn't go away
        //

        SharedSecurity->ReferenceCount += 1;
        DebugTrace( 0, DbgAcl, ("NtfsCacheSharedSecurityByDescriptor bumping refcount %08x\n", SharedSecurity ));

        //
        //  If we found a shared security descriptor with no Id assigned, then
        //  we must assign it.  Since it is known that no Id was assigned we
        //  must also add it into the cache.
        //

        if (SharedSecurity->Header.HashKey.SecurityId == SECURITY_ID_INVALID) {

            //
            //  Find unique SecurityId for descriptor and set SecurityId in Fcb.
            //

            SecurityId = GetSecurityIdFromSecurityDescriptorUnsafe( IrpContext,
                                                                    SharedSecurity );

            ASSERT( SharedSecurity->Header.HashKey.SecurityId == SecurityId );
            SharedSecurity->Header.HashKey.SecurityId = SecurityId;
            DebugTrace( 0, DbgAcl, ("NtfsCacheSharedSecurityByDescriptor setting security Id to new %08x\n", SecurityId ));

            //
            //  We need to drop the FcbSecurity before performing the checkpoint, to avoid
            //  deadlocks, but this is ok since we have incremented the reference count on
            //  our SharedSecurity.
            //

            NtfsReleaseFcbSecurity( IrpContext->Vcb );
            FcbSecurityAcquired = FALSE;

            //
            //  Checkpoint the current transaction so that we can safely add this
            //  shared security to the cache.  Once this call is complete, we are
            //  guaranteed that the security index modifications make it out to
            //  disk before the newly allocated security ID does.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Release the security descriptor and mft if owned
            //

            NtfsReleaseExclusiveScbIfOwned( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

            //
            //  Check if the mft has been acquired during the call before releasing it
            //

            if (NtfsIsSharedScb( IrpContext->Vcb->MftScb ) != OwnerCount) {
                NtfsReleaseScb( IrpContext, IrpContext->Vcb->MftScb );
            }

            //
            //  Cache this shared security for faster access.
            //

            NtfsAcquireFcbSecurity( IrpContext->Vcb );
            FcbSecurityAcquired = TRUE;
            AddCachedSharedSecurityUnsafe( IrpContext->Vcb, SharedSecurity );
        }

    } finally {

        if (AbnormalTermination( )) {
            if (SharedSecurity != NULL) {
                if (!FcbSecurityAcquired) {

                    NtfsAcquireFcbSecurity( IrpContext->Vcb );
                    RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
                    FcbSecurityAcquired = TRUE;
                }
            }
        }

        if (FcbSecurityAcquired) {
            NtfsReleaseFcbSecurity( IrpContext->Vcb );
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ( "NtfsCacheSharedSecurityByDescriptor -> %08x\n", SharedSecurity ) );

    return SharedSecurity;
}


NTSTATUS
NtfsModifySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine modifies an existing security descriptor for a file/directory.

Arguments:

    Fcb - Supplies the Fcb whose security is being modified

    SecurityInformation - Supplies the security information structure passed to
        the file system by the I/O system.

    SecurityDescriptor - Supplies the security information structure passed to
        the file system by the I/O system.

Return Value:

    NTSTATUS - Returns an appropriate status value for the function results

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR DescriptorPtr;
    ULONG DescriptorLength;
    PSCB Scb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, DbgAcl, ("NtfsModifySecurity...\n") );

    //
    //  First check if we need to load the security descriptor for the file
    //

    if (Fcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, Fcb );

    }

    ASSERT( Fcb->SharedSecurity != NULL);

    DescriptorPtr = &Fcb->SharedSecurity->SecurityDescriptor;

    //
    //  Do the modify operation.  SeSetSecurityDescriptorInfo no longer
    //  frees the passed security descriptor.
    //

    if (!NT_SUCCESS( Status = SeSetSecurityDescriptorInfo( NULL,
                                                           SecurityInformation,
                                                           SecurityDescriptor,
                                                           &DescriptorPtr,
                                                           PagedPool,
                                                           IoGetFileObjectGenericMapping() ))) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    DescriptorLength = RtlLengthSecurityDescriptor( DescriptorPtr );

    try {

        //
        //  Check for a zero length.
        //

        if (DescriptorLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );

        }

        //
        //  LEGACY NOTE - remove this test when all volumes go to NT 5
        //

        if (Fcb->Vcb->SecurityDescriptorStream != NULL) {
            PSHARED_SECURITY SharedSecurity;
            PSHARED_SECURITY OldSharedSecurity = NULL;
            SECURITY_ID OldSecurityId;
            ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

            //
            //  Cache security descriptor
            //

            //
            //  After the SeSetSecurityDescriptorInfo we should have a valid sd
            //

            ASSERT( SeValidSecurityDescriptor( DescriptorLength, DescriptorPtr ));

            SharedSecurity = NtfsCacheSharedSecurityByDescriptor( IrpContext, DescriptorPtr, DescriptorLength, TRUE );

            NtfsInitializeAttributeContext( &AttributeContext );

            try {

                //
                //  Move Quota to new owner as described in descriptor.
                //

                NtfsMoveQuotaOwner( IrpContext, Fcb, DescriptorPtr );

                //
                //  Set in new shared security
                //

                OldSharedSecurity = Fcb->SharedSecurity;
                OldSecurityId = Fcb->SecurityId;

                Fcb->SharedSecurity = SharedSecurity;
                Fcb->SecurityId = SharedSecurity->Header.HashKey.SecurityId;

                DebugTrace( 0, DbgAcl, ("NtfsModifySecurity setting Fcb securityId to %08x\n", Fcb->SecurityId ));

                //
                //  We are called to replace an existing security descriptor.  In the
                //  event that we have a downlevel $STANDARD_INFORMATION attribute, we
                //  must convert it to large form so that the security ID is stored.
                //

                if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO) ) {

                    DebugTrace( 0, DbgAcl, ("Growing standard information\n") );

                    NtfsGrowStandardInformation( IrpContext, Fcb );
                }

                //
                //  Despite having a large $STANDARD_INFORMATION, we may have
                //  a security descriptor present.  This occurs if the SecurityId
                //  is invalid
                //

                if (OldSecurityId == SECURITY_ID_INVALID) {

                    //
                    //  Read in the security descriptor attribute. If it
                    //  doesn't exist then we're done, otherwise simply delete the
                    //  attribute
                    //

                    if (NtfsLookupAttributeByCode( IrpContext,
                                                         Fcb,
                                                         &Fcb->FileReference,
                                                         $SECURITY_DESCRIPTOR,
                                                         &AttributeContext )) {

                        UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );

                        DebugTrace( 0, DbgAcl, ("Delete existing Security Descriptor\n") );

                        NtfsDeleteAttributeRecord( IrpContext,
                                                   Fcb,
                                                   DELETE_LOG_OPERATION |
                                                    DELETE_RELEASE_FILE_RECORD |
                                                    DELETE_RELEASE_ALLOCATION,
                                                   &AttributeContext );

                        //
                        //  If the $SECURITY_DESCRIPTOR was non resident, the above
                        //  delete call created one for us under the covers.  We
                        //  need to mark it as deleted otherwise, we detect the
                        //  volume as being corrupt.
                        //

                        Scb = NtfsCreateScb( IrpContext,
                                             Fcb,
                                             $SECURITY_DESCRIPTOR,
                                             &NoName,
                                             TRUE,
                                             NULL );

                        if (Scb != NULL) {
                            ASSERT_EXCLUSIVE_SCB( Scb );
                            SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                        }
                    }
                }

                //
                //  The security descriptor in the FCB is now changed and may not
                //  reflect what is $STANDARD_INFORMATION.  The caller is responsible
                //  for making this update.
                //

            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

                if (AbnormalTermination()) {

                    if (OldSharedSecurity != NULL) {

                        //
                        //  Put back the security the way we found it
                        //

                        Fcb->SharedSecurity = OldSharedSecurity;
                        Fcb->SecurityId = OldSecurityId;
                        DebugTrace( 0, DbgAcl, ("NtfsModifySecurity resetting Fcb->SecurityId to %08x\n", Fcb->SecurityId ));
                    }

                    OldSharedSecurity = SharedSecurity;
                }

                //
                //  release old security descriptor (or new one if
                //  NtfsMoveQuotaOwner raises
                //

                ASSERT( OldSharedSecurity != NULL );
                NtfsAcquireFcbSecurity( Fcb->Vcb );
                RemoveReferenceSharedSecurityUnsafe( &OldSharedSecurity );
                NtfsReleaseFcbSecurity( Fcb->Vcb );
            }

        } else {

            //  LEGACY NOTE - delete this clause when all volumes go to NT 5

            //
            //  Update the move the quota to the new owner if necessary.
            //

            NtfsMoveQuotaOwner( IrpContext, Fcb, DescriptorPtr );


            //
            //  Load the security descriptor into the Fcb
            //

            NtfsAcquireFcbSecurity( Fcb->Vcb );

            RemoveReferenceSharedSecurityUnsafe( &Fcb->SharedSecurity );

            NtfsReleaseFcbSecurity( Fcb->Vcb );

            NtfsSetFcbSecurityFromDescriptor(
                                       IrpContext,
                                       Fcb,
                                       DescriptorPtr,
                                       DescriptorLength,
                                       TRUE );

            //
            //  Now we need to store the new security descriptor on disk
            //

            NtfsStoreSecurityDescriptor( IrpContext, Fcb, TRUE );

        }

    } finally {

        SeDeassignSecurity( &DescriptorPtr );

    }

    //
    //  Remember that we modified the security on the file.
    //

    SetFlag( Fcb->InfoFlags, FCB_INFO_MODIFIED_SECURITY );

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ("NtfsModifySecurity -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsQuerySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG SecurityDescriptorLength
    )

/*++

Routine Description:

    This routine is used to query the contents of an existing security descriptor for
    a file/directory.

Arguments:

    Fcb - Supplies the file/directory being queried

    SecurityInformation - Supplies the security information structure passed to
        the file system by the I/O system.

    SecurityDescriptor - Supplies the security information structure passed to
        the file system by the I/O system.

    SecurityDescriptorLength - Supplies the length of the input security descriptor
        buffer in bytes.

Return Value:

    NTSTATUS - Returns an appropriate status value for the function results

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR LocalPointer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQuerySecurity...\n") );

    //
    //  First check if we need to load the security descriptor for the file
    //

    if (Fcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, Fcb );

    }

    LocalPointer = &Fcb->SharedSecurity->SecurityDescriptor;

    //
    //  Now with the security descriptor loaded do the query operation but
    //  protect ourselves with a exception handler just in case the caller's
    //  buffer isn't valid
    //

    try {

        Status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                                SecurityDescriptor,
                                                SecurityDescriptorLength,
                                                &LocalPointer );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsQuerySecurity -> %08lx\n", Status) );

    return Status;
}


#define NTFS_SE_CONTROL (((SE_DACL_PRESENT | SE_SELF_RELATIVE) << 16) | SECURITY_DESCRIPTOR_REVISION1)
#define NTFS_DEFAULT_ACCESS_MASK 0x001f01ff

ULONG NtfsWorldAclFile[] = {
        0x00000000,     // Null Sacl
        0x00000014,     // Dacl
        0x001c0002,     // Acl header
        0x00000001,     // One ACE
        0x00140000,     // ACE Header
        NTFS_DEFAULT_ACCESS_MASK,
        0x00000101,     // World Sid
        0x01000000,
        0x00000000
        };

ULONG NtfsWorldAclDir[] = {
        0x00000000,     // Null Sacl
        0x00000014,     // Dacl
        0x00300002,     // Acl header
        0x00000002,     // Two ACEs
        0x00140000,     // ACE Header
        NTFS_DEFAULT_ACCESS_MASK,
        0x00000101,     // World Sid
        0x01000000,
        0x00000000,
        0x00140b00,     // ACE Header
        NTFS_DEFAULT_ACCESS_MASK,
        0x00000101,     // World Sid
        0x01000000,
        0x00000000
        };


VOID
NtfsAccessCheck (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PIRP Irp,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN CheckOnly
    )

/*++

Routine Description:

    This routine does a general access check for the indicated desired access.
    This will only be called in the context of an open/create operation.

    If access is granted then control is returned to the caller
    otherwise this function will do the proper Nt security calls to log
    the attempt and then raise an access denied status.

Arguments:

    Fcb - Supplies the file/directory being examined

    ParentFcb - Optionally supplies the parent of the Fcb being examined

    Irp - Supplies the Irp being processed

    DesiredAccess - Supplies a mask of the access being requested

    CheckOnly - Indicates if this operation is to check the desired access
        only and not accumulate the access granted here.  In this case we
        are guaranteed that we have passed in a hard-wired desired access
        and MAXIMUM_ALLOWED will not be one of them.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    NTSTATUS AccessStatus;
    NTSTATUS AccessStatusError;

    PACCESS_STATE AccessState;

    PIO_STACK_LOCATION IrpSp;

#ifdef NTFS_CACHE_RIGHTS
    ACCESS_MASK TmpDesiredAccess;
#endif

    KPROCESSOR_MODE EffectiveMode;
    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    PISECURITY_DESCRIPTOR SecurityDescriptor;
    PPRIVILEGE_SET Privileges;
    PUNICODE_STRING FileName;
    PUNICODE_STRING RelatedFileName;
    PUNICODE_STRING PartialFileName;
    UNICODE_STRING FullFileName;
    PUNICODE_STRING DeviceObjectName;
    USHORT DeviceObjectNameLength;
    ULONG FullFileNameLength;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    BOOLEAN CleanupAttrContext = FALSE;

    BOOLEAN LeadingSlash;
    BOOLEAN RelatedFileNamePresent;
    BOOLEAN PartialFileNamePresent;
    BOOLEAN MaximumRequested;
    BOOLEAN MaximumDeleteAcquired;
    BOOLEAN MaximumReadAttrAcquired;
    BOOLEAN PerformAccessValidation;
    BOOLEAN PerformDeleteAudit;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAccessCheck...\n") );

    //
    //  First extract the parts of the Irp that we need to do our checking
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Check if we need to load the security descriptor for the file
    //

    if (Fcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, Fcb );
    }

    ASSERT( Fcb->SharedSecurity != NULL );

    SecurityDescriptor = (PISECURITY_DESCRIPTOR) Fcb->SharedSecurity->SecurityDescriptor;

    //
    //  Check to see if auditing is enabled and if this is the default world ACL.
    //

    if ((*((PULONG) SecurityDescriptor) == NTFS_SE_CONTROL) &&
        !SeAuditingFileEvents( TRUE, SecurityDescriptor )) {

        //
        //  Directories and files have different default ACLs.
        //

        if (((Fcb->Info.FileAttributes & DUP_FILE_NAME_INDEX_PRESENT) &&
             RtlEqualMemory( &SecurityDescriptor->Sacl,
                             NtfsWorldAclDir,
                             sizeof( NtfsWorldAclDir ))) ||

            RtlEqualMemory( &SecurityDescriptor->Sacl,
                            NtfsWorldAclFile,
                            sizeof(NtfsWorldAclFile))) {

            if (FlagOn( DesiredAccess, MAXIMUM_ALLOWED )) {
                GrantedAccess = NTFS_DEFAULT_ACCESS_MASK;
            } else {
                GrantedAccess = DesiredAccess & NTFS_DEFAULT_ACCESS_MASK;
            }

            if (!CheckOnly) {

                SetFlag( AccessState->PreviouslyGrantedAccess, GrantedAccess );
                ClearFlag( AccessState->RemainingDesiredAccess, GrantedAccess | MAXIMUM_ALLOWED );
            }

            DebugTrace( -1, Dbg, ("NtfsAccessCheck -> DefaultWorldAcl\n") );

            return;
        }
    }

    Privileges = NULL;
    FileName = NULL;
    RelatedFileName = NULL;
    PartialFileName = NULL;
    DeviceObjectName = NULL;
    MaximumRequested = FALSE;
    MaximumDeleteAcquired = FALSE;
    MaximumReadAttrAcquired = FALSE;
    PerformAccessValidation = TRUE;
    PerformDeleteAudit = FALSE;

    //
    //  Check to see if we need to perform access validation
    //

    ClearFlag( DesiredAccess, AccessState->PreviouslyGrantedAccess );

#ifdef NTFS_CACHE_RIGHTS
    //
    //  Get any cached knowledge about rights that all callers are known to
    //  have for this security descriptor.
    //

    GrantedAccess = NtfsGetCachedRightsWorld( &Fcb->SharedSecurity->CachedRights );

    if (!CheckOnly) {

        SetFlag( AccessState->PreviouslyGrantedAccess,
                 FlagOn( DesiredAccess, GrantedAccess ));
    }

    ClearFlag( DesiredAccess, GrantedAccess );
#endif

    if (DesiredAccess == 0) {

        //
        //  Nothing to check, skip AVR and go straight to auditing
        //

        PerformAccessValidation = FALSE;
        AccessGranted = TRUE;
    }

    //
    //  Remember the case where MAXIMUM_ALLOWED was requested.
    //

    if (FlagOn( DesiredAccess, MAXIMUM_ALLOWED )) {

        MaximumRequested = TRUE;
    }

    if (FlagOn(IrpSp->Parameters.Create.SecurityContext->FullCreateOptions,FILE_DELETE_ON_CLOSE)) {
        PerformDeleteAudit = TRUE;
    }

    //
    //  SL_FORCE_ACCESS_CHECK causes us to use an effective RequestorMode
    //  of UserMode.
    //

    EffectiveMode = (KPROCESSOR_MODE)(FlagOn( IrpSp->Flags, SL_FORCE_ACCESS_CHECK ) ?
                                      UserMode :
                                      Irp->RequestorMode);

    //
    //  Lock the user context, do the access check and then unlock the context
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (PerformAccessValidation) {

#ifdef NTFS_CACHE_RIGHTS
            BOOLEAN EntryCached = FALSE;

            //
            //  Check the cached information only if the effective
            //  RequestorMode is UserMode.

            if (EffectiveMode == UserMode) {

                //
                //  Add in any cached knowledge about rights that this caller
                //  is known to have for this security descriptor.
                //

                (VOID)NtfsGetCachedRights( Fcb->Vcb,
                                           &AccessState->SubjectSecurityContext,
                                           Fcb->SharedSecurity,
                                           &GrantedAccess,
                                           &EntryCached,
                                           NULL,
                                           NULL );

                //
                //  Make certain that GrantedAccess has no rights not
                //  originally requested.
                //

                ClearFlag( GrantedAccess, ~DesiredAccess );

                TmpDesiredAccess = DesiredAccess;
                ClearFlag( TmpDesiredAccess, GrantedAccess );

                if (EntryCached) {

                    ClearFlag( TmpDesiredAccess, MAXIMUM_ALLOWED );
                }

                //
                //  If all rights are available, then access is granted.
                //

                if (TmpDesiredAccess == 0) {

                    AccessGranted = TRUE;
                    AccessStatus = STATUS_SUCCESS;

                //
                //  Otherwise, we don't know.
                //

                } else {

                    AccessGranted = FALSE;

                }
            } else {

                AccessGranted = FALSE;

            }
#endif

            //
            //  We need to take the slow path.
            //

#ifdef NTFS_CACHE_RIGHTS
            if (!AccessGranted) {
#endif

                //
                //  Get the rights information.
                //

                AccessGranted = SeAccessCheck( &Fcb->SharedSecurity->SecurityDescriptor,
                                               &AccessState->SubjectSecurityContext,
                                               TRUE,                           // Tokens are locked
                                               DesiredAccess,
                                               0,
                                               &Privileges,
                                               IoGetFileObjectGenericMapping(),
                                               EffectiveMode,
                                               &GrantedAccess,
                                               &AccessStatus );

                if (Privileges != NULL) {

                    Status = SeAppendPrivileges( AccessState, Privileges );
                    SeFreePrivileges( Privileges );
                    Privileges = NULL;
                }
#ifdef NTFS_CACHE_RIGHTS
            }
#endif

            if (AccessGranted) {

                ClearFlag( DesiredAccess, GrantedAccess | MAXIMUM_ALLOWED );

                if (!CheckOnly) {

                    SetFlag( AccessState->PreviouslyGrantedAccess, GrantedAccess );

                    //
                    //  Remember the case where MAXIMUM_ALLOWED was requested and we
                    //  got everything requested from the file.
                    //

                    if (MaximumRequested) {

                        //
                        //  Check whether we got DELETE and READ_ATTRIBUTES.  Otherwise
                        //  we will query the parent.
                        //

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, DELETE )) {

                            MaximumDeleteAcquired = TRUE;
                        }

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, FILE_READ_ATTRIBUTES )) {

                            MaximumReadAttrAcquired = TRUE;
                        }
                    }

                    ClearFlag( AccessState->RemainingDesiredAccess, (GrantedAccess | MAXIMUM_ALLOWED) );
                }

            } else {

                AccessStatusError = AccessStatus;
            }

            //
            //  Check if the access is not granted and if we were given a parent fcb, and
            //  if the desired access was asking for delete or file read attributes.  If so
            //  then we need to do some extra work to decide if the caller does get access
            //  based on the parent directories security descriptor.  We also do the same
            //  work if MAXIMUM_ALLOWED was requested and we didn't get DELETE or
            //  FILE_READ_ATTRIBUTES.
            //

            if ((ParentFcb != NULL)
                && ((!AccessGranted && FlagOn( DesiredAccess, DELETE | FILE_READ_ATTRIBUTES ))
                    || (MaximumRequested
                        && (!MaximumDeleteAcquired || !MaximumReadAttrAcquired)))) {

                BOOLEAN DeleteAccessGranted = TRUE;
                BOOLEAN ReadAttributesAccessGranted = TRUE;

                ACCESS_MASK DeleteChildGrantedAccess = 0;
                ACCESS_MASK ListDirectoryGrantedAccess = 0;

                //
                //  Before we proceed load in the parent security descriptor.
                //  Acquire the parent shared while doing this to protect the
                //  security descriptor.
                //

                SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
                NtfsAcquireResourceShared( IrpContext, ParentFcb, TRUE );
                SeLockSubjectContext( &AccessState->SubjectSecurityContext );

                try {

                    if (ParentFcb->SharedSecurity == NULL) {

                        NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );
                    }

                    ASSERT( ParentFcb->SharedSecurity != NULL);

                    //
                    //  Now if the user is asking for delete access then check if the parent
                    //  will granted delete access to the child, and if so then we munge the
                    //  desired access
                    //

#ifdef NTFS_CACHE_RIGHTS
                    //
                    //  Check the cached information only if the effective
                    //  RequestorMode is UserMode.
                    //

                    if (EffectiveMode == UserMode) {

                        //
                        //  Acquire in any cached knowledge about rights that
                        //  this caller is known to have for this security
                        //  descriptor.
                        //

                        (VOID)NtfsGetCachedRights( ParentFcb->Vcb,
                                                   &AccessState->SubjectSecurityContext,
                                                   ParentFcb->SharedSecurity,
                                                   &GrantedAccess,
                                                   NULL,
                                                   NULL,
                                                   NULL );

                        //
                        //  Add in the results of the parent directory access.
                        //

                        if (FlagOn( GrantedAccess, FILE_DELETE_CHILD) ) {

                            SetFlag( DeleteChildGrantedAccess, DELETE );
                            ClearFlag( DesiredAccess, DELETE );
                            MaximumDeleteAcquired = TRUE;

                        }

                        if (FlagOn( GrantedAccess, FILE_LIST_DIRECTORY) ) {

                            SetFlag( ListDirectoryGrantedAccess, FILE_READ_ATTRIBUTES );
                            ClearFlag( DesiredAccess, FILE_READ_ATTRIBUTES );
                            MaximumReadAttrAcquired = TRUE;

                        }

                    }
#endif

                    if (FlagOn( DesiredAccess, DELETE ) ||
                        (MaximumRequested && !MaximumDeleteAcquired)) {

                        DeleteAccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                             &AccessState->SubjectSecurityContext,
                                                             TRUE,                           // Tokens are locked
                                                             FILE_DELETE_CHILD,
                                                             0,
                                                             &Privileges,
                                                             IoGetFileObjectGenericMapping(),
                                                             EffectiveMode,
                                                             &DeleteChildGrantedAccess,
                                                             &AccessStatus );

                        if (Privileges != NULL) {

                            SeFreePrivileges( Privileges );
                            Privileges = NULL;
                        }

                        if (DeleteAccessGranted) {

                            SetFlag( DeleteChildGrantedAccess, DELETE );
                            ClearFlag( DeleteChildGrantedAccess, FILE_DELETE_CHILD );
                            ClearFlag( DesiredAccess, DELETE );

                        } else {

                            AccessStatusError = AccessStatus;
                        }
                    }

                    //
                    //  Do the same test for read attributes and munge the desired access
                    //  as appropriate
                    //

                    if (FlagOn(DesiredAccess, FILE_READ_ATTRIBUTES)
                        || (MaximumRequested && !MaximumReadAttrAcquired)) {

                        ReadAttributesAccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                                     &AccessState->SubjectSecurityContext,
                                                                     TRUE,                           // Tokens are locked
                                                                     FILE_LIST_DIRECTORY,
                                                                     0,
                                                                     &Privileges,
                                                                     IoGetFileObjectGenericMapping(),
                                                                     EffectiveMode,
                                                                     &ListDirectoryGrantedAccess,
                                                                     &AccessStatus );

                        if (Privileges != NULL) {

                            SeFreePrivileges( Privileges );
                            Privileges = NULL;
                        }

                        if (ReadAttributesAccessGranted) {

                            SetFlag( ListDirectoryGrantedAccess, FILE_READ_ATTRIBUTES );
                            ClearFlag( ListDirectoryGrantedAccess, FILE_LIST_DIRECTORY );
                            ClearFlag( DesiredAccess, FILE_READ_ATTRIBUTES );

                        } else {

                            AccessStatusError = AccessStatus;
                        }
                    }

                } finally {

                    NtfsReleaseResource( IrpContext, ParentFcb );
                }

                if (DesiredAccess == 0) {

                    //
                    //  If we got either the delete or list directory access then
                    //  grant access.
                    //

                    if (ListDirectoryGrantedAccess != 0 ||
                        DeleteChildGrantedAccess != 0) {

                        AccessGranted = TRUE;
                    }

                } else {

                    //
                    //  Now the desired access has been munged by removing everything the parent
                    //  has granted so now do the check on the child again
                    //

                    AccessGranted = SeAccessCheck( &Fcb->SharedSecurity->SecurityDescriptor,
                                                   &AccessState->SubjectSecurityContext,
                                                   TRUE,                           // Tokens are locked
                                                   DesiredAccess,
                                                   0,
                                                   &Privileges,
                                                   IoGetFileObjectGenericMapping(),
                                                   EffectiveMode,
                                                   &GrantedAccess,
                                                   &AccessStatus );

                    if (Privileges != NULL) {

                        Status = SeAppendPrivileges( AccessState, Privileges );
                        SeFreePrivileges( Privileges );
                        Privileges = NULL;
                    }

                    //
                    //  Suppose that we asked for MAXIMUM_ALLOWED and no access was allowed
                    //  on the file.  In that case the call above would fail.  It's possible
                    //  that we were given DELETE or READ_ATTR permission from the
                    //  parent directory.  If we have granted any access and the only remaining
                    //  desired access is MAXIMUM_ALLOWED then grant this access.
                    //

                    if (!AccessGranted) {

                        AccessStatusError = AccessStatus;

                        if (DesiredAccess == MAXIMUM_ALLOWED &&
                            (ListDirectoryGrantedAccess != 0 ||
                             DeleteChildGrantedAccess != 0)) {

                            GrantedAccess = 0;
                            AccessGranted = TRUE;
                        }

                    }
                }

                //
                //  If we are given access this time then by definition one of the earlier
                //  parent checks had to have succeeded, otherwise we would have failed again
                //  and we can update the access state
                //

                if (!CheckOnly && AccessGranted) {

                    SetFlag( AccessState->PreviouslyGrantedAccess,
                             (GrantedAccess | DeleteChildGrantedAccess | ListDirectoryGrantedAccess) );

                    ClearFlag( AccessState->RemainingDesiredAccess,
                               (GrantedAccess | MAXIMUM_ALLOWED | DeleteChildGrantedAccess | ListDirectoryGrantedAccess) );
                }
            }
        }

        //
        //  Now call a routine that will do the proper open audit/alarm work
        //
        //  ****    We need to expand the audit alarm code to deal with
        //          create and traverse alarms.
        //

        //
        //  First we take a shortcut and see if we should bother setting up
        //  and making the audit call.
        //

        //
        // NOTE: Calling SeAuditingFileEvents below disables per-user auditing functionality.
        // To make per-user auditing work again, it is necessary to change the call below to
        // be SeAuditingFileOrGlobalEvents, which also takes the subject context.
        //
        // The reason for calling SeAuditingFileEvents here is because per-user auditing is
        // not currently exposed to users, and this routine imposes less of a performance
        // penalty than does calling SeAuditingFileOrGlobalEvents.
        //

        if (SeAuditingFileEvents( AccessGranted, &Fcb->SharedSecurity->SecurityDescriptor )) {

            BOOLEAN Found;
            PFILE_NAME FileNameAttr;
            UNICODE_STRING FileRecordName;

            NtfsInitializeAttributeContext( &Context );
            CleanupAttrContext = TRUE;

            //
            //  Construct the file name.  The file name
            //  consists of:
            //
            //  The device name out of the Vcb +
            //
            //  The contents of the filename in the File Object +
            //
            //  The contents of the Related File Object if it
            //    is present and the name in the File Object
            //    does not start with a '\'
            //
            //
            //  Obtain the file name.
            //

            PartialFileName = &IrpSp->FileObject->FileName;

            PartialFileNamePresent = (PartialFileName->Length != 0);

            if (!PartialFileNamePresent &&
                FlagOn(IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID) ||
                (IrpSp->FileObject->RelatedFileObject != NULL &&
                 IrpSp->FileObject->RelatedFileObject->FsContext2 != NULL &&
                 FlagOn(((PCCB) IrpSp->FileObject->RelatedFileObject->FsContext2)->Flags,
                     CCB_FLAG_OPEN_BY_FILE_ID))) {

                //
                //  If this file is open by id or the relative file object is
                //  then get the first file name out of the file record.
                //

                Found = NtfsLookupAttributeByCode( IrpContext,
                                                   Fcb,
                                                   &Fcb->FileReference,
                                                   $FILE_NAME,
                                                   &Context );

                while (Found) {

                    FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

                    if (FileNameAttr->Flags != FILE_NAME_DOS) {

                        FileRecordName.Length = FileNameAttr->FileNameLength *
                                                    sizeof(WCHAR);
                        FileRecordName.MaximumLength = FileRecordName.Length;
                        FileRecordName.Buffer = FileNameAttr->FileName;

                        PartialFileNamePresent = TRUE;
                        PartialFileName = &FileRecordName;
                        break;
                    }

                    Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                           Fcb,
                                                           $FILE_NAME,
                                                           &Context );
                }
            }

            //
            //  Obtain the device name.
            //

            DeviceObjectName = &Fcb->Vcb->DeviceName;

            DeviceObjectNameLength = DeviceObjectName->Length;

            //
            //  Compute how much space we need for the final name string
            //

            FullFileNameLength = (ULONG)DeviceObjectNameLength +
                                 PartialFileName->Length +
                                 sizeof( UNICODE_NULL )  +
                                 sizeof((WCHAR)'\\');

            if ((FullFileNameLength & 0xffff0000L) != 0) {
                NtfsRaiseStatus( IrpContext, STATUS_OBJECT_NAME_INVALID, NULL, NULL );
            }

            FullFileName.MaximumLength = DeviceObjectNameLength  +
                                         PartialFileName->Length +
                                         sizeof( UNICODE_NULL )  +
                                         sizeof((WCHAR)'\\');

            //
            //  If the partial file name starts with a '\', then don't use
            //  whatever may be in the related file name.
            //

            if (PartialFileNamePresent &&
                ((WCHAR)(PartialFileName->Buffer[0]) == L'\\' ||
                PartialFileName == &FileRecordName)) {

                LeadingSlash = TRUE;

            } else {

                //
                //  Since PartialFileName either doesn't exist or doesn't
                //  start with a '\', examine the RelatedFileName to see
                //  if it exists.
                //

                LeadingSlash = FALSE;

                if (IrpSp->FileObject->RelatedFileObject != NULL) {

                    RelatedFileName = &IrpSp->FileObject->RelatedFileObject->FileName;
                }

                if (RelatedFileNamePresent = ((RelatedFileName != NULL) && (RelatedFileName->Length != 0))) {

                    FullFileName.MaximumLength += RelatedFileName->Length;
                }
            }

            FullFileName.Buffer = NtfsAllocatePool(PagedPool, FullFileName.MaximumLength );
            NtfsCleanupAttributeContext( IrpContext, &Context );
            CleanupAttrContext = FALSE;

            RtlCopyUnicodeString( &FullFileName, DeviceObjectName );

            //
            //  RelatedFileNamePresent is not initialized if LeadingSlash == TRUE,
            //  but in that case we won't even examine it.
            //

            if (!LeadingSlash && RelatedFileNamePresent) {

                Status = RtlAppendUnicodeStringToString( &FullFileName, RelatedFileName );

                ASSERTMSG("RtlAppendUnicodeStringToString of RelatedFileName", NT_SUCCESS( Status ));

                //
                //  RelatedFileName may simply be '\'.  Don't append another
                //  '\' in this case.
                //

                if (RelatedFileName->Length != sizeof( WCHAR )) {

                    FullFileName.Buffer[ (FullFileName.Length / sizeof( WCHAR )) ] = L'\\';
                    FullFileName.Length += sizeof(WCHAR);
                }
            }

            if (PartialFileNamePresent) {

                Status = RtlAppendUnicodeStringToString( &FullFileName, PartialFileName );

                //
                //  This should not fail
                //

                ASSERTMSG("RtlAppendUnicodeStringToString of PartialFileName failed", NT_SUCCESS( Status ));
            }


            if (PerformDeleteAudit) {
                SeOpenObjectForDeleteAuditAlarm( &FileString,
                                                 NULL,
                                                 &FullFileName,
                                                 &Fcb->SharedSecurity->SecurityDescriptor,
                                                 AccessState,
                                                 FALSE,
                                                 AccessGranted,
                                                 EffectiveMode,
                                                 &AccessState->GenerateOnClose );
            } else {
                SeOpenObjectAuditAlarm( &FileString,
                                        NULL,
                                        &FullFileName,
                                        &Fcb->SharedSecurity->SecurityDescriptor,
                                        AccessState,
                                        FALSE,
                                        AccessGranted,
                                        EffectiveMode,
                                        &AccessState->GenerateOnClose );

            }

            NtfsFreePool( FullFileName.Buffer );
        }

    } finally {

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
    }

    //
    //  If access is not granted then we will raise
    //

    if (!AccessGranted) {

        DebugTrace( -1, Dbg, ("NtfsAccessCheck -> Access Denied\n") );

        NtfsRaiseStatus( IrpContext, AccessStatusError, NULL, NULL );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAccessCheck -> VOID\n") );

    return;
}


NTSTATUS
NtfsCheckFileForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN FcbExisted,
    IN PINDEX_ENTRY IndexEntry
    )

/*++

Routine Description:

    This routine checks that the caller has permission to delete the target
    file of a rename or set link operation.

Arguments:

    ParentScb - This is the parent directory for this file.

    ThisFcb - This is the Fcb for the link being removed.

    FcbExisted - Indicates if this Fcb was just created.

    IndexEntry - This is the index entry on the disk for this file.

Return Value:

    NTSTATUS - Indicating whether access was granted or the reason access
        was denied.

--*/

{
    UNICODE_STRING LastComponentFileName;
    PFILE_NAME IndexFileName;
    PLCB ThisLcb;
    PFCB ParentFcb = ParentScb->Fcb;

    PSCB NextScb = NULL;

    BOOLEAN LcbExisted = FALSE;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN UnlockSubjectContext = FALSE;

    PPRIVILEGE_SET Privileges = NULL;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckFileForDelete:  Entered\n") );

    ThisLcb = NULL;

    IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

    //
    //  If the unclean count is non-zero, we exit with an error.
    //

    if (ThisFcb->CleanupCount != 0) {

        DebugTrace( 0, Dbg, ("Cleanup count of target is non-zero\n") );

        return STATUS_ACCESS_DENIED;
    }

    //
    //  We look at the index entry to see if the file is either a directory
    //  or a read-only file.  We can't delete this for a target directory open.
    //

    if (IsDirectory( &ThisFcb->Info )
        || IsReadOnly( &ThisFcb->Info )) {

        DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Read only or directory\n") );

        return STATUS_ACCESS_DENIED;
    }

    //
    //  We want to scan through all of the Scb for data streams on this file
    //  and look for image sections.  We must be able to remove the image section
    //  in order to delete the file.  Otherwise we can get the case where an
    //  active image (with no handle) could be deleted and subsequent faults
    //  through the image section will return zeroes.
    //

    if (ThisFcb->LinkCount == 1) {

        BOOLEAN DecrementScb = FALSE;

        //
        //  We will increment the Scb count to prevent this Scb from going away
        //  if the flush call below generates a close.  Use a try-finally to
        //  restore the count.
        //

        try {

            while ((NextScb = NtfsGetNextChildScb( ThisFcb, NextScb )) != NULL) {

                InterlockedIncrement( &NextScb->CloseCount );
                DecrementScb = TRUE;

                if (NtfsIsTypeCodeUserData( NextScb->AttributeTypeCode ) &&
                    !FlagOn( NextScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) &&
                    (NextScb->NonpagedScb->SegmentObject.ImageSectionObject != NULL)) {

                    if (!MmFlushImageSection( &NextScb->NonpagedScb->SegmentObject,
                                              MmFlushForDelete )) {

                        Status = STATUS_ACCESS_DENIED;
                        leave;
                    }
                }

                InterlockedDecrement( &NextScb->CloseCount );
                DecrementScb = FALSE;
            }

        } finally {

            if (DecrementScb) {

                InterlockedDecrement( &NextScb->CloseCount );
            }
        }

        if (Status != STATUS_SUCCESS) {

            return Status;
        }
    }

    //
    //  We need to check if the link to this file has been deleted.  We
    //  first check if we definitely know if the link is deleted by
    //  looking at the file name flags and the Fcb flags.
    //  If that result is uncertain, we need to create an Lcb and
    //  check the Lcb flags.
    //

    if (FcbExisted) {

        if (FlagOn( IndexFileName->Flags, FILE_NAME_NTFS | FILE_NAME_DOS )) {

            if (FlagOn( ThisFcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED )) {

                DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Link is going away\n") );
                return STATUS_DELETE_PENDING;
            }

        //
        //  This is a Posix link.  We need to create the link to test it
        //  for deletion.
        //

        } else {

            LastComponentFileName.MaximumLength =
            LastComponentFileName.Length = IndexFileName->FileNameLength * sizeof( WCHAR );

            LastComponentFileName.Buffer = (PWCHAR) IndexFileName->FileName;

            ThisLcb = NtfsCreateLcb( IrpContext,
                                     ParentScb,
                                     ThisFcb,
                                     LastComponentFileName,
                                     IndexFileName->Flags,
                                     &LcbExisted );

            //
            //  If no Lcb was returned, there's no way that the Lcb has been
            //  marked for deletion already.
            //

            if ((ThisLcb != NULL) &&
                (FlagOn( ThisLcb->LcbState, LCB_STATE_DELETE_ON_CLOSE ))) {

                DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Link is going away\n") );

                return STATUS_DELETE_PENDING;
            }
        }
    }

    //
    //  Finally call the security package to check for delete access.
    //  We check for delete access on the target Fcb.  If this succeeds, we
    //  are done.  Otherwise we will check for delete child access on the
    //  the parent.  Either is sufficient to perform the delete.
    //

    //
    //  Check if we need to load the security descriptor for the file
    //

    if (ThisFcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, ThisFcb );
    }

    ASSERT( ThisFcb->SharedSecurity != NULL );

#ifdef NTFS_CACHE_RIGHTS
    //
    //  Get any cached knowledge about rights that all callers are known to
    //  have for this security descriptor.
    //

    GrantedAccess = NtfsGetCachedRightsWorld( &ThisFcb->SharedSecurity->CachedRights );
    if (FlagOn( GrantedAccess, DELETE )) {

        return STATUS_SUCCESS;
    }
#endif

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Lock the user context, do the access check and then unlock the context
        //

        SeLockSubjectContext( IrpContext->Union.SubjectContext );
        UnlockSubjectContext = TRUE;

#ifdef NTFS_CACHE_RIGHTS
        //
        //  Acquire any cached knowledge about rights that this caller
        //  is known to have for this security descriptor.
        //

        (VOID)NtfsGetCachedRights( ThisFcb->Vcb,
                                   IrpContext->Union.SubjectContext,
                                   ThisFcb->SharedSecurity,
                                   &GrantedAccess,
                                   NULL,
                                   NULL,
                                   NULL );

        if (FlagOn( GrantedAccess, DELETE )) {

            AccessGranted = TRUE;
            Status = STATUS_SUCCESS;

        } else {
#endif
            AccessGranted = SeAccessCheck( &ThisFcb->SharedSecurity->SecurityDescriptor,
                                           IrpContext->Union.SubjectContext,
                                           TRUE,                           // Tokens are locked
                                           DELETE,
                                           0,
                                           &Privileges,
                                           IoGetFileObjectGenericMapping(),
                                           UserMode,
                                           &GrantedAccess,
                                           &Status );
#ifdef NTFS_CACHE_RIGHTS
        }
#endif

        //
        //  Check if the access is not granted and if we were given a parent fcb, and
        //  if the desired access was asking for delete or file read attributes.  If so
        //  then we need to do some extra work to decide if the caller does get access
        //  based on the parent directories security descriptor
        //

        if (!AccessGranted) {

            //
            //  Before we proceed load in the parent security descriptor
            //

            if (ParentFcb->SharedSecurity == NULL) {

                NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );
            }

            ASSERT( ParentFcb->SharedSecurity != NULL);

            //
            //  Now if the user is asking for delete access then check if the parent
            //  will granted delete access to the child, and if so then we munge the
            //  desired access
            //

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Add in any cached knowledge about rights that this caller
            //  is known to have for this security descriptor.
            //

            (VOID)NtfsGetCachedRights( ParentFcb->Vcb,
                                       IrpContext->Union.SubjectContext,
                                       ParentFcb->SharedSecurity,
                                       &GrantedAccess,
                                       NULL,
                                       NULL,
                                       NULL );

            if (FlagOn( GrantedAccess, FILE_DELETE_CHILD )) {

                AccessGranted = TRUE;
                Status = STATUS_SUCCESS;

            } else {
#endif

                AccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                               IrpContext->Union.SubjectContext,
                                               TRUE,                           // Tokens are locked
                                               FILE_DELETE_CHILD,
                                               0,
                                               &Privileges,
                                               IoGetFileObjectGenericMapping(),
                                               UserMode,
                                               &GrantedAccess,
                                               &Status );

#ifdef NTFS_CACHE_RIGHTS
            }
#endif
        }

    } finally {

        DebugUnwind( NtfsCheckFileForDelete );

        if (UnlockSubjectContext) {

            SeUnlockSubjectContext( IrpContext->Union.SubjectContext );
        }

        DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Exit\n") );
    }

    return Status;
}


VOID
NtfsCheckIndexForAddOrDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreatePrivileges
    )

/*++

Routine Description:

    This routine checks if a caller has permission to remove or add a link
    within a directory.

Arguments:

    ParentFcb - This is the parent directory for the add or delete operation.

    DesiredAccess - Indicates the type of operation.  We could be adding or
        removing and entry in the index.

    CreatePriveleges - Backup and restore priveleges captured at create time.

Return Value:

    None - This routine raises on error.

--*/

{
    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    NTSTATUS Status;

    BOOLEAN UnlockSubjectContext = FALSE;

    PPRIVILEGE_SET Privileges = NULL;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckIndexForAddOrDelete:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we have restore privelege then we can add either a file or directory.
        //

        if (FlagOn( CreatePrivileges, TOKEN_HAS_RESTORE_PRIVILEGE )) {

            ClearFlag( DesiredAccess,
                       DELETE | FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE );
        }

        //
        //  Do a security check if there is more being asked for.
        //

        if (DesiredAccess != 0) {

            //
            //  Finally call the security package to check for delete access.
            //  We check for delete access on the target Fcb.  If this succeeds, we
            //  are done.  Otherwise we will check for delete child access on the
            //  the parent.  Either is sufficient to perform the delete.
            //

            //
            //  Check if we need to load the security descriptor for the file
            //

            if (ParentFcb->SharedSecurity == NULL) {

                NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );

            }

            ASSERT( ParentFcb->SharedSecurity != NULL );

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Get any cached knowledge about rights that all callers are known to
            //  have for this security descriptor.
            //

            GrantedAccess = NtfsGetCachedRightsWorld( &ParentFcb->SharedSecurity->CachedRights );

            ClearFlag( DesiredAccess, GrantedAccess );
        }

        if (DesiredAccess != 0) {

            //
            //  Finally call the security package to check for delete access.
            //  We check for delete access on the target Fcb.  If this succeeds, we
            //  are done.  Otherwise we will check for delete child access on the
            //  the parent.  Either is sufficient to perform the delete.
            //
#endif

            //
            //  Capture and lock the user context, do the access check and then unlock the context
            //

            SeLockSubjectContext( IrpContext->Union.SubjectContext );
            UnlockSubjectContext = TRUE;

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Acquire any cached knowledge about rights that this caller
            //  is known to have for this security descriptor.
            //

            (VOID)NtfsGetCachedRights( ParentFcb->Vcb,
                                       IrpContext->Union.SubjectContext,
                                       ParentFcb->SharedSecurity,
                                       &GrantedAccess,
                                       NULL,
                                       NULL,
                                       NULL );

            if (FlagOn( GrantedAccess, DELETE )) {

                AccessGranted = TRUE;
                Status = STATUS_SUCCESS;

            } else {
#endif
                AccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                               IrpContext->Union.SubjectContext,
                                               TRUE,                           // Tokens are locked
                                               DesiredAccess,
                                               0,
                                               &Privileges,
                                               IoGetFileObjectGenericMapping(),
                                               UserMode,
                                               &GrantedAccess,
                                               &Status );

                //
                //  If access is not granted then we will raise
                //

                if (!AccessGranted) {

                    DebugTrace( 0, Dbg, ("Access Denied\n") );

                    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

                }
#ifdef NTFS_CACHE_RIGHTS
            }
#endif
        }

    } finally {

        DebugUnwind( NtfsCheckIndexForAddOrDelete );

        if (UnlockSubjectContext) {

            SeUnlockSubjectContext( IrpContext->Union.SubjectContext );
        }

        DebugTrace( -1, Dbg, ("NtfsCheckIndexForAddOrDelete:  Exit\n") );
    }

    return;
}


PSHARED_SECURITY
GetSharedSecurityFromDescriptorUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    )

/*++

Routine Description:

    This routine is called to create or find a shared security structure
    given an security descriptor. We check the parent if present to determine
    if we have a matching security descriptor and reference the existing one if
    so.  This routine must be called while holding the Vcb so we can
    safely access the parent structure.

Arguments:

    IrpContext - context of call

    SecurityId - Id (if known) of security descriptor.

    SecurityDescriptor - Security Descriptor for this file.

    SecurityDescriptorLength - Length of security descriptor for this file

    RaiseIfInvalid - raise if the sd is invalid rather than supplying a default
                     used during a create as opposed to an open

Return Value:

    PSHARED_SECURITY if found, NULL otherwise.

--*/

{
    ULONG Hash = 0;
    PSHARED_SECURITY SharedSecurity;

    PAGED_CODE();

    //
    //  Make sure the security descriptor we just read in is valid
    //

    if ((SecurityDescriptorLength == 0) ||
        !SeValidSecurityDescriptor( SecurityDescriptorLength, SecurityDescriptor )) {

        if (RaiseIfInvalid) {
            NtfsRaiseStatus( IrpContext, STATUS_INVALID_SECURITY_DESCR, NULL, NULL );
        }

        SecurityDescriptor = NtfsData.DefaultDescriptor;
        SecurityDescriptorLength = NtfsData.DefaultDescriptorLength;

        if (!SeValidSecurityDescriptor( SecurityDescriptorLength, SecurityDescriptor )) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }
    }

    //
    //  Hash security descriptor.  This hash must be position independent to
    //  allow for multiple instances of the same descriptor.  It is assumed
    //  that the bits within the security descriptor are all position
    //  independent, i.e, no pointers, all offsets.
    //
    //  For speed in the hash, we consider the security descriptor as an array
    //  of ULONGs.  The fragment at the end that is ignored should not affect
    //  the collision nature of this hash.
    //

    {
        PULONG Rover = (PULONG)SecurityDescriptor;
        ULONG Count = SecurityDescriptorLength / 4;

        while (Count--) {

            Hash = ((Hash << 3) | (Hash >> (32-3))) + *Rover++;
        }
    }

    DebugTrace( 0, DbgAcl, ("Hash is %08x\n", Hash) );

    //
    //  try to find it by hash
    //

    SharedSecurity = FindCachedSharedSecurityByHashUnsafe( IrpContext->Vcb,
                                                           SecurityDescriptor,
                                                           SecurityDescriptorLength,
                                                           Hash );

    //
    //  If we can't find an existing descriptor allocate new pool and copy
    //  security descriptor into it.
    //

    if (SharedSecurity == NULL) {
        SharedSecurity = NtfsAllocatePool( PagedPool,
                                           FIELD_OFFSET( SHARED_SECURITY, SecurityDescriptor )
                                               + SecurityDescriptorLength );

        SharedSecurity->ReferenceCount = 0;

        //
        //  Initialize security index data in shared security
        //

        //
        //  Set the security id in the shared structure.  If it is not
        //  invalid, also cache this shared security structure
        //

        SharedSecurity->Header.HashKey.SecurityId = SECURITY_ID_INVALID;
        SharedSecurity->Header.HashKey.Hash = Hash;
        SetSharedSecurityLength(SharedSecurity, SecurityDescriptorLength);
        SharedSecurity->Header.Offset = (ULONGLONG) 0xFFFFFFFFFFFFFFFFi64;

        RtlCopyMemory( &SharedSecurity->SecurityDescriptor,
                       SecurityDescriptor,
                       SecurityDescriptorLength );

#ifdef NTFS_CACHE_RIGHTS
        //
        //  Initialize the cached rights.
        //

        RtlZeroMemory( &SharedSecurity->CachedRights,
                       sizeof( CACHED_ACCESS_RIGHTS ));
#endif
    }

    DebugTrace( 0, DbgAcl, ("GetSharedSecurityFromDescriptorUnsafe found %08x with Id %08x\n",
                            SharedSecurity, SharedSecurity->Header.HashKey.SecurityId ));

    return SharedSecurity;
}


VOID
NtfsSetFcbSecurityFromDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    )

/*++

Routine Description:

    This routine is called to fill in the shared security structure in
    an Fcb.  We check the parent if present to determine if we have
    a matching security descriptor and reference the existing one if
    so.  This routine must be called while holding the Vcb so we can
    safely access the parent structure.

Arguments:

    IrpContext - context of call

    Fcb - Supplies the fcb for the file being operated on

    SecurityDescriptor - Security Descriptor for this file.

    SecurityDescriptorLength - Length of security descriptor for this file

Return Value:

    None.

--*/

{
    PSHARED_SECURITY SharedSecurity;

    PAGED_CODE( );

    NtfsAcquireFcbSecurity( Fcb->Vcb );

    try {
        SharedSecurity = GetSharedSecurityFromDescriptorUnsafe( IrpContext,
                                                                SecurityDescriptor,
                                                                SecurityDescriptorLength,
                                                                RaiseIfInvalid );

        SharedSecurity->ReferenceCount += 1;
        DebugTrace( +1, DbgAcl, ("NtfsSetFcbSecurityFromDescriptor bumping refcount %08x\n", SharedSecurity ));

        ASSERT( Fcb->SharedSecurity == NULL );
        Fcb->SharedSecurity = SharedSecurity;

        AddCachedSharedSecurityUnsafe( IrpContext->Vcb, SharedSecurity );

    } finally {

        NtfsReleaseFcbSecurity( Fcb->Vcb );
    }

    return;
}


BOOLEAN
NtfsNotifyTraverseCheck (
    IN PCCB Ccb,
    IN PFCB Fcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++

Routine Description:

    This routine is the callback routine provided to the dir notify package
    to check that a caller who is watching a tree has traverse access to
    the directory which has the change.  This routine is only called
    when traverse access checking was turned on for the open used to
    perform the watch.

Arguments:

    Ccb - This is the Ccb associated with the directory which is being
        watched.

    Fcb - This is the Fcb for the directory which contains the file being
        modified.  We want to walk up the tree from this point and check
        that the caller has traverse access across that directory.
        If not specified then there is no work to do.

    SubjectContext - This is the subject context captured at the time the
        dir notify call was made.

Return Value:

    BOOLEAN - TRUE if the caller has traverse access to the file which was
        changed.  FALSE otherwise.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    PFCB TopFcb;

    IRP_CONTEXT LocalIrpContext;
    IRP LocalIrp;

    PIRP_CONTEXT IrpContext;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    NTSTATUS Status = STATUS_SUCCESS;
#ifdef NTFS_CACHE_RIGHTS
    NTSTATUS TokenInfoStatus = STATUS_UNSUCCESSFUL;
#endif

    PPRIVILEGE_SET Privileges = NULL;
    PAGED_CODE();

    //
    //  If we have no Fcb then we can return immediately.
    //

    if (Fcb == NULL) {

        return TRUE;
    }

    IrpContext = &LocalIrpContext;
    NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );

    IrpContext->OriginatingIrp = &LocalIrp;
    IrpContext->Vcb = Fcb->Vcb;

    //
    //  Make sure we don't get any pop-ups
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    NtfsUpdateIrpContextWithTopLevel( IrpContext, &TopLevelContext );

    TopFcb = Ccb->Lcb->Fcb;

    //
    //  Use a try-except to catch all of the errors.
    //

    try {

        //
        //  Always lock the subject context.
        //

        SeLockSubjectContext( SubjectContext );

        //
        //  Use a try-finally to perform local cleanup.
        //

        try {

            //
            //  We look while walking up the tree.
            //

            do {

#ifdef NTFS_CACHE_RIGHTS
                LUID ModifiedId;
                LUID TokenId;
#endif
                PLCB ParentLcb;

                //
                //  Since this is a directory it can have only one parent.  So
                //  we can use any Lcb to walk upwards.
                //

                ParentLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                               LCB,
                                               FcbLinks );

                Fcb = ParentLcb->Scb->Fcb;

                //
                //  Check if we need to load the security descriptor for the file
                //

                if (Fcb->SharedSecurity == NULL) {

                    NtfsLoadSecurityDescriptor( IrpContext, Fcb );
                }

#ifdef NTFS_CACHE_RIGHTS
                //
                //  Acquire any cached knowledge about rights that this caller
                //  is known to have for this security descriptor.
                //
                //  Note that we can trust that TokenId and ModifiedId won't
                //  change inside this block of code because we have locked
                //  the subject context above.
                //

                if (TokenInfoStatus != STATUS_SUCCESS) {

                    //
                    //  We have not previously acquired the Id information.
                    //

                    TokenInfoStatus = NtfsGetCachedRights( Fcb->Vcb,
                                                           SubjectContext,
                                                           Fcb->SharedSecurity,
                                                           &GrantedAccess,
                                                           NULL,
                                                           &TokenId,
                                                           &ModifiedId );
                } else {

                    NtfsGetCachedRightsById( Fcb->Vcb,
                                             &TokenId,
                                             &ModifiedId,
                                             SubjectContext,
                                             Fcb->SharedSecurity,
                                             NULL,
                                             &GrantedAccess );
                }

                if (FlagOn( GrantedAccess, FILE_TRAVERSE )) {

                    AccessGranted = TRUE;

                } else {
#endif
                    AccessGranted = SeAccessCheck( &Fcb->SharedSecurity->SecurityDescriptor,
                                                   SubjectContext,
                                                   TRUE,                           // Tokens are locked
                                                   FILE_TRAVERSE,
                                                   0,
                                                   &Privileges,
                                                   IoGetFileObjectGenericMapping(),
                                                   UserMode,
                                                   &GrantedAccess,
                                                   &Status );
#ifdef NTFS_CACHE_RIGHTS
                }
#endif

            } while (AccessGranted && (Fcb != TopFcb));

        } finally {

            SeUnlockSubjectContext( SubjectContext );
        }

    } except (NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        NOTHING;
    }

    NtfsCleanupIrpContext( IrpContext, TRUE );

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    return AccessGranted;
}


VOID
NtfsInitializeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to initialize the security indexes and descriptor
    stream.

Arguments:

    IrpContext - context of call

    Vcb - Supplies the volume being initialized

    Fcb - Supplies the file containing the seurity indexes and descriptor
        stream.

Return Value:

    None.

--*/

{
    UNICODE_STRING SecurityIdIndexName = CONSTANT_UNICODE_STRING( L"$SII" );
    UNICODE_STRING SecurityDescriptorHashIndexName = CONSTANT_UNICODE_STRING( L"$SDH" );
    UNICODE_STRING SecurityDescriptorStreamName = CONSTANT_UNICODE_STRING( L"$SDS" );

    MAP_HANDLE Map;
    NTSTATUS Status;

    PAGED_CODE( );

    //
    //  Open/Create the security descriptor stream
    //

    NtOfsCreateAttribute( IrpContext,
                          Fcb,
                          SecurityDescriptorStreamName,
                          CREATE_OR_OPEN,
                          TRUE,
                          &Vcb->SecurityDescriptorStream );

    NtfsAcquireSharedScb( IrpContext, Vcb->SecurityDescriptorStream );

    //
    //  Load the run information for the Security data stream.
    //  Note this call must be done after the stream is nonresident.
    //

    if (!FlagOn( Vcb->SecurityDescriptorStream->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {
        NtfsPreloadAllocation( IrpContext,
                               Vcb->SecurityDescriptorStream,
                               0,
                               MAXLONGLONG );
    }

    //
    //  Open the Security descriptor indexes and storage.
    //

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      SecurityIdIndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_ULONG,
                      NtOfsCollateUlong,
                      NULL,
                      &Vcb->SecurityIdIndex );

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      SecurityDescriptorHashIndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_SECURITY_HASH,
                      NtOfsCollateSecurityHash,
                      NULL,
                      &Vcb->SecurityDescriptorHashIndex );

    //
    //  Retrieve the next security Id to allocate
    //

    try {

        SECURITY_ID LastSecurityId = 0xFFFFFFFF;
        INDEX_KEY LastKey;
        INDEX_ROW LastRow;

        LastKey.KeyLength = sizeof( SECURITY_ID );
        LastKey.Key = &LastSecurityId;

        Map.Bcb = NULL;

        Status = NtOfsFindLastRecord( IrpContext,
                                      Vcb->SecurityIdIndex,
                                      &LastKey,
                                      &LastRow,
                                      &Map );

        //
        //  If we've found the last key, set the next Id to allocate to be
        //  one greater than this last key.
        //

        if (Status == STATUS_SUCCESS) {

            ASSERT( LastRow.KeyPart.KeyLength == sizeof( SECURITY_ID ) );
            if (LastRow.KeyPart.KeyLength != sizeof( SECURITY_ID )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            DebugTrace( 0, DbgAcl, ("Found last security Id in index\n") );
            Vcb->NextSecurityId = *(SECURITY_ID *)LastRow.KeyPart.Key + 1;

        //
        //  If the index is empty, then set the next Id to be the beginning of the
        //  user range.
        //

        } else if (Status == STATUS_NO_MATCH) {

            DebugTrace( 0, DbgAcl, ("Security Id index is empty\n") );
            Vcb->NextSecurityId = SECURITY_ID_FIRST;

        } else {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        DebugTrace( 0, DbgAcl, ("NextSecurityId is %x\n", Vcb->NextSecurityId) );

    } finally {

        NtOfsReleaseMap( IrpContext, &Map );
    }
}


PSHARED_SECURITY
NtfsCacheSharedSecurityBySecurityId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId
    )

/*++

Routine Description:

    This routine maps looks up a shared security structure given the security Id by
    looking in the per-Vcb cache or loads it if not present.

Arguments:

    IrpContext - Context of call

    Vcb - Volume where security Id is cached

    SecurityId - security Id for descriptor that is being retrieved

Return Value:

    Referenced PSHARED_SECURITY of found descriptor.

--*/

{
    PSHARED_SECURITY *Bucket;
    PSHARED_SECURITY SharedSecurity;
    PBCB Bcb;
    PSECURITY_DESCRIPTOR_HEADER SecurityDescriptorHeader;

    PAGED_CODE( );

    NtfsAcquireFcbSecurity( Vcb );

    //
    //  Probe the cache by Id
    //

    Bucket = Vcb->SecurityCacheById[SecurityId % VCB_SECURITY_CACHE_BY_ID_SIZE];

    //
    //  We get a match under the following conditions.
    //
    //      - There is a corresponding entry in the SecurityID array
    //      - This entry points to an entry in the SecurityHash array
    //      - The entry in the SecurityHash array has the correct SecurityID
    //

    if ((Bucket != NULL) &&
        ((SharedSecurity = *Bucket) != NULL) &&
        (SharedSecurity->Header.HashKey.SecurityId == SecurityId)) {

        DebugTrace( 0, DbgAcl, ("Found cached security descriptor %x %x\n",
            SharedSecurity, SharedSecurity->Header.HashKey.SecurityId) );

        DebugTrace( 0, DbgAcl, ("NtfsCacheSharedSecurityBySecurityId bumping refcount %08x\n", SharedSecurity ));

        //
        //  We found the correct shared security.  Make sure it cannot go
        //  away on us.
        //

        SharedSecurity->ReferenceCount += 1;
        NtfsReleaseFcbSecurity( Vcb );
        return SharedSecurity;
    }

    //
    //  If we get here we didn't find a matching descriptor.  Throw away
    //  the incorrect security descriptor we may have found through the
    //  SecurityID array.
    //

    SharedSecurity = NULL;
    NtfsReleaseFcbSecurity( Vcb );

    //
    //  If we don't have a security index, then return the default security descriptor.
    //  This should only happen in cases of corrupted volumes or security indices.
    //

    if (Vcb->SecurityDescriptorStream == NULL) {

        DebugTrace( 0, 0, ("No security index present in Vcb, using default descriptor\n") );
        return NULL;
    }

    //
    //  We don't have the descriptor in the cache and have to load it from disk.
    //

    Bcb = NULL;

    DebugTrace( 0, DbgAcl, ("Looking up security descriptor %x\n", SecurityId) );

    //
    //  Lock down the security stream
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->SecurityDescriptorStream );

    //
    //  Reacquire the security mutex
    //

    NtfsAcquireFcbSecurity( Vcb );

    try {

        //
        //  Consult the Vcb index to map to the security descriptor
        //

        if (!MapSecurityIdToSecurityDescriptorHeaderUnsafe( IrpContext,
                                                            Vcb,
                                                            SecurityId,
                                                            &SecurityDescriptorHeader,
                                                            &Bcb )) {

            //
            //  We couldn't find the Id.  We generate a security descriptor from
            //  the default one.
            //

            leave;
        }

        DebugTrace( 0, DbgAcl, ("Found it at %16I64X\n", SecurityDescriptorHeader->Offset) );

        //
        //  Look up the security descriptor by hash (just in case)
        //

        SharedSecurity = FindCachedSharedSecurityByHashUnsafe( Vcb,
                                                               (PSECURITY_DESCRIPTOR) ( SecurityDescriptorHeader + 1 ),
                                                               GETSECURITYDESCRIPTORLENGTH( SecurityDescriptorHeader ),
                                                               SecurityDescriptorHeader->HashKey.Hash );

        //
        //  If not found
        //

        if (SharedSecurity == NULL) {

            DebugTrace( 0, DbgAcl, ("Not in hash table, creating new SHARED SECURITY\n") );

            SharedSecurity = NtfsAllocatePool( PagedPool,
                                               FIELD_OFFSET( SHARED_SECURITY, Header ) + SecurityDescriptorHeader->Length );

            SharedSecurity->ReferenceCount = 0;

            RtlCopyMemory( &SharedSecurity->Header,
                           SecurityDescriptorHeader,
                           SecurityDescriptorHeader->Length );

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Initialize the cached rights.
            //

            RtlZeroMemory( &SharedSecurity->CachedRights,
                           sizeof( CACHED_ACCESS_RIGHTS ));
#endif

        } else {
            DebugTrace( 0, DbgAcl, ("Found in hash table %x, promoting header\n", SharedSecurity) );
            //
            //  We found the descriptor by hash.  Perform some consistency checks
            //


#if DBG
            if (SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID &&
                SharedSecurity->Header.HashKey.SecurityId != SecurityId )
                DebugTrace( 0, 0, ("Duplicate hash entry found %x %x\n", SecurityId,
                                   SharedSecurity->Header.HashKey.SecurityId ));
#endif

            SharedSecurity->Header = *SecurityDescriptorHeader;
        }

        //
        //  reference the security descriptor
        //

        SharedSecurity->ReferenceCount += 1;

        //
        //  Regardless of whether we found it by hash (since the earlier Id probe missed)
        //  or created it anew.  Let's put it back into the cache
        //

        AddCachedSharedSecurityUnsafe( Vcb, SharedSecurity );

    } finally {

        NtfsUnpinBcb( IrpContext, &Bcb );
        NtfsReleaseScb( IrpContext, Vcb->SecurityDescriptorStream );

        //
        //  Release access to security cache
        //

        NtfsReleaseFcbSecurity( Vcb );
    }

    //
    //  if we did not generate a shared security, then build one from
    //  the default security descriptor
    //

    if (SharedSecurity == NULL) {
        DebugTrace( 0, 0, ("Security Id %x not found, using default\n", SecurityId) );
        SharedSecurity = NtfsCacheSharedSecurityByDescriptor( IrpContext,
                                                              NtfsData.DefaultDescriptor,
                                                              NtfsData.DefaultDescriptorLength,
                                                              FALSE );
    }

    return SharedSecurity;
}


//
//  Local Support routine
//

PSHARED_SECURITY
FindCachedSharedSecurityByHashUnsafe (
    IN PVCB Vcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN ULONG Hash
    )

/*++

Routine Description:

    This routine maps looks up a shared security structure given the Hash by
    looking in the per-Vcb cache.  This routine assumes exclusive access to the
    security cache.

Arguments:

    Vcb - Volume where security Id is cached

    SecurityDescriptor - Security descriptor being retrieved

    SecurityDescriptorLength - length of descriptor.

    Hash - Hash for descriptor that is being retrieved

Return Value:

    PSHARED_SECURITY of found shared descriptor.  Otherwise, NULL is returned.

--*/

{
    PSHARED_SECURITY SharedSecurity;

    PAGED_CODE( );

    //
    //  Hash the hash into the per-volume table

    SharedSecurity = Vcb->SecurityCacheByHash[Hash % VCB_SECURITY_CACHE_BY_HASH_SIZE];

    //
    //  If there is no shared descriptor there, then no match
    //

    if (SharedSecurity == NULL) {
        return NULL;
    }

    //
    //  if the hash doesn't match then no descriptor found
    //

    if (SharedSecurity->Header.HashKey.Hash != Hash) {
        return NULL;
    }

    //
    //  If the lengths don't match then no descriptor found
    //

    if (GetSharedSecurityLength( SharedSecurity ) != SecurityDescriptorLength) {
        return NULL;
    }

    //
    //  If the security descriptor bits don't compare then no match
    //

    if (!RtlEqualMemory( SharedSecurity->SecurityDescriptor,
                         SecurityDescriptor,
                         SecurityDescriptorLength) ) {
        return NULL;
    }


    //
    //  The shared security was found
    //

    return SharedSecurity;
}


//
//  Local Support routine
//

VOID
AddCachedSharedSecurityUnsafe (
    IN PVCB Vcb,
    PSHARED_SECURITY SharedSecurity
    )

/*++

Routine Description:

    This routine adds shared security to the Vcb Cache.  This routine assumes
    exclusive access to the security cache.  The shared security being added
    may have a ref count of one and may already be in the table.

Arguments:

    Vcb - Volume where security Id is cached

    SharedSecurity - descriptor to be added to the cache

Return Value:

    None.

--*/

{
    PSHARED_SECURITY *Bucket;
    PSHARED_SECURITY Old;

    PAGED_CODE( );

    //
    //  Is there an item already in the hash bucket?
    //

    Bucket = &Vcb->SecurityCacheByHash[SharedSecurity->Header.HashKey.Hash % VCB_SECURITY_CACHE_BY_HASH_SIZE];

    Old = *Bucket;

    //
    //  Place it into the bucket and reference it
    //

    *Bucket = SharedSecurity;
    SharedSecurity->ReferenceCount += 1;
    DebugTrace( 0, DbgAcl, ("AddCachedSharedSecurityUnsafe bumping refcount %08x\n", SharedSecurity ));

    //
    //  Set up hash to point to bucket
    //

    Vcb->SecurityCacheById[SharedSecurity->Header.HashKey.SecurityId % VCB_SECURITY_CACHE_BY_ID_SIZE] = Bucket;

    //
    //  Handle removing the old value from the bucket.  We do this after advancing
    //  the ReferenceCount above in the case where the item is already in the bucket.
    //

    if (Old != NULL) {

        //
        //  Remove and dereference the item in the bucket
        //

        RemoveReferenceSharedSecurityUnsafe( &Old );
    }

    return;
}


VOID
NtOfsPurgeSecurityCache (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine removes all shared security from the per-Vcb cache.

Arguments:

    Vcb - Volume where descriptors are cached

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE( );

    //
    //  Serialize access to the security cache
    //

    NtfsAcquireFcbSecurity( Vcb );

    //
    //  Walk through the cache looking for cached security
    //

    for (i = 0; i < VCB_SECURITY_CACHE_BY_ID_SIZE; i++)
    {
        if (Vcb->SecurityCacheByHash[i] != NULL) {
            //
            //  Remove the reference to the security
            //

            PSHARED_SECURITY SharedSecurity = Vcb->SecurityCacheByHash[i];
            Vcb->SecurityCacheByHash[i] = NULL;
            RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
        }
    }

    //
    //  Release access to the cache
    //

    NtfsReleaseFcbSecurity( Vcb );
}


//
//  Local Support routine
//

BOOLEAN
MapSecurityIdToSecurityDescriptorHeaderUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId,
    OUT PSECURITY_DESCRIPTOR_HEADER *SecurityDescriptorHeader,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine maps from a security Id to the descriptor bits stored in the
    security descriptor stream using the security Id index.

Arguments:

    IrpContext - Context of the call

    Vcb - Volume where descriptor is stored

    SecurityId - security Id for descriptor that is being retrieved

    SecurityDescriptorHeader - returned security descriptor pointer

    Bcb - returned mapping control structure

Return Value:

    True if the descriptor header was successfully mapped.

--*/

{
    SECURITY_DESCRIPTOR_HEADER Header;
    NTSTATUS Status;
    MAP_HANDLE Map;
    INDEX_ROW Row;
    INDEX_KEY Key;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    PAGED_CODE( );

    DebugTrace( 0, DbgAcl, ("Mapping security ID %08x\n", SecurityId) );

    //
    //  Lookup descriptor stream position information.
    //  The format of the key is simply the ULONG SecurityId
    //

    Key.KeyLength = sizeof( SecurityId );
    Key.Key = &SecurityId;

    Status = NtOfsFindRecord( IrpContext,
                              Vcb->SecurityIdIndex,
                              &Key,
                              &Row,
                              &Map,
                              NULL );

    DebugTrace( 0, DbgAcl, ("Security Id lookup status = %08x\n", Status) );

    //
    //  If the security Id is not found, we let the called decide if the volume
    //  needs fixing or whether a default descriptor should be used.
    //

    if (Status == STATUS_NO_MATCH) {
        return FALSE;
    }

    //
    //  Save security descriptor offset and length information
    //

    Header = *(PSECURITY_DESCRIPTOR_HEADER)Row.DataPart.Data;
    ASSERT( Header.HashKey.SecurityId == SecurityId );

    //
    //  Release mapping information
    //

    NtOfsReleaseMap( IrpContext, &Map );

    //
    //  Make sure that the data is the correct size.  This is a true failure case
    //  where we must fix the disk up. We can just return false because caller
    //  will then use a default sd and chkdsk will replace with the same default
    //  when it next  verifies the disk
    //

    ASSERT( Row.DataPart.DataLength == sizeof( SECURITY_DESCRIPTOR_HEADER ) );
    if (Row.DataPart.DataLength != sizeof( SECURITY_DESCRIPTOR_HEADER )) {
        DebugTrace( 0, DbgAcl, ("SecurityId data doesn't have the correct length\n") );
        return FALSE;
    }

    //
    //  Don't try to map clearly invalid sections of the sds stream
    //

    if (Header.Offset > (ULONGLONG)(Vcb->SecurityDescriptorStream->Header.FileSize.QuadPart) ||
        Header.Offset + Header.Length > (ULONGLONG)(Vcb->SecurityDescriptorStream->Header.FileSize.QuadPart)) {
        DebugTrace( 0, DbgAcl, ("SecurityId data doesn't have a correct position\n") );
        return FALSE;
    }

    //
    //  Map security descriptor
    //

    DebugTrace( 0, DbgAcl, ("Mapping security descriptor stream at %I64x, len %x\n",
                    Header.Offset, Header.Length) );

    NtfsMapStream(
        IrpContext,
        Vcb->SecurityDescriptorStream,
        Header.Offset,
        Header.Length,
        Bcb,
        SecurityDescriptorHeader );

    //
    //  Sanity check the found descriptor
    //

    if (RtlCompareMemory( &Header, *SecurityDescriptorHeader, sizeof( Header )) != sizeof( Header )) {
        DebugTrace( 0, DbgAcl, ("Index data does not match stream header\n") );
        return FALSE;
    }

    //
    //  Now actually verify the descriptor is valid. If length is too small (even 0)
    //  SeValidSecurityDescriptor will safely return false so we don't need to test this
    //  before calling
    //

    SecurityDescriptor = (PSECURITY_DESCRIPTOR) Add2Ptr( (*SecurityDescriptorHeader), sizeof( SECURITY_DESCRIPTOR_HEADER ) );

    if (!SeValidSecurityDescriptor( GETSECURITYDESCRIPTORLENGTH( *SecurityDescriptorHeader ), SecurityDescriptor )) {
        DebugTrace( 0, DbgAcl, ("SecurityId data is not valid\n") );
        return FALSE;
    }

#if DBG
    {
        ULONG SecurityDescLength;

        SecurityDescLength = RtlLengthSecurityDescriptor( SecurityDescriptor );
        ASSERT( SecurityDescLength == GETSECURITYDESCRIPTORLENGTH( *SecurityDescriptorHeader ) );
    }
#endif

    return TRUE;
}


VOID
NtfsLoadSecurityDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine loads the shared security descriptor into the fcb for the
    file from disk using either the SecurityId or the $Security_Descriptor

Arguments:

    Fcb - Supplies the fcb for the file being operated on

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERTMSG("Must only be called with a null value here", Fcb->SharedSecurity == NULL);

    DebugTrace( +1, DbgAcl, ("NtfsLoadSecurityDescriptor...\n") );

    //
    //  If the file has a valid SecurityId then retrieve the security descriptor
    //  from the security descriptor index
    //

    if ((Fcb->SecurityId != SECURITY_ID_INVALID) &&
        (Fcb->Vcb->SecurityDescriptorStream != NULL)) {

        ASSERT( Fcb->SharedSecurity == NULL );
        Fcb->SharedSecurity = NtfsCacheSharedSecurityBySecurityId( IrpContext,
                                                                   Fcb->Vcb,
                                                                   Fcb->SecurityId );

        ASSERT( Fcb->SharedSecurity != NULL );

    } else {

        PBCB Bcb = NULL;
        PSECURITY_DESCRIPTOR SecurityDescriptor;
        ULONG SecurityDescriptorLength;
        ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
        PATTRIBUTE_RECORD_HEADER Attribute;

        try {
            //
            //  Read in the security descriptor attribute, and if it is not present
            //  then there then the file is not protected.  In that case we will
            //  use the default descriptor.
            //

            NtfsInitializeAttributeContext( &AttributeContext );

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $SECURITY_DESCRIPTOR,
                                            &AttributeContext )) {

                DebugTrace( 0, DbgAcl, ("Security Descriptor attribute does not exist\n") );

                SecurityDescriptor = NtfsData.DefaultDescriptor;
                SecurityDescriptorLength = NtfsData.DefaultDescriptorLength;

            } else {

                //
                //  There must be a security descriptor with a non-zero length; only
                //  applies for non-resident descriptors with valid data length.
                //

                Attribute = NtfsFoundAttribute( &AttributeContext );

                if (NtfsIsAttributeResident( Attribute ) ?
                    (Attribute->Form.Resident.ValueLength == 0) :
                    (Attribute->Form.Nonresident.ValidDataLength == 0)) {

                    SecurityDescriptor = NtfsData.DefaultDescriptor;
                    SecurityDescriptorLength = NtfsData.DefaultDescriptorLength;

                } else {

                    NtfsMapAttributeValue( IrpContext,
                                           Fcb,
                                           (PVOID *)&SecurityDescriptor,
                                           &SecurityDescriptorLength,
                                           &Bcb,
                                           &AttributeContext );
                }
            }

            NtfsSetFcbSecurityFromDescriptor(
                                   IrpContext,
                                   Fcb,
                                   SecurityDescriptor,
                                   SecurityDescriptorLength,
                                   FALSE );
            } finally {

            DebugUnwind( NtfsLoadSecurityDescriptor );

            //
            //  Cleanup our attribute enumeration context and the Bcb
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsUnpinBcb( IrpContext, &Bcb );
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ("NtfsLoadSecurityDescriptor -> VOID\n") );

    return;
}


//
//  Local Support routine
//

NTSTATUS
NtOfsMatchSecurityHash (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

/*++

Routine Description:

    Test whether an index row is worthy of returning based on its contents as
    a row in the SecurityDescriptorHashIndex.

Arguments:

    IndexRow - row that is being tested

    MatchData - a PVOID that is the hash function we look for.

Returns:

    STATUS_SUCCESS if the IndexRow matches
    STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
        continue
    STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
        should terminate


--*/

{
    ASSERT(IndexRow->KeyPart.KeyLength == sizeof( SECURITY_HASH_KEY ) );

    PAGED_CODE( );

    if (((PSECURITY_HASH_KEY)IndexRow->KeyPart.Key)->Hash == (ULONG)((ULONG_PTR) MatchData)) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_NO_MORE_MATCHES;
    }
}


//
//  Local Support routine
//

VOID
NtOfsLookupSecurityDescriptorInIndex (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    )

/*++

Routine Description:

    Look up the security descriptor in the index.  If found, return the
    security ID.

Arguments:

    IrpContext - context of the call

    SharedSecurity - shared security for a file

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DebugTrace( +1, DbgAcl, ("NtOfsLookupSecurityDescriptorInIndex...\n") );

    //
    //  For each matching hash record in the index, see if the actual security
    //  security descriptor matches.
    //

    {
        INDEX_KEY IndexKey;
        INDEX_ROW FoundRow;
        PSECURITY_DESCRIPTOR_HEADER Header;
        UCHAR HashDescriptorHeader[2 * (sizeof( SECURITY_DESCRIPTOR_HEADER ) + sizeof( ULONG ))];

        PINDEX_KEY Key = &IndexKey;
        PREAD_CONTEXT ReadContext = NULL;
        ULONG FoundCount = 0;
        PBCB Bcb = NULL;

        IndexKey.KeyLength = sizeof( SharedSecurity->Header.HashKey );
        IndexKey.Key = &SharedSecurity->Header.HashKey.Hash;

        try {
            //
            //  We keep reading hash records until we find a hash.
            //

            while (SharedSecurity->Header.HashKey.SecurityId == SECURITY_ID_INVALID) {

                //
                //  Read next matching SecurityHashIndex record
                //

                FoundCount = 1;
                NtOfsReadRecords( IrpContext,
                                  IrpContext->Vcb->SecurityDescriptorHashIndex,
                                  &ReadContext,
                                  Key,
                                  NtOfsMatchSecurityHash,
                                  ULongToPtr( SharedSecurity->Header.HashKey.Hash ),
                                  &FoundCount,
                                  &FoundRow,
                                  sizeof( HashDescriptorHeader ),
                                  &HashDescriptorHeader[0]);

                //
                //  Set next read to read sequentially rather than explicitly
                //  seek.
                //

                Key = NULL;

                //
                //  If there were no more records found, then go and establish a
                //  a new security Id.
                //

                if (FoundCount == 0) {
                    break;
                }

                //
                //  Examine the row to see if the descriptors are
                //  the same.  Verify the cache contents.
                //

                ASSERT( FoundRow.DataPart.DataLength == sizeof( SECURITY_DESCRIPTOR_HEADER ) );
                if (FoundRow.DataPart.DataLength != sizeof( SECURITY_DESCRIPTOR_HEADER )) {
                    DebugTrace( 0, DbgAcl, ("Found row has a bad size\n") );
                    NtfsRaiseStatus( IrpContext,
                                     STATUS_DISK_CORRUPT_ERROR,
                                     NULL, NULL );
                }

                Header = (PSECURITY_DESCRIPTOR_HEADER)FoundRow.DataPart.Data;

                //
                //  If the length of the security descriptor in the stream is NOT
                //  the same as the current security descriptor, then a match is
                //  not possible
                //

                if (SharedSecurity->Header.Length != Header->Length) {
                    DebugTrace( 0, DbgAcl, ("Descriptor has wrong length\n") );
                    continue;
                }

                //
                //  Map security descriptor given descriptor stream position.
                //

                try {
                    PSECURITY_DESCRIPTOR_HEADER TestHeader;

                    NtfsMapStream( IrpContext,
                                   IrpContext->Vcb->SecurityDescriptorStream,
                                   Header->Offset,
                                   Header->Length,
                                   &Bcb,
                                   &TestHeader );

                    //
                    //  Make sure index data matches stream data
                    //

                    ASSERT( (TestHeader->HashKey.Hash == Header->HashKey.Hash) &&
                            (TestHeader->HashKey.SecurityId == Header->HashKey.SecurityId) &&
                            (TestHeader->Length == Header->Length) );

                    //
                    //  Compare byte-for-byte the security descriptors.  We do not
                    //  perform any rearranging of descriptors into canonical forms.
                    //

                    if (RtlEqualMemory( SharedSecurity->SecurityDescriptor,
                                        TestHeader + 1,
                                        GetSharedSecurityLength( SharedSecurity )) ) {
                        //
                        //  We have a match.  Save the found header
                        //

                        SharedSecurity->Header = *TestHeader;
                        DebugTrace( 0, DbgAcl, ("Reusing indexed security Id %x\n",
                                    TestHeader->HashKey.SecurityId) );
                        leave;
                    }

                    DebugTrace( 0, 0, ("Descriptors different in bits %x\n", TestHeader->HashKey.SecurityId));

                } finally {
                    NtfsUnpinBcb( IrpContext, &Bcb );
                }
            }

        } finally {
            if (ReadContext != NULL) {
                NtOfsFreeReadContext( ReadContext );
            }
        }
    }

    DebugTrace( -1, DbgAcl, ("NtOfsLookupSecurityDescriptorInIndex...Done\n") );

    return;
}


//
//  Local Support routine
//

SECURITY_ID
GetSecurityIdFromSecurityDescriptorUnsafe (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    )

/*++

Routine Description:

    Return the security Id associated with a given security descriptor. If
    there is an existing Id, return it.  If no Id exists, create one. This assumes
    security mutex is already acquired

Arguments:

    IrpContext - context of the call

    SharedSecurity - Shared security used by file

Return Value:

    SECURITY_ID corresponding to the unique instantiation of the security
            descriptor on the volume.

--*/

{
    SECURITY_ID SavedSecurityId;
    LONGLONG NextDescriptorOffset, PaddedNextDescriptorOffset;

    PAGED_CODE( );

    DebugTrace( +1, DbgAcl, ("GetSecurityIdFromSecurityDescriptorUnsafe...\n") );

    //
    //  Drop the security mutex since we are going to acquire / extend the descriptor stream
    //  and the mutex is basically an end resource. Inc ref. count to keep
    //  shared security around
    //

    SharedSecurity->ReferenceCount += 1;
    NtfsReleaseFcbSecurity( IrpContext->Vcb );

    //
    //  Find descriptor in indexes/stream
    //

    try {

        //
        //  Make sure the data structures don't change underneath us
        //

        NtfsAcquireSharedScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

        //
        //  Save next Security Id.  This is used if we fail to find the security
        //  descriptor in the descriptor stream.
        //

        SavedSecurityId = IrpContext->Vcb->NextSecurityId;

        NtOfsLookupSecurityDescriptorInIndex( IrpContext, SharedSecurity );

        //
        //  If we've found the security descriptor in the stream we're done.
        //

        if (SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID) {
            leave;
        }

        //
        //  The security descriptor is not found.  Reacquire the security
        //  stream exclusive since we are about to modify it.
        //

        NtfsReleaseScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );
        NtfsAcquireExclusiveScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

        //
        //  During the short interval above, we did not own the security stream.
        //  It is possible that another thread has gotten in and created this
        //  descriptor.  Therefore, we must probe the indexes again.
        //
        //  Rather than perform this expensive test *always*, we saved the next
        //  security id to be allocated above.  Now that we've obtained the stream
        //  exclusive we can check to see if the saved one is the same as the next
        //  one.  If so, then we need to probe the indexes.  Otherwise
        //  we know that no modifications have taken place.
        //

        if (SavedSecurityId != IrpContext->Vcb->NextSecurityId) {
            DebugTrace( 0, DbgAcl, ("SecurityId changed, rescanning\n") );

            //
            //  The descriptor cache has been edited.  We must search again
            //

            NtOfsLookupSecurityDescriptorInIndex( IrpContext, SharedSecurity );

            //
            //  If the Id was found this time, simply return it
            //

            if (SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID) {
                leave;
            }
        }

        //
        //  Allocate security id.  This does not need to be logged since we only
        //  increment this and initialize this from the max key in the index at
        //  mount time.
        //

        SharedSecurity->Header.HashKey.SecurityId = IrpContext->Vcb->NextSecurityId++;

        //
        //  Determine allocation location in descriptor stream.  The alignment
        //  requirements for security descriptors within the stream are:
        //
        //      DWORD alignment
        //      Not spanning a VACB_MAPPING_GRANULARITY boundary
        //

        //
        //  Get current EOF for descriptor stream.  This includes the replicated
        //  region.  Remove the replicated region (& ~VACB_MAPPING_GRANULARITY)
        //

#if DBG
        {
            LONGLONG Tmp = NtOfsQueryLength( IrpContext->Vcb->SecurityDescriptorStream );
            ASSERT( Tmp == 0 || (Tmp & VACB_MAPPING_GRANULARITY) );
        }
#endif

        NextDescriptorOffset = NtOfsQueryLength( IrpContext->Vcb->SecurityDescriptorStream ) & ~VACB_MAPPING_GRANULARITY;

        //
        //  Align to 16 byte boundary.
        //

        PaddedNextDescriptorOffset =
        SharedSecurity->Header.Offset = (NextDescriptorOffset + 0xF) & 0xFFFFFFFFFFFFFFF0i64;

        DebugTrace( 0,
                    DbgAcl,
                    ("Allocating SecurityId %x at %016I64x\n",
                     SharedSecurity->Header.HashKey.SecurityId,
                     SharedSecurity->Header.Offset) );

        //
        //  Make sure we don't span a VACB_MAPPING_GRANULARITY boundary and
        //  have enough room for a completely-zero header.
        //

        if (
            //
            //  Offset in window
            //

            (SharedSecurity->Header.Offset & (VACB_MAPPING_GRANULARITY - 1))

            //
            //  Plus size security stream entry
            //

                + SharedSecurity->Header.Length

            //
            //  Plus size of one empty header
            //

                + sizeof( SharedSecurity->Header )

            //
            //  goes into the next block
            //
                 > VACB_MAPPING_GRANULARITY) {

            //
            //  We are about to span the mapping granularity of the cache manager
            //  so we want to place this into the next cache window.  However,
            //  the following window is where the replicated descriptors are
            //  stored.  We must advance to the window beyond that.
            //

            SharedSecurity->Header.Offset =

                //
                //  Round down to previous VACB_MAPPING GRANULARITY
                //

                (SharedSecurity->Header.Offset & ~(VACB_MAPPING_GRANULARITY - 1))

                //
                //  Move past this window and replicated window
                //

                + 2 * VACB_MAPPING_GRANULARITY;

            //
            //  The next descriptor offset is used for zeroing out the padding
            //

            PaddedNextDescriptorOffset = SharedSecurity->Header.Offset - VACB_MAPPING_GRANULARITY;
        }

        //
        //  Grow security stream to make room for new descriptor and header. This
        //  takes into account the replicated copy of the descriptor.
        //

        NtOfsSetLength( IrpContext,
                        IrpContext->Vcb->SecurityDescriptorStream,
                        (SharedSecurity->Header.Offset +
                         SharedSecurity->Header.Length +
                         VACB_MAPPING_GRANULARITY) );

        //
        //  Zero out any alignment padding since Chkdsk verifies the replication by
        //  doing 256K memcmp's.
        //

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      NextDescriptorOffset + VACB_MAPPING_GRANULARITY,
                      (ULONG)(PaddedNextDescriptorOffset - NextDescriptorOffset),
                      NULL );

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      NextDescriptorOffset,
                      (ULONG)(PaddedNextDescriptorOffset - NextDescriptorOffset),
                      NULL );

        //
        //  Put the new descriptor into the stream in both the "normal"
        //  place and in the replicated place.
        //

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      SharedSecurity->Header.Offset,
                      SharedSecurity->Header.Length,
                      &SharedSecurity->Header );

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      SharedSecurity->Header.Offset + VACB_MAPPING_GRANULARITY,
                      SharedSecurity->Header.Length,
                      &SharedSecurity->Header );

        //
        //  add id->data map
        //

        {
            INDEX_ROW Row;

            Row.KeyPart.KeyLength = sizeof( SharedSecurity->Header.HashKey.SecurityId );
            Row.KeyPart.Key = &SharedSecurity->Header.HashKey.SecurityId;

            Row.DataPart.DataLength = sizeof( SharedSecurity->Header );
            Row.DataPart.Data = &SharedSecurity->Header;

            NtOfsAddRecords( IrpContext,
                             IrpContext->Vcb->SecurityIdIndex,
                             1,
                             &Row,
                             FALSE );
        }

        //
        //  add hash|id->data map
        //

        {
            INDEX_ROW Row;

            Row.KeyPart.KeyLength =
                sizeof( SharedSecurity->Header.HashKey );
            Row.KeyPart.Key = &SharedSecurity->Header.HashKey;

            Row.DataPart.DataLength = sizeof( SharedSecurity->Header );
            Row.DataPart.Data = &SharedSecurity->Header;

            NtOfsAddRecords( IrpContext,
                             IrpContext->Vcb->SecurityDescriptorHashIndex,
                             1,
                             &Row,
                             FALSE );
        }

    } finally {

        NtfsReleaseScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

        //
        //  Reacquire fcb security mutex and deref count
        //

        NtfsAcquireFcbSecurity( IrpContext->Vcb );
        SharedSecurity->ReferenceCount -= 1;
    }

    DebugTrace( -1,
                DbgAcl,
                ("GetSecurityIdFromSecurityDescriptorUnsafe returns %08x\n",
                 SharedSecurity->Header.HashKey.SecurityId) );

    return SharedSecurity->Header.HashKey.SecurityId;
}


VOID
NtfsStoreSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    LEGACY NOTE - this routine disappears when all volumes become NT 5

    This routine stores a new security descriptor already stored in the fcb
    from memory onto the disk.

Arguments:

    Fcb - Supplies the fcb for the file being operated on

    LogIt - Supplies whether or not the creation of a new security descriptor
            should/ be logged or not.  Modifications are always logged.  This
            parameter must only be specified as FALSE for a file which is currently
            being created.

Return Value:

    None.

Note:
    This will dirty the standard information in the FCB but will not update it on
    disk.  The caller needs to bring these into sync.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    ATTRIBUTE_ENUMERATION_CONTEXT StdInfoContext;
    BOOLEAN CleanupStdInfoContext = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsStoreSecurityDescriptor...\n") );

    ASSERT_EXCLUSIVE_FCB( Fcb );

    //
    //  Initialize the attribute and find the security attribute
    //

    NtfsInitializeAttributeContext( &AttributeContext );
    try {

        ASSERT( Fcb->Vcb->SecurityDescriptorStream == NULL);

        //
        //  Check if the attribute is first being modified or deleted, a null
        //  value means that we are deleting the security descriptor
        //

        if (Fcb->SharedSecurity == NULL) {

            DebugTrace( 0, Dbg, ("Security Descriptor is null\n") );

            //
            //  If it already doesn't exist then we're done, otherwise simply
            //  delete the attribute
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $SECURITY_DESCRIPTOR,
                                           &AttributeContext )) {

                DebugTrace( 0, Dbg, ("Delete existing Security Descriptor\n") );

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &AttributeContext );
            }

            leave;
        }

        //
        //  At this point we are modifying the security descriptor so read in the
        //  security descriptor,  if it does not exist then we will need to create
        //  one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $SECURITY_DESCRIPTOR,
                                        &AttributeContext )) {

            DebugTrace( 0, Dbg, ("Create a new Security Descriptor\n") );

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsInitializeAttributeContext( &AttributeContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $SECURITY_DESCRIPTOR,
                                          NULL,                          // attribute name
                                          &Fcb->SharedSecurity->SecurityDescriptor,
                                          GetSharedSecurityLength(Fcb->SharedSecurity),
                                          0,                             // attribute flags
                                          NULL,                          // where indexed
                                          LogIt,                         // logit
                                          &AttributeContext );

            //
            //  We may be modifying the security descriptor of an NT 5.0 volume.
            //  We want to store a SecurityID in the standard information field so
            //  that if we reboot on 5.0 NTFS will know where to find the most
            //  recent security descriptor.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {

                LARGE_STANDARD_INFORMATION StandardInformation;

                //
                //  Initialize the context structure.
                //

                NtfsInitializeAttributeContext( &StdInfoContext );
                CleanupStdInfoContext = TRUE;

                //
                //  Locate the standard information, it must be there.
                //

                if (!NtfsLookupAttributeByCode( IrpContext,
                                                Fcb,
                                                &Fcb->FileReference,
                                                $STANDARD_INFORMATION,
                                                &StdInfoContext )) {

                    DebugTrace( 0, Dbg, ("Can't find standard information\n") );

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                ASSERT( NtfsFoundAttribute( &StdInfoContext )->Form.Resident.ValueLength >= sizeof( LARGE_STANDARD_INFORMATION ));

                //
                //  Copy the existing standard information to our buffer.
                //

                RtlCopyMemory( &StandardInformation,
                               NtfsAttributeValue( NtfsFoundAttribute( &StdInfoContext )),
                               sizeof( LARGE_STANDARD_INFORMATION ));

                StandardInformation.SecurityId = SECURITY_ID_INVALID;
                StandardInformation.OwnerId = 0;

                //
                //  Call to change the attribute value.
                //

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          0,
                                          &StandardInformation,
                                          sizeof( LARGE_STANDARD_INFORMATION ),
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          &StdInfoContext );
            }

        } else {

            DebugTrace( 0, Dbg, ("Change an existing Security Descriptor\n") );

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      0,                                 // Value offset
                                      &Fcb->SharedSecurity->SecurityDescriptor,
                                      GetSharedSecurityLength( Fcb->SharedSecurity ),
                                      TRUE,                              // logit
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      &AttributeContext );
        }

    } finally {

        DebugUnwind( NtfsStoreSecurityDescriptor );

        //
        //  Cleanup our attribute enumeration context
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

        if (CleanupStdInfoContext) {

            NtfsCleanupAttributeContext( IrpContext, &StdInfoContext );
        }

    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsStoreSecurityDescriptor -> VOID\n") );

    return;
}


PSHARED_SECURITY
NtfsCacheSharedSecurityForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb
    )

/*++

Routine Description:

    This routine finds or constructs a security id and SHARED_SECURITY from
    a specific file or directory.

Arguments:

    IrpContext - Context of the call

    ParentFcb - Supplies the directory under which the new fcb exists

Return Value:

    Referenced shared security.

--*/

{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSHARED_SECURITY SharedSecurity;
    NTSTATUS Status;
    BOOLEAN IsDirectory;
    PACCESS_STATE AccessState;
    PIO_STACK_LOCATION IrpSp;
    ULONG SecurityDescLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( ParentFcb );

    PAGED_CODE();

    DebugTrace( +1, DbgAcl, ("NtfsCacheSharedSecurityForCreate...\n") );

    //
    //  First decide if we are creating a file or a directory
    //

    IrpSp = IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp);
    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

        IsDirectory = TRUE;

    } else {

        IsDirectory = FALSE;
    }

    //
    //  Extract the parts of the Irp that we need to do our assignment
    //

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Check if we need to load the security descriptor for the parent.
    //

    if (ParentFcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );
    }

    ASSERT( ParentFcb->SharedSecurity != NULL );

    //
    //  Create a new security descriptor for the file and raise if there is
    //  an error
    //

    if (!NT_SUCCESS( Status = SeAssignSecurity( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                AccessState->SecurityDescriptor,
                                                &SecurityDescriptor,
                                                IsDirectory,
                                                &AccessState->SubjectSecurityContext,
                                                IoGetFileObjectGenericMapping(),
                                                PagedPool ))) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

    }

    SecurityDescLength = RtlLengthSecurityDescriptor( SecurityDescriptor );

    ASSERT( SeValidSecurityDescriptor( SecurityDescLength, SecurityDescriptor ));

    try {

        //
        //  Make sure the length is non-zero.
        //

        if (SecurityDescLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );

        }

        //
        //  We have a security descriptor.  Create a shared security descriptor.
        //

        SharedSecurity = NtfsCacheSharedSecurityByDescriptor( IrpContext,
                                                              SecurityDescriptor,
                                                              SecurityDescLength,
                                                              TRUE );

    } finally {

        //
        //  Free the security descriptor created by Se
        //

        SeDeassignSecurity( &SecurityDescriptor );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ("NtfsCacheSharedSecurityForCreate -> VOID\n") );

    return SharedSecurity;
}


/*++

Routine Descriptions:

    Collation routines for security hash index.  Collation occurs by Hash first,
    then security Id

Arguments:

    Key1 - First key to compare.

    Key2 - Second key to compare.

    CollationData - Optional data to support the collation.

Return Value:

    LessThan, EqualTo, or Greater than, for how Key1 compares
    with Key2.

--*/

FSRTL_COMPARISON_RESULT
NtOfsCollateSecurityHash (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    PSECURITY_HASH_KEY HashKey1 = (PSECURITY_HASH_KEY) Key1->Key;
    PSECURITY_HASH_KEY HashKey2 = (PSECURITY_HASH_KEY) Key2->Key;

    UNREFERENCED_PARAMETER(CollationData);

    PAGED_CODE( );

    ASSERT( Key1->KeyLength == sizeof( SECURITY_HASH_KEY ) );
    ASSERT( Key2->KeyLength == sizeof( SECURITY_HASH_KEY ) );

    if (HashKey1->Hash < HashKey2->Hash) {
        return LessThan;
    } else if (HashKey1->Hash > HashKey2->Hash) {
        return GreaterThan;
    } else if (HashKey1->SecurityId < HashKey2->SecurityId) {
        return LessThan;
    } else if (HashKey1->SecurityId > HashKey2->SecurityId) {
        return GreaterThan;
    } else {
        return EqualTo;
    }
}


BOOLEAN
NtfsCanAdministerVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR TestSecurityDescriptor OPTIONAL,
    IN PULONG TestDesiredAccess OPTIONAL
    )

/*++

Routine Descriptions:

    For volume open irps test if the user has enough access to administer the volume
    This means retesting the original requested access

Arguments:

    Irp - The create irp

    Fcb - The fcb to be tested - this should always be the volumedasd fcb

    TestSecurityDescriptor - If specified then use then apply this descriptor for the
        test.

    TestDesiredAccess - If specified then this is the access to apply.

Return Value:

    TRUE  if the user can administer the volume

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN ManageAccessGranted;
    ULONG ManageDesiredAccess;
    ULONG ManageGrantedAccess;
    NTSTATUS ManageAccessStatus;
    PPRIVILEGE_SET Privileges = NULL;
    PACCESS_STATE AccessState;
    KPROCESSOR_MODE EffectiveMode;

    PAGED_CODE();

    ASSERT( IrpContext->MajorFunction == IRP_MJ_CREATE );
    ASSERT( Fcb == Fcb->Vcb->VolumeDasdScb->Fcb );

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;
    ManageDesiredAccess = AccessState->OriginalDesiredAccess;

    if (ARGUMENT_PRESENT( TestDesiredAccess )) {

        ManageDesiredAccess = *TestDesiredAccess;
    }

    //
    //  SL_FORCE_ACCESS_CHECK causes us to use an effective RequestorMode
    //  of UserMode.
    //

    EffectiveMode = (KPROCESSOR_MODE)(FlagOn( IrpSp->Flags, SL_FORCE_ACCESS_CHECK ) ?
                                      UserMode :
                                      Irp->RequestorMode);

    //
    //  Lock the user context, do the access check and then unlock the context
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    try {

        ManageAccessGranted = SeAccessCheck( (ARGUMENT_PRESENT( TestSecurityDescriptor ) ?
                                              TestSecurityDescriptor :
                                              &Fcb->SharedSecurity->SecurityDescriptor),
                                             &AccessState->SubjectSecurityContext,
                                             TRUE,                           // Tokens are locked
                                             ManageDesiredAccess,
                                             0,
                                             &Privileges,
                                             IoGetFileObjectGenericMapping(),
                                             EffectiveMode,
                                             &ManageGrantedAccess,
                                             &ManageAccessStatus );
    } finally {

        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
    }


    if (Privileges != NULL) {
        SeFreePrivileges( Privileges );
    }

    return ManageAccessGranted;

    UNREFERENCED_PARAMETER( IrpContext );
}

#ifdef NTFS_CACHE_RIGHTS

VOID
NtfsGetCachedRightsById (
    IN PVCB Vcb,
    IN PLUID TokenId,
    IN PLUID ModifiedId,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PACCESS_MASK Rights
    )

/*++

Routine Descriptions:

    This call returns the access rights held by the effective
    ACCESS_TOKEN for the given security information, if available.

Arguments:

    Vcb - Volume where security Id is cached

    TokenId - The effective token's id.

    ModifiedId - The effective token's modification id.

    SubjectSecurityContext - A pointer to the subject's captured and locked
        security context

    SharedSecurity - Shared security used by file

    EntryCached - If the token-specific rights are cached at all, TRUE is
        optionally returned here, otherwise FALSE is returned.

    Rights - The access rights are returned here.  If an entry is not found
        in the cache for the effective token, only the world rights are
        returned.

Return Value:

    None.

--*/

{
    UCHAR Index;
    BOOLEAN AccessGranted;
    BOOLEAN LockHeld = FALSE;
    BOOLEAN IsCached = FALSE;
    NTSTATUS AccessStatus = STATUS_UNSUCCESSFUL;
    ACCESS_MASK GrantedAccess;
    PCACHED_ACCESS_RIGHTS CachedRights;

    PAGED_CODE( );

    NtfsAcquireFcbSecurity( Vcb );
    LockHeld = TRUE;

    try {

        CachedRights = &SharedSecurity->CachedRights;

        *Rights = CachedRights->EveryoneRights;

        //
        //  Search the list for the given TokenId.
        //  It is assumed that a specific TokenId will only appear
        //  once in the cache.
        //

        for (Index = 0;
             Index < CachedRights->Count;
             Index += 1) {

            //
            //  Check for a match on TokenId and ModifiedId.
            //

            if (RtlEqualLuid( &CachedRights->TokenRights[Index].TokenId,
                              TokenId )) {

                if (RtlEqualLuid( &CachedRights->TokenRights[Index].ModifiedId,
                                  ModifiedId )) {

                    //
                    //  We have a match.
                    //

                    SetFlag( *Rights, CachedRights->TokenRights[Index].Rights );
                    IsCached = TRUE;
                }
                break;
            }
        }

        //
        //  If the entry is not cached, get the maximum rights.
        //  Note that it is assumed that this call will not return
        //  rights that require privileges, even if they are currently
        //  enabled.  This is the behavior when only MAXIMUM_ALLOWED
        //  is requested.
        //

        if (!IsCached) {

            //
            //  Drop our lock across this call.
            //

            NtfsReleaseFcbSecurity( Vcb );
            LockHeld = FALSE;

            AccessGranted = SeAccessCheck( &SharedSecurity->SecurityDescriptor,
                                           SubjectSecurityContext,
                                           TRUE,                           // Tokens are locked
                                           MAXIMUM_ALLOWED,
                                           0,
                                           NULL,
                                           IoGetFileObjectGenericMapping(),
                                           UserMode,
                                           &GrantedAccess,
                                           &AccessStatus );


            if (AccessGranted) {

                //
                //  Update the cached knowledge about rights that this
                //  caller is known to have for this security descriptor.
                //

                NtfsAddCachedRights( Vcb,
                                     SharedSecurity,
                                     GrantedAccess,
                                     TokenId,
                                     ModifiedId );

                IsCached = TRUE;
            }
        }

    } finally {

        if (LockHeld) {

            NtfsReleaseFcbSecurity( Vcb );
        }
    }

    if (ARGUMENT_PRESENT( EntryCached )) {

        *EntryCached = IsCached;
    }

    return;
}


NTSTATUS
NtfsGetCachedRights (
    IN PVCB Vcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PACCESS_MASK Rights,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PLUID TokenId OPTIONAL,
    OUT PLUID ModifiedId OPTIONAL
    )

/*++

Routine Descriptions:

    This call returns the access rights known to be held by the effective
    ACCESS_TOKEN for the given security information.  It is assumed that
    the subject context is locked.

Arguments:

    Vcb - Volume where security Id is cached

    SubjectSecurityContext - A pointer to the subject's captured and locked
        security context

    SharedSecurity - Shared security used by file

    Rights - The access rights are returned here.  If an entry is not found
        in the cache for the effective token, only the world rights are
        returned.

    EntryCached - If the token-specific rights are cached at all, TRUE is
        optionally returned here, otherwise FALSE is returned.

    TokenId - The effective token's id is optionally returned here.

    ModifiedId - The effective token's modification id is optionally
        returned here.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS if and only if we have obtained at
        least the TokenId and ModifiedId information.

--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN EToken;
    PTOKEN_STATISTICS Info = NULL;

    PAGED_CODE( );

    DebugTrace( +1, Dbg, ("NtfsGetCachedRights...\n") );

    //
    //  First obtain the effective token's id and modification id.
    //

    EToken = SeQuerySubjectContextToken( SubjectSecurityContext );
    Status = SeQueryInformationToken( EToken, TokenStatistics, &Info );

    //
    //  If we have the TokenId and ModifiedId, get the cached rights.
    //

    if (Status == STATUS_SUCCESS) {

        NtfsGetCachedRightsById( Vcb,
                                 &Info->TokenId,
                                 &Info->ModifiedId,
                                 SubjectSecurityContext,
                                 SharedSecurity,
                                 EntryCached,
                                 Rights );

        //
        //  Return the Tokenid and ModifiedId to the caller.
        //

        if (ARGUMENT_PRESENT( TokenId )) {

            RtlCopyLuid( TokenId, &Info->TokenId );
        }

        if (ARGUMENT_PRESENT( ModifiedId )) {

            RtlCopyLuid( ModifiedId, &Info->ModifiedId );
        }

    } else {

        //
        //  Just return the rights everyone is known to have.
        //

        *Rights = SharedSecurity->CachedRights.EveryoneRights;

        if (ARGUMENT_PRESENT( EntryCached )) {

            *EntryCached = FALSE;
        }
    }

    if (Info != NULL) {

        ExFreePool( Info );
    }

    DebugTrace( -1, Dbg, ("NtfsGetCachedRights -> %08lx, Rights=%08lx\n", Status, *Rights) );
    return Status;
}


VOID
NtfsAddCachedRights (
    IN PVCB Vcb,
    IN PSHARED_SECURITY SharedSecurity,
    IN ACCESS_MASK Rights,
    IN PLUID TokenId,
    IN PLUID ModifiedId
    )

/*++

Routine Descriptions:

    This call caches the access rights held by the effective ACCESS_TOKEN
    for the given security information.  It is assumed that the subject
    context is locked.

Arguments:

    Vcb - Volume where security Id is cached

    SharedSecurity - Shared security used by file

    Rights - The access rights.

    TokenId - The effective token's id.

    ModifiedId - The effective token's modification id.

Return Value:

    None.

--*/

{
    BOOLEAN GetEveryoneRights = FALSE;
    UCHAR Index;
    PCACHED_ACCESS_RIGHTS CachedRights;

    PAGED_CODE( );

    DebugTrace( +1, Dbg, ("NtfsAddCachedRights...\n") );

    //
    //  Make certain that MAXIMUM_ALLOWED is not in the rights.
    //

    ClearFlag( Rights, MAXIMUM_ALLOWED );

    //
    //  Acquire the security mutex
    //

    NtfsAcquireFcbSecurity( Vcb );

    try {

        //
        //  Search the list for the given TokenId.
        //  It is assumed that a specific TokenId will only appear
        //  once in the cache.
        //

        for (Index = 0, CachedRights = &SharedSecurity->CachedRights;
             Index < CachedRights->Count;
             Index += 1) {

            //
            //  Check for a match on TokenId and ModifiedId.
            //

            if (RtlEqualLuid( &CachedRights->TokenRights[Index].TokenId,
                              TokenId )) {

                //
                //  Replace ModifiedId if it doesn't match.  That will
                //  happen when the token's enabled groups or privileges
                //  have changed since the last time we cached information
                //  for it.
                //

                if (!RtlEqualLuid( &CachedRights->TokenRights[Index].ModifiedId,
                                   ModifiedId )) {

                    RtlCopyLuid( &CachedRights->TokenRights[Index].ModifiedId,
                                 ModifiedId );
                }

                //
                //  We have a match.  Set the rights.
                //

                CachedRights->TokenRights[Index].Rights = Rights;

                //
                //  Remember the next entry to use.
                //

                CachedRights->NextInsert = Index + 1;
                break;
            }
        }

        //
        //  If the entry was not found above, add the new entry into the cache.
        //

        if (Index == CachedRights->Count) {

            if ((CachedRights->Count >= 1) &&
                !CachedRights->HaveEveryoneRights) {

                //
                //  Once we add the second TokenId to the cache, we have a
                //  good indicator that having the world rights could be
                //  useful.
                //

                GetEveryoneRights = TRUE;

                //
                //  Set the indicator that we have the rights now so that
                //  there is no need in the acquisition routine to acquire
                //  the security mutex.  This will prevent multiple threads
                //  from attempting to acquire the everyone rights.
                //
                //  Note that until we actually acquire the rights information
                //  caller will assume that the rights are 0 and go through
                //  the normal per-token access check path.
                //

                CachedRights->HaveEveryoneRights = TRUE;
            }

            Index = CachedRights->NextInsert;

            //
            //  We will just replace the first entry in the list.
            //

            if (Index == NTFS_MAX_CACHED_RIGHTS) {

                Index = 0;
            }

            ASSERT( Index < NTFS_MAX_CACHED_RIGHTS );

            //
            //  Copy in the information.
            //

            CachedRights->TokenRights[Index].Rights = Rights;
            RtlCopyLuid( &CachedRights->TokenRights[Index].TokenId,
                         TokenId );
            RtlCopyLuid( &CachedRights->TokenRights[Index].ModifiedId,
                         ModifiedId );

            if (Index == CachedRights->Count) {

                //
                //  Bump the count of entries.
                //

                CachedRights->Count += 1;
            }

            //
            //  Remember the next entry to use.
            //

            CachedRights->NextInsert = Index + 1;
        }

    } finally {

        NtfsReleaseFcbSecurity( Vcb );
    }

    if (GetEveryoneRights) {

        NtfsSetCachedRightsWorld( SharedSecurity );
    }

    DebugTrace( -1, Dbg, ("NtfsAddCachedRights -> VOID\n") );
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\shutdown.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module implements the file system shutdown routine for Ntfs

Author:

    Gary Kimura     [GaryKi]    19-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  Interal support routine
//

VOID
NtfsCheckpointVolumeUntilDone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_SHUTDOWN)


NTSTATUS
NtfsFsdShutdown (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of shutdown.  Note that Shutdown will
    never be done asynchronously so we will never need the Fsp counterpart
    to shutdown.

    This is the shutdown routine for the Ntfs file system device driver.
    This routine locks the global file system lock and then syncs all the
    mounted volumes.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - Always STATUS_SUCCESS

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    PLIST_ENTRY Links;
    PVCB Vcb;
    PIRP NewIrp;
    KEVENT Event;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    DebugTrace( +1, Dbg, ("NtfsFsdShutdown\n") );

    FsRtlEnterFileSystem();

    //
    //  Allocate an Irp Context that we can use in our procedure calls
    //  and we know that shutdown will always be synchronous
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );

    NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

    //
    //  Get everyone else out of the way
    //

    if (!NtfsAcquireExclusiveGlobal( IrpContext, BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ))) {
        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    try {

        BOOLEAN AcquiredFiles;
        BOOLEAN AcquiredCheckpoint;

        //
        //  Initialize an event for doing calls down to
        //  our target device objects
        //

        KeInitializeEvent( &Event, NotificationEvent, FALSE );

        //
        //  For every volume that is mounted we will flush the
        //  volume and then shutdown the target device objects.
        //

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

            //
            //  Get the Vcb and put it in the IrpContext.
            //

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);
            IrpContext->Vcb = Vcb;

            //
            //  If we have already been called before for this volume
            //  (and yes this does happen), skip this volume as no writes
            //  have been allowed since the first shutdown.
            //

            if ( FlagOn( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN ) ) {

                continue;
            }

            //
            //  Clear the Mft defrag flag to stop any actions behind our backs.
            //

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );

            AcquiredFiles = FALSE;
            AcquiredCheckpoint = FALSE;

            try {

                if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                    //
                    //  Start by locking out all other checkpoint
                    //  operations.
                    //

                    NtfsAcquireCheckpoint( IrpContext, Vcb );

                    while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

                        //
                        //  Release the checkpoint event because we cannot checkpoint now.
                        //

                        NtfsReleaseCheckpoint( IrpContext, Vcb );

                        NtfsWaitOnCheckpointNotify( IrpContext, Vcb );

                        NtfsAcquireCheckpoint( IrpContext, Vcb );
                    }

                    SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
                    NtfsResetCheckpointNotify( IrpContext, Vcb );
                    NtfsReleaseCheckpoint( IrpContext, Vcb );
                    AcquiredCheckpoint = TRUE;

                    NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, TRUE, FALSE );
                    AcquiredFiles = TRUE;

                    SetFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

                    if (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED)) {
                        NtfsCheckpointVolumeUntilDone( IrpContext, Vcb );
                    }
                    NtfsCommitCurrentTransaction( IrpContext );

                    //
                    //  Bug 308819. We find that transactions continue to happen at times even after shutdown
                    //  has been flagged. If we stop the log file, then currently we don't check for
                    //  NULL LSNs getting returned by NtfsWriteLog. As a result our metadata can get
                    //  corrupted. Until we rectify this, let's just not stop the log file in shutdown.
                    //
                    //  NtfsStopLogFile( Vcb );
                    //

                    NtfsAcquireCheckpoint( IrpContext, Vcb );
                    ClearFlag( Vcb->CheckpointFlags,
                               VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);
                    NtfsSetCheckpointNotify( IrpContext, Vcb );
                    NtfsReleaseCheckpoint( IrpContext, Vcb );
                    AcquiredCheckpoint = FALSE;

                    NewIrp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                           Vcb->TargetDeviceObject,
                                                           NULL,
                                                           0,
                                                           NULL,
                                                           &Event,
                                                           NULL );

                    if (NewIrp == NULL) {

                        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
                    }

                    if (NT_SUCCESS(IoCallDriver( Vcb->TargetDeviceObject, NewIrp ))) {

                        (VOID) KeWaitForSingleObject( &Event,
                                                      Executive,
                                                      KernelMode,
                                                      FALSE,
                                                      NULL );

                        KeClearEvent( &Event );
                    }
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                NtfsMinimumExceptionProcessing( IrpContext );
            }

            if (AcquiredCheckpoint) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags,
                           VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);
                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN );
            ClearFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

            if (AcquiredFiles) {

                NtfsReleaseAllFiles( IrpContext, Vcb, TRUE );
            }
        }

    } finally {

        NtfsReleaseGlobal( IrpContext );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    }

    DebugTrace( -1, Dbg, ("NtfsFsdShutdown -> STATUS_SUCCESS\n") );

    FsRtlExitFileSystem();

    return STATUS_SUCCESS;
}


VOID
NtfsCheckpointVolumeUntilDone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine keeps trying to checkpoint/flush a volume until it
    works.  Doing clean checkpoints and looping back to retry on log file full.

Arguments:

    Vcb - Vcb to checkpoint til done

Return Value:

    None

--*/

{
    NTSTATUS Status;

    do {

        Status = STATUS_SUCCESS;

        try {
            NtfsCheckpointVolume( IrpContext,
                                  Vcb,
                                  TRUE,
                                  TRUE,
                                  TRUE,
                                  0,
                                  Vcb->LastRestartArea );
        } except( (Status = GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER ) {

            NtfsMinimumExceptionProcessing( IrpContext );
        }

        if (!NT_SUCCESS(Status)) {

            //
            //  To make sure that we can access all of our streams correctly,
            //  we first restore all of the higher sizes before aborting the
            //  transaction.  Then we restore all of the lower sizes after
            //  the abort, so that all Scbs are finally restored.
            //

            NtfsRestoreScbSnapshots( IrpContext, TRUE );
            NtfsAbortTransaction( IrpContext, IrpContext->Vcb, NULL );
            NtfsRestoreScbSnapshots( IrpContext, FALSE );

            //
            //  A clean volume checkpoint should never get log file full
            //

            if (Status == STATUS_LOG_FILE_FULL) {

                //
                //  Make sure we don't leave the error code in the top-level
                //  IrpContext field.
                //

                ASSERT( IrpContext->TransactionId == 0 );
                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                NtfsCheckpointVolume( IrpContext,
                                      Vcb,
                                      TRUE,
                                      TRUE,
                                      FALSE,
                                      0,
                                      Vcb->LastRestartArea );
            }
        }

    } while (Status == STATUS_LOG_FILE_FULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\seinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SeInfo.c

Abstract:

    This module implements the Security Info routines for NTFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    26-Dec-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SEINFO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonQuerySecurityInfo)
#pragma alloc_text(PAGE, NtfsCommonSetSecurityInfo)
#endif


NTSTATUS
NtfsCommonQuerySecurityInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying security information called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN AcquiredFcb = TRUE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQuerySecurityInfo") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  The only type of opens we accept are user file and directory opens
    //

    if ((TypeOfOpen != UserFileOpen)
        && (TypeOfOpen != UserDirectoryOpen)
        && (TypeOfOpen != UserViewIndexOpen)) {

        Status = STATUS_INVALID_PARAMETER;

    } else {

        //
        //  Our operation is to acquire the fcb, do the operation and then
        //  release the fcb.  If the security descriptor for this file is
        //  not already loaded we will release the Fcb and then acquire both
        //  the Vcb and Fcb.  We must have the Vcb to examine our parent's
        //  security descriptor.
        //

        NtfsAcquireSharedFcb( IrpContext, Fcb, NULL, 0 );

        try {

            if (Fcb->SharedSecurity == NULL) {

                NtfsReleaseFcb( IrpContext, Fcb );
                AcquiredFcb = FALSE;

                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
                AcquiredFcb = TRUE;
            }

            //
            //  Make sure the volume is still mounted.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            Status = NtfsQuerySecurity( IrpContext,
                                        Fcb,
                                        &IrpSp->Parameters.QuerySecurity.SecurityInformation,
                                        (PSECURITY_DESCRIPTOR)Irp->UserBuffer,
                                        &IrpSp->Parameters.QuerySecurity.Length );

            if (NT_SUCCESS( Status )) {

                Irp->IoStatus.Information = IrpSp->Parameters.QuerySecurity.Length;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {

                Irp->IoStatus.Information = IrpSp->Parameters.QuerySecurity.Length;

                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            //  Abort transaction on error by raising.
            //

            NtfsCleanupTransaction( IrpContext, Status, FALSE );

        } finally {

            DebugUnwind( NtfsCommonQuerySecurityInfo );

            if (AcquiredFcb) {

                NtfsReleaseFcb( IrpContext, Fcb );
            }
        }
    }

    //
    //  Now complete the request and return to our caller
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsCommonQuerySecurityInfo -> %08lx", Status) );

    return Status;
}


NTSTATUS
NtfsCommonSetSecurityInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Setting security information called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PQUOTA_CONTROL_BLOCK OldQuotaControl = NULL;
    ULONG OldOwnerId;
    ULONG LargeStdInfo;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetSecurityInfo") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  The only type of opens we accept are user file and directory opens
    //

    if ((TypeOfOpen != UserFileOpen)
        && (TypeOfOpen != UserDirectoryOpen)
        && (TypeOfOpen != UserViewIndexOpen)) {

        Status = STATUS_INVALID_PARAMETER;

    } else if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        
    } else {
    
        //
        //  Capture the source information.
        //

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;

        //
        //  Our operation is to acquire the fcb, do the operation and then
        //  release the fcb
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

        try {

            //
            //  Make sure the volume is still mounted.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            //
            //  Post the change to the Usn Journal.
            //

            NtfsPostUsnChange( IrpContext, Scb, USN_REASON_SECURITY_CHANGE );

            //
            //  Capture the current OwnerId, Qutoa Control Block and
            //  size of standard information.
            //

            OldQuotaControl = Fcb->QuotaControl;
            OldOwnerId = Fcb->OwnerId;
            LargeStdInfo = Fcb->FcbState & FCB_STATE_LARGE_STD_INFO;

            Status = NtfsModifySecurity( IrpContext,
                                         Fcb,
                                         &IrpSp->Parameters.SetSecurity.SecurityInformation,
                                         IrpSp->Parameters.SetSecurity.SecurityDescriptor );

            if (NT_SUCCESS( Status )) {

                //
                //  Make sure the new security descriptor Id is written out.
                //

                NtfsUpdateStandardInformation( IrpContext, Fcb );
            }

            //
            //  Abort transaction on error by raising.
            //

            NtfsCleanupTransaction( IrpContext, Status, FALSE );

            //
            //  Set the flag in the Ccb to indicate this change occurred.
            //

            if (!IsDirectory( &Fcb->Info )) {
                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
            }

        } finally {

            DebugUnwind( NtfsCommonSetSecurityInfo );

            if (AbnormalTermination()) {

                //
                //  The request failed.  Restore the owner and
                //  QuotaControl are restored.
                //

                if ((Fcb->QuotaControl != OldQuotaControl) &&
                    (Fcb->QuotaControl != NULL)) {

                    //
                    //  A new quota control block was assigned.
                    //  Dereference it.
                    //

                    NtfsDereferenceQuotaControlBlock( Fcb->Vcb,
                                                      &Fcb->QuotaControl );
                }

                Fcb->QuotaControl = OldQuotaControl;
                Fcb->OwnerId = OldOwnerId;

                if (LargeStdInfo == 0) {

                    //
                    //  The standard information has be returned to
                    //  its orginal size.
                    //

                    ClearFlag( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO );
                }

            } else {

                //
                //  The request succeed.  If the quota control block was
                //  changed then derefence the old block.
                //

                if ((Fcb->QuotaControl != OldQuotaControl) &&
                    (OldQuotaControl != NULL)) {

                    NtfsDereferenceQuotaControlBlock( Fcb->Vcb,
                                                      &OldQuotaControl);
                }
            }

        }
    }

    //
    //  Now complete the request and return to our caller
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsCommonSetSecurityInfo -> %08lx", Status) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=ntfs
TARGETTYPE=DRIVER
DRIVERTYPE=FS

INCLUDES=..;$(PROJECT_ROOT)\ntos\inc;$(DRIVERS_INC_PATH)

NTPROFILEINPUT=yes

C_DEFINES=$(C_DEFINES) -D_NTDRIVER_

!IFDEF BUILD_FOR_3_51
C_DEFINES= $(C_DEFINES) -D_NTIFS_
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\AllocSup.c \
        ..\AttrData.c \
        ..\AttrSup.c  \
        ..\BitmpSup.c \
        ..\CacheSup.c \
        ..\CheckSup.c \
        ..\Cleanup.c  \
        ..\Close.c    \
        ..\ColatSup.c \
        ..\Create.c   \
        ..\DevCtrl.c  \
        ..\DevIoSup.c \
        ..\DirCtrl.c  \
        ..\Ea.c       \
        ..\FileInfo.c \
        ..\FilObSup.c \
        ..\Flush.c    \
        ..\FsCtrl.c   \
        ..\FspDisp.c  \
        ..\FstIoSup.c \
        ..\HashSup.c  \
        ..\IndexSup.c \
        ..\LockCtrl.c \
        ..\LogSup.c   \
        ..\McbSup.c   \
        ..\MftSup.c   \
        ..\NameSup.c  \
        ..\Ntfs.rc    \
        ..\NtfsData.c \
        ..\NtfsExp.c  \
        ..\NtfsInit.c \
        ..\ObjIdSup.c \
        ..\Pnp.c      \
        ..\PrefxSup.c \
        ..\Quota.c    \
        ..\QuotaSup.c \
        ..\Read.c     \
        ..\ReparSup.c \
        ..\ResrcSup.c \
        ..\RestrSup.c \
        ..\SecurSup.c \
        ..\SeInfo.c   \
        ..\Shutdown.c \
        ..\StrucSup.c \
        ..\UsnSup.c   \
        ..\VattrSup.c \
        ..\VerfySup.c \
        ..\ViewSup.c  \
        ..\VolInfo.c  \
        ..\WorkQue.c  \
        ..\Write.c

PRECOMPILED_INCLUDE=..\ntfsproc.h
PRECOMPILED_PCH=ntfsproc.pch
PRECOMPILED_OBJ=ntfsproc.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\usnsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    UsnSup.c

Abstract:

    This module implements the Usn Journal support routines for NtOfs

Author:

    Tom Miller      [TomM]          1-Dec-1996

Revision History:

--*/

#include "NtfsProc.h"
#include "lockorder.h"

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('UFtN')

#define GENERATE_CLOSE_RECORD_LIMIT     (200)

UNICODE_STRING $Max = CONSTANT_UNICODE_STRING( L"$Max" );

RTL_GENERIC_COMPARE_RESULTS
NtfsUsnTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

PVOID
NtfsUsnTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

VOID
NtfsUsnTableFree (
    IN PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

VOID
NtfsCancelReadUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NtfsCancelDeleteUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeleteUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

BOOLEAN
NtfsValidateUsnPage (
    IN PUSN_RECORD UsnRecord,
    IN USN PageUsn,
    IN USN *UserStartUsn OPTIONAL,
    IN LONGLONG UsnFileSize,
    OUT PBOOLEAN ValidUserStartUsn OPTIONAL,
    OUT USN *NextUsn
    );

//
//  VOID
//  NtfsAdvanceUsnJournal (
//  PVCB Vcb,
//  PUSN_JOURNAL_INSTANCE UsnJournalInstance,
//  LONGLONG OldSize,
//  PBOOLEAN NewMax
//  );
//

#define NtfsAdvanceUsnJournal(V,I,SZ,M)   {                                 \
    ULONG _TempUlong;                                                       \
    _TempUlong = USN_PAGE_BOUNDARY;                                         \
    if (USN_PAGE_BOUNDARY < (V)->BytesPerCluster) {                         \
        _TempUlong = (V)->BytesPerCluster;                                  \
    }                                                                       \
    (I)->LowestValidUsn = SZ + _TempUlong - 1;                              \
    ((PLARGE_INTEGER) &(I)->LowestValidUsn)->LowPart &= ~(_TempUlong - 1);  \
    KeQuerySystemTime( (PLARGE_INTEGER) &(I)->JournalId );                  \
    *(M) = TRUE;                                                            \
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsDeleteUsnJournal)
#pragma alloc_text(PAGE, NtfsDeleteUsnSpecial)
#pragma alloc_text(PAGE, NtfsDeleteUsnWorker)
#pragma alloc_text(PAGE, NtfsPostUsnChange)
#pragma alloc_text(PAGE, NtfsQueryUsnJournal)
#pragma alloc_text(PAGE, NtfsReadUsnJournal)
#pragma alloc_text(PAGE, NtfsSetupUsnJournal)
#pragma alloc_text(PAGE, NtfsTrimUsnJournal)
#pragma alloc_text(PAGE, NtfsUsnTableCompare)
#pragma alloc_text(PAGE, NtfsUsnTableAllocate)
#pragma alloc_text(PAGE, NtfsUsnTableFree)
#pragma alloc_text(PAGE, NtfsValidateUsnPage)
#pragma alloc_text(PAGE, NtfsWriteUsnJournalChanges)
#endif


NTSTATUS
NtfsReadUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN ProbeInput
    )

/*++

Routine Description:

    This routine reads records filtered from the Usn journal.

Arguments:

    IrpContext - Only optional if we are being called to cancel an async
                 request.

    Irp - request being serviced

    ProbeInput - Indicates if we should probe the user input buffer.  We also
        call this routine internally and don't want to probe in that case.

Return Value:

    NTSTATUS - The return status for the operation.
    STATUS_PENDING - if asynch Irp queued for later completion.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUSN_RECORD UsnRecord;
    USN_RECORD UNALIGNED *OutputUsnRecord;
    PVOID UserBuffer;
    LONGLONG ViewLength;
    ULONG RemainingUserBuffer, BytesUsed;
    MAP_HANDLE MapHandle;

    READ_USN_JOURNAL_DATA CapturedData;
    PSCB UsnJournal;
    ULONG JournalAcquired = FALSE;
    ULONG AccessingUserBuffer = FALSE;
    ULONG DecrementReferenceCount = FALSE;
    ULONG VcbAcquired = FALSE;
    ULONG Wait;
    ULONG OriginalWait;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {

        ASSERT( ProbeInput );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  This request must be able to wait for resources.  Set WAIT to TRUE.
    //

    Wait = TRUE;
    if (ProbeInput && !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Wait = FALSE;
    }

    NtOfsInitializeMapHandle( &MapHandle );
    UserBuffer = NtfsMapUserBuffer( Irp );

    try {

        //
        //  We always want to be able to wait for resources in this routine but need to be able
        //  to restore the original wait value in the Irp.  After this the original wait will
        //  have only the wait flag set and then only if it originally wasn't set.  In clean
        //  up we just need to clear the irp context flags using this mask.
        //

        OriginalWait = (IrpContext->State ^ IRP_CONTEXT_STATE_WAIT) & IRP_CONTEXT_STATE_WAIT;

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

        //
        //  Detect if we fail while accessing the input buffer.
        //

        try {

            AccessingUserBuffer = TRUE;

            //
            //  Probe the input buffer if not in kernel mode and we haven't already done so.
            //

            if (Irp->RequestorMode != KernelMode) {

                if (ProbeInput) {

                    ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                  IrpSp->Parameters.FileSystemControl.InputBufferLength,
                                  sizeof( ULONG ));
                }

                //
                //  Probe the output buffer if we haven't locked it down yet.
                //  Capture the JournalData from the unsafe user buffer.
                //

                if (Irp->MdlAddress == NULL) {

                    ProbeForWrite( UserBuffer, IrpSp->Parameters.FileSystemControl.OutputBufferLength, sizeof( ULONG ));
                }
            }

            //
            //  Acquire the Vcb to serialize journal operations with delete journal and dismount.
            //  Only do this if are being called directly by the user.
            //

            if (ProbeInput) {

                VcbAcquired = NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

                if (!FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                    UsnJournal = NULL;

                } else {

                    UsnJournal = Vcb->UsnJournal;
                }

            } else {

                UsnJournal = Vcb->UsnJournal;
            }

            //
            //  Make sure no one is deleting the journal.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

                Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                leave;
            }

            //
            //  Also check that the version is still active.
            //

            if (UsnJournal == NULL) {

                Status = STATUS_JOURNAL_NOT_ACTIVE;
                leave;
            }

            //
            //  Check that the buffer sizes meet our minimum needs.
            //

            if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( READ_USN_JOURNAL_DATA )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;

            } else {

                RtlCopyMemory( &CapturedData,
                               IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                               sizeof( READ_USN_JOURNAL_DATA ));

                //
                //  Check that the user is querying with the correct journal ID.
                //

                if (CapturedData.UsnJournalID != Vcb->UsnJournalInstance.JournalId) {

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }
            }

            //
            //  Check that the output buffer can hold at least one USN.
            //

            if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( USN )) {

                Status = STATUS_BUFFER_TOO_SMALL;
                leave;
            }

            AccessingUserBuffer = FALSE;

            //
            //  Set up for filling output records
            //

            RemainingUserBuffer = IrpSp->Parameters.FileSystemControl.OutputBufferLength - sizeof(USN);
            OutputUsnRecord = (PUSN_RECORD) Add2Ptr( UserBuffer, sizeof(USN) );
            BytesUsed = sizeof(USN);

            NtfsAcquireResourceShared( IrpContext, UsnJournal, TRUE );
            JournalAcquired = TRUE;

            if (VcbAcquired) {

                NtfsReleaseVcb( IrpContext, Vcb );
                VcbAcquired = FALSE;
            }

            //
            //  Verify the volume is mounted.
            //

            if (FlagOn( UsnJournal->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            //
            //  If 0 was specified as the Usn, then translate that to the first record
            //  in the Usn journal.
            //

            if (CapturedData.StartUsn == 0) {
                CapturedData.StartUsn = Vcb->FirstValidUsn;
            }

            //
            //  Loop here until he gets some data, if that is what the caller wants.
            //

            do {

                //
                //  Make sure he is within the stream.
                //

                if (CapturedData.StartUsn < Vcb->FirstValidUsn) {
                    CapturedData.StartUsn = Vcb->FirstValidUsn;
                    Status = STATUS_JOURNAL_ENTRY_DELETED;
                    break;
                }

                //
                //  Make sure he is within the stream.
                //

                if (CapturedData.StartUsn >= UsnJournal->Header.FileSize.QuadPart) {

                    //
                    //  If he wants to wait for data, then wait here.
                    //
                    //  If an asynchronous request has
                    //  met its wakeup condition, then this Irp will not be the same as the
                    //  Originating Irp, and we do not want to give him a second chance since
                    //  this could cause us to loop in NtOfsPostNewLength.  (Basically the only
                    //  case where this could happen anyway is if he gave us a bogus StartUsn
                    //  which is too high.)
                    //

                    if (CapturedData.BytesToWaitFor != 0) {

                        //
                        //  Make sure the journal doesn't get deleted while
                        //  this Irp is outstanding.
                        //

                        InterlockedIncrement( &UsnJournal->CloseCount );
                        DecrementReferenceCount = TRUE;

                        //
                        //  If the caller does not want to wait, then just queue his
                        //  Irp to be completed when sufficient bytes come in.  If we were
                        //  called for another Irp, then do the same, since we know that
                        //  was another async Irp.
                        //

                        if (!Wait || (Irp != IrpContext->OriginatingIrp)) {

                            //
                            //  Now set up our wait block, capturing the user's parameters.
                            //  Update the Irp to say where the input parameters are now.
                            //

                            Status = NtfsHoldIrpForNewLength( IrpContext,
                                                              UsnJournal,
                                                              Irp,
                                                              CapturedData.StartUsn + CapturedData.BytesToWaitFor,
                                                              NtfsCancelReadUsnJournal,
                                                              &CapturedData,
                                                              &IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                                              sizeof( READ_USN_JOURNAL_DATA ));

                            //
                            //  If pending then someone else will decrement the reference count.
                            //

                            if (Status == STATUS_PENDING) {

                                DecrementReferenceCount = FALSE;
                            }

                            leave;
                        }

                        //
                        //  We can safely release the resource.  Our reference on the Scb above
                        //  will keep it from being deleted.
                        //

                        NtfsReleaseResource( IrpContext, UsnJournal );
                        JournalAcquired = FALSE;

                        FsRtlExitFileSystem();

                        Status = NtOfsWaitForNewLength( UsnJournal,
                                                        CapturedData.StartUsn + CapturedData.BytesToWaitFor,
                                                        FALSE,
                                                        Irp,
                                                        NtfsCancelReadUsnJournal,
                                                        ((CapturedData.Timeout != 0) ?
                                                         (PLARGE_INTEGER) &CapturedData.Timeout :
                                                         NULL) );

                        FsRtlEnterFileSystem();

                        //
                        //  Get out in the error case.
                        //

                        if (Status != STATUS_SUCCESS) {

                            leave;
                        }

                        //
                        //  Acquire the resource to proceed with the request.
                        //

                        NtfsAcquireResourceShared( IrpContext, UsnJournal, TRUE );
                        JournalAcquired = TRUE;

                        //
                        //  Decrement our reference on the Scb.
                        //

                        InterlockedDecrement( &UsnJournal->CloseCount );
                        DecrementReferenceCount = FALSE;

                        //
                        //  The journal may have been deleted while we weren't holding
                        //  anything.
                        //

                        if (UsnJournal != UsnJournal->Vcb->UsnJournal) {

                            if (FlagOn( UsnJournal->Vcb->VcbState, VCB_STATE_USN_DELETE )) {
                                Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                            } else {
                                Status = STATUS_JOURNAL_NOT_ACTIVE;
                            }
                            leave;
                        }

                        ASSERT( Status == STATUS_SUCCESS );

                        //
                        //  **** Get out if we are shutting down the volume.
                        //

                        //  if (ShuttingDown) {
                        //      Status = STATUS_TOO_LATE;
                        //      leave;
                        //  }

                    //
                    //  Otherwise, get out.  Note, we may have processed a number of records
                    //  that did not match his filter criteria, so we will return success, so
                    //  we can at least give him an updated Usn so we do not have to skip over
                    //  all those records again.
                    //

                    } else {

                        break;
                    }
                }

                //
                //  Loop through as many views as required to fill the output buffer.
                //

                while ((RemainingUserBuffer != 0) && (CapturedData.StartUsn < UsnJournal->Header.FileSize.QuadPart)) {

                    LONGLONG BiasedStartUsn;
                    BOOLEAN ValidUserStartUsn;
                    USN NextUsn;
                    ULONG RecordSize;

                    //
                    //  Calculate length to process in this view.
                    //

                    ViewLength = UsnJournal->Header.FileSize.QuadPart - CapturedData.StartUsn;
                    if (ViewLength > (VACB_MAPPING_GRANULARITY - (ULONG)(CapturedData.StartUsn & (VACB_MAPPING_GRANULARITY - 1)))) {
                        ViewLength = VACB_MAPPING_GRANULARITY - (ULONG)(CapturedData.StartUsn & (VACB_MAPPING_GRANULARITY - 1));
                    }

                    //
                    //  Map the view containing the desired Usn.
                    //

                    BiasedStartUsn = CapturedData.StartUsn - Vcb->UsnCacheBias;
                    NtOfsMapAttribute( IrpContext, UsnJournal, BiasedStartUsn, (ULONG)ViewLength, (PVOID *)&UsnRecord, &MapHandle );

                    //
                    //  For each page in the view we want to validate the page and return the records
                    //  within the page starting at the user's current usn.
                    //

                    do {

                        //
                        //  Validate the records on the entire page are valid.
                        //

                        if (!NtfsValidateUsnPage( (PUSN_RECORD) BlockAlignTruncate( ((ULONG_PTR) UsnRecord), USN_PAGE_SIZE ),
                                                  BlockAlignTruncate( CapturedData.StartUsn, USN_PAGE_SIZE ),
                                                  &CapturedData.StartUsn,
                                                  UsnJournal->Header.FileSize.QuadPart,
                                                  &ValidUserStartUsn,
                                                  &NextUsn )) {

                            //
                            //  Simply fail the request with bad data.
                            //

                            Status = STATUS_DATA_ERROR;
                            leave;
                        }

                        //
                        //  If the user gave us an incorrect Usn then fail the request.
                        //

                        if (!ValidUserStartUsn) {

                            Status = STATUS_INVALID_PARAMETER;
                            leave;
                        }

                        //
                        //  Now loop to process this page.  We know the Usn values which exist on the page and
                        //  there are no checks for valid data needed.
                        //

                        while (CapturedData.StartUsn < NextUsn) {

                            RecordSize = UsnRecord->RecordLength;

                            //
                            //  Only recognize version 2 records.
                            //

                            if (FlagOn( UsnRecord->Reason, CapturedData.ReasonMask ) &&
                                (!CapturedData.ReturnOnlyOnClose || FlagOn( UsnRecord->Reason, USN_REASON_CLOSE )) &&
                                (UsnRecord->MajorVersion == 2)) {

                                if (RecordSize > RemainingUserBuffer) {
                                    RemainingUserBuffer = 0;
                                    break;
                                }

                                //
                                //  Copy the data back to the unsafe user buffer.
                                //

                                AccessingUserBuffer = TRUE;

                                //
                                //  Copy directly if the version numbers match.
                                //

                                RtlCopyMemory( OutputUsnRecord, UsnRecord, RecordSize );

                                AccessingUserBuffer = FALSE;

                                RemainingUserBuffer -= RecordSize;
                                BytesUsed += RecordSize;
                                OutputUsnRecord = Add2Ptr( OutputUsnRecord, RecordSize );
                            }

                            CapturedData.StartUsn += RecordSize;
                            UsnRecord = Add2Ptr( UsnRecord, RecordSize );

                            //
                            //  The view length should already account for record size.
                            //

                            ASSERT( ViewLength >= RecordSize );
                            ViewLength -= RecordSize;
                        }

                        //
                        //  Break out if the users buffer is empty.
                        //

                        if (RemainingUserBuffer == 0) {

                            break;
                        }

                        //
                        //  We finished the current page.  Now move to the next page.
                        //  Figure out how many bytes remain on this page.
                        //  If the next offset is the start of the next page then make sure
                        //  to mask off the page size bits again.
                        //

                        RecordSize = BlockOffset( USN_PAGE_SIZE - BlockOffset( (ULONG) NextUsn, USN_PAGE_SIZE ),
                                                  USN_PAGE_SIZE );

                        if (RecordSize > ViewLength) {

                            RecordSize = (ULONG) ViewLength;
                        }

                        UsnRecord = Add2Ptr( UsnRecord, RecordSize );
                        CapturedData.StartUsn += RecordSize;
                        ViewLength -= RecordSize;

                    } while (ViewLength != 0);

                    NtOfsReleaseMap( IrpContext, &MapHandle );
                }

            } while ((RemainingUserBuffer != 0) && (BytesUsed == sizeof(USN)));

            Irp->IoStatus.Information = BytesUsed;

            //
            //  Set the returned Usn.  Move to the start of the next page if
            //  the next record won't fit on this page.
            //

            AccessingUserBuffer = TRUE;
            *(USN *)UserBuffer = CapturedData.StartUsn;
            AccessingUserBuffer = FALSE;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            //
            //  Restore the original wait state back into the IrpContext.
            //

            ClearFlag( IrpContext->State, OriginalWait );

            if (FsRtlIsNtstatusExpected( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

            } else {

                ExRaiseStatus( AccessingUserBuffer ? STATUS_INVALID_USER_BUFFER : Status );
            }
        }

    } finally {

        NtOfsReleaseMap( IrpContext, &MapHandle );

        if (JournalAcquired) {
            NtfsReleaseResource( IrpContext, UsnJournal );
        }

        if (DecrementReferenceCount) {

            InterlockedDecrement( &UsnJournal->CloseCount );
        }

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  Complete the request, unless we've marked this Irp as pending and we plan to complete
    //  it later.  If the Irp is not the originating Irp then it belongs to another request
    //  and we don't want to complete it.
    //

    //
    //  Restore the original wait flag back into the IrpContext.
    //

    ClearFlag( IrpContext->State, OriginalWait );

    ASSERT( (Status == STATUS_PENDING) || (Irp->CancelRoutine == NULL) );

    NtfsCompleteRequest( (Irp == IrpContext->OriginatingIrp) ? IrpContext : NULL,
                         (Status != STATUS_PENDING) ? Irp : NULL,
                         Status );

    return Status;
}


ULONG
NtfsPostUsnChange (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID ScbOrFcb,
    IN ULONG Reason
    )

/*++

Routine Description:

    This routine is called to post a set of changes to a file.  A change is
    only posted if at least one reason in the Reason mask is not already set
    in either the Fcb or the IrpContext or if we are changing the source info
    reasons in the Fcb.

Arguments:

    ScbOrFcb - Supplies the file for which a change is being posted.  If reason contains
               USN_REASON_DATA_xxx reasons, then it must be an Scb, because we transform
               the code for named streams and do other special handling.

    Reason - Supplies a mask of reasons for which a change is being posted.

Return Value:

    Nonzero if changes are actually posted from this or a previous call

--*/

{
    PLCB Lcb;
    PFCB_USN_RECORD FcbUsnRecord;
    BOOLEAN Found;
    PFCB Fcb;
    PSCB Scb = NULL;
    ULONG NewReasons;
    ULONG RemovedSourceInfo;
    PUSN_FCB ThisUsn;
    BOOLEAN LockedFcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;

    //
    //  Assume we got an Fcb.
    //

    Fcb = (PFCB)ScbOrFcb;

    ASSERT( !(Reason & (USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION)) ||
            (NTFS_NTC_FCB != Fcb->NodeTypeCode) );

    //
    //  Switch if we got an Scb
    //

    if (Fcb->NodeTypeCode != NTFS_NTC_FCB) {

        ASSERT_SCB(Fcb);

        Scb = (PSCB)ScbOrFcb;
        Fcb = Scb->Fcb;
    }

    //
    //  We better be holding some resource.
    //

    ASSERT( !IsListEmpty( &IrpContext->ExclusiveFcbList ) ||
            ((Fcb->PagingIoResource != NULL) && NtfsIsSharedFcbPagingIo( Fcb )) ||
            NtfsIsSharedFcb( Fcb ) );

    //
    //  If there is a Usn Journal and its not a system file setup the memory structures
    //  to hold the usn reasons
    //

    ThisUsn = &IrpContext->Usn;

    if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE ) &&
        !FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

        //
        //  First see if we have a Usn record structure already for this file.  We might need
        //  the whole usn record or simply the name.  If this is the RENAME_NEW_NAME record
        //  then find then name again as well.
        //

        if ((Fcb->FcbUsnRecord == NULL) ||
            !FlagOn( Fcb->FcbState, FCB_STATE_VALID_USN_NAME ) ||
            FlagOn( Reason, USN_REASON_RENAME_NEW_NAME )) {

            ULONG SizeToAllocate;
            ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
            PFILE_NAME FileName = NULL;

            NtfsInitializeAttributeContext( &AttributeContext );

            try {

                //
                //  First we have to find the designated file name.  If we are lucky
                //  it is in an Lcb.  We cannot do this in the case of rename, because
                //  the in-memory stuff is not fixed up yet.
                //

                if (!FlagOn( Reason, USN_REASON_RENAME_NEW_NAME )) {

                    Lcb = (PLCB)CONTAINING_RECORD( Fcb->LcbQueue.Flink, LCB, FcbLinks );
                    while (&Lcb->FcbLinks.Flink != &Fcb->LcbQueue.Flink) {

                        //
                        //  If this is the designated file name, then we can get out pointing
                        //  to the FILE_NAME in the Lcb.
                        //

                        if (FlagOn( Lcb->LcbState, LCB_STATE_DESIGNATED_LINK )) {
                            FileName = (PFILE_NAME)&Lcb->ParentDirectory;
                            break;
                        }

                        //
                        //  Advance to next Lcb.
                        //

                        Lcb = (PLCB)CONTAINING_RECORD( Lcb->FcbLinks.Flink, LCB, FcbLinks );
                    }
                }

                //
                //  If we did not find the file name the easy way, then we have to go
                //  get it.
                //

                if (FileName == NULL) {

                    //
                    //  Acquire some synchronization against the filerecord
                    //  

                    NtfsAcquireResourceShared( IrpContext, Fcb, TRUE );
                    AcquiredFcb = TRUE;

                    //
                    //  Now scan for the filename attribute we need.
                    //

                    Found = NtfsLookupAttributeByCode( IrpContext,
                                                       Fcb,
                                                       &Fcb->FileReference,
                                                       $FILE_NAME,
                                                       &AttributeContext );

                    while (Found) {

                        FileName = (PFILE_NAME)NtfsAttributeValue( NtfsFoundAttribute(&AttributeContext) );

                        if (!FlagOn(FileName->Flags, FILE_NAME_DOS) || FlagOn(FileName->Flags, FILE_NAME_NTFS)) {
                            break;
                        }

                        Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                               Fcb,
                                                               $FILE_NAME,
                                                               &AttributeContext );
                    }

                    //
                    //  If there is no file name, raise corrupt!
                    //

                    if (FileName == NULL) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }
                }

                //
                //  Lock the Fcb so the record can't go away.
                //

                NtfsLockFcb( IrpContext, Fcb );
                LockedFcb = TRUE;

                //
                //  Now test for the need for a new record and construct one
                //  if necc. Prev. test was unsafe for checking the Fcb->FcbUsnRecord
                //

                if ((Fcb->FcbUsnRecord == NULL) ||
                    !FlagOn( Fcb->FcbState, FCB_STATE_VALID_USN_NAME ) ||
                    FlagOn( Reason, USN_REASON_RENAME_NEW_NAME )) {

                    //
                    //  Calculate the size required for the record and allocate a new record.
                    //

                    SizeToAllocate = sizeof( FCB_USN_RECORD ) + (FileName->FileNameLength * sizeof(WCHAR));
                    FcbUsnRecord = NtfsAllocatePool( PagedPool, SizeToAllocate );

                    //
                    //  Zero and initialize the new usn record.
                    //

                    RtlZeroMemory( FcbUsnRecord, SizeToAllocate );

                    FcbUsnRecord->NodeTypeCode = NTFS_NTC_USN_RECORD;
                    FcbUsnRecord->NodeByteSize = (USHORT)QuadAlign(FIELD_OFFSET( FCB_USN_RECORD, UsnRecord.FileName ) +
                                                                   (FileName->FileNameLength * sizeof(WCHAR)));
                    FcbUsnRecord->Fcb = Fcb;

                    FcbUsnRecord->UsnRecord.RecordLength = FcbUsnRecord->NodeByteSize -
                                                           FIELD_OFFSET( FCB_USN_RECORD, UsnRecord );

                    FcbUsnRecord->UsnRecord.MajorVersion = 2;
                    FcbUsnRecord->UsnRecord.FileReferenceNumber = *(PULONGLONG)&Fcb->FileReference;
                    FcbUsnRecord->UsnRecord.ParentFileReferenceNumber = *(PULONGLONG)&FileName->ParentDirectory;
                    FcbUsnRecord->UsnRecord.SecurityId = Fcb->SecurityId;
                    FcbUsnRecord->UsnRecord.FileNameLength = FileName->FileNameLength * 2;
                    FcbUsnRecord->UsnRecord.FileNameOffset = FIELD_OFFSET( USN_RECORD, FileName );

                    RtlCopyMemory( FcbUsnRecord->UsnRecord.FileName,
                                   FileName->FileName,
                                   FileName->FileNameLength * 2 );

                    //
                    //  If the record is there then copy the existing reasons and source info.
                    //

                    if (Fcb->FcbUsnRecord != NULL) {

                        FcbUsnRecord->UsnRecord.Reason = Fcb->FcbUsnRecord->UsnRecord.Reason;
                        FcbUsnRecord->UsnRecord.SourceInfo = Fcb->FcbUsnRecord->UsnRecord.SourceInfo;

                        //
                        //  Deallocate the existing block if still there.
                        //

                        NtfsLockFcb( IrpContext, Fcb->Vcb->UsnJournal->Fcb );

                        //
                        //  Put the new block into the modified list if the current one is
                        //  already there.
                        //

                        if (Fcb->FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {

                            InsertTailList( &Fcb->FcbUsnRecord->ModifiedOpenFilesLinks,
                                            &FcbUsnRecord->ModifiedOpenFilesLinks );
                            RemoveEntryList( &Fcb->FcbUsnRecord->ModifiedOpenFilesLinks );

                            if (Fcb->FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                                InsertTailList( &Fcb->FcbUsnRecord->TimeOutLinks,
                                                &FcbUsnRecord->TimeOutLinks );
                                RemoveEntryList( &Fcb->FcbUsnRecord->TimeOutLinks );
                            }
                        }

                        NtfsFreePool( Fcb->FcbUsnRecord );
                        Fcb->FcbUsnRecord = FcbUsnRecord;
                        NtfsUnlockFcb( IrpContext, Fcb->Vcb->UsnJournal->Fcb );

                    //
                    //  Otherwise this is a new usn structure.
                    //

                    } else {

                        Fcb->FcbUsnRecord = FcbUsnRecord;

                    }
                } else {

                    //
                    //  We are going to reuse the current fcb record in this path.
                    //  This can happen in races between the write path which has only paged sharing
                    //  and the close record path which has only main exclusive. In this
                    //  case the only synchronization we have is the fcb->mutex
                    //  The old usnrecord should be identical to the current one we would have constructed
                    //

                    ASSERT( FileName->FileNameLength * 2 == Fcb->FcbUsnRecord->UsnRecord.FileNameLength );
                    ASSERT( RtlEqualMemory( FileName->FileName, Fcb->FcbUsnRecord->UsnRecord.FileName,  Fcb->FcbUsnRecord->UsnRecord.FileNameLength ) );
                }

                //
                //  Set the flag indicating that the Usn name is valid.
                //

                SetFlag( Fcb->FcbState, FCB_STATE_VALID_USN_NAME );


            } finally {

                if (LockedFcb) {
                    NtfsUnlockFcb( IrpContext, Fcb );
                }
                if (AcquiredFcb) {
                    NtfsReleaseResource( IrpContext, Fcb );
                }
                NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            }
        }
    }

    //
    //  If we have memory structures for the usn reasons fill in the new reasons
    //  Note: this means that journal may not be active at this point. We will always
    //  accumulate reasons once we have started
    //

    if (Fcb->FcbUsnRecord != NULL) {

        //
        //  Scan the list to see if we already have an entry for this Fcb.  If there are
        //  no entries then use the position in the IrpContext, otherwise allocate a USN_FCB
        //  and chain this into the IrpContext.  Typical case for this is rename.
        //

        do {

            if (ThisUsn->CurrentUsnFcb == Fcb) { break; }

            //
            //  Check if we are at the last entry then we want to use the entry in the
            //  IrpContext.
            //

            if (ThisUsn->CurrentUsnFcb == NULL) {

                RtlZeroMemory( &ThisUsn->CurrentUsnFcb,
                               sizeof( USN_FCB ) - FIELD_OFFSET( USN_FCB, CurrentUsnFcb ));
                ThisUsn->CurrentUsnFcb = Fcb;
                break;
            }

            if (ThisUsn->NextUsnFcb == NULL) {

                //
                //  Allocate a new entry.
                //

                ThisUsn->NextUsnFcb = NtfsAllocatePool( PagedPool, sizeof( USN_FCB ));
                ThisUsn = ThisUsn->NextUsnFcb;

                RtlZeroMemory( ThisUsn, sizeof( USN_FCB ));
                ThisUsn->CurrentUsnFcb = Fcb;
                break;
            }

            ThisUsn = ThisUsn->NextUsnFcb;

        } while (TRUE);

        //
        //  If the Reason is one of the data stream reasons, and this is the named data
        //  steam, then change the code.
        //

        ASSERT(USN_REASON_NAMED_DATA_OVERWRITE == (USN_REASON_DATA_OVERWRITE << 4));
        ASSERT(USN_REASON_NAMED_DATA_EXTEND == (USN_REASON_DATA_EXTEND << 4));
        ASSERT(USN_REASON_NAMED_DATA_TRUNCATION == (USN_REASON_DATA_TRUNCATION << 4));

        if ((Reason & (USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION)) &&
            (Scb->AttributeName.Length != 0)) {

            //
            //  If any flag other than these three are set already, the shift will make
            //  them look like other flags.  For instance, USN_REASON_NAMED_DATA_EXTEND
            //  will become USN_REASON_FILE_DELETE, which will cause a number of problems.
            //

            ASSERT(!FlagOn( Reason, ~(USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION) ));

            Reason <<= 4;
        }

        //
        //  If there are no new reasons, then we can ignore this change.
        //
        //  We will generate a new record if the SourceInfo indicates some
        //  change to the source info in the record.
        //

        NtfsLockFcb( IrpContext, Fcb );

        //
        //  The rename flags are the only ones that do not accumulate until final close, since
        //  we write records designating old and new names.  So if we are writing one flag
        //  we must clear the other.
        //

        if (FlagOn(Reason, USN_REASON_RENAME_OLD_NAME | USN_REASON_RENAME_NEW_NAME)) {

            ClearFlag( ThisUsn->NewReasons,
                       (Reason ^ (USN_REASON_RENAME_OLD_NAME | USN_REASON_RENAME_NEW_NAME)) );
            ClearFlag( Fcb->FcbUsnRecord->UsnRecord.Reason,
                       (Reason ^ (USN_REASON_RENAME_OLD_NAME | USN_REASON_RENAME_NEW_NAME)) );
        }

        //
        //  Check if the reason is a new reason.
        //

        NewReasons = FlagOn( ~(Fcb->FcbUsnRecord->UsnRecord.Reason | ThisUsn->NewReasons), Reason );
        if (NewReasons != 0) {

            //
            //  Check if we will remove a bit from the source info.
            //

            if ((Fcb->FcbUsnRecord->UsnRecord.SourceInfo != 0) &&
                (Fcb->FcbUsnRecord->UsnRecord.Reason != 0) &&
                (Reason != USN_REASON_CLOSE)) {

                RemovedSourceInfo = FlagOn( Fcb->FcbUsnRecord->UsnRecord.SourceInfo,
                                            ~(IrpContext->SourceInfo | ThisUsn->RemovedSourceInfo) );

                if (RemovedSourceInfo != 0) {

                    SetFlag( ThisUsn->RemovedSourceInfo, RemovedSourceInfo );
                }
            }

            //
            //  Post the new reasons to the IrpContext.
            //

            ThisUsn->CurrentUsnFcb = Fcb;
            SetFlag( ThisUsn->NewReasons, NewReasons );
            SetFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );

        //
        //  Check if there is a change only to the source info.
        //  We look to see if we would remove a bit from the
        //  source info only if there has been at least one
        //  usn record already.
        //

        } else if ((Fcb->FcbUsnRecord->UsnRecord.SourceInfo != 0) &&
                   (Fcb->FcbUsnRecord->UsnRecord.Reason != 0) &&
                   (Reason != USN_REASON_CLOSE)) {

            //
            //  Remember the bit being removed.
            //

            RemovedSourceInfo = FlagOn( Fcb->FcbUsnRecord->UsnRecord.SourceInfo,
                                        ~(IrpContext->SourceInfo | ThisUsn->RemovedSourceInfo) );

            if (RemovedSourceInfo != 0) {

                SetFlag( ThisUsn->RemovedSourceInfo, RemovedSourceInfo );
                ThisUsn->CurrentUsnFcb = Fcb;
                SetFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );

            } else {

                Reason = 0;
            }

        //
        //  If we did not apply the changes, then make sure we do no more special processing
        //  below.
        //

        } else {

            Reason = 0;
        }

        NtfsUnlockFcb( IrpContext, Fcb );

        //
        //  For data overwrites it is necessary to actually write the Usn journal now, in
        //  case we crash before the request is completed, yet the data makes it out.  Also
        //  we need to capture the Lsn to flush to if the data is getting flushed.
        //
        //  We don't need to make this call if we are doing a rename.  Rename will rewrite previous
        //  records.
        //

        if ((IrpContext->MajorFunction != IRP_MJ_SET_INFORMATION) &&
            FlagOn( Reason, USN_REASON_DATA_OVERWRITE | USN_REASON_NAMED_DATA_OVERWRITE )) {

            LSN UpdateLsn;

            //
            //  For now assume we are not already a transaction, since we will be doing a
            //  checkpoint.  (If this ASSERT ever fires, verify that it is ok to checkpoint
            //  the transaction in that case and fix the ASSERT!)
            //

            ASSERT(IrpContext->TransactionId == 0);

            //
            //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
            //  reduce contention. Get rid of any pinned Mft records, because WriteUsnJournal is going
            //  to acquire the Scb resource.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsWriteUsnJournalChanges( IrpContext );
            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Capture the Lsn to flush to *in the first thread to set one of the above bits*,
            //  before letting any data hit the disk.  Synchronize it with the Fcb lock.
            //

            UpdateLsn = LfsQueryLastLsn( Fcb->Vcb->LogHandle );
            NtfsLockFcb( IrpContext, Fcb );
            Fcb->UpdateLsn = UpdateLsn;
            NtfsUnlockFcb( IrpContext, Fcb );
        }
    }

    return ThisUsn->NewReasons;
}


VOID
NtfsWriteUsnJournalChanges (
    PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to write a set of posted changes from the IrpContext
    to the UsnJournal, if they have not already been posted.

Arguments:

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PFCB Fcb;
    PVCB Vcb;
    PSCB UsnJournal;
    PUSN_FCB ThisUsn;
    ULONG PreserveWaitState;
    BOOLEAN WroteUsnRecord = FALSE;
    BOOLEAN ReleaseFcbs = FALSE;
    BOOLEAN CleanupContext = FALSE;

    ThisUsn = &IrpContext->Usn;

    do {

        //
        //  Is there an Fcb with usn reasons in the current irpcontext usn_fcb structures ?
        //  Also are there any new reasons to report for this fcb.
        //

        if ((ThisUsn->CurrentUsnFcb != NULL) &&
            FlagOn( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON )) {

            Fcb = ThisUsn->CurrentUsnFcb;
            Vcb = Fcb->Vcb;
            UsnJournal = Vcb->UsnJournal;

            //
            //  Remember that we wrote a record.
            //

            WroteUsnRecord = TRUE;

            //
            //  We better be waitable.
            //

            PreserveWaitState = (IrpContext->State ^ IRP_CONTEXT_STATE_WAIT) & IRP_CONTEXT_STATE_WAIT;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                //
                //  Acquire the Usn journal and lock the Fcb fields.
                //

                NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
                NtfsAcquireExclusiveScb( IrpContext, UsnJournal );
                ReleaseFcbs = TRUE;
            }

            try {

                USN Usn;
                ULONG BytesLeftInPage;

                //
                //  Make sure the changes have not already been logged.  We're
                //  looking for new reasons or a change to the source info.
                //

                NtfsLockFcb( IrpContext, Fcb );

                //
                //  This is the tricky synchronization case. Assumption is
                //  that if name goes invalid we have both resources exclusive and any writes will
                //  be preceded by a post which will remove the invalid record
                //  This occurs when we remove a link and generate one record under the old name
                //  with the flag set as invalid
                //

                ASSERT( !FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE ) ||
                        FlagOn( Fcb->FcbState, FCB_STATE_VALID_USN_NAME ) ||
                        (NtfsIsExclusiveFcb( Fcb ) &&
                         ((Fcb->PagingIoResource == NULL) || (NtfsIsExclusiveFcbPagingIo( Fcb )))) );

                //
                //  Initialize the Fcb source info if this is our first record.
                //

                if (Fcb->FcbUsnRecord->UsnRecord.Reason == 0) {

                    Fcb->FcbUsnRecord->UsnRecord.SourceInfo = IrpContext->SourceInfo;
                }

                //
                //  Accumulate all reasons and store in the Fcb before unlocking the Fcb.
                //

                SetFlag( Fcb->FcbUsnRecord->UsnRecord.Reason, ThisUsn->NewReasons );

                //
                //  Now clear the source info flags not supported by this
                //  caller.
                //

                ClearFlag( Fcb->FcbUsnRecord->UsnRecord.SourceInfo, ThisUsn->RemovedSourceInfo );

                //
                //  Unlock Fcb now so we do not deadlock if we do a checkpoint.
                //

                NtfsUnlockFcb( IrpContext, Fcb );

                //
                //  Only actually persist to disk if the journal is active
                //

                if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                    ASSERT( UsnJournal != NULL );

                    //
                    //  Initialize the context structure if we are doing a close.
                    //

                    if (FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_CLOSE )) {
                        NtfsInitializeAttributeContext( &AttributeContext );
                        CleanupContext = TRUE;
                    }

                    Usn = UsnJournal->Header.FileSize.QuadPart;
                    BytesLeftInPage = USN_PAGE_SIZE - ((ULONG)Usn & (USN_PAGE_SIZE - 1));

                    //
                    //  If there is not enough room left in this page for the
                    //  current Usn Record, then advance to the next page boundary
                    //  by writing 0's (these pages not zero-initialized( and update  the Usn.
                    //

                    if (BytesLeftInPage < Fcb->FcbUsnRecord->UsnRecord.RecordLength) {

                        ASSERT( Fcb->FcbUsnRecord->UsnRecord.RecordLength <= USN_PAGE_SIZE );

                        NtOfsPutData( IrpContext, UsnJournal, -1, BytesLeftInPage, NULL );
                        Usn += BytesLeftInPage;
                    }

                    Fcb->FcbUsnRecord->UsnRecord.Usn = Usn;

                    //
                    //  Build the FileAttributes from the Fcb.
                    //

                    Fcb->FcbUsnRecord->UsnRecord.FileAttributes = Fcb->Info.FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;

                    //
                    //  We have to generate the DIRECTORY attribute.
                    //

                    if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {
                        SetFlag( Fcb->FcbUsnRecord->UsnRecord.FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
                    }

                    //
                    //  If there are no flags set then explicitly set the NORMAL flag.
                    //

                    if (Fcb->FcbUsnRecord->UsnRecord.FileAttributes == 0) {
                        Fcb->FcbUsnRecord->UsnRecord.FileAttributes = FILE_ATTRIBUTE_NORMAL;
                    }

                    KeQuerySystemTime( &Fcb->FcbUsnRecord->UsnRecord.TimeStamp );

                    //
                    //  Append the record to the UsnJournal.  We should never see a record with
                    //  both rename flags or the close flag with the old name flag.
                    //

                    ASSERT( !FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_RENAME_OLD_NAME ) ||
                            !FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason,
                                     USN_REASON_CLOSE | USN_REASON_RENAME_NEW_NAME ));

                    NtOfsPutData( IrpContext,
                                  UsnJournal,
                                  -1,
                                  Fcb->FcbUsnRecord->UsnRecord.RecordLength,
                                  &Fcb->FcbUsnRecord->UsnRecord );

#ifdef BRIANDBG
                    //
                    //  The Usn better be in an allocated piece.
                    //

                    {
                        LCN Lcn;
                        LONGLONG ClusterCount;

                        if (!NtfsLookupAllocation( IrpContext,
                                                   UsnJournal,
                                                   LlClustersFromBytesTruncate( Vcb, Usn ),
                                                   &Lcn,
                                                   &ClusterCount,
                                                   NULL,
                                                   NULL ) ||
                            (Lcn == UNUSED_LCN)) {
                            ASSERT( FALSE );
                        }
                    }
#endif
                    //
                    //  If this is the close record, then we must update the Usn in the file record.
                    //

                    if (!FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_FILE_DELETE ) &&
                        !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                        //
                        //  See if we need to actually grow Standard Information first.
                        //  Do this even if we don't write the Usn record now.  We may
                        //  generate a close record for this file during mount and
                        //  we expect the STANDARD_INFORMATION to support Usns.
                        //

                        if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {

                            //
                            //  Grow the standard information.
                            //

                            NtfsGrowStandardInformation( IrpContext, Fcb );
                        }


                        if (FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_CLOSE )) {

                            //
                            //  Locate the standard information, it must be there.
                            //

                            if (!NtfsLookupAttributeByCode( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $STANDARD_INFORMATION,
                                                            &AttributeContext )) {

                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            ASSERT(NtfsFoundAttribute( &AttributeContext )->Form.Resident.ValueLength ==
                                sizeof( STANDARD_INFORMATION ));

                            //
                            //  Call to change the attribute value.
                            //

                            NtfsChangeAttributeValue( IrpContext,
                                                      Fcb,
                                                      FIELD_OFFSET(STANDARD_INFORMATION, Usn),
                                                      &Usn,
                                                      sizeof(Usn),
                                                      FALSE,
                                                      FALSE,
                                                      FALSE,
                                                      FALSE,
                                                      &AttributeContext );
                        }
                    }

                    //
                    //  Remember to release these resources as soon as possible now.
                    //  Note, if we are not sure that we became a transaction (else
                    //  case below) then our finally clause will do the release.
                    //
                    //  If the system has already gone through shutdown we won't be
                    //  able to start a transaction.  Test that we have a transaction
                    //  before setting these flags.
                    //

                    if (IrpContext->TransactionId != 0) {

                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                                    IRP_CONTEXT_FLAG_RELEASE_MFT );
                    }
                }

                //
                //  Clear the flag indicating that there are new reasons to report.
                //

                ClearFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );


            } finally {

                //
                //  Cleanup the context structure if we are doing a close.
                //

                if (CleanupContext) {
                    NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
                }

                if (ReleaseFcbs) {
                    NtfsReleaseScb( IrpContext, UsnJournal );
                    ASSERT( NtfsIsExclusiveScb( Vcb->MftScb ) );
                    NtfsReleaseScb( IrpContext, Vcb->MftScb );
                }
            }

            ClearFlag( IrpContext->State, PreserveWaitState );
        }

        //
        //  Go to the next entry if present.  If we are at the last entry then walk through all of the
        //  entries and clear the flag indicating we have new reasons.
        //

        if (ThisUsn->NextUsnFcb == NULL) {

            //
            //  Exit if we didn't write any records.
            //

            if (!WroteUsnRecord) { break; }

            ThisUsn = &IrpContext->Usn;

            do {

                ClearFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );
                if (ThisUsn->NextUsnFcb == NULL) { break; }

                ThisUsn = ThisUsn->NextUsnFcb;

            } while (TRUE);

            break;
        }

        ThisUsn = ThisUsn->NextUsnFcb;

    } while (TRUE);

    return;
}


VOID
NtfsSetupUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA NewJournalData
    )

/*++

Routine Description:

    This routine is called to setup the Usn Journal - the stream may or may
    not yet exist.  This routine is responsible for cleaning up the disk and
    in-memory structures on failure.

Arguments:

    Vcb - Supplies the volume being initialized.

    Fcb - Supplies the file for the Usn Journal.

    CreateIfNotExist - Indicates that we should use the values in the Vcb instead of on-disk.

    Restamp - Indicates if we should restamp the journal with a new Id.

    NewJournalData - Allocation size and delta for Usn journal if we are not reading from disk.

Return Value:

    None.

--*/

{
    RTL_GENERIC_TABLE UsnControlTable;
    PSCB UsnJournal;
    PUSN_RECORD UsnRecord, UsnRecordInTable;
    BOOLEAN CleanupControlTable = FALSE;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    MAP_HANDLE MapHandle;
    USN StartUsn;
    LONGLONG ClusterCount;

    PUSN_JOURNAL_INSTANCE UsnJournalData;
    USN_JOURNAL_INSTANCE UsnJournalInstance, VcbUsnInstance;
    PUSN_JOURNAL_INSTANCE InstanceToRestore;

    PBCB Bcb = NULL;

    LONGLONG SavedReservedSpace;
    LONGLONG RequiredReserved;

    BOOLEAN FoundMax;
    BOOLEAN NewMax = FALSE;
    BOOLEAN InsufficientReserved = FALSE;

    BOOLEAN DecrementCloseCount = TRUE;

    LARGE_INTEGER LastTimeStamp;

    ULONG TempUlong;
    LONGLONG TempLonglong;

    PAGED_CODE( );

    //
    //  Make sure we don't move to a larger page size.
    //

    ASSERT( USN_PAGE_BOUNDARY >= PAGE_SIZE );

    //
    //  Open/Create the Usn Journal stream.  We should never have an Scb
    //  if we are mounting a new volume.
    //

    ASSERT( (((ULONG) USN_JOURNAL_CACHE_BIAS) & (VACB_MAPPING_GRANULARITY - 1)) == 0 );

    NtOfsCreateAttribute( IrpContext,
                          Fcb,
                          JournalStreamName,
                          CREATE_OR_OPEN,
                          TRUE,
                          &UsnJournal );

    ASSERT( NtfsIsExclusiveScb( UsnJournal ) && NtfsIsExclusiveScb( Vcb->MftScb ) );

    //
    //  Initialize the enumeration context and map handle.
    //

    NtfsInitializeAttributeContext( &AttributeContext );
    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Let's build the journal instance data.  Assume we have current valid
    //  values in the Vcb for the Id and lowest valid usn.
    //

    UsnJournalInstance.MaximumSize = NewJournalData->MaximumSize;
    UsnJournalInstance.AllocationDelta = NewJournalData->AllocationDelta;

    UsnJournalInstance.JournalId = Vcb->UsnJournalInstance.JournalId;
    UsnJournalInstance.LowestValidUsn = Vcb->UsnJournalInstance.LowestValidUsn;

    //
    //  Capture the current reservation in the Journal Scb and also the
    //  current JournalData in the Vcb to restore on error.
    //

    SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;

    RtlCopyMemory( &VcbUsnInstance,
                   &Vcb->UsnJournalInstance,
                   sizeof( USN_JOURNAL_INSTANCE ));

    InstanceToRestore = &VcbUsnInstance;

    try {

        //
        //  Make sure the Scb is initialized.
        //

        if (!FlagOn( UsnJournal->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, UsnJournal, NULL );
        }

        //
        //  Always create the journal non-resident.  Otherwise in
        //  ConvertToNonResident we always need to check for this case
        //  which only happens once per volume.
        //

        if (FlagOn( UsnJournal->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            NtfsLookupAttributeForScb( IrpContext, UsnJournal, NULL, &AttributeContext );
            ASSERT( NtfsIsAttributeResident( NtfsFoundAttribute( &AttributeContext )));
            NtfsConvertToNonresident( IrpContext,
                                      Fcb,
                                      NtfsFoundAttribute( &AttributeContext ),
                                      FALSE,
                                      &AttributeContext );

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Remember to restamp if an earlier delete operation failed.  This flag should
        //  never be set if there is a current UsnJournal Scb in the Vcb.
        //


        ASSERT( !FlagOn( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE ) ||
                (Vcb->UsnJournal == NULL) );

        if (FlagOn( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE )) {

            Restamp = TRUE;
        }

        //
        //  If the $Max doesn't exist or we want to restamp then generate the
        //  new ID and Lowest ID.
        //

        if (!(FoundMax = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    $DATA,
                                                    &$Max,
                                                    NULL,
                                                    FALSE,
                                                    &AttributeContext )) ||
            Restamp ) {

            NtfsAdvanceUsnJournal( Vcb, &UsnJournalInstance, UsnJournal->Header.FileSize.QuadPart, &NewMax );

        //
        //  Examine the current $Max attribute for validity and either use the current values or
        //  generate new values.
        //

        } else {

            //
            //  Get the size of the $Max attribute.  It should always be resident but we will rewrite it in
            //  the case where it isn't.
            //

            if (NtfsIsAttributeResident( NtfsFoundAttribute( &AttributeContext ))) {

                TempUlong = (NtfsFoundAttribute( &AttributeContext))->Form.Resident.ValueLength;

            } else {

                TempUlong = (ULONG) (NtfsFoundAttribute( &AttributeContext))->Form.Nonresident.FileSize;
                NewMax = TRUE;
            }

            //
            //  Map the attribute and check it for consistency.
            //

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   &UsnJournalData,
                                   &TempUlong,
                                   &Bcb,
                                   &AttributeContext );

            //
            //  Only copy over the range of values we would understand.  If the size is not one
            //  we recognize then restamp the journal.  We handle the V1 case as well as V2 case.
            //

            if (TempUlong == sizeof( CREATE_USN_JOURNAL_DATA )) {

                UsnJournalInstance.LowestValidUsn = 0;
                KeQuerySystemTime( (PLARGE_INTEGER) &UsnJournalInstance.JournalId );

                //
                //  Put version 2 on the disk.
                //

                NewMax = TRUE;

                //
                //  If this is not an overwrite then copy the size and delta from the attribute.
                //

                if (!CreateIfNotExist) {

                    //
                    //  Assume we will use the values from the disk.
                    //

                    RtlCopyMemory( &UsnJournalInstance,
                                   UsnJournalData,
                                   TempUlong );
                }

            } else if (TempUlong == sizeof( USN_JOURNAL_INSTANCE )) {

                //
                //  Assume we will use the values from the disk.
                //

                if (CreateIfNotExist) {

                    NewMax = TRUE;
                    UsnJournalInstance.LowestValidUsn = UsnJournalData->LowestValidUsn;
                    UsnJournalInstance.JournalId = UsnJournalData->JournalId;

                } else {

                    //
                    //  Get the data from the disk.
                    //

                    RtlCopyMemory( &UsnJournalInstance,
                                   UsnJournalData,
                                   TempUlong );
                }

            } else {

                //
                //  Restamp in this case.
                //  We move forward in the file to the next Usn boundary.
                //

                NtfsAdvanceUsnJournal( Vcb, &UsnJournalInstance, UsnJournal->Header.FileSize.QuadPart, &NewMax );
            }

            //
            //  Put the Bcb back into the context if we removed it.
            //

            if (NtfsFoundBcb( &AttributeContext ) == NULL) {

                NtfsFoundBcb( &AttributeContext ) = Bcb;
                Bcb = NULL;
            }
        }

        //
        //  Check that the file doesn't end on a sparse hole.
        //

        if (!NewMax &&
            (UsnJournal->Header.AllocationSize.QuadPart != 0) &&
            (UsnJournalInstance.LowestValidUsn != UsnJournal->Header.AllocationSize.QuadPart)) {

            LCN Lcn;
            LONGLONG ClusterCount;

            if (!NtfsLookupAllocation( IrpContext,
                                       UsnJournal,
                                       LlClustersFromBytesTruncate( Vcb, UsnJournal->Header.AllocationSize.QuadPart - 1 ),
                                       &Lcn,
                                       &ClusterCount,
                                       NULL,
                                       NULL ) ||
                (Lcn == UNUSED_LCN)) {

                NtfsAdvanceUsnJournal( Vcb, &UsnJournalInstance, UsnJournal->Header.AllocationSize.QuadPart, &NewMax );
            }
        }

        //
        //  Enforce minimum sizes and allocation deltas, do not let them eat the whole volume,
        //  and round them to a Cache Manager View Size.  All of these decisions are arbitrary,
        //  but hopefully reasonable.  An option would be to take the cases other than those
        //  dealing with rounding, and return an error.
        //

        if ((ULONGLONG) UsnJournalInstance.MaximumSize < (ULONGLONG) VcbUsnInstance.MaximumSize) {

            UsnJournalInstance.MaximumSize = VcbUsnInstance.MaximumSize;
        }

        if (UsnJournalInstance.MaximumSize < MINIMUM_USN_JOURNAL_SIZE) {
            UsnJournalInstance.MaximumSize = MINIMUM_USN_JOURNAL_SIZE;
            NewMax = TRUE;
        } else {

            if ((ULONGLONG) UsnJournalInstance.MaximumSize > LlBytesFromClusters(Vcb, Vcb->TotalClusters) / 2) {
                UsnJournalInstance.MaximumSize = LlBytesFromClusters(Vcb, Vcb->TotalClusters) / 2;
                NewMax = TRUE;
            }

            if ((ULONGLONG) UsnJournalInstance.MaximumSize > USN_MAXIMUM_JOURNAL_SIZE) {
                UsnJournalInstance.MaximumSize = USN_MAXIMUM_JOURNAL_SIZE;
                NewMax = TRUE;
            }
        }

        //
        //  Round this value down to a cache view boundary.
        //

        UsnJournalInstance.MaximumSize &= ~(LONGLONG)((VACB_MAPPING_GRANULARITY) - 1);

        //
        //  Now do the allocation delta.
        //

        if ((ULONGLONG) UsnJournalInstance.AllocationDelta < (ULONGLONG) VcbUsnInstance.AllocationDelta) {

            UsnJournalInstance.AllocationDelta = VcbUsnInstance.AllocationDelta;
        }

        if (UsnJournalInstance.AllocationDelta < (MINIMUM_USN_JOURNAL_SIZE / 4)) {
            UsnJournalInstance.AllocationDelta = MINIMUM_USN_JOURNAL_SIZE / 4;
            NewMax = TRUE;
        } else if ((ULONGLONG) UsnJournalInstance.AllocationDelta > (UsnJournalInstance.MaximumSize / 4)) {
            UsnJournalInstance.AllocationDelta = (UsnJournalInstance.MaximumSize / 4);
            NewMax = TRUE;
        }

        //
        //  Round this down to a view boundary as well.
        //

        UsnJournalInstance.AllocationDelta &= ~(LONGLONG)((VACB_MAPPING_GRANULARITY) - 1);

        //
        //  We now know the desired size of the journal (including allocation delta).  Next
        //  we need to check that this space is available on disk.  Otherwise we can get in
        //  a state where every operation on the volume will fail because we need to grow
        //  the journal and the space isn't available.  The strategy here will be to use
        //  the reserved clusters in the Vcb to make sure we have enough space.  If the
        //  journal already exists and we are simply opening it then the space should
        //  be available.  It is possible someone could move this volume to NT4 and fill
        //  up the disk however.  If we can't reserve the space in the current system then
        //  update the $Max attribute to indicate that we can't access the journal at this time.
        //

        //
        //  We need to be very precise about the initial reservation.  The total allocation we allow
        //  ourselves is (MaxSize + Delta * 2).  We will reserve the missing space now and adjust it
        //  during the TrimUsnJournal phase.
        //

        RequiredReserved = UsnJournalInstance.MaximumSize + (UsnJournalInstance.AllocationDelta * 2);

        if (RequiredReserved >= UsnJournal->TotalAllocated) {

            RequiredReserved -= UsnJournal->TotalAllocated;

        } else {

            RequiredReserved = UsnJournalInstance.AllocationDelta;
        }

        NtfsAcquireReservedClusters( Vcb );

        //
        //  Check if there is more to reserve and adjust the reservation if necessary.
        //

        if (RequiredReserved > SavedReservedSpace) {

            //
            //  Check that the reserved clusters are available.
            //

            if (LlClustersFromBytes( Vcb, (RequiredReserved - SavedReservedSpace) ) + Vcb->TotalReserved > Vcb->FreeClusters) {

                //
                //  We can't reserve the required space.  If someone is changing the journal then simply
                //  raise the error.
                //

                if (CreateIfNotExist) {

                    NtfsReleaseReservedClusters( Vcb );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

                //
                //  We are trying to open the journal but can't get the space.  Update the
                //  $Max to indicate that the ID is changing.  We will bail later in this case.
                //
                //  We move forward in the file to the next Usn boundary.
                //

                TempUlong = USN_PAGE_BOUNDARY;
                if (USN_PAGE_BOUNDARY < Vcb->BytesPerCluster) {

                    TempUlong = Vcb->BytesPerCluster;
                }

                UsnJournalInstance.LowestValidUsn = UsnJournal->Header.FileSize.QuadPart + TempUlong - 1;
                ((PLARGE_INTEGER) &UsnJournalInstance.LowestValidUsn)->LowPart &= ~(TempUlong - 1);

                //
                //  Generate a new journal ID.
                //

                KeQuerySystemTime( (PLARGE_INTEGER) &UsnJournalInstance.JournalId );

                //
                //  Remember that we are restamping and need to rewrite the $Max attribute.
                //

                NewMax = TRUE;

                InsufficientReserved = TRUE;
            }
        }

        //
        //  Remove the current reservation and bias with the new reservation.
        //

        Vcb->TotalReserved -= LlClustersFromBytes( Vcb, SavedReservedSpace );
        Vcb->TotalReserved += LlClustersFromBytes( Vcb, RequiredReserved );
        UsnJournal->ScbType.Data.TotalReserved = RequiredReserved;
        SetFlag( UsnJournal->ScbState, SCB_STATE_WRITE_ACCESS_SEEN );
        NtfsReleaseReservedClusters( Vcb );

        //
        //  Check we need to write a new $Max attribute.
        //

        if (NewMax) {

            //
            //  Delete the existing $Max if present.
            //

            if (FoundMax) {

                if (NtfsIsAttributeResident( NtfsFoundAttribute( &AttributeContext ))) {

                    NtfsDeleteAttributeRecord( IrpContext,
                                               Fcb,
                                               (DELETE_LOG_OPERATION |
                                                DELETE_RELEASE_FILE_RECORD |
                                                DELETE_RELEASE_ALLOCATION),
                                               &AttributeContext );

                } else {

                    PSCB MaxScb;

                    MaxScb = NtfsCreateScb( IrpContext,
                                            Fcb,
                                            $DATA,
                                            &$Max,
                                            FALSE,
                                            NULL );

                    do {

                        NtfsDeleteAttributeRecord( IrpContext,
                                                   Fcb,
                                                   (DELETE_LOG_OPERATION |
                                                    DELETE_RELEASE_FILE_RECORD |
                                                    DELETE_RELEASE_ALLOCATION),
                                                   &AttributeContext );

                    } while (NtfsLookupNextAttributeForScb( IrpContext, MaxScb, &AttributeContext ));
                }
            }

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

            //
            //  Create the new $MAX attribute.
            //

            NtfsCreateAttributeWithValue( IrpContext,
                                          UsnJournal->Fcb,
                                          $DATA,
                                          &$Max,
                                          &UsnJournalInstance,
                                          sizeof( USN_JOURNAL_INSTANCE ),
                                          0,                             // attribute flags
                                          NULL,
                                          TRUE,
                                          &AttributeContext );
        }

        //
        //  Check if we are finished with the journal because of reservation problems.
        //

        if (InsufficientReserved) {

            //
            //  We want to checkpoint the request in order to leave the new $Max on disk.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );
            leave;
        }

        //
        //  Now update the Vcb with the new instance values.
        //

        RtlCopyMemory( &Vcb->UsnJournalInstance,
                       &UsnJournalInstance,
                       sizeof( USN_JOURNAL_INSTANCE ));

        //
        //  We now have the correct journal values in the Vcb and the reservation in the Scb.
        //  The next step is to make sure that the allocation in the journal data is consistent
        //  with the lowest Vcn value.
        //

        if (UsnJournalInstance.LowestValidUsn >= UsnJournal->Header.FileSize.QuadPart) {

            ASSERT( (Vcb->UsnJournal == NULL) ||
                    (Vcb->UsnJournal->Header.FileSize.QuadPart == 0) ||
                    (UsnJournalInstance.LowestValidUsn == UsnJournal->Header.FileSize.QuadPart) );

            //
            //  Add allocation if we need to.
            //

            if (UsnJournalInstance.LowestValidUsn > UsnJournal->Header.AllocationSize.QuadPart) {

                NtfsAddAllocation( IrpContext,
                                   NULL,
                                   UsnJournal,
                                   LlClustersFromBytesTruncate( Vcb, UsnJournal->Header.AllocationSize.QuadPart ),
                                   LlClustersFromBytes( Vcb,
                                                        UsnJournalInstance.LowestValidUsn - UsnJournal->Header.AllocationSize.QuadPart ),
                                   FALSE,
                                   NULL );
            }

            //
            //  Bump all of the sizes to this value.
            //

            UsnJournal->Header.ValidDataLength.QuadPart =
            UsnJournal->Header.FileSize.QuadPart =
            UsnJournal->ValidDataToDisk = UsnJournalInstance.LowestValidUsn;

            NtfsWriteFileSizes( IrpContext,
                                UsnJournal,
                                &UsnJournal->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                FALSE );

            //
            //  Throw away the allocation upto this value.
            //

            NtfsDeleteAllocation( IrpContext,
                                  NULL,
                                  UsnJournal,
                                  0,
                                  LlClustersFromBytesTruncate( Vcb, UsnJournalInstance.LowestValidUsn ) - 1,
                                  TRUE,
                                  FALSE );

            //
            //  Bias the Reserved space again.
            //

            RequiredReserved = UsnJournalInstance.MaximumSize + (UsnJournalInstance.AllocationDelta * 2);

            if (RequiredReserved >= UsnJournal->TotalAllocated) {

                RequiredReserved -= UsnJournal->TotalAllocated;

            } else {

                RequiredReserved = UsnJournalInstance.AllocationDelta;
            }

            NtfsAcquireReservedClusters( Vcb );
            Vcb->TotalReserved -= LlClustersFromBytes( Vcb, UsnJournal->ScbType.Data.TotalReserved );
            Vcb->TotalReserved += LlClustersFromBytes( Vcb, RequiredReserved );
            UsnJournal->ScbType.Data.TotalReserved = RequiredReserved;
            NtfsReleaseReservedClusters( Vcb );
        }

        //
        //  Make sure the stream is marked as sparse.
        //

        if (!FlagOn( UsnJournal->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            NtfsSetSparseStream( IrpContext, NULL, UsnJournal );
            NtfsUpdateDuplicateInfo( IrpContext, UsnJournal->Fcb, NULL, Vcb->ExtendDirectory );

            //
            //  No point in restoring the Vcb values now.
            //

            InstanceToRestore = NULL;
            SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;
        }

        //
        //  If this was just an overwrite of parameters (Journal already started), get out.
        //

        if (Vcb->UsnJournal != NULL) {

            ASSERT( FlagOn( Vcb->UsnJournal->Fcb->FcbState, FCB_STATE_USN_JOURNAL ));
            SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;
            InstanceToRestore = NULL;

            leave;
        }

        //
        //  Note in the Fcb that this is a journal file.
        //

        SetFlag( UsnJournal->Fcb->FcbState, FCB_STATE_USN_JOURNAL );

        //
        //  Initialize a generic table to scoreboard Fcb entries
        //

        RtlInitializeGenericTable( &UsnControlTable,
                                   NtfsUsnTableCompare,
                                   NtfsUsnTableAllocate,
                                   NtfsUsnTableFree,
                                   NULL );

        CleanupControlTable = TRUE;

        //
        //  Load the run information for the stream.  We are looking for the first position
        //  to read from the disk.
        //

        NtfsPreloadAllocation( IrpContext, UsnJournal, 0, MAXLONGLONG );

        if (UsnJournal->Header.AllocationSize.QuadPart != 0) {

            VCN CurrentVcn = 0;

            while (!NtfsLookupAllocation( IrpContext,
                                          UsnJournal,
                                          CurrentVcn,
                                          &TempLonglong,
                                          &ClusterCount,
                                          NULL,
                                          NULL )) {

                //
                //  Check the case where we returned the maximum LCN value.
                //

                if (CurrentVcn + ClusterCount == MAXLONGLONG) {

                    Vcb->FirstValidUsn = UsnJournal->Header.FileSize.QuadPart;
                    break;
                }

                //
                //  Find out the number of bytes in this block and check we don't
                //  go beyond file size.
                //

                Vcb->FirstValidUsn += LlBytesFromClusters( Vcb, ClusterCount );

                if (Vcb->FirstValidUsn >= UsnJournal->Header.FileSize.QuadPart) {

                    Vcb->FirstValidUsn = UsnJournal->Header.FileSize.QuadPart;
                    break;
                }

                CurrentVcn += ClusterCount;
            }
        }

        //
        //  Skip forward if we have restamped the file.
        //

        if (Vcb->FirstValidUsn < UsnJournalInstance.LowestValidUsn) {

            Vcb->FirstValidUsn = UsnJournalInstance.LowestValidUsn;
        }

        //
        //  Loop through as many views as required to fill the output buffer.
        //

        StartUsn = Vcb->LowestOpenUsn;
        if (StartUsn < Vcb->FirstValidUsn) {
            StartUsn = Vcb->FirstValidUsn;
        }

        //
        //  This is where we set up the bias for the Scb.  Only do this for cases where
        //  there already isn't a data section.
        //

        if (UsnJournal->NonpagedScb->SegmentObject.DataSectionObject == NULL) {

            Vcb->UsnCacheBias = Vcb->FirstValidUsn & ~(USN_JOURNAL_CACHE_BIAS - 1);

            if (Vcb->UsnCacheBias != 0) {

                Vcb->UsnCacheBias -= USN_JOURNAL_CACHE_BIAS;
            }

            NtfsCreateInternalAttributeStream( IrpContext, UsnJournal, TRUE, NULL );
        }

        while (StartUsn < UsnJournal->Header.FileSize.QuadPart) {

            LONGLONG BiasedStartUsn;

            //
            //  Calculate length to process in this view.
            //

            TempLonglong = UsnJournal->Header.FileSize.QuadPart - StartUsn;
            if (TempLonglong > (VACB_MAPPING_GRANULARITY - (ULONG)(StartUsn & (VACB_MAPPING_GRANULARITY - 1)))) {
                TempLonglong = VACB_MAPPING_GRANULARITY - (ULONG)(StartUsn & (VACB_MAPPING_GRANULARITY - 1));
            }

            //
            //  Map the view containing the desired Usn.
            //

            ASSERT( StartUsn >= Vcb->UsnCacheBias );
            BiasedStartUsn = StartUsn - Vcb->UsnCacheBias;
            NtOfsMapAttribute( IrpContext, UsnJournal, BiasedStartUsn, (ULONG)TempLonglong, &UsnRecord, &MapHandle );

            //
            //  Now loop to process this view.  TempLonglong is the space left in this view.  TempUlong is
            //  the space for the next record.
            //

            while (TempLonglong != 0) {

                //
                //  Calculate size left in current page, and see if we have to move to the
                //  next page.
                //
                //  Note in this loop we are not going to trust the the contents of the
                //  file, so if we see anything broken we raise an error.
                //

                TempUlong = USN_PAGE_SIZE - (ULONG)(StartUsn & (USN_PAGE_SIZE - 1));

                if ((TempUlong >= (FIELD_OFFSET(USN_RECORD, FileName) + sizeof(WCHAR))) && (UsnRecord->RecordLength != 0)) {

                    //
                    //  Get the size of the current record.
                    //

                    TempUlong = UsnRecord->RecordLength;

                    //
                    //  Since the Usn is embedded in the Usn record, we can do a fairly precise
                    //  test that we got a valid Usn.  Also make sure we got a valid RecordSize
                    //  that does not go beyond FileSize or the end of the page.  If we see a
                    //  bad record, then let's just skip to the end of the page rather than
                    //  tubing the mount process.
                    //

                    if ((TempUlong & (sizeof(ULONGLONG) - 1)) ||
                        (TempUlong > TempLonglong) ||
                        (TempUlong > (USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1)))) ||
                        (StartUsn != UsnRecord->Usn)) {

                        TempUlong = (USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1)));

                        //
                        //  FileSize may stop before the end of the page, so check for that so
                        //  we terminate correctly.
                        //

                        if (TempUlong > TempLonglong) {
                            TempUlong = (ULONG)TempLonglong;
                        }

                    //
                    //  We have to skip over any MajorVersion we do not understand.
                    //

                    } else if ((UsnRecord->MajorVersion == 1) ||
                               (UsnRecord->MajorVersion == 2)) {

                        //
                        //  Load up the info from this record.
                        //

                        if (!FlagOn(UsnRecord->Reason, USN_REASON_CLOSE)) {

                            UsnRecordInTable = RtlInsertElementGenericTable( &UsnControlTable,
                                                                             UsnRecord,
                                                                             UsnRecord->RecordLength,
                                                                             NULL );

                            UsnRecordInTable->Reason = UsnRecord->Reason;

                        //
                        //  If this is a close record, then we can delete our element from the
                        //  generic table.  Note if the record is not there this function returns
                        //  FALSE, and the attempted delete is benign.
                        //

                        } else {

                            (VOID)RtlDeleteElementGenericTable( &UsnControlTable, UsnRecord );
                        }

                        //
                        //  Capture each time stamp so that we can stamp our close records
                        //  with the last one we see.
                        //

                        LastTimeStamp = UsnRecord->TimeStamp;
                    }

                //
                //  Check for a bogus Usn near the end of a page that would cause us to
                //  decrement through length, or a RecordSize of 0, and just skip to the
                //  end of the page.
                //

                } else if ((TempUlong > TempLonglong) || (TempUlong == 0)) {

                    TempUlong = (USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1)));

                    if (TempUlong > TempLonglong) {

                        TempUlong = (ULONG) TempLonglong;
                    }
                }

                StartUsn += TempUlong;
                TempLonglong -= TempUlong;
                UsnRecord = Add2Ptr( UsnRecord, TempUlong );
            }

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        //
        //  Now write the close records for anyone who is left.  We store a counter
        //  in TempUlong to limit the number of records we do at a time.
        //

        for (TempUlong = 0, UsnRecord = RtlEnumerateGenericTable( &UsnControlTable, TRUE );
             UsnRecord != NULL;
             UsnRecord = RtlEnumerateGenericTable( &UsnControlTable, TRUE )) {

            ULONG UsnRecordReason;
            FILE_REFERENCE UsnRecordFileReferenceNumber;
            ULONG BytesLeftInPage;
            PFILE_RECORD_SEGMENT_HEADER FileRecord;
            NTSTATUS Status;

            StartUsn = NtOfsQueryLength( UsnJournal );
            StartUsn = UsnJournal->Header.FileSize.QuadPart;
            BytesLeftInPage = USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1));

            //
            //  If there is not enough room left in this page for the
            //  current Usn Record, then advance to the next page boundary
            //  by writing 0's (these pages not zero-initialized( and update  the Usn.
            //

            if (BytesLeftInPage < UsnRecord->RecordLength) {

                NtOfsPutData( IrpContext, UsnJournal, -1, BytesLeftInPage, NULL );
                StartUsn += BytesLeftInPage;
            }

            //
            //  Append the record to the UsnJournal.  Note that the generic table is unaligned for
            //  64-bit values so we have to carefully copy the larger values.
            //

            *((ULONGLONG UNALIGNED *) &UsnRecord->Usn) = StartUsn;
            *((ULONGLONG UNALIGNED *) &UsnRecord->TimeStamp) = *((PULONGLONG) &LastTimeStamp);

            UsnRecord->Reason |= USN_REASON_CLOSE;
            NtOfsPutData( IrpContext,
                          UsnJournal,
                          -1,
                          UsnRecord->RecordLength,
                          UsnRecord );

            //
            //  Remember key fields of the Usn record.
            //

            UsnRecordReason = UsnRecord->Reason;
            *((PULONGLONG) &UsnRecordFileReferenceNumber) = *((ULONGLONG UNALIGNED *) &UsnRecord->FileReferenceNumber);

            RtlDeleteElementGenericTable( &UsnControlTable, UsnRecord );
            TempUlong += 1;

            //
            //  Now we have to update the Usn in the file record, if it is not deleted.
            //  Also, we use try-except to plow on in the event of any errors, so we
            //  do not make the volume unmountable.  (One legitimate concern would be
            //  a hot-fix in the Mft.)
            //

            if (!FlagOn(UsnRecordReason, USN_REASON_FILE_DELETE)) {

                //
                //  Start by reading the file record and performing some simple tests.
                //  We don't want to go down the path where we mark the volume dirty
                //  for a file that was already cleaned up by autochk.
                //

                NtfsUnpinBcb( IrpContext, &Bcb );
                NtfsReadMftRecord( IrpContext,
                                   Vcb,
                                   &UsnRecordFileReferenceNumber,
                                   FALSE,
                                   &Bcb,
                                   &FileRecord,
                                   NULL );

                //
                //  Proceed only if the file record passes the following tests.
                //
                //      - FileRecord is in-use
                //      - Sequence numbers match
                //      - Standard information is the correct size (we should have done
                //          this when we wrote the changes)
                //

                if ((*(PULONG)(FileRecord)->MultiSectorHeader.Signature == *(PULONG)FileSignature) &&
                    FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) &&
                    (FileRecord->SequenceNumber == UsnRecordFileReferenceNumber.SequenceNumber)) {

                    //
                    //  Locate the standard information, it must be there.  This is the
                    //  Fcb for the Usn Journal, but the lookup routine only needs to get
                    //  the Vcb from it, and will special-case the return to us.
                    //

                    NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

                    try {

                        //
                        //  If we cannot find it for some reason, then leave.
                        //

                        if (!NtfsLookupAttributeByCode( IrpContext,
                                                        Fcb,
                                                        &UsnRecordFileReferenceNumber,
                                                        $STANDARD_INFORMATION,
                                                        &AttributeContext )) {
                            leave;
                        }

                        ASSERT(NtfsFoundAttribute( &AttributeContext )->Form.Resident.ValueLength ==
                            sizeof( STANDARD_INFORMATION ));

                        //
                        //  Call to change the attribute value.  Again, this is the wrong Fcb,
                        //  but it is ok since we are not changing the attribute size and will
                        //  only need to get the Vcb from it.
                        //

                        NtfsChangeAttributeValue( IrpContext,
                                                  Fcb,
                                                  FIELD_OFFSET(STANDARD_INFORMATION, Usn),
                                                  &StartUsn,
                                                  sizeof(StartUsn),
                                                  FALSE,
                                                  FALSE,
                                                  FALSE,
                                                  FALSE,
                                                  &AttributeContext );

                    } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {


                        //
                        //  If we get a log file full then raise this status.  There
                        //  is no reason to continue if we get a log file full.
                        //

                        if (Status == STATUS_LOG_FILE_FULL) {

                            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                        }

                        //
                        //  OK.  We are going to continue.  Make sure we clean up the IrpContext.
                        //

                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                    }
                }

                NtfsUnpinBcb( IrpContext, &Bcb );
            }

            //
            //  Checkpoint the transaction periodically so we don't spin on log file full.
            //

            if (TempUlong > GENERATE_CLOSE_RECORD_LIMIT) {

                NtfsCheckpointCurrentTransaction( IrpContext );
                SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;
                InstanceToRestore = NULL;
                TempUlong = 0;
            }
        }

        //
        //  Everything has succeeded to this point.  Now make sure the DELETE_USN flag is cleared on
        //  disk if present.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE )) {

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_DELETE_USN_UNDERWAY,
                                        FALSE,
                                        TRUE );
        }

        InstanceToRestore = NULL;
        SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;

        Vcb->UsnJournal = UsnJournal;
        DecrementCloseCount = FALSE;

        NtfsLockVcb( IrpContext, Vcb );
        SetFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE );
        ClearFlag( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE );
        NtfsUnlockVcb( IrpContext, Vcb );

    } finally {

        //
        //  Clean up any remaining entries in the control table in case we failed
        //  while processing it.
        //

        if (CleanupControlTable) {

            while ((UsnRecord = RtlEnumerateGenericTable( &UsnControlTable, TRUE )) != NULL) {

                RtlDeleteElementGenericTable( &UsnControlTable, UsnRecord );
            }
        }

        //
        //  Restore any changes we might have made to the Vcb.
        //

        if (InstanceToRestore) {

            RtlCopyMemory( &Vcb->UsnJournalInstance,
                           InstanceToRestore,
                           sizeof( USN_JOURNAL_INSTANCE ));
        }

        //
        //  Back out the reservation change if necessary.
        //

        if (UsnJournal->ScbType.Data.TotalReserved != SavedReservedSpace) {

            NtfsAcquireReservedClusters( Vcb );
            Vcb->TotalReserved += LlClustersFromBytes( Vcb, SavedReservedSpace );
            Vcb->TotalReserved -= LlClustersFromBytes( Vcb, UsnJournal->ScbType.Data.TotalReserved );
            UsnJournal->ScbType.Data.TotalReserved = SavedReservedSpace;
            NtfsReleaseReservedClusters( Vcb );
        }

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        NtfsUnpinBcb( IrpContext, &Bcb );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        //
        //  If we got an error and the Usn journal is not going to be created then fix up the
        //  new Scb so we won't access it during volume flush operations, etc.  Otherwise we
        //  will think the volume is corrupt because there is no attribute for the Scb.
        //

        if (DecrementCloseCount) {

            NtOfsCloseAttribute( IrpContext, UsnJournal );
        }

        if (Vcb->UsnJournal == NULL) {

#ifdef NTFSDBG

            //
            //  Compensate again for misclassification of usnjournal during delete
            //

            if (IrpContext->OwnershipState == NtfsOwns_ExVcb_Mft_Extend_Journal) {
                IrpContext->OwnershipState = NtfsOwns_ExVcb_Mft_Extend_File;
            }
#endif

            UsnJournal->Header.AllocationSize.QuadPart =
            UsnJournal->Header.FileSize.QuadPart =
            UsnJournal->ValidDataToDisk =
            UsnJournal->Header.ValidDataLength.QuadPart = 0;

            UsnJournal->AttributeTypeCode = $UNUSED;
            SetFlag( UsnJournal->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

            //
            //  Clear the system file flag out of the Fcb.
            //

            ClearFlag( UsnJournal->Fcb->FcbState, FCB_STATE_SYSTEM_FILE );

            ASSERT( ExIsResourceAcquiredSharedLite( &Vcb->Resource ));

            NtfsTeardownStructures( IrpContext,
                                    UsnJournal,
                                    NULL,
                                    TRUE,
                                    0,
                                    NULL );

        }
    }

    return;
}


VOID
NtfsTrimUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine may be called to check if the Usn Journal is beyond the designated
    size goal, and if so to delete the front of the file to bring it within the goal.
    This may require first generating a few close records for files that are still open
    and have their last record within this range.  Such files that are modified again
    will simply look like they were opened again.

    This routine is called with certain checkpoint flags for the volume set.  This is to
    serialize with the DeleteUsnJournal path.  We must clear them and signal other
    checkpointers to proceed.

Arguments:

    Vcb - Supplies the Vcb on which the Usn Journal is to be trimmed.

Return Value:

    None.

--*/

{
    PFCB Fcb;
    PFCB_USN_RECORD FcbUsnRecord;
    PSCB UsnJournal = Vcb->UsnJournal;
    USN FirstValidUsn = Vcb->FirstValidUsn;
    ULONG Done = FALSE;

    LONGLONG SavedReserved;
    LONGLONG RequiredReserved;
    LONGLONG SavedBias;
    BOOLEAN AcquiredMft = FALSE;
    BOOLEAN DerefFcb = FALSE;

    //
    //  Purge file record cache - may not be necc. here, examine this post nt5
    //

    NtfsPurgeFileRecordCache( IrpContext );

    //
    //  See if it is time to trim the UsnJournal.
    //

    NtfsAcquireResourceShared( IrpContext, UsnJournal, TRUE );
    while ((USN)(FirstValidUsn +
                 Vcb->UsnJournalInstance.MaximumSize +
                 Vcb->UsnJournalInstance.AllocationDelta) < (USN)UsnJournal->Header.FileSize.QuadPart) {

        FirstValidUsn += Vcb->UsnJournalInstance.AllocationDelta;
    }
    NtfsReleaseResource( IrpContext, UsnJournal );

    //
    //  Get to work if we have a new Usn to trim to.
    //

    if (FirstValidUsn != Vcb->FirstValidUsn) {

        //
        //  Use try-finally to catch any log file full condtions or allocation failures.
        //  Since these are the only possible error condition, we know what resources to
        //  free on exit.
        //

        try {

            do {

                Fcb = NULL;

                //
                //  Purge file record cache before acquiring vcb everytime
                //

                NtfsPurgeFileRecordCache( IrpContext );

                //
                //  Synchronize with the Fcb table and Usn Journal so that we can
                //  see if the next Fcb has to have a close record generated.
                //

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                NtfsAcquireFcbTable( IrpContext, Vcb );
                ExAcquireFastMutex( UsnJournal->Header.FastMutex );

                if (!IsListEmpty(&Vcb->ModifiedOpenFiles)) {
                    FcbUsnRecord = (PFCB_USN_RECORD)CONTAINING_RECORD( Vcb->ModifiedOpenFiles.Flink,
                                                                       FCB_USN_RECORD,
                                                                       ModifiedOpenFilesLinks );

                    //
                    //  If the Usn record for this Fcb is older than where we want to delete
                    //  to, then reference it.  Otherwise signal we are done by clearing
                    //  the Fcb pointer.
                    //

                    if (FcbUsnRecord->Fcb->Usn < FirstValidUsn) {
                        Fcb = FcbUsnRecord->Fcb;
                        Fcb->ReferenceCount += 1;
                        DerefFcb = TRUE;
                    } else {
                        Fcb = NULL;
                    }
                }

                ExReleaseFastMutex( UsnJournal->Header.FastMutex );
                NtfsReleaseFcbTable( IrpContext, Vcb );

                //
                //  Do we have to generate another close record?
                //

                if (Fcb != NULL) {

                    //
                    //  We must lock out other activity on this file since we are about
                    //  to reset the Usn reasons.
                    //

                    if (Fcb->PagingIoResource != NULL) {
                        ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
                    }
                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );

                    //
                    //  Skip over system files.
                    //

                    if (!FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

                        //
                        //  Post the close to our IrpContext.
                        //

                        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                        //
                        //  If we did not actually post a change, something is wrong,
                        //  because when a close change is written, the Fcb is removed from
                        //  the list.
                        //

                        ASSERT(IrpContext->Usn.CurrentUsnFcb != NULL);

                        //
                        //  Now generate the close record and checkpoint the transaction.
                        //

                        NtfsWriteUsnJournalChanges( IrpContext );
                        NtfsCheckpointCurrentTransaction( IrpContext );
                    }

                    //
                    //  Now we will dereference the Fcb.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    Fcb->ReferenceCount -= 1;
                    DerefFcb = FALSE;

                    //
                    //  We may be required to delete this guy.  This frees the Fcb Table.
                    //

                    if (IsListEmpty( &Fcb->ScbQueue ) && (Fcb->ReferenceCount == 0) && (Fcb->CloseCount == 0)) {

                        BOOLEAN AcquiredFcbTable = TRUE;

                        NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                        ASSERT(!AcquiredFcbTable);
                        Fcb = (PFCB)1;

                    //
                    //  Otherwise free the table and Fcb resources.
                    //

                    } else {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        NtfsReleaseFcb( IrpContext, Fcb );
                        if (Fcb->PagingIoResource != NULL) {
                            ExReleaseResourceLite( Fcb->PagingIoResource );
                        }
                    }
                }

                //
                //  Now we can drop the Vcb before looping back.
                //

                NtfsReleaseVcb( IrpContext, Vcb );

            } while (Fcb != NULL);

        } finally {

            //
            //  We got an error if Fcb is not NULL
            //

            if (Fcb != NULL) {

                if (DerefFcb) {
                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    Fcb->ReferenceCount -= 1;
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                }

                NtfsReleaseFcb( IrpContext, Fcb );
                if (Fcb->PagingIoResource != NULL) {
                    ExReleaseResourceLite( Fcb->PagingIoResource );
                }
                NtfsReleaseVcb( IrpContext, Vcb );
            }

            //
            //  If we raised then we need to clear the checkpoint flags.
            //

            if (AbnormalTermination()) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags,
                           VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);

                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }
        }

        //
        //  Now synchronize for deleting the allocation and purging pages from
        //  the cache.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
        NtfsAcquireExclusiveScb( IrpContext, UsnJournal );

        //
        //  Clear the checkpoint flags at this point.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->CheckpointFlags,
                   VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);

        NtfsSetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        try {

            LONGLONG BiasedFirstValidUsn;
            LONGLONG NewBias;

            SavedReserved = UsnJournal->ScbType.Data.TotalReserved;
            SavedBias = Vcb->UsnCacheBias;

            //
            //  Make sure to preserve our reservation.  We need to make sure anything we
            //  deallocate is available to us.
            //

            RequiredReserved = Vcb->UsnJournalInstance.AllocationDelta * 2 + Vcb->UsnJournalInstance.MaximumSize;

            if (SavedReserved < RequiredReserved) {

                //
                //  Bias the reservation with the maximum amount.
                //

                NtfsAcquireReservedClusters( Vcb );
                Vcb->TotalReserved -= LlClustersFromBytesTruncate( Vcb, SavedReserved );
                Vcb->TotalReserved += LlClustersFromBytesTruncate( Vcb, RequiredReserved );
                UsnJournal->ScbType.Data.TotalReserved = RequiredReserved;
                NtfsReleaseReservedClusters( Vcb );
            }

            NtfsDeleteAllocation( IrpContext,
                                  UsnJournal->FileObject,
                                  UsnJournal,
                                  0,
                                  LlClustersFromBytes(Vcb, FirstValidUsn) - 1,
                                  TRUE,
                                  TRUE );

            //
            //  Do a final checkpoint, especially since this IrpContext gets reused.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Adjust the current reserved amount more precisely.
            //

            NtfsAcquireReservedClusters( Vcb );

            if (UsnJournal->TotalAllocated > RequiredReserved) {

                SavedReserved = Vcb->UsnJournalInstance.AllocationDelta;

            } else {

                SavedReserved = RequiredReserved - UsnJournal->TotalAllocated;
            }

            //
            //  Remove the current reservation and bias with the new reservation.
            //

            Vcb->TotalReserved -= LlClustersFromBytesTruncate( Vcb, UsnJournal->ScbType.Data.TotalReserved );
            Vcb->TotalReserved += LlClustersFromBytesTruncate( Vcb, SavedReserved );
            UsnJournal->ScbType.Data.TotalReserved = SavedReserved;
            NtfsReleaseReservedClusters( Vcb );

            //
            //  If the nearly impossible case that the length wraps, then our
            //  purge will be too small, which simply means some unused pages
            //  will have to leave memory on their own!
            //

            BiasedFirstValidUsn = Vcb->FirstValidUsn - Vcb->UsnCacheBias;

            CcPurgeCacheSection( &UsnJournal->NonpagedScb->SegmentObject,
                                 (PLARGE_INTEGER)&BiasedFirstValidUsn,
                                 (ULONG)(FirstValidUsn - Vcb->FirstValidUsn) - 1,
                                 FALSE );


            //
            //  Adjust bias now if at threshold - the flush causes everything in
            //  cache and logfile to disk and we hold the journal exclusive. So
            //  all in memory stuff will now reflect the new bias
            //

            NewBias = FirstValidUsn & ~(USN_JOURNAL_CACHE_BIAS - 1);
            if (NewBias != 0) {
                NewBias -= USN_JOURNAL_CACHE_BIAS;
            }

            if (NewBias != Vcb->UsnCacheBias) {

                //
                //  Flush And Purge releases all resources in exclusive list so acquire
                //  the mft an extra time beforehand and restore back afterwards
                //

                NtfsAcquireResourceExclusive( IrpContext, Vcb->MftScb, TRUE );
                NtfsReleaseScb( IrpContext, Vcb->MftScb );
                AcquiredMft = TRUE;

                NtfsFlushAndPurgeScb( IrpContext, UsnJournal, NULL );
                Vcb->UsnCacheBias = NewBias;
                SavedBias = NewBias;
            }

            //
            //  If we reach here, then we can advance FirstValidUsn.  (Otherwise
            //  any retryable conditions will just resume work on this range.
            //

            Vcb->FirstValidUsn = FirstValidUsn;

        } finally {

            //
            //  Restore the error if we raised while deallocating.
            //

            if (SavedBias != Vcb->UsnCacheBias) {
                Vcb->UsnCacheBias = SavedBias;
            }

            if (SavedReserved != UsnJournal->ScbType.Data.TotalReserved) {

                NtfsAcquireReservedClusters( Vcb );
                Vcb->TotalReserved += LlClustersFromBytesTruncate( Vcb, SavedReserved );
                Vcb->TotalReserved -= LlClustersFromBytesTruncate( Vcb, RequiredReserved );
                UsnJournal->ScbType.Data.TotalReserved = SavedReserved;
                NtfsReleaseReservedClusters( Vcb );
            }

            NtfsReleaseScb( IrpContext, UsnJournal );

            if (AcquiredMft) {
                NtfsReleaseResource( IrpContext, Vcb->MftScb );
            } else {
                NtfsReleaseScb( IrpContext, Vcb->MftScb );
            }
        }

    } else {

        //
        //  Clear the checkpoint flags at this point.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->CheckpointFlags,
                   VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);

        NtfsSetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
    }
}


NTSTATUS
NtfsQueryUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the worker routine which returns the information about the current instance
    of the Usn journal.

Arguments:

    Irp - This is the Irp for the request.

Return Value:

    NTSTATUS - Result for this request.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PUSN_JOURNAL_DATA JournalData;

    PAGED_CODE();

    //
    //  Always make this request synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the compressed state of the file/directory.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in th
    //  irp first.  Then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        JournalData = (PUSN_JOURNAL_DATA) Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        JournalData = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (JournalData == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough for the journal data.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( USN_JOURNAL_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Decode the file object.  We only support this call for volume opens.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Acquire shared access to the Scb and check that the volume is still mounted.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    if (!FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED)) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Indicate if the journal is being deleted or has not started.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_JOURNAL_DELETE_IN_PROGRESS );
        return STATUS_JOURNAL_DELETE_IN_PROGRESS;
    }

    if (!FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_JOURNAL_NOT_ACTIVE );
        return STATUS_JOURNAL_NOT_ACTIVE;
    }

    //
    //  Otherwise serialize with the Usn journal and copy the data from the journal Scb
    //  and Vcb.
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->UsnJournal );

    JournalData->UsnJournalID = Vcb->UsnJournalInstance.JournalId;
    JournalData->FirstUsn = Vcb->FirstValidUsn;
    JournalData->NextUsn = Vcb->UsnJournal->Header.FileSize.QuadPart;
    JournalData->LowestValidUsn = Vcb->UsnJournalInstance.LowestValidUsn;
    JournalData->MaxUsn = MAXFILESIZE;
    JournalData->MaximumSize = Vcb->UsnJournalInstance.MaximumSize;
    JournalData->AllocationDelta = Vcb->UsnJournalInstance.AllocationDelta;

    NtfsReleaseScb( IrpContext, Vcb->UsnJournal );

    ASSERT( JournalData->FirstUsn >= JournalData->LowestValidUsn );

    NtfsReleaseVcb( IrpContext, Vcb );
    Irp->IoStatus.Information = sizeof( USN_JOURNAL_DATA );

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


NTSTATUS
NtfsDeleteUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the user want to delete the current usn journal.  This will
    initiate the work to scan the Mft and reset all usn values to zero and remove the
    UsnJournal file from the disk.

Arguments:

    Irp - This is the Irp for the request.

Return Value:

    NTSTATUS - Result for this request.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PDELETE_USN_JOURNAL_DATA DeleteData;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN CheckpointHeld = FALSE;
    BOOLEAN AcquiredNotify = FALSE;
    PSCB ReleaseUsnJournal = NULL;

    PLIST_ENTRY Links;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  We always wait in this path.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Perform a check on the input buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        DeleteData = (PDELETE_USN_JOURNAL_DATA) Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        DeleteData = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (DeleteData == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( DELETE_USN_JOURNAL_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Decode the file object type
    //

    NtfsDecodeFileObject( IrpContext,
                          IrpSp->FileObject,
                          &Vcb,
                          &Fcb,
                          &Scb,
                          &Ccb,
                          TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {

    
        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  We only support deleting and waiting for delete.
    //

    if (DeleteData->DeleteFlags == 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    if (FlagOn( DeleteData->DeleteFlags, ~USN_DELETE_VALID_FLAGS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Serialize with chkpoints and acquire the Vcb.  We need to carefully remove
        //  the journal from the Vcb.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS )) {

            //
            //  Release the checkpoint event because we cannot stop the log file now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
            NtfsAcquireCheckpoint( IrpContext, Vcb );
        }

        SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        CheckpointHeld = TRUE;

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

        //
        //  Check that the volume is still mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  If the user wants to delete the journal then make sure the delete hasn't
        //  already started.
        //

        if (FlagOn( DeleteData->DeleteFlags, USN_DELETE_FLAG_DELETE )) {

            //
            //  If the journal is already being deleted and this caller wanted to
            //  do the delete then let him know it has already begun.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

                Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                leave;
            }

            //
            //  Proceed with the delete if there is a Usn journal on disk.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_PRESENT ) ||
                (Vcb->UsnJournal != NULL)) {

                PSCB UsnJournal = Vcb->UsnJournal;

                //
                //  If the journal is running then the caller needs to match the journal ID.
                //

                if ((UsnJournal != NULL) &&
                    (DeleteData->UsnJournalID != Vcb->UsnJournalInstance.JournalId)) {

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                //
                //  Write the bit to disk to indicate that the journal is being deleted.
                //  Checkpoint the transaction.
                //

                NtfsSetVolumeInfoFlagState( IrpContext,
                                            Vcb,
                                            VOLUME_DELETE_USN_UNDERWAY,
                                            TRUE,
                                            TRUE );

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  We are going to proceed with the delete.  Clear the flag in the Vcb that
                //  indicates the journal is active.  Then acquire and drop all of the files in
                //  order to serialize with anyone using the journal.
                //

                ClearFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE );

                NtfsAcquireAllFiles( IrpContext,
                                     Vcb,
                                     TRUE,
                                     TRUE,
                                     TRUE );

                ReleaseUsnJournal = UsnJournal;
                if (UsnJournal != NULL) {

                    NtfsAcquireExclusiveScb( IrpContext, UsnJournal );
                }

                //
                //  Set the delete flag in the Vcb and remove the journal from the Vcb.
                //

                SetFlag( Vcb->VcbState, VCB_STATE_USN_DELETE );
                NtfsSetSegmentNumber( &Vcb->DeleteUsnData.DeleteUsnFileReference,
                                      0,
                                      MASTER_FILE_TABLE_NUMBER );

                Vcb->DeleteUsnData.DeleteUsnFileReference.SequenceNumber = 0;
                Vcb->DeleteUsnData.DeleteState = 0;
                Vcb->DeleteUsnData.PriorJournalScb = Vcb->UsnJournal;
                Vcb->UsnJournal = NULL;

                if (UsnJournal != NULL) {

                    //
                    //  Let's purge the data in the Usn journal and clear the bias
                    //  and file reference numbers in the Vcb.
                    //

                    CcPurgeCacheSection( &UsnJournal->NonpagedScb->SegmentObject,
                                         NULL,
                                         0,
                                         FALSE );

                    ClearFlag( UsnJournal->ScbPersist, SCB_PERSIST_USN_JOURNAL );
                }

                Vcb->UsnCacheBias = 0;
                *((PLONGLONG) &Vcb->UsnJournalReference) = 0;

                //
                //  Release the checkpoint if held.
                //

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS );
                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
                CheckpointHeld = FALSE;

                //
                //  Walk through the Irps waiting for new Usn data and cause them to be completed.
                //

                if (UsnJournal != NULL) {

                    PWAIT_FOR_NEW_LENGTH Waiter, NextWaiter;

                    ExAcquireFastMutex( UsnJournal->Header.FastMutex );
                    Waiter = (PWAIT_FOR_NEW_LENGTH) UsnJournal->ScbType.Data.WaitForNewLength.Flink;

                    while (Waiter != (PWAIT_FOR_NEW_LENGTH) &UsnJournal->ScbType.Data.WaitForNewLength) {

                        NextWaiter = (PWAIT_FOR_NEW_LENGTH) Waiter->WaitList.Flink;

                        //
                        //  We want to complete all of the Irps on the waiting list.  If cancel
                        //  has already been called on the Irp we don't have to do anything.
                        //  Otherwise complete the async Irps and signal the event on
                        //  the sync irps.
                        //

                        if (NtfsClearCancelRoutine( Waiter->Irp )) {

                            //
                            //  If this is an async request then complete the Irp.
                            //

                            if (FlagOn( Waiter->Flags, NTFS_WAIT_FLAG_ASYNC )) {

                                //
                                //  Make sure we decrement the reference count in the Scb.
                                //  Then remove the waiter from the queue and complete the Irp.
                                //

                                InterlockedDecrement( &UsnJournal->CloseCount );
                                RemoveEntryList( &Waiter->WaitList );

                                NtfsCompleteRequest( NULL, Waiter->Irp, STATUS_JOURNAL_DELETE_IN_PROGRESS );
                                NtfsFreePool( Waiter );

                            //
                            //  This is a synch Irp.  All we can do is set the event and note the status
                            //  code.
                            //

                            } else {

                                Waiter->Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                                KeSetEvent( &Waiter->Event, 0, FALSE );
                            }
                        }

                        Waiter = NextWaiter;
                    }


                    //
                    //  Walk through all of the Fcb Usn records and deallocate them.
                    //

                    Links = Vcb->ModifiedOpenFiles.Flink;

                    while (Vcb->ModifiedOpenFiles.Flink != &Vcb->ModifiedOpenFiles) {

                        RemoveEntryList( Links );
                        Links->Flink = NULL;

                        //
                        //  Look to see if we need to remove the TimeOut link as well.
                        //

                        Links = &(CONTAINING_RECORD( Links, FCB_USN_RECORD, ModifiedOpenFilesLinks ))->TimeOutLinks;

                        if (Links->Flink != NULL) {

                            RemoveEntryList( Links );
                        }

                        Links = Vcb->ModifiedOpenFiles.Flink;
                    }

                    ExReleaseFastMutex( UsnJournal->Header.FastMutex );

                    //
                    //  Make sure remove our reference on the Usn journal.
                    //

                    NtOfsCloseAttributeSafe( IrpContext, UsnJournal );
                    ReleaseUsnJournal = NULL;
                }

                //
                //  If this caller wants to wait for this then acquire the notify
                //  mutex now.
                //

                if (FlagOn( DeleteData->DeleteFlags, USN_DELETE_FLAG_NOTIFY )) {

                    NtfsAcquireUsnNotify( Vcb );
                    AcquiredNotify = TRUE;
                }

                //
                //  Post the work item to do the rest of the delete.
                //

                NtfsPostSpecial( IrpContext, Vcb, NtfsDeleteUsnSpecial, &Vcb->DeleteUsnData );
            }
        }

        //
        //  Check if our caller wants to wait for the delete to complete.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE ) &&
            FlagOn( DeleteData->DeleteFlags, USN_DELETE_FLAG_NOTIFY )) {

            if (!AcquiredNotify) {

                NtfsAcquireUsnNotify( Vcb );
                AcquiredNotify = TRUE;
            }

            Status = STATUS_PENDING;
            if (!NtfsSetCancelRoutine( Irp,
                                       NtfsCancelDeleteUsnJournal,
                                       0,
                                       TRUE )) {

                Status = STATUS_CANCELLED;

            //
            //  Add it to the work queue if we were able to set the
            //  cancel routine.
            //

            } else {

                InsertTailList( &Vcb->NotifyUsnDeleteIrps,
                                &Irp->Tail.Overlay.ListEntry );
            }

            NtfsReleaseUsnNotify( Vcb );
            AcquiredNotify = FALSE;
        }

    } finally {

        if (AcquiredNotify) {

            NtfsReleaseUsnNotify( Vcb );
        }

        //
        //  Release the Usn journal if held.
        //

        if (ReleaseUsnJournal) {

            NtfsReleaseScb( IrpContext, ReleaseUsnJournal );
        }

        //
        //  Release the Vcb if held.
        //

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  Release the checkpoint if held.
        //

        if (CheckpointHeld) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS );
            NtfsSetCheckpointNotify( IrpContext, Vcb );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }
    }

    //
    //  Complete the irp as appropriate.
    //

    NtfsCompleteRequest( IrpContext,
                         (Status == STATUS_PENDING) ? NULL : Irp,
                         Status );
    return Status;
}


VOID
NtfsDeleteUsnSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called to perform the work of deleting a Usn journal for a volume.
    It is called after the original entry point has done the preliminary work of stopping
    future journal activity and cleaning up active journal requests.  Once we reach this
    point then this routine will make sure the Mft values are reset, delete the journal
    file itself and wake up anyone waiting for the delete journal to complete.

Arguments:

    IrpContext - context of the call

    Context - DELETE_USN_CONTEXT structure used to manage the delete.

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTFS_DELETE_JOURNAL_DATA DeleteData = (PNTFS_DELETE_JOURNAL_DATA) Context;
    ULONG AcquiredVcb = FALSE;
    PVCB Vcb = IrpContext->Vcb;
    PFCB UsnFcb = NULL;
    BOOLEAN AcquiredExtendDirectory = FALSE;

    PIRP UsnNotifyIrp;

    PLIST_ENTRY Links;
    PSCB Scb;
    PFCB Fcb;

    PAGED_CODE();

    //
    //  Use a try-except to catch errors.
    //

    try {

        if (NtfsIsVolumeReadOnly( Vcb )) {

            Vcb->DeleteUsnData.FinalStatus = STATUS_MEDIA_WRITE_PROTECTED;
            NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
        }

        //
        //  Make sure to walk the Mft to set the Usn value back to zero.
        //

        if (!FlagOn( DeleteData->DeleteState, DELETE_USN_RESET_MFT )) {

            try {

                Status = NtfsIterateMft( IrpContext,
                                         IrpContext->Vcb,
                                         &DeleteData->DeleteUsnFileReference,
                                         NtfsDeleteUsnWorker,
                                         Context );

            } except (NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                NOTHING;
            }

            if (!NT_SUCCESS( Status ) && (Status != STATUS_END_OF_FILE)) {

                //
                //  If the operation is going to fail then decide if this is retryable.
                //

                if (Status == STATUS_VOLUME_DISMOUNTED) {

                    Vcb->DeleteUsnData.FinalStatus = STATUS_VOLUME_DISMOUNTED;

                } else if ((Status != STATUS_LOG_FILE_FULL) &&
                           (Status != STATUS_CANT_WAIT)) {

                    Vcb->DeleteUsnData.FinalStatus = Status;

                    //
                    //  Set all the flags for delete operations so we stop at this point.
                    //

                    SetFlag( DeleteData->DeleteState,
                             DELETE_USN_RESET_MFT | DELETE_USN_REMOVE_JOURNAL | DELETE_USN_FINAL_CLEANUP );

                    Status = STATUS_CANT_WAIT;
                }

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            Status = STATUS_SUCCESS;

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsCheckpointCurrentTransaction( IrpContext );
            SetFlag( DeleteData->DeleteState, DELETE_USN_RESET_MFT );
        }

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        AcquiredVcb = TRUE;

        //
        //  If the volume is no longer available then raise STATUS_VOLUME_DISMOUNTED.  Someone
        //  else will find all of the waiters.
        //

        if (!NtfsIsVcbAvailable( Vcb )) {

            Vcb->DeleteUsnData.FinalStatus = STATUS_VOLUME_DISMOUNTED;
            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  The next step is to remove the file if present.
        //

        if (!FlagOn( DeleteData->DeleteState, DELETE_USN_REMOVE_JOURNAL )) {

            try {

                if (Vcb->ExtendDirectory != NULL) {

                    NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
                    AcquiredExtendDirectory = TRUE;

                    UsnFcb = NtfsInitializeFileInExtendDirectory( IrpContext,
                                                                  Vcb,
                                                                  &NtfsUsnJrnlName,
                                                                  FALSE,
                                                                  FALSE );

                    if (UsnFcb != NULL) {

                        //
                        //  For lock order acquire in canonical order after unsafe try
                        //

                        if (!NtfsAcquireExclusiveFcb( IrpContext, UsnFcb, NULL, ACQUIRE_NO_DELETE_CHECK  | ACQUIRE_DONT_WAIT)) {
                            NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory );
                            NtfsAcquireExclusiveFcb( IrpContext, UsnFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                            NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
                        }

                        NtfsDeleteFile( IrpContext,
                                        UsnFcb,
                                        Vcb->ExtendDirectory,
                                        &AcquiredExtendDirectory,
                                        NULL,
                                        NULL );

                        NtfsPurgeFileRecordCache( IrpContext );
                        NtfsCheckpointCurrentTransaction( IrpContext );

                        ClearFlag( UsnFcb->FcbState, FCB_STATE_SYSTEM_FILE );
                        SetFlag( UsnFcb->FcbState, FCB_STATE_FILE_DELETED );

                        //
                        //  Walk all of the Scbs for this file and mark them
                        //  deleted.  This will keep the lazy writer from trying to
                        //  flush them.
                        //

                        Links = UsnFcb->ScbQueue.Flink;

                        while (Links != &UsnFcb->ScbQueue) {

                            Scb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                            //
                            //  Recover the reservation for the Scb now instead of waiting for it
                            //  to go away.
                            //

                            if ((Scb->AttributeTypeCode == $DATA) &&
                                (Scb->ScbType.Data.TotalReserved != 0)) {

                                NtfsAcquireReservedClusters( Vcb );

                                Vcb->TotalReserved -= LlClustersFromBytes( Vcb,
                                                                           Scb->ScbType.Data.TotalReserved );
                                Scb->ScbType.Data.TotalReserved = 0;
                                NtfsReleaseReservedClusters( Vcb );
                            }

                            Scb->ValidDataToDisk =
                            Scb->Header.AllocationSize.QuadPart =
                            Scb->Header.FileSize.QuadPart =
                            Scb->Header.ValidDataLength.QuadPart = 0;

                            Scb->AttributeTypeCode = $UNUSED;
                            SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

                            Links = Links->Flink;
                        }

                        //
                        //  Now teardown the Fcb.
                        //

                        NtfsTeardownStructures( IrpContext,
                                                UsnFcb,
                                                NULL,
                                                FALSE,
                                                ACQUIRE_NO_DELETE_CHECK,
                                                NULL );
                    }
                }

            } except (NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                //
                //    We hit some failure and can't complete the operation.
                //    Remember the error, set the flags in the delete Usn structure
                //    and raise CANT_WAIT so we can abort and then do the final cleanup.
                //

                Vcb->DeleteUsnData.FinalStatus = Status;

                //
                //  Set all the flags for delete operations so we stop at this point.
                //

                SetFlag( DeleteData->DeleteState,
                         DELETE_USN_RESET_MFT | DELETE_USN_REMOVE_JOURNAL | DELETE_USN_FINAL_CLEANUP );

                Status = STATUS_CANT_WAIT;
            }

            if (!NT_SUCCESS( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            SetFlag( DeleteData->DeleteState, DELETE_USN_REMOVE_JOURNAL );
        }

        if (!FlagOn( DeleteData->DeleteState, DELETE_USN_FINAL_CLEANUP )) {

            //
            //  Clear the on-disk flag indicating the delete is in progress.
            //

            try {

                NtfsSetVolumeInfoFlagState( IrpContext,
                                            Vcb,
                                            VOLUME_DELETE_USN_UNDERWAY,
                                            FALSE,
                                            TRUE );

            } except (NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                //
                //    We hit some failure and can't complete the operation.
                //    Remember the error, set the flags in the delete Usn structure
                //    and raise CANT_WAIT so we can abort and then do the final cleanup.
                //

                Vcb->DeleteUsnData.FinalStatus = Status;

                //
                //  Set all the flags for delete operations so we stop at this point.
                //

                SetFlag( DeleteData->DeleteState,
                         DELETE_USN_RESET_MFT | DELETE_USN_REMOVE_JOURNAL | DELETE_USN_FINAL_CLEANUP );

                Status = STATUS_CANT_WAIT;
            }

            if (!NT_SUCCESS( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }
        }

        //
        //  Make sure we don't own any resources at this point.
        //

        NtfsPurgeFileRecordCache( IrpContext );
        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Finally, now that we have written the forget record, we can free
        //  any exclusive Scbs that we have been holding.
        //

        while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

            Fcb = (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                          FCB,
                                          ExclusiveFcbLinks );

            NtfsReleaseFcb( IrpContext, Fcb );
        }

        //
        //  Remember any saved status code.
        //

        if (Vcb->DeleteUsnData.FinalStatus != STATUS_SUCCESS) {

            Status = Vcb->DeleteUsnData.FinalStatus;

            //
            //  Since we failed make sure to leave the flag set in the Vcb which indicates the
            //  incomplete delete.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE );
        }

        //
        //  Cleanup the context and flags in the Vcb.
        //

        RtlZeroMemory( &Vcb->DeleteUsnData, sizeof( NTFS_DELETE_JOURNAL_DATA ));
        RtlZeroMemory( &Vcb->UsnJournalInstance, sizeof( USN_JOURNAL_INSTANCE ));
        Vcb->FirstValidUsn = 0;
        Vcb->LowestOpenUsn = 0;

        ClearFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_PRESENT | VCB_STATE_USN_DELETE );

        //
        //  Finally complete all of the waiting Irps in the Usn notify queue.
        //

        NtfsAcquireUsnNotify( Vcb );

        Links = Vcb->NotifyUsnDeleteIrps.Flink;

        while (Links != &Vcb->NotifyUsnDeleteIrps) {

            UsnNotifyIrp = CONTAINING_RECORD( Links,
                                              IRP,
                                              Tail.Overlay.ListEntry );

            //
            //  Remember to move forward in any case.
            //

            Links = Links->Flink;

            //
            //  Clear the notify routine and detect if cancel has
            //  already been called.
            //

            if (NtfsClearCancelRoutine( UsnNotifyIrp )) {

                RemoveEntryList( &UsnNotifyIrp->Tail.Overlay.ListEntry );
                NtfsCompleteRequest( NULL, UsnNotifyIrp, Status );
            }
        }

        NtfsReleaseUsnNotify( Vcb );

    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation())) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    if (AcquiredVcb) {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    //
    //  If this is a fatal failure then do any final cleanup.
    //

    if (!NT_SUCCESS( Status )) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    return;

    UNREFERENCED_PARAMETER( Context );
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
NtfsUsnTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

    This is a generic table support routine to compare two File References
    in Usn Records.

Arguments:

    Table - Supplies the generic table being queried.  Not used.

    FirstStruct - Supplies the first Usn Record to compare

    SecondStruct - Supplies the second Usn Record to compare

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    PAGED_CODE();

    if (*((PLONGLONG) &((PUSN_RECORD) FirstStruct)->FileReferenceNumber) <
        *((PLONGLONG) &((PUSN_RECORD) SecondStruct)->FileReferenceNumber)) {

        return GenericLessThan;
    }

    if (*((PLONGLONG) &((PUSN_RECORD) FirstStruct)->FileReferenceNumber) >
        *((PLONGLONG) &((PUSN_RECORD) SecondStruct)->FileReferenceNumber)) {

        return GenericGreaterThan;
    }

    return GenericEqual;

    UNREFERENCED_PARAMETER( Table );
}


//
//  Local support routine
//

PVOID
NtfsUsnTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    Table - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    UNREFERENCED_PARAMETER( Table );

    PAGED_CODE();

    return NtfsAllocatePool( PagedPool, ByteSize );
}


//
//  Local support routine
//

VOID
NtfsUsnTableFree (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine to free memory

Arguments:

    Table - Supplies the generic table being used

    Buffer - Supplies pointer to the buffer to be freed

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( Table );

    PAGED_CODE();

    NtfsFreePool( Buffer );
}


//
//  Local support routine
//

VOID
NtfsCancelReadUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine may be called by the I/O system to cancel an outstanding
    Irp in NtfsReadUsnJournal.

Arguments:

    DeviceObject - DeviceObject from I/O system

    Irp - Supplies the pointer to the Irp being canceled.

Return Value:

    None

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength;

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Capture the Wait block out of the Status field.  We know the Irp can't
    //  go away at this point.
    //

    WaitForNewLength = (PWAIT_FOR_NEW_LENGTH) Irp->IoStatus.Information;
    Irp->IoStatus.Information = 0;

    //
    //  Take a different action depending on whether we are completing the irp
    //  or simply signaling the cancel.
    //


    //
    //  This is the async case.  We can simply complete this irp.
    //

    if (FlagOn( WaitForNewLength->Flags, NTFS_WAIT_FLAG_ASYNC )) {

        //
        //  Acquire the mutex in order to remove this from the list and complete
        //  the Irp.
        //

        ExAcquireFastMutex( WaitForNewLength->Stream->Header.FastMutex );
        RemoveEntryList( &WaitForNewLength->WaitList );
        ExReleaseFastMutex( WaitForNewLength->Stream->Header.FastMutex );

        InterlockedDecrement( &WaitForNewLength->Stream->CloseCount );

        NtfsCompleteRequest( NULL, Irp, STATUS_CANCELLED );
        NtfsFreePool( WaitForNewLength );

    //
    //  If there is not an Irp we simply signal the event and let someone else
    //  do the work.  This is the synchronous case.
    //

    } else {

        WaitForNewLength->Status = STATUS_CANCELLED;
        KeSetEvent( &WaitForNewLength->Event, 0, FALSE );
    }

    return;
    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

VOID
NtfsCancelDeleteUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine may be called by the I/O system to cancel an outstanding
    Irp waiting for the usn journal to be deleted.

Arguments:

    DeviceObject - DeviceObject from I/O system

    Irp - Supplies the pointer to the Irp being canceled.

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PVCB Vcb;

    //
    //  Block out future cancels.
    //

    IoSetCancelRoutine( Irp, NULL );

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Capture the Vcb so we can do the necessary synchronization.
    //

    FileObject = IrpSp->FileObject;
    Vcb = ((PSCB)(FileObject->FsContext))->Vcb;

    //
    //  Acquire the list and remove the Irp.  Complete the Irp with
    //  STATUS_CANCELLED.
    //

    NtfsAcquireUsnNotify( Vcb );
    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    NtfsReleaseUsnNotify( Vcb );

    Irp->IoStatus.Information = 0;
    NtfsCompleteRequest( NULL, Irp, STATUS_CANCELLED );

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
NtfsDeleteUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routines resets the Usn in the file record for the Fcb to zero.

Arguments:

    IrpContext - context of the call

    Fcb - Fcb for the file record to clear

    Context - Unused

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID UsnRecord;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER Attribute;
    STANDARD_INFORMATION NewStandardInformation;
    USN Usn = 0;

    PAGED_CODE();

    //
    //  Initialize the search context.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-except to catch all of the errors.
    //

    try {

        //
        //  Use a try-finally to facilitate cleanup.
        //

        try {

            //
            //  Look up the standard information attribute and modify the usn field if
            //  the attribute is found and it is a large standard attribute.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO ) &&
                NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $STANDARD_INFORMATION,
                                           &AttrContext )) {

                Attribute = NtfsFoundAttribute( &AttrContext );

                if (((PSTANDARD_INFORMATION) NtfsAttributeValue( Attribute ))->Usn != 0) {

                    RtlCopyMemory( &NewStandardInformation,
                                   NtfsAttributeValue( Attribute ),
                                   sizeof( STANDARD_INFORMATION ));

                    NewStandardInformation.Usn = 0;

                    NtfsChangeAttributeValue( IrpContext,
                                              Fcb,
                                              0,
                                              &NewStandardInformation,
                                              sizeof( STANDARD_INFORMATION ),
                                              FALSE,
                                              FALSE,
                                              FALSE,
                                              FALSE,
                                              &AttrContext );
                }
            }

            //
            //  Make sure the Fcb reflects this change.
            //

            NtfsLockFcb( IrpContext, Fcb );

            Fcb->Usn = 0;
            UsnRecord = Fcb->FcbUsnRecord;
            Fcb->FcbUsnRecord = NULL;

            NtfsUnlockFcb( IrpContext, Fcb );

            if (UsnRecord != NULL) {

                NtfsFreePool( UsnRecord );
            }

        } finally {

            //
            //  Be sure to clean up the context.
            //

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

    //
    //  We want to swallow any expected errors except LOG_FILE_FULL and CANT_WAIT.
    //

    } except ((FsRtlIsNtstatusExpected( Status = GetExceptionCode()) &&
               (Status != STATUS_LOG_FILE_FULL) &&
               (Status != STATUS_CANT_WAIT)) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Always return success from this routine.
    //

    IrpContext->ExceptionStatus = STATUS_SUCCESS;
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( Context );
}


//
//  Local support routine
//

BOOLEAN
NtfsValidateUsnPage (
    IN PUSN_RECORD UsnRecord,
    IN USN PageUsn,
    IN USN *UserStartUsn OPTIONAL,
    IN LONGLONG UsnFileSize,
    OUT PBOOLEAN ValidUserStartUsn OPTIONAL,
    OUT USN *NextUsn
    )

/*++

Routine Description:

    This routine checks the offsets within a single page of the usn journal.  This allows the caller to
    then walk safely through the page.

Arguments:

    UsnRecord - Pointer to the start of the Usn page.

    PageUsn - This is the Usn for the first record of the page.

    UserStartUsn - If specified then do an additional check that the user's specified usn in fact
        lies correctly on this page.  The output boolean must also be specified if this is.

    UsnFileSize - This is the current size of the usn journal.  If we are looking at the last page then
        we only check to this point.

    ValidUserStartUsn - Address to result of check on user specified start Usn.

    NextUsn - This is the Usn past the valid portion of the page.  It will point to a position on the
        current page unless the last record on the page completely fills the page.  If the page isn't valid
        then it points to the position where the invalid record was detected.

Return Value:

    BOOLEAN - TRUE if the page is valid until a legal terminating condition.  FALSE if there is internal
        corruption on the page.

--*/

{
    ULONG RemainingPageBytes;
    ULONG RecordLength;
    BOOLEAN ValidPage = TRUE;
    BOOLEAN FoundEntry = FALSE;

    PAGED_CODE();

    //
    //  Verify a few input values.
    //

    ASSERT( UsnFileSize > PageUsn );
    ASSERT( !FlagOn( *((PULONG) &UsnRecord), USN_PAGE_SIZE - 1 ));
    ASSERT( !ARGUMENT_PRESENT( UserStartUsn ) || ARGUMENT_PRESENT( ValidUserStartUsn ));
    ASSERT( !ARGUMENT_PRESENT( ValidUserStartUsn ) || ARGUMENT_PRESENT( UserStartUsn ));

    //
    //  Compute the Usn past the valid data on this page.  It is either the end of the journal or
    //  the next page of the journal.
    //

    RemainingPageBytes = USN_PAGE_SIZE;

    if (UsnFileSize < (PageUsn + USN_PAGE_SIZE)) {

        RemainingPageBytes = (ULONG) (UsnFileSize - PageUsn);
    }

    //
    //  Assume the user's Usn is invalid unless it wasn't specified.
    //

    if (!ARGUMENT_PRESENT( ValidUserStartUsn )) {

        ValidUserStartUsn = (PBOOLEAN) NtfsAllocateFromStack( sizeof( BOOLEAN ));
        *ValidUserStartUsn = TRUE;

    } else {

        *ValidUserStartUsn = FALSE;
    }

    //
    //  Keep track of our current position in the page with the user's pointer.
    //

    *NextUsn = PageUsn;

    //
    //  Check each entry in the page for the following.
    //
    //      1 - Fixed portion of the header won't fit within the remaining bytes on the page.
    //      2 - Record header is zeroed.
    //      3 - Record length is not quad-aligned.
    //      4 - Record length is larger than the remaining bytes on the page.
    //      5 - Usn on the page doesn't match the computed value.
    //

    while (RemainingPageBytes != 0) {

        //
        //  Not enough bytes even for the full Usn header.
        //

        if (RemainingPageBytes < (FIELD_OFFSET( USN_RECORD, FileName ) + sizeof( WCHAR ))) {

            //
            //  If there is at least a ulong it better be zeroed.
            //

            if ((RemainingPageBytes >= sizeof( ULONG )) &&
                (UsnRecord->RecordLength != 0)) {

                ValidPage = FALSE;

            //
            //  If the user's Usn points to this offset then it is valid.
            //

            } else if (!(*ValidUserStartUsn) &&
                        (*NextUsn == *UserStartUsn)) {

                *ValidUserStartUsn = TRUE;
            }

            break;
        }

        //
        //  There should be at least one entry on the page.  We attempt to detect
        //  a local loss of data through zeroing but won't check to the end of
        //  the page.
        //

        RecordLength = UsnRecord->RecordLength;
        if (RecordLength == 0) {

            //
            //  Fail if we haven't found at least one entry.
            //

            if (!FoundEntry) {

                ValidPage = FALSE;

            //
            //  We know we should be dealing with the tail of the page.  It should
            //  be zeroed through the fixed portion of a Usn record.  Theoretically
            //  it should be zeroed to the end of the page but we will assume that we
            //  are only looking for local corruption.  If we lost data through the
            //  end of the page we can't detect it anyway.
            //

            } else {

                PCHAR CurrentByte = (PCHAR) UsnRecord;
                ULONG Count = FIELD_OFFSET( USN_RECORD, FileName ) + sizeof( WCHAR );

                while (Count != 0) {

                    if (*CurrentByte != 0) {

                        ValidPage = FALSE;
                        break;
                    }

                    Count -= 1;
                    CurrentByte += 1;
                }

                //
                //  If the page is valid then check if the user's Usn is at this point.  It is
                //  legal for him to specify the point where the zeroes begin.
                //

                if (ValidPage &&
                    !(*ValidUserStartUsn) &&
                    (*NextUsn == *UserStartUsn)) {

                    *ValidUserStartUsn = TRUE;
                }
            }

            break;
        }

        //
        //  Invalid if record length is not-quad aligned or is larger than
        //  remaining bytes on the page.
        //

        if (FlagOn( RecordLength, sizeof( ULONGLONG ) - 1 ) ||
            (RecordLength > RemainingPageBytes)) {

            ValidPage = FALSE;
            break;
        }

        //
        //  Now check that the Usn is the expected value.
        //

        if (UsnRecord->Usn != *NextUsn) {

            ValidPage = FALSE;
            break;
        }

        //
        //  Remember that we found a valid entry.
        //

        FoundEntry = TRUE;

        //
        //  If the user's Usn matches this one then remember his is valid.
        //

        if (!(*ValidUserStartUsn) &&
            (*NextUsn == *UserStartUsn)) {

            *ValidUserStartUsn = TRUE;
        }

        //
        //  Advance to the next record in the page.
        //

        UsnRecord = Add2Ptr( UsnRecord, RecordLength );

        RemainingPageBytes -= RecordLength;
        *NextUsn += RecordLength;
    }

    return ValidPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\strucsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    StrucSup.c


Abstract:

    This module implements the Ntfs in-memory data structure manipulation
    routines

Author:

    Gary Kimura     [GaryKi]        21-May-1991
    Tom Miller      [TomM]          9-Sep-1991

Revision History:

--*/

#include "NtfsProc.h"
#include "lockorder.h"

//
//  Temporarily reference our local attribute definitions
//

extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_STRUCSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('sFtN')

//
//  Define a structure to use when renaming or moving Lcb's so that
//  all the allocation for new filenames will succeed before munging names.
//  This new allocation can be for the filename attribute in an Lcb or the
//  filename in a Ccb.
//

typedef struct _NEW_FILENAME {

    //
    //  Ntfs structure which needs the allocation.
    //

    PVOID Structure;
    PVOID NewAllocation;

} NEW_FILENAME;
typedef NEW_FILENAME *PNEW_FILENAME;


//
//  Local support routines
//

VOID
NtfsCheckScbForCache (
    IN OUT PSCB Scb
    );

BOOLEAN
NtfsRemoveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN CheckForAttributeTable
    );

BOOLEAN
NtfsPrepareFcbForRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB StartingScb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable
    );

VOID
NtfsTeardownFromLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB StartingFcb,
    IN PLCB StartingLcb,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedStartingLcb,
    OUT PBOOLEAN RemovedStartingFcb
    );

VOID
NtfsReserveCcbNamesInLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PULONG ParentNameLength OPTIONAL,
    IN ULONG LastComponentNameLength
    );

VOID
NtfsClearRecursiveLcb (
    IN PLCB Lcb
    );


//
//  The following local routines are for manipulating the Fcb Table.
//  The first three are generic table calls backs.
//

RTL_GENERIC_COMPARE_RESULTS
NtfsFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    );

//
//  VOID
//  NtfsInsertFcbTableEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN FILE_REFERENCE FileReference
//      );
//

#if (DBG || defined( NTFS_FREE_ASSERTS ))
#define NtfsInsertFcbTableEntry(IC,V,F,FR) {                            \
    FCB_TABLE_ELEMENT _Key;                                             \
    PFCB_TABLE_ELEMENT _NewKey;                                         \
    _Key.FileReference = (FR);                                          \
    _Key.Fcb = (F);                                                     \
    _NewKey = RtlInsertElementGenericTable( &(V)->FcbTable,             \
                                            &_Key,                      \
                                            sizeof(FCB_TABLE_ELEMENT),  \
                                            NULL );                     \
    ASSERT( _NewKey->Fcb == _Key.Fcb );                                 \
}
#else
#define NtfsInsertFcbTableEntry(IC,V,F,FR) {                        \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.FileReference = (FR);                                      \
    _Key.Fcb = (F);                                                 \
    (VOID) RtlInsertElementGenericTable( &(V)->FcbTable,            \
                                         &_Key,                     \
                                         sizeof(FCB_TABLE_ELEMENT), \
                                         NULL );                    \
}
#endif

//
//  VOID
//  NtfsInsertFcbTableEntryFull (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN FILE_REFERENCE FileReference,
//      IN PVOID NodeOrParent,
//      IN ULONG SearchResult
//      );
//

#if (DBG || defined( NTFS_FREE_ASSERTS ))
#define NtfsInsertFcbTableEntryFull(IC,V,F,FR,N,SR) {                       \
    FCB_TABLE_ELEMENT _Key;                                                 \
    PFCB_TABLE_ELEMENT _NewKey;                                             \
    _Key.FileReference = (FR);                                              \
    _Key.Fcb = (F);                                                         \
    _NewKey = RtlInsertElementGenericTableFull( &(V)->FcbTable,             \
                                                &_Key,                      \
                                                sizeof(FCB_TABLE_ELEMENT),  \
                                                NULL,                       \
                                                (N),                        \
                                                (SR)                        \
                                                );                          \
    ASSERT( _NewKey->Fcb == _Key.Fcb );                                     \
}
#else
#define NtfsInsertFcbTableEntryFull(IC,V,F,FR,N,SR) {                   \
    FCB_TABLE_ELEMENT _Key;                                             \
    _Key.FileReference = (FR);                                          \
    _Key.Fcb = (F);                                                     \
    (VOID) RtlInsertElementGenericTableFull( &(V)->FcbTable,            \
                                             &_Key,                     \
                                             sizeof(FCB_TABLE_ELEMENT), \
                                             NULL,                      \
                                             (N),                       \
                                             (SR)                       \
                                             );                         \
}
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAllocateCompressionSync)
#pragma alloc_text(PAGE, NtfsBuildNormalizedName)
#pragma alloc_text(PAGE, NtfsBuildRelativeName)
#pragma alloc_text(PAGE, NtfsCheckScbForCache)
#pragma alloc_text(PAGE, NtfsClearRecursiveLcb)
#pragma alloc_text(PAGE, NtfsCombineLcbs)
#pragma alloc_text(PAGE, NtfsCreateCcb)
#pragma alloc_text(PAGE, NtfsCreateFcb)
#pragma alloc_text(PAGE, NtfsCreateFileLock)
#pragma alloc_text(PAGE, NtfsCreateLcb)
#pragma alloc_text(PAGE, NtfsCreatePrerestartScb)
#pragma alloc_text(PAGE, NtfsCreateRootFcb)
#pragma alloc_text(PAGE, NtfsCreateScb)
#pragma alloc_text(PAGE, NtfsDeallocateCompressionSync)
#pragma alloc_text(PAGE, NtfsDeleteCcb)
#pragma alloc_text(PAGE, NtfsDeleteFcb)
#pragma alloc_text(PAGE, NtfsDeleteLcb)
#pragma alloc_text(PAGE, NtfsDeleteNormalizedName)
#pragma alloc_text(PAGE, NtfsDeleteScb)
#pragma alloc_text(PAGE, NtfsDeleteVcb)
#pragma alloc_text(PAGE, NtfsFcbTableCompare)
#pragma alloc_text(PAGE, NtfsGetDeallocatedClusters)
#pragma alloc_text(PAGE, NtfsGetNextFcbTableEntry)
#pragma alloc_text(PAGE, NtfsGetNextScb)
#pragma alloc_text(PAGE, NtfsInitializeVcb)
#pragma alloc_text(PAGE, NtfsLookupLcbByFlags)
#pragma alloc_text(PAGE, NtfsMoveLcb)
#pragma alloc_text(PAGE, NtfsPostToNewLengthQueue)
#pragma alloc_text(PAGE, NtfsProcessNewLengthQueue)
#pragma alloc_text(PAGE, NtfsRemoveScb)
#pragma alloc_text(PAGE, NtfsRenameLcb)
#pragma alloc_text(PAGE, NtfsReserveCcbNamesInLcb)
#pragma alloc_text(PAGE, NtfsTeardownStructures)
#pragma alloc_text(PAGE, NtfsTestStatusProc)
#pragma alloc_text(PAGE, NtfsUpdateNormalizedName)
#pragma alloc_text(PAGE, NtfsUpdateScbSnapshots)
#pragma alloc_text(PAGE, NtfsWalkUpTree)
#endif


VOID
NtfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG NumberProcessors;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeVcb, Vcb = %08lx\n", Vcb) );

    //
    //  First zero out the Vcb
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    //  Set the node type code and size
    //

    Vcb->NodeTypeCode = NTFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof(VCB);

    //
    //  Set the following Vcb flags before putting the Vcb in the
    //  Vcb queue.  This will lock out checkpoints until the
    //  volume is mounted.
    //

    SetFlag( Vcb->CheckpointFlags,
             VCB_CHECKPOINT_IN_PROGRESS |
             VCB_LAST_CHECKPOINT_CLEAN);

    //
    //  Insert this vcb record into the vcb queue off of the global data
    //  record
    //

    InsertTailList( &NtfsData.VcbQueue, &Vcb->VcbLinks );

    //
    //  Set the target device object and vpb fields
    //

    ObReferenceObject( TargetDeviceObject );
    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Set the state and condition fields.  The removable media flag
    //  is set based on the real device's characteristics.
    //

    if (FlagOn(Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA)) {

        SetFlag( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA );
    }

    SetFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

    //
    //  Initialized the ModifiedOpenFilesListhead and the delete notify queue.
    //

    InitializeListHead( &Vcb->NotifyUsnDeleteIrps );
    InitializeListHead( &Vcb->ModifiedOpenFiles );
    InitializeListHead( &Vcb->TimeOutListA );
    InitializeListHead( &Vcb->TimeOutListB );

    Vcb->CurrentTimeOutFiles = &Vcb->TimeOutListA;
    Vcb->AgedTimeOutFiles = &Vcb->TimeOutListB;

    //
    //  Initialize list of OpenAttribute structures.
    //

    InitializeListHead( &Vcb->OpenAttributeData );

    //
    //  Initialize list of deallocated clusters
    //

    InitializeListHead( &Vcb->DeallocatedClusterListHead );

    //
    //  Initialize the synchronization objects in the Vcb.
    //

    ExInitializeResourceLite( &Vcb->Resource );
    ExInitializeResourceLite( &Vcb->MftFlushResource );

    ExInitializeFastMutex( &Vcb->FcbTableMutex );
    ExInitializeFastMutex( &Vcb->FcbSecurityMutex );
    ExInitializeFastMutex( &Vcb->ReservedClustersMutex );
    ExInitializeFastMutex( &Vcb->HashTableMutex );
    ExInitializeFastMutex( &Vcb->CheckpointMutex );

    KeInitializeEvent( &Vcb->CheckpointNotifyEvent, NotificationEvent, TRUE );

    //
    //  Initialize the Fcb Table
    //

    RtlInitializeGenericTable( &Vcb->FcbTable,
                               NtfsFcbTableCompare,
                               NtfsAllocateFcbTableEntry,
                               NtfsFreeFcbTableEntry,
                               NULL );

    //
    //  Initialize the property tunneling structure
    //

    FsRtlInitializeTunnelCache(&Vcb->Tunnel);


#ifdef BENL_DBG
    InitializeListHead( &(Vcb->RestartRedoHead) );
    InitializeListHead( &(Vcb->RestartUndoHead) );
#endif

    //
    //  Possible calls that might fail begins here
    //

    //
    //  Initialize the list head and mutex for the dir notify Irps.
    //  Also the rename resource.
    //

    InitializeListHead( &Vcb->DirNotifyList );
    InitializeListHead( &Vcb->ViewIndexNotifyList );
    FsRtlNotifyInitializeSync( &Vcb->NotifySync );

    //
    //  Allocate and initialize struct array for performance data.  This
    //  attempt to allocate could raise STATUS_INSUFFICIENT_RESOURCES.
    //

    NumberProcessors = KeNumberProcessors;
    Vcb->Statistics = NtfsAllocatePool( NonPagedPool,
                                         sizeof(FILE_SYSTEM_STATISTICS) * NumberProcessors );

    RtlZeroMemory( Vcb->Statistics, sizeof(FILE_SYSTEM_STATISTICS) * NumberProcessors );

    for (i = 0; i < NumberProcessors; i += 1) {
        Vcb->Statistics[i].Common.FileSystemType = FILESYSTEM_STATISTICS_TYPE_NTFS;
        Vcb->Statistics[i].Common.Version = 1;
        Vcb->Statistics[i].Common.SizeOfCompleteStructure =
            sizeof(FILE_SYSTEM_STATISTICS);
    }

    //
    //  Initialize the cached runs.
    //

    NtfsInitializeCachedRuns( &Vcb->CachedRuns );

    //
    //  Initialize the hash table.
    //

    NtfsInitializeHashTable( &Vcb->HashTable );

    //
    //  Allocate a spare Vpb for the dismount case.
    //

    Vcb->SpareVpb = NtfsAllocatePoolWithTag( NonPagedPool, sizeof( VPB ), 'VftN' );

    //
    //  Capture the current change count in the device we talk to.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA )) {

        ULONG ChangeCount = 0;

        NtfsDeviceIoControlAsync( IrpContext,
                                  Vcb->TargetDeviceObject,
                                  IOCTL_DISK_CHECK_VERIFY,
                                  (PVOID) &ChangeCount,
                                  sizeof( ChangeCount ));

        //
        //  Ignore any error for now.  We will see it later if there is
        //  one.
        //

        Vcb->DeviceChangeCount = ChangeCount;
    }

    //
    //  Set the dirty page table hint to its initial value
    //

    Vcb->DirtyPageTableSizeHint = INITIAL_DIRTY_TABLE_HINT;

    //
    //  Initialize the recently deallocated cluster mcbs and put the 1st one on the list.
    //

    FsRtlInitializeLargeMcb( &Vcb->DeallocatedClusters1.Mcb, PagedPool );
    FsRtlInitializeLargeMcb( &Vcb->DeallocatedClusters2.Mcb, PagedPool );

    Vcb->DeallocatedClusters1.Lsn.QuadPart = 0;
    InsertHeadList( &Vcb->DeallocatedClusterListHead, &Vcb->DeallocatedClusters1.Link );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsInitializeVcb -> VOID\n") );

    return;
}


BOOLEAN
NtfsDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB *Vcb
    )

/*++

Routine Description:

    This routine removes the Vcb record from Ntfs's in-memory data
    structures.

Arguments:

    Vcb - Supplies the Vcb to be removed

Return Value:

    BOOLEAN - TRUE if the Vcb was deleted, FALSE otherwise.

--*/

{
    PVOLUME_DEVICE_OBJECT VolDo;
    BOOLEAN AcquiredFcb;
    PSCB Scb;
    PFCB Fcb;
    BOOLEAN VcbDeleted = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( *Vcb );

    ASSERTMSG("Cannot delete Vcb ", !FlagOn((*Vcb)->VcbState, VCB_STATE_VOLUME_MOUNTED));

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteVcb, *Vcb = %08lx\n", *Vcb) );

    //
    //  Remember the volume device object.
    //

    VolDo = CONTAINING_RECORD( *Vcb, VOLUME_DEVICE_OBJECT, Vcb );

    //
    //  Make sure that we can really delete the vcb
    //

    ASSERT( (*Vcb)->CloseCount == 0 );

    NtOfsPurgeSecurityCache( *Vcb );

    //
    //  If the Vcb log file object is present then we need to
    //  dereference it and uninitialize it through the cache.
    //

    if (((*Vcb)->LogFileObject != NULL) &&
        !FlagOn( (*Vcb)->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE )) {

        CcUninitializeCacheMap( (*Vcb)->LogFileObject,
                                &Li0,
                                NULL );

        //
        //  Set a flag indicating that we are dereferencing the LogFileObject.
        //

        SetFlag( (*Vcb)->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE );
        ObDereferenceObject( (*Vcb)->LogFileObject );
    }

    //
    //  Only proceed if the log file object went away.  In the typical case the
    //  close will come in through a recursive call from the ObDereference call
    //  above.
    //

    if ((*Vcb)->LogFileObject == NULL) {

        //
        //  If the OnDiskOat is not the same as the embedded table then
        //  free the OnDisk table.
        //

        if (((*Vcb)->OnDiskOat != NULL) &&
            ((*Vcb)->OnDiskOat != &(*Vcb)->OpenAttributeTable)) {

            NtfsFreeRestartTable( (*Vcb)->OnDiskOat );
            NtfsFreePool( (*Vcb)->OnDiskOat );
            (*Vcb)->OnDiskOat = NULL;
        }

        //
        //  Uninitialize the Mcb's for the deallocated cluster Mcb's.
        //

        if ((*Vcb)->DeallocatedClusters1.Link.Flink == NULL) {
            FsRtlUninitializeLargeMcb( &(*Vcb)->DeallocatedClusters1.Mcb );
        }
        if ((*Vcb)->DeallocatedClusters2.Link.Flink == NULL) {
            FsRtlUninitializeLargeMcb( &(*Vcb)->DeallocatedClusters2.Mcb );
        }

        while (!IsListEmpty(&(*Vcb)->DeallocatedClusterListHead )) {

            PDEALLOCATED_CLUSTERS Clusters;

            Clusters = (PDEALLOCATED_CLUSTERS) RemoveHeadList( &(*Vcb)->DeallocatedClusterListHead );
            FsRtlUninitializeLargeMcb( &Clusters->Mcb );
            if ((Clusters != &((*Vcb)->DeallocatedClusters2)) &&
                (Clusters != &((*Vcb)->DeallocatedClusters1))) {

                NtfsFreePool( Clusters );
            }
        }

        //
        //  Clean up the Root Lcb if present.
        //

        if ((*Vcb)->RootLcb != NULL) {

            //
            //  Cleanup the Lcb so the DeleteLcb routine won't look at any
            //  other structures.
            //

            InitializeListHead( &(*Vcb)->RootLcb->ScbLinks );
            InitializeListHead( &(*Vcb)->RootLcb->FcbLinks );
            ClearFlag( (*Vcb)->RootLcb->LcbState,
                       LCB_STATE_EXACT_CASE_IN_TREE | LCB_STATE_IGNORE_CASE_IN_TREE );

            NtfsDeleteLcb( IrpContext, &(*Vcb)->RootLcb );
            (*Vcb)->RootLcb = NULL;
        }

        //
        //  Make sure the Fcb table is completely emptied.  It is possible that an occasional Fcb
        //  (along with its Scb) will not be deleted when the file object closes come in.
        //

        while (TRUE) {

            PVOID RestartKey;

            //
            //  Always reinitialize the search so we get the first element in the tree.
            //

            RestartKey = NULL;
            NtfsAcquireFcbTable( IrpContext, *Vcb );
            Fcb = NtfsGetNextFcbTableEntry( *Vcb, &RestartKey );
            NtfsReleaseFcbTable( IrpContext, *Vcb );

            if (Fcb == NULL) { break; }

            while ((Scb = NtfsGetNextChildScb( Fcb, NULL )) != NULL) {

                NtfsDeleteScb( IrpContext, &Scb );
            }

            NtfsAcquireFcbTable( IrpContext, *Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcb );
        }

        //
        //  Free the upcase table and attribute definitions.  The upcase
        //  table only gets freed if it is not the global table.
        //

        if (((*Vcb)->UpcaseTable != NULL) && ((*Vcb)->UpcaseTable != NtfsData.UpcaseTable)) {

            NtfsFreePool( (*Vcb)->UpcaseTable );
        }

        (*Vcb)->UpcaseTable = NULL;

        if (((*Vcb)->AttributeDefinitions != NULL) &&
            ((*Vcb)->AttributeDefinitions != NtfsAttributeDefinitions)) {

            NtfsFreePool( (*Vcb)->AttributeDefinitions );
            (*Vcb)->AttributeDefinitions = NULL;
        }

        //
        //  Free the device name string if present.
        //

        if ((*Vcb)->DeviceName.Buffer != NULL) {

            NtfsFreePool( (*Vcb)->DeviceName.Buffer );
            (*Vcb)->DeviceName.Buffer = NULL;
        }

        FsRtlNotifyUninitializeSync( &(*Vcb)->NotifySync );

        //
        //  We will free the structure allocated for the Lfs handle.
        //

        LfsDeleteLogHandle( (*Vcb)->LogHandle );
        (*Vcb)->LogHandle = NULL;

        //
        //  Delete the vcb resource and also free the restart tables
        //

        //
        //  Empty the list of OpenAttribute Data.
        //

        NtfsFreeAllOpenAttributeData( *Vcb );

        NtfsFreeRestartTable( &(*Vcb)->OpenAttributeTable );
        NtfsFreeRestartTable( &(*Vcb)->TransactionTable );

        //
        //  The Vpb in the Vcb may be a temporary Vpb and we should free it here.
        //

        if (FlagOn( (*Vcb)->VcbState, VCB_STATE_TEMP_VPB )) {

            NtfsFreePool( (*Vcb)->Vpb );
            (*Vcb)->Vpb = NULL;
        }

        //
        //  Uninitialize the hash table.
        //

        NtfsUninitializeHashTable( &(*Vcb)->HashTable );

        ExDeleteResourceLite( &(*Vcb)->Resource );
        ExDeleteResourceLite( &(*Vcb)->MftFlushResource );

        //
        //  Delete the space used to store performance counters.
        //

        if ((*Vcb)->Statistics != NULL) {
            NtfsFreePool( (*Vcb)->Statistics );
            (*Vcb)->Statistics = NULL;
        }

        //
        //  Tear down the file property tunneling structure
        //

        FsRtlDeleteTunnelCache(&(*Vcb)->Tunnel);

#ifdef NTFS_CHECK_BITMAP
        if ((*Vcb)->BitmapCopy != NULL) {

            ULONG Count = 0;

            while (Count < (*Vcb)->BitmapPages) {

                if (((*Vcb)->BitmapCopy + Count)->Buffer != NULL) {

                    NtfsFreePool( ((*Vcb)->BitmapCopy + Count)->Buffer );
                }

                Count += 1;
            }

            NtfsFreePool( (*Vcb)->BitmapCopy );
            (*Vcb)->BitmapCopy = NULL;
        }
#endif

        //
        // Drop the reference on the target device object
        //

        ObDereferenceObject( (*Vcb)->TargetDeviceObject );

        //
        //  Check that the Usn queues are empty.
        //

        ASSERT( IsListEmpty( &(*Vcb)->NotifyUsnDeleteIrps ));
        ASSERT( IsListEmpty( &(*Vcb)->ModifiedOpenFiles ));
        ASSERT( IsListEmpty( &(*Vcb)->TimeOutListA ));
        ASSERT( IsListEmpty( &(*Vcb)->TimeOutListB ));

        //
        //  Unnitialize the cached runs.
        //

        NtfsUninitializeCachedRuns( &(*Vcb)->CachedRuns );

        //
        //  Free any spare Vpb we might have stored in the Vcb.
        //

        if ((*Vcb)->SpareVpb != NULL) {

            NtfsFreePool( (*Vcb)->SpareVpb );
            (*Vcb)->SpareVpb = NULL;
        }

        //
        //  Return the Vcb (i.e., the VolumeDeviceObject) to pool and null out
        //  the input pointer to be safe
        //

        IoDeleteDevice( (PDEVICE_OBJECT)VolDo );

        *Vcb = NULL;
        VcbDeleted = TRUE;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteVcb -> VOID\n") );

    return VcbDeleted;
}


PFCB
NtfsCreateRootFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root FCB record
    into the in memory data structure.  It also creates the necessary Root LCB
    record and inserts the root name into the prefix table.

Arguments:

    Vcb - Supplies the Vcb to associate with the new root Fcb and Lcb

Return Value:

    PFCB - returns pointer to the newly allocated root FCB.

--*/

{
    PFCB RootFcb;
    PLCB RootLcb;

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage = NULL;
    PERESOURCE UnwindResource = NULL;
    PFAST_MUTEX UnwindFastMutex = NULL;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace( +1, Dbg, ("NtfsCreateRootFcb, Vcb = %08lx\n", Vcb) );

    try {

        //
        //  Allocate a new fcb and zero it out.  We use Fcb locally so we
        //  don't have to continually go through the Vcb
        //

        RootFcb =
        UnwindStorage = (PFCB)ExAllocateFromPagedLookasideList( &NtfsFcbIndexLookasideList );

        RtlZeroMemory( RootFcb, sizeof(FCB_INDEX) );

        //
        //  Set the proper node type code and byte size
        //

        RootFcb->NodeTypeCode = NTFS_NTC_FCB;
        RootFcb->NodeByteSize = sizeof(FCB);

        SetFlag( RootFcb->FcbState, FCB_STATE_COMPOUND_INDEX );

        //
        //  Initialize the Lcb queue and point back to our Vcb.
        //

        InitializeListHead( &RootFcb->LcbQueue );

        RootFcb->Vcb = Vcb;

        //
        //  File Reference
        //

        NtfsSetSegmentNumber( &RootFcb->FileReference,
                              0,
                              ROOT_FILE_NAME_INDEX_NUMBER );
        RootFcb->FileReference.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

        //
        //  Initialize the Scb
        //

        InitializeListHead( &RootFcb->ScbQueue );

        //
        //  Allocate and initialize the resource variable
        //

        UnwindResource = RootFcb->Resource = NtfsAllocateEresource();

        //
        //  Allocate and initialize the Fcb fast mutex.
        //

        UnwindFastMutex =
        RootFcb->FcbMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
        ExInitializeFastMutex( UnwindFastMutex );

        //
        //  Insert this new fcb into the fcb table
        //

        NtfsInsertFcbTableEntry( IrpContext, Vcb, RootFcb, RootFcb->FileReference );
        SetFlag( RootFcb->FcbState, FCB_STATE_IN_FCB_TABLE );

        //
        //  Now insert this new root fcb into it proper position in the graph with a
        //  root lcb.  First allocate an initialize the root lcb and then build the
        //  lcb/scb graph.
        //

        {
            //
            //  Use the root Lcb within the Fcb.
            //

            RootLcb = Vcb->RootLcb = (PLCB) &((PFCB_INDEX) RootFcb)->Lcb;

            RootLcb->NodeTypeCode = NTFS_NTC_LCB;
            RootLcb->NodeByteSize = sizeof(LCB);

            //
            //  Insert the root lcb into the Root Fcb's queue
            //

            InsertTailList( &RootFcb->LcbQueue, &RootLcb->FcbLinks );
            RootLcb->Fcb = RootFcb;

            //
            //  Use the embedded file name attribute.
            //

            RootLcb->FileNameAttr = (PFILE_NAME) &RootLcb->ParentDirectory;

            RootLcb->FileNameAttr->ParentDirectory = RootFcb->FileReference;
            RootLcb->FileNameAttr->FileNameLength = 1;
            RootLcb->FileNameAttr->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

            RootLcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &RootLcb->FileNameAttr->FileName;

            RootLcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( RootLcb->FileNameAttr,
                                                               NtfsFileNameSizeFromLength( 2 ));

            RootLcb->ExactCaseLink.LinkName.MaximumLength =
            RootLcb->ExactCaseLink.LinkName.Length =
            RootLcb->IgnoreCaseLink.LinkName.MaximumLength =
            RootLcb->IgnoreCaseLink.LinkName.Length = 2;

            RootLcb->ExactCaseLink.LinkName.Buffer[0] =
            RootLcb->IgnoreCaseLink.LinkName.Buffer[0] = L'\\';

            SetFlag( RootLcb->FileNameAttr->Flags, FILE_NAME_NTFS | FILE_NAME_DOS );

            //
            //  Initialize both the ccb.
            //

            InitializeListHead( &RootLcb->CcbQueue );
        }

    } finally {

        DebugUnwind( NtfsCreateRootFcb );

        if (AbnormalTermination()) {

            if (UnwindResource)   { NtfsFreeEresource( UnwindResource ); }
            if (UnwindStorage) { NtfsFreePool( UnwindStorage ); }
            if (UnwindFastMutex) { NtfsFreePool( UnwindFastMutex ); }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateRootFcb -> %8lx\n", RootFcb) );

    return RootFcb;
}


PFCB
NtfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_REFERENCE FileReference,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN LargeFcb,
    OUT PBOOLEAN ReturnedExistingFcb OPTIONAL
    )

/*++

Routine Description:

    This routine allocates and initializes a new Fcb record. The record
    is not placed within the Fcb/Scb graph but is only inserted in the
    FcbTable.

Arguments:

    Vcb - Supplies the Vcb to associate the new FCB under.

    FileReference - Supplies the file reference to use to identify the
        Fcb with.  We will search the Fcb table for any preexisting
        Fcb's with the same file reference number.

    IsPagingFile - Indicates if we are creating an FCB for a paging file
        or some other type of file.

    LargeFcb - Indicates if we should use the larger of the compound Fcb's.

    ReturnedExistingFcb - Optionally indicates to the caller if the
        returned Fcb already existed

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Entry;

    PFCB Fcb;

    PVOID NodeOrParent;
    TABLE_SEARCH_RESULT SearchResult;

    BOOLEAN LocalReturnedExistingFcb;
    BOOLEAN DeletedOldFcb = FALSE;

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage = NULL;
    PERESOURCE UnwindResource = NULL;
    PFAST_MUTEX UnwindFastMutex = NULL;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_SHARED_RESOURCE( &Vcb->Resource );

    DebugTrace( +1, Dbg, ("NtfsCreateFcb\n") );

    if (!ARGUMENT_PRESENT(ReturnedExistingFcb)) { ReturnedExistingFcb = &LocalReturnedExistingFcb; }

    //
    //  First search the FcbTable for a matching fcb
    //

    Key.FileReference = FileReference;
    Fcb = NULL;

    if ((Entry = RtlLookupElementGenericTableFull( &Vcb->FcbTable, &Key, &NodeOrParent, &SearchResult )) != NULL) {

        Fcb = Entry->Fcb;

        //
        //  It's possible that this Fcb has been deleted but in truncating and
        //  growing the Mft we are reusing some of the file references.
        //  If this file has been deleted but the Fcb is waiting around for
        //  closes, we will remove it from the Fcb table and create a new Fcb
        //  below.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

            //
            //  Remove it from the Fcb table and remember to create an
            //  Fcb below.
            //

            NtfsDeleteFcbTableEntry( Fcb->Vcb,
                                     Fcb->FileReference );

            ClearFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );
            DeletedOldFcb = TRUE;
            Fcb = NULL;

        } else {

            *ReturnedExistingFcb = TRUE;
        }
    }

    //
    //  Now check if we have an Fcb.
    //

    if (Fcb == NULL) {

        *ReturnedExistingFcb = FALSE;

        try {

            //
            //  Allocate a new FCB and zero it out.
            //

            if (IsPagingFile ||
                NtfsSegmentNumber( &FileReference ) <= MASTER_FILE_TABLE2_NUMBER ||
                NtfsSegmentNumber( &FileReference ) == BAD_CLUSTER_FILE_NUMBER ||
                NtfsSegmentNumber( &FileReference ) == BIT_MAP_FILE_NUMBER) {

                Fcb = UnwindStorage = NtfsAllocatePoolWithTag( NonPagedPool,
                                                               sizeof(FCB),
                                                               'fftN' );
                RtlZeroMemory( Fcb, sizeof(FCB) );

                if (IsPagingFile) {

                    //
                    //  We can't have the pagingfile on a readonly volume.
                    //

                    if (NtfsIsVolumeReadOnly( Vcb )) {

                        NtfsFreePool( Fcb );
                        leave;
                    }

                    SetFlag( Fcb->FcbState, FCB_STATE_PAGING_FILE );

                    //
                    //  We don't want to dismount this volume now that
                    //  we have a pagefile open on it.
                    //

                    SetFlag( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT );
                }

                SetFlag( Fcb->FcbState, FCB_STATE_NONPAGED );

            } else {

                if (LargeFcb) {

                    Fcb = UnwindStorage =
                        (PFCB)ExAllocateFromPagedLookasideList( &NtfsFcbIndexLookasideList );

                    RtlZeroMemory( Fcb, sizeof( FCB_INDEX ));
                    SetFlag( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX );

                } else {

                    Fcb = UnwindStorage =
                        (PFCB)ExAllocateFromPagedLookasideList( &NtfsFcbDataLookasideList );

                    RtlZeroMemory( Fcb, sizeof( FCB_DATA ));
                    SetFlag( Fcb->FcbState, FCB_STATE_COMPOUND_DATA );
                }
            }

            //
            //  Set the proper node type code and byte size
            //

            Fcb->NodeTypeCode = NTFS_NTC_FCB;
            Fcb->NodeByteSize = sizeof(FCB);

            //
            //  Initialize the Lcb queue and point back to our Vcb, and indicate
            //  that we are a directory
            //

            InitializeListHead( &Fcb->LcbQueue );

            Fcb->Vcb = Vcb;

            //
            //  File Reference
            //

            Fcb->FileReference = FileReference;

            //
            //  Initialize the Scb
            //

            InitializeListHead( &Fcb->ScbQueue );

            //
            //  Allocate and initialize the resource variable
            //

            UnwindResource = Fcb->Resource = NtfsAllocateEresource();

            //
            //  Allocate and initialize fast mutex for the Fcb.
            //

            UnwindFastMutex = Fcb->FcbMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
            ExInitializeFastMutex( UnwindFastMutex );

            //
            //  Insert this new fcb into the fcb table. We have to use the basic
            //  version of this function when we deleted an old fcb because the "smarter" one
            //  will just return back the old entry rather than researching
            //

            if (DeletedOldFcb) {
                NtfsInsertFcbTableEntry( IrpContext, Vcb, Fcb, FileReference );
            } else {
                NtfsInsertFcbTableEntryFull( IrpContext, Vcb, Fcb, FileReference, NodeOrParent, SearchResult );
            }


            SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );

            //
            //  Set the flag to indicate if this is a system file.
            //

            if (NtfsSegmentNumber( &FileReference ) < FIRST_USER_FILE_NUMBER) {

                SetFlag( Fcb->FcbState, FCB_STATE_SYSTEM_FILE );
            }

        } finally {

            DebugUnwind( NtfsCreateFcb );

            if (AbnormalTermination()) {

                if (UnwindFastMutex) { NtfsFreePool( UnwindFastMutex ); }
                if (UnwindResource)   { NtfsFreeEresource( UnwindResource ); }
                if (UnwindStorage) { NtfsFreePool( UnwindStorage ); }
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateFcb -> %08lx\n", Fcb) );

    return Fcb;
}


VOID
NtfsDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *Fcb,
    OUT PBOOLEAN AcquiredFcbTable
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB record from all Ntfs's in-memory
    data structures.  It assumes that it does not have anything Scb children nor
    does it have any lcb edges going into it at the time of the call.

Arguments:

    Fcb - Supplies the FCB to be removed

    AcquiredFcbTable - Set to FALSE when this routine releases the
        FcbTable.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( *Fcb );
    ASSERT( IsListEmpty(&(*Fcb)->ScbQueue) );
    ASSERT( (NodeType(*Fcb) == NTFS_NTC_FCB) );

    DebugTrace( +1, Dbg, ("NtfsDeleteFcb, *Fcb = %08lx\n", *Fcb) );

    //
    //  First free any possible Scb snapshots.
    //

    NtfsFreeSnapshotsForFcb( IrpContext, *Fcb );

    //
    //  This Fcb may be in the ExclusiveFcb list of the IrpContext.
    //  If it is (The Flink is not NULL), we remove it.
    //  And release the global resource.
    //

    if ((*Fcb)->ExclusiveFcbLinks.Flink != NULL) {

        RemoveEntryList( &(*Fcb)->ExclusiveFcbLinks );
    }

    //
    //  Clear the IrpContext field for any request which may own the paging
    //  IO resource for this Fcb.
    //

    if (IrpContext->CleanupStructure == *Fcb) {

        IrpContext->CleanupStructure = NULL;

    } else if (IrpContext->TopLevelIrpContext->CleanupStructure == *Fcb) {

        IrpContext->TopLevelIrpContext->CleanupStructure = NULL;
    }

    //
    //  Either we own the FCB or nobody should own it.  The extra acquire
    //  here does not matter since we will free the resource below.
    //

    ASSERT( NtfsAcquireResourceExclusive( IrpContext, (*Fcb), FALSE ));
    ASSERT( ExGetSharedWaiterCount( (*Fcb)->Resource ) == 0 );
    ASSERT( ExGetExclusiveWaiterCount( (*Fcb)->Resource) == 0 );

#ifdef NTFSDBG

    //
    //  Lock order package needs to know this resource is gone
    //

    if (IrpContext->Vcb && FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
        NtfsChangeResourceOrderState( IrpContext, NtfsIdentifyFcb( IrpContext->Vcb, *Fcb ), TRUE, FALSE );
    }
#endif

    //
    //  Deallocate the resources protecting the Fcb
    //

    NtfsFreeEresource( (*Fcb)->Resource );

    if ( (*Fcb)->PagingIoResource != NULL ) {

        if (IrpContext->CleanupStructure == *Fcb) {
            IrpContext->CleanupStructure = NULL;
        }

        NtfsFreeEresource( (*Fcb)->PagingIoResource );
    }

    //
    //  Deallocate the fast mutex.
    //

    if ((*Fcb)->FcbMutex != NULL) {

        NtfsFreePool( (*Fcb)->FcbMutex );
    }

    //
    //  Remove the fcb from the fcb table if present.
    //

    if (FlagOn( (*Fcb)->FcbState, FCB_STATE_IN_FCB_TABLE )) {

        NtfsDeleteFcbTableEntry( (*Fcb)->Vcb, (*Fcb)->FileReference );
        ClearFlag( (*Fcb)->FcbState, FCB_STATE_IN_FCB_TABLE );
    }

    NtfsReleaseFcbTable( IrpContext, (*Fcb)->Vcb );
    *AcquiredFcbTable = FALSE;

    //
    //  Dereference and possibly deallocate the security descriptor if present.
    //

    if ((*Fcb)->SharedSecurity != NULL) {

        NtfsAcquireFcbSecurity( (*Fcb)->Vcb );
        RemoveReferenceSharedSecurityUnsafe( &(*Fcb)->SharedSecurity );
        NtfsReleaseFcbSecurity( (*Fcb)->Vcb );
    }

    //
    //  Release the quota control block.
    //

    if (NtfsPerformQuotaOperation( *Fcb )) {
        NtfsDereferenceQuotaControlBlock( (*Fcb)->Vcb, &(*Fcb)->QuotaControl );
    }

    //
    //  Delete the UsnRecord if one exists.
    //

    if ((*Fcb)->FcbUsnRecord != NULL) {

        PUSN_FCB ThisUsn, LastUsn;

        //
        //  See if the Fcb is in one of the Usn blocks.
        //

        ThisUsn = &IrpContext->Usn;

        do {

            if (ThisUsn->CurrentUsnFcb == (*Fcb)) {

                //
                //  Cleanup the UsnFcb in the IrpContext.  It's possible that
                //  we might want to reuse the UsnFcb later in this request.
                //

                if (ThisUsn != &IrpContext->Usn) {

                    LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                    NtfsFreePool( ThisUsn );

                } else {

                    ThisUsn->CurrentUsnFcb = NULL;
                    ThisUsn->NewReasons = 0;
                    ThisUsn->RemovedSourceInfo = 0;
                    ThisUsn->UsnFcbFlags = 0;
                }
                break;
            }

            if (ThisUsn->NextUsnFcb == NULL) { break; }

            LastUsn = ThisUsn;
            ThisUsn = ThisUsn->NextUsnFcb;

        } while (TRUE);

        //
        //  Remove the Fcb from the list in the Usn journal.
        //

        if ((*Fcb)->FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {
            NtfsLockFcb( IrpContext, (*Fcb)->Vcb->UsnJournal->Fcb );
            RemoveEntryList( &(*Fcb)->FcbUsnRecord->ModifiedOpenFilesLinks );

            if ((*Fcb)->FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                RemoveEntryList( &(*Fcb)->FcbUsnRecord->TimeOutLinks );
            }
            NtfsUnlockFcb( IrpContext, (*Fcb)->Vcb->UsnJournal->Fcb );
        }

        NtfsFreePool( (*Fcb)->FcbUsnRecord );
    }

    //
    //  Let our top-level caller know the Fcb was deleted.
    //

    if ((*Fcb)->FcbContext != NULL) {

        (*Fcb)->FcbContext->FcbDeleted = TRUE;
    }

    //
    //  Deallocate the Fcb itself
    //

    if (FlagOn( (*Fcb)->FcbState, FCB_STATE_NONPAGED )) {

        NtfsFreePool( *Fcb );

    } else {

        if (FlagOn( (*Fcb)->FcbState, FCB_STATE_COMPOUND_INDEX )) {

            ExFreeToPagedLookasideList( &NtfsFcbIndexLookasideList, *Fcb );

        } else {

            ExFreeToPagedLookasideList( &NtfsFcbDataLookasideList, *Fcb );
        }
    }

    //
    //  Zero out the input pointer
    //

    *Fcb = NULL;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteFcb -> VOID\n") );

    return;
}


PFCB
NtfsGetNextFcbTableEntry (
    IN PVCB Vcb,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine will enumerate through all of the fcb's for the given
    vcb

Arguments:

    Vcb - Supplies the Vcb used in this operation

    RestartKey - This value is used by the table package to maintain
        its position in the enumeration.  It is initialized to NULL
        for the first search.

Return Value:

    PFCB - A pointer to the next fcb or NULL if the enumeration is
        completed

--*/

{
    PFCB Fcb;

    PAGED_CODE();

    Fcb = (PFCB) RtlEnumerateGenericTableWithoutSplaying( &Vcb->FcbTable, RestartKey );

    if (Fcb != NULL) {

        Fcb = ((PFCB_TABLE_ELEMENT)(Fcb))->Fcb;
    }

    return Fcb;
}


PSCB
NtfsCreateScb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PCUNICODE_STRING AttributeName,
    IN BOOLEAN ReturnExistingOnly,
    OUT PBOOLEAN ReturnedExistingScb OPTIONAL
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Scb record into
    the in memory data structures, provided one does not already exist
    with the identical attribute record.

Arguments:

    Fcb - Supplies the Fcb to associate the new SCB under.

    AttributeTypeCode - Supplies the attribute type code for the new Scb

    AttributeName - Supplies the attribute name for the new Scb, with
        AttributeName->Length == 0 if there is no name.

    ReturnExistingOnly - If specified as TRUE then only an existing Scb
        will be returned.  If no matching Scb exists then NULL is returned.

    ReturnedExistingScb - Indicates if this procedure found an existing
        Scb with the identical attribute record (variable is set to TRUE)
        or if this procedure needed to create a new Scb (variable is set to
        FALSE).

Return Value:

    PSCB - Returns a pointer to the newly allocated SCB or NULL if there is
        no Scb and ReturnExistingOnly is TRUE.

--*/

{
    PSCB Scb;
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    BOOLEAN LocalReturnedExistingScb;
    BOOLEAN PagingIoResource;
    BOOLEAN ModifiedNoWrite;
#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG) || defined(SYSCACHE_DEBUG))
    BOOLEAN SyscacheFile = FALSE;
#endif

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage[4];
    POPLOCK UnwindOplock;
    PNTFS_MCB UnwindMcb;

    PLARGE_MCB UnwindAddedClustersMcb;
    PLARGE_MCB UnwindRemovedClustersMcb;

    BOOLEAN UnwindFromQueue;

    BOOLEAN Nonpaged;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    ASSERT( AttributeTypeCode >= $STANDARD_INFORMATION );

    DebugTrace( +1, Dbg, ("NtfsCreateScb\n") );

    if (!ARGUMENT_PRESENT(ReturnedExistingScb)) { ReturnedExistingScb = &LocalReturnedExistingScb; }

    //
    //  Search the scb queue of the fcb looking for a matching
    //  attribute type code and attribute name
    //

    NtfsLockFcb( IrpContext, Fcb );

    Scb = NULL;
    while ((Scb = NtfsGetNextChildScb( Fcb, Scb )) != NULL) {

        ASSERT_SCB( Scb );

        //
        //  For every scb already in the fcb's queue check for a matching
        //  type code and name.  If we find a match we return from this
        //  procedure right away.
        //

        if ((AttributeTypeCode == Scb->AttributeTypeCode) &&
            !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED) &&
            NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable,
                               &Scb->AttributeName,
                               (PUNICODE_STRING) AttributeName,
                               FALSE )) {

            NtfsUnlockFcb( IrpContext, Fcb );
            *ReturnedExistingScb = TRUE;

            if (NtfsIsExclusiveScb(Scb)) {

                NtfsSnapshotScb( IrpContext, Scb );
            }

            DebugTrace( -1, Dbg, ("NtfsCreateScb -> %08lx\n", Scb) );

            return Scb;
        }
    }

    //
    //  If the user only wanted an existing Scb then return NULL.
    //

    if (ReturnExistingOnly) {

        NtfsUnlockFcb( IrpContext, Fcb );
        DebugTrace( -1, Dbg, ("NtfsCreateScb -> %08lx\n", NULL) );
        return NULL;
    }

    //
    //  We didn't find it so we are not going to be returning an existing Scb
    //  Initialize local variables for later cleanup.
    //

    PagingIoResource = FALSE;
    ModifiedNoWrite = TRUE;
    UnwindOplock = NULL;
    UnwindMcb = NULL;
    UnwindAddedClustersMcb = NULL;
    UnwindRemovedClustersMcb = NULL;
    UnwindFromQueue = FALSE;
    Nonpaged = FALSE;
    UnwindStorage[0] = NULL;
    UnwindStorage[1] = NULL;
    UnwindStorage[2] = NULL;
    UnwindStorage[3] = NULL;

    *ReturnedExistingScb = FALSE;

    try {

        //
        //  Decide the node type and size of the Scb.  Also decide if it will be
        //  allocated from paged or non-paged pool.
        //

        if (AttributeTypeCode == $INDEX_ALLOCATION) {

            if (NtfsSegmentNumber( &Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER) {
                NodeTypeCode = NTFS_NTC_SCB_ROOT_INDEX;
            } else {
                NodeTypeCode = NTFS_NTC_SCB_INDEX;
            }

            NodeByteSize = SIZEOF_SCB_INDEX;

        } else if ((NtfsSegmentNumber( &Fcb->FileReference ) <= MASTER_FILE_TABLE2_NUMBER) &&
                   (AttributeTypeCode == $DATA)) {

            NodeTypeCode = NTFS_NTC_SCB_MFT;
            NodeByteSize = SIZEOF_SCB_MFT;

        } else {

            NodeTypeCode = NTFS_NTC_SCB_DATA;
            NodeByteSize = SIZEOF_SCB_DATA;

            //
            //  If this is a user data stream then remember that we need
            //  a paging IO resource.  Test for the cases where we DONT want
            //  to mark this stream as MODIFIED_NO_WRITE.
            //
            //  If we need a paging IO resource the file must be a data stream.
            //

            if ((AttributeTypeCode == $DATA) ||
                (AttributeTypeCode >= $FIRST_USER_DEFINED_ATTRIBUTE)) {

                //
                //  For Data streams in the Root File or non-system files we need
                //  a paging IO resource and don't want to mark the file as
                //  MODIFIED_NO_WRITE.
                //

                //
                //  We should never reach this point for either the volume bitmap or
                //  volume dasd files.
                //

                ASSERT( (NtfsSegmentNumber( &Fcb->FileReference ) != VOLUME_DASD_NUMBER) &&
                        (NtfsSegmentNumber( &Fcb->FileReference ) != BIT_MAP_FILE_NUMBER) );

                if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                    //
                    //  Make sure that all files in the reserved area are marked as system except
                    //  the root index.
                    //

                    ASSERT( (NtfsSegmentNumber( &Fcb->FileReference ) >= FIRST_USER_FILE_NUMBER) ||
                            (NtfsSegmentNumber( &Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER) );

                    ModifiedNoWrite = FALSE;
                    PagingIoResource = TRUE;
                }

            }
        }

        //
        //  The scb will come from non-paged if the Fcb is non-paged or
        //  it is an attribute list.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_NONPAGED ) || (AttributeTypeCode == $ATTRIBUTE_LIST)) {

            Scb = UnwindStorage[0] = NtfsAllocatePoolWithTag( NonPagedPool, NodeByteSize, 'nftN' );
            Nonpaged = TRUE;

        } else if (AttributeTypeCode == $INDEX_ALLOCATION) {

            //
            //  If the Fcb is an INDEX Fcb and the Scb is unused, then
            //  use that.  Otherwise allocate from the lookaside list.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
                (SafeNodeType( &((PFCB_INDEX) Fcb)->Scb ) == 0)) {

                Scb = (PSCB) &((PFCB_INDEX) Fcb)->Scb;

            } else {

                Scb = UnwindStorage[0] = (PSCB)NtfsAllocatePoolWithTag( PagedPool, SIZEOF_SCB_INDEX, 'SftN' );
            }

#ifdef SYSCACHE_DEBUG
            if (((IrpContext->OriginatingIrp != NULL) &&
                 (FsRtlIsSyscacheFile( IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject )))) {


                KdPrint( ("NTFS: Found syscache dir: fo:0x%x scb:0x%x filref: 0x%x\n",
                          IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject,
                          Scb,
                          NtfsUnsafeSegmentNumber( &Fcb->FileReference )) );
                SyscacheFile = TRUE;
            }
#endif

        } else {

            //
            //  We can use the Scb field in the Fcb in all cases if it is
            //  unused.  We will only use it for a data stream since
            //  it will have the longest life.
            //

            ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) ||
                    FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_DATA ));

            if ((AttributeTypeCode == $DATA) &&
                (SafeNodeType( &((PFCB_INDEX) Fcb)->Scb ) == 0)) {

                Scb = (PSCB) &((PFCB_INDEX) Fcb)->Scb;

            } else {

                Scb = UnwindStorage[0] = (PSCB)ExAllocateFromPagedLookasideList( &NtfsScbDataLookasideList );
            }

#ifdef SYSCACHE_DEBUG
            if (((IrpContext->OriginatingIrp != NULL) &&
                 (FsRtlIsSyscacheFile( IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject )))) {


                KdPrint( ("NTFS: Found syscache file: fo:0x%x scb:0x%x filref: 0x%x\n",
                          IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject,
                          Scb,
                          NtfsUnsafeSegmentNumber( &Fcb->FileReference )) );
                SyscacheFile = TRUE;
            }

            if (!IsListEmpty( &Fcb->LcbQueue )) {
                PLCB Lcb = (PLCB) CONTAINING_RECORD( Fcb->LcbQueue.Flink, LCB, FcbLinks.Flink  );

                while (TRUE) {

                    if ((Lcb->Scb != NULL) &&
                        (FlagOn( Lcb->Scb->ScbPersist, SCB_PERSIST_SYSCACHE_DIR ))) {

                        SyscacheFile = TRUE;
                        KdPrint( ("NTFS: Found syscache file in dir: fo:0x%x scb:0x%x filref: 0x%x\n",
                                  IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject,
                                  Scb,
                                  NtfsUnsafeSegmentNumber( &Fcb->FileReference )) );
                    }

                    if (Lcb->FcbLinks.Flink != &Fcb->LcbQueue) {
                        Lcb = (PLCB)CONTAINING_RECORD( Lcb->FcbLinks.Flink, LCB, FcbLinks.Flink );
                    } else {
                        break;
                    }
                }
            }
#endif

#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG))
            if (( IrpContext->OriginatingIrp != NULL)
                (FsRtlIsSyscacheFile(IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject))) {

                SyscacheFile = TRUE;
            }
#endif
        }

        //
        //  Store the Scb address and zero it out.
        //

        RtlZeroMemory( Scb, NodeByteSize );

#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG))
        if (SyscacheFile) {
            SetFlag( Scb->ScbState, SCB_STATE_SYSCACHE_FILE );
        }
#endif

        //
        //  Set the proper node type code and byte size
        //

        Scb->Header.NodeTypeCode = NodeTypeCode;
        Scb->Header.NodeByteSize = NodeByteSize;

        //
        //  Set a back pointer to the resource we will be using
        //

        Scb->Header.Resource = Fcb->Resource;

        //
        //  Decide if we will be using the PagingIoResource
        //

        if (PagingIoResource) {

            PERESOURCE NewResource;

            //
            //  Initialize it in the Fcb if it is not already there, and
            //  setup the pointer and flag in the Scb.
            //

            if (Fcb->PagingIoResource == NULL) {

                //
                //  If this is a superseding open and our caller wants
                //  to acquire the paging io resource, then do it now.
                //  We could be in a state where there was no paging
                //  IO resource when we acquired the Fcb but will need
                //  it if this transaction needs to be unwound.
                //

                NewResource = NtfsAllocateEresource();

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) &&
                    (IrpContext->MajorFunction == IRP_MJ_CREATE) &&
                    (IrpContext->OriginatingIrp != NULL) &&
                    (IrpContext->CleanupStructure == NULL)) {

                    ExAcquireResourceExclusiveLite( NewResource, TRUE );
                    IrpContext->CleanupStructure = Fcb;
                }

                Fcb->PagingIoResource = NewResource;
            }

            Scb->Header.PagingIoResource = Fcb->PagingIoResource;
        }

        //
        //  Insert this Scb into our parents scb queue, and point back to
        //  our parent fcb and vcb.  Put this entry at the head of the list.
        //  Any Scb on the delayed close queue goes to the end of the list.
        //

        InsertHeadList( &Fcb->ScbQueue, &Scb->FcbLinks );
        UnwindFromQueue = TRUE;

        Scb->Fcb = Fcb;
        Scb->Vcb = Fcb->Vcb;

        //
        //  If the attribute name exists then allocate a buffer for the
        //  attribute name and iniitalize it.
        //

        if (AttributeName->Length != 0) {

            //
            //  The typical case is the $I30 string.  If this matches then
            //  point to a common string.
            //

            if ((AttributeName->Length == NtfsFileNameIndex.Length) &&
                (RtlEqualMemory( AttributeName->Buffer,
                                 NtfsFileNameIndex.Buffer,
                                 AttributeName->Length ) )) {

                Scb->AttributeName = NtfsFileNameIndex;

            } else {

                Scb->AttributeName.Length = AttributeName->Length;
                Scb->AttributeName.MaximumLength = (USHORT)(AttributeName->Length + sizeof( WCHAR ));

                Scb->AttributeName.Buffer = UnwindStorage[1] =
                    NtfsAllocatePool(PagedPool, AttributeName->Length + sizeof( WCHAR ));

                RtlCopyMemory( Scb->AttributeName.Buffer, AttributeName->Buffer, AttributeName->Length );
                Scb->AttributeName.Buffer[AttributeName->Length / sizeof( WCHAR )] = L'\0';
            }
        }

        //
        //  Set the attribute Type Code
        //

        Scb->AttributeTypeCode = AttributeTypeCode;
        if (NtfsIsTypeCodeSubjectToQuota( AttributeTypeCode )){
            SetFlag( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA );
        }

        //
        //  If this is an Mft Scb then initialize the cluster Mcb's.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_MFT) {

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.AddedClusters, NonPagedPool );
            UnwindAddedClustersMcb = &Scb->ScbType.Mft.AddedClusters;

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.RemovedClusters, NonPagedPool );
            UnwindRemovedClustersMcb = &Scb->ScbType.Mft.RemovedClusters;
        }

        //
        //  Get the mutex for the Scb.  We may be able to use the one in the Fcb.
        //  We can if the Scb is paged.
        //

        if (Nonpaged) {

            SetFlag( Scb->ScbState, SCB_STATE_NONPAGED );
            UnwindStorage[3] =
            Scb->Header.FastMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
            ExInitializeFastMutex( Scb->Header.FastMutex );

        } else {

            Scb->Header.FastMutex = Fcb->FcbMutex;
        }

        //
        //  Initialize the FCB advanced header.  Note that the mutex
        //  has already been setup (just above) so we don't re-setitup
        //  here. We will not support filter contexts for paging files
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
            FsRtlSetupAdvancedHeader( &Scb->Header, NULL );
        } else {
            SetFlag( Scb->Header.Flags, FSRTL_FLAG_ADVANCED_HEADER );
        }

        //
        //  Allocate the Nonpaged portion of the Scb.
        //

        Scb->NonpagedScb =
        UnwindStorage[2] = (PSCB_NONPAGED)ExAllocateFromNPagedLookasideList( &NtfsScbNonpagedLookasideList );

        RtlZeroMemory( Scb->NonpagedScb, sizeof( SCB_NONPAGED ));

        Scb->NonpagedScb->NodeTypeCode = NTFS_NTC_SCB_NONPAGED;
        Scb->NonpagedScb->NodeByteSize = sizeof( SCB_NONPAGED );
        Scb->NonpagedScb->Vcb = Scb->Vcb;

        //
        //  Fill in the advanced fields
        //

        Scb->Header.PendingEofAdvances = &Scb->EofListHead;
        InitializeListHead( &Scb->EofListHead );

        NtfsInitializeNtfsMcb( &Scb->Mcb,
                               &Scb->Header,
                               &Scb->McbStructs,
                               FlagOn( Scb->ScbState, SCB_STATE_NONPAGED )
                               ? NonPagedPool : PagedPool);

        UnwindMcb = &Scb->Mcb;

        InitializeListHead( &Scb->CcbQueue );

        //
        //  Do that data stream specific initialization.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_DATA) {

            FsRtlInitializeOplock( &Scb->ScbType.Data.Oplock );
            UnwindOplock = &Scb->ScbType.Data.Oplock;
            InitializeListHead( &Scb->ScbType.Data.WaitForNewLength );
            InitializeListHead( &Scb->ScbType.Data.CompressionSyncList );

            //
            //  Set a flag if this is the Usn Journal.
            //

            if (!PagingIoResource &&
                (*((PLONGLONG) &Fcb->Vcb->UsnJournalReference) == *((PLONGLONG) &Fcb->FileReference)) &&
                (AttributeName->Length == JournalStreamName.Length) &&
                RtlEqualMemory( AttributeName->Buffer,
                                JournalStreamName.Buffer,
                                JournalStreamName.Length )) {

                SetFlag( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL );
            }

#ifdef SYSCACHE_DEBUG
            if (SyscacheFile)
            {

                Scb->LogSetNumber = InterlockedIncrement( &NtfsCurrentSyscacheLogSet ) % NUM_SC_LOGSETS;
                NtfsSyscacheLogSet[Scb->LogSetNumber].Scb = Scb;
                NtfsSyscacheLogSet[Scb->LogSetNumber].SegmentNumberUnsafe =
                    NtfsUnsafeSegmentNumber( &Fcb->FileReference );

                if (NtfsSyscacheLogSet[Scb->LogSetNumber].SyscacheLog == NULL) {
                    NtfsSyscacheLogSet[Scb->LogSetNumber].SyscacheLog = NtfsAllocatePoolWithTagNoRaise( NonPagedPool, sizeof(SYSCACHE_LOG) * NUM_SC_EVENTS, ' neB' );
                }
                Scb->SyscacheLog = NtfsSyscacheLogSet[Scb->LogSetNumber].SyscacheLog;
                Scb->SyscacheLogEntryCount = NUM_SC_EVENTS;
                Scb->CurrentSyscacheLogEntry = -1;

                //
                //  Degrade gracefully if no memory
                //
                if (!Scb->SyscacheLog)
                {
                    Scb->SyscacheLogEntryCount = 0;
                } else
                {
                    memset( Scb->SyscacheLog, 0x61626162, sizeof( SYSCACHE_LOG ) * NUM_SC_EVENTS );
                }
            }
#endif

#ifdef SYSCACHE
            InitializeListHead( &Scb->ScbType.Data.SyscacheEventList );
#endif
        } else {

            //
            //  There is a deallocated queue for indexes and the Mft.
            //

            InitializeListHead( &Scb->ScbType.Index.RecentlyDeallocatedQueue );

            //
            //  Initialize index-specific fields.
            //

            if (AttributeTypeCode == $INDEX_ALLOCATION) {

                InitializeListHead( &Scb->ScbType.Index.LcbQueue );
            }

#ifdef SYSCACHE_DEBUG
            if (SyscacheFile) {
                SetFlag( Scb->ScbPersist, SCB_PERSIST_SYSCACHE_DIR );
            }
#endif
        }

        //
        //  If this Scb should be marked as containing Lsn's or
        //  Update Sequence Arrays, do so now.
        //

        NtfsCheckScbForCache( Scb );

        //
        //  We shouldn't make this call during restart.
        //

        ASSERT( !FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ));

        //
        //  Set the flag indicating that we want the Mapped Page Writer out of this file.
        //

        if (ModifiedNoWrite) {

            SetFlag( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
        }

        //
        //  Let's make sure we caught all of the interesting cases.
        //

        ASSERT( ModifiedNoWrite ?
                (((Scb->AttributeTypeCode != $DATA) ||
                  FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) ||
                  FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) :
                (((Scb->AttributeTypeCode == $DATA) &&
                   !FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) &&
                   !FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) );

        //
        //  Decide whether this is a view index and set
        //  the appropriate scb state bit accordingly.
        //

        if (FlagOn( Fcb->Info.FileAttributes, DUP_VIEW_INDEX_PRESENT ) &&
            (Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
            (Scb->AttributeName.Buffer != NtfsFileNameIndex.Buffer)) {

            SetFlag( Scb->ScbState, SCB_STATE_VIEW_INDEX );
        }

    } finally {

        DebugUnwind( NtfsCreateScb );

        NtfsUnlockFcb( IrpContext, Fcb );

        if (AbnormalTermination()) {

            if (UnwindFromQueue) { RemoveEntryList( &Scb->FcbLinks ); }
            if (UnwindMcb != NULL) { NtfsUninitializeNtfsMcb( UnwindMcb ); }

            if (UnwindAddedClustersMcb != NULL) { FsRtlUninitializeLargeMcb( UnwindAddedClustersMcb ); }
            if (UnwindRemovedClustersMcb != NULL) { FsRtlUninitializeLargeMcb( UnwindRemovedClustersMcb ); }
            if (UnwindOplock != NULL) { FsRtlUninitializeOplock( UnwindOplock ); }
            if (UnwindStorage[0]) { NtfsFreePool( UnwindStorage[0] );
            } else if (Scb != NULL) { Scb->Header.NodeTypeCode = 0; }
            if (UnwindStorage[1]) { NtfsFreePool( UnwindStorage[1] ); }
            if (UnwindStorage[2]) { NtfsFreePool( UnwindStorage[2] ); }
            if (UnwindStorage[3]) { NtfsFreePool( UnwindStorage[3] ); }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateScb -> %08lx\n", Scb) );

#ifdef SYSCACHE_DEBUG
    ASSERT( SyscacheFile || (Scb->SyscacheLogEntryCount == 0 && Scb->SyscacheLog == 0 ));
#endif

    return Scb;
}


PSCB
NtfsCreatePrerestartScb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN ULONG BytesPerIndexBuffer
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Scb record into
    the in memory data structures, provided one does not already exist
    with the identical attribute record.  It does this on the FcbTable
    off of the Vcb.  If necessary this routine will also create the fcb
    if one does not already exist for the indicated file reference.

Arguments:

    Vcb - Supplies the Vcb to associate the new SCB under.

    FileReference - Supplies the file reference for the new SCB this is
        used to identify/create a new lookaside Fcb.

    AttributeTypeCode - Supplies the attribute type code for the new SCB

    AttributeName - Supplies the optional attribute name of the SCB

    BytesPerIndexBuffer - For index Scbs, this must specify the bytes per
                          index buffer.

Return Value:

    PSCB - Returns a pointer to the newly allocated SCB

--*/

{
    PSCB Scb;
    PFCB Fcb;

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT( AttributeTypeCode >= $STANDARD_INFORMATION );

    DebugTrace( +1, Dbg, ("NtfsCreatePrerestartScb\n") );

    //
    //  Use a try-finally to release the Fcb table.
    //

    NtfsAcquireFcbTable( IrpContext, Vcb );

    try {

        //
        //  First make sure we have an Fcb of the proper file reference
        //  and indicate that it is from prerestart
        //

        Fcb = NtfsCreateFcb( IrpContext,
                             Vcb,
                             *FileReference,
                             FALSE,
                             TRUE,
                             NULL );
    } finally {

        NtfsReleaseFcbTable( IrpContext, Vcb );
    }

    //
    //  Search the child scbs of this fcb for a matching Scb (based on
    //  attribute type code and attribute name) if one is not found then
    //  we'll create a new scb.  When we exit the following loop if the
    //  scb pointer to not null then we've found a preexisting scb.
    //

    Scb = NULL;
    while ((Scb = NtfsGetNextChildScb(Fcb, Scb)) != NULL) {

        ASSERT_SCB( Scb );

        //
        //  The the attribute type codes match and if supplied the name also
        //  matches then we got our scb
        //

        if (Scb->AttributeTypeCode == AttributeTypeCode) {

            if (!ARGUMENT_PRESENT( AttributeName )) {

                if (Scb->AttributeName.Length == 0) {

                    break;
                }

            } else if (AttributeName->Length == 0
                       && Scb->AttributeName.Length == 0) {

                break;

            } else if (NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable,
                                          AttributeName,
                                          &Scb->AttributeName,
                                          FALSE )) { // Ignore Case

                break;
            }
        }
    }

    //
    //  If scb now null then we need to create a minimal scb.  We always allocate
    //  these out of non-paged pool.
    //

    if (Scb == NULL) {

        BOOLEAN ShareScb = FALSE;

        //
        //  Allocate new scb and zero it out and set the node type code and byte size.
        //

        if (AttributeTypeCode == $INDEX_ALLOCATION) {

            if (NtfsSegmentNumber( FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER) {

                NodeTypeCode = NTFS_NTC_SCB_ROOT_INDEX;
            } else {
                NodeTypeCode = NTFS_NTC_SCB_INDEX;
            }

            NodeByteSize = SIZEOF_SCB_INDEX;

        } else if (NtfsSegmentNumber( FileReference ) <= MASTER_FILE_TABLE2_NUMBER
                   && (AttributeTypeCode == $DATA)) {

            NodeTypeCode = NTFS_NTC_SCB_MFT;
            NodeByteSize = SIZEOF_SCB_MFT;

        } else {

            NodeTypeCode = NTFS_NTC_SCB_DATA;
            NodeByteSize = SIZEOF_SCB_DATA;
        }

        Scb = NtfsAllocatePoolWithTag( NonPagedPool, NodeByteSize, 'tftN' );

        RtlZeroMemory( Scb, NodeByteSize );

        //
        //  Fill in the node type code and size.
        //

        Scb->Header.NodeTypeCode = NodeTypeCode;
        Scb->Header.NodeByteSize = NodeByteSize;

        //
        //  Show that all of the Scb's are from nonpaged pool.
        //

        SetFlag( Scb->ScbState, SCB_STATE_NONPAGED );

        //
        //  Initialize all of the fields that don't require allocations
        //  first.  We want to make sure we don't leave the Scb in
        //  a state that could cause a crash during Scb teardown.
        //

        //
        //  Set a back pointer to the resource we will be using
        //

        Scb->Header.Resource = Fcb->Resource;

        //
        //  Insert this scb into our parents scb queue and point back to our
        //  parent fcb and vcb.  Put this entry at the head of the list.
        //  Any Scb on the delayed close queue goes to the end of the list.
        //

        InsertHeadList( &Fcb->ScbQueue, &Scb->FcbLinks );

        Scb->Fcb = Fcb;
        Scb->Vcb = Vcb;

        InitializeListHead( &Scb->CcbQueue );

        //
        //  Set the attribute type code recently deallocated information structures.
        //

        Scb->AttributeTypeCode = AttributeTypeCode;

        //
        //  Fill in the advanced fields
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
            FsRtlSetupAdvancedHeader( &Scb->Header, NULL );
        } else {
            SetFlag( Scb->Header.Flags, FSRTL_FLAG_ADVANCED_HEADER );
        }

        Scb->Header.PendingEofAdvances = &Scb->EofListHead;
        InitializeListHead( &Scb->EofListHead );

        //
        //  Do that data stream specific initialization.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_DATA) {

            FsRtlInitializeOplock( &Scb->ScbType.Data.Oplock );
            InitializeListHead( &Scb->ScbType.Data.WaitForNewLength );
            InitializeListHead( &Scb->ScbType.Data.CompressionSyncList );

            //
            //  Set a flag if this is the Usn Journal.
            //

            if (ARGUMENT_PRESENT( AttributeName ) &&
                (*((PLONGLONG) &Vcb->UsnJournalReference) == *((PLONGLONG) &Fcb->FileReference)) &&
                (AttributeName->Length == JournalStreamName.Length) &&
                RtlEqualMemory( AttributeName->Buffer,
                                JournalStreamName.Buffer,
                                JournalStreamName.Length )) {

                SetFlag( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL );
            }

#ifdef SYSCACHE
            InitializeListHead( &Scb->ScbType.Data.SyscacheEventList );
#endif
        } else {

            //
            //  There is a deallocated queue for indexes and the Mft.
            //

            InitializeListHead( &Scb->ScbType.Index.RecentlyDeallocatedQueue );

            //
            //  Initialize index-specific fields.
            //

            if (AttributeTypeCode == $INDEX_ALLOCATION) {

                Scb->ScbType.Index.BytesPerIndexBuffer = BytesPerIndexBuffer;

                InitializeListHead( &Scb->ScbType.Index.LcbQueue );
            }
        }

        //
        //  If this is an Mft Scb then initialize the cluster Mcb's.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_MFT) {

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.AddedClusters, NonPagedPool );

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.RemovedClusters, NonPagedPool );
        }

        Scb->NonpagedScb = (PSCB_NONPAGED)ExAllocateFromNPagedLookasideList( &NtfsScbNonpagedLookasideList );

        RtlZeroMemory( Scb->NonpagedScb, sizeof( SCB_NONPAGED ));

        Scb->NonpagedScb->NodeTypeCode = NTFS_NTC_SCB_NONPAGED;
        Scb->NonpagedScb->NodeByteSize = sizeof( SCB_NONPAGED );
        Scb->NonpagedScb->Vcb = Vcb;

        //
        //  Allocate and insert the mutext into the advanced header.  This is
        //  done now (instead of up with the call to FsRtlSetupAdvancedHeader)
        //  to guarentee the existing order during initilization.
        //

        Scb->Header.FastMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
        ExInitializeFastMutex( Scb->Header.FastMutex );

        NtfsInitializeNtfsMcb( &Scb->Mcb, &Scb->Header, &Scb->McbStructs, NonPagedPool );

        //
        //  If the attribute name is present and the name length is greater than 0
        //  then allocate a buffer for the attribute name and initialize it.
        //

        if (ARGUMENT_PRESENT( AttributeName ) && (AttributeName->Length != 0)) {

            //
            //  The typical case is the $I30 string.  If this matches then
            //  point to a common string.
            //

            if ((AttributeName->Length == NtfsFileNameIndex.Length) &&
                (RtlEqualMemory( AttributeName->Buffer,
                                 NtfsFileNameIndex.Buffer,
                                 AttributeName->Length ) )) {

                Scb->AttributeName = NtfsFileNameIndex;

            } else {

                Scb->AttributeName.Length = AttributeName->Length;
                Scb->AttributeName.MaximumLength = (USHORT)(AttributeName->Length + sizeof( WCHAR ));

                Scb->AttributeName.Buffer = NtfsAllocatePool(PagedPool, AttributeName->Length + sizeof( WCHAR ));

                RtlCopyMemory( Scb->AttributeName.Buffer, AttributeName->Buffer, AttributeName->Length );
                Scb->AttributeName.Buffer[AttributeName->Length / sizeof( WCHAR )] = L'\0';
            }
        }

        //
        //  If this Scb should be marked as containing Lsn's or
        //  Update Sequence Arrays, do so now.
        //

        NtfsCheckScbForCache( Scb );

        //
        //  Always mark the prerestart Scb's as MODIFIED_NO_WRITE.
        //

        SetFlag( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
    }

    DebugTrace( -1, Dbg, ("NtfsCreatePrerestartScb -> %08lx\n", Scb) );

    return Scb;
}


VOID
NtfsFreeScbAttributeName (
    IN PWSTR AttributeNameBuffer
    )

/*++

Routine Description:

    This routine frees the pool used by an Scb attribute name iff it is
    not one of the default system attribute names.

Arguments:

    AttributeName - Supplies the attribute name buffer to free

Return Value:

    None.

--*/

{
    if ((AttributeNameBuffer != NULL) &&
        (AttributeNameBuffer != NtfsFileNameIndex.Buffer) &&
        (AttributeNameBuffer != NtfsObjId.Buffer) &&
        (AttributeNameBuffer != NtfsQuota.Buffer)) {

        NtfsFreePool( AttributeNameBuffer );
    }
}


VOID
NtfsDeleteScb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine deallocates and removes an Scb record
    from Ntfs's in-memory data structures.  It assume that is does not have
    any children lcb emanating from it.

Arguments:

    Scb - Supplies the SCB to be removed

Return Value:

    None.

--*/

{
    PVCB Vcb;
    PFCB Fcb;
    POPEN_ATTRIBUTE_ENTRY AttributeEntry;
    USHORT ThisNodeType;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( *Scb );
    ASSERT( (*Scb)->CleanupCount == 0 );

    DebugTrace( +1, Dbg, ("NtfsDeleteScb, *Scb = %08lx\n", *Scb) );

    Fcb = (*Scb)->Fcb;
    Vcb = Fcb->Vcb;

    RemoveEntryList( &(*Scb)->FcbLinks );

    ThisNodeType = SafeNodeType( *Scb );

    //
    //  If this is a bitmap Scb for a directory then make sure the record
    //  allocation structure is uninitialized.  Otherwise we will leave a
    //  stale pointer for the record allocation package.
    //

    if (((*Scb)->AttributeTypeCode == $BITMAP) &&
        IsDirectory( &Fcb->Info)) {

        PLIST_ENTRY Links;
        PSCB IndexAllocationScb;

        Links = Fcb->ScbQueue.Flink;

        while (Links != &Fcb->ScbQueue) {

            IndexAllocationScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

            if (IndexAllocationScb->AttributeTypeCode == $INDEX_ALLOCATION) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &IndexAllocationScb->ScbType.Index.RecordAllocationContext );

                IndexAllocationScb->ScbType.Index.AllocationInitialized = FALSE;

                break;
            }

            Links = Links->Flink;
        }
    }

    //
    //  Delete the write mask, if one is being maintained.
    //


#ifdef SYSCACHE
    if ((ThisNodeType == NTFS_NTC_SCB_DATA) &&
        ((*Scb)->ScbType.Data.WriteMask != (PULONG)NULL)) {

        NtfsFreePool((*Scb)->ScbType.Data.WriteMask);
    }
#endif

    //
    //  Mark our entry in the Open Attribute Table as free,
    //  although it will not be deleted until some future
    //  checkpoint.  Log this change as well, as long as the
    //  log file is active.
    //

    if (((*Scb)->NonpagedScb != NULL) &&
        ((*Scb)->NonpagedScb->OpenAttributeTableIndex != 0)) {

        NtfsAcquireSharedRestartTable( &Vcb->OpenAttributeTable, TRUE );
        AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                   (*Scb)->NonpagedScb->OpenAttributeTableIndex );
        AttributeEntry->OatData->Overlay.Scb = NULL;
        NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );

        //
        //  "Steal" the name, and let it belong to the Open Attribute Table
        //  entry and deallocate it only during checkpoints.
        //

        (*Scb)->AttributeName.Buffer = NULL;
    }

    //
    //  Uninitialize the file lock and oplock variables if this
    //  a data Scb.  For the index case make sure that the lcb queue
    //  is empty.  If this is for an Mft Scb then uninitialize the
    //  allocation Mcb's.
    //

    NtfsUninitializeNtfsMcb( &(*Scb)->Mcb );

    if (ThisNodeType == NTFS_NTC_SCB_DATA ) {

        FsRtlUninitializeOplock( &(*Scb)->ScbType.Data.Oplock );

        if ((*Scb)->ScbType.Data.FileLock != NULL) {

            FsRtlFreeFileLock( (*Scb)->ScbType.Data.FileLock );
        }

#ifdef SYSCACHE

        while (!IsListEmpty( &(*Scb)->ScbType.Data.SyscacheEventList )) {

            PSYSCACHE_EVENT SyscacheEvent;

            SyscacheEvent = CONTAINING_RECORD( (*Scb)->ScbType.Data.SyscacheEventList.Flink,
                                               SYSCACHE_EVENT,
                                               EventList );

            RemoveEntryList( &SyscacheEvent->EventList );
            NtfsFreePool( SyscacheEvent );
        }
#endif

        ASSERT( IsListEmpty( &(*Scb)->ScbType.Data.CompressionSyncList ));

#ifdef NTFS_RWC_DEBUG
        if ((*Scb)->ScbType.Data.HistoryBuffer != NULL) {

            NtfsFreePool( (*Scb)->ScbType.Data.HistoryBuffer );
            (*Scb)->ScbType.Data.HistoryBuffer = NULL;
        }
#endif
    } else if (ThisNodeType != NTFS_NTC_SCB_MFT) {

        //
        //  Walk through and remove any Lcb's from the queue.
        //

        while (!IsListEmpty( &(*Scb)->ScbType.Index.LcbQueue )) {

            PLCB NextLcb;

            NextLcb = CONTAINING_RECORD( (*Scb)->ScbType.Index.LcbQueue.Flink,
                                         LCB,
                                         ScbLinks );

            NtfsDeleteLcb( IrpContext, &NextLcb );
        }

        if ((*Scb)->ScbType.Index.NormalizedName.Buffer != NULL) {

            NtfsDeleteNormalizedName( *Scb );
        }

    } else {

        FsRtlUninitializeLargeMcb( &(*Scb)->ScbType.Mft.AddedClusters );
        FsRtlUninitializeLargeMcb( &(*Scb)->ScbType.Mft.RemovedClusters );
    }

    if ((*Scb)->EncryptionContext != NULL) {

        //
        //  Let the encryption driver do anything necessary to clean up
        //  its private data structures.
        //

        if (NtfsData.EncryptionCallBackTable.CleanUp != NULL) {

            NtfsData.EncryptionCallBackTable.CleanUp( &(*Scb)->EncryptionContext );
        }

        //
        //  If the encryption driver didn't clear this in its cleanup routine,
        //  or if there is no cleanup routine registered, we should free any
        //  for the encryption context ourselves.
        //

        if ((*Scb)->EncryptionContext != NULL) {

            NtfsFreePool( (*Scb)->EncryptionContext );
            (*Scb)->EncryptionContext = NULL;
        }
    }

    //
    //  Show there is no longer a snapshot Scb, if there is a snapshot.
    //  We rely on the snapshot package to correctly recognize the
    //  the case where the Scb field is gone.
    //

    if ((*Scb)->ScbSnapshot != NULL) {

        (*Scb)->ScbSnapshot->Scb = NULL;
    }

    //
    //  Cleanup Filesystem Filter contexts (this was moved to the point
    //  before the FastMutex is freed because this routine now uses it)
    //

    if (FlagOn( (*Scb)->Header.Flags2, FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS )) {

        FsRtlTeardownPerStreamContexts( (PFSRTL_ADVANCED_FCB_HEADER)&(*Scb)->Header );
    }

    //
    //  Deallocate the fast mutex if not in the Fcb.
    //

    if (((*Scb)->Header.FastMutex != (*Scb)->Fcb->FcbMutex) &&
        ((*Scb)->Header.FastMutex != NULL)) {

        NtfsFreePool( (*Scb)->Header.FastMutex );
    }

    //
    //  Deallocate the non-paged scb.
    //

    if ((*Scb)->NonpagedScb != NULL) {

        ExFreeToNPagedLookasideList( &NtfsScbNonpagedLookasideList, (*Scb)->NonpagedScb );
    }

    //
    //  Deallocate the attribute name.
    //

    NtfsFreeScbAttributeName( (*Scb)->AttributeName.Buffer );

    //
    //  See if CollationData is to be deleted.
    //

    if (FlagOn((*Scb)->ScbState, SCB_STATE_DELETE_COLLATION_DATA)) {
        NtfsFreePool((*Scb)->ScbType.Index.CollationData);
    }

    //
    //  Always directly free the Mft and non-paged Scb's.
    //

    if (FlagOn( (*Scb)->ScbState, SCB_STATE_NONPAGED ) ||
        (ThisNodeType == NTFS_NTC_SCB_MFT)) {

        NtfsFreePool( *Scb );

    } else {

        //
        //  Free any final reserved clusters for data Scb's.
        //


        if (ThisNodeType == NTFS_NTC_SCB_DATA) {

            //
            //  Free the reserved bitmap and reserved clusters if present.
            //

            if ((*Scb)->ScbType.Data.ReservedBitMap != NULL) {
                NtfsDeleteReservedBitmap( *Scb );
            }
        }

        //
        //  Now free the Scb itself.
        //
        //  Check if this is an embedded Scb.  This could be part of either an INDEX_FCB
        //  or a DATA_FCB.  We depend on the fact that the Scb would be in the same
        //  location in either case.
        //

        if ((*Scb) == (PSCB) &((PFCB_DATA) (*Scb)->Fcb)->Scb) {

            (*Scb)->Header.NodeTypeCode = 0;

        } else if (SafeNodeType( *Scb ) == NTFS_NTC_SCB_DATA) {

            ExFreeToPagedLookasideList( &NtfsScbDataLookasideList, *Scb );

        } else {

            NtfsFreePool( *Scb );
        }
    }

    //
    //  Zero out the input pointer
    //

    *Scb = NULL;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteScb -> VOID\n") );

    return;
}


BOOLEAN
NtfsUpdateNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PSCB Scb,
    IN PFILE_NAME FileName OPTIONAL,
    IN BOOLEAN CheckBufferSizeOnly
    )

/*++

Routine Description:

    This routine is called to update the normalized name in an IndexScb.
    This name will be the path from the root without any short name components.
    This routine will append the given name if present provided this is not a
    DOS only name.  In any other case this routine will go to the disk to
    find the name.  This routine will handle the case where there is an existing buffer
    and the data will fit, as well as the case where the buffer doesn't exist
    or is too small.

Arguments:

    ParentScb - Supplies the parent of the current Scb.  The name for the target
        scb is appended to the name in this Scb.

    Scb - Supplies the target Scb to add the name to.

    FileName - If present this is a filename attribute for this Scb.  We check
        that it is not a DOS-only name.

    CheckBufferSizeOnly - Indicates that we don't want to change the name yet.  Just
        verify that the buffer is the correct size.

Return Value:

    BOOLEAN - TRUE if we updated the name in the Scb, FALSE otherwise.  We would return
        FALSE only if the parent becomes uninitialized on us.  Any callers who can't
        tolerate this must own the parent.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PFILE_NAME OriginalFileName;
    BOOLEAN CleanupContext = FALSE;
    ULONG Length;
    ULONG UnsafeLength;
    ULONG SeparatorLength;
    BOOLEAN UpdatedName = TRUE;

    PAGED_CODE();

    ASSERT( NodeType( Scb ) == NTFS_NTC_SCB_INDEX );
    ASSERT( NodeType( ParentScb ) == NTFS_NTC_SCB_INDEX ||
            NodeType( ParentScb ) == NTFS_NTC_SCB_ROOT_INDEX );

    //
    //  Use a try-finally to clean up the attribute context.
    //

    try {

        //
        //  If the parent is the root then we don't need an extra separator.
        //

        SeparatorLength = 1;
        if (ParentScb == ParentScb->Vcb->RootIndexScb) {

            SeparatorLength = 0;
        }

        //
        //  Remember if we got a file name from our caller.
        //

        OriginalFileName = FileName;

        //
        //  The only safe time to examine the normalized name structures are
        //  when holding the hash table mutex.  These values shouldn't change
        //  often but if they do (and we are doing unsynchronized tests) then
        //  we will simply restart the logic.
        //

        do {

            //
            //  If the filename isn't present or is a DOS-only name then go to
            //  disk to find another name for this Scb.
            //

            if (!ARGUMENT_PRESENT( FileName ) || (FileName->Flags == FILE_NAME_DOS)) {

                BOOLEAN Found;

                NtfsInitializeAttributeContext( &Context );
                CleanupContext = TRUE;

                //
                //  Walk through the names for this entry.  There better
                //  be one which is not a DOS-only name.
                //

                Found = NtfsLookupAttributeByCode( IrpContext,
                                                   Scb->Fcb,
                                                   &Scb->Fcb->FileReference,
                                                   $FILE_NAME,
                                                   &Context );

                while (Found) {

                    FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

                    if (FileName->Flags != FILE_NAME_DOS) { break; }

                    Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                           Scb->Fcb,
                                                           $FILE_NAME,
                                                           &Context );
                }

                //
                //  We should have found the entry.
                //

                if (!Found) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }
            }

            //
            //  Compute the length we need for the name.  This is unsynchronized so
            //  we will verify it later.

            UnsafeLength = ParentScb->ScbType.Index.NormalizedName.Length + (FileName->FileNameLength + SeparatorLength) * sizeof( WCHAR );

            //
            //  If the current buffer is insufficient then allocate a new one.
            //  Note that these are all unsafe tests.  We will have to
            //  verify the values after acquiring the hash table mutex.
            //

            if (Scb->ScbType.Index.NormalizedName.MaximumLength < UnsafeLength) {

                PVOID OldBuffer;
                PVOID NewBuffer;

                NewBuffer = NtfsAllocatePoolWithTag( PagedPool, UnsafeLength, 'oftN' );

                //
                //  Now acquire the Hash table mutex and verify the numbers.  If they
                //  are still valid then continue.
                //

                NtfsAcquireHashTable( Scb->Vcb );

                //
                //  Check for unexpected changes.
                //

                Length = ParentScb->ScbType.Index.NormalizedName.Length + (FileName->FileNameLength + SeparatorLength) * sizeof( WCHAR );

                if ((ParentScb->ScbType.Index.NormalizedName.Length == 0) ||
                    (Length > UnsafeLength)) {

                    //
                    //  The following is an exit condition for us.
                    //

                    if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {
                        UpdatedName = FALSE;
                    }

                    NtfsReleaseHashTable( Scb->Vcb );

                    //
                    //  Free pool and clean up.
                    //

                    NtfsFreePool( NewBuffer );
                    if (CleanupContext) {
                        NtfsCleanupAttributeContext( IrpContext, &Context );
                        CleanupContext = FALSE;
                    }

                    FileName = OriginalFileName;

                    continue;
                }

                //
                //  Now copy over the existing data.
                //

                OldBuffer = Scb->ScbType.Index.NormalizedName.Buffer;

                if (OldBuffer != NULL) {

                    RtlCopyMemory( NewBuffer,
                                   OldBuffer,
                                   Scb->ScbType.Index.NormalizedName.MaximumLength );

                    NtfsFreePool( OldBuffer );
                }

                //
                //  Swap out the old buffer and max length.  No change to the hash value at
                //  this point.
                //

                Scb->ScbType.Index.NormalizedName.Buffer = NewBuffer;
                Scb->ScbType.Index.NormalizedName.MaximumLength = (USHORT) Length;

            //
            //  Acquire the hash table and verify that nothing has changed on us.
            //

            } else {

                NtfsAcquireHashTable( Scb->Vcb );

                //
                //  Check for unexpected changes.
                //

                Length = ParentScb->ScbType.Index.NormalizedName.Length + (FileName->FileNameLength + SeparatorLength) * sizeof( WCHAR );

                if ((ParentScb->ScbType.Index.NormalizedName.Length == 0) ||
                    (Length > UnsafeLength)) {

                    //
                    //  The following is an exit condition for us.
                    //

                    if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {
                        UpdatedName = FALSE;
                    }

                    NtfsReleaseHashTable( Scb->Vcb );

                    //
                    //  Cleanup for retry.
                    //

                    if (CleanupContext) {
                        NtfsCleanupAttributeContext( IrpContext, &Context );
                        CleanupContext = FALSE;
                    }

                    FileName = OriginalFileName;
                    continue;
                }
            }

            //
            //  At this point we hold the hash table and know that the buffer is sufficient
            //  for the new data.  However it still contains the previous data.  If we aren't
            //  just updating the buffer lengths then store the new data.
            //

            if (!CheckBufferSizeOnly) {

                PCHAR NextChar;

                //
                //  Copy the new name into the buffer.
                //

                Scb->ScbType.Index.NormalizedName.Length = (USHORT) Length;
                NextChar = (PCHAR) Scb->ScbType.Index.NormalizedName.Buffer;

                //
                //  Now copy the name in.  Don't forget to add the separator if the parent isn't
                //  the root.
                //

                RtlCopyMemory( NextChar,
                               ParentScb->ScbType.Index.NormalizedName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Length );

                NextChar += ParentScb->ScbType.Index.NormalizedName.Length;

                if (SeparatorLength == 1) {

                    *((PWCHAR) NextChar) = L'\\';
                    NextChar += sizeof( WCHAR );
                }

                //
                //  Now append this name to the parent name.
                //

                RtlCopyMemory( NextChar,
                               FileName->FileName,
                               FileName->FileNameLength * sizeof( WCHAR ));

                Scb->ScbType.Index.HashValue = 0;
                NtfsConvertNameToHash( Scb->ScbType.Index.NormalizedName.Buffer,
                                       Scb->ScbType.Index.NormalizedName.Length,
                                       Scb->Vcb->UpcaseTable,
                                       &Scb->ScbType.Index.HashValue );
            }

            NtfsReleaseHashTable( Scb->Vcb );

            //
            //  Only one pass required in the typical case.
            //

            break;

        //
        //  We either break out specifically or set this to FALSE.
        //

        } while (UpdatedName);

    } finally {

        if (CleanupContext) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }
    }

    return UpdatedName;
}


VOID
NtfsDeleteNormalizedName (
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to delete the normalized name from an Scb.
    We make this a function in order to serialize the normalized name
    deletion with the hash package.  The user has already done
    the check to see if this Scb has a normalized name.  Note that the
    name may not be valid (Length == 0) but it does have a buffer
    requiring cleanup.

Arguments:

    Scb - Index Scb with a normalized name.

Return Value:

    None

--*/

{
    PVOID OldBuffer;

    PAGED_CODE();

    ASSERT( Scb->AttributeTypeCode == $INDEX_ALLOCATION );
    ASSERT( Scb->ScbType.Index.NormalizedName.Buffer != NULL );

    //
    //  The hash table mutex is needed to synchronize with callers in the hash
    //  package who look at this Scb name without serializing with the Scb.
    //  They must hold the hash mutex for their entire operation.
    //

    NtfsAcquireHashTable( Scb->Vcb );
    OldBuffer = Scb->ScbType.Index.NormalizedName.Buffer;
    Scb->ScbType.Index.NormalizedName.Buffer = NULL;
    Scb->ScbType.Index.NormalizedName.MaximumLength = Scb->ScbType.Index.NormalizedName.Length = 0;

    NtfsReleaseHashTable( Scb->Vcb );

    NtfsFreePool( OldBuffer );

    return;
}



NTSTATUS
NtfsWalkUpTree (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN NTFSWALKUPFUNCTION WalkUpFunction,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine walks up the tree from child to parent, applying
    a function at each level.  Processing terminates when WalkUpFunction
    returns a failure status code.  The current convention is that
    WalkUpFunctions return STATUS_NO_MORE_FILES when a successful upward
    traversal occurs.  Other status codes are private to
    caller/WalkUpFunction.

Arguments:

    IrpContext - context of the call

    Fcb - beginning file

    WalkUpFunction - function that is applied to each level

    Context - Pointer to caller-private data passed to WalkUpFunction

Return Value:

    STATUS_SUCCESS - at end of complete walk

    Status code returned by WalkUpFunction otherwise

--*/

{
    PFCB ThisFcb = Fcb;
    PFCB NextFcb = NULL;
    PSCB NextScb = NULL;
    PLCB NextLcb;
    BOOLEAN AcquiredNextFcb = FALSE;
    BOOLEAN AcquiredThisFcb = FALSE;
    BOOLEAN AcquiredFcbTable = FALSE;

    BOOLEAN FoundEntry = TRUE;
    BOOLEAN CleanupAttrContext = FALSE;
    PFILE_NAME FileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_SHARED_RESOURCE( &Fcb->Vcb->Resource );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        while (TRUE) {

            //
            //  If we reach the root then exit.
            //

            if (ThisFcb == ThisFcb->Vcb->RootIndexScb->Fcb) {
                //
                //  Special case root directory
                //

                Status = WalkUpFunction( IrpContext, ThisFcb, ThisFcb->Vcb->RootIndexScb, NULL, Context );
                break;
            }

            //
            //  Find a non-dos name for the current Scb.  There better be one.
            //

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            FoundEntry = NtfsLookupAttributeByCode( IrpContext,
                                                    ThisFcb,
                                                    &ThisFcb->FileReference,
                                                    $FILE_NAME,
                                                    &AttrContext );

            while (FoundEntry) {

                FileName = (PFILE_NAME)
                        NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                if (FileName->Flags != FILE_NAME_DOS ) {
                    break;
                }

                FoundEntry = NtfsLookupNextAttributeByCode( IrpContext,
                                                            ThisFcb,
                                                            $FILE_NAME,
                                                            &AttrContext );
            }

            if (!FoundEntry) {

                NtfsRaiseStatus( IrpContext,
                                 STATUS_FILE_CORRUPT_ERROR,
                                 NULL,
                                 NextFcb );
            }

            ASSERT( NextScb == NULL || NextScb->Fcb == ThisFcb );
            Status = WalkUpFunction( IrpContext, ThisFcb, NextScb, FileName, Context );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            //  Now get the parent for the current component.  Acquire the Fcb for
            //  synchronization.  We can either walk up the Lcb chain or look it up
            //  in the Fcb table.  It must be for the same name as the file name
            //  since there is only one path up the tree for a directory.
            //

            if (!IsListEmpty( &ThisFcb->LcbQueue ) && IsDirectory( &ThisFcb->Info )) {

                NextLcb =
                    (PLCB) CONTAINING_RECORD( ThisFcb->LcbQueue.Flink, LCB, FcbLinks );
                NextScb = NextLcb->Scb;
                NextFcb = NextScb->Fcb;

                NtfsAcquireExclusiveFcb( IrpContext, NextFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                AcquiredNextFcb = TRUE;

                ASSERT( NtfsEqualMftRef( &FileName->ParentDirectory,
                                         &NextFcb->FileReference ));

            } else {
                UNICODE_STRING ComponentName;

                NtfsAcquireFcbTable( IrpContext, Fcb->Vcb );
                AcquiredFcbTable = TRUE;

                NextFcb = NtfsCreateFcb( IrpContext,
                                         Fcb->Vcb,
                                         FileName->ParentDirectory,
                                         FALSE,
                                         TRUE,
                                         NULL );

                NextFcb->ReferenceCount += 1;

                //
                //  Try to do an unsafe acquire.  Otherwise we must drop the Fcb table
                //  and acquire the Fcb and then reacquire the Fcb table.
                //

                if (!NtfsAcquireExclusiveFcb( IrpContext, NextFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                    NtfsReleaseFcbTable( IrpContext, Fcb->Vcb );
                    NtfsAcquireExclusiveFcb( IrpContext, NextFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    NtfsAcquireFcbTable( IrpContext, Fcb->Vcb );

                }

                NextFcb->ReferenceCount -= 1;
                NtfsReleaseFcbTable( IrpContext, Fcb->Vcb );
                AcquiredFcbTable = FALSE;
                AcquiredNextFcb = TRUE;

                NextScb = NtfsCreateScb( IrpContext,
                                         NextFcb,
                                         $INDEX_ALLOCATION,
                                         &NtfsFileNameIndex,
                                         FALSE,
                                         NULL );

                ComponentName.Buffer = FileName->FileName;
                ComponentName.MaximumLength =
                    ComponentName.Length = FileName->FileNameLength * sizeof( WCHAR );

                NextLcb = NtfsCreateLcb( IrpContext,
                                         NextScb,
                                         ThisFcb,
                                         ComponentName,
                                         FileName->Flags,
                                         NULL );
            }

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;

            //
            //  Release the current Fcb and move up the tree.
            //

            if (AcquiredThisFcb) {
                NtfsReleaseFcb( IrpContext, ThisFcb );
            }

            ThisFcb = NextFcb;
            AcquiredThisFcb = TRUE;
            AcquiredNextFcb = FALSE;
        }

    } finally {

        if (AcquiredFcbTable) { NtfsReleaseFcbTable( IrpContext, Fcb->Vcb ); }
        if (AcquiredNextFcb) { NtfsReleaseFcb( IrpContext, NextFcb ); }
        if (AcquiredThisFcb) { NtfsReleaseFcb( IrpContext, ThisFcb ); }

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

    }

    return Status;
}


NTSTATUS
NtfsBuildRelativeName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called for each parent directory up to the root.  We
    prepend the name of the current node to the ScopeContext as we walk
    up.  We terminate this walk when we hit the top of the scope or the
    root.

Arguments:

    IrpContext - context of the call

    Fcb - parent

    FileName - FILE_NAME of self relative to parent

    Context - Pointer to caller-private data passed to WalkUpFunction

Return Value:

    STATUS_SUCCESS - if we're still walking up the tree

    STATUS_NO_MORE_FILES - if we've found the specified scope

    STATUS_OBJECT_PATH_NOT_FOUND - if we've reached the root and did not
        hit the scope.

--*/
{
    PSCOPE_CONTEXT ScopeContext = (PSCOPE_CONTEXT) Context;
    ULONG SlashCount;
    WCHAR *Name;
    ULONG Count;
    USHORT NewLength;

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    //
    //  If we've reached the passed-in scope then we're done
    //

    if (NtfsEqualMftRef( &ScopeContext->Scope, &Fcb->FileReference )) {
        return STATUS_NO_MORE_FILES;
    }

    //
    //  If we've reached the root then we're totally outside the scope
    //

    if (NtfsEqualMftRef( &RootIndexFileReference, &Fcb->FileReference )) {
        return STATUS_OBJECT_PATH_NOT_FOUND;
    }

    //
    //  Set up Name from input.  We take the shortcut to building the name
    //  only if we're looking from the root.  Also, if we are starting at
    //  the root, then we should use the canned name as well.
    //

    if (
        //
        //  No file name (i.e., root)
        //

        FileName == NULL ||

        //
        //  We're searching to the root and
        //  we have an Scb and
        //  the Scb has a normalized name
        //

        (ScopeContext->IsRoot &&
         (Scb != NULL) &&
         (Scb->ScbType.Index.NormalizedName.Length != 0))) {

        Name = Scb->ScbType.Index.NormalizedName.Buffer;
        Count = Scb->ScbType.Index.NormalizedName.Length / sizeof( WCHAR );
        SlashCount = 0;

    } else {
        Name = FileName->FileName;
        Count = FileName->FileNameLength;
        SlashCount = 1;
    }

    //
    //  If there's not enough room in the string to allow for prepending
    //

    NewLength = (USHORT) ((SlashCount + Count) * sizeof( WCHAR ) + ScopeContext->Name.Length);
    if (NewLength > ScopeContext->Name.MaximumLength ) {

        WCHAR *NewBuffer;

        //
        //  Reallocate string.  Adjust size of string for pool boundaries.
        //

        NewLength = ((NewLength + 8 + 0x40 - 1) & ~(0x40 - 1)) - 8;
        NewBuffer = NtfsAllocatePool( PagedPool, NewLength );

        //
        //  Copy over previous contents into new buffer
        //

        if (ScopeContext->Name.Length != 0) {
            RtlCopyMemory( NewBuffer,
                           ScopeContext->Name.Buffer,
                           ScopeContext->Name.Length );
            NtfsFreePool( ScopeContext->Name.Buffer );
        }

        ScopeContext->Name.Buffer = NewBuffer;
        ScopeContext->Name.MaximumLength = NewLength;
    }

    //
    //  Shift string over to make new room
    //

    RtlMoveMemory( &ScopeContext->Name.Buffer[SlashCount + Count],
                   ScopeContext->Name.Buffer,
                   ScopeContext->Name.Length );

    //
    //  copy name
    //

    RtlCopyMemory( &ScopeContext->Name.Buffer[SlashCount],
                   Name,
                   Count * sizeof( WCHAR ) );

    //
    //  Stick in the slash
    //

    if (SlashCount != 0) {
        ScopeContext->Name.Buffer[0] = L'\\';
    }

    ScopeContext->Name.Length += (USHORT)((SlashCount + Count) * sizeof( WCHAR ));

    return SlashCount == 0 ? STATUS_NO_MORE_FILES : STATUS_SUCCESS;
}


VOID
NtfsBuildNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB IndexScb OPTIONAL,
    OUT PUNICODE_STRING PathName
    )

/*++

Routine Description:

    This routine is called to build a normalized name for an Fcb by looking
    up the file name attributes up to the root directory.

Arguments:

    IrpContext - context of call

    Fcb - Supplies the starting point.

    IndexScb - Indicates that we are storing this name into an Scb so we
        we need to serialize with the hash package and also generate a
        hash for this.

    PathName - location where full name is stored

Return Value:

    None.  This routine either succeeds or raises.

--*/

{
    SCOPE_CONTEXT ScopeContext;

    PAGED_CODE();

    RtlZeroMemory( &ScopeContext, sizeof( ScopeContext ));
    ScopeContext.Scope = RootIndexFileReference;
    ScopeContext.IsRoot = TRUE;

    try {

        NtfsWalkUpTree( IrpContext, Fcb, NtfsBuildRelativeName, &ScopeContext );

        if (ARGUMENT_PRESENT( IndexScb )) {

            NtfsAcquireHashTable( Fcb->Vcb );
            *PathName = ScopeContext.Name;
            IndexScb->ScbType.Index.HashValue = 0;
            NtfsConvertNameToHash( PathName->Buffer,
                                   PathName->Length,
                                   IndexScb->Vcb->UpcaseTable,
                                   &IndexScb->ScbType.Index.HashValue );

            NtfsReleaseHashTable( Fcb->Vcb );

        } else {

            *PathName = ScopeContext.Name;
        }

        ScopeContext.Name.Buffer = NULL;

    } finally {
        if (ScopeContext.Name.Buffer != NULL) {
            NtfsFreePool( ScopeContext.Name.Buffer );
        }
    }
}


VOID
NtfsSnapshotScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine snapshots necessary Scb data, such as the Scb file sizes,
    so that they may be correctly restored if the caller's I/O request is
    aborted for any reason.  The restoring of these values and the freeing
    of any pool involved is automatic.

Arguments:

    Scb - Supplies the current Scb

Return Value:

    None

--*/

{
    PSCB_SNAPSHOT ScbSnapshot;

    ASSERT_EXCLUSIVE_SCB(Scb);

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  Only do the snapshot if the Scb is initialized, we have not done
    //  so already, and it is worth special-casing the bitmap, as it never changes!
    //  We will snapshot the volume bitmap if it is on the exclusive Fcb list however.
    //  This should only happen if we are extending the volume bitmap through the
    //  ExtendVolume fsctl.
    //

    if (FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED) &&
        (Scb->ScbSnapshot == NULL) &&
        ((Scb != Scb->Vcb->BitmapScb) ||
         (Scb->Fcb->ExclusiveFcbLinks.Flink != NULL))) {

        //
        //  If the snapshot structure in the IrpContext is in use, then we have
        //  to allocate one and insert it in the list.
        //

        if (ScbSnapshot->SnapshotLinks.Flink != NULL) {

            ScbSnapshot = (PSCB_SNAPSHOT)ExAllocateFromNPagedLookasideList( &NtfsScbSnapshotLookasideList );

            InsertTailList( &IrpContext->ScbSnapshot.SnapshotLinks,
                            &ScbSnapshot->SnapshotLinks );

        //
        //  Otherwise we will initialize the listhead to show that the structure
        //  in the IrpContext is in use.
        //

        } else {

            InitializeListHead( &ScbSnapshot->SnapshotLinks );
        }

        //
        //  We should never be writing compressed if the file isn't compressed.
        //

        ASSERT( FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) ||
                !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
                (Scb->CompressionUnit != 0) );

        //
        //  Snapshot the Scb values and point the Scb and snapshot structure
        //  at each other.
        //

        NtfsVerifySizes( &Scb->Header );
        ScbSnapshot->AllocationSize = Scb->Header.AllocationSize.QuadPart;

        ScbSnapshot->FileSize = Scb->Header.FileSize.QuadPart;
        ScbSnapshot->ValidDataLength = Scb->Header.ValidDataLength.QuadPart;
        ScbSnapshot->ValidDataToDisk = Scb->ValidDataToDisk;
        ScbSnapshot->Scb = Scb;
        ScbSnapshot->LowestModifiedVcn = MAXLONGLONG;
        ScbSnapshot->HighestModifiedVcn = 0;

        ScbSnapshot->TotalAllocated = Scb->TotalAllocated;

        ScbSnapshot->ScbState = FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

        Scb->ScbSnapshot = ScbSnapshot;
        NtfsVerifySizesLongLong( ScbSnapshot );

        //
        //  If this is the Mft Scb then initialize the cluster Mcb structures.
        //

        if (Scb == Scb->Vcb->MftScb) {

            FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.AddedClusters, 0 );
            FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.RemovedClusters, 0 );

            Scb->ScbType.Mft.FreeRecordChange = 0;
            Scb->ScbType.Mft.HoleRecordChange = 0;
        }

        //
        //  Determine if we can use the snapshot for rollback of file sizes
        //  The 4 cases are we own the pagingio, we own io at eof, its being converted to non-res
        //  or its a mod-no write stream  which we explicity control like the usn journal
        //

        if (NtfsSnapshotFileSizesTest( IrpContext, Scb )) {
            Scb->ScbSnapshot->OwnerIrpContext = IrpContext;
        } else {
            Scb->ScbSnapshot->OwnerIrpContext = NULL;
        }
    }
}


VOID
NtfsUpdateScbSnapshots (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine may be called to update the snapshot values for all Scbs,
    after completing a transaction checkpoint.

Arguments:

Return Value:

    None

--*/

{
    PSCB_SNAPSHOT ScbSnapshot;
    PSCB Scb;

    ASSERT(FIELD_OFFSET(SCB_SNAPSHOT, SnapshotLinks) == 0);

    PAGED_CODE();

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  There is no snapshot data to update if the Flink is still NULL.
    //

    if (ScbSnapshot->SnapshotLinks.Flink != NULL) {

        //
        //  Loop to update first the Scb data from the snapshot in the
        //  IrpContext, and then 0 or more additional snapshots linked
        //  to the IrpContext.
        //

        do {

            Scb = ScbSnapshot->Scb;

            //
            //  Update the Scb values.
            //

            if (Scb != NULL) {

                ScbSnapshot->AllocationSize = Scb->Header.AllocationSize.QuadPart;

                //
                //  If this is the MftScb then clear out the added/removed
                //  cluster Mcbs.
                //

                if (Scb == Scb->Vcb->MftScb) {

                    FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.AddedClusters, (LONGLONG)0 );
                    FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.RemovedClusters, (LONGLONG)0 );

                    Scb->ScbType.Mft.FreeRecordChange = 0;
                    Scb->ScbType.Mft.HoleRecordChange = 0;
                }

                ScbSnapshot->FileSize = Scb->Header.FileSize.QuadPart;
                ScbSnapshot->ValidDataLength = Scb->Header.ValidDataLength.QuadPart;
                ScbSnapshot->ValidDataToDisk = Scb->ValidDataToDisk;
                ScbSnapshot->TotalAllocated = Scb->TotalAllocated;

                ScbSnapshot->ScbState = FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );
                NtfsVerifySizesLongLong( ScbSnapshot );
            }

            ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

        } while (ScbSnapshot != &IrpContext->ScbSnapshot);
    }
}


VOID
NtfsRestoreScbSnapshots (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Higher
    )

/*++

Routine Description:

    This routine restores snapshot Scb data in the event of an aborted request.

Arguments:

    Higher - Specified as TRUE to restore only those Scb values which are
             higher than current values.  Specified as FALSE to restore
             only those Scb values which are lower (or same!).

Return Value:

    None

--*/

{
    BOOLEAN UpdateCc;
    PSCB_SNAPSHOT ScbSnapshot;
    PSCB Scb;
    PVCB Vcb = IrpContext->Vcb;

    ASSERT(FIELD_OFFSET(SCB_SNAPSHOT, SnapshotLinks) == 0);

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  There is no snapshot data to restore if the Flink is still NULL.
    //

    if (ScbSnapshot->SnapshotLinks.Flink != NULL) {

        //
        //  Loop to retore first the Scb data from the snapshot in the
        //  IrpContext, and then 0 or more additional snapshots linked
        //  to the IrpContext.
        //

        do {

            PSECTION_OBJECT_POINTERS SectionObjectPointer;
            PFILE_OBJECT PseudoFileObject;

            Scb = ScbSnapshot->Scb;

            if (Scb == NULL) {

                ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;
                continue;
            }

            //
            //  Increment the cleanup count so the Scb won't go away.
            //

            InterlockedIncrement( &Scb->CleanupCount );

            //
            //  We update the Scb file size in the correct pass.  We always do
            //  the extend/truncate pair.
            //
            //  Only do sizes if our caller was changing these fields, which we marked
            //  by setting the irpcontext owner when we snapped
            //
            //  The one unusual case is where we are converting a stream to
            //  nonresident when this is not the stream for the request.  We
            //  must restore the Scb for this case as well.
            //

            UpdateCc = FALSE;
            if ((ScbSnapshot->OwnerIrpContext == IrpContext) || (ScbSnapshot->OwnerIrpContext == IrpContext->TopLevelIrpContext)) {

                //
                //  Proceed to restore all values which are in higher or not
                //  higher.
                //

                if (Higher == (ScbSnapshot->AllocationSize >= Scb->Header.AllocationSize.QuadPart)) {

                    //
                    //  If this is the maximize pass, we want to extend the cache section.
                    //  In all cases we restore the allocation size in the Scb and
                    //  recover the resident bit.
                    //

                    Scb->Header.AllocationSize.QuadPart = ScbSnapshot->AllocationSize;

                    ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );
                    SetFlag( Scb->ScbState,
                             FlagOn( ScbSnapshot->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ));

                    //
                    //  Calculate FastIoPossible
                    //

                    if (Scb->CompressionUnit != 0) {
                        NtfsAcquireFsrtlHeader( Scb );
                        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                        NtfsReleaseFsrtlHeader( Scb );
                    }
                }

                NtfsAcquireFsrtlHeader( Scb );
                if (Higher ?
                    (ScbSnapshot->FileSize > Scb->Header.FileSize.QuadPart) :
                    (ScbSnapshot->FileSize < Scb->Header.FileSize.QuadPart)) {

                    Scb->Header.FileSize.QuadPart = ScbSnapshot->FileSize;

                    //
                    //  We really only need to update Cc if FileSize changes,
                    //  since he does not look at ValidDataLength, and he
                    //  only cares about successfully reached highwatermarks
                    //  on AllocationSize (making section big enough).
                    //
                    //  Note that setting this flag TRUE also implies we
                    //  are correctly synchronized with FileSize!
                    //

                    UpdateCc = TRUE;
                }

                if (Higher == (ScbSnapshot->ValidDataLength >
                               Scb->Header.ValidDataLength.QuadPart)) {

                    Scb->Header.ValidDataLength.QuadPart = ScbSnapshot->ValidDataLength;
                }

                ASSERT( (Scb->Header.ValidDataLength.QuadPart <= Scb->Header.FileSize.QuadPart) ||
                        (Scb->Header.ValidDataLength.QuadPart == MAXLONGLONG) );

                //
                //  If this is the unnamed data attribute, we have to update
                //  some Fcb fields for standard information as well.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                    Scb->Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
                }

                NtfsReleaseFsrtlHeader( Scb );
            }

            if (!Higher) {

                Scb->ValidDataToDisk = ScbSnapshot->ValidDataToDisk;

                //
                //  We always truncate the Mcb to the original allocation size.
                //  If the Mcb has shrunk beyond this, this becomes a noop.
                //  If the file is resident, then we will uninitialize
                //  and reinitialize the Mcb.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                    //
                    //  Remove all of the mappings in the Mcb.
                    //

                    NtfsUnloadNtfsMcbRange( &Scb->Mcb, (LONGLONG)0, MAXLONGLONG, FALSE, FALSE );

                    //
                    //  If we attempted a convert a data attribute to non-
                    //  resident and failed then need to nuke the pages in the
                    //  section if this is not a user file.  This is because for
                    //  resident system attributes we always update the attribute
                    //  directly and don't want to reference stale data in the
                    //  section if we do a convert to non-resident later.
                    //

                    if (Scb->AttributeTypeCode != $DATA) {

                        if (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL) {

                            //
                            //  If we're not synchronized with the lazy writer, we shouldn't
                            //  be attempting this purge.  Otherwise there's a potential for
                            //  deadlock when this thread waits on the active count, while the
                            //  thread trying to get rid of his reference is waiting for the
                            //  main resource on this scb.
                            //

                            ASSERT( (Scb->Header.PagingIoResource == NULL) ||
                                    NtfsIsExclusiveScbPagingIo( Scb ) );

                            if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                      NULL,
                                                      0,
                                                      FALSE )) {

                                ASSERTMSG( "Failed to purge Scb during restore\n", FALSE );
                            }
                        }

                        //
                        //  If the attribute is for non-user data
                        //  (which is not opened explicitly by a user), then we
                        //  want to modify this Scb so it won't be used again.
                        //  Set the sizes to zero, mark it as being initialized
                        //  and deleted and then change the attribute type code
                        //  so we won't ever return it via NtfsCreateScb.
                        //

                        if (IsListEmpty( &Scb->CcbQueue )) {

                            NtfsAcquireFsrtlHeader( Scb );
                            Scb->Header.AllocationSize =
                            Scb->Header.FileSize =
                            Scb->Header.ValidDataLength = Li0;
                            NtfsReleaseFsrtlHeader( Scb );
                            Scb->ValidDataToDisk = 0;

                            SetFlag( Scb->ScbState,
                                     SCB_STATE_FILE_SIZE_LOADED |
                                     SCB_STATE_HEADER_INITIALIZED |
                                     SCB_STATE_ATTRIBUTE_DELETED );

                            Scb->AttributeTypeCode = $UNUSED;
                        }
                    }

                //
                //  If we have modified this Mcb and want to back out any
                //  changes then truncate the Mcb.  Don't do the Mft, because
                //  that is handled elsewhere.
                //

                } else if ((ScbSnapshot->LowestModifiedVcn != MAXLONGLONG) &&
                           (Scb != Vcb->MftScb)) {

                    //
                    //  Truncate the Mcb.
                    //

                    NtfsUnloadNtfsMcbRange( &Scb->Mcb, ScbSnapshot->LowestModifiedVcn, ScbSnapshot->HighestModifiedVcn, FALSE, FALSE );
                }

                Scb->TotalAllocated = ScbSnapshot->TotalAllocated;

            } else {

                //
                //  Set the flag to indicate that we're performing a restore on this
                //  Scb.  We don't want to write any new log records as a result of
                //  this operation other than the abort records.
                //

                SetFlag( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY );
            }

            //
            //  Be sure to update Cache Manager.  The interface here uses a file
            //  object but the routine itself only uses the section object pointers.
            //  We put a pointer to the segment object pointers on the stack and
            //  cast some prior value as a file object pointer.
            //

            PseudoFileObject = (PFILE_OBJECT) CONTAINING_RECORD( &SectionObjectPointer,
                                                                 FILE_OBJECT,
                                                                 SectionObjectPointer );
            PseudoFileObject->SectionObjectPointer = &Scb->NonpagedScb->SegmentObject;

            //
            //  Now tell the cache manager the sizes.
            //
            //  If we fail in this call, we definitely want to charge on anyway.
            //  It should only fail if it tries to extend the section and cannot,
            //  in which case we do not care because we cannot need the extended
            //  part to the section anyway.  (This is probably the very error that
            //  is causing us to clean up in the first place!)
            //
            //  We don't need to make this call if the top level request is a
            //  paging Io write.
            //
            //  We only do this if there is a shared cache map for this stream.
            //  Otherwise CC will cause a flush to happen which could mess up
            //  the transaction and abort logic.
            //

            if (UpdateCc &&
                (IrpContext->OriginatingIrp == NULL ||
                 IrpContext->OriginatingIrp->Type != IO_TYPE_IRP ||
                 IrpContext->MajorFunction != IRP_MJ_WRITE ||
                 !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ))) {

                try {

                    NtfsSetBothCacheSizes( PseudoFileObject,
                                           (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                           Scb );

                } except(FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                                    EXCEPTION_EXECUTE_HANDLER :
                                    EXCEPTION_CONTINUE_SEARCH) {

                    NtfsMinimumExceptionProcessing( IrpContext );
                }
            }

            //
            //  If this is the unnamed data attribute, we have to update
            //  some Fcb fields for standard information as well.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
            }

            //
            //  We always clear the Scb deleted flag and the deleted flag in the Fcb
            //  unless this was a create new file operation which failed.  We recognize
            //  this by looking for the major Irp code in the IrpContext, and the
            //  deleted bit in the Fcb.
            //

            if (Scb->AttributeTypeCode != $UNUSED &&
                (IrpContext->MajorFunction != IRP_MJ_CREATE ||
                 !FlagOn( Scb->Fcb->FcbState, FCB_STATE_FILE_DELETED ))) {

                ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                ClearFlag( Scb->Fcb->FcbState, FCB_STATE_FILE_DELETED );
            }

            //
            //  Clear the flags in the Scb if this Scb is from a create
            //  that failed.  We always clear our RESTORE_UNDERWAY flag.
            //
            //  If this is an Index allocation or Mft bitmap, then we
            //  store MAXULONG in the record allocation context to indicate
            //  that we should reinitialize it.
            //

            if (!Higher) {

                ClearFlag( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY );

                if (FlagOn( Scb->ScbState, SCB_STATE_UNINITIALIZE_ON_RESTORE )) {

                    ClearFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED |
                                              SCB_STATE_HEADER_INITIALIZED |
                                              SCB_STATE_UNINITIALIZE_ON_RESTORE );
                }

                //
                //  If this is the MftScb we have several jobs to do.
                //
                //      - Force the record allocation context to be reinitialized
                //      - Back out the changes to the Vcb->MftFreeRecords field
                //      - Back changes to the Vcb->MftHoleRecords field
                //      - Clear the flag indicating we allocated file record 15
                //      - Clear the flag indicating we reserved a record
                //      - Remove any clusters added to the Scb Mcb
                //      - Restore any clusters removed from the Scb Mcb
                //

                if (Scb == Vcb->MftScb) {

                    ULONG RunIndex;
                    VCN Vcn;
                    LCN Lcn;
                    LONGLONG Clusters;

                    Scb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
                    (LONG) Vcb->MftFreeRecords -= Scb->ScbType.Mft.FreeRecordChange;
                    (LONG) Vcb->MftHoleRecords -= Scb->ScbType.Mft.HoleRecordChange;

                    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_15_USED )) {

                        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_15_USED );
                        ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED );
                    }

                    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED )) {

                        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
                        ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );

                        Scb->ScbType.Mft.ReservedIndex = 0;
                    }

                    RunIndex = 0;

                    while (FsRtlGetNextLargeMcbEntry( &Scb->ScbType.Mft.AddedClusters,
                                                      RunIndex,
                                                      &Vcn,
                                                      &Lcn,
                                                      &Clusters )) {

                        if (Lcn != UNUSED_LCN) {

                            NtfsRemoveNtfsMcbEntry( &Scb->Mcb, Vcn, Clusters );
                        }

                        RunIndex += 1;
                    }

                    RunIndex = 0;

                    while (FsRtlGetNextLargeMcbEntry( &Scb->ScbType.Mft.RemovedClusters,
                                                      RunIndex,
                                                      &Vcn,
                                                      &Lcn,
                                                      &Clusters )) {

                        if (Lcn != UNUSED_LCN) {

                            NtfsAddNtfsMcbEntry( &Scb->Mcb, Vcn, Lcn, Clusters, FALSE );
                        }

                        RunIndex += 1;
                    }

                } else if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

                    Scb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
                }
            }

            //
            //  Decrement the cleanup count to restore the previous value.
            //

            InterlockedDecrement( &Scb->CleanupCount );

            ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

        } while (ScbSnapshot != &IrpContext->ScbSnapshot);
    }
}


VOID
NtfsMungeScbSnapshot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileSize
    )

/*++

Routine Description:

    This routine is called to modify the Scb snapshot when we need the snapshot to
    have different values than the Scb when it was acquired.  One case is when NtfsCommonWrite
    updates the file size in the Scb for the duration of the transaction.

Arguments:

    Scb - Scb whose snapshot should be updated.  There should always be a snapshot here.

    FileSize - Value for file size to store in the snapshot.  Also check that valid data and
        ValidDataToDisk are not larger than this value.

Return Value:

    None

--*/

{
    //
    //  We should have a snapshot in most cases but if not build it now.
    //

    if (Scb->ScbSnapshot == NULL) {

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
        }

        NtfsSnapshotScb( IrpContext, Scb );

        ASSERT( Scb->ScbSnapshot != NULL );
    }

    NtfsAcquireFsrtlHeader( Scb );

    Scb->ScbSnapshot->FileSize = FileSize;

    if (Scb->ScbSnapshot->ValidDataLength > FileSize) {
        Scb->ScbSnapshot->ValidDataLength = FileSize;
    }

    if (Scb->ScbSnapshot->ValidDataToDisk > FileSize) {
        Scb->ScbSnapshot->ValidDataToDisk = FileSize;
    }

    NtfsVerifySizes( &Scb->Header );

    NtfsReleaseFsrtlHeader( Scb );

    return;
}


VOID
NtfsFreeSnapshotsForFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine restores snapshot Scb data in the event of an aborted request.

Arguments:

    Fcb - Fcb for which all snapshots are to be freed, or NULL to free all
          snapshots.

Return Value:

    None

--*/

{
    PSCB_SNAPSHOT ScbSnapshot;

    ASSERT(FIELD_OFFSET(SCB_SNAPSHOT, SnapshotLinks) == 0);

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  There is no snapshot data to free if the Flink is still NULL.
    //  We also don't free the snapshot if this isn't a top-level action.
    //

    if (ScbSnapshot->SnapshotLinks.Flink != NULL) {

        //
        //  Loop to free first the Scb data from the snapshot in the
        //  IrpContext, and then 0 or more additional snapshots linked
        //  to the IrpContext.
        //

        do {

            PSCB_SNAPSHOT NextScbSnapshot;

            //
            //  Move to next snapshot before we delete the current one.
            //

            NextScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

            //
            //  We are now at a snapshot in the snapshot list.  We skip
            //  over this entry if it has an Scb and the Fcb for that
            //  Scb does not match the input Fcb.  If there is no
            //  input Fcb we always deal with this snapshot.
            //

            if (ScbSnapshot->Scb != NULL
                && Fcb != NULL
                && ScbSnapshot->Scb->Fcb != Fcb) {

                ScbSnapshot = NextScbSnapshot;
                continue;
            }

            //
            //  If there is an Scb, then clear its snapshot pointer.
            //  Always clear the UNINITIALIZE_ON_RESTORE flag, RESTORE_UNDERWAY, PROTECT_SPARSE_MCB and
            //  CONVERT_UNDERWAY flags.
            //

            if (ScbSnapshot->Scb != NULL) {

                //
                //  Check if there is any special processing we need to do for the Scb based on the state.
                //  Do a single test now and then retest below to reduce the work in the mainline path.
                //

                if (FlagOn( ScbSnapshot->Scb->ScbState,
                            (SCB_STATE_UNINITIALIZE_ON_RESTORE |
                             SCB_STATE_RESTORE_UNDERWAY |
                             SCB_STATE_PROTECT_SPARSE_MCB |
                             SCB_STATE_CONVERT_UNDERWAY |
                             SCB_STATE_ATTRIBUTE_DELETED))) {

                    //
                    //  If the attribute is deleted and the type is a user logged stream then
                    //  mark the Scb as type $UNUSED to keep us from ever accessing it again.
                    //

                    if ((ScbSnapshot->Scb->AttributeTypeCode == $LOGGED_UTILITY_STREAM ) &&
                        FlagOn( ScbSnapshot->Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                        ScbSnapshot->Scb->AttributeTypeCode = $UNUSED;
                    }

                    //
                    //  Clear the state flags which indicate whether there is a transitional change
                    //  underway.
                    //

                    if (FlagOn( ScbSnapshot->Scb->ScbState,
                                (SCB_STATE_UNINITIALIZE_ON_RESTORE |
                                 SCB_STATE_RESTORE_UNDERWAY |
                                 SCB_STATE_PROTECT_SPARSE_MCB |
                                 SCB_STATE_CONVERT_UNDERWAY ))) {

                        NtfsAcquireFsrtlHeader( ScbSnapshot->Scb );
                        ClearFlag( ScbSnapshot->Scb->ScbState,
                                   SCB_STATE_UNINITIALIZE_ON_RESTORE | SCB_STATE_RESTORE_UNDERWAY | SCB_STATE_PROTECT_SPARSE_MCB | SCB_STATE_CONVERT_UNDERWAY );
                        NtfsReleaseFsrtlHeader( ScbSnapshot->Scb );
                    }
                }

                ScbSnapshot->Scb->ScbSnapshot = NULL;
            }

            if (ScbSnapshot == &IrpContext->ScbSnapshot) {

                IrpContext->ScbSnapshot.Scb = NULL;

            //
            //  Else delete the snapshot structure
            //

            } else {

                RemoveEntryList(&ScbSnapshot->SnapshotLinks);

                ExFreeToNPagedLookasideList( &NtfsScbSnapshotLookasideList, ScbSnapshot );
            }

            ScbSnapshot = NextScbSnapshot;

        } while (ScbSnapshot != &IrpContext->ScbSnapshot);
    }
}


BOOLEAN
NtfsCreateFileLock (
    IN PSCB Scb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine is called to create and initialize a file lock structure.
    A try-except is used to catch allocation failures if the caller doesn't
    want the exception raised.

Arguments:

    Scb - Supplies the Scb to attach the file lock to.

    RaiseOnError - If TRUE then don't catch the allocation failure.

Return Value:

    TRUE if the lock is allocated and initialized.  FALSE if there is an
    error and the caller didn't specify RaiseOnError.

--*/

{
    PFILE_LOCK FileLock = NULL;
    BOOLEAN Success = TRUE;

    PAGED_CODE();

    FileLock = FsRtlAllocateFileLock( NULL, NULL );

    if (FileLock != NULL) {

        //
        //  Use the FsRtl header mutex to synchronize storing
        //  the lock structure, and only store it if no one
        //  else beat us.
        //

        NtfsAcquireFsrtlHeader(Scb);

        if (Scb->ScbType.Data.FileLock == NULL) {
            Scb->ScbType.Data.FileLock = FileLock;
            FileLock = NULL;
        }

        NtfsReleaseFsrtlHeader(Scb);

        if (FileLock != NULL) {
            FsRtlFreeFileLock( FileLock );
        }

    } else {

        //
        //  Fail appropriately.
        //

        if (RaiseOnError) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        Success = FALSE;
    }

    return Success;
}


PSCB
NtfsGetNextScb (
    IN PSCB Scb,
    IN PSCB TerminationScb
    )

/*++

Routine Description:

    This routine is used to iterate through Scbs in a tree.

    The rules are:

        . If you have a child, go to it, else
        . If you have a next sibling, go to it, else
        . Go to your parent's next sibling.

    If this routine is called with in invalid TerminationScb it will fail,
    badly.

Arguments:

    Scb - Supplies the current Scb

    TerminationScb - The Scb at which the enumeration should (non-inclusively)
        stop.  Assumed to be a directory.

Return Value:

    The next Scb in the enumeration, or NULL if Scb was the final one.

--*/

{
    PSCB Results;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetNextScb, Scb = %08lx, TerminationScb = %08lx\n", Scb, TerminationScb) );

    //
    //  If this is an index (i.e., not a file) and it has children then return
    //  the scb for the first child
    //
    //                  Scb
    //
    //                 /   \.
    //                /     \.
    //
    //           ChildLcb
    //
    //              |
    //              |
    //
    //           ChildFcb
    //
    //            /   \.
    //           /     \.
    //
    //       Results
    //

    if (((SafeNodeType(Scb) == NTFS_NTC_SCB_INDEX) || (SafeNodeType(Scb) == NTFS_NTC_SCB_ROOT_INDEX))

                &&

         !IsListEmpty(&Scb->ScbType.Index.LcbQueue)) {

        PLCB ChildLcb;
        PFCB ChildFcb;

        //
        //  locate the first lcb out of this scb and also the corresponding fcb
        //

        ChildLcb = NtfsGetNextChildLcb(Scb, NULL);
        ChildFcb = ChildLcb->Fcb;

        //
        //  Then as a bookkeeping means for ourselves we will move this
        //  lcb to the head of the fcb's lcb queue that way when we
        //  need to ask which link we went through to get here we will know
        //

        RemoveEntryList( &ChildLcb->FcbLinks );
        InsertHeadList( &ChildFcb->LcbQueue, &ChildLcb->FcbLinks );

        //
        //  And our return value is the first scb of this fcb
        //

        ASSERT( !IsListEmpty(&ChildFcb->ScbQueue) );

        //
        //  Acquire and drop the Fcb in order to look at the Scb list.
        //

        ExAcquireResourceExclusiveLite( ChildFcb->Resource, TRUE );
        Results = NtfsGetNextChildScb( ChildFcb, NULL );
        ExReleaseResourceLite( ChildFcb->Resource );

    //
    //  We could be processing an empty index
    //

    } else if ( Scb == TerminationScb ) {

        Results = NULL;

    } else {

        PSCB SiblingScb;
        PFCB ParentFcb;
        PLCB ParentLcb;
        PLCB SiblingLcb;
        PFCB SiblingFcb;

        //
        //  Acquire and drop the Fcb in order to look at the Scb list.
        //

        ExAcquireResourceExclusiveLite( Scb->Fcb->Resource, TRUE );
        SiblingScb = NtfsGetNextChildScb( Scb->Fcb, Scb );
        ExReleaseResourceLite( Scb->Fcb->Resource );

        while (TRUE) {

            //
            //  If there is a sibling scb to the input scb then return it
            //
            //                Fcb
            //
            //               /   \.
            //              /     \.
            //
            //            Scb   Sibling
            //                    Scb
            //

            if (SiblingScb != NULL) {

                Results = SiblingScb;
                break;
            }

            //
            //  The scb doesn't have any more siblings.  See if our fcb has a sibling
            //
            //                           S
            //
            //                         /   \.
            //                        /     \.
            //
            //               ParentLcb     SiblingLcb
            //
            //                   |             |
            //                   |             |
            //
            //               ParentFcb     SiblingFcb
            //
            //                /             /     \.
            //               /             /       \.
            //
            //             Scb         Results
            //
            //  It's possible that the SiblingFcb has already been traversed.
            //  Consider the case where there are multiple links between the
            //  same Scb and Fcb.  We want to ignore this case or else face
            //  an infinite loop by moving the Lcb to the beginning of the
            //  Fcb queue and then later finding an Lcb that we have already
            //  traverse.  We use the fact that we haven't modified the
            //  ordering of the Lcb off the parent Scb.  When we find a
            //  candidate for the next Fcb, we walk backwards through the
            //  list of Lcb's off the Scb to make sure this is not a
            //  duplicate Fcb.
            //

            ParentFcb = Scb->Fcb;

            ParentLcb = NtfsGetNextParentLcb(ParentFcb, NULL);

            //
            //  Try to find a sibling Lcb which does not point to an Fcb
            //  we've already visited.
            //

            SiblingLcb = ParentLcb;

            while ((SiblingLcb = NtfsGetNextChildLcb( ParentLcb->Scb, SiblingLcb)) != NULL) {

                PLCB PrevChildLcb;
                PFCB PotentialSiblingFcb;

                //
                //  Now walk through the child Lcb's of the Scb which we have
                //  already visited.
                //

                PrevChildLcb = SiblingLcb;
                PotentialSiblingFcb = SiblingLcb->Fcb;

                //
                //  Skip this Lcb if the Fcb has no children.
                //

                if (IsListEmpty( &PotentialSiblingFcb->ScbQueue )) {

                    continue;
                }

                while ((PrevChildLcb = NtfsGetPrevChildLcb( ParentLcb->Scb, PrevChildLcb )) != NULL) {

                    //
                    //  If the parent Fcb and the Fcb for this Lcb are the same,
                    //  then we have already returned the Scb's for this Fcb.
                    //

                    if (PrevChildLcb->Fcb == PotentialSiblingFcb) {

                        break;
                    }
                }

                //
                //  If we don't have a PrevChildLcb, that means that we have a valid
                //  sibling Lcb.  We will ignore any sibling Lcb's whose
                //  Fcb's don't have any Scb's.
                //

                if (PrevChildLcb == NULL) {

                    break;
                }
            }

            if (SiblingLcb != NULL) {

                SiblingFcb = SiblingLcb->Fcb;

                //
                //  Then as a bookkeeping means for ourselves we will move this
                //  lcb to the head of the fcb's lcb queue that way when we
                //  need to ask which link we went through to get here we will know
                //

                RemoveEntryList( &SiblingLcb->FcbLinks );
                InsertHeadList( &SiblingFcb->LcbQueue, &SiblingLcb->FcbLinks );

                //
                //  And our return value is the first scb of this fcb
                //

                ASSERT( !IsListEmpty(&SiblingFcb->ScbQueue) );

                //
                //  Acquire and drop the Fcb in order to look at the Scb list.
                //

                ExAcquireResourceExclusiveLite( SiblingFcb->Resource, TRUE );
                Results = NtfsGetNextChildScb( SiblingFcb, NULL );
                ExReleaseResourceLite( SiblingFcb->Resource );
                break;
            }

            //
            //  The Fcb has no sibling so bounce up one and see if we
            //  have reached our termination scb yet
            //
            //                          NewScb
            //
            //                         /
            //                        /
            //
            //               ParentLcb
            //
            //                   |
            //                   |
            //
            //               ParentFcb
            //
            //                /
            //               /
            //
            //             Scb
            //
            //

            Scb = ParentLcb->Scb;

            if (Scb == TerminationScb) {

                Results = NULL;
                break;
            }

            //
            //  Acquire and drop the Fcb in order to look at the Scb list.
            //

            ExAcquireResourceExclusiveLite( Scb->Fcb->Resource, TRUE );
            SiblingScb = NtfsGetNextChildScb( Scb->Fcb, Scb );
            ExReleaseResourceLite( Scb->Fcb->Resource );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsGetNextScb -> %08lx\n", Results) );

    return Results;
}


PLCB
NtfsCreateLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN UNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN OUT PBOOLEAN ReturnedExistingLcb OPTIONAL
    )

/*++

Routine Description:

    This routine allocates and creates a new lcb between an
    existing scb and fcb.  If a component of the exact
    name already exists we return that one instead of creating
    a new lcb

Arguments:

    Scb - Supplies the parent scb to use

    Fcb - Supplies the child fcb to use

    LastComponentFileName - Supplies the last component of the
        path that this link represents

    FileNameFlags - Indicates if this is an NTFS, DOS or hard link

    ReturnedExistingLcb - Optionally tells the caller if the
        lcb returned already existed.  If specified and points to a
        FALSE value on entry then we won't create the new Lcb.

Return Value:

    LCB - returns a pointer the newly created lcb.  NULL if our caller doesn't
        want to create an Lcb and it didn't already exist.

--*/

{
    PLCB Lcb = NULL;
    BOOLEAN LocalReturnedExistingLcb = TRUE;

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage[2] = { NULL, NULL };

    PAGED_CODE();
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_FCB( Fcb );
    ASSERT(NodeType(Scb) != NTFS_NTC_SCB_DATA);

    DebugTrace( +1, Dbg, ("NtfsCreateLcb...\n") );

    if (!ARGUMENT_PRESENT(ReturnedExistingLcb)) { ReturnedExistingLcb = &LocalReturnedExistingLcb; }

    //
    //  Search the lcb children of the input Scb to see if we have an Lcb that matches
    //  this one.  We match if the Lcb points to the same fcb and the last component file name
    //  and flags match.  We ignore any Lcb's that indicate links that have been
    //  removed.
    //

    Lcb = NULL;

    while ((Lcb = NtfsGetNextParentLcb(Fcb, Lcb)) != NULL) {

        ASSERT_LCB( Lcb );

        if ((Scb == Lcb->Scb)

                &&

            (!FlagOn( Lcb->LcbState, LCB_STATE_LINK_IS_GONE ))

                &&

            (FileNameFlags == Lcb->FileNameAttr->Flags)

                &&

            (LastComponentFileName.Length == Lcb->ExactCaseLink.LinkName.Length)

                &&

            (RtlEqualMemory( LastComponentFileName.Buffer,
                             Lcb->ExactCaseLink.LinkName.Buffer,
                             LastComponentFileName.Length ) )) {

            *ReturnedExistingLcb = TRUE;

            DebugTrace( -1, Dbg, ("NtfsCreateLcb -> %08lx\n", Lcb) );

            return Lcb;
        }
    }

    //
    //  If our caller does not want us to create a new Lcb then return FALSE.
    //

    if (!(*ReturnedExistingLcb)) {

        DebugTrace( -1, Dbg, ("NtfsCreateLcb -> %08lx\n", NULL) );

        return NULL;
    }

    *ReturnedExistingLcb = FALSE;

    try {

        UCHAR MaxNameLength;

        //
        //  Allocate a new lcb, zero it out and set the node type information
        //  Check if we can allocate the Lcb out of a compound Fcb.  Check here if
        //  we can use the embedded name as well.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_DATA) &&
            (SafeNodeType( &((PFCB_DATA) Fcb)->Lcb ) == 0)) {

            Lcb = (PLCB) &((PFCB_DATA) Fcb)->Lcb;
            MaxNameLength = MAX_DATA_FILE_NAME;

        } else if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
            (SafeNodeType( &((PFCB_INDEX) Fcb)->Lcb ) == 0)) {

            Lcb = (PLCB) &((PFCB_INDEX) Fcb)->Lcb;
            MaxNameLength = MAX_INDEX_FILE_NAME;

        } else {

            Lcb = UnwindStorage[0] = ExAllocateFromPagedLookasideList( &NtfsLcbLookasideList );
            MaxNameLength = 0;
        }

        RtlZeroMemory( Lcb, sizeof(LCB) );

        Lcb->NodeTypeCode = NTFS_NTC_LCB;
        Lcb->NodeByteSize = sizeof(LCB);

        //
        //  Check if we will have to allocate a separate filename attr.
        //

        if (MaxNameLength < (USHORT) (LastComponentFileName.Length / sizeof( WCHAR ))) {

            //
            //  Allocate the last component part of the lcb and copy over the data.
            //  Check if there is space in the Fcb for this.
            //

            Lcb->FileNameAttr =
            UnwindStorage[1] = NtfsAllocatePool(PagedPool, LastComponentFileName.Length +
                                                      NtfsFileNameSizeFromLength( LastComponentFileName.Length ));

            MaxNameLength = (UCHAR)(LastComponentFileName.Length / sizeof( WCHAR ));

        } else {

            Lcb->FileNameAttr = (PFILE_NAME) &Lcb->ParentDirectory;
        }

        Lcb->FileNameAttr->ParentDirectory = Scb->Fcb->FileReference;
        Lcb->FileNameAttr->FileNameLength = (UCHAR) (LastComponentFileName.Length / sizeof( WCHAR ));
        Lcb->FileNameAttr->Flags = FileNameFlags;

        Lcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &Lcb->FileNameAttr->FileName;

        Lcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( Lcb->FileNameAttr,
                                                       NtfsFileNameSizeFromLength( MaxNameLength * sizeof( WCHAR )));

        Lcb->ExactCaseLink.LinkName.Length =
        Lcb->IgnoreCaseLink.LinkName.Length = LastComponentFileName.Length;

        Lcb->ExactCaseLink.LinkName.MaximumLength =
        Lcb->IgnoreCaseLink.LinkName.MaximumLength = MaxNameLength * sizeof( WCHAR );

        RtlCopyMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                       LastComponentFileName.Buffer,
                       LastComponentFileName.Length );

        RtlCopyMemory( Lcb->IgnoreCaseLink.LinkName.Buffer,
                       LastComponentFileName.Buffer,
                       LastComponentFileName.Length );

        NtfsUpcaseName( IrpContext->Vcb->UpcaseTable,
                        IrpContext->Vcb->UpcaseTableSize,
                        &Lcb->IgnoreCaseLink.LinkName );

        //
        //  Now put this Lcb into the queues for the scb and the fcb
        //

        InsertTailList( &Scb->ScbType.Index.LcbQueue, &Lcb->ScbLinks );
        Lcb->Scb = Scb;

        InsertTailList( &Fcb->LcbQueue, &Lcb->FcbLinks );
        Lcb->Fcb = Fcb;

        //
        //  Now initialize the ccb queue.
        //

        InitializeListHead( &Lcb->CcbQueue );

    } finally {

        DebugUnwind( NtfsCreateLcb );

        if (AbnormalTermination()) {

            if (UnwindStorage[0]) { NtfsFreePool( UnwindStorage[0] );
            } else if (Lcb != NULL) { Lcb->NodeTypeCode = 0; }
            if (UnwindStorage[1]) { NtfsFreePool( UnwindStorage[1] ); }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateLcb -> %08lx\n", Lcb) );

    return Lcb;
}


VOID
NtfsDeleteLcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PLCB *Lcb
    )

/*++

Routine Description:

    This routine deallocated and removes the lcb record from Ntfs's in-memory
    data structures.  It assumes that the ccb queue is empty.  We also assume
    that this is not the root lcb that we are trying to delete.

Arguments:

    Lcb - Supplise the Lcb to be removed

Return Value:

    None.

--*/

{
    PCCB Ccb;
    PLIST_ENTRY Links;

    PAGED_CODE();
    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace( +1, Dbg, ("NtfsDeleteLcb, *Lcb = %08lx\n", *Lcb) );

    //
    //  Get rid of any prefixes that might still be attached to us
    //

    NtfsRemovePrefix( (*Lcb) );

    //
    //  Remove any hash table entries for this Lcb.
    //

    NtfsRemoveHashEntriesForLcb( *Lcb );

    //
    //  Walk through the Ccb's for this link and clear the Lcb
    //  pointer.  This can only be for Ccb's which there is no
    //  more user handle.
    //

    Links = (*Lcb)->CcbQueue.Flink;

    while (Links != &(*Lcb)->CcbQueue) {

        Ccb = CONTAINING_RECORD( Links,
                                 CCB,
                                 LcbLinks );

        Links = Links->Flink;
        NtfsUnlinkCcbFromLcb( IrpContext, Ccb );
    }

    //
    //
    //  Now remove ourselves from our scb and fcb
    //

    RemoveEntryList( &(*Lcb)->ScbLinks );
    RemoveEntryList( &(*Lcb)->FcbLinks );

    //
    //  Free up the last component part and then free ourselves
    //

    if ((*Lcb)->FileNameAttr != (PFILE_NAME) &(*Lcb)->ParentDirectory) {

        NtfsFreePool( (*Lcb)->FileNameAttr );
        DebugDoit( (*Lcb)->FileNameAttr = NULL );
    }

    //
    //  Check if we are part of an embedded structure otherwise free back to the
    //  lookaside list
    //

    if (((*Lcb) == (PLCB) &((PFCB_DATA) (*Lcb)->Fcb)->Lcb) ||
        ((*Lcb) == (PLCB) &((PFCB_INDEX) (*Lcb)->Fcb)->Lcb)) {

#ifdef KEITHKADBG
        RtlZeroMemory( *Lcb, sizeof( LCB ) );
#endif

        (*Lcb)->NodeTypeCode = 0;

    } else {

#ifdef KEITHKADBG
        RtlZeroMemory( *Lcb, sizeof( LCB ) );
#endif

        ExFreeToPagedLookasideList( &NtfsLcbLookasideList, *Lcb );
    }

    //
    //  And for safety sake null out the pointer
    //

    *Lcb = NULL;

    DebugTrace( -1, Dbg, ("NtfsDeleteLcb -> VOID\n") );

    return;
}


VOID
NtfsMoveLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PUNICODE_STRING TargetDirectoryName,
    IN PUNICODE_STRING LastComponentName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    )

/*++

Routine Description:

    This routine completely moves the input lcb to join different fcbs and
    scbs.  It hasIt uses the target directory
    file object to supply the complete new name to use.

Arguments:

    Lcb - Supplies the Lcb being moved.

    Scb - Supplies the new parent scb

    Fcb - Supplies the new child fcb

    TargetDirectoryName - This is the path used to reach the new parent directory
        for this Lcb.  It will only be from the root.

    LastComponentName - This is the last component name to store in this relocated Lcb.

    FileNameFlags - Indicates if this is an NTFS, DOS or hard link

    CheckBufferSizeOnly - If TRUE we just want to pass through and verify that
        the buffer sizes of the various structures will be large enough for the
        new name.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;
    ULONG BytesNeeded;
    PVOID NewAllocation;
    PCHAR NextChar;

    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );
    ASSERT_SCB( Scb );
    ASSERT_FCB( Fcb );
    ASSERT( NodeType( Scb ) != NTFS_NTC_SCB_DATA );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMoveLcb, Lcb = %08lx\n", Lcb) );

    //
    //  If we're not just checking sizes then remove entries from the prefix table
    //  and the normalized name for descendents of the current scb.
    //

    if (!CheckBufferSizeOnly) {

        NtfsClearRecursiveLcb ( Lcb );
    }

    //
    //  Remember the number of bytes needed for the last component.
    //

    BytesNeeded = LastComponentName->Length;

    //
    //  Check if we need to allocate a new filename attribute.  If so allocate
    //  it and store it into the new allocation buffer.
    //

    if (Lcb->ExactCaseLink.LinkName.MaximumLength < BytesNeeded) {

        NewAllocation = NtfsAllocatePool( PagedPool,
                                          BytesNeeded + NtfsFileNameSizeFromLength( BytesNeeded ));

        //
        //  Set up the existing names into the new buffer.  That way if we have an allocation
        //  failure below with the Ccb's the Lcb is still in a valid state.
        //

        RtlCopyMemory( NewAllocation,
                       Lcb->FileNameAttr,
                       NtfsFileNameSizeFromLength( Lcb->ExactCaseLink.LinkName.MaximumLength ));

        RtlCopyMemory( Add2Ptr( NewAllocation, NtfsFileNameSizeFromLength( BytesNeeded )),
                       Lcb->IgnoreCaseLink.LinkName.Buffer,
                       Lcb->IgnoreCaseLink.LinkName.MaximumLength );

        if (Lcb->FileNameAttr != (PFILE_NAME) &Lcb->ParentDirectory) {

            NtfsFreePool( Lcb->FileNameAttr );
        }

        Lcb->FileNameAttr = NewAllocation;

        Lcb->ExactCaseLink.LinkName.MaximumLength =
        Lcb->IgnoreCaseLink.LinkName.MaximumLength = (USHORT) BytesNeeded;

        Lcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &Lcb->FileNameAttr->FileName;
        Lcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( Lcb->FileNameAttr,
                                                       NtfsFileNameSizeFromLength( BytesNeeded ));
    }

    //
    //  Compute the full length of the name for the CCB, assume we will need a
    //  separator.
    //

    BytesNeeded = TargetDirectoryName->Length + sizeof( WCHAR );

    //
    //  Now for every ccb attached to us we need to check if we need a new
    //  filename buffer.
    //

    NtfsReserveCcbNamesInLcb( IrpContext, Lcb, &BytesNeeded, LastComponentName->Length );

    //
    //  Add back in the last component.
    //

    BytesNeeded += LastComponentName->Length;

    //
    //  Now update the Lcb with the new values if we are to rewrite the buffers.
    //

    if (!CheckBufferSizeOnly) {

        Lcb->FileNameAttr->ParentDirectory = Scb->Fcb->FileReference;
        Lcb->FileNameAttr->FileNameLength = (UCHAR) (LastComponentName->Length / sizeof( WCHAR ));
        Lcb->FileNameAttr->Flags = FileNameFlags;

        Lcb->ExactCaseLink.LinkName.Length =
        Lcb->IgnoreCaseLink.LinkName.Length = (USHORT) LastComponentName->Length;

        RtlCopyMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                       LastComponentName->Buffer,
                       LastComponentName->Length );

        RtlCopyMemory( Lcb->IgnoreCaseLink.LinkName.Buffer,
                       LastComponentName->Buffer,
                       LastComponentName->Length );

        NtfsUpcaseName( IrpContext->Vcb->UpcaseTable,
                        IrpContext->Vcb->UpcaseTableSize,
                        &Lcb->IgnoreCaseLink.LinkName );

        //
        //  Now for every ccb attached to us we need to munge it file object name by
        //  copying over the entire new name
        //

        Ccb = NULL;
        while ((Ccb = NtfsGetNextCcb(Lcb, Ccb)) != NULL) {

            //
            //  We ignore any Ccb's which are associated with open by File Id
            //  file objects or their file objects have gone through cleanup.
            //  Lock and unlock the Fcb to serialize access to the close flag.
            //

            NtfsLockFcb( IrpContext, Ccb->Lcb->Fcb );
            if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID | CCB_FLAG_CLOSE )) {

                Ccb->FullFileName.Length = (USHORT) BytesNeeded;
                NextChar = (PCHAR) Ccb->FullFileName.Buffer;

                RtlCopyMemory( NextChar,
                               TargetDirectoryName->Buffer,
                               TargetDirectoryName->Length );

                NextChar += TargetDirectoryName->Length;

                if (TargetDirectoryName->Length != sizeof( WCHAR )) {

                    *((PWCHAR) NextChar) = L'\\';
                    NextChar += sizeof( WCHAR );

                } else {

                    Ccb->FullFileName.Length -= sizeof( WCHAR );
                }

                RtlCopyMemory( NextChar,
                               LastComponentName->Buffer,
                               LastComponentName->Length );

                Ccb->LastFileNameOffset = (USHORT) (Ccb->FullFileName.Length - LastComponentName->Length);
            }

            NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
        }

        //
        //  Now dequeue ourselves from our old scb and fcb and put us in the
        //  new fcb and scb queues.
        //

        RemoveEntryList( &Lcb->ScbLinks );
        RemoveEntryList( &Lcb->FcbLinks );

        InsertTailList( &Scb->ScbType.Index.LcbQueue, &Lcb->ScbLinks );
        Lcb->Scb = Scb;

        InsertTailList( &Fcb->LcbQueue, &Lcb->FcbLinks );
        Lcb->Fcb = Fcb;
    }

    //
    //  And return to our caller
    //


    return;
}


VOID
NtfsRenameLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PUNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    )

/*++

Routine Description:

    This routine changes the last component name of the input lcb
    It also walks through the opened ccb and munges their names and
    also removes the lcb from the prefix table

Arguments:

    Lcb - Supplies the Lcb being renamed

    LastComponentFileName - Supplies the new last component to use
        for the lcb name

    FileNameFlags - Indicates if this is an NTFS, DOS or hard link

    CheckBufferSizeOnly - If TRUE we just want to pass through and verify that
        the buffer sizes of the various structures will be large enough for the
        new name.


Return Value:

    None.

--*/

{
    PVCB Vcb = Lcb->Fcb->Vcb;
    ULONG BytesNeeded;
    PVOID NewAllocation;

    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );

    PAGED_CODE();

    //
    //  If we're not just checking sizes then remove entries from the prefix table
    //  and the normalized name for descendents of the current scb.
    //

    if (!CheckBufferSizeOnly) {

        NtfsClearRecursiveLcb ( Lcb );
    }

    //
    //  Remember the number of bytes needed for the last component.
    //

    BytesNeeded = LastComponentFileName->Length;

    //
    //  Check if we need to allocate a new filename attribute.  If so allocate
    //  it and store it into the new allocation buffer.
    //

    if (Lcb->ExactCaseLink.LinkName.MaximumLength < BytesNeeded) {

        NewAllocation = NtfsAllocatePool( PagedPool,
                                          BytesNeeded + NtfsFileNameSizeFromLength( BytesNeeded ));

        //
        //  Set up the existing names into the new buffer.  That way if we have an allocation
        //  failure below with the Ccb's the Lcb is still in a valid state.
        //

        RtlCopyMemory( NewAllocation,
                       Lcb->FileNameAttr,
                       NtfsFileNameSizeFromLength( Lcb->ExactCaseLink.LinkName.MaximumLength ));

        RtlCopyMemory( Add2Ptr( NewAllocation, NtfsFileNameSizeFromLength( BytesNeeded )),
                       Lcb->IgnoreCaseLink.LinkName.Buffer,
                       Lcb->IgnoreCaseLink.LinkName.MaximumLength );

        if (Lcb->FileNameAttr != (PFILE_NAME) &Lcb->ParentDirectory) {

            NtfsFreePool( Lcb->FileNameAttr );
        }

        Lcb->FileNameAttr = NewAllocation;

        Lcb->ExactCaseLink.LinkName.MaximumLength =
        Lcb->IgnoreCaseLink.LinkName.MaximumLength = (USHORT) BytesNeeded;

        Lcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &Lcb->FileNameAttr->FileName;
        Lcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( Lcb->FileNameAttr,
                                                       NtfsFileNameSizeFromLength( BytesNeeded ));
    }

    //
    //  Now for every ccb attached to us we need to check if we need a new
    //  filename buffer.
    //

    NtfsReserveCcbNamesInLcb( IrpContext, Lcb, NULL, BytesNeeded );

    //
    //  Now update the Lcb and Ccb's with the new values if we are to rewrite the buffers.
    //

    if (!CheckBufferSizeOnly) {

        BytesNeeded = LastComponentFileName->Length;

        Lcb->FileNameAttr->FileNameLength = (UCHAR) (BytesNeeded / sizeof( WCHAR ));
        Lcb->FileNameAttr->Flags = FileNameFlags;

        Lcb->ExactCaseLink.LinkName.Length =
        Lcb->IgnoreCaseLink.LinkName.Length = (USHORT) LastComponentFileName->Length;

        RtlCopyMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                       LastComponentFileName->Buffer,
                       BytesNeeded );

        RtlCopyMemory( Lcb->IgnoreCaseLink.LinkName.Buffer,
                       LastComponentFileName->Buffer,
                       BytesNeeded );

        NtfsUpcaseName( IrpContext->Vcb->UpcaseTable,
                        IrpContext->Vcb->UpcaseTableSize,
                        &Lcb->IgnoreCaseLink.LinkName );

        //
        //  Now for every ccb attached to us we need to munge it file object name by
        //  copying over the entire new name
        //

        Ccb = NULL;
        while ((Ccb = NtfsGetNextCcb(Lcb, Ccb)) != NULL) {

            //
            //  We ignore any Ccb's which are associated with open by File Id
            //  file objects.  We also ignore any Ccb's which don't have a file
            //  object pointer.  Lock and unlock the Fcb to serialize access
            //  to the close flag.
            //

            NtfsLockFcb( IrpContext, Ccb->Lcb->Fcb );
            if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID | CCB_FLAG_CLOSE )) {

                RtlCopyMemory( &Ccb->FullFileName.Buffer[ Ccb->LastFileNameOffset / sizeof( WCHAR ) ],
                               LastComponentFileName->Buffer,
                               BytesNeeded );

                Ccb->FullFileName.Length = Ccb->LastFileNameOffset + (USHORT) BytesNeeded;
            }
            NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
        }
    }

    return;
}


VOID
NtfsCombineLcbs (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB PrimaryLcb,
    IN PLCB AuxLcb
    )

/*++

Routine Description:

    This routine is called for the case where we have multiple Lcb's for a
    file which connect to the same Scb.  We are performing a link rename
    operation which causes the links to be combined and we need to
    move all of the Ccb's to the same Lcb.  This routine will be called only
    after the names have been munged so that they are identical.
    (i.e. call NtfsRenameLcb first)

Arguments:

    PrimaryLcb - Supplies the Lcb to receive all the Ccb's and Pcb's.

    AuxLcb - Supplies the Lcb to strip.

Return Value:

    None.

--*/

{
    PLIST_ENTRY Links;
    PCCB NextCcb;

    DebugTrace( +1, Dbg, ("NtfsCombineLcbs:  Entered\n") );

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( PrimaryLcb );
    ASSERT_LCB( AuxLcb );

    PAGED_CODE();

    //
    //  Move all of the Ccb's first.
    //

    for (Links = AuxLcb->CcbQueue.Flink;
         Links != &AuxLcb->CcbQueue;
         Links = AuxLcb->CcbQueue.Flink) {

        NextCcb = CONTAINING_RECORD( Links, CCB, LcbLinks );
        NtfsUnlinkCcbFromLcb( IrpContext, NextCcb );
        NtfsLinkCcbToLcb( IrpContext, NextCcb, PrimaryLcb );
    }

    //
    //  Now do the prefix entries.
    //

    ASSERT( NtfsIsExclusiveScb( AuxLcb->Scb ) );
    NtfsRemovePrefix( AuxLcb );

    //
    //  Remove any hash table entries for this Lcb.
    //

    NtfsRemoveHashEntriesForLcb( AuxLcb );

    //
    //  Finally we need to transfer the unclean counts from the
    //  Lcb being merged to the primary Lcb.
    //

    PrimaryLcb->CleanupCount += AuxLcb->CleanupCount;

    DebugTrace( -1, Dbg, ("NtfsCombineLcbs:  Entered\n") );

    return;
}


PLCB
NtfsLookupLcbByFlags (
    IN PFCB Fcb,
    IN UCHAR FileNameFlags
    )

/*++

Routine Description:

    This routine is called to find a split primary link by the file flag
    only.

Arguments:

    Fcb - This is the Fcb for the file.

    FileNameFlags - This is the file flag to search for.  We will return
        a link which matches this exactly.

Return Value:

    PLCB - The Lcb which has the desired flag, NULL otherwise.

--*/

{
    PLCB Lcb;

    PLIST_ENTRY Links;
    PLCB ThisLcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupLcbByFlags:  Entered\n") );

    Lcb = NULL;

    //
    //  Walk through the Lcb's for the file, looking for an exact match.
    //

    for (Links = Fcb->LcbQueue.Flink; Links != &Fcb->LcbQueue; Links = Links->Flink) {

        ThisLcb = CONTAINING_RECORD( Links, LCB, FcbLinks );

        if (ThisLcb->FileNameAttr->Flags == FileNameFlags) {

            Lcb = ThisLcb;
            break;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsLookupLcbByFlags:  Exit\n") );

    return Lcb;
}



ULONG
NtfsLookupNameLengthViaLcb (
    IN PFCB Fcb,
    OUT PBOOLEAN LeadingBackslash
    )

/*++

Routine Description:

    This routine is called to find the length of the file name by walking
    backwards through the Lcb links.

Arguments:

    Fcb - This is the Fcb for the file.

    LeadingBackslash - On return, indicates whether this chain begins with a
        backslash.

Return Value:

    ULONG This is the length of the bytes found in the Lcb chain.

--*/

{
    ULONG NameLength;

    DebugTrace( +1, Dbg, ("NtfsLookupNameLengthViaLcb:  Entered\n") );

    //
    //  Initialize the return values.
    //

    NameLength = 0;
    *LeadingBackslash = FALSE;

    //
    //  If there is no Lcb we are done.
    //

    if (!IsListEmpty( &Fcb->LcbQueue )) {

        PLCB ThisLcb;
        BOOLEAN FirstComponent;

        //
        //  Walk up the list of Lcb's and count the name elements.
        //

        FirstComponent = TRUE;

        ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                     LCB,
                                     FcbLinks );

        //
        //  Loop until we have reached the root or there are no more Lcb's.
        //

        while (TRUE) {

            if (ThisLcb == Fcb->Vcb->RootLcb) {

                NameLength += sizeof( WCHAR );
                *LeadingBackslash = TRUE;
                break;
            }

            //
            //  If this is not the first component, we add room for a separating
            //  forward slash.
            //

            if (!FirstComponent) {

                NameLength += sizeof( WCHAR );

            } else {

                FirstComponent = FALSE;
            }

            NameLength += ThisLcb->ExactCaseLink.LinkName.Length;

            //
            //  If the next Fcb has no Lcb we exit.
            //

            Fcb = ((PSCB) ThisLcb->Scb)->Fcb;

            if (IsListEmpty( &Fcb->LcbQueue)) {

                break;
            }

            ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                         LCB,
                                         FcbLinks );
        }

    //
    //  If this is a system file we use the hard coded name.
    //

    } else if (NtfsSegmentNumber( &Fcb->FileReference ) <= UPCASE_TABLE_NUMBER) {

        NameLength = NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Length;
        *LeadingBackslash = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsLookupNameLengthViaLcb:  Exit - %08lx\n", NameLength) );
    return NameLength;
}


VOID
NtfsFileNameViaLcb (
    IN PFCB Fcb,
    IN PWCHAR FileName,
    ULONG Length,
    ULONG BytesToCopy
    )

/*++

Routine Description:

    This routine is called to fill a buffer with the generated filename.  The name
    is constructed by walking backwards through the Lcb chain from the current Fcb.

Arguments:

    Fcb - This is the Fcb for the file.

    FileName - This is the buffer to fill with the name.

    Length - This is the length of the name.  Already calculated by calling
        NtfsLookupNameLengthViaLcb.

    BytesToCopy - This indicates the number of bytes we are to copy.  We drop
        any characters out of the trailing Lcb's to only insert the beginning
        of the path.

Return Value:

    None.

--*/

{
    ULONG BytesToDrop;

    PWCHAR ThisName;
    DebugTrace( +1, Dbg, ("NtfsFileNameViaLcb:  Entered\n") );

    //
    //  If there is no Lcb or there are no bytes to copy we are done.
    //

    if (BytesToCopy) {

        if (!IsListEmpty( &Fcb->LcbQueue )) {

            PLCB ThisLcb;
            BOOLEAN FirstComponent;

            //
            //  Walk up the list of Lcb's and count the name elements.
            //

            FirstComponent = TRUE;

            ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                         LCB,
                                         FcbLinks );

            //
            //  Loop until we have reached the root or there are no more Lcb's.
            //

            while (TRUE) {

                if (ThisLcb == Fcb->Vcb->RootLcb) {

                    *FileName = L'\\';
                    break;
                }

                //
                //  If this is not the first component, we add room for a separating
                //  forward slash.
                //

                if (!FirstComponent) {

                    Length -= sizeof( WCHAR );
                    ThisName = (PWCHAR) Add2Ptr( FileName,
                                                 Length );

                    if (Length < BytesToCopy) {

                        *ThisName = L'\\';
                    }

                } else {

                    FirstComponent = FALSE;
                }

                //
                //  Length is current pointing just beyond where the next
                //  copy will end.  If we are beyond the number of bytes to copy
                //  then we will truncate the copy.
                //

                if (Length > BytesToCopy) {

                    BytesToDrop = Length - BytesToCopy;

                } else {

                    BytesToDrop = 0;
                }

                Length -= ThisLcb->ExactCaseLink.LinkName.Length;

                ThisName = (PWCHAR) Add2Ptr( FileName,
                                             Length );

                //
                //  Only perform the copy if we are in the range of bytes to copy.
                //

                if (Length < BytesToCopy) {

                    RtlCopyMemory( ThisName,
                                   ThisLcb->ExactCaseLink.LinkName.Buffer,
                                   ThisLcb->ExactCaseLink.LinkName.Length - BytesToDrop );
                }

                //
                //  If the next Fcb has no Lcb we exit.
                //

                Fcb = ((PSCB) ThisLcb->Scb)->Fcb;

                if (IsListEmpty( &Fcb->LcbQueue)) {

                    break;
                }

                ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                             LCB,
                                             FcbLinks );
            }

        //
        //  If this is a system file, we use the hard coded name.
        //

        } else if (NtfsSegmentNumber(&Fcb->FileReference) <= UPCASE_TABLE_NUMBER) {

            if (BytesToCopy > NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Length) {

                BytesToCopy = NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Length;
            }

            RtlCopyMemory( FileName,
                           NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Buffer,
                           BytesToCopy );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsFileNameViaLcb:  Exit\n") );
    return;
}


PCCB
NtfsCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN BOOLEAN Indexed,
    IN USHORT EaModificationCount,
    IN ULONG Flags,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset
    )

/*++

Routine Description:

    This routine creates a new CCB record

Arguments:

    Fcb - This is the Fcb for the file.  We will check if we can allocate
        the Ccb from an embedded structure.

    Indexed - Indicates if we need an index Ccb.

    EaModificationCount - This is the current modification count in the
        Fcb for this file.

    Flags - Informational flags for this Ccb.

    FileObject - Object containing full path used to open this file.

    LastFileNameOffset - Supplies the offset (in bytes) of the last component
        for the name that the user is opening.  If this is the root
        directory it should denote "\" and all other ones should not
        start with a backslash.

Return Value:

    CCB - returns a pointer to the newly allocate CCB

--*/

{
    PCCB Ccb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace( +1, Dbg, ("NtfsCreateCcb\n") );

    //
    //  Allocate a new CCB Record.  If the Fcb is nonpaged then we must allocate
    //  a non-paged ccb.  Then test if we can allocate this out of the Fcb.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_NONPAGED )) {

        if (Indexed) {

            Ccb = NtfsAllocatePoolWithTag( NonPagedPool, sizeof(CCB), 'CftN' );

        } else {

            Ccb = NtfsAllocatePoolWithTag( NonPagedPool, sizeof(CCB_DATA), 'cftN' );
        }

    } else if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
               (SafeNodeType( &((PFCB_INDEX) Fcb)->Ccb ) == 0)) {

        Ccb = (PCCB) &((PFCB_INDEX) Fcb)->Ccb;

    } else if (!Indexed &&
               FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_DATA ) &&
               (SafeNodeType( &((PFCB_DATA) Fcb)->Ccb ) == 0)) {

        Ccb = (PCCB) &((PFCB_DATA) Fcb)->Ccb;

    } else {

        if (Indexed) {

            Ccb = (PCCB)ExAllocateFromPagedLookasideList( &NtfsCcbLookasideList );

        } else {

            Ccb = (PCCB)ExAllocateFromPagedLookasideList( &NtfsCcbDataLookasideList );
        }
    }

    //
    //  Zero and initialize the correct structure.
    //

    if (Indexed) {

        RtlZeroMemory( Ccb, sizeof(CCB) );

        //
        //  Set the proper node type code and node byte size
        //

        Ccb->NodeTypeCode = NTFS_NTC_CCB_INDEX;
        Ccb->NodeByteSize = sizeof(CCB);

    } else {

        RtlZeroMemory( Ccb, sizeof(CCB_DATA) );

        //
        //  Set the proper node type code and node byte size
        //

        Ccb->NodeTypeCode = NTFS_NTC_CCB_DATA;
        Ccb->NodeByteSize = sizeof(CCB_DATA);
    }

    //
    //  Copy the Ea modification count.
    //

    Ccb->EaModificationCount = EaModificationCount;

    //
    //  Copy the flags field
    //

    Ccb->Flags = Flags;

    //
    //  Set the file object and last file name offset fields
    //

    Ccb->FullFileName = FileObject->FileName;
    Ccb->LastFileNameOffset = (USHORT)LastFileNameOffset;

    //
    //  Initialize the Lcb queue.
    //

    InitializeListHead( &Ccb->LcbLinks );

    //
    //  Add the Ccb onto the Scb
    //

    InsertTailList( &Scb->CcbQueue, &Ccb->CcbLinks );

#ifdef CCB_FILE_OBJECT
    Ccb->FileObject = FileObject;
    Ccb->Process = PsGetCurrentProcess();
#endif

    DebugTrace( -1, Dbg, ("NtfsCreateCcb -> %08lx\n", Ccb) );

    return Ccb;
}


VOID
NtfsDeleteCcb (
    IN PFCB Fcb,
    IN OUT PCCB *Ccb
    )

/*++

Routine Description:

    This routine deallocates the specified CCB record.

Arguments:

    Fcb - This is the Fcb for the file.  We will check if we can allocate
        the Ccb from an embedded structure.

    Ccb - Supplies the CCB to remove

Return Value:

    None

--*/

{
    ASSERT_CCB( *Ccb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteCcb, Ccb = %08lx\n", Ccb) );

    //
    //  Deallocate any structures the Ccb is pointing to.  The following
    //  are only in index Ccb.
    //

    if (SafeNodeType( *Ccb ) == NTFS_NTC_CCB_INDEX) {

        //
        //  Make sure we aren't deleting this with any waiters.
        //

        ASSERT( (*Ccb)->EnumQueue.Flink == NULL );

        //
        //  If this Ccb was for a view index, we may need to
        //  free the read context used for directory enumeration.
        //

        if (FlagOn( (*Ccb)->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED )) {

            NtOfsFreeReadContext( (*Ccb)->QueryBuffer );

        } else if ((*Ccb)->QueryBuffer != NULL)  {

            NtfsFreePool( (*Ccb)->QueryBuffer );
        }

        if ((*Ccb)->IndexEntry != NULL)   { NtfsFreePool( (*Ccb)->IndexEntry ); }

        if ((*Ccb)->IndexContext != NULL) {

            PINDEX_CONTEXT IndexContext;

            if ((*Ccb)->IndexContext->Base != (*Ccb)->IndexContext->LookupStack) {
                NtfsFreePool( (*Ccb)->IndexContext->Base );
            }

            //
            //  Copy the IndexContext pointer into the stack so we don't dereference the
            //  paged Ccb while holding a spinlock.
            //

            IndexContext = (*Ccb)->IndexContext;
            ExFreeToPagedLookasideList( &NtfsIndexContextLookasideList, IndexContext );
        }
    }

    if (FlagOn( (*Ccb)->Flags, CCB_FLAG_ALLOCATED_FILE_NAME )) {

        NtfsFreePool( (*Ccb)->FullFileName.Buffer );
    }

    //
    //  Unhook Ccb from Scb list
    //

    RemoveEntryList( &(*Ccb)->CcbLinks );

    //
    //  Deallocate the Ccb simply clear the flag in the Ccb header.
    //

    if ((*Ccb == (PCCB) &((PFCB_DATA) Fcb)->Ccb) ||
        (*Ccb == (PCCB) &((PFCB_INDEX) Fcb)->Ccb)) {

        (*Ccb)->NodeTypeCode = 0;

    } else {

        if (SafeNodeType( *Ccb ) == NTFS_NTC_CCB_INDEX) {

            ExFreeToPagedLookasideList( &NtfsCcbLookasideList, *Ccb );

        } else {

            ExFreeToPagedLookasideList( &NtfsCcbDataLookasideList, *Ccb );
        }
    }

    //
    //  Zero out the input pointer
    //

    *Ccb = NULL;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteCcb -> VOID\n") );

    return;

}


VOID
NtfsInitializeIrpContext (
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN Wait,
    IN OUT PIRP_CONTEXT *IrpContext
    )

/*++

Routine Description:

    This routine creates and/or initializes a new IRP_CONTEXT record.  The context
    may be on the stack already or we might need to allocate it here.

Arguments:

    Irp - Supplies the originating Irp.  In many cases we won't be given an IrpContext for
        operations where we are doing work for Ntfs not for the user.
        operation.

    Wait - Supplies the wait value to store in the context.

    IrpContext - Address to store the IrpContext on return.  If this initially points to
        a non-NULL value then the IrpContext is on the stack.


Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb;
    ULONG StateFlags = 0;
    UCHAR MajorFunction;
    UCHAR MinorFunction;

    ASSERT_OPTIONAL_IRP( Irp );

    //
    //  If the Irp is present then check that this is a legal operation for Ntfs.
    //
    //  Also capture the Vcb, function codes and write-through state if we have
    //  a legal Irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        ASSERT( (DWORD_PTR)(Irp->Tail.Overlay.AuxiliaryBuffer) != 0xFFFFFFFF );

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  If we were called with our file system device object instead of a
        //  volume device object and this is not a mount, the request is illegal.
        //

        if ((IrpSp->DeviceObject->Size == (USHORT)sizeof(DEVICE_OBJECT)) &&
            (IrpSp->FileObject != NULL)) {

            //
            //  Clear the IrpContext pointer so our caller knows the request failed.
            //

            *IrpContext = NULL;
            ExRaiseStatus( STATUS_INVALID_DEVICE_REQUEST );
        }

        //
        //  Copy RealDevice for workque algorithms, and also set WriteThrough
        //  if there is a file object.
        //

        if (IrpSp->FileObject != NULL) {

            //
            //  Locate the volume device object and Vcb that we are trying to access
            //  so we can see if the request is WriteThrough.  We ignore the
            //  write-through flag for close and cleanup.
            //

            Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;

            ASSERT( NodeType(Vcb) == NTFS_NTC_VCB );

            ASSERTMSG( "No correspondence btwn file and device in irp",
                      ((IrpSp->FileObject->Vpb == NULL) &&
                       ((IrpSp->FileObject->DeviceObject != NULL) &&
                       (IrpSp->FileObject->DeviceObject->Vpb != NULL) &&
                       (IrpSp->DeviceObject == IrpSp->FileObject->DeviceObject->Vpb->DeviceObject))) ||

                      ((IrpSp->FileObject->Vpb != NULL) &&
                       (IrpSp->DeviceObject == IrpSp->FileObject->Vpb->DeviceObject)) ||

                      (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) );

            if (IsFileWriteThrough( IrpSp->FileObject, Vcb )) {

                StateFlags = IRP_CONTEXT_STATE_WRITE_THROUGH;
            }

        //
        //  We would still like to find out the Vcb in all cases except for
        //  mount.
        //

        } else if (IrpSp->DeviceObject != NULL) {

            Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;

        } else {

            Vcb = NULL;
        }

        //
        //  Major/Minor Function codes
        //

        MajorFunction = IrpSp->MajorFunction;
        MinorFunction = IrpSp->MinorFunction;

    } else {

        Vcb = NULL;
        MajorFunction = 0;
        MinorFunction = 0;
    }

    //
    //  Allocate an IrpContext from zone if available, otherwise from
    //  non-paged pool.
    //

    if (*IrpContext == NULL) {

        *IrpContext = (PIRP_CONTEXT)ExAllocateFromNPagedLookasideList( &NtfsIrpContextLookasideList );
        SetFlag( StateFlags, IRP_CONTEXT_STATE_ALLOC_FROM_POOL );
    }

    DebugDoit( NtfsFsdEntryCount += 1);

    RtlZeroMemory( *IrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    (*IrpContext)->NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    (*IrpContext)->NodeByteSize = sizeof(IRP_CONTEXT);

    //
    //  Set the originating Irp field
    //

    (*IrpContext)->OriginatingIrp = Irp;

    //
    //  Set the Vcb and function codes we found (or NULL).
    //

    (*IrpContext)->Vcb = Vcb;
    (*IrpContext)->MajorFunction = MajorFunction;
    (*IrpContext)->MinorFunction = MinorFunction;

    //
    //  Set the wait and write through flags.
    //

    if (Wait) { SetFlag( (*IrpContext)->State, IRP_CONTEXT_STATE_WAIT ); }
    SetFlag( (*IrpContext)->State, StateFlags );

    //
    //  Initialize the recently deallocated record queue and exclusive Scb queue
    //

    InitializeListHead( &(*IrpContext)->RecentlyDeallocatedQueue );
    InitializeListHead( &(*IrpContext)->ExclusiveFcbList );

    //
    //  Always point to ourselves as the TopLevelIrpContext.
    //

    (*IrpContext)->TopLevelIrpContext = *IrpContext;

    //
    //  Set up LogFull testing
    //

#ifdef NTFS_LOG_FULL_TEST
    (*IrpContext)->CurrentFailCount = (*IrpContext)->NextFailCount = NtfsFailCheck;
#endif

    return;
}


VOID
NtfsCleanupIrpContext (
    IN OUT PIRP_CONTEXT IrpContext,
    IN ULONG Retry
    )

/*++

Routine Description:

    This routine performs cleanup on an IrpContext when we are finished using it in the current
    thread.  This can be because we are completing, retrying or posting a request.  It may be
    from the stack or allocated from pool.

    This request can also be called after a transaction has committed to cleanup all of
    the state information and resources held as part of the transaction.  The user can set
    the appropriate flags to prevent it from being deleted.

Arguments:

    IrpContext - Supplies the IRP_CONTEXT to cleanup.

    Retry - Indicates if we are retrying in the same thread or posting.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Start with the recently deallocated records.
    //

    if (!IsListEmpty( &IrpContext->RecentlyDeallocatedQueue )) {

        NtfsDeallocateRecordsComplete( IrpContext );
    }

    //
    //  Just in case we somehow get here with a transaction ID, clear
    //  it here so we do not loop forever.
    //

    ASSERT(IrpContext->TransactionId == 0);
    IrpContext->TransactionId = 0;


    NtfsReleaseAllResources( IrpContext );

#ifdef MAPCOUNT_DBG

    //
    //  Check all mapping are gone now that we cleaned out cache
    //

    ASSERT( IrpContext->MapCount == 0 );

#endif

    //
    //  Make sure there are no Scb snapshots left.  Most are freed above when the fcb's are released
    //  but preacquires from mm - for example doing a flushuserstream or deleted scbs will need to be
    //  cleaned up here
    //

    NtfsFreeSnapshotsForFcb( IrpContext, NULL );

    //
    //  Make sure we don't need to deallocate a UsnFcb structure.
    //

    while (IrpContext->Usn.NextUsnFcb != NULL) {

        PUSN_FCB ThisUsn;

        ThisUsn = IrpContext->Usn.NextUsnFcb;
        IrpContext->Usn.NextUsnFcb = ThisUsn->NextUsnFcb;
        NtfsFreePool( ThisUsn );
    }

    //
    //  If we can delete this Irp Context do so now.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE ) &&
        !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT )) {

        if (IrpContext->Union.NtfsIoContext != NULL) {

            //
            //  If there is an Io context pointer in the irp context and it is not
            //  on the stack, then free it.
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT )) {

                ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, IrpContext->Union.NtfsIoContext );

            //
            //  If we have captured the subject context then free it now.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_SECURITY )) {

                SeReleaseSubjectContext( IrpContext->Union.SubjectContext );

                NtfsFreePool( IrpContext->Union.SubjectContext );

            //
            //  Else if we locked the user buffer in a sep. mdl in ReadUsnFile
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_MDL )) {

                MmUnlockPages( IrpContext->Union.MdlToCleanup );
                IoFreeMdl( IrpContext->Union.MdlToCleanup );
            }

            IrpContext->Union.NtfsIoContext = NULL;
        }

        //
        //  Restore the thread context pointer if associated with this IrpContext.
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

            NtfsRestoreTopLevelIrp();
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
        }

        //
        //  Return the IRP context record to the lookaside or to pool depending
        //  how much is currently in the lookaside
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL )) {

            ExFreeToNPagedLookasideList( &NtfsIrpContextLookasideList, IrpContext );
        }

    } else {

        //
        //  Do all any necessary to reinitialize IrpContext fields.  We avoid doing
        //  these if the IrpContext is going away.
        //

        RtlZeroMemory( &IrpContext->ScbSnapshot, sizeof( SCB_SNAPSHOT ));

        //
        //  Clear the appropriate flags unless our caller wanted to preserve them.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RETAIN_FLAGS )) {

            //
            //  Set up the Irp Context for retry or post.
            //

            if (Retry) {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY );

            } else {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );
            }

        } else {

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RETAIN_FLAGS | IRP_CONTEXT_FLAG_DONT_DELETE );
        }

        //
        //  Always clear the counts of free records and clusters.
        //

        IrpContext->DeallocatedClusters = 0;
        IrpContext->FreeClusterChange = 0;
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
NtfsTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID FcbOrScb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedFcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to start the teardown process on a node in
    the Fcb/Scb tree.  We will attempt to remove this node and then
    move up the tree removing any nodes held by this node.

    This routine deals with the case where a single node may be holding
    multiple parents in memory.  If we are passed an input Lcb we will
    use that to walk up the tree.  If the Vcb is held exclusively we
    will try to trim any nodes that have no open files on them.

    This routine takes the following steps:

        Remove as many Scb's and file objects from the starting
            Fcb.

        If the Fcb can't go away but has multiple links then remove
            whatever links possible.  If we have the Vcb we can
            do all of them but we will leave a single link behind
            to optimize prefix lookups.  Otherwise we will traverse the
            single link we were given.

        If the Fcb can go away then we should have the Vcb if there are
            multiple links to remove.  Otherwise we only remove the link
            we were given if there are multiple links.  In the single link
            case just remove that link.

Arguments:

    FcbOrScb - Supplies either an Fcb or an Scb as the start of the
        teardown point.  The Fcb for this element must be held exclusively.

    Lcb - If specified, this is the path up the tree to perform the
        teardown.

    CheckForAttributeTable - Indicates that we should not teardown an
        Scb which is in the attribute table.  Instead we will attempt
        to put an entry on the async close queue.  This will be TRUE
        if we may need the Scb to abort the current transaction.

    AcquireFlags - Indicates whether we should abort the teardown when
        we can't acquire a parent.  When called from some path where we may
        hold the MftScb or another resource in another path up the tree.

            ACQUIRE_NO_DELETE_CHECK
            ACQUIRE_DONT_WAIT
            ACQUIRE_HOLD_BITMAP

    RemovedFcb - Address to store TRUE if we delete the starting Fcb.

Return Value:

    None

--*/

{
    PSCB StartingScb = NULL;
    PFCB Fcb;
    BOOLEAN FcbCanBeRemoved;
    BOOLEAN RemovedLcb;
    BOOLEAN LocalRemovedFcb = FALSE;
    PLIST_ENTRY Links;
    PLIST_ENTRY NextLink;

    PAGED_CODE();

    //
    //  If this is a recursive call to TearDownStructures we return immediately
    //  doing no operation.
    //

    if (FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_IN_TEARDOWN )) {

        DebugTrace( 0, Dbg, ("Recursive teardown call\n") );
        DebugTrace( -1, Dbg, ("NtfsTeardownStructures -> VOID\n") );

        return;
    }

    if (SafeNodeType(FcbOrScb) == NTFS_NTC_FCB) {

        Fcb = FcbOrScb;

    } else {

        StartingScb = FcbOrScb;
        FcbOrScb = Fcb = StartingScb->Fcb;
    }

    SetFlag( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_IN_TEARDOWN );

    //
    //  Use a try-finally to clear the top level irp field.
    //

    try {

        //
        //  Use our local boolean if the caller didn't supply one.
        //

        if (!ARGUMENT_PRESENT( RemovedFcb )) {

            RemovedFcb = &LocalRemovedFcb;
        }

        //
        //  Check this Fcb for removal.  Remember if all of the Scb's
        //  and file objects are gone.  We will try to remove the Fcb
        //  if the cleanup count is zero or if we are walking up
        //  one directory path of a mult-link file.  If the Fcb has
        //  a non-zero cleanup count but the current Scb has a zero
        //  cleanup count then try to delete the Scb at the very least.
        //

        FcbCanBeRemoved = FALSE;

        if (Fcb->CleanupCount == 0) {

            FcbCanBeRemoved = NtfsPrepareFcbForRemoval( IrpContext,
                                                        Fcb,
                                                        StartingScb,
                                                        CheckForAttributeTable );

        } else if (ARGUMENT_PRESENT( StartingScb ) &&
                   (StartingScb->CleanupCount == 0) &&
                   (StartingScb->AttributeTypeCode != $ATTRIBUTE_LIST)) {

            NtfsRemoveScb( IrpContext, StartingScb, CheckForAttributeTable );
        }

        //
        //  There is a single link (typical case) we either try to
        //  remove that link or we simply return.
        //

        if (Fcb->LcbQueue.Flink == Fcb->LcbQueue.Blink) {

            if (FcbCanBeRemoved) {

                NtfsTeardownFromLcb( IrpContext,
                                     Fcb->Vcb,
                                     Fcb,
                                     CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                                        LCB,
                                                        FcbLinks ),
                                     CheckForAttributeTable,
                                     AcquireFlags,
                                     &RemovedLcb,
                                     RemovedFcb );
            }

            leave;

        //
        //  If there are multiple links we will try to either remove
        //  them all or all but one (if the Fcb is not going away) if
        //  we own the Vcb.  We will try to delete the one we were
        //  given otherwise.
        //

        } else {

            //
            //  If we have the Vcb we will remove all if the Fcb can
            //  go away.  Otherwise we will leave one.
            //

            if (NtfsIsExclusiveVcb( Fcb->Vcb )) {

                Links = Fcb->LcbQueue.Flink;

                while (TRUE) {

                    //
                    //  Remember the next entry in case the current link
                    //  goes away.
                    //

                    NextLink = Links->Flink;

                    RemovedLcb = FALSE;

                    NtfsTeardownFromLcb( IrpContext,
                                         Fcb->Vcb,
                                         Fcb,
                                         CONTAINING_RECORD( Links, LCB, FcbLinks ),
                                         CheckForAttributeTable,
                                         0,
                                         &RemovedLcb,
                                         RemovedFcb );

                    //
                    //  If couldn't remove this link then munge the
                    //  boolean indicating if the Fcb can be removed
                    //  to make it appear we need to remove all of
                    //  the Lcb's.
                    //

                    if (!RemovedLcb) {

                        FcbCanBeRemoved = TRUE;
                    }

                    //
                    //  If the Fcb has been removed then we exit.
                    //  If the next link is the beginning of the
                    //  Lcb queue then we also exit.
                    //  If the next link is the last entry and
                    //  we want to leave a single entry then we
                    //  exit.
                    //

                    if (*RemovedFcb ||
                        (NextLink == &Fcb->LcbQueue) ||
                        (!FcbCanBeRemoved &&
                         (NextLink->Flink == &Fcb->LcbQueue))) {

                        leave;
                    }

                    //
                    //  Move to the next link.
                    //

                    Links = NextLink;
                }

            //
            //  If we have an Lcb just move up that path.
            //

            } else if (ARGUMENT_PRESENT( Lcb )) {

                NtfsTeardownFromLcb( IrpContext,
                                     Fcb->Vcb,
                                     Fcb,
                                     Lcb,
                                     CheckForAttributeTable,
                                     AcquireFlags,
                                     &RemovedLcb,
                                     RemovedFcb );
            }
        }

    } finally {

        DebugUnwind( NtfsTeardownStructures );

        ClearFlag( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_IN_TEARDOWN );
    }

    return;
}


//
//
//

PVOID
NtfsAllocateCompressionSync (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This routine is called by the lookaside package to allocation a new compression
    sync structure.  We have a dedicated routine in order to perform the resource
    initialization if necessary.  Otherwise the caller will need to defensively
    test and initialize the resource.

Arguments:

    PoolType - Type of pool associated with the lookaside list.

    NumberOfBytes - Size of pool block to allocate.

    Tag - Tag to associate with the block.

Return Value:

    NULL if we are unable to allocate the pool.  Otherwise a pointer to the block of
        of pool is returned.

--*/

{
    PCOMPRESSION_SYNC CompressionSync;

    PAGED_CODE();

    CompressionSync = NtfsAllocatePoolWithTagNoRaise( PoolType,
                                                      NumberOfBytes,
                                                      Tag );

    if (CompressionSync != NULL) {

        ExInitializeResourceLite( &CompressionSync->Resource );
        CompressionSync->ReferenceCount = 0;
    }

    return CompressionSync;
}


VOID
NtfsDeallocateCompressionSync (
    IN PVOID CompressionSync
    )

/*++

Routine Description:

    This routine is called to deallocate the pool for a single CompressionSync structure.
    We have our own routine in order to unitialize the embedded resource.

Arguments:

    CompressionSync - Structure to deallocate.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExDeleteResourceLite( &((PCOMPRESSION_SYNC) CompressionSync)->Resource );
    NtfsFreePool( CompressionSync );
    return;
}


VOID
NtfsIncrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    )

/*++

Routine Description:

    This routine increments the cleanup counts for the associated data structures

Arguments:

    Scb - Supplies the Scb used in this operation

    Lcb - Optionally supplies the Lcb used in this operation

    NonCachedHandle - Indicates this handle is for a user non-cached handle.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    //
    //  This is really a pretty light weight procedure but having it be a procedure
    //  really helps in debugging the system and keeping track of who increments
    //  and decrements cleanup counts
    //

    if (ARGUMENT_PRESENT(Lcb)) { Lcb->CleanupCount += 1; }

    InterlockedIncrement( &Scb->CleanupCount );
    Scb->Fcb->CleanupCount += 1;

    if (NonCachedHandle) {

        Scb->NonCachedCleanupCount += 1;
    }

    InterlockedIncrement( &Vcb->CleanupCount );
    return;
}


VOID
NtfsIncrementCloseCounts (
    IN PSCB Scb,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly
    )

/*++

Routine Description:

    This routine increments the close counts for the associated data structures

Arguments:

    Scb - Supplies the Scb used in this operation

    SystemFile - Indicates if the Scb is for a system file  (if so then
        the Vcb system file close count in also incremented)

    ReadOnly - Indicates if the Scb is opened readonly.  (if so then the
        Vcb Read Only close count is also incremented)

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    //
    //  This is really a pretty light weight procedure but having it be a procedure
    //  really helps in debugging the system and keeping track of who increments
    //  and decrements close counts
    //

    //
    //  If this is someone other than the first open, remember that.
    //

    if (InterlockedIncrement( &Scb->CloseCount ) >= 2) {

        SetFlag( Scb->ScbState, SCB_STATE_MULTIPLE_OPENS );
    }

    InterlockedIncrement( &Scb->Fcb->CloseCount );

    InterlockedIncrement( &Vcb->CloseCount );

    if (SystemFile) {

        InterlockedIncrement( &Vcb->SystemFileCloseCount );
    }

    if (ReadOnly) {

        InterlockedIncrement( &Vcb->ReadOnlyCloseCount );
    }

    //
    //  We will always clear the delay close flag in this routine.
    //

    ClearFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );

    return;
}


VOID
NtfsDecrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    )

/*++

Routine Description:

    This procedure decrements the cleanup counts for the associated data structures
    and if necessary it also start to cleanup associated internal attribute streams

Arguments:

    Scb - Supplies the Scb used in this operation

    Lcb - Optionally supplies the Lcb used in this operation

    NonCachedHandle - Indicates this handle is for a user non-cached handle.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    ASSERT_SCB( Scb );
    ASSERT_FCB( Scb->Fcb );
    ASSERT_VCB( Scb->Fcb->Vcb );
    ASSERT_OPTIONAL_LCB( Lcb );

    //
    //  First we decrement the appropriate cleanup counts
    //

    if (ARGUMENT_PRESENT(Lcb)) { Lcb->CleanupCount -= 1; }

    InterlockedDecrement( &Scb->CleanupCount );
    Scb->Fcb->CleanupCount -= 1;

    if (NonCachedHandle) {

        Scb->NonCachedCleanupCount -= 1;
    }

    InterlockedDecrement( &Vcb->CleanupCount );

    //
    //  Now if the Fcb's cleanup count is zero that indicates that we are
    //  done with this Fcb from a user handle standpoint and we should
    //  now scan through all of the Scb's that are opened under this
    //  Fcb and shutdown any internal attributes streams we have open.
    //  For example, EAs and ACLs.  We only need to do one.  The domino effect
    //  will take of the rest.
    //

    if (Scb->Fcb->CleanupCount == 0) {

        PSCB NextScb;

        //
        //  Remember if we are dealing with a system file and return immediately.
        //

        if (FlagOn(Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE) &&
            NtfsSegmentNumber( &Scb->Fcb->FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER) {

            return;
        }

        for (NextScb = CONTAINING_RECORD(Scb->Fcb->ScbQueue.Flink, SCB, FcbLinks);
             &NextScb->FcbLinks != &Scb->Fcb->ScbQueue;
             NextScb = CONTAINING_RECORD( NextScb->FcbLinks.Flink, SCB, FcbLinks )) {

            //
            //  Skip the root index on the volume.
            //

            if (SafeNodeType( NextScb ) == NTFS_NTC_SCB_ROOT_INDEX) { continue; }

            //
            //  It is possible that someone has referenced this Scb to keep it from going away.
            //  We can treat this the same as if there was a cleanup count in the Fcb.  Someone
            //  else is responsible for doing the cleanup.
            //
            //  We can also break out if we have an index with children.
            //

            if ((NextScb->CleanupCount != 0) ||
                ((SafeNodeType( NextScb ) == NTFS_NTC_SCB_INDEX) &&
                  !IsListEmpty( &NextScb->ScbType.Index.LcbQueue ))) {

                break;
            }

            //
            //  If there is an internal stream then dereference it and get out.
            //

            if (NextScb->FileObject != NULL) {

                NtfsDeleteInternalAttributeStream( NextScb,
                                                   (BOOLEAN) (Scb->Fcb->LinkCount == 0),
                                                   FALSE );
                break;
            }
        }
    }

    //
    //  And return to our caller
    //

    return;
}


BOOLEAN
NtfsDecrementCloseCounts (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN DecrementCountsOnly
    )

/*++

Routine Description:

    This routine decrements the close counts for the associated data structures
    and if necessary it will teardown structures that are no longer in use

Arguments:

    Scb - Supplies the Scb used in this operation

    Lcb - Used if calling teardown to know which path to take.

    SystemFile - Indicates if the Scb is for a system file

    ReadOnly - Indicates if the Scb was opened readonly

    DecrementCountsOnly - Indicates if this operation should only modify the
        count fields.

Return Value:

    TRUE if the fcb for the input scb was torndown

--*/

{
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;
    BOOLEAN RemovedFcb = FALSE;

    ASSERT_SCB( Scb );
    ASSERT_FCB( Fcb );
    ASSERT_VCB( Fcb->Vcb );

    //
    //  Decrement the close counts
    //

    InterlockedDecrement( &Scb->CloseCount );
    InterlockedDecrement( &Fcb->CloseCount );

    InterlockedDecrement( &Vcb->CloseCount );

    if (SystemFile) {

        InterlockedDecrement( &Vcb->SystemFileCloseCount );
    }

    if (ReadOnly) {

        InterlockedDecrement( &Vcb->ReadOnlyCloseCount );
    }

    //
    //  Now if the scb's close count is zero then we are ready to tear
    //  it down
    //

    if (!DecrementCountsOnly) {

        //
        //  We want to try to start a teardown from this Scb if
        //
        //      - The close count is zero
        //
        //          or the following are all true
        //
        //      - The cleanup count is zero
        //      - There is a file object in the Scb
        //      - It is a data Scb or an empty index Scb
        //      - It is not an Ntfs system file
        //
        //  The teardown will be noopted if this is a recursive call.
        //

        if (Scb->CloseCount == 0

                ||

            (Scb->CleanupCount == 0
             && Scb->FileObject != NULL
             && !FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)
             && ((SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA)
                 || (SafeNodeType( Scb ) == NTFS_NTC_SCB_MFT)
                 || IsListEmpty( &Scb->ScbType.Index.LcbQueue )))) {

            NtfsTeardownStructures( IrpContext,
                                    Scb,
                                    Lcb,
                                    FALSE,
                                    0,
                                    &RemovedFcb );
        }
    }

    //
    //  And return to our caller
    //

    return RemovedFcb;
}

PERESOURCE
NtfsAllocateEresource (
    )
{
    KIRQL _SavedIrql;
    PERESOURCE Eresource;

    _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
    if (NtfsData.FreeEresourceSize > 0) {
        Eresource = NtfsData.FreeEresourceArray[--NtfsData.FreeEresourceSize];
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        Eresource = NtfsAllocatePoolWithTag( NonPagedPool, sizeof(ERESOURCE), 'rftN' );
        ExInitializeResourceLite( Eresource );
        NtfsData.FreeEresourceMiss += 1;
    }

    return Eresource;
}

VOID
NtfsFreeEresource (
    IN PERESOURCE Eresource
    )
{
    KIRQL _SavedIrql;

    //
    //  Do an unsafe test to see if we should put this on our list.
    //  We want to reinitialize this before adding to the list so
    //  we don't have a bunch of resources which appear to be held.
    //

    if (NtfsData.FreeEresourceSize < NtfsData.FreeEresourceTotal) {

        ExReinitializeResourceLite( Eresource );

        //
        //  Now acquire the spinlock and do a real test.
        //

        _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
        if (NtfsData.FreeEresourceSize < NtfsData.FreeEresourceTotal) {
            NtfsData.FreeEresourceArray[NtfsData.FreeEresourceSize++] = Eresource;
            KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        } else {
            KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
            ExDeleteResourceLite( Eresource );
            NtfsFreePool( Eresource );
        }

    } else {

        ExDeleteResourceLite( Eresource );
        NtfsFreePool( Eresource );
    }

    return;
}


PVOID
NtfsAllocateFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    FcbTable - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    KIRQL _SavedIrql;
    PVOID FcbTableEntry;

    UNREFERENCED_PARAMETER( FcbTable );

    _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
    if (NtfsData.FreeFcbTableSize > 0) {
        FcbTableEntry = NtfsData.FreeFcbTableArray[--NtfsData.FreeFcbTableSize];
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        FcbTableEntry = NtfsAllocatePool( PagedPool, ByteSize );
    }

    return FcbTableEntry;
}


VOID
NtfsFreeFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine that deallocates memory

Arguments:

    FcbTable - Supplies the generic table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    KIRQL _SavedIrql;

    UNREFERENCED_PARAMETER( FcbTable );

    _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
    if (NtfsData.FreeFcbTableSize < FREE_FCB_TABLE_SIZE) {
        NtfsData.FreeFcbTableArray[NtfsData.FreeFcbTableSize++] = Buffer;
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        NtfsFreePool( Buffer );
    }

    return;
}


VOID
NtfsPostToNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to add an Scb to the queue of Scbs which have
    waiters on extends.  There is a single element embedded in the IrpContext.
    Otherwise this field in the IrpContext will point to an array of elements.

Arguments:

    Scb - This is the Scb to add to the queue.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Nothing to do if this Scb is in the IrpContext.
    //

    if (Scb != IrpContext->CheckNewLength) {

        //
        //  If the IrpContext field is unused then stuff this into it.
        //

        if (IrpContext->CheckNewLength == NULL) {

            IrpContext->CheckNewLength = Scb;

        } else {

            PULONG_PTR NewQueue;

            //
            //  First case - there is an Scb in the IrpContext.
            //  Allocate a larger structure and put our element in it.
            //

            if (SafeNodeType( IrpContext->CheckNewLength ) == NTFS_NTC_SCB_DATA ) {

                NewQueue = NtfsAllocatePool( PagedPool, sizeof( ULONG_PTR ) * 3 );
                *NewQueue = (ULONG_PTR) IrpContext->CheckNewLength;
                IrpContext->CheckNewLength = NewQueue;
                *(NewQueue + 1) = (ULONG_PTR) Scb;
                *(NewQueue + 2) = (ULONG_PTR) NULL;

            //
            //  Second case - walk existing queue and look for an unused element or
            //  the current scb.
            //

            } else {

                NewQueue = IrpContext->CheckNewLength;

                do {

                    //
                    //  Our scb is in the queue.
                    //

                    if (*NewQueue == (ULONG_PTR) Scb) { break; }

                    //
                    //  The current position is unused.
                    //

                    if (*NewQueue == (ULONG_PTR) -1) {

                        *NewQueue = (ULONG_PTR) Scb;
                        break;
                    }

                    //
                    //  We are at the end of the list.
                    //

                    if (*NewQueue == (ULONG_PTR) NULL) {

                        ULONG CurrentLength;

                        CurrentLength = PtrOffset( IrpContext->CheckNewLength, NewQueue );

                        NewQueue = NtfsAllocatePool( PagedPool,
                                                     CurrentLength + (4 * sizeof( ULONG_PTR )) );

                        RtlCopyMemory( NewQueue,
                                       IrpContext->CheckNewLength,
                                       CurrentLength );

                        NewQueue = Add2Ptr( NewQueue, CurrentLength );
                        *NewQueue = (ULONG_PTR) Scb;
                        *(NewQueue + 1) = -1;
                        *(NewQueue + 2) = -1;
                        *(NewQueue + 3) = (ULONG_PTR) NULL;

                        NtfsFreePool( IrpContext->CheckNewLength );
                        IrpContext->CheckNewLength = NewQueue;
                        break;
                    }

                    //
                    //  Go to the next element.
                    //

                    NewQueue += 1;

                } while (TRUE);
            }
        }
    }

    return;
}


VOID
NtfsProcessNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CleanupOnly
    )

/*++

Routine Description:

    This routine is called when there is at least one Scb in the IrpContext
    queue of streams which have waiters on the new length.  We will call
    NtOfsPostNewLength for each element unless we are cleaning up only.

Arguments:

    IrpContext - Has a non-empty queue of Scbs for the current transaction.

    CleanupOnly - Indicates if we only want to clean up the queue, not
        alert any waiters (this is the error path).

Return Value:

    None.

--*/

{
    PULONG_PTR NextScb;
    PAGED_CODE();

    //
    //  Check if the only entry is resident in the IrpContext.
    //

    if (SafeNodeType( IrpContext->CheckNewLength ) == NTFS_NTC_SCB_DATA) {

        if (!CleanupOnly) {

            NtOfsPostNewLength( IrpContext, (PSCB) IrpContext->CheckNewLength, FALSE );
        }

    //
    //  Otherwise we want to walk through the external entries.
    //

    } else {

        if (!CleanupOnly) {

            NextScb = IrpContext->CheckNewLength;

            //
            //  Continue until we run out of entries.  The end of the block has a NULL, any unused entries
            //  will have a -1.
            //

            while ((*NextScb != (ULONG_PTR) -1) && (*NextScb != (ULONG_PTR) NULL)) {

                ASSERT( SafeNodeType( *NextScb ) == NTFS_NTC_SCB_DATA );
                NtOfsPostNewLength( IrpContext, (PSCB) *NextScb, FALSE );

                NextScb += 1;
            }
        }
        NtfsFreePool( IrpContext->CheckNewLength );
    }

    IrpContext->CheckNewLength = NULL;

    return;
}


VOID
NtfsTestStatusProc (
    )

/*++

Routine Description:

    This routine is to catch specific status codes in the running system.  It
    is called only when NtfsTestStatus is TRUE and the current request is completing
    with NtfsTestStatusCode.

Arguments:

    None

Return Value:

    None

--*/

{
    ASSERT( FALSE );
}


//
//  Local support routine
//

VOID
NtfsCheckScbForCache (
    IN OUT PSCB Scb
    )

/*++

Routine Description:

    This routine checks if the Scb has blocks contining
    Lsn's or Update sequence arrays and set the appropriate
    bit in the Scb state word.

    The Scb is Update sequence aware if it the Data Attribute for the
    Mft or the Data Attribute for the log file or any index allocation
    stream.

    The Lsn aware Scb's are the ones above without the Log file.

Arguments:

    Scb - Supplies the current Scb

Return Value:

    The next Scb in the enumeration, or NULL if Scb was the final one.

--*/

{
    //
    //  Temporarily either sequence 0 or 1 is ok.
    //

    FILE_REFERENCE MftTemp = {0,0,1};

    PAGED_CODE();

    //
    //  Check for Update Sequence Array files first.
    //

    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION)

          ||

        (Scb->AttributeTypeCode == $DATA
            && Scb->AttributeName.Length == 0
            && (NtfsEqualMftRef( &Scb->Fcb->FileReference, &MftFileReference )
                || NtfsEqualMftRef( &Scb->Fcb->FileReference, &MftTemp )
                || NtfsEqualMftRef( &Scb->Fcb->FileReference, &Mft2FileReference )
                || NtfsEqualMftRef( &Scb->Fcb->FileReference, &LogFileReference )))) {

        SetFlag( Scb->ScbState, SCB_STATE_USA_PRESENT );
    }

    return;
}


//
//  Local support routine.
//

BOOLEAN
NtfsRemoveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN CheckForAttributeTable
    )

/*++

Routine Description:

    This routine will try to remove an Scb from the Fcb/Scb tree.
    It deals with the case where we can make no attempt to remove
    the Scb, the case where we start the process but can't complete
    it, and finally the case where we remove the Scb entirely.

    The following conditions prevent us from removing the Scb at all.

        The open count is greater than 1.
        It is the root directory.
        It is an index Scb with no stream file and an outstanding close.
        It is a data file with a non-zero close count.

    We start the teardown under the following conditions.

        It is an index with an open count of 1, and a stream file object.

    We totally remove the Scb when the open count is zero.

Arguments:

    Scb - Supplies the Scb to test

    CheckForAttributeTable - Indicates that we don't want to remove this
        Scb in this thread if it is in the open attribute table.  We will
        queue an async close in this case.  This is to prevent us from
        deleting an Scb which may be needed in the abort path.

Return Value:

    BOOLEAN - TRUE if the Scb was removed, FALSE otherwise.  We return FALSE for
        the case where we start the process but don't finish.

--*/

{
    BOOLEAN ScbRemoved;

    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveScb:  Entered\n") );
    DebugTrace( 0, Dbg, ("Scb   ->  %08lx\n", Scb) );

    ScbRemoved = FALSE;

    //
    //  If the Scb is not the root Scb and the count is less than two,
    //  then this Scb is a candidate for removal.
    //

    if ((SafeNodeType( Scb ) != NTFS_NTC_SCB_ROOT_INDEX) && (Scb->CleanupCount == 0)) {

        //
        //
        //  If this is a data file or it is an index without children,
        //  we can get rid of the Scb if there are no children.  If
        //  there is one open count and it is the file object, we
        //  can start the cleanup on the file object.
        //

        if ((SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA) ||
            (SafeNodeType( Scb ) == NTFS_NTC_SCB_MFT) ||
            IsListEmpty( &Scb->ScbType.Index.LcbQueue )) {

            //
            //  Check if we need to post a request to the async queue.
            //

            if (CheckForAttributeTable &&
                (Scb->NonpagedScb->OpenAttributeTableIndex != 0)) {

                NtfsAddScbToFspClose( IrpContext, Scb, FALSE );

            } else {

                if (Scb->CloseCount == 0) {

                    NtfsDeleteScb( IrpContext, &Scb );
                    ScbRemoved = TRUE;

                //
                //  Else we know the open count is 1 or 2.  If there is a stream
                //  file, we discard it (but not for the special system
                //  files) that get removed on dismount
                //

                } else if (((Scb->FileObject != NULL) ||
#ifdef  COMPRESS_ON_WIRE
                            (Scb->Header.FileObjectC != NULL)
#else
                            FALSE
#endif

                            ) &&

                           !FlagOn(Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

                    NtfsDeleteInternalAttributeStream( Scb, (BOOLEAN) (Scb->Fcb->LinkCount == 0), FALSE );

                    //
                    //  If the close count went to zero then remove the Scb.
                    //

                    if (Scb->CloseCount == 0) {

                        NtfsDeleteScb( IrpContext, &Scb );
                        ScbRemoved = TRUE;
                    }
                }
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsRemoveScb:  Exit  ->  %04x\n", ScbRemoved) );

    return ScbRemoved;
}


//
//  Local support routine
//

BOOLEAN
NtfsPrepareFcbForRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB StartingScb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable
    )

/*++

Routine Description:

    This routine will attempt to prepare the Fcb for removal from the Fcb/Scb
    tree.  It will try to remove all of the Scb's and test finally if
    all of the close count has gone to zero.  NOTE the close count is incremented
    by routines to reference this Fcb to keep it from being torn down.  An empty
    Scb list isn't enough to insure that the Fcb can be removed.

Arguments:

    Fcb - This is the Fcb to remove.

    StartingScb - This is the Scb to remove first.

    CheckForAttributeTable - Indicates that we should not teardown an
        Scb which is in the attribute table.  Instead we will attempt
        to put an entry on the async close queue.  This will be TRUE
        if we may need the Scb to abort the current transaction.

Return Value:

    BOOLEAN - TRUE if the Fcb can be removed, FALSE otherwise.

--*/

{
    PSCB Scb;

    PAGED_CODE();

    //
    //  Try to remove each Scb in the Fcb queue.
    //

    while (TRUE) {

        if (IsListEmpty( &Fcb->ScbQueue )) {

            if (Fcb->CloseCount == 0) {

                return TRUE;

            } else {

                return FALSE;
            }
        }

        if (ARGUMENT_PRESENT( StartingScb )) {

            Scb = StartingScb;
            StartingScb = NULL;

        } else {

            Scb = CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                     SCB,
                                     FcbLinks );
        }

        //
        //  Another thread along the create path could be active on
        //  one of these Scbs. If we try to remove the Attribute List Scb and
        //  somebody else has an index pinned, we'll wait on an VacbActiveCount
        //  forever. So, we want to skip the AttributeList Scb,
        //  unless it's the only Scb around. (This'll get cleaned up, eventually).
        //

        if ((Scb->AttributeTypeCode == $ATTRIBUTE_LIST) &&
            (Fcb->ScbQueue.Flink != Fcb->ScbQueue.Blink)) {

            RemoveEntryList( &Scb->FcbLinks );
            InsertTailList( &Fcb->ScbQueue, &Scb->FcbLinks );
            continue;
        }

        //
        //  Try to remove this Scb.  If the call to remove didn't succeed
        //  but the close count has gone to zero, it means that a recursive
        //  close was generated which removed a stream file.  In that
        //  case we can delete the Scb now.
        //

        if (!NtfsRemoveScb( IrpContext, Scb, CheckForAttributeTable )) {

            //
            //  Return FALSE to indicate the Fcb can't go away.
            //

            return FALSE;
        }
    }
}


//
//  Local support routine
//

VOID
NtfsTeardownFromLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB StartingFcb,
    IN PLCB StartingLcb,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedStartingLcb,
    OUT PBOOLEAN RemovedStartingFcb
    )

/*++

Routine Description:

    This routine is called to remove a link and continue moving up the
    tree looking for more elements to remove.  We will check that the
    link is unreferenced.  NOTE this Lcb must point up to a directory
    so that other than our starting Lcb no Lcb we encounter will
    have multiple parents.

Arguments:

    Vcb - Vcb for this volume.

    StartingFcb - This is the Fcb whose link we are trying to remove.

    StartingLcb - This is the Lcb to walk up through.  Note that
        this may be a bogus pointer.  It is only valid if there
        is at least one Fcb in the queue.

    CheckForAttributeTable - Indicates that we should not teardown an
        Scb which is in the attribute table.  Instead we will attempt
        to put an entry on the async close queue.  This will be TRUE
        if we may need the Scb to abort the current transaction.

    AcquireFlags - Indicates whether we should abort the teardown when
        we can't acquire a parent.  When called from some path where we may
        hold the MftScb or another resource in another path up the tree.

    RemovedStartingLcb - Address to store TRUE if we remove the
        starting Lcb.

    RemovedStartingFcb - Address to store TRUE if we remove the
        starting Fcb.

Return Value:

    None

--*/

{
    PSCB ParentScb;
    BOOLEAN AcquiredParentScb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;
    BOOLEAN UpdateStandardInfo;
    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN StandardInfoUpdateAllowed = FALSE;
    BOOLEAN AcquiredParentExclusive;
    BOOLEAN EmptyParentQueue;

    PLCB Lcb;
    PFCB Fcb = StartingFcb;

    PAGED_CODE();

    //
    //  Use a try-finally to free any resources held.
    //

    try {

        if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
            (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_SUCCESS)) {

            StandardInfoUpdateAllowed = TRUE;
        }

        while (TRUE) {

            ParentScb = NULL;
            EmptyParentQueue = FALSE;

            //
            //  Check if we need to update the standard information for this file.
            //

            if (StandardInfoUpdateAllowed &&
                !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED | FCB_STATE_SYSTEM_FILE )) {

                UpdateStandardInfo = TRUE;

            } else {

                UpdateStandardInfo = FALSE;
            }

            //
            //  Look through all of the Lcb's for this Fcb.
            //

            while (!IsListEmpty( &Fcb->LcbQueue )) {

                if (Fcb == StartingFcb) {

                    Lcb = StartingLcb;

                } else {

                    Lcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                             LCB,
                                             FcbLinks );
                }

                //
                //  Get out if not the last handle on this Lcb.
                //

                if (Lcb->CleanupCount != 0) {

                    leave;
                }

                //
                //  Acquire the parent if not already acquired.
                //

                if (ParentScb == NULL) {

                    ParentScb = Lcb->Scb;

                    //
                    //  Do an unsafe test to see if we want the parent
                    //  shared or exclusive.  We want it exclusive
                    //  if we will be walking up the tree because we are at the last Lcb.
                    //

                    if (ParentScb->ScbType.Index.LcbQueue.Flink == ParentScb->ScbType.Index.LcbQueue.Blink) {

                        if (!NtfsAcquireExclusiveFcb( IrpContext,
                                                      ParentScb->Fcb,
                                                      ParentScb,
                                                      ACQUIRE_NO_DELETE_CHECK | AcquireFlags )) {

                            leave;
                        }

                        if (FlagOn( ParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                            NtfsSnapshotScb( IrpContext, ParentScb );
                        }

                        AcquiredParentExclusive = TRUE;

                    } else {

                        //
                        //  Try to acquire the parent but check whether we
                        //  should wait.
                        //

                        if (!NtfsAcquireSharedFcbCheckWait( IrpContext,
                                                            ParentScb->Fcb,
                                                            AcquireFlags )) {

                            leave;
                        }

                        AcquiredParentExclusive = FALSE;
                    }

                    AcquiredParentScb = TRUE;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                } else {

                    //
                    //  We better be looking at another Lcb to the same parent.
                    //

                    ASSERT( ParentScb == Lcb->Scb );
#endif
                }

                //
                //  Check if we collide with a create moving down the tree.
                //

                if (Lcb->ReferenceCount != 0) {

                    leave;
                }

                //
                //  Now remove the Lcb.  Remember if this is our original
                //  Lcb.
                //

                if (Lcb == StartingLcb) {

                    *RemovedStartingLcb = TRUE;
                }

                //
                //  We may only have the parent shared at this point.  We need
                //  to serialize using the parent shared plus the fast
                //  mutex to remove the Lcb.  We could test whether we need
                //  to do this but hopefully the typical case is that we
                //  have it shared and it won't be very expensive to acquire
                //  it exclusively at this point.
                //

                NtfsAcquireFsrtlHeader( ParentScb );
                NtfsDeleteLcb( IrpContext, &Lcb );

                //
                //  Remember if the parent Lcb queue is now empty.
                //

                if (IsListEmpty( &ParentScb->ScbType.Index.LcbQueue )) {

                    EmptyParentQueue = TRUE;
                }

                NtfsReleaseFsrtlHeader( ParentScb );

                //
                //  If this is the first Fcb then exit the loop.
                //

                if (Fcb == StartingFcb) {

                    break;
                }
            }

            //
            //  If we get here it means we removed all of the Lcb's we
            //  could for the current Fcb.  If the list is empty we
            //  can remove the Fcb itself.
            //

            if (IsListEmpty( &Fcb->LcbQueue )) {

                //
                //  If this is a directory that was opened by Id it is
                //  possible that we still have an update to perform
                //  for the duplicate information and possibly for
                //  standard information.
                //

                if (UpdateStandardInfo &&
                    (FlagOn( Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS ) ||
                     FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO ))) {

                    //
                    //  Use a try-except, we ignore errors here.
                    //

                    try {

                        NtfsUpdateStandardInformation( IrpContext, Fcb );
                        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        NtfsMinimumExceptionProcessing( IrpContext );
                    }

                    NtfsCheckpointCurrentTransaction( IrpContext );
                }

                //
                //  Our worst nightmare has come true.  We had to create an Scb
                //  and a stream in order to write out the duplicate information.
                //  This will happen if we have a non-resident attribute list.
                //

                if (!IsListEmpty( &Fcb->ScbQueue)) {

                    //
                    //  Dereference any file object and delete the Scb if possible.
                    //

                    NtfsRemoveScb( IrpContext,
                                    CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                                       SCB,
                                                       FcbLinks ),
                                   FALSE );
                }

                //
                //  If the list is now empty then check the reference count.
                //

                if (IsListEmpty( &Fcb->ScbQueue)) {

                    //
                    //  Now we are ready to remove the current Fcb.  We need to
                    //  do a final check of the reference count to make sure
                    //  it isn't being referenced in an open somewhere.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;

                    if (Fcb->ReferenceCount == 0) {

                        if (Fcb == StartingFcb) {

                            *RemovedStartingFcb = TRUE;
                        }

                        NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );
                        AcquiredFcb = FALSE;

                    } else {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = FALSE;
                    }
                }
            }

            //
            //  Move to the Fcb for the ParentScb.  Break out if no parent
            //  or there are no more entries on the parent.
            //

            if ((ParentScb == NULL) || !EmptyParentQueue) {

                leave;
            }

            //
            //  If we have a parent Scb then we might have it
            //  either shared or exclusive.  We can now do
            //  a thorough test to see if we need it exclusive.
            //

            if (!AcquiredParentExclusive) {

                //
                //  We need to acquire the Fcb table, reference the
                //  parent, drop the parent and reacquire exclusively.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                ParentScb->Fcb->ReferenceCount += 1;
                NtfsReleaseFcbTable( IrpContext, Vcb );
                NtfsReleaseFcb( IrpContext, ParentScb->Fcb );

                if (!NtfsAcquireExclusiveFcb( IrpContext,
                                              ParentScb->Fcb,
                                              ParentScb,
                                              ACQUIRE_NO_DELETE_CHECK | AcquireFlags )) {

                    //
                    //  We couldn't get the parent.  No problem, someone
                    //  else will do any necessary teardown.
                    //

                    AcquiredParentScb = FALSE;

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    ParentScb->Fcb->ReferenceCount -= 1;
                    NtfsReleaseFcbTable( IrpContext, Vcb );

                    leave;

                } else {

                    if (FlagOn( ParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                        NtfsSnapshotScb( IrpContext, ParentScb );
                    }

                    AcquiredParentExclusive = TRUE;
                }

                //
                //  Now decrement the parent reference.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                ParentScb->Fcb->ReferenceCount -= 1;
                NtfsReleaseFcbTable( IrpContext, Vcb );
            }

            Fcb = ParentScb->Fcb;
            AcquiredFcb = TRUE;
            AcquiredParentScb = FALSE;

            //
            //  Check if this Fcb can be removed.
            //

            if (!NtfsPrepareFcbForRemoval( IrpContext, Fcb, NULL, CheckForAttributeTable )) {

                leave;
            }
        }

    } finally {

        DebugUnwind( NtfsTeardownFromLcb );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        if (AcquiredFcb) {

            NtfsReleaseFcb( IrpContext, Fcb );
        }

        if (AcquiredParentScb) {

            NtfsReleaseScb( IrpContext, ParentScb );
        }
    }

    return;
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
NtfsFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )

/*++

Routine Description:

    This is a generic table support routine to compare two fcb table elements

Arguments:

    FcbTable - Supplies the generic table being queried

    FirstStruct - Supplies the first fcb table element to compare

    SecondStruct - Supplies the second fcb table element to compare

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    FILE_REFERENCE FirstRef = *((PFILE_REFERENCE) FirstStruct);
    FILE_REFERENCE SecondRef = *((PFILE_REFERENCE) SecondStruct);

    PAGED_CODE();

    //
    //  Use also the sequence number for all compares so file references in the
    //  fcb table are unique over time and space.  If we want to ignore sequence
    //  numbers we can zero out the sequence number field, but then we will also
    //  need to delete the Fcbs from the table during cleanup and not when the
    //  fcb really gets deleted.  Otherwise we cannot reuse file records.
    //

    if (NtfsFullSegmentNumber( &FirstRef ) < NtfsFullSegmentNumber( &SecondRef )) {

        return GenericLessThan;

    } else if (NtfsFullSegmentNumber( &FirstRef ) > NtfsFullSegmentNumber( &SecondRef )) {

        return GenericGreaterThan;

    } else {

        //
        //  SequenceNumber comparison now
        //

        if (FirstRef.SequenceNumber < SecondRef.SequenceNumber) {
            return GenericLessThan;
        } else if (FirstRef.SequenceNumber > SecondRef.SequenceNumber) {
            return GenericGreaterThan;
        } else {
            return GenericEqual;
        }

    }

    UNREFERENCED_PARAMETER( FcbTable );
}


//
//  Local support routine
//

VOID
NtfsReserveCcbNamesInLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PULONG ParentNameLength OPTIONAL,
    IN ULONG LastComponentNameLength
    )

/*++

Routine Description:

    This routine walks through a list of Ccbs and grows the name buffer as
    necessary.

Arguments:

    Lcb - Lcb with links of Ccbs to check.

    ParentNameLength - If specified then this is the full length of the new name
        to the parent directory.  Otherwise we use the existing parent name in
        each Ccb.  The separator is implied.

    LastComponentNameLength - Number of bytes needed for the last component of the name.

Return Value:

    None - This routine will raise on an allocation failure.

--*/

{
    PCCB Ccb;
    PVOID NewAllocation;
    ULONG BytesNeeded;

    PAGED_CODE();

    //
    //  Now for every ccb attached to us we need to check if we need a new
    //  filename buffer.  Protect the Ccb with the Fcb mutex to serialize access to
    //  the flags field with close.
    //

    Ccb = NULL;
    while ((Ccb = NtfsGetNextCcb( Lcb, Ccb )) != NULL) {

        //
        //  If the Ccb last component length is zero, this Ccb is for a
        //  file object that was opened by File Id.  We won't to  any
        //  work for the name in the fileobject for this.  Otherwise we
        //  compute the length of the new name and see if we have enough space
        //  The CLOSE flag indicates whether this had gone through the close path or not.
        //  We use the LockFcb command above to serialize with the setting of the close
        //  flag.
        //

        NtfsLockFcb( IrpContext, Ccb->Lcb->Fcb );

        if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID | CCB_FLAG_CLOSE )) {

            if (ARGUMENT_PRESENT( ParentNameLength )) {

                BytesNeeded = *ParentNameLength + LastComponentNameLength;

            } else {

                BytesNeeded = Ccb->LastFileNameOffset + LastComponentNameLength;
            }

            if (Ccb->FullFileName.MaximumLength < BytesNeeded) {

                //
                //  Allocate a new file name buffer and copy the existing data back into it.
                //

                NewAllocation = NtfsAllocatePoolNoRaise( PagedPool, BytesNeeded );

                if (NewAllocation == NULL) {

                    NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
                    NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
                }

                RtlCopyMemory( NewAllocation,
                               Ccb->FullFileName.Buffer,
                               Ccb->FullFileName.Length );

                if (FlagOn( Ccb->Flags, CCB_FLAG_ALLOCATED_FILE_NAME )) {

                    NtfsFreePool( Ccb->FullFileName.Buffer );
                }

                Ccb->FullFileName.Buffer = NewAllocation;
                Ccb->FullFileName.MaximumLength = (USHORT) BytesNeeded;

                SetFlag( Ccb->Flags, CCB_FLAG_ALLOCATED_FILE_NAME );
            }
        }

        NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsClearRecursiveLcb (
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine is called to clear all of the normalized names, prefix entries and hash entries in
    a subtree starting from a given Lcb.  Typically this is used as part of a rename when a parent rename
    affects the full name of all of the children.

Arguments:

    Lcb - Lcb which is root of rename.

Return Value:

    None - This routine will raise on an allocation failure.

--*/

{
    PSCB ChildScb;
    PSCB NextScb;
    PLCB NextLcb;

    PAGED_CODE();

    //
    //  Clear the index offset pointer so we will look this up again.
    //

    Lcb->QuickIndex.BufferOffset = 0;

    //
    //  Get rid of any prefixes that might still be attached to us
    //

    ASSERT( NtfsIsExclusiveScb( Lcb->Scb ) );
    NtfsRemovePrefix( Lcb );

    //
    //  Remove any hash table entries for this Lcb.
    //

    NtfsRemoveHashEntriesForLcb( Lcb );

    //
    //  And then traverse the graph underneath our fcb and remove all prefixes
    //  also used there.  For each child scb under the fcb we will traverse all of
    //  its descendant Scb children and for each lcb we encounter we will remove its prefixes.
    //

    ChildScb = NULL;
    while ((ChildScb = NtfsGetNextChildScb( Lcb->Fcb, ChildScb )) != NULL) {

        //
        //  Now we have to descend into this Scb subtree, if it exists.
        //  Then remove the prefix entries on all of the links found.
        //  Do this as a do-while so we can use common code to handle the top-level
        //  Scb as well.
        //

        NextScb = ChildScb;
        do {

            //
            //  Walk through the Lcbs of any index Scb and remove the prefix and
            //  hash entries.
            //

            if (SafeNodeType( NextScb ) == NTFS_NTC_SCB_INDEX) {

                //
                //  We better have the Vcb exclusive to descend down the tree.
                //

                ASSERT( NtfsIsExclusiveVcb( Lcb->Fcb->Vcb ));

                NextLcb = NULL;
                while ((NextLcb = NtfsGetNextChildLcb( NextScb, NextLcb )) != NULL) {

                    //
                    //  Remove any hash table and prefix entries for this Lcb.
                    //  We can be unsynchronized here because we own the Vcb
                    //  exclusive and there are no open handles on either of these.
                    //

                    NtfsRemovePrefix( NextLcb );
                    NtfsRemoveHashEntriesForLcb( NextLcb );
                }

                //
                //  If this is an index Scb with a normalized name, then free
                //  the normalized name.
                //

                if ((NextScb != ChildScb) &&
                    (NextScb->ScbType.Index.NormalizedName.Buffer != NULL)) {

                    NtfsDeleteNormalizedName( NextScb );
                }
            }

        } while ((NextScb = NtfsGetNextScb( NextScb, ChildScb )) != NULL);
    }

    return;
}


PDEALLOCATED_CLUSTERS
NtfsGetDeallocatedClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )
/*++

Routine Description:

    Add an entry if possible and neccessary to recently deallocated list and return the head of the list.
    If there isn't enough memory this routine just returns the old head
    We determine whether to add the entry based on the threshold for the mapping size

Arguments:

    Vcb -  Vcb to add entry to

Return Value:

    The new head of the list

--*/

{
    PDEALLOCATED_CLUSTERS CurrentClusters;
    PDEALLOCATED_CLUSTERS NewClusters;

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    CurrentClusters = (PDEALLOCATED_CLUSTERS) Vcb->DeallocatedClusterListHead.Flink;

    if (FsRtlNumberOfRunsInLargeMcb( &CurrentClusters->Mcb ) > NTFS_DEALLOCATED_MCB_LIMIT) {

        //
        //  Find a new deallocated cluster. Use the preallocated ones if they
        //  are not in use. If we fail to allocate memory continue to use the old one
        //

        if (Vcb->DeallocatedClusters1.Link.Flink == NULL) {

            NewClusters = &Vcb->DeallocatedClusters1;
            NewClusters->Lsn.QuadPart = 0;

        } else  if (Vcb->DeallocatedClusters2.Link.Flink == NULL) {

            NewClusters = &Vcb->DeallocatedClusters2;
            NewClusters->Lsn.QuadPart = 0;

        } else {

            NewClusters = NtfsAllocatePoolNoRaise( PagedPool, sizeof( DEALLOCATED_CLUSTERS ) );
            if (NewClusters != NULL) {
                RtlZeroMemory( NewClusters, sizeof( DEALLOCATED_CLUSTERS ) );
                FsRtlInitializeLargeMcb( &NewClusters->Mcb, PagedPool );
            }
        }

        if (NewClusters != NULL) {
            ASSERT( NewClusters->ClusterCount == 0 );

            CurrentClusters->Lsn = LfsQueryLastLsn( Vcb->LogHandle );
            InsertHeadList( &Vcb->DeallocatedClusterListHead, &NewClusters->Link );
            CurrentClusters = NewClusters;
        }
    }

    return CurrentClusters;
}


#ifdef SYSCACHE_DEBUG

#define ENTRIES_PER_PAGE (PAGE_SIZE / sizeof( ON_DISK_SYSCACHE_LOG ))

ULONG
FsRtlLogSyscacheEvent (
    IN PSCB Scb,
    IN ULONG Event,
    IN ULONG Flags,
    IN LONGLONG Start,
    IN LONGLONG Range,
    IN LONGLONG Result
    )

/*++

Routine Description:

    Logging routine for syscache tracking

Arguments:

    Scb -  Scb being tracked

    Event - SCE Event being record

    Flags -Flag for the event

    Start - starting offset

    Range - range of the action

    Result - result

Return Value:

    Sequence number for this log entry

--*/

{
    LONG TempEntry;
#ifdef SYSCACHE_DEBUG_ON_DISK
    LONG TempDiskEntry;
    LONGLONG Offset;
    PON_DISK_SYSCACHE_LOG Entry;
    PBCB Bcb;
#endif

    TempEntry = InterlockedIncrement( &(Scb->CurrentSyscacheLogEntry) );
    TempEntry = TempEntry % Scb->SyscacheLogEntryCount;
    Scb->SyscacheLog[TempEntry].Event = Event;
    Scb->SyscacheLog[TempEntry].Flags = Flags;
    Scb->SyscacheLog[TempEntry].Start = Start;
    Scb->SyscacheLog[TempEntry].Range = Range;
    Scb->SyscacheLog[TempEntry].Result = Result;

#ifdef SYSCACHE_DEBUG_ON_DISK

    if ((Scb->Vcb->SyscacheScb != NULL) &&
        (Scb->Vcb->SyscacheScb->Header.FileSize.QuadPart > 0 )) {

        TempDiskEntry = InterlockedIncrement( &NtfsCurrentSyscacheOnDiskEntry );
        Offset = (((TempDiskEntry / ENTRIES_PER_PAGE) * PAGE_SIZE) +
                  ((TempDiskEntry % ENTRIES_PER_PAGE) * sizeof( ON_DISK_SYSCACHE_LOG )));

        Offset = Offset % Scb->Vcb->SyscacheScb->Header.FileSize.QuadPart;

        try {

            CcPreparePinWrite( Scb->Vcb->SyscacheScb->FileObject,
                               (PLARGE_INTEGER)&Offset,
                               sizeof( ON_DISK_SYSCACHE_LOG ),
                               FALSE,
                               TRUE,
                               &Bcb,
                               &Entry );

            Entry->SegmentNumberUnsafe = Scb->Fcb->FileReference.SegmentNumberLowPart;
            Entry->Event = Event;
            Entry->Flags = Flags;
            Entry->Start = Start;
            Entry->Range = Range;
            Entry->Result = Result;

            CcUnpinData( Bcb );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            ASSERT( FALSE );
        }
    }
#endif

    return TempEntry;
}


VOID
FsRtlUpdateSyscacheEvent (
    IN PSCB Scb,
    IN ULONG EntryNumber,
    IN LONGLONG Result,
    IN ULONG NewFlag
    )

/*++

Routine Description:

    Logging routine for syscache tracking - updates a prev. written record

Arguments:

    Scb -

    EntryNumber -

    Result -

    NewFlag -


Return Value:

    none

--*/

{
    Scb->SyscacheLog[EntryNumber].Flags |= NewFlag;
    Scb->SyscacheLog[EntryNumber].Result = Result;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\vattrsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    VAttrSup.c

Abstract:

    This module implements the attribute routines for NtOfs

Author:

    Tom Miller      [TomM]          10-Apr-1996

Revision History:

--*/

#include "NtfsProc.h"

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('vFtN')

#undef NtOfsMapAttribute
NTFSAPI
VOID
NtOfsMapAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    );

#undef NtOfsPreparePinWrite
NTFSAPI
VOID
NtOfsPreparePinWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    );

#undef NtOfsPinRead
NTFSAPI
VOID
NtOfsPinRead(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PMAP_HANDLE MapHandle
    );

#undef NtOfsReleaseMap
NTFSAPI
VOID
NtOfsReleaseMap (
    IN PIRP_CONTEXT IrpContext,
    IN PMAP_HANDLE MapHandle
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtOfsCreateAttribute)
#pragma alloc_text(PAGE, NtOfsCreateAttributeEx)
#pragma alloc_text(PAGE, NtOfsCloseAttribute)
#pragma alloc_text(PAGE, NtOfsDeleteAttribute)
#pragma alloc_text(PAGE, NtOfsQueryLength)
#pragma alloc_text(PAGE, NtOfsSetLength)
#pragma alloc_text(PAGE, NtfsHoldIrpForNewLength)
#pragma alloc_text(PAGE, NtOfsPostNewLength)
#pragma alloc_text(PAGE, NtOfsFlushAttribute)
#pragma alloc_text(PAGE, NtOfsPutData)
#pragma alloc_text(PAGE, NtOfsMapAttribute)
#pragma alloc_text(PAGE, NtOfsReleaseMap)
#endif


NTFSAPI
NTSTATUS
NtOfsCreateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN UNICODE_STRING Name,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG LogNonresidentToo,
    OUT PSCB *ReturnScb
    )

/*++

Routine Description:

    This routine may be called to create / open a named data attribute
    within a given file, which may or may not be recoverable.

Arguments:

    Fcb - File in which the attribute is to be created.  It is acquired exclusive

    Name - Name of the attribute for all related Scbs and attributes on disk.

    CreateOptions - Standard create flags.

    LogNonresidentToo - Supplies nonzero if updates to the attribute should
                        be logged.

    ReturnScb - Returns an Scb as handle for the attribute.

Return Value:

    STATUS_OBJECT_NAME_COLLISION -- if CreateNew and attribute already exists
    STATUS_OBJECT_NAME_NOT_FOUND -- if OpenExisting and attribute does not exist

--*/

{
    return NtOfsCreateAttributeEx( IrpContext,
                                   Fcb,
                                   Name,
                                   $DATA,
                                   CreateOptions,
                                   LogNonresidentToo,
                                   ReturnScb );
}


NTFSAPI
NTSTATUS
NtOfsCreateAttributeEx (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN UNICODE_STRING Name,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG LogNonresidentToo,
    OUT PSCB *ReturnScb
    )

/*++

Routine Description:

    This routine may be called to create / open a named data attribute
    within a given file, which may or may not be recoverable.

Arguments:

    Fcb - File in which the attribute is to be created.  It is acquired exclusive

    Name - Name of the attribute for all related Scbs and attributes on disk.

    CreateOptions - Standard create flags.

    LogNonresidentToo - Supplies nonzero if updates to the attribute should
                        be logged.

    ReturnScb - Returns an Scb as handle for the attribute.

Return Value:

    STATUS_OBJECT_NAME_COLLISION -- if CreateNew and attribute already exists
    STATUS_OBJECT_NAME_NOT_FOUND -- if OpenExisting and attribute does not exist

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN FoundAttribute;
    NTSTATUS Status = STATUS_SUCCESS;
    PSCB Scb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( NtfsIsExclusiveFcb( Fcb ));

    PAGED_CODE();

    if (AttributeTypeCode != $DATA &&
        AttributeTypeCode != $LOGGED_UTILITY_STREAM) {

        ASSERTMSG( "Invalid attribute type code in NtOfsCreateAttributeEx", FALSE );

        *ReturnScb = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Now, just create the Data Attribute.
    //

    NtfsInitializeAttributeContext( &LocalContext );

    try {

        //
        //  First see if the attribute already exists, by searching for the root
        //  attribute.
        //

        FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    AttributeTypeCode,
                                                    &Name,
                                                    NULL,
                                                    TRUE,
                                                    &LocalContext );

        //
        //  If it is not there, and the CreateOptions allow, then let's create
        //  the attribute root now.  (First cleaning up the attribute context from
        //  the lookup).
        //

        if (!FoundAttribute && (CreateOptions <= CREATE_OR_OPEN)) {

            //
            //  Make sure we acquire the quota resource before creating the stream.  Just
            //  in case we need the Mft during the create.
            //

            if (NtfsIsTypeCodeSubjectToQuota( AttributeTypeCode ) &&
                NtfsPerformQuotaOperation( Fcb )) {

                //
                //  The quota index must be acquired before the mft scb is acquired.
                //

                ASSERT( !NtfsIsExclusiveScb( Fcb->Vcb->MftScb ) ||
                        ExIsResourceAcquiredSharedLite( Fcb->Vcb->QuotaTableScb->Fcb->Resource ));

                NtfsAcquireQuotaControl( IrpContext, Fcb->QuotaControl );
            }

            NtfsCleanupAttributeContext( IrpContext, &LocalContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          AttributeTypeCode,
                                          &Name,
                                          NULL,
                                          0,
                                          0,
                                          NULL,
                                          TRUE,
                                          &LocalContext );

        //
        //  If the attribute is already there, and we were asked to create it, then
        //  return an error.
        //

        } else if (FoundAttribute && (CreateOptions == CREATE_NEW)) {

            Status = STATUS_OBJECT_NAME_COLLISION;
            leave;

        //
        //  If the attribute is not there, and we  were supposed to open existing, then
        //  return an error.
        //

        } else if (!FoundAttribute) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            leave;
        }

        //
        //  Otherwise create/find the Scb and reference it.
        //

        Scb = NtfsCreateScb( IrpContext, Fcb, AttributeTypeCode, &Name, FALSE, &FoundAttribute );

        //
        //  Make sure things are correctly reference counted
        //

        NtfsIncrementCloseCounts( Scb, TRUE, FALSE );

        //
        //  If we created the Scb, then get the no modified write set correctly.
        //

        ASSERT( !FoundAttribute ||
                (LogNonresidentToo == BooleanFlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE)) );

        if (!FoundAttribute && LogNonresidentToo) {
            SetFlag( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
            Scb->Header.ValidDataLength.QuadPart = MAXLONGLONG;
        }

        //
        //  Make sure the stream can be mapped internally.  Defer this for the Usn journal
        //  until we set up the journal bias.
        //

        if ((Scb->FileObject == NULL) && !FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {
            NtfsCreateInternalAttributeStream( IrpContext, Scb, TRUE, NULL );
        }

        NtfsUpdateScbFromAttribute( IrpContext, Scb, NtfsFoundAttribute(&LocalContext) );

    } finally {

        if (AbnormalTermination( )) {
            if (Scb != NULL) {
                NtOfsCloseAttribute( IrpContext, Scb );
            }
        }

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );
    }

    *ReturnScb = Scb;

    return Status;
}


NTFSAPI
VOID
NtOfsCloseAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to close a previously returned handle on an attribute.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

Return Value:

    None.

--*/

{
    ASSERT( NtfsIsExclusiveFcb( Scb->Fcb ));

    PAGED_CODE();

    //
    //  We either need the caller to empty this list before closing (as assumed here),
    //  or possibly empty it here.  At this point it seems better to assume that the
    //  caller must take action to insure any waiting threads will shutdown and not
    //  touch the stream anymore, then call NtOfsPostNewLength to flush the queue.
    //  If the queue is nonempty here, maybe the caller didn't think this through!
    //

    ASSERT( IsListEmpty( &Scb->ScbType.Data.WaitForNewLength ) ||
            (Scb->CloseCount > 1) );

    NtfsDecrementCloseCounts( IrpContext, Scb, NULL, TRUE, FALSE, TRUE );
}


NTFSAPI
VOID
NtOfsDeleteAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to delete an attribute with type code
    $LOGGED_UTILITY_STREAM.

Arguments:

    Fcb - Supplies an Fcb as the previously returned object handle for the file

    Scb - Supplies an Scb as the previously returned handle for this attribute.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN FoundAttribute;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        //
        //  Make sure we aren't deleting a data stream.  We do this after
        //  initializing the attribute context to make the finally clause simpler.
        //  This test can be removed if some trusted component using the NtOfs
        //  API has a legitimate need to delete other types of attributes.
        //

        NtfsInitializeAttributeContext( &LocalContext );

        if (Scb->AttributeTypeCode != $LOGGED_UTILITY_STREAM) {

            leave;
        }

        //
        //  First see if there is some attribute allocation, and if so truncate it
        //  away allowing this operation to be broken up.
        //

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       Scb->AttributeTypeCode,
                                       &Scb->AttributeName,
                                       NULL,
                                       FALSE,
                                       &LocalContext )

                &&

            !NtfsIsAttributeResident( NtfsFoundAttribute( &LocalContext ))) {

            ASSERT( Scb->FileObject != NULL );

            NtfsDeleteAllocation( IrpContext, NULL, Scb, 0, MAXLONGLONG, TRUE, TRUE );
        }

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        //
        //  Initialize the attribute context on each trip through the loop.
        //

        NtfsInitializeAttributeContext( &LocalContext );

        //
        //  Now there should be a single attribute record, so look it up and delete it.
        //

        FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    Scb->AttributeTypeCode,
                                                    &Scb->AttributeName,
                                                    NULL,
                                                    TRUE,
                                                    &LocalContext );

        //
        //  If this stream is subject to quota, make sure the quota has been enlarged.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   (DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION),
                                   &LocalContext );

        SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );
    }

    return;
}


NTFSAPI
LONGLONG
NtOfsQueryLength (
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to query the Length (FileSize) of an attribute.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

    Length - Returns the current Length of the attribute.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    LONGLONG Length;

    PAGED_CODE();

    ExAcquireFastMutex( Scb->Header.FastMutex );
    Length = Scb->Header.FileSize.QuadPart;
    ExReleaseFastMutex( Scb->Header.FastMutex );
    return Length;
}


NTFSAPI
VOID
NtOfsSetLength (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine may be called to set the Length (FileSize) of an attribute.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

    Length - Supplies the new Length for the attribute.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PFILE_OBJECT FileObject = Scb->FileObject;
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN Truncating = FALSE;
    BOOLEAN CleanupAttrContext = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( NtfsIsExclusiveScb( Scb ));

    ASSERT(FileObject != NULL);

    PAGED_CODE();

    try {

        //
        //  If this is a resident attribute we will try to keep it resident.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            //
            //  If the new file size is larger than a file record then convert
            //  to non-resident and use the non-resident code below.  Otherwise
            //  call ChangeAttributeValue which may also convert to nonresident.
            //

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext,
                                       Scb,
                                       NULL,
                                       &AttrContext );

            //
            //  Either convert or change the attribute value.
            //

            if (Length >= Scb->Vcb->BytesPerFileRecordSegment) {

                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &AttrContext ),
                                          FALSE,
                                          &AttrContext );

            } else {

                ULONG AttributeOffset;

                //
                //  We are sometimes called by MM during a create section, so
                //  for right now the best way we have of detecting a create
                //  section is whether or not the requestor mode is kernel.
                //

                if ((ULONG)Length > Scb->Header.FileSize.LowPart) {

                    AttributeOffset = Scb->Header.FileSize.LowPart;

                } else {

                    AttributeOffset = (ULONG) Length;
                }

                //
                //  ****TEMP  Ideally we would do this simple case by hand.
                //

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          AttributeOffset,
                                          NULL,
                                          (ULONG)Length - AttributeOffset,
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          &AttrContext );

                ExAcquireFastMutex( Scb->Header.FastMutex );

                Scb->Header.FileSize.QuadPart = Length;

                //
                //  If the file went non-resident, then the allocation size in
                //  the Scb is correct.  Otherwise we quad-align the new file size.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                    Scb->Header.AllocationSize.LowPart = QuadAlign( Scb->Header.FileSize.LowPart );
                    if (Scb->Header.ValidDataLength.QuadPart != MAXLONGLONG) {
                        Scb->Header.ValidDataLength.QuadPart = Length;
                    }

                    Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

                } else {

                    SetFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
                }

                ExReleaseFastMutex( Scb->Header.FastMutex );

                //
                //  Now update Cc.
                //

                CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Scb->Header.AllocationSize );

                //
                //  ****TEMP****  This hack is awaiting our actually doing this change
                //                in CcSetFileSizes.
                //

                *((PLONGLONG)(Scb->NonpagedScb->SegmentObject.SharedCacheMap) + 5) = Length;

                leave;
            }
        }

        //
        //  Nonresident path
        //
        //  Now determine where the new file size lines up with the
        //  current file layout.  The two cases we need to consider are
        //  where the new file size is less than the current file size and
        //  valid data length, in which case we need to shrink them.
        //  Or we new file size is greater than the current allocation,
        //  in which case we need to extend the allocation to match the
        //  new file size.
        //

        if (Length > Scb->Header.AllocationSize.QuadPart) {

            LONGLONG NewAllocationSize = Length;
            BOOLEAN AskForMore = TRUE;

            //
            //  See if this is the Usn Journal to enforce allocation granularity.
            //
            //  ****    Temporary - this support should be generalized with an Scb field
            //                      settable by all callers.
            //

            if (Scb == Vcb->UsnJournal) {

                LONGLONG MaxAllocation;

                //
                //  Limit ourselves to 128 runs.  We don't want to commit in the
                //  middle of the allocation.
                //

                NewAllocationSize = MAXIMUM_RUNS_AT_ONCE * Vcb->BytesPerCluster;

                //
                //  Don't use more than 1/4 of the free space on the volume.
                //

                MaxAllocation = Int64ShllMod32( Vcb->FreeClusters, Vcb->ClusterShift - 2 );

                if (NewAllocationSize > MaxAllocation) {

                    //
                    //  Round down to the Max.  Don't worry if there is nothing, our code
                    //  below will catch this case and the allocation package always rounds
                    //  to a compression unit boundary.
                    //

                    NewAllocationSize = MaxAllocation;
                }

                //
                //  Don't grow by more than the Usn delta.
                //

                if (NewAllocationSize > (LONGLONG) Vcb->UsnJournalInstance.AllocationDelta) {

                    NewAllocationSize = (LONGLONG) Vcb->UsnJournalInstance.AllocationDelta;
                }

                NewAllocationSize += (LONGLONG) Scb->Header.AllocationSize.QuadPart;

                //
                //  Handle possible weird case.
                //

                if (NewAllocationSize < Length) {
                    NewAllocationSize = Length;
                }

                //
                //  Always pad the allocation to a compression unit boundary.
                //

                ASSERT( Scb->CompressionUnit != 0 );
                NewAllocationSize += Scb->CompressionUnit - 1;
                NewAllocationSize &= ~((LONGLONG) (Scb->CompressionUnit - 1));

                AskForMore = FALSE;

            } else if (Scb->Header.PagingIoResource == NULL) {

                //
                //  If the file is sparse then make sure we allocate a full compression unit.
                //  Otherwise we can end up with a partially allocated chunk in the Usn
                //  Journal.
                //

                if (Scb->CompressionUnit != 0) {

                    NewAllocationSize += Scb->CompressionUnit - 1;
                    ((PLARGE_INTEGER) &NewAllocationSize)->LowPart &= ~(Scb->CompressionUnit - 1);
                }

                AskForMore = FALSE;
            }

            //
            //  Add the allocation.  Never ask for extra for logged streams.
            //

            NtfsAddAllocation( IrpContext,
                               FileObject,
                               Scb,
                               LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ),
                               LlClustersFromBytes(Scb->Vcb, (NewAllocationSize - Scb->Header.AllocationSize.QuadPart)),
                               AskForMore,
                               NULL );


            ExAcquireFastMutex( Scb->Header.FastMutex );

        //
        //  Otherwise see if we have to knock these numbers down...
        //

        } else {

            ExAcquireFastMutex( Scb->Header.FastMutex );
            if ((Length < Scb->Header.ValidDataLength.QuadPart) &&
                (Scb->Header.ValidDataLength.QuadPart != MAXLONGLONG)) {

                Scb->Header.ValidDataLength.QuadPart = Length;
            }

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                (Length < Scb->ValidDataToDisk)) {

                Scb->ValidDataToDisk = Length;
            }
        }

        //
        //  Now put the new size in the Scb.
        //

        Scb->Header.FileSize.QuadPart = Length;
        ExReleaseFastMutex( Scb->Header.FastMutex );

        //
        //  Call our common routine to modify the file sizes.  We are now
        //  done with Length and NewValidDataLength, and we have
        //  PagingIo + main exclusive (so no one can be working on this Scb).
        //  NtfsWriteFileSizes uses the sizes in the Scb, and this is the
        //  one place where in Ntfs where we wish to use a different value
        //  for ValidDataLength.  Therefore, we save the current ValidData
        //  and plug it with our desired value and restore on return.
        //

        NtfsWriteFileSizes( IrpContext,
                            Scb,
                            &Scb->Header.ValidDataLength.QuadPart,
                            FALSE,
                            TRUE,
                            TRUE );

        //
        //  Now update Cc.
        //

        NtfsSetCcFileSizes( FileObject, Scb, (PCC_FILE_SIZES)&Scb->Header.AllocationSize );

    } finally {

        if (CleanupAttrContext) {
            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

    }
}


NTFSAPI
NTSTATUS
NtfsHoldIrpForNewLength (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PIRP Irp,
    IN LONGLONG Length,
    IN PDRIVER_CANCEL CancelRoutine,
    IN PVOID CapturedData OPTIONAL,
    OUT PVOID *CopyCapturedData OPTIONAL,
    IN ULONG CapturedDataLength
    )

/*++

RoutineDescription:

    This routine may be called to wait until the designated stream exceeds the specified
    length.

Arguments:

    Scb - Supplies the stream to wait on.

    Irp - Supplies the address of the Irp to hold

    Length - Supplies the length to be exceeded.  To wait for any file extend, supply the last seen
             FileSize.  To wait for N new bytes wait for last seen FileSize + N.

    CancelRoutine - Routine to register as the cancel routine.

    CapturedData - Specified if caller wishes to have auxillary data captured to pool.

    CopyCapturedData - Address to store copy of the captured data.

    CapturedDataLength - Length of the auxillary data to capture.  Must be 0 if CapturedData not
                         specified.

Return value:

    NTSTATUS - Status of posting this request.  STATUS_CANCELLED if the irp has been cancelled
        before we could register a callback, STATUS_PENDING if the request was posted without
        problem.  Any other error indicates the irp wasn't posted and our caller needs to
        clean it up.

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength;
    NTSTATUS Status = STATUS_PENDING;

    PAGED_CODE();

    //
    //  Allocate and initialize a wait block.
    //

    WaitForNewLength = NtfsAllocatePool( NonPagedPool, QuadAlign(sizeof(WAIT_FOR_NEW_LENGTH)) + CapturedDataLength );
    RtlZeroMemory( WaitForNewLength, sizeof(WAIT_FOR_NEW_LENGTH) );
    if (ARGUMENT_PRESENT(CapturedData)) {
        RtlCopyMemory( Add2Ptr(WaitForNewLength, QuadAlign(sizeof(WAIT_FOR_NEW_LENGTH))),
                       CapturedData,
                       CapturedDataLength );
        CapturedData = Add2Ptr(WaitForNewLength, QuadAlign(sizeof(WAIT_FOR_NEW_LENGTH)));

        *CopyCapturedData = CapturedData;
    }

    WaitForNewLength->Irp = Irp;
    WaitForNewLength->Length = Length;
    WaitForNewLength->Stream = Scb;
    WaitForNewLength->Status = STATUS_SUCCESS;
    WaitForNewLength->Flags = NTFS_WAIT_FLAG_ASYNC;

    //
    //  Prepare the Irp for hanging around.  Only make this call once per Irp.  We occasionally
    //  wake up a waiting Irp and then find we don't have enough data to return.  In that
    //  case we don't want to clean up the 'borrowed' IrpContext and the Irp has already
    //  been prepared.
    //

    if (IrpContext->OriginatingIrp == Irp) {

        NtfsPrePostIrp( IrpContext, Irp );
    }

    //
    //  Synchronize to queue and initialize the wait block.
    //

    ExAcquireFastMutex( Scb->Header.FastMutex );

    if (NtfsSetCancelRoutine( Irp, CancelRoutine, (ULONG_PTR) WaitForNewLength, TRUE )) {

        InsertTailList( &Scb->ScbType.Data.WaitForNewLength, &WaitForNewLength->WaitList );
        IoMarkIrpPending( Irp );

    //
    //  The irp has already been marked for cancel.
    //

    } else {

        Status = STATUS_CANCELLED;
        NtfsFreePool( WaitForNewLength );
    }

    ExReleaseFastMutex( Scb->Header.FastMutex );

    //
    //  Mark the Irp pending and get out.
    //

    return Status;
}


NTFSAPI
NTSTATUS
NtOfsWaitForNewLength (
    IN PSCB Scb,
    IN LONGLONG Length,
    IN ULONG Async,
    IN PIRP Irp,
    IN PDRIVER_CANCEL CancelRoutine,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

RoutineDescription:

    This routine may be called to wait until the designated stream exceeds the specified
    length.

Arguments:

    Scb - Supplies the stream to wait on.

    Length - Supplies the length to be exceeded.  To wait for any file extend, supply the last seen
             FileSize.  To wait for N new bytes wait for last seen FileSize + N.

    Async - Indicates if we want to complete this request in another thread in
        the case of cancel.

    Irp - Supplies Irp of current request, so that wait can be skipped if Irp has been cancelled.

    CancelRoutine - This is the cancel routine to store in the Irp.

    TimeOut - Supplies an standard optional timeout spec, in case the caller wants to set
              a max time to wait.

Return value:

    NTSTATUS - Status to proceed with the request.  It may be STATUS_SUCCESS, STATUS_TIMEOUT or
        STATUS_CANCELLED.  It may also be some other error specific to this type of request.
        In general the caller may wish to ignore the status code since they own the Irp now
        and are responsible for completing it.

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength;
    LONGLONG OriginalLength = Scb->Header.FileSize.QuadPart;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Allocate and initialize a wait block.
    //

    WaitForNewLength = NtfsAllocatePool( NonPagedPool, sizeof( WAIT_FOR_NEW_LENGTH ));
    WaitForNewLength->Irp = Irp;
    WaitForNewLength->Length = Length;
    WaitForNewLength->Stream = Scb;
    WaitForNewLength->Status = STATUS_SUCCESS;

    //
    //  Take different action if this is async or sync.
    //

    if (Async) {

        WaitForNewLength->Flags = NTFS_WAIT_FLAG_ASYNC;

    } else {

        WaitForNewLength->Flags = 0;
        KeInitializeEvent( &WaitForNewLength->Event, NotificationEvent, FALSE );
    }

    //
    //  Test if we need to wait at all.
    //

    ExAcquireFastMutex( Scb->Header.FastMutex );

    //
    //  Has the length already changed?  If not we must wait.
    //

    if (Scb->Header.FileSize.QuadPart <= Length) {

        //
        //  Now set up the cancel routine.  Return cancel if the user has
        //  already cancelled this.  Otherwise set up to wait.
        //

        if (NtfsSetCancelRoutine( Irp, CancelRoutine, (ULONG_PTR) WaitForNewLength, Async )) {

            InsertTailList( &Scb->ScbType.Data.WaitForNewLength, &WaitForNewLength->WaitList );
            ExReleaseFastMutex( Scb->Header.FastMutex );

            //
            //  Now wait for someone to signal the length change.
            //

            if (!Async) {

                do {
                    Status = KeWaitForSingleObject( &WaitForNewLength->Event,
                                                    Executive,
                                                    (KPROCESSOR_MODE)(ARGUMENT_PRESENT(Irp) ?
                                                                        Irp->RequestorMode :
                                                                        KernelMode),
                                                    TRUE,
                                                    Timeout );

                    //
                    //  If the system timed out but there was no change in the file length then
                    //  we want to wait for the first change of the file.  Wait again but without
                    //  a timeout and a length of the current size + 1.  This satisfies the timeout
                    //  semantics which are don't wait for the full user length request to be satisfied
                    //  if it doesn't occur within the timeout period.  Return either what has changed
                    //  in that time or the first change which occurs if nothing changed within the
                    //  timeout period.
                    //

                    if ((Status == STATUS_TIMEOUT) &&
                        ARGUMENT_PRESENT( Timeout ) &&
                        (Scb->Header.FileSize.QuadPart == OriginalLength)) {

                        Timeout = NULL;
                        WaitForNewLength->Length = OriginalLength + 1;

                        //
                        //  Set the status to STATUS_KERNEL_APC so we will retry.
                        //

                        Status = STATUS_KERNEL_APC;
                        continue;
                    }

                } while (Status == STATUS_KERNEL_APC);

                //
                //  Make sure to clear the cancel routine.  We don't care if
                //  a cancel is underway here.
                //

                ExAcquireFastMutex( Scb->Header.FastMutex );

                //
                //  Make a timeout look like STATUS_SUCCESS.  Otherwise return the error.
                //

                if (Status == STATUS_TIMEOUT) {

                    Status = STATUS_SUCCESS;

                    //
                    //  Clear the cancel routine.
                    //

                    NtfsClearCancelRoutine( WaitForNewLength->Irp );

                } else {

                    //
                    //  If the wait completed with success then check for the error
                    //  in the wait block.
                    //

                    if (Status == STATUS_SUCCESS) {

                        Status = WaitForNewLength->Status;

                    //
                    //  Clear the cancel routine.
                    //

                    } else {

                        NtfsClearCancelRoutine( WaitForNewLength->Irp );
                    }
                }

                RemoveEntryList( &WaitForNewLength->WaitList );
                ExReleaseFastMutex( Scb->Header.FastMutex );
                NtfsFreePool( WaitForNewLength );

            //
            //  The current thread is finished with the Irp.
            //

            } else {

                Status = STATUS_PENDING;
            }

        //
        //  The irp has already been marked for cancel.
        //

        } else {

            ExReleaseFastMutex( Scb->Header.FastMutex );
            NtfsFreePool( WaitForNewLength );
            Status = STATUS_CANCELLED;
        }

    } else {

        ExReleaseFastMutex( Scb->Header.FastMutex );
        NtfsFreePool( WaitForNewLength );
    }


    return Status;
}


VOID
NtOfsPostNewLength (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PSCB Scb,
    IN BOOLEAN WakeAll
    )

/*++

RoutineDescription:

    This routine may be called to wake one or more waiters based on the desired FileSize change,
    or to unconditionally wake all waiters (such as for a shutdown condition).

    NOTE:  The caller must have the FsRtl header mutex acquired when calling this routine.

Arguments:

    Scb - Supplies the stream to act on.

    WakeAll - Supplies TRUE if all waiters should be unconditionally woken.

Return value:

    None.

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength, WaiterToWake;

    ASSERT(FIELD_OFFSET(WAIT_FOR_NEW_LENGTH, WaitList) == 0);

    PAGED_CODE();

    ExAcquireFastMutex( Scb->Header.FastMutex );
    WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)Scb->ScbType.Data.WaitForNewLength.Flink;

    while (WaitForNewLength != (PWAIT_FOR_NEW_LENGTH)&Scb->ScbType.Data.WaitForNewLength) {

        //
        //  If we are supposed to wake this guy, then move our pointer to the next guy
        //  first, then wake him, setting his event after removing him from the list,
        //  since setting the event will cause him to eventually reuse the stack space
        //  containing the wait block.
        //

        if ((Scb->Header.FileSize.QuadPart > WaitForNewLength->Length) || WakeAll) {
            WaiterToWake = WaitForNewLength;
            WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)WaitForNewLength->WaitList.Flink;

            //
            //  If this is for an asynchronous Irp, then remove him from the list and
            //  drop the mutex to do further processing.  We only do further processing
            //  if there is not currently a cancel thread active for this Irp.
            //
            //  NOTE:   This code currently relies on the fact that there is just one
            //          caller to the routine to hold an Irp.  If more such caller's
            //          surface, then the routine address would have to be stored in
            //          the wait context.
            //
            //  If cancel is active then we will skip over this Irp.
            //

            if (NtfsClearCancelRoutine( WaiterToWake->Irp )) {

                if (FlagOn( WaiterToWake->Flags, NTFS_WAIT_FLAG_ASYNC )) {

                    //
                    //  Make sure we decrement the reference count in the Scb.
                    //

                    InterlockedDecrement( &Scb->CloseCount );
                    RemoveEntryList( &WaiterToWake->WaitList );
                    ExReleaseFastMutex( Scb->Header.FastMutex );

                    //
                    //  Nothing really should go wrong, unless we get an I/O error,
                    //  none the less, we want to stop any exceptions and complete
                    //  the request ourselves rather than impact our caller.
                    //

                    if (ARGUMENT_PRESENT( IrpContext )) {

                        try {
                            NtfsReadUsnJournal( IrpContext,
                                                WaiterToWake->Irp,
                                                FALSE );
                        } except(NtfsExceptionFilter( NULL, GetExceptionInformation())) {
                            NtfsCompleteRequest( NULL, WaiterToWake->Irp, GetExceptionCode() );
                        }

                    //
                    //  Assume the only caller with no IrpContext is cancelling the request.
                    //

                    } else {

                        NtfsCompleteRequest( NULL, WaiterToWake->Irp, STATUS_CANCELLED );
                    }

                    //
                    //  Free the wait block and go back to the beginning of the list.
                    //  Is it possible that we can into a continuous loop here?  We may
                    //  need a strategy to recognize which entries we have visited
                    //  in this loop.
                    //

                    NtfsFreePool( WaiterToWake );
                    ExAcquireFastMutex( Scb->Header.FastMutex );
                    WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)Scb->ScbType.Data.WaitForNewLength.Flink;

                } else {

                    KeSetEvent( &WaiterToWake->Event, 0, FALSE );
                }
            }

        } else {

            WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)WaitForNewLength->WaitList.Flink;
        }
    }
    ExReleaseFastMutex( Scb->Header.FastMutex );
}

NTFSAPI
VOID
NtOfsFlushAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Purge
    )

/*++

Routine Description:

    This routine flushes the specified attribute, and optionally purges it from the cache.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

    Purge - Supplies TRUE if the attribute is to be purged.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    PAGED_CODE();

    if (Purge) {
        NtfsFlushAndPurgeScb( IrpContext, Scb, NULL );
    } else {
        NtfsFlushUserStream( IrpContext, Scb, NULL, 0 );
    }
}


NTFSAPI
VOID
NtOfsPutData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    IN PVOID Data OPTIONAL
    )

/*++

Routine Description:

    This routine is called to update a range of a recoverable stream. Note this
    update cannot extend the filesize unless its a write to eof put (Offset = -1)

Arguments:

    Scb - Scb for the stream to zero.

    Offset - Offset in stream to update.

    Length - Length of stream to update in bytes.

    Data - Data to update stream with if specified, else range should be zeroed.

Return Value:

    None.

--*/

{
    ULONG OriginalLength = Length;
    BOOLEAN WriteToEof = FALSE;
    BOOLEAN MovingBackwards = TRUE;

    PAGED_CODE();

    ASSERT( FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) );

    //
    //  Handle Put to end of file.
    //

    if (Offset < 0) {
        WriteToEof = TRUE;
        Offset = Scb->Header.FileSize.QuadPart;
        NtOfsSetLength( IrpContext, Scb, Offset + Length );
    }

    ASSERT((Offset + Length) <= Scb->Header.FileSize.QuadPart);

    //
    //  First handle the resident case.
    //

    if (FlagOn(Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT)) {

        ATTRIBUTE_ENUMERATION_CONTEXT Context;
        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER Attribute;
        ULONG RecordOffset, AttributeOffset;
        PVCB Vcb = Scb->Vcb;

        NtfsInitializeAttributeContext( &Context );

        try {

            //
            //  Lookup and pin the attribute.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );
            NtfsPinMappedAttribute( IrpContext, Vcb, &Context );

            //
            //  Extract the relevant pointers and calculate offsets.
            //

            FileRecord = NtfsContainingFileRecord(&Context);
            Attribute = NtfsFoundAttribute(&Context);
            RecordOffset = PtrOffset(FileRecord, Attribute);
            AttributeOffset = Attribute->Form.Resident.ValueOffset + (ULONG)Offset;

            //
            //  Log the change while we still have the old data.
            //

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(&Context),
                          UpdateResidentValue,
                          Data,
                          Length,
                          UpdateResidentValue,
                          Add2Ptr(Attribute, Attribute->Form.Resident.ValueOffset + (ULONG)Offset),
                          Length,
                          NtfsMftOffset(&Context),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Now update this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    Data,
                                    Length,
                                    FALSE );

            //
            //  If there is a stream for this attribute, then we must update it in the
            //  cache, copying from the attribute itself in order to handle the zeroing
            //  (Data == NULL) case.
            //

            if (Scb->FileObject != NULL) {
                CcCopyWrite( Scb->FileObject,
                             (PLARGE_INTEGER)&Offset,
                             Length,
                             TRUE,
                             Add2Ptr(Attribute, AttributeOffset) );
            }

            //
            //  Optionally update ValidDataLength
            //

            Offset += Length;
            if (Offset > Scb->Header.ValidDataLength.QuadPart) {
                Scb->Header.ValidDataLength.QuadPart = Offset;
            }

        } finally {
            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

    //
    //  Now handle the nonresident case.
    //

    } else {

        PVOID Buffer;
        PVOID SubData = NULL;
        LONGLONG NewValidDataLength = Offset + Length;
        PBCB Bcb = NULL;
        ULONG PageOffset = (ULONG)Offset & (PAGE_SIZE - 1);
        ULONGLONG SubOffset;
        ULONG SubLength;
        
        ASSERT(Scb->FileObject != NULL);

        //
        //  If we are starting beyond ValidDataLength, then recurse to
        //  zero what we need.
        //

        if (Offset > Scb->Header.FileSize.QuadPart) {

            ASSERT((Offset - Scb->Header.FileSize.QuadPart) <= MAXULONG);

            NtOfsPutData( IrpContext,
                          Scb,
                          Scb->Header.FileSize.QuadPart,
                          (ULONG)(Offset - Scb->Header.FileSize.QuadPart),
                          NULL );
        }

        try {

            //
            //  Now loop until there are no more pages with new data
            //  to log.  We'll start assuming a backwards copy 
            //

            while (Length != 0) {

                if (MovingBackwards) {

                    //
                    //  Calculate the last page of the transfer - if its the 1st page start at offset
                    //  

                    SubOffset = max( Offset, BlockAlignTruncate( Offset + Length - 1, PAGE_SIZE ) );
                    SubLength = (ULONG)(Offset + Length - SubOffset); 

                    //
                    //  This guarantees we can truncate to a 32 bit value
                    // 

                    ASSERT( Offset + Length - SubOffset <= PAGE_SIZE );
                
                } else {

                    SubOffset = Offset + OriginalLength - Length;
                    SubLength = min( PAGE_SIZE - ((ULONG)SubOffset & (PAGE_SIZE - 1)), Length );
                }

                if (Data != NULL) {
                    SubData = Add2Ptr( Data, SubOffset - Offset );
                }

#ifdef BENL_DBG
                if(BlockAlignTruncate( Offset + Length - 1, PAGE_SIZE ) != BlockAlignTruncate( Offset, PAGE_SIZE )) {
//                    KdPrint(( "NTFS: pin %I64x %x from %I64x %x\n", SubOffset, SubLength, Offset, Length ));
                }
#endif
                
                //
                //  Pin the page
                //  

                NtfsPinStream( IrpContext,
                               Scb,
                               SubOffset,
                               SubLength,
                               &Bcb,
                               &Buffer );

                //
                //  Doublecheck the direction of copy based on the relative position of the 
                //  source (data) and destination (buffer).  We don't care if the source is null
                //  We'll only switch once from backwards to forwards
                //  

                if (MovingBackwards &&
                    ((PCHAR)Buffer < (PCHAR)SubData) &&
                    (Data != NULL)) {

                    //
                    //  Start over with the opposite direction
                    //  

                    MovingBackwards = FALSE;
                    NtfsUnpinBcb( IrpContext, &Bcb );
                    continue;
                }

                //
                //  Now log the changes to this page.
                //

                (VOID)
                NtfsWriteLog( IrpContext,
                              Scb,
                              Bcb,
                              UpdateNonresidentValue,
                              SubData,
                              SubLength,
                              WriteToEof ? Noop : UpdateNonresidentValue,
                              WriteToEof ? NULL : Buffer,
                              WriteToEof ? 0 : SubLength,
                              BlockAlignTruncate( SubOffset, PAGE_SIZE ),
                              (ULONG)(SubOffset & (PAGE_SIZE - 1)),
                              0,
                              (ULONG)(SubOffset & (PAGE_SIZE - 1)) + SubLength );

                //
                //  Move the data into place.
                //

                if (Data != NULL) {
                    RtlMoveMemory( Buffer, SubData, SubLength );
                } else {
                    RtlZeroMemory( Buffer, SubLength );
                }

                //
                //  Unpin the page and decrement the length
                //

                NtfsUnpinBcb( IrpContext, &Bcb );

                Length -= SubLength;
            }

            //
            //  Optionally update ValidDataLength
            //

            if (NewValidDataLength > Scb->Header.ValidDataLength.QuadPart) {

                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
                NtfsWriteFileSizes( IrpContext, Scb, &NewValidDataLength, TRUE, TRUE, TRUE );

                //
                //  See if we have to wake anyone.
                //

                if (!IsListEmpty(&Scb->ScbType.Data.WaitForNewLength)) {
                    NtfsPostToNewLengthQueue( IrpContext, Scb );
                }
            }

        } finally {
            NtfsUnpinBcb( IrpContext, &Bcb );
        }
    }
}


//
//  The following prototypes are here only for someone external to Ntfs (such as EFS)
//  trying to link to Ntfs using ntfsexp.h.
//

NTFSAPI
VOID
NtOfsMapAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    NtOfsMapAttribute maps the given region of an Scb. Its a thin wrapper
    around CcMapData.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    Scb - Scb to map data from

    Offset - offset into data

    Length - length of region to be pinned

    Buffer - returned buffer with pinned data virtual address

    MapHandle - returned map handle used to manage the pinned region.

Return Value:

    None

--*/

{
    PAGED_CODE( );
    UNREFERENCED_PARAMETER( IrpContext );
    CcMapData( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, TRUE, &MapHandle->Bcb, Buffer );
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    MapHandle->FileOffset = Offset;
    MapHandle->Length = Length;
    MapHandle->Buffer = *(PVOID *)Buffer;
}


NTFSAPI
VOID
NtOfsPreparePinWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    NtOfsPreparePinWrite maps and pins a portion of the specified attribute and
    returns a pointer to the memory.  This is equivalent to doing a NtOfsMapAttribute
    followed by NtOfsPinRead and NtOfsDirty but is more efficient.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    Scb - Scb to pin in preparation for a write

    Offset - offset into data

    Length - length of region to be pinned

    Buffer - returned buffer with pinned data virtual address

    MapHandle - returned map handle used to manage the pinned region.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );
    if ((Offset + Length) > Scb->Header.AllocationSize.QuadPart) {
        ExRaiseStatus(STATUS_END_OF_FILE);
    }
    CcPreparePinWrite( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, FALSE, TRUE, &MapHandle->Bcb, Buffer );
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    MapHandle->FileOffset = Offset;
    MapHandle->Length = Length;
    MapHandle->Buffer = Buffer;
}


NTFSAPI
VOID
NtOfsPinRead(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    NtOfsPinRead pins a section of a map and read in all pages from the mapped
    attribute.  Offset and Length must describe a byte range which is equal to
    or included by the original mapped range.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    Scb - Scb to pin data for reads in

    Offset - offset into data

    Length - length of region to be pinned

    MapHandle - returned map handle used to manage the pinned region.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );
    ASSERT( MapHandle->Bcb != NULL );
    ASSERT( (Offset >= MapHandle->FileOffset) && ((Offset + Length) <= (MapHandle->FileOffset + MapHandle->Length)) );
    CcPinMappedData( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, TRUE, &MapHandle->Bcb );
    MapHandle->FileOffset = Offset;
    MapHandle->Length = Length;
}


NTFSAPI
VOID
NtOfsReleaseMap (
    IN PIRP_CONTEXT IrpContext,
    IN PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    This routine unmaps/unpins a mapped portion of an attribute.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    MapHandle - Supplies map handle containing the bcb to be released.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    if (MapHandle->Bcb != NULL) {
        CcUnpinData( MapHandle->Bcb );
#ifdef MAPCOUNT_DBG
        IrpContext->MapCount--;
#endif
        MapHandle->Bcb = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\verfysup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Ntfs Verify volume and fcb support
    routines

Author:

    Gary Kimura         [GaryKi]            30-Jan-1992

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_VERFYSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('VFtN')

#if DBG
extern BOOLEAN NtfsCheckQuota;
#endif

BOOLEAN NtfsSuppressPopup = FALSE;

//
//  Local procedure prototypes
//

VOID
NtfsPerformVerifyDiskRead (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID Buffer,
    IN LONGLONG Offset,
    IN ULONG NumberOfBytesToRead
    );

NTSTATUS
NtfsVerifyReadCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

VOID
NtOfsCloseIndexSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB *Scb
    );


typedef struct _EVENTLOG_ERROR_PACKET {
    PVCB Vcb;
    UCHAR MajorFunction;
    ULONG TransactionId;
    PQUOTA_USER_DATA UserData;
    ULONG LogCode;
    NTSTATUS FinalStatus;
} EVENTLOG_ERROR_PACKET, *PEVENTLOG_ERROR_PACKET;


VOID
NtfsResolveVolumeAndLogEventSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    );

BOOLEAN
NtfsLogEventInternal (
    IN PVCB Vcb,
    IN UCHAR MajorFunction,
    IN ULONG TransactionId,
    IN PUNICODE_STRING String OPTIONAL,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCheckpointAllVolumes)
#pragma alloc_text(PAGE, NtfsCheckUsnTimeOut)
#pragma alloc_text(PAGE, NtfsMarkVolumeDirty)
#pragma alloc_text(PAGE, NtfsPerformVerifyOperation)
#pragma alloc_text(PAGE, NtfsPingVolume)
#pragma alloc_text(PAGE, NtfsUpdateVolumeInfo)
#pragma alloc_text(PAGE, NtOfsCloseAttributeSafe)
#pragma alloc_text(PAGE, NtOfsCloseIndexSafe)
#pragma alloc_text(PAGE, NtfsResolveVolumeAndLogEventSpecial)
#pragma alloc_text(PAGE, NtfsLogEventInternal)
#endif



BOOLEAN
NtfsPerformVerifyOperation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is used to force a verification of the volume.  It assumes
    that everything might be resource/mutex locked so it cannot take out
    any resources.  It will read in the boot sector and the dasd file record
    and from those determine if the volume is okay.  This routine is called
    whenever the real device has started rejecting I/O requests with
    VERIFY_REQUIRED.

    If the volume verifies okay then we will return TRUE otherwise we will
    return FALSE.

    It does not alter the Vcb state.

Arguments:

    Vcb - Supplies the Vcb being queried.

Return Value:

    BOOLEAN - TRUE if the volume verified okay, and FALSE otherwise.

--*/

{
    BOOLEAN Results = FALSE;

    PPACKED_BOOT_SECTOR BootSector;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    VCN LogFileVcn;
    LCN LogFileLcn;
    LONGLONG ClusterCount;
    ULONG RemainingLogBytes;
    LONGLONG CurrentLogBytes;
    PVOID CurrentLogBuffer;
    PVOID LogFileHeader = NULL;

    LONGLONG Offset;

    PSTANDARD_INFORMATION StandardInformation;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPerformVerifyOperation, Vcb = %08lx\n", Vcb) );

    BootSector = NULL;
    FileRecord = NULL;

    try {

        //
        //  Forget this volume if we have already failed the remount once.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            leave;
        }

        //
        //  Allocate a buffer for the boot sector, read it in, and then check if
        //  it some of the fields still match.  The starting lcn is zero and the
        //  size is the size of a disk sector.
        //

        BootSector = NtfsAllocatePool( NonPagedPool,
                                        (ULONG) ROUND_TO_PAGES( Vcb->BytesPerSector ));

        NtfsPerformVerifyDiskRead( IrpContext, Vcb, BootSector, (LONGLONG)0, Vcb->BytesPerSector );

        //
        //  For now we will only check that the serial numbers, mft lcn's and
        //  number of sectors match up with what they use to be.
        //

        if ((BootSector->SerialNumber !=  Vcb->VolumeSerialNumber) ||
            (BootSector->MftStartLcn !=   Vcb->MftStartLcn) ||
            (BootSector->Mft2StartLcn !=  Vcb->Mft2StartLcn) ||
            (BootSector->NumberSectors != Vcb->NumberSectors)) {

            leave;
        }

        //
        //  Allocate a buffer for the dasd file record, read it in, and then check
        //  if some of the fields still match.  The size of the record is the number
        //  of bytes in a file record segment, and because the dasd file record is
        //  known to be contiguous with the start of the mft we can compute the starting
        //  lcn as the base of the mft plus the dasd number mulitplied by the clusters
        //  per file record segment.
        //

        FileRecord = NtfsAllocatePool( NonPagedPoolCacheAligned,
                                        (ULONG) ROUND_TO_PAGES( Vcb->BytesPerFileRecordSegment ));

        Offset = LlBytesFromClusters(Vcb, Vcb->MftStartLcn) +
                 (VOLUME_DASD_NUMBER * Vcb->BytesPerFileRecordSegment);

        NtfsPerformVerifyDiskRead( IrpContext, Vcb, FileRecord, Offset, Vcb->BytesPerFileRecordSegment );

        //
        //  Given a pointer to a file record we want the value of the first attribute which
        //  will be the standard information attribute.  Then we will check the
        //  times stored in the standard information attribute against the times we
        //  have saved in the vcb.  Note that last access time will be modified if
        //  the disk was moved and mounted on a different system without doing a dismount
        //  on this system.
        //

        StandardInformation = NtfsGetValue(((PATTRIBUTE_RECORD_HEADER)Add2Ptr( FileRecord,
                                                                               FileRecord->FirstAttributeOffset )));

        if ((StandardInformation->CreationTime !=         Vcb->VolumeCreationTime) ||
            (StandardInformation->LastModificationTime != Vcb->VolumeLastModificationTime) ||
            (StandardInformation->LastChangeTime !=       Vcb->VolumeLastChangeTime) ||
            (StandardInformation->LastAccessTime !=       Vcb->VolumeLastAccessTime)) {

            leave;
        }

        //
        //  If the device is not writable we won't remount it.
        //

        if (NtfsDeviceIoControlAsync( IrpContext,
                                      Vcb->TargetDeviceObject,
                                      IOCTL_DISK_IS_WRITABLE,
                                      NULL,
                                      0 ) == STATUS_MEDIA_WRITE_PROTECTED) {

            leave;
        }

        //
        //  We need to read the start of the log file for Lfs to verify the log file.
        //

        LogFileHeader = NtfsAllocatePool( NonPagedPoolCacheAligned, PAGE_SIZE * 2 );

        //
        //  Now read in the first two pages.  We may have to perform multiple reads to
        //  get the whole thing.
        //

        RemainingLogBytes = PAGE_SIZE * 2;
        CurrentLogBuffer = LogFileHeader;
        LogFileVcn = 0;

        do {

            //
            //  Find the location of the log file start.
            //

            NtfsLookupAllocation( IrpContext,
                                  Vcb->LogFileScb,
                                  LogFileVcn,
                                  &LogFileLcn,
                                  &ClusterCount,
                                  NULL,
                                  NULL );


            CurrentLogBytes = LlBytesFromClusters( Vcb, ClusterCount );

            if (CurrentLogBytes > RemainingLogBytes) {

                CurrentLogBytes = RemainingLogBytes;
            }

            NtfsPerformVerifyDiskRead( IrpContext,
                                       Vcb,
                                       CurrentLogBuffer,
                                       LlBytesFromClusters( Vcb, LogFileLcn ),
                                       (ULONG) CurrentLogBytes );

            //
            //  Move through the log file.
            //

            RemainingLogBytes -= (ULONG) CurrentLogBytes;
            CurrentLogBuffer = Add2Ptr( CurrentLogBuffer, (ULONG) CurrentLogBytes );
            LogFileVcn += ClusterCount;

        } while (RemainingLogBytes);

        //
        //  We need to perform the revert operation on this buffer.
        //

        if (NtfsVerifyAndRevertUsaBlock( IrpContext,
                                         Vcb->LogFileScb,
                                         LogFileHeader,
                                         PAGE_SIZE * 2,
                                         0 )) {

            //
            //  Now call Lfs to verify the header.
            //

            Results = LfsVerifyLogFile( Vcb->LogHandle, LogFileHeader, PAGE_SIZE * 2 );
        }

    } finally {

        if (BootSector != NULL) { NtfsFreePool( BootSector ); }
        if (FileRecord != NULL) { NtfsFreePool( FileRecord ); }
        if (LogFileHeader != NULL) { NtfsFreePool( LogFileHeader ); }
    }

    DebugTrace( -1, Dbg, ("NtfsPerformVerifyOperation -> %08lx\n", Results) );

    return Results;
}


VOID
NtOfsCloseIndexSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB *Scb
    )

/*++

Routine Description:

    This routine checks whether the given Scb is NULL, and if not,
    calls NtOfsCloseIndex to close the index.

Arguments:

    Scb - Supplies the Scb of the index to close safely.

Return Value:

    None.

--*/

{
    if (*Scb != NULL) {

        //
        //  Notice that we don't release the Scbs, since
        //  NtOfsCloseIndex might tear the Scbs down and make
        //  trying to release them unsafe.  When this request is
        //  completed, the Scbs will be released anyway.
        //

        NtfsAcquireExclusiveScb( IrpContext, *Scb );
        NtOfsCloseIndex( IrpContext, *Scb );
        *Scb = NULL;
    }
}


VOID
NtOfsCloseAttributeSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine checks whether the given Scb is NULL, and if not,
    calls NtOfsCloseAttribute to close the attribute.

Arguments:

    Scb - Supplies the Scb of the attribute to close safely.

Return Value:

    None.

--*/

{
    if (Scb != NULL) {

        NtOfsCloseAttribute( IrpContext, Scb );
    }
}


VOID
NtfsPerformDismountOnVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DoCompleteDismount,
    OUT PVPB *NewVpbReturn OPTIONAL
    )

/*++

Routine Description:

    This routine is called to start the dismount process on a vcb.
    It marks the Vcb as not mounted and dereferences all opened stream
    file objects, and gets the Vcb out of the Vpb's mounted volume
    structures.

Arguments:

    Vcb - Supplies the Vcb being dismounted

    DoCompleteDismount - Indicates if we are to actually mark the volume
        as dismounted or if we are simply to stop the logfile and close
        the internal attribute streams.

    NewVpbReturn - If supplied, provides a way to return to the caller
                   the new Vpb created in here.  If we do not need to
                   create a new Vpb in this function, we store NULL in
                   NewVpbReturn.

Return Value:

    None.

--*/

{
    PFCB Fcb;
    PFCB NextFcb = NULL;
    PSCB Scb;
    PVOID RestartKey;
    PLIST_ENTRY Links;
    PIRP UsnNotifyIrp;

    BOOLEAN CheckSystemScb;

    PVPB NewVpb;

    DebugTrace( +1, Dbg, ("NtfsPerformDismountOnVcb, Vcb = %08lx\n", Vcb) );

#ifdef DISMOUNT_DBG
    NtfsData.DismountCount += 1;
#endif

    //
    //  We should always be syncrhonized with checkpoints when dismounting initially
    //

    ASSERT( !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) ||
            (Vcb->CheckpointOwnerThread == PsGetCurrentThread()) ||
            ((IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
             (IrpContext->TopLevelIrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME)) );

    //
    //  Blow away our delayed close file object.
    //

    if (!IsListEmpty( &NtfsData.AsyncCloseList ) ||
        !IsListEmpty( &NtfsData.DelayedCloseList )) {

        NtfsFspClose( Vcb );
    }

    //
    //  Commit any current transaction before we start tearing down the volume.
    //

    NtfsCommitCurrentTransaction( IrpContext );

    //
    //  Add one more checkpoint at the front of the logfile if we haven't hit any errors yet
    //

    if ((IrpContext->ExceptionStatus == STATUS_SUCCESS) &&
        FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE ) &&
        FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_COMPLETED )) {

        try {
            NtfsCheckpointVolume( IrpContext, Vcb, TRUE, TRUE, FALSE, LFS_WRITE_FLAG_WRITE_AT_FRONT, Li0 );
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  Swallow any errors while checkpointing
            //

#ifdef BENL_DBG
            KdPrint(( "NTFS: exception in dismount checkpoint 0x%x\n", GetExceptionCode() ));
#endif

            NtfsMinimumExceptionProcessing( IrpContext );
            IrpContext->ExceptionStatus = STATUS_SUCCESS;
        }
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Get rid of all the Ofs indices for Security, Quota, and Object Ids, etc.
        //

        NtOfsCloseIndexSafe( IrpContext, &Vcb->QuotaTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->ReparsePointTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->OwnerIdTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->ObjectIdTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->SecurityIdIndex );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->SecurityDescriptorHashIndex );
        NtOfsCloseAttributeSafe( IrpContext, Vcb->SecurityDescriptorStream );

        //
        //  Walk through and complete any Irps in the ReadUsn queue.
        //

        if (Vcb->UsnJournal != NULL) {

            PWAIT_FOR_NEW_LENGTH Waiter, NextWaiter;
            PSCB UsnJournal = Vcb->UsnJournal;

            NtfsAcquireExclusiveScb( IrpContext, UsnJournal );

            NtfsAcquireFsrtlHeader( UsnJournal );

            Waiter = (PWAIT_FOR_NEW_LENGTH) UsnJournal->ScbType.Data.WaitForNewLength.Flink;

            while (Waiter != (PWAIT_FOR_NEW_LENGTH) &UsnJournal->ScbType.Data.WaitForNewLength) {

                NextWaiter = (PWAIT_FOR_NEW_LENGTH) Waiter->WaitList.Flink;

                //
                //  Make sure we own the Irp and there is not an active cancel
                //  on this Irp.
                //

                if (NtfsClearCancelRoutine( Waiter->Irp )) {

                    //
                    //  If this is an async request then simply complete the request.
                    //

                    if (FlagOn( Waiter->Flags, NTFS_WAIT_FLAG_ASYNC )) {

                        //
                        //  Make sure we decrement the reference count in the Scb.
                        //  Then remove the waiter from the queue and complete the Irp.
                        //

                        InterlockedDecrement( &UsnJournal->CloseCount );
                        RemoveEntryList( &Waiter->WaitList );

                        NtfsCompleteRequest( NULL, Waiter->Irp, STATUS_VOLUME_DISMOUNTED );
                        NtfsFreePool( Waiter );

                    //
                    //  This is a synch Irp.  All we can do is set the event and note the status
                    //  code.
                    //

                    } else {

                        Waiter->Status = STATUS_VOLUME_DISMOUNTED;
                        KeSetEvent( &Waiter->Event, 0, FALSE );
                    }
                }

                //
                //  Move to the next waiter.
                //

                Waiter = NextWaiter;
            }

            NtfsReleaseFsrtlHeader( UsnJournal );
        }

        //
        //  Walk through and remove all of the entries on the UsnDeleteNotify queue.
        //

        NtfsAcquireUsnNotify( Vcb );

        Links = Vcb->NotifyUsnDeleteIrps.Flink;

        while (Links != &Vcb->NotifyUsnDeleteIrps) {

            UsnNotifyIrp = CONTAINING_RECORD( Links,
                                              IRP,
                                              Tail.Overlay.ListEntry );

            //
            //  Remember to move forward in any case.
            //

            Links = Links->Flink;

            //
            //  Clear the notify routine and detect if cancel has
            //  already been called.
            //

            if (NtfsClearCancelRoutine( UsnNotifyIrp )) {

                RemoveEntryList( &UsnNotifyIrp->Tail.Overlay.ListEntry );
                NtfsCompleteRequest( NULL, UsnNotifyIrp, STATUS_VOLUME_DISMOUNTED );
            }
        }

        ClearFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE );
        NtfsReleaseUsnNotify( Vcb );

        NtOfsCloseAttributeSafe( IrpContext, Vcb->UsnJournal );

#ifdef SYSCACHE_DEBUG
        if (Vcb->SyscacheScb) {
            CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
            NTSTATUS WaitStatus;

            NtfsAcquireExclusiveScb( IrpContext, Vcb->SyscacheScb );

            KeInitializeEvent( &UninitializeCompleteEvent.Event,
                               SynchronizationEvent,
                               FALSE);

            CcUninitializeCacheMap( Vcb->SyscacheScb->FileObject,
                                    &Li0,
                                    &UninitializeCompleteEvent );

            //
            //  Now wait for the cache manager to finish purging the file.
            //  This will guarantee that Mm gets the purge before we
            //  delete the Vcb.
            //

            WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

            ASSERT( NT_SUCCESS( WaitStatus ) );

            ObDereferenceObject( Vcb->SyscacheScb->FileObject );
            Vcb->SyscacheScb->FileObject = NULL;

            NtfsDecrementCleanupCounts( Vcb->SyscacheScb, NULL, FALSE );
            NtOfsCloseAttributeSafe( IrpContext, Vcb->SyscacheScb );
            NtfsReleaseScb( IrpContext, Vcb->SyscacheScb );
            Vcb->SyscacheScb = NULL;
        }
#endif

        //
        //  Free the quota control template if necessary.
        //

        if (Vcb->QuotaControlTemplate != NULL) {

            NtfsFreePool( Vcb->QuotaControlTemplate );
            Vcb->QuotaControlTemplate = NULL;
        }

        //
        //  Stop the log file.
        //

        NtfsStopLogFile( Vcb );

        //
        //  Mark the volume as not mounted.
        //

        ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

        //
        //  Now for every file Scb with an opened stream file we will delete
        //  the internal attribute stream.  Before the days of forced dismount
        //  we were basically looking at system files.  Restarting the enumeration
        //  when we found an internal stream wasn't very expensive.  Now that there
        //  may be hundreds or even thousands of Fcbs we really don't want to resume
        //  from the beginning.  Instead we will reference the following entry
        //  while removing the fileobject from the current Fcb.  Then we know
        //  the next entry will remain.
        //

        RestartKey = NULL;
        do {

            Fcb = NextFcb;
            NtfsAcquireFcbTable( IrpContext, Vcb );
            NextFcb = NtfsGetNextFcbTableEntry( Vcb, &RestartKey );

            //
            //  We always want to reference the next entry if present to keep our order correct in the
            //  list.
            //

            if (NextFcb != NULL) {

                //
                //  We'll use this Fcb next time through the loop.
                //

                NextFcb->ReferenceCount += 1;
            }

            //
            //  If our starting Fcb is NULL then we are at the first entry in the list or
            //  we have exhausted the list.  In either case our exist test in the loop
            //  will handle it.
            //

            if (Fcb == NULL) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
                continue;
            }

            //
            //  Remove the extra reference on this Fcb.
            //

            ASSERT_FCB( Fcb );

            Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            Scb = NULL;
            while ((Fcb != NULL) && ((Scb = NtfsGetNextChildScb( Fcb, Scb )) != NULL)) {

                FCB_CONTEXT FcbContext;

                ASSERT_SCB( Scb );

                if (Scb->FileObject != NULL) {

                    //
                    //  Assume we want to see if we should check whether to clear a system Scb field.
                    //

                    CheckSystemScb = TRUE;

                    //
                    //  For the VolumeDasdScb and bad cluster file, we simply decrement
                    //  the counts that we incremented.
                    //

                    if ((Scb == Vcb->VolumeDasdScb) ||
                        (Scb == Vcb->BadClusterFileScb)) {

                        Scb->FileObject = NULL;

                        //
                        //  We need to know if the Fcb gets deleted.
                        //

                        Fcb->FcbContext = &FcbContext;
                        FcbContext.FcbDeleted = FALSE;

                        NtfsDecrementCloseCounts( IrpContext,
                                                  Scb,
                                                  NULL,
                                                  TRUE,
                                                  FALSE,
                                                  FALSE );

                        if (FcbContext.FcbDeleted) {
                            Fcb = NULL;
                        } else {
                            Fcb->FcbContext = NULL;
                        }

                    //
                    //  Dereference the file object in the Scb unless it is the one in
                    //  the Vcb for the Log File.  This routine may not be able to
                    //  dereference file object because of synchronization problems (there
                    //  can be a lazy writer callback in process which owns the paging
                    //  io resource).  In that case we don't want to go back to the beginning
                    //  of Fcb table or we will loop indefinitely.
                    //

                    } else if (Scb->FileObject != Vcb->LogFileObject) {

                        //
                        //  If this is the Usn journal then make sure to empty
                        //  the queue of modified Fcb's.
                        //

                        if (Scb == Vcb->UsnJournal) {

                            PLIST_ENTRY Links;

                            //
                            //  Before we remove the journal we want to remove all
                            //  of the entries in the modified list.
                            //

                            NtfsLockFcb( IrpContext, Scb->Fcb );

                            Links = Vcb->ModifiedOpenFiles.Flink;

                            while (Vcb->ModifiedOpenFiles.Flink != &Vcb->ModifiedOpenFiles) {

                                RemoveEntryList( Links );
                                Links->Flink = NULL;

                                //
                                //  Look to see if we need to remove the TimeOut link as well.
                                //

                                Links = &(CONTAINING_RECORD( Links, FCB_USN_RECORD, ModifiedOpenFilesLinks ))->TimeOutLinks;

                                if (Links->Flink != NULL) {

                                    RemoveEntryList( Links );
                                }
                                Links = Vcb->ModifiedOpenFiles.Flink;
                            }
                            NtfsUnlockFcb( IrpContext, Scb->Fcb );
                        }

                        //
                        //  Acquire the fcb rather than the scb since the scb may go away
                        //

                        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, ACQUIRE_NO_DELETE_CHECK );

                        //
                        //  We need to know if the Fcb gets deleted.
                        //

                        Fcb->FcbContext = &FcbContext;
                        FcbContext.FcbDeleted = FALSE;

                        try {
                            CheckSystemScb = NtfsDeleteInternalAttributeStream( Scb, TRUE, FALSE );
                        } finally {

                            if (FcbContext.FcbDeleted) {
                                Fcb = NULL;
                            } else {

                                NtfsReleaseFcb( IrpContext, Fcb );
                                Fcb->FcbContext = NULL;
                            }
                        }

                    //
                    //  This is the file object for the Log file.  Remove our
                    //  extra reference on the logfile Scb.
                    //

                    } else if (Scb->FileObject != NULL) {

                        //
                        //  Remember the log file object so we can defer the dereference.
                        //

                        NtfsDecrementCloseCounts( IrpContext,
                                                  Vcb->LogFileScb,
                                                  NULL,
                                                  TRUE,
                                                  FALSE,
                                                  TRUE );

                        Scb->FileObject = NULL;
                    }

                    if (CheckSystemScb) {

                        if (Scb == Vcb->MftScb)                     { Vcb->MftScb = NULL; }
                        else if (Scb == Vcb->Mft2Scb)               { Vcb->Mft2Scb = NULL; }
                        else if (Scb == Vcb->LogFileScb)            { Vcb->LogFileScb = NULL; }
                        else if (Scb == Vcb->VolumeDasdScb)         { Vcb->VolumeDasdScb = NULL; }
                        else if (Scb == Vcb->AttributeDefTableScb)  { Vcb->AttributeDefTableScb = NULL; }
                        else if (Scb == Vcb->UpcaseTableScb)        { Vcb->UpcaseTableScb = NULL; }
                        else if (Scb == Vcb->RootIndexScb)          { Vcb->RootIndexScb = NULL; }
                        else if (Scb == Vcb->BitmapScb)             { Vcb->BitmapScb = NULL; }
                        else if (Scb == Vcb->BadClusterFileScb)     { Vcb->BadClusterFileScb = NULL; }
                        else if (Scb == Vcb->QuotaTableScb)         { Vcb->QuotaTableScb = NULL; }
                        else if (Scb == Vcb->MftBitmapScb)          { Vcb->MftBitmapScb = NULL; }
                        else if (Scb == Vcb->SecurityIdIndex)       { Vcb->SecurityIdIndex = NULL; }
                        else if (Scb == Vcb->SecurityDescriptorHashIndex)
                                                                    { Vcb->SecurityDescriptorHashIndex = NULL; }
                        else if (Scb == Vcb->SecurityDescriptorStream)
                                                                    { Vcb->SecurityDescriptorStream = NULL; }
                        else if (Scb == Vcb->ExtendDirectory)       { Vcb->ExtendDirectory = NULL; }
                        else if (Scb == Vcb->UsnJournal)            { Vcb->UsnJournal = NULL; }

                        //
                        //  Restart the Scb scan for this Fcb.
                        //  our call to Delete Internal Attribute Stream just messed up our
                        //  enumeration.
                        //

                        Scb = NULL;
                    }
                }
            }
        } while (NextFcb != NULL);

        DebugTrace( 0, Dbg, ("Vcb->CloseCount = %08lx\n", Vcb->CloseCount) );

        //
        //  Do any deleayed closes now so we can get the Vcb->CloseCount as
        //  low as we possibly can so we have a good chance of being able to
        //  close the logfile now.
        //

        if (!IsListEmpty( &NtfsData.AsyncCloseList ) ||
            !IsListEmpty( &NtfsData.DelayedCloseList )) {

            NtfsFspClose( Vcb );
        }

        //
        //  The code above may have dropped the CloseCount to 0 even though
        //  there's still a file object for the log file.  If the count
        //  isn't 0 yet, there's a chance that a lazy write could still
        //  happen, in which case we need to keep the logfile around.
        //  Often we can close the logfile now, so the Vpb refcount can go
        //  to zero and show the PnP code that we're ready to be removed.
        //  Any queued closes (async or delayed) don't matter either, since
        //  we know no more writes will be coming in for those file objects.
        //  The FspClose call above may not have caught all the outstanding
        //  closes, since another thread may have just pulled a file from
        //  one of the queues, but not yet processed the actual close.
        //

        if (((Vcb->CloseCount - Vcb->QueuedCloseCount) == 0) &&
            (Vcb->LogFileObject != NULL) &&
            !FlagOn( Vcb->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE )) {

            CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
            NTSTATUS WaitStatus;

            KeInitializeEvent( &UninitializeCompleteEvent.Event,
                               SynchronizationEvent,
                               FALSE);

            CcUninitializeCacheMap( Vcb->LogFileObject,
                                    &Li0,
                                    &UninitializeCompleteEvent );

            //
            //  Now wait for the cache manager to finish purging the file.
            //  This will guarantee that Mm gets the purge before we
            //  delete the Vcb.
            //

            WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

            ASSERT( NT_SUCCESS( WaitStatus ) );

            //
            //  Set a flag indicating that we are dereferencing the LogFileObject.
            //

            SetFlag( Vcb->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE );
            ObDereferenceObject( Vcb->LogFileObject );
        }

        //
        //  Now only really dismount the volume if that's what our caller wants.
        //

        if (DoCompleteDismount && !FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

            PREVENT_MEDIA_REMOVAL Prevent;
            KIRQL SavedIrql;

            //
            //  Attempt to unlock any removable media, ignoring status.  We can't
            //  do this if some previous PnP operation has stopped the device below
            //  us.  Remember that we may be dismounting now after the last async
            //  close has been processed, so we can't just test whether the current
            //  operation is a PnP remove.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED )) {

                Prevent.PreventMediaRemoval = FALSE;
                (VOID)NtfsDeviceIoControl( IrpContext,
                                           Vcb->TargetDeviceObject,
                                           IOCTL_DISK_MEDIA_REMOVAL,
                                           &Prevent,
                                           sizeof(PREVENT_MEDIA_REMOVAL),
                                           NULL,
                                           0,
                                           NULL );
            }

            //
            //  Remove this voldo from the mounted disk structures
            //
            IoAcquireVpbSpinLock( &SavedIrql );

            //
            //  If there are no file objects and no reference counts in the
            //  Vpb then we can use the existing Vpb. Or if we're cleaning
            //  up a vcb where allocation for the spare vpb failed also use it.
            //

            if (((Vcb->CloseCount == 0) &&
                 (Vcb->Vpb->ReferenceCount == 0)) ||

                (Vcb->SpareVpb == NULL)) {

                //
                //  Make a new vpb the io subsys can delete
                //

                Vcb->Vpb->DeviceObject = NULL;
                ClearFlag( Vcb->Vpb->Flags, VPB_MOUNTED );

                if (ARGUMENT_PRESENT( NewVpbReturn )) {

                    //
                    //  Let our caller know we did not end up needing the new vpb.
                    //

                    *NewVpbReturn = NULL;
                }

            //
            //  Otherwise we will swap out the Vpb.
            //

            } else {

                //
                //  Use the spare Vpb in the Vcb.
                //

                NewVpb = Vcb->SpareVpb;
                Vcb->SpareVpb = NULL;

                //
                //  It better be there.
                //

                ASSERT( NewVpb != NULL );

                RtlZeroMemory( NewVpb, sizeof( VPB ) );

                //
                //  Set a few important fields in the Vpb.
                //

                NewVpb->Type = IO_TYPE_VPB;
                NewVpb->Size = sizeof( VPB );
                NewVpb->RealDevice = Vcb->Vpb->RealDevice;
                NewVpb->DeviceObject = NULL;
                NewVpb->Flags = FlagOn( Vcb->Vpb->Flags, VPB_REMOVE_PENDING );

                if (ARGUMENT_PRESENT( NewVpbReturn )) {

                    //
                    //  Let our caller know we will indeed need the new vpb.
                    //

                    *NewVpbReturn = NewVpb;
                }

                Vcb->Vpb->RealDevice->Vpb = NewVpb;

                SetFlag( Vcb->VcbState, VCB_STATE_TEMP_VPB );
                SetFlag( Vcb->Vpb->Flags, VPB_PERSISTENT );
            }

            IoReleaseVpbSpinLock( SavedIrql );

            SetFlag( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT );
        }

    } finally {

        //
        //  We should never be leaking a reference count on an Fcb.
        //

        ASSERT( NextFcb == NULL );

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsPerformDismountOnVcb -> VOID\n") );
    }

    return;
}


BOOLEAN
NtfsPingVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PBOOLEAN OwnsVcb OPTIONAL
    )

/*++

Routine Description:

    This routine will ping the volume to see if the device needs to
    be verified.  It is used for create operations to see if the
    create should proceed or if we should complete the create Irp
    with a remount status.

Arguments:

    Vcb - Supplies the Vcb being pinged

    OwnsVcb - Indicates if this thread already owns the Vcb.  Updated here if we
        need serialization on the Vcb and it isn't already acquired.  If not
        specified then we assume the Vcb is held.

Return Value:

    BOOLEAN - TRUE if the volume is fine and the operation should
        proceed and FALSE if the volume needs to be verified

--*/

{
    BOOLEAN Results;
    ULONG ChangeCount = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPingVolume, Vcb = %08lx\n", Vcb) );

    //
    //  If the media is removable and the verify volume flag in the
    //  device object is not set then we want to ping the device
    //  to see if it needs to be verified.
    //
    //  Note that we only force this ping for create operations.
    //  For others we take a sporting chance.  If in the end we
    //  have to physically access the disk, the right thing will happen.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA ) &&
        !FlagOn( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME )) {

        PDEVICE_OBJECT TargetDevice;
        NTSTATUS Status;

        if (ARGUMENT_PRESENT( OwnsVcb ) && !(*OwnsVcb)) {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            *OwnsVcb = TRUE;
        }

        TargetDevice = Vcb->TargetDeviceObject;

        Status = NtfsDeviceIoControlAsync( IrpContext,
                                           TargetDevice,
                                           IOCTL_DISK_CHECK_VERIFY,
                                           (PVOID)&ChangeCount,
                                           sizeof(ChangeCount) );

        if (!NT_SUCCESS( Status )) {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        if (ChangeCount != Vcb->DeviceChangeCount) {

            //
            //  The disk driver lost a media change event, possibly
            //  because it was eaten by a user request before the
            //  volume was mounted.  We set things up as they would
            //  be if the driver had returned VERIFY_REQUIRED.
            //

            Vcb->DeviceChangeCount = ChangeCount;
            IoSetDeviceToVerify( PsGetCurrentThread(), TargetDevice );
            SetFlag( TargetDevice->Flags, DO_VERIFY_VOLUME );

            NtfsRaiseStatus( IrpContext, STATUS_VERIFY_REQUIRED, NULL, NULL );
        }
    }

    if (FlagOn( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME )) {

        Results = FALSE;

    } else {

        Results = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsPingVolume -> %08lx\n", Results) );

    return Results;
}


VOID
NtfsVolumeCheckpointDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is dispatched every 5 seconds when disk structure is being
    modified.  It had the ExWorker thread to volume checkpoints.

Arguments:

    DeferredContext - Not Used

Return Value:

    None.

--*/

{
    TIMER_STATUS TimerStatus;
    ULONG VolumeCheckpointStatus;

    //
    //  Atomic reset of status indicating the timer is currently fired.  This
    //  synchronizes with NtfsSetDirtyBcb.  After NtfsSetDirtyBcb dirties
    //  a Bcb, it sees if it should enable this timer routine.
    //
    //  If the status indicates that a timer is active, it does nothing.  In this
    //  case it is guaranteed that when the timer fires, it causes a checkpoint (to
    //  force out the dirty Bcb data).
    //
    //  If there is no timer active, it enables it, thus queueing a checkpoint later.
    //
    //  If the timer routine actually fires between the dirtying of the Bcb and the
    //  testing of the status then a single extra checkpoint is generated.  This
    //  extra checkpoint is not considered harmful.
    //

    //
    //  Atomically reset status and get previous value
    //

    TimerStatus = InterlockedExchange( (PLONG)&NtfsData.TimerStatus, TIMER_NOT_SET );

    //
    //  We have only one instance of the work queue item.  It can only be
    //  queued once.  In a slow system, this checkpoint item may not be processed
    //  by the time this timer routine fires again.
    //

    VolumeCheckpointStatus = InterlockedExchange( &NtfsData.VolumeCheckpointStatus,
                                                  CHECKPOINT_POSTED | CHECKPOINT_PENDING );

    if (!FlagOn( VolumeCheckpointStatus, CHECKPOINT_POSTED )) {

        ASSERT( NtfsData.VolumeCheckpointItem.List.Flink == NULL );
        ExQueueWorkItem( &NtfsData.VolumeCheckpointItem, CriticalWorkQueue );
    }

    return;

    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );
    UNREFERENCED_PARAMETER( DeferredContext );
    UNREFERENCED_PARAMETER( Dpc );
}


VOID
NtfsCheckpointAllVolumes (
    PVOID Parameter
    )

/*++

Routine Description:

    This routine searches all of the vcbs for Ntfs and tries to clean
    them.  If the vcb is good and dirty but not almost clean then
    we set it almost clean.  If the Vcb is good and dirty and almost clean
    then we clean it.

Arguments:

    Parameter - Not Used.

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    PLIST_ENTRY Links;
    PVCB Vcb;

    BOOLEAN AcquiredGlobal = FALSE;
    BOOLEAN StartTimer = FALSE;

    TIMER_STATUS TimerStatus;
    ULONG VolumeCheckpointStatus;

    PAGED_CODE();

    //
    //  Note that an exception like log file terminates the Vcb scan until the next
    //  interval.  It would be possible to restructure this routine to work on the other
    //  volumes first, however for deadlock prevention it is also nice to free up this
    //  thread to handle the checkpoint.
    //

    try {

        //
        //  Clear the flag that indicates someone is waiting for a checkpoint.  That way
        //  we can tell if the checkpoint timer fires while we are checkpointing.
        //

        InterlockedExchange( &NtfsData.VolumeCheckpointStatus, CHECKPOINT_POSTED );

        //
        //  Create an IrpContext and make sure it doesn't go away until we are ready.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        //
        //  Make sure we don't get any pop-ups
        //

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );


        NtfsAcquireSharedGlobal( IrpContext, TRUE );
        AcquiredGlobal = TRUE;

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

            IrpContext->Vcb = Vcb;

             if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
                 (!NtfsIsVolumeReadOnly( Vcb ))) {

                NtfsCheckpointVolume( IrpContext, Vcb, FALSE, FALSE, TRUE, 0, Li0 );

                //
                //  Check to see whether this was not a clean checkpoint.
                //

                if (!FlagOn( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN )) {

                    StartTimer = TRUE;
                }

                NtfsCommitCurrentTransaction( IrpContext );

#if DBG
                if (NtfsCheckQuota && Vcb->QuotaTableScb != NULL) {
                    NtfsPostRepairQuotaIndex( IrpContext, Vcb );
                }
#endif
            }

            //
            //  Clean up this IrpContext.
            //

            NtfsCleanupIrpContext( IrpContext, TRUE );
        }

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Process the exception.  We know the IrpContext won't go away here.
        //

        NtfsProcessException( IrpContext, NULL, GetExceptionCode() );
    }

    if (AcquiredGlobal) {
        NtfsReleaseGlobal( IrpContext );
    }

    VolumeCheckpointStatus = InterlockedExchange( &NtfsData.VolumeCheckpointStatus, 0 );

    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
    NtfsCleanupIrpContext( IrpContext, TRUE );
    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  Synchronize with the checkpoint timer and other instances of this routine.
    //
    //  Perform an interlocked exchange to indicate that a timer is being set.
    //
    //  If the previous value indicates that no timer was set, then we
    //  enable the volume checkpoint timer.  This will guarantee that a checkpoint
    //  will occur to flush out the dirty Bcb data.
    //
    //  If the timer was set previously, then it is guaranteed that a checkpoint
    //  will occur without this routine having to reenable the timer.
    //
    //  If the timer and checkpoint occurred between the dirtying of the Bcb and
    //  the setting of the timer status, then we will be queueing a single extra
    //  checkpoint on a clean volume.  This is not considered harmful.
    //

    //
    //  Atomically set the timer status to indicate a timer is being set and
    //  retrieve the previous value.
    //

    if (StartTimer || FlagOn( VolumeCheckpointStatus, CHECKPOINT_PENDING )) {

        TimerStatus = InterlockedExchange( (PLONG)&NtfsData.TimerStatus, TIMER_SET );

        //
        //  If the timer is not currently set then we must start the checkpoint timer
        //  to make sure the above dirtying is flushed out.
        //

        if (TimerStatus == TIMER_NOT_SET) {

            LONGLONG NewTimerValue;

            //
            //  If the timer timed out because the checkpoint took so long then
            //  only wait two seconds.  Otherwise use our normal time of five seconds.
            //

            if (FlagOn( VolumeCheckpointStatus, CHECKPOINT_PENDING )) {

                NewTimerValue = -2*1000*1000*10;

            } else {

                NewTimerValue = -5*1000*1000*10;
            }

            KeSetTimer( &NtfsData.VolumeCheckpointTimer,
                        *(PLARGE_INTEGER) &NewTimerValue,
                        &NtfsData.VolumeCheckpointDpc );
        }
    }

    //
    //  Pulse the NtfsEncryptionPendingEvent so there's no chance of a waiter waiting forever.
    //

    KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );

    //
    //  And return to our caller
    //

    return;

    UNREFERENCED_PARAMETER( Parameter );
}


VOID
NtfsUsnTimeOutDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is dispatched every 5 minutes to look for Usn records waiting
    for a close to be issued.  It posts a work item to the ExWorker thread.

Arguments:

    DeferredContext - Not Used

Return Value:

    None.

--*/

{
    ASSERT( NtfsData.UsnTimeOutItem.List.Flink == NULL );
    ExQueueWorkItem( &NtfsData.UsnTimeOutItem, CriticalWorkQueue );

    return;

    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );
    UNREFERENCED_PARAMETER( DeferredContext );
    UNREFERENCED_PARAMETER( Dpc );
}


VOID
NtfsCheckUsnTimeOut (
    PVOID Parameter
    )

/*++

Routine Description:

    This is the worker routine which walks the queue of UsnRecords waiting for close records.  It either
    issues the close record and/or removes it from the queue of TimeOut records.  It also toggles the
    two TimeOut queues and restarts the timer for the next break.

Arguments:

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    PFCB_USN_RECORD FcbUsnRecord;
    PLIST_ENTRY Links;
    PVCB Vcb;
    PFCB Fcb;

    BOOLEAN AcquiredGlobal = FALSE;
    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;

    PLIST_ENTRY Temp;

    PAGED_CODE();
    FsRtlEnterFileSystem();

    //
    //  Note that an exception like log file terminates the Vcb scan until the next
    //  interval.  It would be possible to restructure this routine to work on the other
    //  volumes first, however for deadlock prevention it is also nice to free up this
    //  thread to handle the checkpoint.
    //

    try {

        //
        //  Create an IrpContext and make sure it doesn't go away until we are ready.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        //
        //  Make sure we don't get any pop-ups
        //

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );


        NtfsAcquireSharedGlobal( IrpContext, TRUE );
        AcquiredGlobal = TRUE;

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

            IrpContext->Vcb = Vcb;

            if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                AcquiredVcb = TRUE;

                if (Vcb->UsnJournal != NULL) {

                    do {

                        Fcb = NULL;

                        //
                        //  Synchronize with the Fcb table and Usn Journal so that we can
                        //  see if the next Fcb has to have a close record generated.
                        //

                        NtfsAcquireFcbTable( IrpContext, Vcb );
                        NtfsAcquireFsrtlHeader( Vcb->UsnJournal );

                        if (!IsListEmpty( Vcb->AgedTimeOutFiles )) {

                            FcbUsnRecord = (PFCB_USN_RECORD)CONTAINING_RECORD( Vcb->AgedTimeOutFiles->Flink,
                                                                               FCB_USN_RECORD,
                                                                               TimeOutLinks );

                            //
                            //  Since we have a UsnRecord and Fcb we want to reference the Fcb so
                            //  it won't go away.
                            //

                            Fcb = FcbUsnRecord->Fcb;
                            Fcb->ReferenceCount += 1;
                        }

                        NtfsReleaseFsrtlHeader( Vcb->UsnJournal );
                        NtfsReleaseFcbTable( IrpContext, Vcb );

                        //
                        //  Do we have to generate another close record?
                        //

                        if (Fcb != NULL) {

                            //
                            //  We must lock out other activity on this file since we are about
                            //  to reset the Usn reasons.
                            //

                            if (Fcb->PagingIoResource != NULL) {

                                ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
                            }

                            NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                            AcquiredFcb = TRUE;

                            //
                            //  Skip over system files, files which now have a handle count, deleted
                            //  files or files which are no longer on the aged list.
                            //

                            if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE | FCB_STATE_FILE_DELETED ) &&
                                (Fcb->CleanupCount == 0) &&
                                (Fcb->FcbUsnRecord != NULL) &&
                                (Fcb->FcbUsnRecord->TimeOutLinks.Flink != NULL)) {

                                //
                                //  Post the close to our IrpContext.
                                //

                                NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                                //
                                //  If we did not actually post a change, something is wrong,
                                //  because when a close change is written, the Fcb is removed from
                                //  the list.
                                //

                                ASSERT( IrpContext->Usn.CurrentUsnFcb != NULL );

                                //
                                //  Now generate the close record and checkpoint the transaction.
                                //

                                NtfsWriteUsnJournalChanges( IrpContext );
                                NtfsCheckpointCurrentTransaction( IrpContext );

                            //
                            //  Remove this entry from the time out list if still present.
                            //

                            } else if ((Fcb->FcbUsnRecord != NULL) &&
                                       (Fcb->FcbUsnRecord->TimeOutLinks.Flink != NULL)) {

                                NtfsAcquireFsrtlHeader( Vcb->UsnJournal );
                                RemoveEntryList( &Fcb->FcbUsnRecord->TimeOutLinks );
                                Fcb->FcbUsnRecord->TimeOutLinks.Flink = NULL;
                                NtfsReleaseFsrtlHeader( Vcb->UsnJournal );
                            }

                            //
                            //  Now we will dereference the Fcb.
                            //

                            NtfsAcquireFcbTable( IrpContext, Vcb );
                            Fcb->ReferenceCount -= 1;

                            //
                            //  We may be required to delete this guy.  This frees the Fcb Table.
                            //

                            if (IsListEmpty( &Fcb->ScbQueue ) && (Fcb->ReferenceCount == 0) && (Fcb->CloseCount == 0)) {


                                BOOLEAN AcquiredFcbTable = TRUE;

                                NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                                ASSERT( !AcquiredFcbTable );

                            //
                            //  Otherwise free the table and Fcb resources.
                            //

                            } else {

                                NtfsReleaseFcbTable( IrpContext, Vcb );

                                //
                                //  Release in inverse order because only main holds down
                                //  the fcb
                                //

                                if (Fcb->PagingIoResource != NULL) {

                                    ExReleaseResourceLite( Fcb->PagingIoResource );
                                }
                                NtfsReleaseFcb( IrpContext, Fcb );
                            }

                            AcquiredFcb = FALSE;
                        }

                    } while (Fcb != NULL);

                    //
                    //  Now swap the aged lists.
                    //

                    ASSERT( IsListEmpty( Vcb->AgedTimeOutFiles ));

                    NtfsLockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                    Temp = Vcb->AgedTimeOutFiles;
                    Vcb->AgedTimeOutFiles = Vcb->CurrentTimeOutFiles;
                    Vcb->CurrentTimeOutFiles = Temp;
                    NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                }

                //
                //  Now we can drop the Vcb before looping back.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                AcquiredVcb = FALSE;

                //
                //  Clean up this IrpContext.
                //

                NtfsCleanupIrpContext( IrpContext, TRUE );
            }
        }

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        if (AcquiredFcb) {

            NtfsAcquireFcbTable( IrpContext, Vcb );
            Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            //
            //  Only main protects the fcb from being deleted so release in inverse order
            //

            if (Fcb->PagingIoResource != NULL) {

                ExReleaseResourceLite( Fcb->PagingIoResource );
            }

            NtfsReleaseFcb( IrpContext, Fcb );
        }

        AcquiredFcb = FALSE;

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;
        }

        //
        //  Process the exception.  We know the IrpContext won't go away here.
        //

        NtfsProcessException( IrpContext, NULL, GetExceptionCode() );
    }

    if (AcquiredFcb) {

        NtfsReleaseFcb( IrpContext, Fcb );
        if (Fcb->PagingIoResource != NULL) {

            ExReleaseResourceLite( Fcb->PagingIoResource );
        }
    }

    if (AcquiredVcb) {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    if (AcquiredGlobal) {

        NtfsReleaseGlobal( IrpContext );
    }

    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
    NtfsCleanupIrpContext( IrpContext, TRUE );
    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  Now start the timer again.
    //

    {
        LONGLONG FiveMinutesFromNow = -5*1000*1000*10;

        FiveMinutesFromNow *= 60;

        KeSetTimer( &NtfsData.UsnTimeOutTimer,
                    *(PLARGE_INTEGER)&FiveMinutesFromNow,
                    &NtfsData.UsnTimeOutDpc );
    }

    FsRtlExitFileSystem();
    return;

    UNREFERENCED_PARAMETER( Parameter );
}


NTSTATUS
NtfsDeviceIoControlAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine is used to perform an IoCtl when we may be at the APC level
    and calling NtfsDeviceIoControl could be unsafe.

Arguments:

    DeviceObject - Supplies the device object to which to send the ioctl.

    IoCtl - Supplies the I/O control code.

    Buffer - Points to a buffer for any extra input/output for the given ioctl.

    BufferLength - The size, in bytes, of the above buffer.

Return Value:

    Status.

--*/

{
    KEVENT Event;
    PIRP Irp;
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Initialize the event we're going to use
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Build the irp for the operation and also set the overrride flag
    //
    //  Note that we may be at APC level, so do this asyncrhonously and
    //  use an event for synchronization normal request completion
    //  cannot occur at APC level.
    //
    //  We use IRP_MJ_FLUSH_BUFFERS since it (ironically) doesn't require
    //  a buffer.
    //

    Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_FLUSH_BUFFERS,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL );

    if ( Irp == NULL ) {

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    IrpSp = IoGetNextIrpStackLocation( Irp );
    SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    IrpSp->Parameters.DeviceIoControl.IoControlCode = IoCtl;
    Irp->AssociatedIrp.SystemBuffer = Buffer;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = BufferLength;

    //
    //  Reset the major code to the correct value.
    //

    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    //
    //  Set up the completion routine.
    //

    IoSetCompletionRoutine( Irp,
                            NtfsVerifyReadCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Call the device to do the io and wait for it to finish.
    //

    (VOID)IoCallDriver( DeviceObject, Irp );
    (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

    //
    //  Grab the Status.
    //

    Status = Irp->IoStatus.Status;

    IoFreeIrp( Irp );

    //
    //  And return to our caller.
    //

    return Status;
}


//
//  Local Support routine
//

VOID
NtfsPerformVerifyDiskRead (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID Buffer,
    IN LONGLONG Offset,
    IN ULONG NumberOfBytesToRead
    )

/*++

Routine Description:

    This routine is used to read in a range of bytes from the disk.  It
    bypasses all of the caching and regular I/O logic, and builds and issues
    the requests itself.  It does this operation overriding the verify
    volume flag in the device object.

Arguments:

    Vcb - Supplies the Vcb denoting the device for this operation

    Buffer - Supplies the buffer that will recieve the results of this operation

    Offset - Supplies the offset of where to start reading

    NumberOfBytesToRead - Supplies the number of bytes to read, this must
        be in multiple of bytes units acceptable to the disk driver.

Return Value:

    None.

--*/

{
    KEVENT Event;
    PIRP Irp;
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    //
    //  Initialize the event we're going to use
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Build the irp for the operation and also set the overrride flag
    //
    //  Note that we may be at APC level, so do this asyncrhonously and
    //  use an event for synchronization normal request completion
    //  cannot occur at APC level.
    //

    Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_READ,
                                         Vcb->TargetDeviceObject,
                                         Buffer,
                                         NumberOfBytesToRead,
                                         (PLARGE_INTEGER)&Offset,
                                         NULL );

    if ( Irp == NULL ) {

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            NtfsVerifyReadCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Call the device to do the write and wait for it to finish.
    //

    try {

        (VOID)IoCallDriver( Vcb->TargetDeviceObject, Irp );
        (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

        //
        //  Grab the Status.
        //

        Status = Irp->IoStatus.Status;

    } finally {

        //
        //  If there is an MDL (or MDLs) associated with this I/O
        //  request, Free it (them) here.  This is accomplished by
        //  walking the MDL list hanging off of the IRP and deallocating
        //  each MDL encountered.
        //

        while (Irp->MdlAddress != NULL) {

            PMDL NextMdl;

            NextMdl = Irp->MdlAddress->Next;

            MmUnlockPages( Irp->MdlAddress );

            IoFreeMdl( Irp->MdlAddress );

            Irp->MdlAddress = NextMdl;
        }

        IoFreeIrp( Irp );
    }

    //
    //  If it doesn't succeed then raise the error
    //

    if (!NT_SUCCESS(Status)) {

        NtfsNormalizeAndRaiseStatus( IrpContext,
                                     Status,
                                     STATUS_UNEXPECTED_IO_ERROR );
    }

    //
    //  And return to our caller
    //

    return;
}


NTSTATUS
NtfsIoCallSelf (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction
    )

/*++

Routine Description:

    This routine is used to call ourselves for a simple function.  Note that
    if more use is found for this routine than the few current uses, its interface
    may be easily expanded.

Arguments:

    FileObject - FileObject for request.

    MajorFunction - function to be performed.

Return Value:

    Status code resulting from the driver call

--*/

{
    KEVENT Event;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  Initialize the event we're going to use
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    //  Build the irp for the operation and also set the overrride flag
    //
    //  Note that we may be at APC level, so do this asyncrhonously and
    //  use an event for synchronization normal request completion
    //  cannot occur at APC level.
    //


    Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL );

    if (Irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Fill in a few remaining items
    //

    Irp->Tail.Overlay.OriginalFileObject = FileObject;

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = MajorFunction;
    IrpSp->FileObject = FileObject;

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            NtfsVerifyReadCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    NtfsPurgeFileRecordCache( IrpContext );
    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

    //
    //  Call the device to do the write and wait for it to finish.
    //

    try {

        (VOID)IoCallDriver( DeviceObject, Irp );
        (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

        //
        //  Grab the Status.
        //

        Status = Irp->IoStatus.Status;

    } finally {

        //
        //  There should never be an MDL here.
        //

        ASSERT(Irp->MdlAddress == NULL);

        IoFreeIrp( Irp );

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );
    }

    //
    //  If it doesn't succeed then raise the error
    //
    //  And return to our caller
    //

    return Status;
}


BOOLEAN
NtfsLogEventInternal (
    IN PVCB Vcb,
    IN UCHAR MajorFunction,
    IN ULONG TransactionId,
    IN PUNICODE_STRING String OPTIONAL,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    )

/*++

Routine Description:

    Create an eventlogentry. This version is given all the strings and user data
    it needs.

Arguments:

    Vcb - the vcb
    MajorFunction - irp majorfunction when log was generated

    TransactionId -  transaction id for transaction if any

    String - Any string needed in the message

    UserData - Any userdata

    LogCode - IO_ type code (NOT an NTSTATUS)  see ntiologc.h

    FinalStatus - NTSTATUS of error


Return Value:

    TRUE if successful

--*/
{
    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    PFILE_QUOTA_INFORMATION FileQuotaInfo;
    ULONG SidLength;
    ULONG DumpDataLength = 0;
    ULONG StringLength = 0;
    ULONG LogSize = sizeof( IO_ERROR_LOG_PACKET );
    PWCHAR RecordString;

    if (Vcb == NULL) {
        return FALSE;
    }

    if (ARGUMENT_PRESENT( String )) {
        StringLength = String->Length + sizeof(WCHAR);
        LogSize += StringLength;
    }

    if (ARGUMENT_PRESENT( UserData )) {

        //
        //  Calculate the required length of the Sid.
        //

        SidLength = RtlLengthSid( &UserData->QuotaSid );
        DumpDataLength = SidLength +
                         FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid );

        //
        //  The error packet already has 1 ulong for dump data in it
        //

        LogSize += DumpDataLength - sizeof( ULONG );

    }

    if (LogSize > ERROR_LOG_MAXIMUM_SIZE) {
        LogSize = ERROR_LOG_MAXIMUM_SIZE;
    }

    //
    //  We don't deal with the user dump data not fitting in the record
    //

    ASSERT( DumpDataLength - sizeof( ULONG ) + sizeof( IO_ERROR_LOG_PACKET ) <= LogSize );

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET)
                    IoAllocateErrorLogEntry( (CONTAINING_RECORD( Vcb, VOLUME_DEVICE_OBJECT, Vcb ))->DeviceObject.DriverObject,
                                             (UCHAR) (LogSize) );

    if (ErrorLogEntry == NULL) {
        return FALSE;
    }

    ErrorLogEntry->EventCategory = ELF_CATEGORY_DISK;
    ErrorLogEntry->ErrorCode = LogCode;
    ErrorLogEntry->FinalStatus = FinalStatus;

    ErrorLogEntry->SequenceNumber = TransactionId;
    ErrorLogEntry->MajorFunctionCode = MajorFunction;
    ErrorLogEntry->RetryCount = 0;
    ErrorLogEntry->DumpDataSize = (USHORT) DumpDataLength;

    //
    //  The label string at the end of the error log entry.
    //

    ErrorLogEntry->NumberOfStrings = 1;
    ErrorLogEntry->StringOffset = (USHORT) (sizeof( IO_ERROR_LOG_PACKET ) + DumpDataLength - sizeof( ULONG ));
    RecordString = (PWCHAR) Add2Ptr( ErrorLogEntry, ErrorLogEntry->StringOffset );

    if (LogSize - ErrorLogEntry->StringOffset < StringLength) {
        RtlCopyMemory( RecordString,
                       String->Buffer,
                       LogSize - ErrorLogEntry->StringOffset - sizeof( WCHAR ) * 4 );
        RecordString += (LogSize - ErrorLogEntry->StringOffset - sizeof( WCHAR ) * 4) / sizeof(WCHAR);
        RtlCopyMemory( RecordString, L"...", sizeof( WCHAR ) * 4 );

    } else {
        RtlCopyMemory( RecordString,
                       String->Buffer,
                       String->Length );
        //
        //  Make sure the string is null terminated.
        //

        RecordString += String->Length / sizeof( WCHAR );
        *RecordString = L'\0';
    }

    if (ARGUMENT_PRESENT( UserData )) {

        FileQuotaInfo = (PFILE_QUOTA_INFORMATION) ErrorLogEntry->DumpData;

        FileQuotaInfo->NextEntryOffset = 0;
        FileQuotaInfo->SidLength = SidLength;
        FileQuotaInfo->ChangeTime.QuadPart = UserData->QuotaChangeTime;
        FileQuotaInfo->QuotaUsed.QuadPart = UserData->QuotaUsed;
        FileQuotaInfo->QuotaThreshold.QuadPart = UserData->QuotaThreshold;
        FileQuotaInfo->QuotaLimit.QuadPart = UserData->QuotaLimit;
        RtlCopyMemory( &FileQuotaInfo->Sid,
                       &UserData->QuotaSid,
                       SidLength );
    }

    IoWriteErrorLogEntry( ErrorLogEntry );
    return TRUE;
}



BOOLEAN
NtfsLogEvent (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    )

/*++

Routine Description:

    This routine logs an io event. If UserData is supplied then the
    data logged is a FILE_QUOTA_INFORMATION structure

Arguments:

    UserData - Supplies the optional quota user data index entry.

    LogCode - Supplies the Io Log code to use for the ErrorCode field.

    FinalStauts - Supplies the final status of the operation.

Return Value:

    True - if the event was successfully logged.

--*/

{
    PEVENTLOG_ERROR_PACKET Packet;
    ULONG OldCount;
    UNICODE_STRING Label;

    if (IrpContext->Vcb == NULL) {
        return FALSE;
    }

    OldCount = InterlockedCompareExchange( &(NtfsData.VolumeNameLookupsInProgress), 1, 0 );
    if (OldCount == 0) {

        Packet = NtfsAllocatePoolWithTagNoRaise( PagedPool, sizeof( EVENTLOG_ERROR_PACKET ), MODULE_POOL_TAG );
        if (Packet) {

            RtlZeroMemory( Packet, sizeof( EVENTLOG_ERROR_PACKET ) );

            //
            //  Copy UserData if necc. since the resolution is asynch
            //

            if (ARGUMENT_PRESENT( UserData )) {

                ULONG SidLength;
                ULONG UserDataLength;

                SidLength = RtlLengthSid( &UserData->QuotaSid );
                UserDataLength = SidLength +
                                SIZEOF_QUOTA_USER_DATA;

                Packet->UserData = NtfsAllocatePoolWithTagNoRaise( PagedPool, UserDataLength, MODULE_POOL_TAG );
                if (!Packet->UserData) {
                    NtfsFreePool( Packet );
                    return NtfsLogEventInternal( IrpContext->Vcb, IrpContext->MajorFunction, IrpContext->TransactionId, NULL, UserData, LogCode, FinalStatus );
                }
                RtlCopyMemory( Packet->UserData, UserData, UserDataLength );
            }

            Packet->FinalStatus = FinalStatus;
            Packet->LogCode = LogCode;
            Packet->MajorFunction = IrpContext->MajorFunction;
            Packet->TransactionId = IrpContext->TransactionId;
            Packet->Vcb = IrpContext->Vcb;

            NtfsPostSpecial( IrpContext, IrpContext->Vcb, NtfsResolveVolumeAndLogEventSpecial, Packet );
            return TRUE;

        } else {

            Label.Length = Label.MaximumLength = IrpContext->Vcb->Vpb->VolumeLabelLength;
            Label.Buffer = &(IrpContext->Vcb->Vpb->VolumeLabel[0]);
            return NtfsLogEventInternal( IrpContext->Vcb, IrpContext->MajorFunction, IrpContext->TransactionId, &Label, NULL, LogCode, FinalStatus );
        }

    } else {

        Label.Length = Label.MaximumLength = IrpContext->Vcb->Vpb->VolumeLabelLength;
        Label.Buffer = &(IrpContext->Vcb->Vpb->VolumeLabel[0]);
        return NtfsLogEventInternal( IrpContext->Vcb, IrpContext->MajorFunction, IrpContext->TransactionId, &Label, NULL, LogCode, FinalStatus );
    }
}



VOID
NtfsResolveVolumeAndLogEventSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    Resolve Vcb's win32 devicename and raise an io hard error. This is done in
    a separate thread in order to have enough stack to re-enter the filesys if necc.
    Also because we may reenter. Starting from here means we own no resources other than
    having inc'ed the close count on the underlying vcb to prevent its going away

Arguments:

    IrpContext -  IrpContext containing vcb we're interested in
    Context    -  String to append to volume win32 name


Return Value:

    none

--*/
{
    PEVENTLOG_ERROR_PACKET EventCtx = 0;
    UNICODE_STRING VolumeName;
    NTSTATUS Status;
    WCHAR *NewBuffer = NULL;
    ULONG DumpDataLength = 0;
    ULONG LabelLength = 0;
    BOOLEAN AllocatedVolName = FALSE;


    UNREFERENCED_PARAMETER( IrpContext );

    ASSERT( Context != NULL );

    EventCtx = (PEVENTLOG_ERROR_PACKET) Context;

    VolumeName.Length = 0;
    VolumeName.Buffer = NULL;

    try {

        Status = IoVolumeDeviceToDosName( EventCtx->Vcb->TargetDeviceObject, &VolumeName );
        ASSERT( (STATUS_SUCCESS == Status) || (VolumeName.Length == 0) );

        //
        //  We're stuck using the label
        //

        if (VolumeName.Length == 0) {
            VolumeName.Length = EventCtx->Vcb->Vpb->VolumeLabelLength;
            VolumeName.Buffer = &(EventCtx->Vcb->Vpb->VolumeLabel[0]);
        } else if (STATUS_SUCCESS == Status) {
            AllocatedVolName = TRUE;
        }

        //
        //  Ignore status from LogEventInternal at this point if we fail
        //

        NtfsLogEventInternal( EventCtx->Vcb, EventCtx->MajorFunction, EventCtx->TransactionId, &VolumeName, EventCtx->UserData, EventCtx->LogCode, EventCtx->FinalStatus );

    } finally {

        //
        //  Indicate we're done and other lookups can occur
        //

        InterlockedDecrement( &(NtfsData.VolumeNameLookupsInProgress) );

        if (EventCtx) {
            if (EventCtx->UserData) {
                NtfsFreePool( EventCtx->UserData );
            }
            NtfsFreePool( EventCtx );
        }

        if (AllocatedVolName) {
            NtfsFreePool( VolumeName.Buffer );
        }
    }
}



VOID
NtfsPostVcbIsCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status OPTIONAL,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to mark the volume dirty and possibly raise a hard error.

Arguments:

    Status - If not zero, then this is the error code for the popup.

    FileReference - If specified, then this is the file reference for the corrupt file.

    Fcb - If specified, then this is the Fcb for the corrupt file.

Return Value:

    None

--*/
{
    PVCB Vcb = IrpContext->Vcb;

    //
    //  Set this flag to keep the volume from ever getting set clean.
    //

    if (Vcb != NULL) {

        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );

        //
        //  This would be the appropriate place to raise a hard error popup,
        //  ala the code in FastFat.  We should do it after marking the volume
        //  dirty so that if anything goes wrong with the popup, the volume is
        //  already marked anyway.
        //

        if ((Status != 0) &&
            !NtfsSuppressPopup &&
            ((IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
             (IrpContext->MinorFunction != IRP_MN_MOUNT_VOLUME))) {

            NtfsRaiseInformationHardError( IrpContext,
                                           Status,
                                           FileReference,
                                           Fcb );
        }
    }
}


VOID
NtfsMarkVolumeDirty (
    IN PIRP_CONTEXT IrpContex