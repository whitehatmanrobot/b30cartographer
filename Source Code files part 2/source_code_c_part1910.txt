
                     dec ecx
                    jnz mc64_14
                }
            }
        }
    }
    else if (g_dwCPUFeatureSet & NV_FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc64_2:      movq mm0,[ebx+ 0]
             movq mm1,[ebx+ 8]
             movq mm2,[ebx+16]
             movq mm3,[ebx+24]
             movq mm4,[ebx+32]
             movq mm5,[ebx+40]
             movq mm6,[ebx+48]
             movq mm7,[ebx+56]
             add ebx,64
             movq [edx+ 0],mm0
             movq [edx+ 8],mm1
             movq [edx+16],mm2
             movq [edx+24],mm3
             movq [edx+32],mm4
             movq [edx+40],mm5
             movq [edx+48],mm6
             movq [edx+56],mm7
             add edx,64
             dec ecx
            jnz mc64_2
            emms
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*16);
    }
}

/*
 * nvMemCopy
 *
 * copy memory as fast as we can
 */
void nvMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount,
    DWORD dwFlags
)
{
    /*
     * small block optimizations
     *  less than 32 bytes gets unaligned dword accesses followed by some bytes (normal memcpy)
     *  less than 128 bytes and caller does not care for alignment
     */
    if ( (dwCount < 32)
     || ((dwCount < 128) && (dwFlags == NV_MEMCOPY_DONTCARE)))
    {
        memcpy ((void*)dwDest,(void*)dwSrc,dwCount);
        return;
    }

    /*
     * align source or dest depending on flags
     */
    {
        DWORD dwNum = (dwFlags & NV_MEMCOPY_WANTSRCALIGNED)
                    ? (dwSrc  & 15)
                    : (dwDest & 15);

        if (dwCount >= 4)
        {
            /*
             * align to 4
             */
            if (dwNum & 3)
            {
                DWORD dwTemp = 4 - (dwNum & 3);
                nvMemCopy1 (dwDest,dwSrc,dwTemp);
                dwSrc   += dwTemp;
                dwDest  += dwTemp;
                dwCount -= dwTemp;
            }

            if (dwCount >= 16)
            {
                /*
                 * align to 16
                 */
                if (dwNum & 12)
                {
                    DWORD dwTemp = 16 - (dwNum & 12);
                    nvMemCopy4 (dwDest,dwSrc,dwTemp / 4);
                    dwSrc   += dwTemp;
                    dwDest  += dwTemp;
                    dwCount -= dwTemp;
                }
            }
        }
    }

    /*
     * copy remaining data
     */
    {
        DWORD dw64 = dwCount & 0xffffffc0;
        DWORD dw16 = dwCount & 0x00000030;
        DWORD dw4  = dwCount & 0x0000000c;
        DWORD dw1  = dwCount & 0x00000003;

        if (dw64)
        {
            nvMemCopy64 (dwDest,dwSrc,dw64 / 64);
            dwDest += dw64;
            dwSrc  += dw64;
        }
        if (dw16)
        {
            nvMemCopy16 (dwDest,dwSrc,dw16 / 16);
            dwDest += dw16;
            dwSrc  += dw16;
        }
        if (dw4)
        {
            nvMemCopy4 (dwDest,dwSrc,dw4 / 4);
            dwDest += dw4;
            dwSrc  += dw4;
        }
        if (dw1)
        {
            nvMemCopy1 (dwDest,dwSrc,dw1 / 1);
            dwDest += dw1;
            dwSrc  += dw1;
        }
    }
}

/*
 * nvMemTouch
 *
 * moves given data block to L1 cache if it fits - else is wastes time
 */
void nvMemTouch
(
    DWORD dwSrc,
    DWORD dwCount
)
{
    __asm
    {
        mov ecx,[dwCount]
        shr ecx,5
         jz mts

        mov ebx,[dwSrc]

    mtl: mov eax,[ebx]
         add ebx,32
         dec ecx
        jnz mtl

    mts:
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\nvinit.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVSWIZ.CPP                                                        *
*   CPU Texture swizzling routines                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvdetect.h"

/*
 * globals
 */
DWORD g_dwCPUFeatureSet = 0;
DWORD g_dwCPUClockSpeed = 0;

/*
 * nvUtilCreate
 *
 * initializes the nvutil component
 */
void nvUtilCreate
(
    void
)
{
    /*
     * feature set
     */
    g_dwCPUFeatureSet = (nvDetectMMX()    ? NV_FS_MMX    : 0)
                      | (nvDetectKATMAI() ? NV_FS_KATMAI : 0);

    MEMORYSTATUS ms;
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus (&ms);

    if (ms.dwTotalPhys >= 250*1024*1024)      g_dwCPUFeatureSet |= NV_FS_64MB | NV_FS_128MB | NV_FS_256MB;
    else if (ms.dwTotalPhys >= 120*1024*1024) g_dwCPUFeatureSet |= NV_FS_64MB | NV_FS_128MB;
    else if (ms.dwTotalPhys >=  60*1024*1024) g_dwCPUFeatureSet |= NV_FS_64MB;

    /*
     * clock speed
     */
    g_dwCPUClockSpeed = nvGetCPUSpeed();
}

/*
 * nvUtilDestroy
 *
 * destroys the nvutil component
 */
void nvUtilDestroy
(
    void
)
{
}

/*
 * nvGetCPUCaps
 *
 * returns CPU caps
 */
void nvGetCPUCaps
(
    NVCPUINFO *pInfo
)
{
    pInfo->dwCPUClockSpeed = g_dwCPUClockSpeed;
    pInfo->dwCPUFeatureSet = g_dwCPUFeatureSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\precomp.h ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <malloc.h>
#include <math.h>
#include "..\..\ddraw\win9x\nv4\x86\x86.h" // this should be moved to a better place
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\nvUtil.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVUTIL.H                                                          *
*   interface to NV utility functions common to most 3D drivers             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/15/99 - wrote it                     *
*                                                                           *
\***************************************************************************/
#ifndef _nvutil_h
#define _nvutil_h

/*
 * constants
 */
#define NV_MEMCOPY_DONTCARE         0   // alignment is not an issue
#define NV_MEMCOPY_WANTSRCALIGNED   1   // source must be aligned
#define NV_MEMCOPY_WANTDESTALIGNED  2   // dest must be aligned

#define NV_SWIZFLAG_SRCSWIZZLED     1   // source is swizzled
#define NV_SWIZFLAG_DESTSWIZZLED    2   // dest is swizzled

#define NV_FS_MMX                   0x00000001      // CPU can do MMX
#define NV_FS_KATMAI                0x00000002      // CPU is a P3 (or later)
#define NV_FS_64MB                  0x10000000      // has at least 64Mb
#define NV_FS_128MB                 0x20000000      // has at least 128Mb
#define NV_FS_256MB                 0x40000000      // has at least 256Mb

/*
 * types
 */
#ifndef _WINDOWS_
#error windows.h must be included before including nvutil.h
#endif

/*
 * macros
 */

/*
 * structs
 */
typedef struct
{
    DWORD dwCPUFeatureSet;
    DWORD dwCPUClockSpeed;
} NVCPUINFO;

/*
 * exports
 */
#ifdef __cplusplus
extern "C" 
{
#endif

/*
 * creation and destruction
 */
void nvUtilCreate  (void);
void nvUtilDestroy (void);

/*
 * CPU caps
 */
void nvGetCPUCaps (NVCPUINFO*);

/*
 * mem copy
 */
void nvMemCopy
(
    DWORD dwDest,                   // dest address
    DWORD dwSrc,                    // source address
    DWORD dwCount,                  // # of bytes to copy
    DWORD dwFlags                   // alignment flags (NV_MEMCOPY_xxx)
);

/*
 * swizzling
 */
BOOL nvSwizzleBlt
(
    DWORD         dwSrcAddr,        // base address
    DWORD         dwSrcLogW,        // log2 of texture width
    DWORD         dwSrcLogH,        // log2 of texture height
    DWORD         dwSrcX0,          // sub rectangle to swizzlw
    DWORD         dwSrcY0,
    DWORD         dwSrcX1,
    DWORD         dwSrcY1,
    DWORD         dwSrcPitch,       // pitch

    DWORD         dwDestAddr,
    DWORD         dwDestLogW,
    DWORD         dwDestLogH,
    DWORD         dwDestX,
    DWORD         dwDestY,
    DWORD         dwDestPitch,

    DWORD         dwBPP,            // bytes pre pixel (not bits per pixel!)
    DWORD         dwFlags           // swizzle flags (NV_SWIZFLAG_xxx)
);

#ifdef __cplusplus
}
#endif

#endif //!_nvutil_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvCapture.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#include "nvCapture.h"
#include <time.h>

#include "targa.c"

#define CAPTURE_MAX_FILESIZE  0x80000000          // 2 GB
#define CAPTURE_MAX_TEMP      (65536 * 10)
#define CAPTURE_MAX_INCS      16                  // maximum number of times file can be inc'ed
                                                  // before temp buffer is flushed
#define CAPTURE_STRING_SIZE   64

#define CAPTURE_FILE_FORMAT_RECORD "%s\\%s%05d.acf"
#define CAPTURE_FILE_FORMAT_PLAY   "%s\\%s%06d.tga"

// globals
HANDLE hCaptureFile                        = NULL;
BYTE   abTempSpace[CAPTURE_MAX_TEMP];
DWORD  adwTempOffset[CAPTURE_MAX_INCS];
DWORD  adwTempSerial[CAPTURE_MAX_INCS];               // the serial number of the file for which this temp data is eventually destined
DWORD  dwTempOffsetCount                   = 0;
DWORD  dwTempOffsetCurrent                 = 0;
DWORD  dwSerialNumber                      = 0;
DWORD  dwPlaySerialNumber                  = 0;
DWORD  dwFileSize                          = 0;
char   szPath[CAPTURE_STRING_SIZE]         = "|||||||";
char   szFilename[CAPTURE_STRING_SIZE]     = "|||||||";
char   szPlayPath[CAPTURE_STRING_SIZE]     = "|||||||";
char   szPlayFilename[CAPTURE_STRING_SIZE] = "|||||||";

// ---------------------------- RECORDING -----------------------------------

//
// captureFilePurge
// remove all old files beginning with serial number dwSerial
//
int captureFilePurge
(
    DWORD dwSerial
)
{
    char  filename[128];
    BOOL  bSuccess;

    do {

        // generate filename
        sprintf (filename, CAPTURE_FILE_FORMAT_RECORD, szPath, szFilename, dwSerial);
        // delete
        bSuccess = DeleteFile (filename);
        // increment
        dwSerial++;

    } while (bSuccess);

    return 1;
}

//
// captureFileOpen
// opens a new capture file with the current serial number
//
int captureFileOpen
(
    DWORD dwSerial
)
{
    char filename[128];

    if (hCaptureFile)
    {
        // shouldn't re-open a file
        __asm int 3
    }

    // generate filename
    sprintf (filename, CAPTURE_FILE_FORMAT_RECORD, szPath, szFilename, dwSerial);

    // open file
    hCaptureFile = CreateFile (filename, GENERIC_WRITE, 0,0, OPEN_ALWAYS, 0,0);
    if (hCaptureFile == INVALID_HANDLE_VALUE)
    {
        hCaptureFile = NULL;
        return 0;
    }

    // set the file pointer to the end. this appears to be
    // the only way to append to a file. how retarded.
    SetFilePointer(hCaptureFile, 0,0, FILE_END);

    return 1;
}

//
// captureFileClose
// closes the current capture file, if any
//
int captureFileClose
(
    void
)
{
    if (hCaptureFile)
    {
        BOOL bSuccess = CloseHandle (hCaptureFile);
        if (!bSuccess)
        {
            __asm int 3
        }
        hCaptureFile = NULL;
    }

    return 1;
}

//
// captureFileInc
// close the current file and open the next in the series
//
int captureFileInc
(
    void
)
{
    dwSerialNumber++;
    dwFileSize = 0;
    return 1;
}

//
// captureLog
// write stuff into the log file (or into a temporary buffer for lack of the former)
//
int captureLog
(
    void     *pBuffer,
    unsigned  uCount
)
{
    DWORD dw;
    DWORD dwCount;

    // do we have to save off buffered data first?
    if (dwTempOffsetCount)
    {
        for (dwCount=0; dwCount<dwTempOffsetCount; dwCount++)
        {
            DWORD dwStart = dwCount ? adwTempOffset[dwCount-1] : 0;
            DWORD dwEnd   = adwTempOffset[dwCount];
            if ((!captureFileOpen(adwTempSerial[dwCount]))
                ||
                (!WriteFile (hCaptureFile, &(abTempSpace[dwStart]), dwEnd-dwStart, &dw, NULL)))
            {
                captureFileClose();
                goto noFileAccess;
            }
            captureFileClose();
        }
        // reset, now that it is empty
        dwTempOffsetCount = 0;
    }

    // write out new data
    if (captureFileOpen(dwSerialNumber))
    {
        if (!WriteFile (hCaptureFile,pBuffer,uCount,&dw,NULL))
        {
            captureFileClose();
            goto noFileAccess;
        }
        captureFileClose();
        dwFileSize += uCount;
        if (dwFileSize > CAPTURE_MAX_FILESIZE)
        {
            // don't let files grow too large
            captureFileInc();
        }
        return 1;
    }

noFileAccess:

    if ((dwTempOffsetCount == 0) ||
        (adwTempSerial[dwTempOffsetCount-1] != dwSerialNumber))
    {
        if (dwTempOffsetCount < CAPTURE_MAX_INCS)
        {
            // move to the next file and save a pointer to this location in the buffer
            adwTempOffset[dwTempOffsetCount] = dwTempOffsetCurrent;
            adwTempSerial[dwTempOffsetCount] = dwSerialNumber;
            dwTempOffsetCount++;
        }
        else
        {
            // we're out of array space
            __asm int 3;
            return 0;
        }
    }

    if (adwTempOffset[dwTempOffsetCount-1] + uCount > CAPTURE_MAX_TEMP)
    {
        DWORD err = GetLastError();
        __asm mov eax,[err]
        __asm int 3; // out of temp space
        return 0;
    }

    // save off temporarily
    memcpy (abTempSpace + adwTempOffset[dwTempOffsetCount-1], pBuffer, uCount);

    dwTempOffsetCurrent += uCount;
    adwTempOffset[dwTempOffsetCount-1] = dwTempOffsetCurrent;

    return 1;
}

//
// captureSetParams
// set name, path, and base serial number of recorded files
//
int captureSetParams
(
    char  *szBasePath,      // directory in which to dump captures (NULL is legal)
    char  *szBaseFilename,  // base name of files to write
    DWORD  dwBaseFilenum    // the serial number of the first file recorded
)
{
    DWORD dwStrEnd;

    // get rid of terminating '\' (if it exists) since
    // we'll tack one on later and having two is ugly
    dwStrEnd = strlen(szBasePath) - 1;
    if (szBasePath[dwStrEnd] == '\\') {
        szBasePath[dwStrEnd] = '\0';
    }

    // if things have changed, update and reset
    if ((strcmp (szBasePath, szPath)) ||
        (strcmp (szBaseFilename, szFilename)))
    {
        if (szBasePath) {
            strncpy (szPath, szBasePath, CAPTURE_STRING_SIZE);
        }
        if (szBaseFilename) {
            strncpy (szFilename, szBaseFilename, CAPTURE_STRING_SIZE);
        }
        dwSerialNumber = dwBaseFilenum;
        dwFileSize     = 0;
        captureFilePurge (dwBaseFilenum);
    }

    return 1;
}

//
// captureStartup
// should be called only once to initialize root capture file
//
int captureStartup
(
    char  *szBasePath,      // directory in which to dump captures (NULL is legal)
    char  *szBaseFilename,  // base name of files to write
    DWORD  dwBaseFilenum    // the serial number of the first file recorded
)
{
    CAPTURE_INFORMATION  info;
    struct tm           *newtime;
    time_t               aclock;
    static BOOL          bCalled = FALSE;

    // defer multiple creations
    if (bCalled) {
        // this shouldn't get called more than once
        __asm int 3
        return 0;
    }
    else {
        bCalled = TRUE;
    }

    captureSetParams (szBasePath, szBaseFilename, dwBaseFilenum);

    // reset temporary file buffer stuff
    dwTempOffsetCount = 0;

    // write header
    memset (&info,0,sizeof(info));
    info.dwJmpCommand         = CAPTURE_JMP_COMMAND;
    info.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
    info.dwExtensionID        = CAPTURE_XID_INFORMATION;
    info.dwSchema             = CAPTURE_CURRENT_SCHEMA;
    strcpy (info.szInformation,"Capture V1.00::");
#if defined(NVDD32)
    strcat (info.szInformation,"Direct3D::");
#elif defined(__GL_ICD)
    strcat (info.szInformation,"OpenGL::");
#else
    strcat (info.szInformation,"Unknown::");
#endif
    time (&aclock);
    newtime = localtime(&aclock);
    strcat (info.szInformation,asctime(newtime));
    captureLog (&info,sizeof(info));

    // done
    return 1;
}

//
// captureShutdown
// called once when all capturing is done
//
int captureShutdown
(
    void
)
{
    // close the file, if any
    captureFileClose();

    return 1;
}

// ------------------------------ PLAYBACK ----------------------------------

//
// capturePlayFileInc
// increment the playback file counter
//
int capturePlayFileInc
(
    void
)
{
    dwPlaySerialNumber++;
    return 1;
}

//
// capturePlay
// copy the contents of a file into the render target
//
int capturePlay
(
    void *pRenderTarget,
    DWORD dwPitch,
    DWORD dwWidth,
    DWORD dwHeight
)
{
    char  filename[128];
    BYTE *pBuffer;
    int   iTGAWidth, iTGAHeight;
    DWORD i;

    // clear the frame buffer, so we know we're in playback mode
    // even if the file copy fails for some reason
    for (i=0; i<dwHeight; i++)
    {
        memset ((BYTE *)pRenderTarget+i*dwPitch, 0xff, dwWidth);
    }

    // generate filename
    sprintf (filename, CAPTURE_FILE_FORMAT_PLAY, szPlayPath, szPlayFilename, dwPlaySerialNumber);

    // copy contents to render target
    read_targa_file (filename, &pBuffer, &iTGAWidth, &iTGAHeight);

    if (!pBuffer)
    {
        return 0;
    }

    // sanity checks
    if ((4*iTGAWidth != (int)dwWidth) || (iTGAHeight != (int)dwHeight))
    {
        // sizes must match
        __asm int 3
        return 0;
    }

    // copy into the render target
    for (i=0; i<dwHeight; i++)
    {
        memcpy ((BYTE *)pRenderTarget+i*dwPitch, pBuffer+i*dwWidth, dwWidth);
    }

    // free the buffer
    GlobalFree (pBuffer);

    return 1;
}

//
// capturePlaySetParams
// change the name / path / base serial number of the playback files
//
int capturePlaySetParams
(
    char  *szBasePath,      // directory from which to read bitmaps
    char  *szBaseFilename,  // base name of files to read
    DWORD  dwBaseFilenum    // the serial number of the first file played back
)
{
    DWORD dwStrEnd;

    // get rid of terminating '\' (if it exists) since
    // we'll tack one on later and having two is ugly
    dwStrEnd = strlen(szBasePath) - 1;
    if (szBasePath[dwStrEnd] == '\\') {
        szBasePath[dwStrEnd] = '\0';
    }

    // if things have changed, update and reset
    if ((strcmp (szBasePath, szPlayPath)) ||
        (strcmp (szBaseFilename, szPlayFilename)))
    {
        if (szBasePath) {
            strncpy (szPlayPath, szBasePath, CAPTURE_STRING_SIZE);
        }
        if (szBaseFilename) {
            strncpy (szPlayFilename, szBaseFilename, CAPTURE_STRING_SIZE);
        }
        dwPlaySerialNumber = dwBaseFilenum;
    }

    return 1;
}

//
// capturePlayStartup
// should be called only once to initialize root capture file
//
int capturePlayStartup
(
    char  *szBasePath,      // directory from which to read bitmaps
    char  *szBaseFilename,  // base name of files to read
    DWORD  dwBaseFilenum    // the serial number of the first file played back
)
{
    capturePlaySetParams (szBasePath, szBaseFilename, dwBaseFilenum);

    // done
    return 1;
}

//
// capturePlayShutdown
// called once when all playback is done
//
int capturePlayShutdown
(
    void
)
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvD3DKelvinBackend.c ===
#if !defined(IS_OPENGL)
  #include "nvprecomp.h"
#endif

/*****************************************************************************/
#if !defined(IS_OPENGL)
static NV_INLINE void CopyPoint(float *dst, const float *src)
{
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
}
#endif

/*****************************************************************************/
/*****************************************************************************/

// routines for integer tessellations
void SendGuardCurve(unsigned long curvetype, NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, unsigned long flags)
{
    unsigned long dwCount = 0x0;
    int i;
    NV_PATCH_CURVE_INFO *pTemp, *pTempN;
    float *pBegin, *pBeginN;
    float *pEnd, *pEndN;
    unsigned long dwMethod;

    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    nvAssert(curvetype == NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE ||
             curvetype == NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE);


    //don't send guard curves if there aren't any attribs on that can be guarded
    if (!(info->evalEnables & (0x1 << NV_PATCH_ATTRIB_POSITION)) && !(flags & NV_PATCH_HAS_NORMAL)) { return; }

    //GUARD CURVE DATA SENT IN THIS ORDER!!!!!
    //(1) GUARDPOINT NORMAL (2) GUARDPOINT POSITION (3) GUARDCURVE POSITION (4) GUARDCURVE NORMAL

    if (NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE == curvetype) {
        pTemp  = (*quadInfo->pSwatchVBegin)[ATTR_V];
        pBegin = info->pSwatchCorner[ATTR_V][0][0];
        pEnd = info->pSwatchCorner[ATTR_V][1][0];
        if (flags & NV_PATCH_HAS_NORMAL) {
            pTempN = (*quadInfo->pSwatchVBegin)[info->dstNormal];
            pBeginN = info->pSwatchCorner[info->dstNormal][0][0];
            pEndN = info->pSwatchCorner[info->dstNormal][1][0];
        }

    } else {
        pTemp  = (*quadInfo->pSwatchVEnd)[ATTR_V];
        pBegin = info->pSwatchCorner[ATTR_V][0][1];
        pEnd = info->pSwatchCorner[ATTR_V][1][1];
        if (flags & NV_PATCH_HAS_NORMAL)
            pTempN = (*quadInfo->pSwatchVEnd)[info->dstNormal];
            pBeginN = info->pSwatchCorner[info->dstNormal][0][1];
            pEndN = info->pSwatchCorner[info->dstNormal][1][1];
    }

    //  ^-----^-----^
    // /|\ s /|\ s /|\
    //  |  w  |  w  |
    //  |  a  |  a  |
    //  |--t--o--t--|
    //  |  h  |  h  |
    //  o-----+-----o

    //if I'm an inner guard curve (i.e. a RIGHT guard curve, or left guard not on first row/last row) then step forward
    if (quadInfo->stitchVBegin
            && ( ((curvetype == NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE) && !(flags & NV_PATCH_SWATCH_LAST_COL))
                 || ((curvetype == NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE)  && !(flags & NV_PATCH_SWATCH_FIRST_COL))))
    {
        if (info->evalEnables & (0x1 << NV_PATCH_ATTRIB_POSITION)) {
            // position is on
            OffsetCurve(info, pTemp,1);
            // and tweak to swatch corner
            CopyPoint(pTemp->coeffs[0], pBegin);
        }
        if (flags & NV_PATCH_HAS_NORMAL) {
            // normal is on
            OffsetCurve(info, pTempN,1);
            // and tweak to swatch corner
            CopyPoint(pTempN->coeffs[0], pBeginN);
        }
    }

    HOS_NOTE("Begin Curve (Guard Curve)");
    dwMethod = ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE));
    HOS_PUSH(dwCount, dwMethod);
    HOS_PUSH(dwCount+1, curvetype);
    dwCount += 0x2;

    // send guard point normal
    if (flags & NV_PATCH_HAS_NORMAL) {
        //send guard point normal if active
        HOS_NOTE("Set Curve Coefficients");
        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
        HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pEndN[0]));
        HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pEndN[1]));
        HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pEndN[2]));
        HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pEndN[3]));
        dwCount+=5;
    }
    HOS_PUSH_ADJUST(dwCount);

    // send guard point position
    dwCount = 0;
    if (info->evalEnables & (0x1 << NV_PATCH_ATTRIB_POSITION)) {
        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
        HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pEnd[0]));
        HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pEnd[1]));
        HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pEnd[2]));
        HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pEnd[3]));
        dwCount+=5;

        //send guard curve position
        for (i = 0; i < pTemp->order; i++) {
            HOS_NOTE("Set Curve Coefficients");
            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pTemp->coeffs[i][0]));
            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pTemp->coeffs[i][1]));
            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pTemp->coeffs[i][2]));
            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pTemp->coeffs[i][3]));
            dwCount+=5;
        }
        HOS_PUSH_ADJUST(dwCount);
    }

    //send guard curve for normal if active
    dwCount = 0;
    if (flags & NV_PATCH_HAS_NORMAL) {
        //send guard curve...
        for (i = 0; i < pTempN->order; i++) {
            HOS_NOTE("Set Curve Coefficients");
            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pTempN->coeffs[i][0]));
            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pTempN->coeffs[i][1]));
            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pTempN->coeffs[i][2]));
            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pTempN->coeffs[i][3]));
            dwCount+=5;
        }
    }
    HOS_PUSH(dwCount, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(dwCount+1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    dwCount+=2;
    HOS_PUSH_ADJUST(dwCount);

    return;
}

void ComputeKelvinHOSControlWords(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, long flags)
{
    int hwAttr, numcoeffs, order;
    unsigned int BPControl[4];
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();
    unsigned int t1, t2;
    int uMaxSegs = quadInfo->uMaxSegs;
    int vMaxSegs = quadInfo->vMaxSegs;
    int partialWidth, partialHeight, nSwatchU, nSwatchV;
    int doFrac = info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL;

    nvAssert(NV_PATCH_NUMBER_OF_ATTRIBS == 16);   //this is assumed in this loop that follows
    BPControl[0] = BPControl[1] = 0x0;
    numcoeffs = 0;

    for (hwAttr = 0; hwAttr <= 7; hwAttr++) {               //BPControl0
        if (info->evalEnables & (1 << hwAttr)) {
            order = info->maps[hwAttr].uorder;
            nvAssert(order-1 > 0);
            BPControl[0] |= ((order-1) << (hwAttr<<2));     //hwAttr*4
            numcoeffs+=order;
        }
    }

    for (hwAttr = 8; hwAttr < 16; hwAttr++) {               //BPControl1
        if (info->evalEnables & (1 << hwAttr)) {
            order = info->maps[hwAttr].uorder;
            nvAssert(order-1 > 0);
            BPControl[1] |= ((order-1) << ((hwAttr-8)<<2));
            numcoeffs+=order;
        }
    }       

    //in the fractional case we've intentionally rounded up by 1 to subsume the fractional portion of the transition
    //but we don't want to fool the HW with this notational convenience, drop by 1 here if necessary
    if (doFrac) { 
        //stitchUEnd/stitchVEnd are never set in the fractional case so decrement these in the non degenerate cases
        //because the partialwidth/height below won't account for it properly -- in the degenerate case
        //we don't have a last row or last col transition so DON'T decrement here... UGH.
        if (uMaxSegs>1) uMaxSegs--;     
        if (vMaxSegs>1) vMaxSegs--; 
    }
        
    partialWidth = (uMaxSegs - quadInfo->stitchUEnd) % info->maxSwatch;   //should truncate to integer...   
    partialHeight = (vMaxSegs - quadInfo->stitchVEnd) % info->maxSwatch;
    nSwatchU = (uMaxSegs - quadInfo->stitchUEnd - partialWidth)  / info->maxSwatch;
    nSwatchV = (vMaxSegs - quadInfo->stitchVEnd - partialHeight) / info->maxSwatch;   

    //if we have a degenerate regular grid -- ignore the normal
    //counts of SwatchU,SwatchV and set them to 0.  This is required by HW
    //despite appearances.  The Transition inside/outside params in the transition
    //control words will disambiguate this apparent strangeness.
    if (quadInfo->stitchUBegin || quadInfo->stitchUEnd) {
        if (uMaxSegs  <= 1) { nSwatchU = 0; nSwatchV = 0; }
    }
    if (quadInfo->stitchVBegin || quadInfo->stitchVEnd) {
        if (vMaxSegs  <= 1) { nSwatchU = 0; nSwatchV = 0; }
    }

    BPControl[2] = 0x0; //BPControl2
    nvAssert(info->maxSwatch <=17);

    //assumed as a QUAD..
    BPControl[2] = (partialHeight << 26) | (partialWidth << 21) | (info->maxSwatch << 16) | (nSwatchU << 8) | (nSwatchV << 0);

    //Don't turn this on because we don't actully support triangle patches natively... for future work
    //BPControl[2] |=  ((info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR ? 1 : 0) << 31 /*primitive type */);//
    if (doFrac) {        
        BPControl[3] = (NV097_SET_BEGIN_PATCH3_TESSELATION_FIXED_STITCH << 16); 
        if (quadInfo->uMaxSegs == 1 || quadInfo->vMaxSegs == 1) {
            BPControl[3] |= NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST;
            BPControl[3] |= (NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST << 3);
        } else {
            BPControl[3] |= (NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST_AND_LAST | (NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST_AND_LAST << 3));
        }

    } else {
        // row transitions
        t1 = (quadInfo->stitchVEnd ? 2 : 0) | (quadInfo->stitchVBegin ? 1 : 0);
        if (quadInfo->u0Dir != quadInfo->u1Dir  &&  t1) {
            // reverse transition, and not degenerate
            t1 |= 4;
        }
        nvAssert(t1 != 7);

        // col transitions
        t2 = (quadInfo->stitchUEnd ? 16 : 0) | (quadInfo->stitchUBegin ? 8 : 0);
        if (quadInfo->v0Dir != quadInfo->v1Dir  &&  t2) {
            // reverse col transition, and not degenerate
            t2 |= 0x20;
        }
        nvAssert(t2 != 0x38);
        BPControl[3] = t2 | t1;
    }

    if (quadInfo->uMaxDir ^ quadInfo->vMaxDir ^ info->flipUV) {
        BPControl[3] |= (1 << 14);
    }

    if (info->evalEnables & (1 << NV_PATCH_ATTRIB_POSITION)) {
        order = (info->maps[NV_PATCH_ATTRIB_POSITION].vorder - 1);
        nvAssert(order > 0);
        BPControl[3] |= (order << 6 );
    }
    if (flags & NV_PATCH_HAS_NORMAL || info->evalEnables & (1 << NV_PATCH_ATTRIB_NORMAL)) {
        order = (info->maps[info->dstNormal].vorder - 1);
        nvAssert(order > 0);
        BPControl[3] |= (order << 10);
    }
    BPControl[3] |= (numcoeffs << 24);

    HOS_NOTE("Set Begin Patch");
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH0)));
    HOS_PUSH(1, BPControl[0]);
    HOS_PUSH(2, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH1)));
    HOS_PUSH(3, BPControl[1]);
    HOS_PUSH(4, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH2)));
    HOS_PUSH(5, BPControl[2]);
    HOS_PUSH(6, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH3)));
    HOS_PUSH(7, BPControl[3]);
    HOS_PUSH_ADJUST(8);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvdbg.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* NV Common ******************************
//
//  Module: nvDbg.cpp
//      Shared debugging routines for printing, tracing, etc.
//
// **************************************************************************
//
//  History:
//      Matt Lavoie             18Nov00         extracted from d3d
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************

#include "CompileControl.h"

#if (IS_WINNT5 || IS_WIN9X)
    #include "nvprecomp.h"
    #pragma hdrstop
    // need to port nvFile to NT4
    #define HAVE_NV_FILE_FACILITY
#endif  // (IS_WINNT5 || IS_WIN9X)

#include "nvUtil.h"
#include "nvDbg.h"
#include <stdarg.h>
#include <minmax.h>

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//---------------------------------------------------------------------------

#ifdef DEBUG

    int        dbgTrace    = 0;
    NvU32      dbgLevel    = 0;
    NvU32      dbgLog      = 0;
    int        dbgDP2      = 0;

    static int iTraceLevel = 0;

#endif

//-------------------------------------------------------------------------
// DEBUG PRINTING
//---------------------------------------------------------------------------

#if (IS_WINNT4)
    extern "C" void EngDebugPrint( char *, char *, va_list ap );
#endif  // (IS_WINNT4)

static __inline void nvOutputDebugString (char *szStr)
{
#if (IS_WINNT5 || IS_WINNT4)
    EngDebugPrint("", szStr, (va_list)(NULL));
#elif (IS_WIN9X)
    OutputDebugStringA(szStr);
#endif
}
#if 0
//---------------------------------------------------------------------------

void __cdecl PF (char * szFormat, ...)
{
    char str[256];

    nvStrCpy (str, DPF_START_STR);
    nvSprintfVAL (str+nvStrLen(str), szFormat, (va_list)(&szFormat+1));
    nvStrCat (str, DPF_END_STR);
    nvOutputDebugString (str);
}
#endif
//---------------------------------------------------------------------------

#ifdef DEBUG

void __cdecl DPF (char * szFormat, ...)
{
    char str[256];

    nvStrCpy (str, DPF_START_STR);
    nvSprintfVAL (str+nvStrLen(str), szFormat, (va_list)(&szFormat+1));
    nvStrCat (str, DPF_END_STR);

    DPF_PLAIN ("%s", str);
}

#ifdef HAVE_NV_FILE_FACILITY
HANDLE dpf_file;
//-------------------------------------------------------------------------

void __cdecl createDPFLog()
{
    if (dbgLog)
    {
        dpf_file = NvCreateFile(DPF_LOG_FILE, GENERIC_WRITE, 0,0, CREATE_ALWAYS,0,0);
        if (dpf_file != INVALID_HANDLE_VALUE)
        {
            return;
        }

    }
    else
    {
        dpf_file = 0;
    }
}

//-------------------------------------------------------------------------

void __cdecl closeDPFLog()
{
    if (dbgLog)
    {
        if (dpf_file != INVALID_HANDLE_VALUE)
        {
            NvCloseHandle(dpf_file);
            dpf_file = 0;
        }

    }
    else
    {
        dpf_file = 0;
    }
}
#endif

//-------------------------------------------------------------------------

void __cdecl DPF_PLAIN (char * szFormat, ...)
{
    static NvU8 bFirst = TRUE;
    char   str[256];

    nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));
    nvOutputDebugString (str);

#ifdef HAVE_NV_FILE_FACILITY
    // echo output to root of current working drive
    if (dbgLog) {
        NvU32 dw;
        NvWriteFile (dpf_file,str,nvStrLen(str),&dw,NULL);
    }
#endif
}

//-------------------------------------------------------------------------

void __cdecl DPF_LEVEL (NvU32 dwLevel, char *szFormat, ...)
{
    if (dbgLevel & dwLevel) {
        char str[256];
        nvStrCpy (str, DPF_START_STR);
        nvSprintfVAL (str+nvStrLen(str), szFormat, (va_list)(&szFormat+1));
        nvStrCat (str, DPF_END_STR);
        DPF_PLAIN ("%s", str);
    }
}

//-------------------------------------------------------------------------

void __cdecl DPF_LEVEL_PLAIN (NvU32 dwLevel, char * szFormat, ...)
{
    if (dbgLevel & dwLevel) {
        char str[256];
        nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));
        DPF_PLAIN ("%s", str);
    }
}

#endif  // DEBUG

//-------------------------------------------------------------------------
// TRACING
//-------------------------------------------------------------------------

#ifdef DEBUG

void __cdecl dbgResetTraceLevel(void)
{
    iTraceLevel = 0;
}

//-------------------------------------------------------------------------

void __cdecl dbgTracePush (char * szFormat, ...)
{
    char szIndent[2*NV_TRACE_MAX_DEPTH+1];
    char szFullStr[512];
    char szSubStr[NV_TRACE_MAX_COLS+1];
    char szOutStr[NV_TRACE_MAX_COLS+1];
    char szDP2[512];
    int  i;

#if IS_WIN9X
    if (global.b16BitCode) { return; }
#endif

    //print only dp2 calls
    nvStrCpy(szDP2,szFormat);
    szDP2[5] = '\0';
    if (dbgDP2 && nvStrCmp(szDP2,"nvDP2")) {
        iTraceLevel++;
        return;
    }
    
    
    
    // Make sure we want to print this level
    if (iTraceLevel >= (dbgTrace & ~NVDBG_TRACE_EXIT)) {
        iTraceLevel++;
        return;
    }

    // get the proper indent
    szIndent[0] = '\0';
    for (i = 0; (i < iTraceLevel) && (i < NV_TRACE_MAX_DEPTH); i++) {
        nvStrCat (szIndent, "  ");
    }
    

    // generate the full string.
    nvStrCpy (szFullStr, NV_TRACE_START_STR);
    nvSprintfVAL (szFullStr+nvStrLen(szFullStr), szFormat, (va_list)(&szFormat+1));
    NvU32 dwLength = nvStrLen (szFullStr);

    // dole it out in chunks
    NvU32 dwMaxCharsPerLine = NV_TRACE_MAX_COLS - nvStrLen(DPF_START_STR) - nvStrLen(szIndent);
    i = 0;
    while (dwLength) {
        NvU32 dwThisLength = min (dwLength,dwMaxCharsPerLine);
        nvStrNCpy (szSubStr, szFullStr+i, dwThisLength);
        szSubStr[dwThisLength] = '\0';
        nvSprintf (szOutStr, "%s%s", szIndent, szSubStr);
        DPF (szOutStr);
        dwLength -= dwThisLength;
        i += dwThisLength;
    }

    iTraceLevel++;
}

//-------------------------------------------------------------------------

void __cdecl dbgTracePop (void)
{
    char szIndent[2 * NV_TRACE_MAX_DEPTH + 1];
    int i;

#if IS_WIN9X
    if (global.b16BitCode) { return; }
#endif


    iTraceLevel--;

    if ((dbgTrace & NVDBG_TRACE_EXIT) && (iTraceLevel < (dbgTrace & ~NVDBG_TRACE_EXIT))) {
        // get the proper indent
        szIndent[0] = '\0';
        for (i = 0; (i < iTraceLevel) && (i < NV_TRACE_MAX_DEPTH); i++) {
            nvStrCat (szIndent, "  ");
        }
        DPF("%sTRACE: [exit]", szIndent);
    }

    // sanity check
    if (iTraceLevel < 0) {
        dbgError("error: iTraceLevel < 0");
    }
}

#elif INSTRUMENT_ALL_CALLS

#define MAXSTACK 1024   // keep track this many levels deep.
char  aszProcName[MAXSTACK][256];
DWORD adwTimeStack[MAXSTACK];
DWORD dwTimeStackIndex = 0;
BOOL  bTimedBefore     = FALSE;

//-------------------------------------------------------------------------

void __cdecl dbgTracePush (LPSTR szFormat, ...)
{
    if (global.b16BitCode) { return; }

    if (dwTimeStackIndex < MAXSTACK) {
        // for now we just keep the format string (no expantion)
        strcpy (&aszProcName[dwTimeStackIndex][10],szFormat);
        // start timer
        adwTimeStack[dwTimeStackIndex] = GetTickCount();
    }
    dwTimeStackIndex++;
}

//-------------------------------------------------------------------------

void __cdecl dbgTracePop (void)
{
    if (global.b16BitCode) { return; }

    // stop timer
    dwTimeStackIndex--;

    if (dwTimeStackIndex < MAXSTACK) {

        DWORD dwDelta = GetTickCount() - adwTimeStack[dwTimeStackIndex];

        if (dwDelta >= IAC_THRESHOLD) {
            // open file
            HANDLE h = NvCreateFile("\\timeinfo.txt",
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    bTimedBefore ? OPEN_ALWAYS : CREATE_ALWAYS, // delete old file on new runs
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
            if (!h) {
                __asm int 3 // cannot create file
            }
            SetFilePointer (h,0,NULL,FILE_END);

            // log time
            DWORD dw;
            aszProcName[dwTimeStackIndex][0] = char('0' + (dwTimeStackIndex / 100) % 10);
            aszProcName[dwTimeStackIndex][1] = char('0' + (dwTimeStackIndex / 10) % 10);
            aszProcName[dwTimeStackIndex][2] = char('0' + (dwTimeStackIndex / 1) % 10);
            aszProcName[dwTimeStackIndex][3] = char(':');
            aszProcName[dwTimeStackIndex][4] = char('0' + (dwDelta / 10000) % 10);
            aszProcName[dwTimeStackIndex][5] = char('0' + (dwDelta / 1000) % 10);
            aszProcName[dwTimeStackIndex][6] = char('0' + (dwDelta / 100) % 10);
            aszProcName[dwTimeStackIndex][7] = char('0' + (dwDelta / 10) % 10);
            aszProcName[dwTimeStackIndex][8] = char('0' + (dwDelta / 1) % 10);
            aszProcName[dwTimeStackIndex][9] = char(':');
            strcat (&aszProcName[dwTimeStackIndex][10],"\r\n");
            NvWriteFile (h,aszProcName[dwTimeStackIndex],strlen(aszProcName[dwTimeStackIndex]),&dw,NULL);

            // done
            NvCloseHandle (h);
            bTimedBefore = TRUE;
        }
    }
}

#endif // INSTRUMENT_ALL_CALLS

//-------------------------------------------------------------------------
// ERROR HANDLING
//---------------------------------------------------------------------------

#ifdef DEBUG

int _nvAssertReport(const char *pszExpr, const char *pszFile, const int nLine)
{
    DPF("Assertion failed!");
    DPF("File: %s", pszFile);
    DPF("Line: %d", nLine);
    DPF("Expression: %s", pszExpr);
    return TRUE;
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\nvswiz.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVSWIZ.CPP                                                        *
*   CPU Texture swizzling routines                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvinit.h"

/*
 * constants
 */
#define L2MB        5
#define MB          (1<<L2MB)   // swizzle macroblock size

#define MB_UMASK    ((MB*MB-1) & 0x55555555)
#define MB_VMASK    ((MB*MB-1) & 0xaaaaaaaa)

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define TEXELCOPY(d,s,bpp)                          \
{                                                   \
    if ((bpp) == 2) *(WORD*)(d)  = *(WORD*)(s);     \
    /*else if ((bpp) == 1) *(BYTE*)(d)  = *(BYTE*)(s);*/\
    else *(DWORD*)(d) = *(DWORD*)(s);               \
}

#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

/*
 * swizzle table buffer layout
 */
BYTE nvTexelScratchBuffer[8192];  // must be as wide as the widest pitch (4 * 2048 = 8192)

/*****************************************************************************
 * swizzle address generation
 *****************************************************************************/
typedef struct
{
    DWORD dwBase;
    DWORD dwOffset;
    DWORD dwLine;

    DWORD dwDUDXOr;
    DWORD dwDUDXAnd;
    DWORD dwDUDXAdd;

    DWORD dwDVDYOr;
    DWORD dwDVDYAnd;
    DWORD dwDVDYAdd;
} SWIZZLE_ADDR;

__inline DWORD nvSwizzleAddrGet (SWIZZLE_ADDR *lpSA)
{
    return lpSA->dwBase + lpSA->dwOffset;
}

__inline void nvSwizzleAddrNext (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u              = ((lpSA->dwOffset | lpSA->dwDUDXOr) + lpSA->dwDUDXAdd) & lpSA->dwDUDXAnd;
    v              =   lpSA->dwOffset & lpSA->dwDVDYAnd;
    lpSA->dwOffset = u | v;
}

__inline void nvSwizzleAddrNewLine (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u            =   lpSA->dwLine & lpSA->dwDUDXAnd;
    v            = ((lpSA->dwLine | lpSA->dwDVDYOr) + lpSA->dwDVDYAdd) & lpSA->dwDVDYAnd;
    lpSA->dwLine = lpSA->dwOffset = u | v;
}

void nvSwizzleAddrCreate
(
    SWIZZLE_ADDR *lpSA,
    DWORD         dwBase,
    DWORD         dwX,
    DWORD         dwY,
    DWORD         dwLogW,
    DWORD         dwLogH,
    DWORD         dwBPP
)
{
    if (!dwLogW)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwY * dwBPP;
        lpSA->dwDUDXAnd = 0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = 0;
        lpSA->dwDVDYAnd = ~0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = dwBPP;
    }
    else if (!dwLogH)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwX * dwBPP;
        lpSA->dwDUDXAnd = ~0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYAnd = 0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = 0;
    }
    else
    {
        DWORD dwLog       = min(dwLogW,dwLogH);
        DWORD dw2Log      = dwLog << 1;            // # of bits to interleave
        DWORD dwUpperMask = ~((1 << dw2Log) - 1);  // bits to preserve
        DWORD dwLowerMask = ~dwUpperMask;          // bits to interleave

        /*
         * calc offset
         */
        DWORD dwUpperU    = (dwX << dwLog) & dwUpperMask;
        DWORD dwUpperV    = (dwY << dwLog) & dwUpperMask;

        DWORD dwLower     = ((dwX & 0x001) <<  0) | ((dwY & 0x001) <<  1)
                          | ((dwX & 0x002) <<  1) | ((dwY & 0x002) <<  2)
                          | ((dwX & 0x004) <<  2) | ((dwY & 0x004) <<  3)
                          | ((dwX & 0x008) <<  3) | ((dwY & 0x008) <<  4)
                          | ((dwX & 0x010) <<  4) | ((dwY & 0x010) <<  5)
                          | ((dwX & 0x020) <<  5) | ((dwY & 0x020) <<  6)
                          | ((dwX & 0x040) <<  6) | ((dwY & 0x040) <<  7)
                          | ((dwX & 0x080) <<  7) | ((dwY & 0x080) <<  8)
                          | ((dwX & 0x100) <<  8) | ((dwY & 0x100) <<  9)
                          | ((dwX & 0x200) <<  9) | ((dwY & 0x200) << 10)
                          | ((dwX & 0x400) << 10) | ((dwY & 0x400) << 11)
                          | ((dwX & 0x800) << 11) | ((dwY & 0x800) << 12);

        lpSA->dwBase   = dwBase;
        lpSA->dwOffset = lpSA->dwLine
                       = ((dwLower & dwLowerMask) | dwUpperU | dwUpperV) * dwBPP;

        /*
         * calc masks
         */
        lpSA->dwDUDXOr  = (0xaaaaaaaa & dwLowerMask) * dwBPP;
        lpSA->dwDUDXAnd = ((dwLogW > dwLogH) ? (0x55555555 | dwUpperMask)
                                             : (0x55555555 & dwLowerMask)) * dwBPP;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYOr  = (0x55555555 & dwLowerMask) * dwBPP;
        lpSA->dwDVDYAnd = ((dwLogW < dwLogH) ? (0xaaaaaaaa | dwUpperMask)
                                             : (0xaaaaaaaa & dwLowerMask)) * dwBPP;
        lpSA->dwDVDYAdd = dwBPP << 1;
    }
}

/*
 * SOFTWARE SWIZZLE
 * ----------------
 */

/*
 * nvSwizzleSmallBlock
 *
 * swizzles any texture with a dimension less than 8 (i.e. 2048 x 4)
 */
void nvSwizzleSmallBlock
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwCount,dwSize,dwLine;
    DWORD        dwScratch0,dwScratch1;
    DWORD        x,y;
    void        *pMemory;

    /*
     * figure out memory requirements
     */
    dwCount = 1     << (dwLogW + dwLogH);
    dwSize  = dwBPP << (dwLogW + dwLogH);
    if (dwSize > 4096)
    {
        pMemory = malloc(dwSize * 2);
        dwScratch0 = (DWORD)pMemory;
        dwScratch1 = ((DWORD)pMemory) + dwSize;
    }
    else
    {
        pMemory    = NULL;
        dwScratch0 = (DWORD)(nvTexelScratchBuffer + 0);
        dwScratch1 = (DWORD)(nvTexelScratchBuffer + 4096);
    }

    /*
     * read texels
     */
    dwLine = dwBPP << dwLogW;
    if (dwLine != dwSrcPitch)
    {
        DWORD u = dwSrcBase;
        DWORD v = dwScratch0;
        for (y = (1 << dwLogH); y; y--)
        {
            nvMemCopy (v,u,dwLine,NV_MEMCOPY_WANTSRCALIGNED);
            v += dwLine;
            u += dwSrcPitch;
        }
    }
    else
    {
        nvMemCopy (dwScratch0,dwSrcBase,dwLine << dwLogH,NV_MEMCOPY_WANTSRCALIGNED);
    }

    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwScratch1,0,0,dwLogW,dwLogH,dwBPP);

    /*
     * do swizzle
     */
    switch (dwBPP)
    {
        case 1:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(BYTE*)nvSwizzleAddrGet(&sa) = *(BYTE*)dwScratch0;

                    dwScratch0 += 1;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 2:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(WORD*)nvSwizzleAddrGet(&sa) = *(WORD*)dwScratch0;

                    dwScratch0 += 2;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 4:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(DWORD*)nvSwizzleAddrGet(&sa) = *(DWORD*)dwScratch0;

                    dwScratch0 += 4;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
    }

    /*
     * write texels
     */
    nvMemCopy (dwDestBase,dwScratch1,dwSize,NV_MEMCOPY_WANTDESTALIGNED);

    /*
     * free memory
     */
    if (pMemory) free (pMemory);
}

/*
 * nvSwizzleMacroBlock_LS
 *
 * swizzles a full MBxMB block (lin -> swz)
 */
void nvSwizzleMacroBlock_LS
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,
    DWORD dwDestBase,
    DWORD dwBPP
)
{
    if (g_dwCPUFeatureSet & NV_FS_KATMAI)
    {
        switch (dwBPP)
        {
            case 2: // 16bpp Pentium3
            {
                __asm
                {
                    mov eax,offset nvTexelScratchBuffer
                    mov ecx,(MB * MB * 2) / 32
            xxx16:   prefetch_rm8 (1,rmIND8(rEAX), 0)
                     add eax,32
                     dec ecx
                    jnz xxx16

                    mov eax,[dwSrcBase]
                    prefetch_rm8 (1,rmIND8(rEAX), 0)
                    prefetch_rm8 (1,rmIND8(rEAX),32)
                }

                {
                    DWORD src = dwSrcBase;
                    DWORD dst = (DWORD)nvTexelScratchBuffer;
                    DWORD v = 0;
                    DWORD y;

                    for (y = MB; y; y--)
                    {
                        DWORD addr;

                        addr  = src;
                        src  += dwSrcPitch;
                        __asm
                        {
                            mov eax,[src]
                            prefetch_rm8 (1,rmIND8(rEAX), 0)
                            prefetch_rm8 (1,rmIND8(rEAX),32)
                        }


#define NXT1(u)  ((((u) | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2))
#define NXT2(u)  NXT1(NXT1(u))
#define NXT4(u)  NXT2(NXT2(u))
#define NXT8(u)  NXT4(NXT4(u))
#define NXT16(u) NXT8(NXT8(u))
#define NXT32(u) NXT16(NXT16(u))

                        // MB assumed to be 32
                        __asm {
                            push esi
                            push edi
                            push ebx

                        // load 8 texels
                            mov eax,[addr]
                            mov ebx,[eax]
                            mov ecx,[eax + 4]
                            mov edx,[eax + 8]
                            mov edi,[eax + 12]

                            mov eax,[v]

                            mov esi,eax
                          //or esi,0
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT2(0)
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT4(0)
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT4(NXT2(0))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 16]
                            mov ecx,[eax + 20]
                            mov edx,[eax + 24]
                            mov edi,[eax + 28]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT8(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT8(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT8(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT8(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 32]
                            mov ecx,[eax + 36]
                            mov edx,[eax + 40]
                            mov edi,[eax + 44]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 48]
                            mov ecx,[eax + 52]
                            mov edx,[eax + 56]
                            mov edi,[eax + 60]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(NXT8(0))
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT2(0)))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(0)))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(NXT2(0))))
                            add esi,[dst]
                            mov [esi],edi

                            pop ebx
                            pop edi
                            pop esi
                        }

                        v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
                    }

                    nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*2,NV_MEMCOPY_WANTDESTALIGNED);
                }

                return;
            }
            case 4: // 32bpp Pentium3
            {
                __asm
                {
                    mov eax,offset nvTexelScratchBuffer
                    mov ecx,(MB * MB * 4) / 32
            xxx32:   prefetch_rm8 (1,rmIND8(rEAX), 0)
                     add eax,32
                     dec ecx
                    jnz xxx32

                    mov eax,[dwSrcBase]
                    prefetch_rm8 (1,rmIND8(rEAX), 0)
                    prefetch_rm8 (1,rmIND8(rEAX),32)
                }

                {
                    DWORD src = dwSrcBase;
                    DWORD dst = (DWORD)nvTexelScratchBuffer;
                    DWORD v = 0;
                    DWORD y;

                    for (y = MB; y; y--)
                    {
                        DWORD u,x;
                        DWORD addr;

                        addr  = src;
                        src  += dwSrcPitch;
                        __asm
                        {
                            mov eax,[src]
                            prefetch_rm8 (1,rmIND8(rEAX), 0)
                            prefetch_rm8 (1,rmIND8(rEAX),32)
                        }

                        u = 0;
                        for (x = MB; x; x--)
                        {
                            DWORD store = dst + (u | v);
                            *(WORD*)store = *(WORD*)addr;

                            addr += 4;
                            u = ((u | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4);
                        }
                        v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
                    }

                    nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*4,NV_MEMCOPY_WANTDESTALIGNED);
                }

                return;
            }

        }
    }

    /*
     * default code
     */
    {
        DWORD src = dwSrcBase;
        DWORD dst = (DWORD)nvTexelScratchBuffer;
        DWORD v = 0;
        DWORD y;

        for (y = MB; y; y--)
        {
            DWORD u,x;
            DWORD addr;

            addr  = src;
            src  += dwSrcPitch;

            u = 0;
            for (x = MB; x; x--)
            {
                DWORD store = dst + (u | v);
                *(WORD*)store = *(WORD*)addr;

                addr += dwBPP;
                u     = ((u | (MB_VMASK*dwBPP)) + 1*dwBPP) & (MB_UMASK*dwBPP);
            }
            v = ((v | (MB_UMASK*dwBPP)) + 2*dwBPP) & (MB_VMASK*dwBPP);
        }

        nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*dwBPP,NV_MEMCOPY_WANTDESTALIGNED);
    }
}

/*
 * nvSwizzleBlt_Lin_Swz_FullTexture
 *
 * software swizzle algorithm for full textures
 *  full texture means:
 *    source width & height == dest width & height
 *    blt rectangle is (0,0) - (w,h)
 */
void nvSwizzleBlt_Lin_Swz_FullTexture
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwMBPP,dwMBPP2;
    DWORD        x,y;

    /*
     * handle small cases
     */
    if ((dwLogW < L2MB) || (dwLogH < L2MB))
    {
        nvSwizzleSmallBlock (dwSrcBase,dwSrcPitch,
                             dwDestBase,
                             dwLogW,dwLogH,dwBPP);
        return;
    }

    /*
     * adjust width & height for macroblocks
     */
    dwLogW -= L2MB;
    dwLogH -= L2MB;
    dwMBPP  = dwBPP << L2MB;
    dwMBPP2 = dwBPP << (L2MB + L2MB);

    /*
     * optimize for thin vertical case (swizzle bit does not work for this)
     */
    if (!dwLogW)
    {
        for (y = (1 << dwLogH); y; y--)
        {
            nvSwizzleMacroBlock_LS (dwSrcBase,dwSrcPitch,
                                    dwDestBase,
                                    dwBPP);
            dwSrcBase  += dwSrcPitch << L2MB;
            dwDestBase += dwMBPP2;
        }
        return;
    }

    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwDestBase,0,0,dwLogW,dwLogH,dwMBPP2);

    /*
     * do macroblock swizzle
     */
    for (y = (1 << dwLogH); y; y--)
    {
        DWORD dwSrc = dwSrcBase;

        for (x = (1 << dwLogW); x; x--)
        {
            nvSwizzleMacroBlock_LS (dwSrc,dwSrcPitch,
                                    nvSwizzleAddrGet(&sa),
                                    dwBPP);

            nvSwizzleAddrNext (&sa);
            dwSrc += dwBPP << L2MB;
        }

        nvSwizzleAddrNewLine (&sa);
        dwSrcBase += dwSrcPitch << L2MB;
    }
}

/*
 * nvSwizzleBlt_Lin_Lin
 *
 * simple SW bit-blt
 */
void nvSwizzleBlt_Lin_Lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            dwSrcAddr += dwSrcPitch;
            a         += dwBytes;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

/*
 * nvSwizzleBlt_Swz_Lin
 *
 * deswizzle anything
 */
void nvSwizzleBlt_Swz_Lin
(
    SWIZZLE_ADDR *lpSA,

    DWORD         dwDestAddr,
    DWORD         dwDestPitch,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;

        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSA),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }

            nvSwizzleAddrNewLine (lpSA);
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

/*
 * nvSwizzleBlt_Lin_Swz
 *
 * swizzles anything
 */
void nvSwizzleBlt_Lin_Swz
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,

    SWIZZLE_ADDR *lpSA,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSA),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }
            nvSwizzleAddrNewLine (lpSA);
        }

        y -= f;
    }
}

/*
 * nvSwizzleBlt_Swz_Swz
 *
 * swizzle - swizzle copy, handles anything
 */
void nvSwizzleBlt_Swz_Swz
(
    SWIZZLE_ADDR *lpSASrc,

    SWIZZLE_ADDR *lpSADest,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSASrc),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSASrc);
            }
            nvSwizzleAddrNewLine (lpSASrc);
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSADest),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSADest);
            }
            nvSwizzleAddrNewLine (lpSADest);
        }

        y -= f;
    }
}

/*
 * exported
 * --------
 */

/*
 * nvSwizzleBlt
 *
 * performs swizzle or deswizzle in the most optimal fashion depending
 * on surface location and specified flags
 *
 * if pTexture != NULL we will block CPU before writing (if needed)
 * & also update retirement date for proper syncronization.
 */
BOOL nvSwizzleBlt
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcLogW,
    DWORD         dwSrcLogH,
    DWORD         dwSrcX0,
    DWORD         dwSrcY0,
    DWORD         dwSrcX1,
    DWORD         dwSrcY1,
    DWORD         dwSrcPitch,

    DWORD         dwDestAddr,
    DWORD         dwDestLogW,
    DWORD         dwDestLogH,
    DWORD         dwDestX,
    DWORD         dwDestY,
    DWORD         dwDestPitch,

    DWORD         dwBPP,
    DWORD         dwFlags
)
{
    /*
     * prepare common variables
     */
    DWORD dwW         = dwSrcX1 - dwSrcX0;
    DWORD dwH         = dwSrcY1 - dwSrcY0;
    BOOL  bWholeSrc   = ((1U << dwSrcLogW)  == dwW) && ((1U << dwSrcLogH)  == dwH);
    BOOL  bWholeDest  = ((1U << dwDestLogW) == dwW) && ((1U << dwDestLogH) == dwH);
    BOOL  bFullTex    = bWholeSrc && bWholeDest && (dwSrcLogW == dwDestLogW) && (dwSrcLogH == dwDestLogH);

    /*
     * sanity check
     */
    if (!dwH || !dwW || !dwSrcAddr || !dwDestAddr) return FALSE;

    /*
     * break into different swizzle cases
     */
    switch (dwFlags & (NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED))
    {
        case 0:                         // lin -> lin
        {
            DWORD dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            nvSwizzleBlt_Lin_Lin  (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                   dwSrcPitch,
                                   dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                   dwDestPitch,
                                   dwW,dwH,dwSubHeight,dwBPP);
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED:   // swz -> lin
        {
            SWIZZLE_ADDR sa;
            DWORD        dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            nvSwizzleAddrCreate (&sa,dwSrcAddr,dwSrcX0,dwSrcY0,dwSrcLogW,dwSrcLogH,dwBPP);

            nvSwizzleBlt_Swz_Lin (&sa,
                                  dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                  dwDestPitch,
                                  dwW,dwH,dwSubHeight,dwBPP);
        }
        case NV_SWIZFLAG_DESTSWIZZLED:  // lin -> swz
        {
            if (!bFullTex)
            {
                SWIZZLE_ADDR sa;
                DWORD        dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleAddrCreate (&sa,dwDestAddr,dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP);

                nvSwizzleBlt_Lin_Swz (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                      dwSrcPitch,
                                      &sa,
                                      dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
                nvSwizzleBlt_Lin_Swz_FullTexture (dwSrcAddr,dwSrcPitch,
                                                  dwDestAddr,
                                                  dwSrcLogW,dwSrcLogH,dwBPP);
            }
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED: // swz -> swz
        {
            SWIZZLE_ADDR saSrc;
            SWIZZLE_ADDR saDest;
            DWORD        dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            nvSwizzleAddrCreate (&saSrc, dwSrcAddr, dwSrcX0,dwSrcY0,dwSrcLogW, dwSrcLogH, dwBPP);
            nvSwizzleAddrCreate (&saDest,dwDestAddr,dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP);

            nvSwizzleBlt_Swz_Swz (&saSrc,
                                  &saDest,
                                  dwW,dwH,dwSubHeight,dwBPP);
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvGLBackend.c ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvGLBackend.c
//        gl immediate mode entry points for the patch shared library
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

/*** OpenGL immediate mode backend ***/

static void GLImm_BeginPrimitive(void *info, NV_PATCH_PRIMITIVE_TYPE primType)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;

    switch (primType) {
    case NV_PATCH_PRIMITIVE_TSTRIP:
        (*gc->dispatchState->dispatch.Begin)(GL_TRIANGLE_STRIP);
        break;
    case NV_PATCH_PRIMITIVE_TFAN:
        (*gc->dispatchState->dispatch.Begin)(GL_TRIANGLE_FAN);
        break;
    }
}

static void GLImm_EndPrimitive(void *info)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;

    (*gc->dispatchState->dispatch.End)();
}

#if defined(COMPILE_DEBUG_LIBRARY)
// to check that proper unique vertices are generated
#define MAX_UNIQUE_CHECK    (16*16) //512
int enableUniqueCheck = 0;
int nUniqueVertices = 0;
float   uniqueVertices[MAX_UNIQUE_CHECK][4];

#define EQUAL_VERTEX4FV(p0, p1) ( \
           (EV_AS_INT(p0[0]) == EV_AS_INT(p1[0])) \
        && (EV_AS_INT(p0[1]) == EV_AS_INT(p1[1])) \
        && (EV_AS_INT(p0[2]) == EV_AS_INT(p1[2])) \
        && (EV_AS_INT(p0[3]) == EV_AS_INT(p1[3])) \
    ) \

void addUniqueVertex4fv(float *v)
{
    int ii;

    if (nvDebugLevel < 2) {
        return;
    }
    for (ii = 0;  ii < nUniqueVertices;  ii++) {
        if (EQUAL_VERTEX4FV(uniqueVertices[ii], v)) {
            // found match
            return;
        }
    }
    assert(nUniqueVertices < MAX_UNIQUE_CHECK);
    if (nUniqueVertices >= MAX_UNIQUE_CHECK) {
        return;
    }
    uniqueVertices[nUniqueVertices][0] = v[0];
    uniqueVertices[nUniqueVertices][1] = v[1];
    uniqueVertices[nUniqueVertices][2] = v[2];
    uniqueVertices[nUniqueVertices][3] = v[3];
    nUniqueVertices++;
}

void drawUniqueVertices(void)
{
    int ii;
    float *p;

    glColor3f(0.5f, 0.f, 0.f);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);

    glPointSize(16);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    glBegin(GL_POINTS);
    //ffglBegin(GL_TRIANGLES);
    for (ii = 0;  ii < nUniqueVertices;  ii++) {
        p = uniqueVertices[ii];
        TPRINTF(("%2d) x%08X x%08X x%08X : %g %g %g\n", ii,
                    EV_AS_INT(p[0]), EV_AS_INT(p[1]), EV_AS_INT(p[2]),
                    p[0], p[1], p[2]));
        glVertex4fv(p);

        //ffglVertex3f(p[0],        p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1]+.05,   p[2]);
        //ffglVertex3f(p[0],        p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1]-.05,   p[2]);
    }
    glEnd();
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
}
#endif

// This won't work quite right until we have state aliasing for vertex programs.
static void GLImm_SendVertex(void *info,
                             NV_PATCH_EVAL_OUTPUT *pData, int index)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;
    unsigned int evalEnables = ((NV_PATCH_INFO *)info)->evalEnables;
    float *attribs = &pData->vertexAttribs[index][0][0];
    int i;

#if defined(COMPILE_DEBUG_LIBRARY)
    if (enableUniqueCheck) {
        addUniqueVertex4fv(&attribs[4*__GL_ATTRIB_POSITION]);
        NV_TRACE_COND(TR_EVAL, 35,
            tprintf("vert x%08X x%08X x%08X : %g %g %g\n",
                    EV_AS_INT(attribs[4*__GL_ATTRIB_POSITION+0]),
                    EV_AS_INT(attribs[4*__GL_ATTRIB_POSITION+1]),
                    EV_AS_INT(attribs[4*__GL_ATTRIB_POSITION+2]),
                    attribs[4*__GL_ATTRIB_POSITION+0],
                    attribs[4*__GL_ATTRIB_POSITION+1],
                    attribs[4*__GL_ATTRIB_POSITION+2]);
        );
    }
#endif

    if (gc->state.enables.general & __GL_VERTEX_PROGRAM_ENABLE) {
        for (i = 1; i < __GL_NUMBER_OF_VERTEX_ATTRIBS; i++) {
            if (evalEnables & (1 << i)) {
                (*gc->dispatchState->extensions.VertexAttrib4fvNV)(i, &attribs[4*i]);
            }
        }
        (*gc->dispatchState->extensions.VertexAttrib4fvNV)(0, &attribs[4*0]);
    } else {
        if (evalEnables & (1 << __GL_ATTRIB_VERTEX_WEIGHT)) {
            (*gc->dispatchState->extensions.VertexWeightfvEXT)
                (&attribs[4*__GL_ATTRIB_VERTEX_WEIGHT]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_NORMAL)) {
            (*gc->dispatchState->dispatch.Normal3fv)
                (&attribs[4*__GL_ATTRIB_NORMAL]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_COLOR)) {
            (*gc->dispatchState->dispatch.Color4fv)
                (&attribs[4*__GL_ATTRIB_COLOR]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_SECONDARY_COLOR)) {
            (*gc->dispatchState->extensions.SecondaryColor3fvEXT)
                (&attribs[4*__GL_ATTRIB_SECONDARY_COLOR]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_FOG_COORD)) {
            (*gc->dispatchState->extensions.FogCoordfvEXT)
                (&attribs[4*__GL_ATTRIB_FOG_COORD]);
        }
        // 2 unused attribs
        for (i = 0; i < __GL_NUMBER_OF_TEXTURE_UNITS; i++) {
            if (evalEnables & (1 << (__GL_ATTRIB_TEXCOORD0 + i))) {
                (*gc->dispatchState->extensions.MultiTexCoord4fvARB)
                    (GL_TEXTURE0_ARB + i, &attribs[4*(__GL_ATTRIB_TEXCOORD0 + i)]);
            }
        }
        // 6 (NV10) or 4 (NV20) unused attribs

        // Must do position (vertex attrib 0) last
        (*gc->dispatchState->dispatch.Vertex4fv)
            (&attribs[4*__GL_ATTRIB_POSITION]);
    }
}

// This allows us to flip the orientation of geometry.
static void GLImm_SetFrontFace(void *info, int reversed)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;
    unsigned int evalEnables = ((NV_PATCH_INFO *)info)->evalEnables;

    (*gc->dispatchState->dispatch.FrontFace)
        (gc->eval.cachedFrontFaceDirection ^ reversed);
}

static void GLImm_BeginPatch(void *void_info)
{
    NV_PATCH_INFO *info = (NV_PATCH_INFO *)void_info;
    __GLNVstate *state = NV_GET_HWSTATE(info->context);

    assert(!(state->fdEvalMask & NV_PATCH_STATE_OPEN));
    state->fdEvalMask |= NV_PATCH_STATE_OPEN | NV_PATCH_STATE_IN_PB;
}

static void GLImm_EndPatch(void *void_info)
{
    NV_PATCH_INFO *info = (NV_PATCH_INFO *)void_info;
    __GLNVstate *state = NV_GET_HWSTATE(info->context);

    assert(state->fdEvalMask & NV_PATCH_STATE_OPEN);
    state->fdEvalMask &= ~NV_PATCH_STATE_OPEN;
}

static NV_PATCH_BACKEND GLImm_Backend = {
    NULL,
    NULL,
    GLImm_BeginPrimitive,
    GLImm_EndPrimitive,
    GLImm_SendVertex,
    GLImm_SetFrontFace,
    GLImm_BeginPatch,
    GLImm_EndPatch,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvOverlaySurf.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************

#include "nvprecomp.h"
#include "nvOverlaySurf.h"

// A cleaner solution to this would be nice.  Note too that we may have multiple heads
// in different modes; so this is a bit ambiguous. @mjl@
#if (IS_WINNT4 || IS_WINNT5)
#undef GET_MODE_BPP
#define GET_MODE_BPP()           (vpp.m_ppdev->cBitsPerPel)
#endif


static DWORD nvCSCreate4ccIF09(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
static DWORD nvCSCreate4ccRGB0(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf);
static DWORD nvCSCreate4ccIF09(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
static DWORD nvCSCreate4ccYUY2 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight);
static DWORD nvCSCreate4ccYV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
#if (IS_WINNT5 || IS_WIN9X)
static DWORD nvCSCreate4ccNVID (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
static DWORD nvCSCreate4ccNV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
static DWORD nvCSCreate4ccNVMC (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf);
static DWORD nvCSCreate4ccNVSP (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf);
#endif

//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccRGB0 (Vpp_t *pVpp,LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwPitch;

    DWORD dwModeBPP = GET_MODE_BPP();

    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8) {
        dwPitch = pSurf->lpGbl->wWidth;
    }
    else {
        dwPitch = pSurf->lpGbl->wWidth * (dwModeBPP >> 3);
    }

    dwPitch = (dwPitch + vpp.pDriverData->dwSurfaceAlignPad) & ~vpp.pDriverData->dwSurfaceAlignPad;
    DWORD dwBlockSize = (dwPitch * ((DWORD)pSurf->lpGbl->wHeight));
    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8) {
        pSurf->lpGbl->ddpfSurface.dwRGBBitCount = 8;
        pSurf->lpGbl->ddpfSurface.dwRBitMask = 0;
        pSurf->lpGbl->ddpfSurface.dwGBitMask = 0;
        pSurf->lpGbl->ddpfSurface.dwBBitMask = 0;
    }
    else {
        pSurf->lpGbl->ddpfSurface.dwRGBBitCount = dwModeBPP;
        if (dwModeBPP == 8) {
            pSurf->lpGbl->ddpfSurface.dwRBitMask = 0;
            pSurf->lpGbl->ddpfSurface.dwGBitMask = 0;
            pSurf->lpGbl->ddpfSurface.dwBBitMask = 0;
            pSurf->lpGbl->ddpfSurface.dwFlags |= DDPF_PALETTEINDEXED8;
        }
        else if (dwModeBPP == 16) {
            pSurf->lpGbl->ddpfSurface.dwRBitMask = 0x0000F800;
            pSurf->lpGbl->ddpfSurface.dwGBitMask = 0x000007E0;
            pSurf->lpGbl->ddpfSurface.dwBBitMask = 0x0000001F;

        }
        else if (dwModeBPP == 32) {
            pSurf->lpGbl->ddpfSurface.dwRBitMask = 0x00FF0000;
            pSurf->lpGbl->ddpfSurface.dwGBitMask = 0x0000FF00;
            pSurf->lpGbl->ddpfSurface.dwBBitMask = 0x000000FF;
        }
    }
    pSurf->lpGbl->ddpfSurface.dwRGBAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
        DWORD dwStatus;
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
        if (dwStatus == 0) {
            vpp.pDriverData->DDrawVideoSurfaceCount++;
            pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
            return (DD_OK);
        }
    }

    return (DDERR_OUTOFMEMORY);
}

//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccIF09 (Vpp_t *pVpp,LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                                HANDLE hOverlayOwner,
                                DWORD dwExtraSize, DWORD dwExtraNumSurfaces)
{
    DWORD dwPitch;
    DWORD i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return (DDERR_OUTOFCAPS);
        }
    }

    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE) << 1;
    dwPitch = (dwPitch + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;
    // first alloc some extra space for YUV9 surfaces to format chroma
    DWORD dwBlockSize = (dwPitch >> 1) * (((DWORD)pSurf->lpGbl->wHeight + 3) >> 2);
    // now allocate enough video memory for the Indeo part of the surface
    dwPitch = pSurf->lpGbl->wWidth;
    // allow extra room for block skip bits between Indeo portion of surface and YUY2 portion
    dwBlockSize += ((dwPitch * ((DWORD)pSurf->lpGbl->wHeight * 10L)) >> 3);
    // Force block to be properly aligned
    dwBlockSize = (dwBlockSize + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.pDriverData->TotalVRAM >> 20 > 4)) {
        // Remember offset to 2nd half YUY2 portion of surface
        pSurf->lpGbl->dwReserved1 = dwBlockSize;
        // reset dwPitch to actual Indeo surface pitch
        dwPitch = pSurf->lpGbl->wWidth;
    }
    else
        pSurf->lpGbl->dwReserved1 = 0;

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 9;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

        DWORD dwStatus;

        if (vpp.extraOverlayOffset[0] == 0 && dwExtraSize > 0) {
            // first time through, allocate extra space for VPP
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
            if (dwExtraNumSurfaces > 0) {
                vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize;
                vpp.extraOverlayOffset[0] = (vpp.extraOverlayOffset[0] + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
            }
            for (i=1; i<dwExtraNumSurfaces; i++) {
                vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
            }
        }
        else {
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
        }

        if (dwStatus == 0) {
            vpp.pDriverData->DDrawVideoSurfaceCount++;
            pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                DWORD index = 0;
                while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
                    (index < NV_VPP_MAX_OVERLAY_SURFACES))
                    index++;
                nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
                vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
                vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
                vpp.dwOverlaySurfaces++;
            }
            return (DD_OK);
        }

        else {
            for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
                vpp.extraOverlayOffset[i] = 0;
            }
            // We can't support overlay surfaces in system memory
            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                return (DDERR_OUTOFMEMORY);
            }
        }

    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
            (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}

//---------------------------------------------------------------------------
#if (IS_WIN9X || IS_WINNT5)

static DWORD nvCSCreate4ccNV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner,
                         DWORD dwExtraSize, DWORD dwExtraNumSurfaces)
{
    DWORD dwPitch, dwStatus;
    DWORD dwBlockSize;
    DWORD dw422BlockSize;
    int i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return (DDERR_OUTOFCAPS);
        }
    }

    // Round up surface height to an integer multiple of 16 scanlines
    pSurf->lpGbl->wHeight = (pSurf->lpGbl->wHeight + 15) & 0xFFF0;

    dwPitch = (pSurf->lpGbl->wWidth + 3) & ~3;
    dwPitch = (dwPitch + 127) & ~127;                                   // These surfaces MUST be 128 byte aligned so that
    pSurf->lpGbl->lPitch = dwPitch;                                     // when odd field is used as a texture it will be 128 byte aligned
    dwBlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);       // 420 LUMA portion
    dwBlockSize += (dwPitch * ((DWORD)pSurf->lpGbl->wHeight >> 1));     // 420 CHROMA portion
    dwBlockSize += (8 * dwPitch) + 256;                                 // 8 scanline safety buffer + 16x16 block of 0x80 for Intra Block processing
    dwPitch = (pSurf->lpGbl->wWidth + 3) & ~3;
    dwPitch = ((dwPitch << 1) + 127) & ~127;

//    if ((pSurf->lpGbl->wWidth > 1600) && (vpp.pDriverData->TotalVRAM <= 0x2000000))  // Try to fit 1080i with motion comp in a 32 MB frame buffer
    if (pSurf->lpGbl->wWidth > 1600) // Our hardware isn't fast enough or memory efficient enough yet, always run 1080i in crippled mode
    {
        if ((vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN) &&
            (vpp.pDriverData->TotalVRAM > 0x2000000)) {
            vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
            dw422BlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 portion
        } else {   
            vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = TRUE;
            dw422BlockSize = (dwPitch * (DWORD)((pSurf->lpGbl->wHeight + 2) >> 1));    // 422 portion
        }
        if ((vpp.pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS) && 
            (!(vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)))
            vpp.pDriverData->bMCHorizontallyDownscale1080i = TRUE;
        else
            vpp.pDriverData->bMCHorizontallyDownscale1080i = FALSE;
    } else if ((pSurf->lpGbl->wWidth > 1024) && 
               (vpp.pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS) &&
               (!(vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN))) { // actually this is 720p
        vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = TRUE;
        vpp.pDriverData->bMCHorizontallyDownscale1080i = TRUE;
        dw422BlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 portion
    } else {
        vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
        vpp.pDriverData->bMCHorizontallyDownscale1080i = FALSE;
        dw422BlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 portion
    }

    // Only allocate extra space for temporal filtering if it's allowed.
    // This decision was made earlier when the NVMC surface was created.
    if (vpp.pDriverData->bMCTemporalFilterDisabled < 2) {
        if (pSurf->lpGbl->wWidth < 1024)
            dw422BlockSize += (dwPitch * (DWORD)pSurf->lpGbl->wHeight);     // another 422 portion for filtering
    }

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 12;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    // Let overlay code know that we haven't got enough extra video memory for front end downscaling
    if ((vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) &&  (dwExtraNumSurfaces >= 2)) {
        if (vpp.pDriverData->TotalVRAM <= 0x1000000) {
            vpp.extraNumSurfaces = 0;
            dwExtraNumSurfaces = 0;
        }
    }

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.extraOverlayOffset[0] == 0) && (dwExtraSize > 0) && (dwExtraNumSurfaces > 0)) {
        // first time through, allocate extra space for VPP
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dw422BlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
        if (dwExtraNumSurfaces > 0) {
            vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize + dw422BlockSize;
        }
        for (i=1; i<(int)dwExtraNumSurfaces; i++) {
            vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
        }
    } else {
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dw422BlockSize, TYPE_OVERLAY);
    }

    if (dwStatus == 0) {
        vpp.pDriverData->DDrawVideoSurfaceCount++;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;

        // Clear Intra block area to 0x80 bias value 
        // Actually, clear entire 420 surface to gray which avoids prediction pixel blending problems at edges of video image
        memset((char *)(VIDMEM_ADDR(pSurf->lpGbl->fpVidMem)), 128, dwBlockSize);
        // <<<NOTE>>>: Uncomment the following line if line above is ever removed
        // memset((char *)(VIDMEM_ADDR(pSurf->lpGbl->fpVidMem) + dwBlockSize - 256), 128, 256);

        // find a free surface
        for (i=0; i<8; i++) {
            if (vpp.pDriverData->dwMCNV12Surface[i] == 0) {
                break;
            }
        }

        if (i == 8) {
            // no free surfaces
            NVHEAP_FREE(pSurf->lpGbl->fpVidMem);
            vpp.pDriverData->DDrawVideoSurfaceCount--;
            return (DDERR_OUTOFCAPS);
        }

        vpp.pDriverData->dwMCNV12Surface[i] = (DWORD)pSurf;

        if (i==0) {
            vpp.pDriverData->nvMCSurfaceFlags[8].dwMCSurfaceBase = 0; // End of list marker
            vpp.pDriverData->dwMCDestinationSurface = (DWORD)pSurf;
        }

        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase = pSurf->lpGbl->fpVidMem;
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurface422Offset = pSurf->lpGbl->fpVidMem + dwBlockSize - vpp.pDriverData->BaseAddress;

        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCMotionCompReferenceCount =
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCFormatCnvReferenceCount =
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCCompositeReferenceCount =
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCTemporalFilterReferenceCount = vpp.pDriverData->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    } else {
        i = 8;
        while (--i >= 0) {
            if (vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase != 0) {
                NVHEAP_FREE(vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase);
                vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase = 0;
                if (vpp.pDriverData->DDrawVideoSurfaceCount > 0)
                    vpp.pDriverData->DDrawVideoSurfaceCount--;
                if (vpp.dwOverlaySurfaces > 0)
                    vpp.dwOverlaySurfaces--;
                pSurf = (LPDDRAWI_DDRAWSURFACE_LCL)vpp.pDriverData->dwMCNV12Surface[i];
                vpp.pDriverData->dwMCNV12Surface[i] = 0;
                pSurf->lpGbl->fpVidMem = 0;
            }
        }
        if (vpp.dwOverlaySurfaces == 0) {
            vpp.dwOverlayOwner = 0;
            for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
                vpp.extraOverlayOffset[i] = 0;
            }
            vpp.extraNumSurfaces = 0;
        }
        // We can't support overlay surfaces in system memory
        return (DDERR_OUTOFMEMORY);
    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
            (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}
#endif


//---------------------------------------------------------------------------

#if (IS_WIN9X || IS_WINNT5)
static DWORD nvCSCreate4ccNVMC (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    DWORD dwStatus, i;
    DWORD dwBlockSize = 256;
    Vpp_t &vpp = *pVpp;

    NV_DBG_SHOW_FOURCC();

    pSurf->lpGbl->lPitch = 16;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    // Currently we only support one motion comp session only because the display function only works with our 1 overlay
    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_NVMC) {

        if (vpp.pDriverData->dwMCNVMCSurface == 0) {

            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

            if (dwStatus == 0) {
                vpp.pDriverData->DDrawVideoSurfaceCount++;
                pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                vpp.pDriverData->dwMCNVMCSurface = (DWORD)pSurf;

                // If frame buffer is 16MB, don't allow temporal filtering, to save room
                // for higher resolutions and video mirror buffers.
                // Possible values for bMCTemporalFilterDisabled:
                // 0 = temporal filtering enabled.
                // 1 = temporal filtering disabled but allowed (temporal space in NV12 buffers.)
                // 2 = temporal filtering disabled and not allowed (no temporal space in NV12 buffers.)
                if (vpp.pDriverData->TotalVRAM < 0x2000000)
                    vpp.pDriverData->bMCTemporalFilterDisabled = 2;
                else
                    vpp.pDriverData->bMCTemporalFilterDisabled = FALSE; // Default mode is enabled

                vpp.pDriverData->bMCPercentCurrentField = 65;       // Default temporal filter combination factor
                vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE; // This is only needed to support 1080i in 32MB
                vpp.pDriverData->bMCHorizontallyDownscale1080i = FALSE; // This is only needed to support 1080i on NV15 or lower
                vpp.pDriverData->dwMCMostRecentlyDecodedSurfaceBase = -1;
                for (i=0; i<8; i++) {
                    vpp.pDriverData->dwMCNV12Surface[i] = 0;
                }
                for (i=0; i<9; i++) {
                    vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase = 0;
                }
            }
            else {
                return (DDERR_OUTOFMEMORY);
            }

        } else {
            return (DDERR_OUTOFCAPS);
        }

    }

    else {

        if (vpp.pDriverData->dwMCNVDSSurfaceBase == 0) {

            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

            if (dwStatus == 0) {
                vpp.pDriverData->dwMCNVDSSurfaceBase = pSurf->lpGbl->fpVidMem;
                vpp.pDriverData->DDrawVideoSurfaceCount++;
                pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            }
            else {
                return (DDERR_OUTOFMEMORY);
            }
        } else {
            pSurf->lpGbl->fpVidMem = vpp.pDriverData->dwMCNVDSSurfaceBase;
        }
    }

    return (DD_OK);
}
#endif

//---------------------------------------------------------------------------
#if (IS_WIN9X || IS_WINNT5)
static DWORD nvCSCreate4ccNVSP (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    DWORD dwPitch, dwStatus;
    Vpp_t &vpp = *pVpp;

    pSurf->lpGbl->ddpfSurface.dwRGBBitCount = 8;
    pSurf->lpGbl->ddpfSurface.dwRBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwGBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwBBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwRGBAlphaBitMask = 8;

    // Round up surface height to an integer multiple of 16 scanlines
    pSurf->lpGbl->wHeight = (pSurf->lpGbl->wHeight + 15) & 0xFFF0;

    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE);
    dwPitch = (dwPitch + 127) & ~127;
    pSurf->lpGbl->lPitch = dwPitch;
    DWORD dwBlockSize = dwPitch * (DWORD)pSurf->lpGbl->wHeight; // calculate size of 8 bit index per pixel plane
    dwBlockSize <<= 1;  // double size to include 8 bit alpha per pixel plane
    dwBlockSize += (dwBlockSize << 1); // increase to include fully decompressed 32 bit per pixel plane
    dwBlockSize += 1024; // include room for indexed image look up table
    dwPitch = (pSurf->lpGbl->wWidth + 3) & ~3;
    dwPitch = ((dwPitch << 1) + 127) & ~127;
    dwBlockSize += (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 work area for repairing NV12 surfaces
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

    if (dwStatus == 0) {
        vpp.pDriverData->DDrawVideoSurfaceCount++;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
        vpp.pDriverData->dwMCNVSPSurface = (DWORD)pSurf;
    }
    else { // We could but currently don't support system memory subpictures
        return (DDERR_OUTOFMEMORY);
    }

    return (DD_OK);
}
#endif

//---------------------------------------------------------------------------
#if (IS_WINNT5 || IS_WIN9X)
static DWORD nvCSCreate4ccNVID (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    DWORD dwPitch, dwIndex;
    Vpp_t &vpp = *pVpp;

    // find an unused surface
    for (dwIndex=0; dwIndex<4; dwIndex++) {
        if (vpp.pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex] == 0) {
            break;
        }
    }
    if (dwIndex == 4) {
        return (DDERR_OUTOFCAPS);
    }

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 8;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;

    pSurf->lpGbl->fpVidMem = 0;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE);

    LONG adjustedHeight = (DWORD)((pSurf->lpGbl->wHeight + 1) & ~1);

    DWORD dwBlockSize = dwPitch * adjustedHeight;

    // pad the surface enough to be able to align it's base pointer to 256 bytes and it's size to end at 0xFF
    dwBlockSize += 1024;
    NV_DBG_SHOW_FOURCC();
    // now allocate enough AGP memory for the surface
    dwPitch = pSurf->lpGbl->wWidth;
    pSurf->lpGbl->lPitch = dwPitch;

    FLATPTR fpVidMem = 0;
    DWORD   dwStatus;

    NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

    if (dwStatus == 0) {
        // save initial unadjusted memory pointer for use when destroying this surface
        pSurf->lpGbl->dwReserved1 = pSurf->lpGbl->fpVidMem;
        pSurf->lpGbl->fpVidMem = (pSurf->lpGbl->fpVidMem + 511) & ~255;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        vpp.pDriverData->DDrawVideoSurfaceCount++;

    } else {
        return (DDERR_OUTOFMEMORY);
    }

    // Make sure we reset this on next use
    vpp.pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    nvAssert (dwIndex < 4);
    if (vpp.pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] != 0) {
        NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwRootHandle,
                 NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
        vpp.pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] = 0;
    }
    vpp.pDriverData->dwMCNVIDSurface[dwIndex] = (DWORD)pSurf;
    vpp.pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex] = vpp.pDriverData->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
    vpp.pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex] = (DWORD)pSurf->lpGbl->fpVidMem;

    return (DD_OK);
}
#endif

//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccYUY2 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                         HANDLE hOverlayOwner,
                         DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight)
{
    DWORD dwPitch, dwStatus;
    DWORD i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return (DDERR_OUTOFCAPS);
        }
    }

    // First try video memory
    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE) << 1;
    dwPitch = (dwPitch + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;
    if ((vpp.regOverlayMode & (NV4_REG_OVL_MODE_TFILTER | NV4_REG_OVL_MODE_DFILTER)) &&
        (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)) {
        // texture alignment
        dwPitch = (dwPitch + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
    }

    DWORD dwBlockSize = (dwPitch * pSurf->lpGbl->wHeight);  // default block size

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 16;
    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2) {
        pSurf->lpGbl->ddpfSurface.dwYBitMask = 0x00FF00FF;
        pSurf->lpGbl->ddpfSurface.dwUBitMask = 0x0000FF00;
        pSurf->lpGbl->ddpfSurface.dwVBitMask = 0xFF000000;
    }
    else {
        pSurf->lpGbl->ddpfSurface.dwYBitMask = 0xFF00FF00;
        pSurf->lpGbl->ddpfSurface.dwUBitMask = 0x000000FF;
        pSurf->lpGbl->ddpfSurface.dwVBitMask = 0x00FF0000;
    }
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();

    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.pDriverData->TotalVRAM >> 20 > 4)) {
        // Remember offset to 2nd half of surface
        pSurf->lpGbl->dwReserved1 = dwBlockSize;
    }

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && vpp.extraOverlayOffset[0] == 0 && dwExtraSize > 0) {
        // first time through, allocate extra space for VPP
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
        if (dwExtraNumSurfaces > 0) {
            vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize;
        }
        for (i=1; i<dwExtraNumSurfaces; i++) {
            vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
        }

    }
    else {
        // NV10 mediaport has a bug where it might write up to extra 256 bytes.
        // Workaround this bug by allocating a 256 byte guard band for all UYVY
        // surfaces.  Unfortunately, even non-videoport surfaces now get this guard band.
        if ((vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) &&
            (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY)) {
            dwBlockSize += 256;
        }
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
    }

    if (dwStatus == 0) {
        vpp.pDriverData->DDrawVideoSurfaceCount++;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
    }
    else {
        for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
            vpp.extraOverlayOffset[i] = 0;
        }

        return (DDERR_OUTOFMEMORY);
    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
            (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}
//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccYV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                         HANDLE hOverlayOwner,
                         DWORD dwExtraSize, DWORD dwExtraNumSurfaces)
{
    DWORD dwPitch, dwStatus;
    DWORD i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return(DDERR_OUTOFCAPS);
        }
    }

    dwPitch = pSurf->lpGbl->wWidth;
    // allow extra room for block skip bits between Indeo portion of surface and YUY2 portion
    DWORD dwBlockSize = ((dwPitch * ((DWORD)pSurf->lpGbl->wHeight * 12L)) >> 3);
    // Force block to be properly aligned
    dwBlockSize = (dwBlockSize + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.pDriverData->TotalVRAM >> 20 > 4)) {
        // Remember offset to 2nd half YUY2 portion of surface
        pSurf->lpGbl->dwReserved1 = dwBlockSize;
        // reset dwPitch to actual Indeo surface pitch
        dwPitch = pSurf->lpGbl->wWidth;
    }
    else {
        pSurf->lpGbl->dwReserved1 = 0;
    }

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 9;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

        if (vpp.extraOverlayOffset[0] == 0 && dwExtraSize > 0) {
            // first time through, allocate extra space for VPP
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
            if (dwExtraNumSurfaces > 0) {
                vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize;
            }
            for (i=1; i<dwExtraNumSurfaces; i++) {
                vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
            }
        }
        else {
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
        }

        if (dwStatus == 0) {
            vpp.pDriverData->DDrawVideoSurfaceCount++;
            pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                DWORD index = 0;
                while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
                       (index < NV_VPP_MAX_OVERLAY_SURFACES))
                    index++;
                nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
                vpp.dwOverlaySurfaceLCL[index] = (DWORD)pSurf;
                vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
                vpp.dwOverlaySurfaces++;
            }

            return (DD_OK);
        }
        else {
            for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
                vpp.extraOverlayOffset[i] = 0;
            }
            // We can't support overlay surfaces in system memory
            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                return(DDERR_OUTOFMEMORY);
            }
        }
    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
               (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}
//---------------------------------------------------------------------------
// figure out how much extra space is required for video post processing
// dwExtraSize is the size of one workspace surface, for NV4/5 we need 4,
// for NV10 we need 3.  For superpipelining, we need 8 or 5.
//
//

extern void VppCalcExtraSurfaceSpace(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, NvU32 dwDisplayHeight, NvU32 dwRequestedSurfaces,
                         NvU32 *dwExtraSize, NvU32 *dwExtraNumSurfaces, NvU32 *dwBlockHeight)
{
    DWORD dwPitch;
    Vpp_t &vpp = *pVpp;

    dbgTracePush ("nvCSCalcExtraSpace");

    *dwExtraSize = 0;
    *dwExtraNumSurfaces = 0;

    if (dwDisplayHeight > 768) {
        // disable HQVUp for resolutions greater than 1024x768
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
    }

    // find the height
    if (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)
    {
        *dwBlockHeight = dwDisplayHeight;
    }
    else
    {
        *dwBlockHeight = (DWORD)pDDSLcl->lpGbl->wHeight;
    }

    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {

#if (IS_WINNT5 || IS_WIN9X)
        // just set this to something valid for now
        vpp.pDriverData->dwMCDestinationSurface = (DWORD)(pDDSLcl);
#endif

        // OPTIMIZEME: we can bring down the number of required surfaces to 2 if we
        // know that the VPP pipe is only going to use a single stage.
        if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            *dwExtraNumSurfaces = vpp.regVPPMaxSurfaces;
        } else {
            *dwExtraNumSurfaces = vpp.regVPPMaxSurfaces; // OPTIMIZEME: eventually want to make this 5 for NV10
        }

        // if less than 16M, then default to unpipelined VPP
        if (vpp.pDriverData->TotalVRAM < 0x1000000) {
            *dwExtraNumSurfaces = min(*dwExtraNumSurfaces, 4);
        }

        // find the YUYV pitch
        dwPitch = ((pDDSLcl->lpGbl->wWidth + 1) & 0xFFFE) << 1;
        dwPitch = (dwPitch + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;
        *dwExtraSize = (dwPitch * *dwBlockHeight);
        vpp.extraPitch = dwPitch;

        if (vpp.regOverlayMode & (NV4_REG_OVL_MODE_TFILTER | NV4_REG_OVL_MODE_DFILTER)) {

            if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {

                // NV5 requires textures to have dimensions which are a power of 2
                DWORD dwBigPitch;

                // will be using texture unit, so must be a power of 2.
                // round up to the nearest one
#if 1
                DWORD dwLSBIndex, dwMSBIndex;

                dwLSBIndex = dwMSBIndex = dwPitch;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                // this wasn't an even power of 2. round up.
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; }
                // lowest allowed bigPitch is 32
                if (dwMSBIndex < 5) { dwMSBIndex = 5; }
                dwBigPitch = 1 << dwMSBIndex;

                dwLSBIndex = dwMSBIndex = *dwBlockHeight;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                // this wasn't an even power of 2. round up.
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; }
                *dwBlockHeight = 1 << dwMSBIndex;
#else

                if      (dwPitch > 4096) { dwBigPitch = 8192; }
                else if (dwPitch > 2048) { dwBigPitch = 4096; }
                else if (dwPitch > 1024) { dwBigPitch = 2048; }
                else if (dwPitch > 512)  { dwBigPitch = 1024; }
                else if (dwPitch > 256)  { dwBigPitch = 512;  }
                else if (dwPitch > 128)  { dwBigPitch = 256;  }
                else if (dwPitch > 64)   { dwBigPitch = 128;  }
                else if (dwPitch > 32)   { dwBigPitch = 64;   }
                else                     { dwBigPitch = 32;   }

                if      (*dwBlockHeight > 4096) { *dwBlockHeight = 8192; }
                else if (*dwBlockHeight > 2048) { *dwBlockHeight = 4096; }
                else if (*dwBlockHeight > 1024) { *dwBlockHeight = 2048; }
                else if (*dwBlockHeight > 512)  { *dwBlockHeight = 1024; }
                else if (*dwBlockHeight > 256)  { *dwBlockHeight = 512;  }
                else if (*dwBlockHeight > 128)  { *dwBlockHeight = 256;  }
                else if (*dwBlockHeight > 64)   { *dwBlockHeight = 128;  }
                else if (*dwBlockHeight > 32)   { *dwBlockHeight = 64;   }
                else if (*dwBlockHeight > 16)   { *dwBlockHeight = 32;   }
                else if (*dwBlockHeight > 8)    { *dwBlockHeight = 16;   }
                else if (*dwBlockHeight > 4)    { *dwBlockHeight = 8;    }
                else if (*dwBlockHeight > 2)    { *dwBlockHeight = 4;    }
                else if (*dwBlockHeight > 1)    { *dwBlockHeight = 2;    }
                else                            { *dwBlockHeight = 1;    }
#endif

                vpp.extraPitch = dwBigPitch;
                *dwExtraSize = (dwBigPitch * *dwBlockHeight);

            } else {    // NV10 or above

                // NV10 requires texture offsets to be a multiple of 256, so round up pitch to multiple of 256 for BOB
                dwPitch = (dwPitch + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
                vpp.extraPitch = dwPitch;
                *dwExtraSize = dwPitch * *dwBlockHeight;

            }

        }

        // add extra for alignment requirements
        *dwExtraSize += NV_TEXTURE_OFFSET_ALIGN + 1;

        // only allow extra surfaces to be created if they consume less than 1/2 of the total
        // video memory, other memory checks for various features is done in DriverInit and
        // will zero out the enable bits if there isn't enough memory
        if ((*dwExtraNumSurfaces * *dwExtraSize) > (vpp.pDriverData->TotalVRAM >> 1)) {
            if ((4 * *dwExtraSize) <= (vpp.pDriverData->TotalVRAM >> 1) && vpp.regVPPMaxSurfaces >= 4) {
                // can still do everything, but not superpipelined
                *dwExtraNumSurfaces = 4;
            } else if ((3 * *dwExtraSize) <= (vpp.pDriverData->TotalVRAM >> 1) && vpp.regVPPMaxSurfaces >= 3) {
                // at least we will be able to do one VPP stage superpipelined...
                if (vpp.pDriverData->TotalVRAM < 0x1000000) {
                    // 8M boards, lets be extra stingy
                    // Fixes WHQL update bob test in 1024x768x16 which accidentally allocates 720x960 surfaces instead of 720x480
                    *dwExtraNumSurfaces = 2;
                } else {
                    *dwExtraNumSurfaces = 3;
                }
            } else if ((2 * *dwExtraSize) <= (vpp.pDriverData->TotalVRAM >> 1) && vpp.regVPPMaxSurfaces >= 2) {
                // at least we will be able to do one VPP stage...
                *dwExtraNumSurfaces = 2;
            } else {
                *dwExtraNumSurfaces = 0;
            }
        }

        // refine this heuristic by checking free memory, if we don't have enough for 720x576x2x3, then back off if we can
        if ((NV_GET_VIDEO_HEAP_FREE() - (int)(*dwExtraNumSurfaces * *dwExtraSize)) < (768*576*2*3)) {
            switch (*dwExtraNumSurfaces) {
            case 6: *dwExtraNumSurfaces = 4; break;
            case 4: 
            case 3: *dwExtraNumSurfaces = 2; break;
            default: break;
            }
        }

        // This limit is primarily to allow enough FOURCC_NV12 surfaces to be created for HDTV sized HWMC
        // and to allow HWMC support in a 16 MB frame buffer.
        if ((vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) &&  (*dwExtraNumSurfaces > 2)) {
            if (vpp.pDriverData->TotalVRAM <= 0x1000000) {
                *dwExtraNumSurfaces = 2;
            } else {
                if (dwPitch > 3200) {
                    if (vpp.pDriverData->TotalVRAM <= 0x2000000)
                        *dwExtraNumSurfaces = 0;
                    else
                        *dwExtraNumSurfaces = 2;
                } else
                    if (dwPitch > 2048)
                        *dwExtraNumSurfaces = 2;
            }
        }

        // in low memory configurations, demote number of VPP surfaces if many overlay buffers requested
        if (vpp.pDriverData->TotalVRAM < 0x1000000 && dwRequestedSurfaces > 3) {
            switch (*dwExtraNumSurfaces) {
            case 6:
            case 5: *dwExtraNumSurfaces = 4; break;
            case 4: *dwExtraNumSurfaces = 3; break;
            case 3: *dwExtraNumSurfaces = 2; break;
            case 2:
            default: *dwExtraNumSurfaces = 0; break;
            }
        }

        vpp.extraNumSurfaces = *dwExtraNumSurfaces;
        vpp.extraIndex = 0;
        if (*dwExtraNumSurfaces >= NV_VPP_MAX_EXTRA_SURFACES || *dwExtraNumSurfaces == 3) {
            // enable VPP superpipelining
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_LATEFLIPSYNC;
        }
    }

    if (*dwExtraNumSurfaces >= 4) {
        // enable multipass overlay downscale on factors greater than 2
        if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            vpp.dwOverlayMaxDownScaleX = min(vpp.dwOverlayMaxDownScale, 2);
            vpp.dwOverlayMaxDownScaleY = min(vpp.dwOverlayMaxDownScale, 2);
        } else {
            vpp.dwOverlayMaxDownScaleX = min(vpp.dwOverlayMaxDownScale, 4);
            vpp.dwOverlayMaxDownScaleY = min(vpp.dwOverlayMaxDownScale, 2);
        }
    }

    dbgTracePop();
}


//---------------------------------------------------------------------------

extern DWORD VppCreateFourCCSurface(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwRV;
    DWORD i;

    HANDLE hOverlayOwner = GetCurrentProcess();

    DPF_LEVEL(NVDBG_LEVEL_OVERLAY_INFO, "  FOURCC surface requested" );

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0) &&
        (vpp.dwOverlayOwner != (DWORD) hOverlayOwner)) {
        return DDERR_OUTOFCAPS;
    }

    switch (pSurf->lpGbl->ddpfSurface.dwFourCC) {

        case FOURCC_RGB0:
        case FOURCC_RAW8:
            dwRV = nvCSCreate4ccRGB0 (pVpp, pSurf);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_IF09:
        case FOURCC_YVU9:
        case FOURCC_IV32:
        case FOURCC_IV31:
            dwRV = nvCSCreate4ccIF09 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces);
            if (dwRV != DD_OK) return(dwRV);
            break;
#if IS_WINNT5 || IS_WIN9X
        case FOURCC_NV12:   // Our motion comp surface format
            dwRV = nvCSCreate4ccNV12 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVMC: // Our motion comp control surface, NV10 or greater
        case FOURCC_NVDS:
            dwRV = nvCSCreate4ccNVMC (pVpp, pSurf);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVSP: // A subpicture surface (overlay)
            dwRV = nvCSCreate4ccNVSP (pVpp, pSurf);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVID:
            dwRV = nvCSCreate4ccNVID (pVpp, pSurf, pDDGbl);
            if (dwRV != DD_OK) return(dwRV);
            break;
#endif
        case FOURCC_YUY2:
        case FOURCC_YUNV:
        case FOURCC_UYVY:
        case FOURCC_UYNV:
            dwRV = nvCSCreate4ccYUY2 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces, dwBlockHeight);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_YV12:
        case FOURCC_420i:
            dwRV = nvCSCreate4ccYV12 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVT0:
        case FOURCC_NVT1:
        case FOURCC_NVT2:
        case FOURCC_NVT3:
        case FOURCC_NVT4:
        case FOURCC_NVT5:
        case FOURCC_NVS0:
        case FOURCC_NVS1:
        case FOURCC_NVS2:
        case FOURCC_NVS3:
        case FOURCC_NVS4:
        case FOURCC_NVS5:
        case FOURCC_NVHU:
        case FOURCC_NVHS:
#ifdef DXT_SUPPORT
        case FOURCC_DXT1:
        case FOURCC_DXT2:
        case FOURCC_DXT3:
        case FOURCC_DXT4:
        case FOURCC_DXT5:
#endif
            DPF ("should have been handled by texture-create or rejected by CanCreateSurface" );
            dbgError("NV Error!");
            return DDERR_INVALIDPARAMS;
        default:
            DPF ("unknown 4cc code in VppCreateFourCCSurface");
            dbgError("NV Error!");
            return DDERR_INVALIDPARAMS;
    }  // switch

    // align extra surfaces
    for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
        vpp.extraOverlayOffset[i] = (vpp.extraOverlayOffset[i] + NV_TEXTURE_OFFSET_ALIGN - 1) & ~(NV_TEXTURE_OFFSET_ALIGN - 1);
    }

    if (vpp.regOverlayColourControlEnable) {
        // allocate an AGP workspace if overlay has been created
        if (IS_OVERLAY(pSurf->ddsCaps.dwCaps, pSurf->lpGbl->ddpfSurface.dwFourCC) && vpp.fpOverlayShadow==0) {
            DWORD szHostWorkSpace;

            if (vpp.extraOverlayOffset[0]) {
                szHostWorkSpace = (vpp.extraPitch) * (dwBlockHeight + 10) + 8192;
            } else if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YV12 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_420i ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YVU9 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_IV32 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_IV31 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_IF09) {
                szHostWorkSpace = (pSurf->lpGbl->lPitch << 1) * (dwBlockHeight + 10) + 8192;
            } else {
                szHostWorkSpace = pSurf->lpGbl->lPitch * (dwBlockHeight + 10) + 8192;
            }

            // allocate work space in shared system memory
            // add an extra 10 lines + 4k for cache preload overrrun and page alignment
            vpp.fpOverlayShadow = (DWORD) AllocIPM(szHostWorkSpace);

            if (vpp.fpOverlayShadow) {
                unsigned long status;

                // First disconnect everything

                vpp.pDriverData->dDrawSpareSubchannelObject = 0;

                NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwRootHandle,
                    vpp.hFloatingContextDmaInOverlayShadow);

                // Now reconnect everything
                status = NvRmAllocContextDma(vpp.pDriverData->dwRootHandle,
                    vpp.hFloatingContextDmaInOverlayShadow,
                    NV01_CONTEXT_DMA,
                    DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                    DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                    DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                    (PVOID)vpp.fpOverlayShadow,
                    (szHostWorkSpace - 1));
                }
            // tells ring0 code that it can run now
            vpp.regRing0ColourCtlInterlockFlags = vpp.regRing0ColourCtlInterlockFlags | 0x1;
        }
    }

#if IS_WINNT4
    if (pSurf->ddsCaps.dwCaps & (DDSCAPS_OVERLAY)) {
#else
    if (pSurf->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT)) {
#endif
        //
        // Initialize some stuff so KMVT stuff doesn't go crazy.  This can happen if
        // the KMVT routines (mainly vddFlipOverlay) gets called before UpdateOverlay32.
        //
        vpp.dwOverlaySrcX = 0;
        vpp.dwOverlaySrcY = 0;

        // Put some information about the surface in the surface so DVD decoders can
        // initialize DMA blits properly
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 0, GUID_NV_OVERLAY_INFO.Data1);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 1, (GUID_NV_OVERLAY_INFO.Data3 << 16) |
                                                                 GUID_NV_OVERLAY_INFO.Data2);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 2, (GUID_NV_OVERLAY_INFO.Data4[3] << 24) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[2] << 16) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[1] << 8) |
                                                                 GUID_NV_OVERLAY_INFO.Data4[0]);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 3, (GUID_NV_OVERLAY_INFO.Data4[7] << 24) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[6] << 16) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[5] << 8) |
                                                                 GUID_NV_OVERLAY_INFO.Data4[4]);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 4, VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem));
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 5, (DWORD)pSurf);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 6, (DWORD)pDDGbl);
    }

    return (DD_OK);

}  // VppCreateFourCCSurface()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvpatchutilinit.c ===
/*
 * nvPatchUtilInit.c
 *
 * Software emulation for curved surfaces.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 */

#if !defined(IS_OPENGL)
#include "nvprecomp.h"
#endif

#if !defined(_WIN64)
#include "x86.h"
#endif

//FOWARD DECLARATIONS ========================================================================

PFOFSTM CompileOffsetFDMatrix2x2(NV_PATCH_INFO *info);
PFOFSTM CompileOffsetFDMatrix4x4(NV_PATCH_INFO *info);
PFOFSTM CompileOffsetFDMatrix6x6(NV_PATCH_INFO *info);
PFOFSTMED CompileOffsetFDMatrixExtractDiscard2x2(NV_PATCH_INFO *info);
PFOFSTMED CompileOffsetFDMatrixExtractDiscard4x4(NV_PATCH_INFO *info);
PFOFSTMED CompileOffsetFDMatrixExtractDiscard6x6(NV_PATCH_INFO *info);
PFOFSC CompileOffsetCurve2x2(NV_PATCH_INFO *info);
PFOFSC CompileOffsetCurve4x4(NV_PATCH_INFO *info);
PFOFSC CompileOffsetCurve6x6(NV_PATCH_INFO *info);
PFMM MatrixMult2x2(NV_PATCH_INFO *info);
PFMM MatrixMult4x4(NV_PATCH_INFO *info);
PFMM MatrixMult6x6(NV_PATCH_INFO *info);

//FD UNIT GLOBAL DATA ========================================================================
/*int bForceSoftware = 0;
void *HOSInnerLoops[16] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
unsigned int RetessFDtag[2][2] = {0x3f800000, 0, 0x3f800000, 0};     //[slot][0=ratio/ 1=order]
FDMatrix *RetessFDCache[2] = {NULL,NULL};                            //ptrs to cached FDMatrices
int RetessFDMRU = 0;                                                 //most recently used cache slot*/
NV_PATCH_GLOBAL_DATA g_FDGlobalData = DEFAULT_PATCH_GLOBAL_DATA;

//file scope global variables used by x86.h macros to setup inner loops
static unsigned char *ilcData;
static unsigned int ilcCount = 0x0;
static unsigned int ilcMax = 0x0;

//INIT THE FD UNIT ========================================================================
#ifdef DCR_SEMAPHORE
void InitSemaphoreData(NV_PATCH_INFO *info);
#endif
void nvPatchInitFD(NV_PATCH_INFO *info)
{
#if !defined(IS_OPENGL)
    //init pCache to NULL
    int i;
    for(i=0; i < MAX_EV_CACHE; i++){ if(info->pCache[i]) memset(info->pCache[i],0,sizeof(NV_PATCH_ALLOC_CACHE)); }

#endif

    g_FDGlobalData.cpuType = 0x0;
#if !defined(_WIN64)
    if(info->cpuType & FS_KATMAI)
    {
        g_FDGlobalData.cpuType = FS_KATMAI;
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_2x2] = (void *) CompileOffsetFDMatrixExtractDiscard2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_4x4] = (void *) CompileOffsetFDMatrixExtractDiscard4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_6x6] = (void *) CompileOffsetFDMatrixExtractDiscard6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_DEF] = (void *) 0x0;

        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_2x2] =    (void *) CompileOffsetFDMatrix2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_4x4] =    (void *) CompileOffsetFDMatrix4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_6x6] =    (void *) CompileOffsetFDMatrix6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_DEF] =    (void *) 0x0;

        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_2x2] = (void *) CompileOffsetCurve2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_4x4] = (void *) CompileOffsetCurve4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_6x6] = (void *) CompileOffsetCurve6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_DEF] =  (void *) 0x0;

        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_2x2] = (void *) MatrixMult2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_4x4] = (void *) MatrixMult4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_6x6] = (void *) MatrixMult6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_DEF] = 0x0;
    }
    else if(info->cpuType & FS_3DNOW)
    {
        //turn off optimized assembly routines -- I haven't written any 3DNOW stuff
        g_FDGlobalData.cpuType = 0x0;
    }
    else{
        //turn off optimized assembly routines if we don't have KATMAI support
        g_FDGlobalData.cpuType = 0x0;
    }    
#endif

#ifdef DCR_SEMAPHORE
    InitSemaphoreData(info);    
#else
    g_FDGlobalData.bForceSoftware = 0;
#endif

    return;
}

#ifdef DCR_SEMAPHORE
#define PAGE_SIZE   0x00001000
void InitSemaphoreData(NV_PATCH_INFO *info){        
    unsigned long dwSize = 2*PAGE_SIZE;    
    unsigned long dwRootHandle, dwDeviceHandle;

#if defined(IS_OPENGL)
    dwRootHandle = 0;
    dwDeviceHandle = 0;
    nvAssert(0);
#else
    dwRootHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwRootHandle;
    dwDeviceHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwDeviceHandle;
#endif
 
    dwSize--;
    //setup up mutual exclusion area for FD      
    if(NvRmAllocMemory(dwRootHandle, dwDeviceHandle, 
                        FD_SEMAPHORE_HANDLE, 
                        NV01_MEMORY_SYSTEM,
                        (NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS << 4) | 
                        (NVOS02_FLAGS_LOCATION_PCI << 8) | 
                        (NVOS02_FLAGS_COHERENCY_CACHED << 12),
                        (void**)&g_FDGlobalData.baseAllocation,
                        &(dwSize)
                        )){
        g_FDGlobalData.bForceSoftware = 1;
        return;
    }

    //FORCE ALIGNMENT TO A PAGE BOUNDARY FOR SEMAPHORES.
    g_FDGlobalData.alignedAllocation = (BYTE*)((uintptr_t)(g_FDGlobalData.baseAllocation + PAGE_SIZE - 1) & ~(PAGE_SIZE-1));
    g_FDGlobalData.FDSynchCounter = (long *)g_FDGlobalData.alignedAllocation;
    memset(g_FDGlobalData.alignedAllocation,0x0,PAGE_SIZE);

    // map a context dma to the page of semaphores
    if(NvRmAllocContextDma(dwRootHandle,
                        FD_SEMAPHORE_206E_CONTEXT_DMA,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                        (void*) &(g_FDGlobalData.alignedAllocation),
                        PAGE_SIZE-1)){
        g_FDGlobalData.bForceSoftware = 1;
        return;
    }
    
    if(NvRmAllocContextDma(dwRootHandle,
                        FD_SEMAPHORE_097_CONTEXT_DMA,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                        (void*) &(g_FDGlobalData.alignedAllocation),
                        PAGE_SIZE-1)){
        g_FDGlobalData.bForceSoftware = 1;
        return;
    }

    // success
    g_FDGlobalData.bForceSoftware = 0;
    return;
}
#undef PAGE_SIZE
#endif

//TEAR DOWN THE FD UNIT ========================================================================
#if !defined(IS_OPENGL)
void nvPatchDestroyFD()
{
    int i;

#ifdef DCR_SEMAPHORE
#if defined(IS_OPENGL)
    unsigned long dwRootHandle, dwDeviceHandle;
    dwRootHandle = 0;
    dwDeviceHandle = 0;
    nvAssert(0);
#else
    unsigned long dwRootHandle, dwDeviceHandle;
//    dwRootHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwRootHandle;
//    dwDeviceHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwDeviceHandle;
    dwRootHandle = pDriverData->dwRootHandle;
    dwDeviceHandle = pDriverData->dwDeviceHandle;
#endif
#endif

    if(g_FDGlobalData.bFirstTimeInit){ return; } //we've never initialized FD so ignore this call

    //delete HOS inner loops and Retess cache data
    for(i = 0; i < 16; i++){
        if(g_FDGlobalData.HOSInnerLoops[i]){
            delete (unsigned char *)g_FDGlobalData.HOSInnerLoops[i];
            g_FDGlobalData.HOSInnerLoops[i] = NULL;
        }
    }
    for(i=0; i < MAX_EV_CACHE; i++){
        if(MyCache[i].pBaseCache){ delete MyCache[i].pBaseCache; }
        MyCache[i].pBaseCache = NULL;
        MyCache[i].bytesAllocCache = 0;
        MyCache[i].inUse = 0;
        MyCache[i].contextCache = NULL;
        MyCache[i].countFreeCheck = 0;
    }
    g_FDGlobalData.RetessFDtag[0][0] = (unsigned int)0x3f800000;    g_FDGlobalData.RetessFDtag[0][1] = 0;
    g_FDGlobalData.RetessFDtag[1][0] = (unsigned int)0x3f800000;    g_FDGlobalData.RetessFDtag[1][1] = 0;
    if(g_FDGlobalData.RetessFDCache[0]){ delete g_FDGlobalData.RetessFDCache[0]; g_FDGlobalData.RetessFDCache[0] = NULL; }
    if(g_FDGlobalData.RetessFDCache[1]){ delete g_FDGlobalData.RetessFDCache[1]; g_FDGlobalData.RetessFDCache[1] = NULL; }

    g_FDGlobalData.RetessFDCache[0] = NULL;  //ptrs to cached FDMatrices
    g_FDGlobalData.RetessFDCache[1] = NULL;  //ptrs to cached FDMatrices

#ifdef DCR_SEMAPHORE
    NvRmFree (dwRootHandle, dwDeviceHandle, FD_SEMAPHORE_HANDLE );
    NvRmFree (dwRootHandle, dwDeviceHandle, FD_SEMAPHORE_097_CONTEXT_DMA );
    NvRmFree (dwRootHandle, dwDeviceHandle, FD_SEMAPHORE_206E_CONTEXT_DMA );
#endif

    g_FDGlobalData.bFirstTimeInit = 1;   
}
#endif

#if !defined(_WIN64)
//EXTRACT DISCARD ROUTINES ========================================================================
#define BOFFSET    0xc
#define AOFFSET    0x8
#define MOFFSET    0x4
PFOFSTMED CompileOffsetFDMatrixExtractDiscard2x2(NV_PATCH_INFO *info)
{
    return (PFOFSTMED)(0x0);
}

PFOFSTMED CompileOffsetFDMatrixExtractDiscard4x4(NV_PATCH_INFO *info)
{
    unsigned int loop, extract_v, finished, finished2, finished3, skip_rows, skip_columns;
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 1024);
    if(ilcData == 0x0) return (PFOFSTMED)NULL;    
    ilcCount = 0;    ilcMax = 1024;

    while(ilcCount &31)
    {
        xINT3;
    }
    
    //IF FDMatrix format changes this MUST be changed also.
    nvAssert(sizeof(FDMatrix) == (FDMATRIX_HEADER_SIZE + 16*16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTMED)(NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         dst            
    //      EDX                                         dir             
    
    xTEST_r_rm          (rEDX, rmREG(rEDX))
    xLABEL(extract_v)
    xJNZ32(0)
    //process as though I were extracting a row
        xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(MOFFSET)      //EAX = m
        xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)    //#row/cols data members skipped  ECX=m->data[0][0][0];
        xMOV_rm_imm     (rmIND(rECX), 0x4)                     //fill in the #coeffs in the extracted curve
        xADD_rm_imm     (rmREG(rECX), PATCH_CURVE_HEADER_SIZE) //#coeffs data members skipped  ECX=dst->data;
               
        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch first two columns
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(16)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(24)        

        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(BOFFSET)   //EDX = b
        xPUSH_r         (rEDX)                              //save off loop var I'll need it again.
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_columns)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(256)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(264)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(512)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(520)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(528)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(536)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(768)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(776)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(784)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(792)
        xADD_rm_imm     (rmREG(rEAX),32)                    //skip to next two columns
        
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_columns)                      //we skipped columns       
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(24)     

        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch next two columns
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(16)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(24)        

        xPOP_r          (rEDX)
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_columns)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(256)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(264)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(512)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(520)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(528)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(536)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(768)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(776)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(784)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(792)

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,  rmREG(rEDX))             //loop over first two cols
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_columns)                       //we skipped columns       
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(32)      //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(40)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(48)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(56)     


        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(AOFFSET)  //load EDX<-a
        xTEST_r_rm      (rEDX, rmREG(rEDX))                //skip primary loop if we don't do any work here
        xLABEL(finished2)   
        xJZ32(0)
        
        //fetch data to process from temporary storage...   
        xMOVLPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(0)   //only process the row we are interested in
        xMOVHPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(8)      
        xMOVLPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(16)      
        xMOVHPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(24)     
        xMOVLPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(32)  
        xMOVHPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(40)      
        xMOVLPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(48)      
        xMOVHPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(56)     

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xTEST_r_rm      (rEDX, rmREG(rEDX))        //loop over row
            xADDPS_r_rm     (rXMM3, rmREG(rXMM3))               
        xJNZ(loop)

        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save final results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(24)     
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(32)     
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(40)      
        //xMOVLPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(48)   //XMM3 should already have been stored off from before.
        //xMOVHPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(56)     

    xLABEL(finished)
    xJMP(0)
    xTARGET_b32(extract_v)
        //process as though I were extracting a column
        xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(MOFFSET)      //ECX = m
        xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)    //#row/cols data members skipped  ECX=m->data[0][0][0];
        xMOV_rm_imm     (rmIND(rECX), 0x4)                     //fill in the #coeffs in the extracted curve
        xADD_rm_imm     (rmREG(rECX), PATCH_CURVE_HEADER_SIZE) //#coeffs data members skipped  ECX=dst->data;

        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch first two rows
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(256)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(264)        

        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(AOFFSET)   //EDX = a
        xPUSH_r         (rEDX)                              //save off loop var I'll need it again.        
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_rows)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(16)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(24)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(32)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(40)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(288)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(296)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(48)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(56)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(304)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(312)
        xADD_rm_imm     (rmREG(rEAX),512)                    //skip to next two rows
        
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_rows)                         //we skipped rows
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(24)     

        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch first two rows
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(256)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(264)        

        xPOP_r          (rEDX)
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_rows)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(16)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(24)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(32)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(40)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(288)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(296)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(48)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(56)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(304)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(312)

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,  rmREG(rEDX))            //loop over first two colsdd 
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_rows)                         //we skipped rows
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(32)     //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(40)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(48)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(56)     

        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(BOFFSET)
        xTEST_r_rm      (rEDX, rmREG(rEDX))                 //skip primary loop if we don't do any work here
        xLABEL(finished3)   
        xJZ32(0)
        
        //fetch data to process from temporary storage...   
        xMOVLPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(0)      //only process the row we are interested in
        xMOVHPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(8)      
        xMOVLPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(16)      
        xMOVHPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(24)     
        xMOVLPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(32)  
        xMOVHPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(40)      
        //xMOVLPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(48)      
        //xMOVHPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(56)     

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xTEST_r_rm      (rEDX, rmREG(rEDX))             //loop over row
            xADDPS_r_rm     (rXMM3, rmREG(rXMM3))               
        xJNZ(loop)

        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save final results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(24)     
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(32)     
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(40)      
        //xMOVLPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(48)   //XMM3 should already have been stored off from before.
        //xMOVHPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(56)     

    xTARGET_jmp(finished)
    xTARGET_b32(finished2)
    xTARGET_b32(finished3)
    //save final data

    xRET_imm            (0xc)                           //pop off 10 words for the b,a,m,dir that was pushed via fast call.
    nvAssert(ilcCount < ilcMax);
    return (PFOFSTMED)(ilcData + lEntry);
}


PFOFSTMED CompileOffsetFDMatrixExtractDiscard6x6(NV_PATCH_INFO *info)
{
    return (PFOFSTMED)(0x0);
}


//OFFSET FDMATRIX ROUTINES ========================================================================
PFOFSTM CompileOffsetFDMatrix2x2(NV_PATCH_INFO *info)
{
    unsigned int loop, skip_rows, skip_cols;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 512);
    if(ilcData == 0x0) return (PFOFSTM)NULL;    
    ilcCount = 0;    ilcMax = 512;

    while(ilcCount &31)
    {
        xINT3;
    }

    //void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         m            
    //      EDX                                         a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   //b
        
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE) //#row/cols data members skipped  ECX=m->data[0][0][0];

    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)

    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_rows)
    xJZ32(0)
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))    
        xTEST_r_rm      (rEDX,rmREG(rEDX))
    xJNZ(loop)
    
    xTARGET_b32(skip_rows)

    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_cols)
    xJZ32(0)
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM1, rmREG(rXMM3))    
        xTEST_r_rm      (rEDX,rmREG(rEDX))
    xJNZ(loop)
    
    xTARGET_b32(skip_cols)

    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)

    return (PFOFSTM)(0x0);
}

PFOFSTM CompileOffsetFDMatrix4x4(NV_PATCH_INFO *info)
{
    unsigned int loop, skip_rows, skip_cols;
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 1280);
    if(ilcData == 0x0) return (PFOFSTM)NULL;    
    ilcCount = 0;    ilcMax = 1280;

    while(ilcCount &31)
    {
        xINT3;
    }
    
    //IF FDMatrix format changes this MUST be changed also.
    nvAssert(sizeof(FDMatrix) == (FDMATRIX_HEADER_SIZE + 16*16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         m            
    //      EDX                                         a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   //b
        
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=m->data[0][0][0];
    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_rows);
    xJZ32(0)
    xPUSH_r         (rEDX)                              //save this for later.
    //fetch first two rows
    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+0)     xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+16)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+24)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+32)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+40)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+48)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+56)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+0)     xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+16)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+32)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+48)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+56)                    
    
    xADD_rm_imm     (rmREG(rECX), 512)                    //skip to next two rows
    xPOP_r          (rEDX)    
    
    //fetch second two rows
    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+0)     xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+16)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+24)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+32)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+40)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+48)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+56)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+0)     xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+16)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+32)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+48)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+56)                        
    xADD_rm_imm     (rmREG(rECX), -512) //move back to beginning
    
    xTARGET_b32(skip_rows)    

    xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(0x4)   //EDX <-- b
    xTEST_r_rm      (rEDX,rmREG(rEDX))    
    xLABEL(skip_cols)   
    xJZ32(0)
    
    xPUSH_r         (rEDX)
    //fetch first two cols
    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(256)       xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(264)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(512)       xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(520)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(768)       xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(776)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+0)      xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+256)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+264)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+512)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+520)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+768)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+776)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(256)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(512)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(768)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(776)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+0)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+256)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+512)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+768)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+776)        
    
    xADD_rm_imm     (rmREG(rECX), 32)                    //skip to next two rows
    xPOP_r          (rEDX)    

    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(256)       xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(264)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(512)       xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(520)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(768)       xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(776)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+0)      xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+256)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+264)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+512)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+520)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+768)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+776)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(256)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(512)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(768)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(776)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+0)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+256)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+512)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+768)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+776)        

    xTARGET_b32(skip_cols)
    xRET_imm            (0x4)                           //pop off 4 words for the m,a,b that was pushed via fast call.
    nvAssert(ilcCount < ilcMax);
    return (PFOFSTM)(ilcData + lEntry);
}

PFOFSTM CompileOffsetFDMatrix6x6(NV_PATCH_INFO *info)
{
    unsigned int loop, outer_loop, skip_rows, skip_cols;
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 1024);
    if(ilcData == 0x0) return (PFOFSTM)NULL;    
    ilcCount = 0;    ilcMax = 1024;

    while(ilcCount &31)
    {
        xINT3;
    }
    
    //IF FDMatrix format changes this MUST be changed also.
    nvAssert(sizeof(FDMatrix) == (FDMATRIX_HEADER_SIZE + 16*16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         m            
    //      EDX                                         a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   //b
        
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=m->data[0][0][0];
    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_rows);
    xJZ32(0)
    xMOV_rm_imm     (rmREG(rEAX), 0x6)                  //how many rows to do.
    
    xLABEL(outer_loop)
        xSUB_rm_imm     (rmREG(rEAX), 0x1)
        xPUSH_r         (rEDX)                              //save this for later.
        //fetch a row
        xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
        xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(64)        xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(72)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(80)        xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(88)
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM3, rmREG(rXMM4))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xJNZ(loop)
        //save results 
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(64)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(72)
        //xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(80)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(88)    
        xADD_rm_imm     (rmREG(rECX), 256)                      //skip to next row
        xPOP_r          (rEDX)        
    xTEST_r_rm      (rEAX,rmREG(rEAX))
    xJNZ32(outer_loop)
    
    xTARGET_b32(skip_rows)    

    xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(0x4)   //EDX <-- b
    xTEST_r_rm      (rEDX,rmREG(rEDX))    
    xLABEL(skip_cols)   
    xJZ32(0)

    xMOV_rm_imm         (rmREG(rEAX), 0x6)                  //how many cols to do.    
    xLABEL(outer_loop)
        xSUB_rm_imm     (rmREG(rEAX), 0x1)    
        xPUSH_r         (rEDX)
        //fetch first two cols
        xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(256)       xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(264)
        xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(512)       xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(520)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(768)       xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(776)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(1024)      xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(1032)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(1280)      xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(1288)
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM3, rmREG(rXMM4))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xJNZ(loop)
        //save results 
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(256)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(264)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(512)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(520)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(768)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(776)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(1024)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(1032)
        //xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(1280)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(1288)    
        xADD_rm_imm     (rmREG(rECX), 16)                    //skip to next column
        xPOP_r          (rEDX)    
    xTEST_r_rm      (rEAX,rmREG(rEAX))
    xJNZ32(outer_loop)    
    xTARGET_b32(skip_cols)
    xRET_imm            (0x4)                           //pop off 4 words for the m,a,b that was pushed via fast call.
    
    nvAssert(ilcCount < ilcMax);
    return (PFOFSTM)(ilcData + lEntry);
}

//OFFSET CURVE ROUTINES ========================================================================
PFOFSC CompileOffsetCurve2x2(NV_PATCH_INFO *info)
{
    return (PFOFSC)(0x0);
}

PFOFSC CompileOffsetCurve4x4(NV_PATCH_INFO *info)
{
    unsigned int loop, finished, lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 512);
    if(ilcData == 0x0) return (PFOFSC)NULL;    
    ilcCount = 0;    ilcMax = 512;

    while(ilcCount &31)
    {
        xINT3;
    }

    nvAssert(sizeof(NV_PATCH_CURVE_INFO) == (PATCH_CURVE_HEADER_SIZE + 16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTM)(NV_PATCH_CURVE *c, int n);
    //for function above stack frame will look like 
    //      ECX                                         c            
    //      EDX                                         n             
    xTEST_r_rm  (rEDX, rmREG(rEDX))
    xLABEL(finished)
    xJZ32(0)
    xMOVLPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+0)     //4+ skips the order member of the        
    xMOVHPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+8)     //curve struct
    xMOVLPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    xMOVLPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+48)       
    xMOVHPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+56)       
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))                   
    xJNZ(loop)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+0)     //4+ skips the order member of the        
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+8)     //curve struct
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    //xMOVLPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(4+48)  //don't save off last one     
    //xMOVHPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(4+56)       
 
    xTARGET_b32(finished)
    xRET_imm            (0x0)                           
    nvAssert(ilcCount < ilcMax);

    return (PFOFSC)(ilcData + lEntry);
}

PFOFSC CompileOffsetCurve6x6(NV_PATCH_INFO *info)
{
   unsigned int loop, finished, lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 512);
    if(ilcData == 0x0) return (PFOFSC)NULL;    
    ilcCount = 0;    ilcMax = 512;

    while(ilcCount &31)
    {
        xINT3;
    }
    nvAssert(sizeof(NV_PATCH_CURVE_INFO) == (PATCH_CURVE_HEADER_SIZE + 16*4*sizeof(float)));
    xLABEL(lEntry);

    //void (FASTCALL *PFOFSTM)(NV_PATCH_CURVE *c, int n);
    //for function above stack frame will look like 
    //      ECX                                         c            
    //      EDX                                         n             
    xTEST_r_rm  (rEDX, rmREG(rEDX))
    xLABEL(finished)
    xJZ32(0)
    xMOVLPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+0)     //4+ skips the order member of the        
    xMOVHPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+8)     //curve struct
    xMOVLPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    xMOVLPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+48)       
    xMOVHPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+56)       
    xMOVLPS_r_rm    (rXMM4,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+64)       
    xMOVHPS_r_rm    (rXMM4,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+72)       
    xMOVLPS_r_rm    (rXMM5,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+80)       
    xMOVHPS_r_rm    (rXMM5,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+88)       

    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)   
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))                   
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM3, rmREG(rXMM4))                   
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))                   
    xJNZ(loop)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+0)   //4+ skips the order member of the        
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+8)   //curve struct
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(PATCH_CURVE_HEADER_SIZE+48)  
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(PATCH_CURVE_HEADER_SIZE+56)       
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM4) xOFS8(PATCH_CURVE_HEADER_SIZE+64)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM4) xOFS8(PATCH_CURVE_HEADER_SIZE+72)   
    //xMOVLPS_rm_r    (rmIND8(rECX),rXMM5) xOFS8(4+80) //don't save off last one       
    //xMOVHPS_rm_r    (rmIND8(rECX),rXMM5) xOFS8(4+88)       
 
    xTARGET_b32(finished)
    xRET_imm            (0x0)                           
    nvAssert(ilcCount < ilcMax);

    return (PFOFSC)(ilcData + lEntry);
}

//MATRIX MULTIPLY ROUTINES ========================================================================
PFMM MatrixMult2x2(NV_PATCH_INFO *info){
/*      x[1][1] = a00*b00+a01*b10;
        x[1][2] = a00*b01+a01*b11;
        x[2][1] = a10*b00+a11*b10;
        x[2][2] = a10*b01+a11*b11;      */
       return (PFMM)(NULL);
}


PFMM MatrixMult6x6(NV_PATCH_INFO *info)
{
    unsigned int lEntry = 0;

#if !defined(IS_OPENGL)
    ilcData = (unsigned char *)__NV_MALLOC(info->context, 8192);
    if(ilcData == 0x0) return (PFMM)NULL;    
    ilcCount = 0;    ilcMax = 8192;

    while(ilcCount &31){
        xINT3;
    }
    xLABEL(lEntry);

    //typedef void (FASTCALL *PFMM)(FDMatrix *dst, FDMatrix *a, FDMatrix *b);
    //for function above stack frame will look like 
    //      ECX                                             dst            
    //      EDX                                             a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   b
    
    xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(0x4)           //EAX<-b
    xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EAX=b->data[0][0][0];
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=dst->data[0][0][0];
    xADD_rm_imm     (rmREG(rEDX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EDX=a->data[0][0][0];    

//get first half row vector of a
#define GET_ROWa(a) {                                                               \
                    xMOVLPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+0));        \
                    xMOVHPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+8));        \
                    xMOVLPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+16));       \
                    xMOVHPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+24));       \
                    xMOVLPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+32));       \
                    xMOVHPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+40));       \
                   }

#define GET_ROWb(a) {                                                               \
                    xMOVLPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+48));       \
                    xMOVHPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+56));       \
                    xMOVLPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+64));       \
                    xMOVHPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+72));       \
                    xMOVLPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+80));       \
                    xMOVHPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+88));       \
                   }

//get first half row vector of a
#define GET_COLa(a) {                                                              \
                    xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+0));        \
                    xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+8));        \
                    xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+256));      \
                    xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+264));      \
                    xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+512));      \
                    xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+520));      \
                   }

//get first half row vector of a
#define GET_COLb(a) {                                                              \
                    xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+768));      \
                    xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+776));      \
                    xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+1024));     \
                    xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+1032));     \
                    xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+1280));     \
                    xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+1288));     \
                   }

#define CROSSa() {                                                               \
                    xMULPS_r_rm     (rXMM3, rmREG(rXMM0));                       \
                    xMULPS_r_rm     (rXMM4, rmREG(rXMM1));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM4));                       \
                    xMULPS_r_rm     (rXMM5, rmREG(rXMM2));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM5));                       \
                    xMOVAPS_r_rm    (rXMM6, rmREG(rXMM3));                       \
                }

#define CROSSb() {                                                               \
                    xMULPS_r_rm     (rXMM3, rmREG(rXMM0));                       \
                    xMULPS_r_rm     (rXMM4, rmREG(rXMM1));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM4));                       \
                    xMULPS_r_rm     (rXMM5, rmREG(rXMM2));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM5));                       \
                    xMOVAPS_r_rm    (rXMM7, rmREG(rXMM3));                       \
                }

#define SAVE(a,b) {                                                              \
                    xADDPS_r_rm     (rXMM6, rmREG(rXMM7));                       \
                    xMOVLPS_rm_r    (rmIND32(rECX), rXMM6) xOFS32(256*a+16*b+0); \
                    xMOVHPS_rm_r    (rmIND32(rECX), rXMM6) xOFS32(256*a+16*b+8); \
                  }    
    
    // x[0][0] = a00*b00+a01*b10+a02*b20+a03*b30+a04*b40+a05*b50;
    GET_ROWa(0)    GET_COLa(0)    CROSSa()
    GET_ROWb(0)    GET_COLb(0)    CROSSb()
    SAVE(0,0)
    // x[0][1] = a00*b01+a01*b11+a02*b21+a03*b31+a04*b41+a05*b51;
    GET_ROWa(0)    GET_COLa(1)    CROSSa()
    GET_ROWb(0)    GET_COLb(1)    CROSSb()
    SAVE(0,1)
    // x[0][2] = a00*b02+a01*b12+a02*b22+a03*b32+a04*b42+a05*b52;
    GET_ROWa(0)    GET_COLa(2)    CROSSa()
    GET_ROWb(0)    GET_COLb(2)    CROSSb()
    SAVE(0,2)
    // x[0][3] = a00*b03+a01*b13+a02*b23+a03*b33+a04*b43+a05*b53;
    GET_ROWa(0)    GET_COLa(3)    CROSSa()
    GET_ROWb(0)    GET_COLb(3)    CROSSb()
    SAVE(0,3)
    // x[0][4] = a00*b04+a01*b14+a02*b24+a03*b34+a04*b44+a05*b54;
    GET_ROWa(0)    GET_COLa(4)    CROSSa()
    GET_ROWb(0)    GET_COLb(4)    CROSSb()
    SAVE(0,4)
    // x[0][5] = a00*b05+a01*b15+a02*b25+a03*b35+a04*b45+a05*b55;
    GET_ROWa(0)    GET_COLa(5)    CROSSa()
    GET_ROWb(0)    GET_COLb(5)    CROSSb()
    SAVE(0,5)
    // x[1][0] = a10*b00+a11*b10+a12*b20+a13*b30+a14*b40+a15*b50;
    GET_ROWa(1)    GET_COLa(0)    CROSSa()
    GET_ROWb(1)    GET_COLb(0)    CROSSb()
    SAVE(1,0)
    // x[1][1] = a10*b01+a11*b11+a12*b21+a13*b31+a14*b41+a15*b51;
    GET_ROWa(1)    GET_COLa(1)    CROSSa()
    GET_ROWb(1)    GET_COLb(1)    CROSSb()
    SAVE(1,1)
    // x[1][2] = a10*b02+a11*b12+a12*b22+a13*b32+a14*b42+a15*b52;
    GET_ROWa(1)    GET_COLa(2)    CROSSa()
    GET_ROWb(1)    GET_COLb(2)    CROSSb()
    SAVE(1,2)
    // x[1][3] = a10*b03+a11*b13+a12*b23+a13*b33+a14*b43+a15*b53;
    GET_ROWa(1)    GET_COLa(3)    CROSSa()
    GET_ROWb(1)    GET_COLb(3)    CROSSb()
    SAVE(1,3)
    // x[1][4] = a10*b04+a11*b14+a12*b24+a13*b34+a14*b44+a15*b54;
    GET_ROWa(1)    GET_COLa(4)    CROSSa()
    GET_ROWb(1)    GET_COLb(4)    CROSSb()
    SAVE(1,4)
    // x[1][5] = a10*b05+a11*b15+a12*b25+a13*b35+a14*b45+a15*b55;*/
    GET_ROWa(1)    GET_COLa(5)    CROSSa()
    GET_ROWb(1)    GET_COLb(5)    CROSSb()
    SAVE(1,5)

    // x[2][0] = a20*b00+a21*b10+a22*b20+a23*b30+a24*b40+a25*b50;
    GET_ROWa(2)    GET_COLa(0)    CROSSa()
    GET_ROWb(2)    GET_COLb(0)    CROSSb()
    SAVE(2,0)
    // x[2][1] = a20*b01+a21*b11+a22*b21+a23*b31+a24*b41+a25*b51;
    GET_ROWa(2)    GET_COLa(1)    CROSSa()
    GET_ROWb(2)    GET_COLb(1)    CROSSb()
    SAVE(2,1)
    // x[2][2] = a20*b02+a21*b12+a22*b22+a23*b32+a24*b42+a25*b52;
    GET_ROWa(2)    GET_COLa(2)    CROSSa()
    GET_ROWb(2)    GET_COLb(2)    CROSSb()
    SAVE(2,2)
    // x[2][3] = a20*b03+a21*b13+a22*b23+a23*b33+a24*b43+a25*b53;
    GET_ROWa(2)    GET_COLa(3)    CROSSa()
    GET_ROWb(2)    GET_COLb(3)    CROSSb()
    SAVE(2,3)
    // x[2][4] = a20*b04+a21*b14+a22*b24+a23*b34+a24*b44+a25*b54;
    GET_ROWa(2)    GET_COLa(4)    CROSSa()
    GET_ROWb(2)    GET_COLb(4)    CROSSb()
    SAVE(2,4)
    // x[2][5] = a20*b05+a21*b15+a22*b25+a23*b35+a24*b45+a25*b55;
    GET_ROWa(2)    GET_COLa(5)    CROSSa()
    GET_ROWb(2)    GET_COLb(5)    CROSSb()
    SAVE(2,5)

    // x[3][0] = a30*b00+a31*b10+a32*b20+a33*b30+a34*b40+a35*b50;
    GET_ROWa(3)    GET_COLa(0)    CROSSa()
    GET_ROWb(3)    GET_COLb(0)    CROSSb()
    SAVE(3,0)
    // x[3][1] = a30*b01+a31*b11+a32*b21+a33*b31+a34*b41+a35*b51;
    GET_ROWa(3)    GET_COLa(1)    CROSSa()
    GET_ROWb(3)    GET_COLb(1)    CROSSb()
    SAVE(3,1)
    // x[3][2] = a30*b02+a31*b12+a32*b22+a33*b32+a34*b42+a35*b52;
    GET_ROWa(3)    GET_COLa(2)    CROSSa()
    GET_ROWb(3)    GET_COLb(2)    CROSSb()
    SAVE(3,2)
    // x[3][3] = a30*b03+a31*b13+a32*b23+a33*b33+a34*b43+a35*b53;
    GET_ROWa(3)    GET_COLa(3)    CROSSa()
    GET_ROWb(3)    GET_COLb(3)    CROSSb()
    SAVE(3,3)
    // x[3][4] = a30*b04+a31*b14+a32*b24+a33*b34+a34*b44+a35*b54;
    GET_ROWa(3)    GET_COLa(4)    CROSSa()
    GET_ROWb(3)    GET_COLb(4)    CROSSb()
    SAVE(3,4)
    // x[3][5] = a30*b05+a31*b15+a32*b25+a33*b35+a34*b45+a35*b55;
    GET_ROWa(3)    GET_COLa(5)    CROSSa()
    GET_ROWb(3)    GET_COLb(5)    CROSSb()
    SAVE(3,5)

    // x[4][0] = a40*b00+a41*b10+a42*b20+a43*b30+a44*b40+a45*b50;
    GET_ROWa(4)    GET_COLa(0)    CROSSa()
    GET_ROWb(4)    GET_COLb(0)    CROSSb()
    SAVE(4,0)
    // x[4][1] = a40*b01+a41*b11+a42*b21+a43*b31+a44*b41+a45*b51;
    GET_ROWa(4)    GET_COLa(1)    CROSSa()
    GET_ROWb(4)    GET_COLb(1)    CROSSb()
    SAVE(4,1)
    // x[4][2] = a40*b02+a41*b12+a42*b22+a43*b32+a44*b42+a45*b52;
    GET_ROWa(4)    GET_COLa(2)    CROSSa()
    GET_ROWb(4)    GET_COLb(2)    CROSSb()
    SAVE(4,2)
    // x[4][3] = a40*b03+a41*b13+a42*b23+a43*b33+a44*b43+a45*b53;
    GET_ROWa(4)    GET_COLa(3)    CROSSa()
    GET_ROWb(4)    GET_COLb(3)    CROSSb()
    SAVE(4,3)
    // x[4][4] = a40*b04+a41*b14+a42*b24+a43*b34+a44*b44+a45*b54;
    GET_ROWa(4)    GET_COLa(4)    CROSSa()
    GET_ROWb(4)    GET_COLb(4)    CROSSb()
    SAVE(4,4)
    // x[4][5] = a40*b05+a41*b15+a42*b25+a43*b35+a44*b45+a45*b55;
    GET_ROWa(4)    GET_COLa(5)    CROSSa()
    GET_ROWb(4)    GET_COLb(5)    CROSSb()
    SAVE(4,5)

    // x[5][0] = a50*b00+a51*b10+a52*b20+a53*b30+a54*b40+a55*b50;
    GET_ROWa(5)    GET_COLa(0)    CROSSa()
    GET_ROWb(5)    GET_COLb(0)    CROSSb()
    SAVE(5,0)
    // x[5][1] = a50*b01+a51*b11+a52*b21+a53*b31+a54*b41+a55*b51;
    GET_ROWa(5)    GET_COLa(1)    CROSSa()
    GET_ROWb(5)    GET_COLb(1)    CROSSb()
    SAVE(5,1)
    // x[5][2] = a50*b02+a51*b12+a52*b22+a53*b32+a54*b42+a55*b52;
    GET_ROWa(5)    GET_COLa(2)    CROSSa()
    GET_ROWb(5)    GET_COLb(2)    CROSSb()
    SAVE(5,2)
    // x[5][3] = a50*b03+a51*b13+a52*b23+a53*b33+a54*b43+a55*b53;
    GET_ROWa(5)    GET_COLa(3)    CROSSa()
    GET_ROWb(5)    GET_COLb(3)    CROSSb()
    SAVE(5,3)
    // x[5][4] = a50*b04+a51*b14+a52*b24+a53*b34+a54*b44+a55*b54;
    GET_ROWa(5)    GET_COLa(4)    CROSSa()
    GET_ROWb(5)    GET_COLb(4)    CROSSb()
    SAVE(5,4)
    // x[5][5] = a50*b05+a51*b15+a52*b25+a53*b35+a54*b45+a55*b55;
    GET_ROWa(5)    GET_COLa(5)    CROSSa()
    GET_ROWb(5)    GET_COLb(5)    CROSSb()
    SAVE(5,5)
#endif

    xRET_imm            (0x4)                           
    nvAssert(ilcCount < ilcMax);

    return (PFMM)(ilcData + lEntry);

#undef GET_COLa
#undef GET_ROWa
#undef CROSSa
#undef GET_COLb
#undef GET_ROWb
#undef CROSSb
#undef SAVE

}

PFMM MatrixMult4x4(NV_PATCH_INFO *info){
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 2048);
    if(ilcData == 0x0) return (PFMM)NULL;    
    ilcCount = 0;    ilcMax = 2048;

    while(ilcCount &31){
        xINT3;
    }
    xLABEL(lEntry);

    //typedef void (FASTCALL *PFMM)(FDMatrix *dst, FDMatrix *a, FDMatrix *b);
    //for function above stack frame will look like 
    //      ECX                                             dst            
    //      EDX                                             a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   b
    
    xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(0x4)           //EAX<-b
    xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EAX=b->data[0][0][0];
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=dst->data[0][0][0];
    xADD_rm_imm     (rmREG(rEDX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EDX=a->data[0][0][0];    
//get first column vector of b
#define GET_COL(a) {                                                               \
                    xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+0));        \
                    xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+8));        \
                    xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+256));      \
                    xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+264));      \
                    xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32((16*a+512));      \
                    xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32((16*a+520));      \
                    xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32((16*a+768));      \
                    xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32((16*a+776));      \
                   }

//get first row vector of a
#define GET_ROW(a) {                                                                \
                    xMOVLPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+0));        \
                    xMOVHPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+8));        \
                    xMOVLPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+16));       \
                    xMOVHPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+24));       \
                    xMOVLPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+32));       \
                    xMOVHPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+40));       \
                    xMOVLPS_r_rm    (rXMM3,rmIND32(rEDX)) xOFS32((256*a+48));       \
                    xMOVHPS_r_rm    (rXMM3,rmIND32(rEDX)) xOFS32((256*a+56));       \
                   }

#define CROSS() {                                                                \
                    xMULPS_r_rm     (rXMM4, rmREG(rXMM0));                       \
                    xMULPS_r_rm     (rXMM5, rmREG(rXMM1));                       \
                    xADDPS_r_rm     (rXMM4, rmREG(rXMM5));                       \
                    xMULPS_r_rm     (rXMM6, rmREG(rXMM2));                       \
                    xADDPS_r_rm     (rXMM4, rmREG(rXMM6));                       \
                    xMULPS_r_rm     (rXMM7, rmREG(rXMM3));                       \
                    xADDPS_r_rm     (rXMM4, rmREG(rXMM7));                       \
                }

#define SAVE(a,b) {                                                              \
                    xMOVLPS_rm_r    (rmIND32(rECX), rXMM4) xOFS32(256*a+16*b+0); \
                    xMOVHPS_rm_r    (rmIND32(rECX), rXMM4) xOFS32(256*a+16*b+8); \
                  }    

    GET_ROW(0)
    //  x[0][0] = a00*b00+a01*b10+a02*b20+a03*b30;
    GET_COL(0)
    CROSS()
    SAVE(0,0)
    //  x[0][1] = a00*b01+a01*b11+a02*b21+a03*b31;    
    GET_COL(1)
    CROSS()
    SAVE(0,1)
    //  x[0][2] = a00*b02+a01*b12+a02*b22+a03*b32;
    GET_COL(2)
    CROSS()
    SAVE(0,2)
    //  x[0][3] = a00*b03+a01*b13+a02*b23+a03*b33;
    GET_COL(3)
    CROSS()
    SAVE(0,3)

    GET_ROW(1)
    //  x[1][0] = a10*b00+a11*b10+a12*b20+a13*b30;
    GET_COL(0)
    CROSS()
    SAVE(1,0)
    //  x[1][1] = a10*b01+a11*b11+a12*b21+a13*b31;
    GET_COL(1)
    CROSS()
    SAVE(1,1)
    //  x[1][2] = a10*b02+a11*b12+a12*b22+a13*b32;
    GET_COL(2)
    CROSS()
    SAVE(1,2)
    //  x[1][3] = a10*b03+a11*b13+a12*b23+a13*b33;
    GET_COL(3)
    CROSS()
    SAVE(1,3)

    GET_ROW(2)
    //  x[2][0] = a20*b00+a21*b10+a22*b20+a23*b30;
    GET_COL(0)
    CROSS()
    SAVE(2,0)
    //  x[2][1] = a20*b01+a21*b11+a22*b21+a23*b31;
    GET_COL(1)
    CROSS()
    SAVE(2,1)
    //  x[2][2] = a20*b02+a21*b12+a22*b22+a23*b32;
    GET_COL(2)
    CROSS()
    SAVE(2,2)
    //  x[2][3] = a20*b03+a21*b13+a22*b23+a23*b33;
    GET_COL(3)
    CROSS()
    SAVE(2,3)

    GET_ROW(3)
    //  x[3][0] = a30*b00+a31*b10+a32*b20+a33*b30;
    GET_COL(0)
    CROSS()
    SAVE(3,0)
    //  x[3][1] = a30*b01+a31*b11+a32*b21+a33*b31;
    GET_COL(1)
    CROSS()
    SAVE(3,1)
    //  x[3][2] = a30*b02+a31*b12+a32*b22+a33*b32;
    GET_COL(2)
    CROSS()
    SAVE(3,2)
    //  x[3][3] = a30*b03+a31*b13+a32*b23+a33*b33;
    GET_COL(3)
    CROSS()
    SAVE(3,3)
    
    xRET_imm            (0x4)                           
    assert(ilcCount < ilcMax);

    return (PFMM)(ilcData + lEntry);
#undef GET_COL
#undef GET_ROW
#undef SAVE
#undef CROSS
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvPatchConsts.c ===
/*
 * nvPatchConsts.c
 *
 * Tables of constants used for curved surfaces.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 */

#if defined(_MSC_VER)
# pragma warning (disable:4305)  /* Disable VC++ 5.0 "truncation from 'const double' to 'float' */
#endif

/*** Patch interface ***/
#include "nvPatchInterface.h"

// Bezier basis matrices
static float bezBasis1[1][1] = {
    {1},
};

static float bezBasis2[2][2] = {
    {-1, 1},
    { 1, 0},
};

static float bezBasis3[3][3] = {
    { 1, -2, 1},
    {-2,  2, 0},
    { 1,  0, 0},
};

static float bezBasis4[4][4] = {
    {-1,  3, -3, 1},
    { 3, -6,  3, 0},
    {-3,  3,  0, 0},
    { 1,  0,  0, 0},
};

static float bezBasis5[5][5] = {
    { 1,  -4,   6, -4, 1},
    {-4,  12, -12,  4, 0},
    { 6, -12,   6,  0, 0},
    {-4,   4,   0,  0, 0},
    { 1,   0,   0,  0, 0},
};

static float bezBasis6[6][6] = {
    { -1,   5, -10,  10, -5, 1},
    {  5, -20,  30, -20,  5, 0},
    {-10,  30, -30,  10,  0, 0},
    { 10, -20,  10,   0,  0, 0},
    { -5,   5,   0,   0,  0, 0},
    {  1,   0,   0,   0,  0, 0},
};

static float bezBasis7[7][7] = {
    {  1,  -6,  15, -20,  15, -6, 1},
    { -6,  30, -60,  60, -30,  6, 0},
    { 15, -60,  90, -60,  15,  0, 0},
    {-20,  60, -60,  20,   0,  0, 0},
    { 15, -30,  15,   0,   0,  0, 0},
    { -6,   6,   0,   0,   0,  0, 0},
    {  1,   0,   0,   0,   0,  0, 0},
};

static float bezBasis8[8][8] = {
    { -1,    7,  -21,   35,  -35,  21, -7, 1},
    {  7,  -42,  105, -140,  105, -42,  7, 0},
    {-21,  105, -210,  210, -105,  21,  0, 0},
    { 35, -140,  210, -140,   35,   0,  0, 0},
    {-35,  105, -105,   35,    0,   0,  0, 0},
    { 21,  -42,   21,    0,    0,   0,  0, 0},
    { -7,    7,    0,    0,    0,   0,  0, 0},
    {  1,    0,    0,    0,    0,   0,  0, 0},
};

static float bezBasis9[9][9] = {
    {  1,   -8,   28,  -56,   70,  -56,  28, -8, 1},
    { -8,   56, -168,  280, -280,  168, -56,  8, 0},
    { 28, -168,  420, -560,  420, -168,  28,  0, 0},
    {-56,  280, -560,  560, -280,   56,   0,  0, 0},
    { 70, -280,  420, -280,   70,    0,   0,  0, 0},
    {-56,  168, -168,   56,    0,    0,   0,  0, 0},
    { 28,  -56,   28,    0,    0,    0,   0,  0, 0},
    { -8,    8,    0,    0,    0,    0,   0,  0, 0},
    {  1,    0,    0,    0,    0,    0,   0,  0, 0},
};

static float bezBasis10[10][10] = {
    {  -1,    9,   -36,    84,  -126,  126,  -84,  36, -9, 1},
    {   9,  -72,   252,  -504,   630, -504,  252, -72,  9, 0},
    { -36,  252,  -756,  1260, -1260,  756, -252,  36,  0, 0},
    {  84, -504,  1260, -1680,  1260, -504,   84,   0,  0, 0},
    {-126,  630, -1260,  1260,  -630,  126,    0,   0,  0, 0},
    { 126, -504,   756,  -504,   126,    0,    0,   0,  0, 0},
    { -84,  252,  -252,    84,     0,    0,    0,   0,  0, 0},
    {  36,  -72,    36,     0,     0,    0,    0,   0,  0, 0},
    {  -9,    9,     0,     0,     0,    0,    0,   0,  0, 0},
    {   1,    0,     0,     0,     0,    0,    0,   0,  0, 0},
};

static float bezBasis11[11][11] = {
    {1, -10, 45, -120, 210, -252, 210, -120, 45, -10, 1},
    {-10, 90, -360, 840, -1260, 1260, -840, 360, -90, 10, 0},
    {45, -360, 1260, -2520, 3150, -2520, 1260, -360, 45, 0, 0},
    {-120, 840, -2520, 4200, -4200, 2520, -840, 120, 0, 0, 0},
    {210, -1260, 3150, -4200, 3150, -1260, 210, 0, 0, 0, 0},
    {-252, 1260, -2520, 2520, -1260, 252, 0, 0, 0, 0, 0},
    {210, -840, 1260, -840, 210, 0, 0, 0, 0, 0, 0},
    {-120, 360, -360, 120, 0, 0, 0, 0, 0, 0, 0},
    {45, -90, 45, 0, 0, 0, 0, 0, 0, 0, 0},
    {-10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis12[12][12] = {
    {-1, 11, -55, 165, -330, 462, -462, 330, -165, 55, -11, 1},
    {11, -110, 495, -1320, 2310, -2772, 2310, -1320, 495, -110, 11, 0},
    {-55, 495, -1980, 4620, -6930, 6930, -4620, 1980, -495, 55, 0, 0},
    {165, -1320, 4620, -9240, 11550, -9240, 4620, -1320, 165, 0, 0, 0},
    {-330, 2310, -6930, 11550, -11550, 6930, -2310, 330, 0, 0, 0, 0},
    {462, -2772, 6930, -9240, 6930, -2772, 462, 0, 0, 0, 0, 0},
    {-462, 2310, -4620, 4620, -2310, 462, 0, 0, 0, 0, 0, 0},
    {330, -1320, 1980, -1320, 330, 0, 0, 0, 0, 0, 0, 0},
    {-165, 495, -495, 165, 0, 0, 0, 0, 0, 0, 0, 0},
    {55, -110, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis13[13][13] = {
    {1, -12, 66, -220, 495, -792, 924, -792, 495, -220, 66, -12, 1},
    {-12, 132, -660, 1980, -3960, 5544, -5544, 3960, -1980, 660, -132, 12, 0},
    {66, -660, 2970, -7920, 13860, -16632, 13860, -7920, 2970, -660, 66, 0, 0},
    {-220, 1980, -7920, 18480, -27720, 27720, -18480, 7920, -1980, 220, 0, 0, 0},
    {495, -3960, 13860, -27720, 34650, -27720, 13860, -3960, 495, 0, 0, 0, 0},
    {-792, 5544, -16632, 27720, -27720, 16632, -5544, 792, 0, 0, 0, 0, 0},
    {924, -5544, 13860, -18480, 13860, -5544, 924, 0, 0, 0, 0, 0, 0},
    {-792, 3960, -7920, 7920, -3960, 792, 0, 0, 0, 0, 0, 0, 0},
    {495, -1980, 2970, -1980, 495, 0, 0, 0, 0, 0, 0, 0, 0},
    {-220, 660, -660, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {66, -132, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis14[14][14] = {
    {   -1,     13,    -78,    286,   -715,   1287,  -1716,   1716,  -1287,   715, -286,   78, -13, 1},
    {   13,   -156,    858,  -2860,   6435, -10296,  12012, -10296,   6435, -2860,  858, -156,  13, 0},
    {  -78,    858,  -4290,  12870, -25740,  36036, -36036,  25740, -12870,  4290, -858,   78,   0, 0},
    {  286,  -2860,  12870, -34320,  60060, -72072,  60060, -34320,  12870, -2860,  286,    0,   0, 0},
    { -715,   6435, -25740,  60060, -90090,  90090, -60060,  25740,  -6435,   715,    0,    0,   0, 0},
    { 1287, -10296,  36036, -72072,  90090, -72072,  36036, -10296,   1287,     0,    0,    0,   0, 0},
    {-1716,  12012, -36036,  60060, -60060,  36036, -12012,   1716,      0,     0,    0,    0,   0, 0},
    { 1716, -10296,  25740, -34320,  25740, -10296,   1716,      0,      0,     0,    0,    0,   0, 0},
    {-1287,   6435, -12870,  12870,  -6435,   1287,      0,      0,      0,     0,    0,    0,   0, 0},
    {  715,  -2860,   4290,  -2860,    715,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    { -286,    858,   -858,    286,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    {   78,   -156,     78,      0,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    {  -13,     13,      0,      0,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    {    1,      0,      0,      0,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
};

static float bezBasis15[15][15] = {
    {    1, -14, 91, -364, 1001, -2002, 3003, -3432, 3003, -2002, 1001, -364, 91, -14, 1},
    {  -14, 182, -1092, 4004, -10010, 18018, -24024, 24024, -18018, 10010, -4004, 1092, -182, 14, 0},
    {   91, -1092, 6006, -20020, 45045, -72072, 84084, -72072, 45045, -20020, 6006, -1092, 91, 0, 0},
    { -364, 4004, -20020, 60060, -120120, 168168, -168168, 120120, -60060, 20020, -4004, 364, 0, 0, 0},
    { 1001, -10010, 45045, -120120, 210210, -252252, 210210, -120120, 45045, -10010, 1001, 0, 0, 0, 0},
    {-2002, 18018, -72072, 168168, -252252, 252252, -168168, 72072, -18018, 2002, 0, 0, 0, 0, 0},
    { 3003, -24024, 84084, -168168, 210210, -168168, 84084, -24024, 3003, 0, 0, 0, 0, 0, 0},
    {-3432, 24024, -72072, 120120, -120120, 72072, -24024, 3432, 0, 0, 0, 0, 0, 0, 0},
    { 3003, -18018, 45045, -60060, 45045, -18018, 3003, 0, 0, 0, 0, 0, 0, 0, 0},
    {-2002,  10010, -20020, 20020, -10010, 2002, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    { 1001,  -4004,   6006, -4004, 1001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    { -364,   1092,  -1092, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {   91,   -182,     91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {  -14,     14,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {    1,      0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis16[16][16] = {
    {-1, 15, -105, 455, -1365, 3003, -5005, 6435, -6435, 5005, -3003, 1365, -455, 105, -15, 1},
    {15, -210, 1365, -5460, 15015, -30030, 45045, -51480, 45045, -30030, 15015, -5460, 1365, -210, 15, 0},
    {-105, 1365, -8190, 30030, -75075, 135135, -180180, 180180, -135135, 75075, -30030, 8190, -1365, 105, 0, 0},
    {455, -5460, 30030, -100100, 225225, -360360, 420420, -360360, 225225, -100100, 30030, -5460, 455, 0, 0, 0},
    {-1365, 15015, -75075, 225225, -450450, 630630, -630630, 450450, -225225, 75075, -15015, 1365, 0, 0, 0, 0},
    {3003, -30030, 135135, -360360, 630630, -756756, 630630, -360360, 135135, -30030, 3003, 0, 0, 0, 0, 0},
    {-5005, 45045, -180180, 420420, -630630, 630630, -420420, 180180, -45045, 5005, 0, 0, 0, 0, 0, 0},
    {6435, -51480, 180180, -360360, 450450, -360360, 180180, -51480, 6435, 0, 0, 0, 0, 0, 0, 0},
    {-6435, 45045, -135135, 225225, -225225, 135135, -45045, 6435, 0, 0, 0, 0, 0, 0, 0, 0},
    {5005, -30030, 75075, -100100, 75075, -30030, 5005, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-3003, 15015, -30030, 30030, -15015, 3003, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1365, -5460, 8190, -5460, 1365, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-455, 1365, -1365, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {105, -210, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

static float catmullRomBasis4[4][4] = {
    {-1.0f/2,  3.0f/2, -3.0f/2,  1.0f/2}, 
    {   1.0f, -5.0f/2,    2.0f, -1.0f/2}, 
    {-1.0f/2,    0.0f,  1.0f/2,    0.0f}, 
    {   0.0f,    1.0f,    0.0f,    0.0f}
};

//divisors on bspline basis are factorial(order)
static float bsplineBasis1[1][1] = {
    {1},
};

static float bsplineBasis2[2][2] = {
    {-1.0f, 1.0f},
    { 1.0f, 0.0f}
};

static float bsplineBasis3[3][3] = {
    { 1.0f/2, -2.0f/2, 1.0f/2}, 
    {-2.0f/2,  2.0f/2, 0.0f/2}, 
    { 1.0f/2,  1.0f/2, 0.0f/2}
};

static float bsplineBasis4[4][4] = {
    {-1.0f/6,  3.0f/6, -3.0f/6, 1.0f/6}, 
    { 3.0f/6, -6.0f/6,  3.0f/6, 0.0f/6}, 
    {-3.0f/6,  0.0f/6,  3.0f/6, 0.0f/6},  
    { 1.0f/6,  4.0f/6,  1.0f/6, 0.0f/6}
};

static float bsplineBasis5[5][5] = {
    { 1.0f/24,  -4.0f/24,   6.0f/24, -4.0f/24, 1.0f/24}, 
    {-4.0f/24,  12.0f/24, -12.0f/24,  4.0f/24, 0.0f/24}, 
    { 6.0f/24,  -6.0f/24,  -6.0f/24,  6.0f/24, 0.0f/24}, 
    {-4.0f/24, -12.0f/24,  12.0f/24,  4.0f/24, 0.0f/24}, 
    { 1.0f/24,  11.0f/24,  11.0f/24,  1.0f/24, 0.0f/24}
};

static float bsplineBasis6[6][6] = {
    { -1.0f/120,   5.0f/120, -10.0f/120,  10.0f/120, -5.0f/120, 1.0f/120}, 
    {  5.0f/120, -20.0f/120,  30.0f/120, -20.0f/120,  5.0f/120, 0.0f/120}, 
    {-10.0f/120,  20.0f/120,   0.0f/120,  20.0f/120, 10.0f/120, 0.0f/120}, 
    { -5.0f/120, -50.0f/120,   0.0f/120,  50.0f/120,  5.0f/120, 0.0f/120}, 
    {  1.0f/120,  26.0f/120,  66.0f/120,  26.0f/120,  1.0f/120, 0.0f/120}
};

static float bsplineBasis7[7][7] = {
    {  1.0f/720,   -6.0f/720,   15.0f/720,  -20.0f/720,  15.0f/720, -6.0f/720, 1.0f/720}, 
    { -6.0f/720,   30.0f/720,  -60.0f/720,   60.0f/720, -30.0f/720,  6.0f/720, 0.0f/720}, 
    { 15.0f/720,  -45.0f/720,   30.0f/720,   30.0f/720, -45.0f/720, 15.0f/720, 0.0f/720}, 
    {-20.0f/720,  -20.0f/720,  160.0f/720, -160.0f/720,  20.0f/720, 20.0f/720, 0.0f/720}, 
    { 15.0f/720,  135.0f/720, -150.0f/720, -150.0f/720, 135.0f/720, 15.0f/720, 0.0f/720}, 
    { -6.0f/720, -150.0f/720, -240.0f/720,  240.0f/720, 150.0f/720,  6.0f/720, 0.0f/720}, 
    {  1.0f/720,   57.0f/720,  302.0f/720,  302.0f/720,  57.0f/720,  1.0f/720, 0.0f/720}
};
 
static float bsplineBasis8[8][8] = {
    { -1.0f/5040,    7.0f/5040,   -21.0f/5040,    35.0f/5040,  -35.0f/5040,  21.0f/5040,  -7.0f/5040,  1.0f/5040}, 
    {  7.0f/5040,  -42.0f/5040,   105.0f/5040,  -140.0f/5040,  105.0f/5040, -42.0f/5040,   7.0f/5040,  0.0f/5040}, 
    {-21.0f/5040,   84.0f/5040,  -105.0f/5040,     0.0f/5040,  105.0f/5040, -84.0f/5040,  21.0f/5040,  0.0f/5040}, 
    { 35.0f/5040,    0.0f/5040,  -315.0f/5040,   560.0f/5040, -315.0f/5040,   0.0f/5040,  35.0f/5040,  0.0f/5040}, 
    {-35.0f/5040, -280.0f/5040,   665.0f/5040,     0.0f/5040, -665.0f/5040, 280.0f/5040,  35.0f/5040,  0.0f/5040}, 
    { 21.0f/5040,  504.0f/5040,   315.0f/5040, -1680.0f/5040,  315.0f/5040, 504.0f/5040,  21.0f/5040,  0.0f/5040}, 
    { -7.0f/5040, -392.0f/5040, -1715.0f/5040,     0.0f/5040, 1715.0f/5040, 392.0f/5040,   7.0f/5040,  0.0f/5040}, 
    {  1.0f/5040,  120.0f/5040,  1191.0f/5040,  2416.0f/5040, 1191.0f/5040, 120.0f/5040,   1.0f/5040,  0.0f/5040}
};

static float bsplineBasis9[9][9] = {
    {  1.0f/362880,    -8.0f/362880,    28.0f/362880,   -56.0f/362880,    70.0f/362880,   -56.0f/362880,   28.0f/362880, -8.0f/362880, 1.0f/362880}, 
    { -8.0f/362880,    56.0f/362880,  -168.0f/362880,   280.0f/362880,  -280.0f/362880,   168.0f/362880,  -56.0f/362880,  8.0f/362880, 0.0f/362880}, 
    { 28.0f/362880,  -140.0f/362880,   252.0f/362880,  -140.0f/362880,  -140.0f/362880,   252.0f/362880, -140.0f/362880, 28.0f/362880, 0.0f/362880}, 
    {-56.0f/362880,    56.0f/362880,   504.0f/362880, -1400.0f/362880,  1400.0f/362880,  -504.0f/362880,  -56.0f/362880, 56.0f/362880, 0.0f/362880}, 
    { 70.0f/362880,   490.0f/362880, -1890.0f/362880,  1330.0f/362880,  1330.0f/362880, -1890.0f/362880,  490.0f/362880, 70.0f/362880, 0.0f/362880}, 
    {-56.0f/362880, -1288.0f/362880,   504.0f/362880,  5320.0f/362880, -5320.0f/362880,  -504.0f/362880, 1288.0f/362880, 56.0f/362880, 0.0f/362880}, 
    { 28.0f/362880,  1540.0f/362880,  5292.0f/362880, -6860.0f/362880, -6860.0f/362880,  5292.0f/362880, 1540.0f/362880, 28.0f/362880, 0.0f/362880}, 
    { -8.0f/362880,  -952.0f/362880, -8568.0f/362880, -9800.0f/362880,  9800.0f/362880,  8568.0f/362880,  952.0f/362880,  8.0f/362880, 0.0f/362880}, 
    {  1.0f/362880,   247.0f/362880,  4293.0f/362880, 15619.0f/362880, 15619.0f/362880,  4293.0f/362880,  247.0f/362880,  1.0f/362880, 0.0f/362880}
};

static float bsplineBasis10[10][10] = {
    {  -1.0f/3628800,     9.0f/3628800,    -36.0f/3628800,      84.0f/3628800,   -126.0f/3628800,    126.0f/3628800,   -84.0f/3628800,   36.0f/3628800,  -9.0f/3628800, 1.0f/3628800}, 
    {   9.0f/3628800,   -72.0f/3628800,    252.0f/3628800,    -504.0f/3628800,    630.0f/3628800,   -504.0f/3628800,   252.0f/3628800,  -72.0f/3628800,   9.0f/3628800, 0.0f/3628800}, 
    { -36.0f/3628800,   216.0f/3628800,   -504.0f/3628800,     504.0f/3628800,      0.0f/3628800,   -504.0f/3628800,   504.0f/3628800, -216.0f/3628800,  36.0f/3628800, 0.0f/3628800}, 
    {  84.0f/3628800,  -168.0f/3628800,   -672.0f/3628800,    2856.0f/3628800,  -4200.0f/3628800,   2856.0f/3628800,  -672.0f/3628800, -168.0f/3628800,  84.0f/3628800, 0.0f/3628800}, 
    {-126.0f/3628800,  -756.0f/3628800,   4284.0f/3628800,   -5796.0f/3628800,      0.0f/3628800,   5796.0f/3628800, -4284.0f/3628800,  756.0f/3628800, 126.0f/3628800, 0.0f/3628800}, 
    { 126.0f/3628800,  2772.0f/3628800,  -4032.0f/3628800,  -10836.0f/3628800,  23940.0f/3628800, -10836.0f/3628800, -4032.0f/3628800, 2772.0f/3628800, 126.0f/3628800, 0.0f/3628800}, 
    { -84.0f/3628800, -4536.0f/3628800, -11256.0f/3628800,   36456.0f/3628800,      0.0f/3628800, -36456.0f/3628800, 11256.0f/3628800, 4536.0f/3628800,  84.0f/3628800, 0.0f/3628800}, 
    {  36.0f/3628800,  4248.0f/3628800,  34272.0f/3628800,    5544.0f/3628800, -88200.0f/3628800,   5544.0f/3628800, 34272.0f/3628800, 4248.0f/3628800,  36.0f/3628800, 0.0f/3628800}, 
    {  -9.0f/3628800, -2214.0f/3628800, -36414.0f/3628800, -101934.0f/3628800,      0.0f/3628800, 101934.0f/3628800, 36414.0f/3628800, 2214.0f/3628800,   9.0f/3628800, 0.0f/3628800}, 
    {   1.0f/3628800,   502.0f/3628800,  14608.0f/3628800,   88234.0f/3628800, 156190.0f/3628800,  88234.0f/3628800, 14608.0f/3628800,  502.0f/3628800,   1.0f/3628800, 0.0f/3628800}
};

static float bsplineBasis11[11][11] = {
    {   1.0f/39916800,    -10.0f/39916800,      45.0f/39916800,    -120.0f/39916800,     210.0f/39916800,    -252.0f/39916800,     210.0f/39916800,   -120.0f/39916800,    45.0f/39916800, -10.0f/39916800, 1.0f/39916800}, 
    { -10.0f/39916800,     90.0f/39916800,    -360.0f/39916800,     840.0f/39916800,   -1260.0f/39916800,    1260.0f/39916800,    -840.0f/39916800,    360.0f/39916800,   -90.0f/39916800,  10.0f/39916800, 0.0f/39916800}, 
    {  45.0f/39916800,   -315.0f/39916800,     900.0f/39916800,   -1260.0f/39916800,     630.0f/39916800,     630.0f/39916800,   -1260.0f/39916800,    900.0f/39916800,  -315.0f/39916800,  45.0f/39916800, 0.0f/39916800}, 
    {-120.0f/39916800,    360.0f/39916800,     720.0f/39916800,   -5040.0f/39916800,   10080.0f/39916800,  -10080.0f/39916800,    5040.0f/39916800,   -720.0f/39916800,  -360.0f/39916800, 120.0f/39916800, 0.0f/39916800}, 
    { 210.0f/39916800,   1050.0f/39916800,   -8400.0f/39916800,   16800.0f/39916800,   -9660.0f/39916800,   -9660.0f/39916800,   16800.0f/39916800,  -8400.0f/39916800,  1050.0f/39916800, 210.0f/39916800, 0.0f/39916800}, 
    {-252.0f/39916800,  -5292.0f/39916800,   13608.0f/39916800,   13608.0f/39916800,  -69552.0f/39916800,   69552.0f/39916800,  -13608.0f/39916800, -13608.0f/39916800,  5292.0f/39916800, 252.0f/39916800, 0.0f/39916800}, 
    { 210.0f/39916800,  11130.0f/39916800,   16800.0f/39916800, -119280.0f/39916800,   91140.0f/39916800,   91140.0f/39916800, -119280.0f/39916800,  16800.0f/39916800, 11130.0f/39916800, 210.0f/39916800, 0.0f/39916800}, 
    {-120.0f/39916800, -14040.0f/39916800, -100080.0f/39916800,   95760.0f/39916800,  312480.0f/39916800, -312480.0f/39916800,  -95760.0f/39916800, 100080.0f/39916800, 14040.0f/39916800, 120.0f/39916800, 0.0f/39916800}, 
    {  45.0f/39916800,  11025.0f/39916800,  171000.0f/39916800,  327600.0f/39916800, -509670.0f/39916800, -509670.0f/39916800,  327600.0f/39916800, 171000.0f/39916800, 11025.0f/39916800,  45.0f/39916800, 0.0f/39916800}, 
    { -10.0f/39916800,  -5010.0f/39916800, -141060.0f/39916800, -736260.0f/39916800, -679560.0f/39916800,  679560.0f/39916800,  736260.0f/39916800, 141060.0f/39916800,  5010.0f/39916800,  10.0f/39916800, 0.0f/39916800}, 
    {   1.0f/39916800,   1013.0f/39916800,   47840.0f/39916800,  455192.0f/39916800, 1310354.0f/39916800, 1310354.0f/39916800,  455192.0f/39916800,  47840.0f/39916800,  1013.0f/39916800,   1.0f/39916800, 0.0f/39916800}
};

// Matrices to convert from power basis to FD basis
static float powerToFD1[1][1] = {
    {1},
};

static float powerToFD2[2][2] = {
    {0, 1},
    {1, 0},
};

static float powerToFD3[3][3] = {
    {0, 0, 1},
    {1, 1, 0},
    {2, 0, 0},
};

static float powerToFD4[4][4] = {
    {0, 0, 0, 1},
    {1, 1, 1, 0},
    {6, 2, 0, 0},
    {6, 0, 0, 0},
};

static float powerToFD5[5][5] = {
    {0, 0, 0, 0, 1},
    {1, 1, 1, 1, 0},
    {14, 6, 2, 0, 0},
    {36, 6, 0, 0, 0},
    {24, 0, 0, 0, 0},
};

static float powerToFD6[6][6] = {
    {0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 0},
    {30, 14, 6, 2, 0, 0},
    {150, 36, 6, 0, 0, 0},
    {240, 24, 0, 0, 0, 0},
    {120, 0, 0, 0, 0, 0},
};

static float powerToFD7[7][7] = {
    {0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 0},
    {62, 30, 14, 6, 2, 0, 0},
    {540, 150, 36, 6, 0, 0, 0},
    {1560, 240, 24, 0, 0, 0, 0},
    {1800, 120, 0, 0, 0, 0, 0},
    {720, 0, 0, 0, 0, 0, 0},
};

static float powerToFD8[8][8] = {
    {0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 0},
    {126, 62, 30, 14, 6, 2, 0, 0},
    {1806, 540, 150, 36, 6, 0, 0, 0},
    {8400, 1560, 240, 24, 0, 0, 0, 0},
    {16800, 1800, 120, 0, 0, 0, 0, 0},
    {15120, 720, 0, 0, 0, 0, 0, 0},
    {5040, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD9[9][9] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0},
    {254, 126, 62, 30, 14, 6, 2, 0, 0},
    {5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {40320, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD10[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD11[11][11] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD12[12][12] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {29607600, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {129230640, 16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {322494480, 29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {479001600, 30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {419126400, 16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {199584000, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {39916800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD13[13][13] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {14676024, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {165528000.0, 29607600, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {953029440.0, 129230640, 16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {3162075840.0, 322494480, 29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {6411968640.0, 479001600, 30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {8083152000.0, 419126400, 16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {6187104000.0, 199584000, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2634508800.0, 39916800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {479001600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD14[14][14] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {8190, 4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {1569750, 519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {60780720, 14676024, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {901020120, 165528000.0, 29607600, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {6711344640.0, 953029440.0, 129230640, 16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {28805736960.0, 3162075840.0, 322494480, 29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {76592355840.0, 6411968640.0, 479001600, 30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {130456085760.0, 8083152000.0, 419126400, 16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {142702560000.0, 6187104000.0, 199584000, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {97037740800.0, 2634508800.0, 39916800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {37362124800.0, 479001600.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1932053504.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD15[15][15] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {16382, 8190, 4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {4733820, 1569750, 519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {249401880.0, 60780720, 14676024, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {4809004200.0, 901020120.0, 165528000.0, 29607600.0, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {45674188560.0, 6711344640.0, 953029440.0, 129230640.0, 16435440.0, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {248619571200.0, 28805736960.0, 3162075840.0, 322494480.0, 29635200.0, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {843184742400.0, 76592355840.0, 6411968640.0, 479001600.0, 30240000.0, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {1863435974400.0, 130456085760.0, 8083152000.0, 419126400.0, 16329600.0, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2731586457600.0, 142702560000.0, 6187104000.0, 199584000.0, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2637143308800.0, 97037740800.0, 2634508800.0, 39916800.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1612798387200.0, 37362124800.0, 479001600.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {175816868864.0, 1932053504.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1278945280.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD16[16][16] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {32766, 16382, 8190, 4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {14250606, 4733820, 1569750, 519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {1016542800.0, 249401880.0, 60780720.0, 14676024.0, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {25292030400.0, 4809004200.0, 901020120.0, 165528000.0, 29607600.0, 5103000.0, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {302899156560.0, 45674188560.0, 6711344640.0, 953029440.0, 129230640.0, 16435440.0, 1905120.0, 191520.0, 15120, 720, 0, 0, 0, 0, 0, 0},
    {2060056318320.0, 248619571200.0, 28805736960.0, 3162075840.0, 322494480.0, 29635200.0, 2328480.0, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {8734434508800.0, 843184742400.0, 76592355840.0, 6411968640.0, 479001600.0, 30240000.0, 1451520.0, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {24359586451200.0, 1863435974400.0, 130456085760.0, 8083152000.0, 419126400.0, 16329600.0, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {45950224320000.0, 2731586457600.0, 142702560000.0, 6187104000.0, 199584000.0, 3628800.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {59056027430400.0, 2637143308800.0, 97037740800.0, 2634508800.0, 39916800.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {50999300352000.0, 1612798387200.0, 37362124800.0, 479001600.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8790843443200.0, 175816868864.0, 1932053504.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {134289254400.0, 1278945280.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2004310016.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD1[1][1] = {
 {1},
};

static float inversePowerToFD2[2][2] = {
 {0, 1},
 {1, 0},
};

static float inversePowerToFD3[3][3] = {
 {0, 0, 0.5},
 {0, 1.0, -0.5},
 {1.0, 0, 0},
};

static float inversePowerToFD4[4][4] = {
 {0, 0, 0, 0.1666666666666667},
 {0, 0, 0.5, -0.5},
 {0, 1.0, -0.5, 0.3333333333333334},
 {1.0, 0, 0, 0},
};

static float inversePowerToFD5[5][5] = {
 { 0, 0, 0, 0, 0.04166666666666666},
 { 0, 0, 0, 0.1666666666666667, -0.25},
 { 0, 0, 0.5, -0.5, 0.4583333333333334},
 { 0, 1.0, -0.5, 0.3333333333333333, -0.25},
 { 1.0, 0, 0, 0, 0}, 
};

static float inversePowerToFD6[6][6] = {
 { 0, 0, 0, 0, -8.673617379884036e-019, 8.333333333333335e-003},
 { 0, 0, 0, 0, 4.166666666666666e-002, -8.333333333333333e-002},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666667e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000001e-001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0},
};

static float inversePowerToFD7[7][7] = {
 { 0, 0, 0, 0, 1.084202172485504e-019, -2.168404344971009e-019, 1.388888888888889e-003},
 { 0, 0, 0, -1.734723475976807e-018, 2.602085213965211e-018, 8.333333333333332e-003, -2.083333333333333e-002},
 { 0, 0, 0, 0, 4.166666666666667e-002, -8.333333333333334e-002, 1.180555555555556e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.125000000000001e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666667e-001, 3.805555555555557e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333334e-001, -2.500000000000001e-001, 2.000000000000001e-001, -1.666666666666668e-001},
 {1.000000000000000e+000, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD8[8][8] = {
 { 0, 0, 0, 1.355252715606881e-020, -1.355252715606881e-020, 2.710505431213761e-020, -2.710505431213761e-020, 1.984126984126984e-004},
 { 0, 0, 0, 0, -2.168404344971009e-019, 2.168404344971009e-019, 1.388888888888889e-003, -4.166666666666667e-003},
 { 0, 0, 0, 0, 1.734723475976807e-018, 8.333333333333333e-003, -2.083333333333333e-002, 3.472222222222222e-002},
 { 0, 0, 0, 0, 4.166666666666666e-002, -8.333333333333332e-002, 1.180555555555556e-001, -1.458333333333333e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.125000000000001e-001, 3.222222222222224e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666669e-001, 3.805555555555558e-001, -3.500000000000003e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000000e-001, -1.666666666666667e-001, 1.428571428571431e-001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD9[9][9] = {
 {0, 0, 0, 3.388131789017201e-021, -3.388131789017201e-021, 8.470329472543003e-021, -9.317362419797304e-021, 6.776263578034403e-021, 2.480158730158730e-005},
 {0, 0, 0, -2.710505431213761e-020, 0, 5.421010862427522e-020, -5.421010862427522e-020, 1.984126984126985e-004, -6.944444444444445e-004},
 {0, 0, 0, -4.336808689942018e-019, 8.673617379884036e-019, -8.673617379884036e-019, 1.388888888888890e-003, -4.166666666666668e-003, 7.986111111111112e-003},
 {0, 0, 0, 0, 0, 8.333333333333335e-003, -2.083333333333333e-002, 3.472222222222222e-002, -4.861111111111112e-002},
 {0, 0, 0, 2.081668171172169e-017, 4.166666666666664e-002, -8.333333333333332e-002, 1.180555555555555e-001, -1.458333333333333e-001, 1.678819444444444e-001},
 {0, 0, 0, 1.666666666666666e-001, -2.499999999999999e-001, 2.916666666666666e-001, -3.124999999999999e-001, 3.222222222222220e-001, -3.256944444444442e-001},
 {0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333332e-001, -4.166666666666664e-001, 3.805555555555553e-001, -3.499999999999995e-001, 3.241071428571424e-001},
 {0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.499999999999999e-001, 1.999999999999999e-001, -1.666666666666665e-001, 1.428571428571426e-001, -1.249999999999997e-001},
 {1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD10[10][10] = {
 { 0, 0, 0, -1.058791184067875e-022, 0, 0, -2.117582368135751e-022, 8.470329472543003e-022, -2.117582368135751e-021, 2.755731922398594e-006}, 
 { 0, 0, 0, 3.388131789017201e-021, 0, -1.355252715606881e-020, 2.032879073410321e-020, -2.371692252312041e-020, 2.480158730158734e-005, -9.920634920634926e-005},
 { 0, 0, 0, -5.421010862427522e-020, 0, 1.084202172485504e-019, -2.710505431213761e-019, 1.984126984126989e-004, -6.944444444444453e-004, 1.504629629629631e-003}, 
 { 0, 0, 0, 0, 0, -8.673617379884036e-019, 1.388888888888891e-003, -4.166666666666669e-003, 7.986111111111116e-003, -1.250000000000001e-002},
 { 0, 0, 0, 0, 0, 8.333333333333338e-003, -2.083333333333335e-002, 3.472222222222225e-002, -4.861111111111115e-002, 6.186342592592600e-002}, 
 { 0, 0, 0, 0, 4.166666666666667e-002, -8.333333333333337e-002, 1.180555555555556e-001, -1.458333333333334e-001, 1.678819444444446e-001, -1.854166666666670e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666668e-001, -3.125000000000002e-001, 3.222222222222225e-001, -3.256944444444448e-001, 3.255180776014118e-001}, 
 { 0, 0, 5.000000000000000e-001, -4.999999999999999e-001, 4.583333333333333e-001, -4.166666666666669e-001, 3.805555555555559e-001, -3.500000000000004e-001, 3.241071428571435e-001, -3.019841269841282e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.499999999999999e-001, 2.000000000000000e-001, -1.666666666666667e-001, 1.428571428571430e-001, -1.250000000000003e-001, 1.111111111111117e-001}, 
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
};

static float inversePowerToFD11[11][11] = {
{ 0, 0, 0, 0, 0, -1.323488980084844e-023, 1.985233470127266e-023, 0, -2.646977960169689e-023, 2.646977960169689e-023, 2.755731922398589e-007},
{ 0, 0, 0, 0, 0, 6.352747104407253e-022, -1.694065894508601e-021, 3.388131789017201e-021, -6.988021814847978e-021, 2.755731922398603e-006, -1.240079365079368e-005},
{ 0, 0, 0, 2.710505431213761e-020, -1.355252715606881e-020, 0, 1.355252715606881e-020, -2.710505431213761e-020, 2.480158730158737e-005, -9.920634920634938e-005, 2.397486772486777e-004},
{ 0, 0, 0, -2.168404344971009e-019, 1.084202172485504e-019, 2.168404344971009e-019, -5.963111948670274e-019, 1.984126984126994e-004, -6.944444444444463e-004, 1.504629629629633e-003, -2.604166666666673e-003},
{ 0, 0, 0, 0, 8.673617379884036e-019, -2.168404344971009e-018, 1.388888888888893e-003, -4.166666666666673e-003, 7.986111111111123e-003, -1.250000000000002e-002, 1.743634259259262e-002},
{ 0, 0, 0, 0, -3.469446951953614e-018, 8.333333333333344e-003, -2.083333333333335e-002, 3.472222222222225e-002, -4.861111111111115e-002, 6.186342592592597e-002, -7.421875000000003e-002},
{ 0, 0, 0, 1.387778780781446e-017, 4.166666666666666e-002, -8.333333333333334e-002, 1.180555555555556e-001, -1.458333333333335e-001, 1.678819444444446e-001, -1.854166666666667e-001, 1.994268077601409e-001},
{ 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.125000000000001e-001, 3.222222222222226e-001, -3.256944444444450e-001, 3.255180776014112e-001, -3.231646825396818e-001},
{ 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666668e-001, 3.805555555555558e-001, -3.500000000000005e-001, 3.241071428571436e-001, -3.019841269841275e-001, 2.828968253968248e-001},
{ 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000000e-001, -1.666666666666668e-001, 1.428571428571432e-001, -1.250000000000005e-001, 1.111111111111115e-001, -9.999999999999990e-002},
{ 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD12[12][12] = {
 { 0, 0, 0, 0, 0, -4.135903062765138e-025, 1.654361225106055e-024, 0, -4.963083675318166e-024, 1.571643163850753e-023, -3.308722450212111e-023, 2.505210838544177e-008},
 { 0, 0, 0, -1.058791184067875e-022, 1.588186776101813e-022, -1.588186776101813e-022, 1.323488980084844e-022, -2.117582368135751e-022, 4.235164736271502e-022, -8.999725064576941e-022, 2.755731922398606e-007, -1.377865961199297e-006},
 { 0, 0, 0, 0, 1.694065894508601e-021, -8.470329472543003e-022, 0, 3.388131789017201e-021, -1.016439536705160e-020, 2.755731922398615e-006, -1.240079365079371e-005, 3.306878306878317e-005},
 { 0, 0, 0, -2.710505431213761e-020, 0, 3.388131789017201e-020, -8.131516293641283e-020, 1.084202172485504e-019, 2.480158730158719e-005, -9.920634920634925e-005, 2.397486772486777e-004, -4.546957671957683e-004},
 { 0, 0, 0, 0, 2.168404344971009e-019, -3.794707603699266e-019, 5.421010862427522e-019, 1.984126984126981e-004, -6.944444444444450e-004, 1.504629629629632e-003, -2.604166666666673e-003, 3.952546296296310e-003},
 { 0, 0, 0, 0, 0, 1.301042606982605e-018, 1.388888888888886e-003, -4.166666666666662e-003, 7.986111111111107e-003, -1.250000000000000e-002, 1.743634259259261e-002, -2.259837962962969e-002},
 { 0, 0, 0, 6.938893903907228e-018, -6.938893903907228e-018, 8.333333333333338e-003, -2.083333333333333e-002, 3.472222222222222e-002, -4.861111111111111e-002, 6.186342592592592e-002, -7.421875000000003e-002, 8.560130070546752e-002},
 { 0, 0, 0, -1.387778780781446e-017, 4.166666666666668e-002, -8.333333333333334e-002, 1.180555555555555e-001, -1.458333333333333e-001, 1.678819444444442e-001, -1.854166666666664e-001, 1.994268077601408e-001, -2.106757054673722e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.124999999999999e-001, 3.222222222222221e-001, -3.256944444444441e-001, 3.255180776014103e-001, -3.231646825396818e-001, 3.195039682539682e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333333e-001, -4.166666666666668e-001, 3.805555555555558e-001, -3.500000000000001e-001, 3.241071428571427e-001, -3.019841269841264e-001, 2.828968253968248e-001, -2.662698412698415e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333334e-001, -2.500000000000001e-001, 2.000000000000002e-001, -1.666666666666669e-001, 1.428571428571430e-001, -1.250000000000001e-001, 1.111111111111111e-001, -9.999999999999995e-002, 9.090909090909122e-002},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD13[13][13] = {
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.000000000000000e+000},
{1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 0},
{4.094000000000000e+003, 2.046000000000000e+003, 1.022000000000000e+003, 5.100000000000000e+002, 2.540000000000000e+002, 1.260000000000000e+002, 6.200000000000000e+001, 3.000000000000000e+001, 1.400000000000000e+001, 6.000000000000000e+000, 2.000000000000000e+000, 0, 0},
{5.191560000000000e+005, 1.710060000000000e+005, 5.598000000000000e+004, 1.815000000000000e+004, 5.796000000000000e+003, 1.806000000000000e+003, 5.400000000000000e+002, 1.500000000000000e+002, 3.600000000000000e+001, 6.000000000000000e+000, 0, 0, 0},
{1.467602400000000e+007, 3.498000000000000e+006, 8.185200000000000e+005, 1.864800000000000e+005, 4.082400000000000e+004, 8.400000000000000e+003, 1.560000000000000e+003, 2.400000000000000e+002, 2.400000000000000e+001, 0, 0, 0, 0},
{1.655280000000000e+008, 2.960760000000000e+007, 5.103000000000000e+006, 8.341200000000000e+005, 1.260000000000000e+005, 1.680000000000000e+004, 1.800000000000000e+003, 1.200000000000000e+002, 0, 0, 0, 0, 0},
{9.530294400000000e+008, 1.292306400000000e+008, 1.643544000000000e+007, 1.905120000000000e+006, 1.915200000000000e+005, 1.512000000000000e+004, 7.200000000000000e+002, 0, 0, 0, 0, 0, 0},
{3.162075840000000e+009, 3.224944800000000e+008, 2.963520000000000e+007, 2.328480000000000e+006, 1.411200000000000e+005, 5.040000000000000e+003, 0, 0, 0, 0, 0, 0, 0},
{6.411968640000000e+009, 4.790016000000000e+008, 3.024000000000000e+007, 1.451520000000000e+006, 4.032000000000000e+004, 0, 0, 0, 0, 0, 0, 0, 0},
{8.083152000000000e+009, 4.191264000000000e+008, 1.632960000000000e+007, 3.628800000000000e+005, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{6.187104000000000e+009, 1.995840000000000e+008, 3.628800000000000e+006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{2.634508800000000e+009, 3.991680000000000e+007, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{4.790016000000000e+008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};
 
static float inversePowerToFD14[14][14] = {
 { 0, 0, 0, 0, 1.292469707114106e-026, -1.938704560671159e-026, 3.231174267785264e-026, -4.523643974899370e-026, 7.270142102516845e-026, -1.292469707114106e-025, 1.898314882323843e-025, -1.809457589959748e-025, -1.292469707114106e-026, 5.175840099301946e-010},
 { 0, 0, 3.308722450212111e-024, -4.135903062765138e-024, 4.135903062765138e-024, -3.308722450212111e-024, 2.067951531382569e-024, -4.135903062765138e-025, -1.033975765691285e-024, 3.308722450212111e-024, -5.480071558163808e-024, 3.722312756488625e-024, 2.087675698786818e-009, -4.037155277455517e-008},
 { 0, 0, 0, 5.293955920339377e-023, -5.293955920339377e-023, 6.617444900424221e-023, -7.940933880509066e-023, 7.940933880509066e-023, -4.632211430296955e-023, -5.293955920339377e-023, 1.753622898612419e-022, 2.505210838544154e-008, -1.377865961199296e-007, 1.406275754980337e-006},
 { 0, 0, 0, -8.470329472543003e-022, 0, 1.058791184067875e-021, -2.117582368135751e-021, 2.964615315390051e-021, -4.658681209898652e-021, 6.776263578034403e-021, 2.755731922398507e-007, -1.377865961199290e-006, 4.018775720164620e-006, -2.886566023380700e-005},
 { 0, 0, 0, -1.355252715606881e-020, 1.355252715606881e-020, -5.082197683525802e-021, 0, 3.388131789017201e-021, 3.388131789017201e-021, 2.755731922398567e-006, -1.240079365079363e-005, 3.306878306878313e-005, -6.820436507936541e-005, 3.879100648343151e-004},
 { 0, 0, 0, -1.084202172485504e-019, 0, 6.776263578034403e-020, -1.084202172485504e-019, 1.626303258728257e-019, 2.480158730158704e-005, -9.920634920634864e-005, 2.397486772486765e-004, -4.546957671957671e-004, 7.461833112874805e-004, -3.585115001038839e-003},
 { 0, 0, 0, 4.336808689942018e-019, 0, -6.505213034913027e-019, 1.301042606982605e-018, 1.984126984126960e-004, -6.944444444444401e-004, 1.504629629629622e-003, -2.604166666666656e-003, 3.952546296296286e-003, -5.506365740740740e-003, 2.328622416866577e-002},
 { 0, 0, 0, 0, -3.469446951953614e-018, 6.071532165918825e-018, 1.388888888888879e-003, -4.166666666666650e-003, 7.986111111111083e-003, -1.249999999999995e-002, 1.743634259259251e-002, -2.259837962962950e-002, 2.784862305261595e-002, -1.066586145639159e-001},
 { 0, 0, 0, -6.938893903907228e-018, 2.081668171172169e-017, 8.333333333333297e-003, -2.083333333333329e-002, 3.472222222222215e-002, -4.861111111111099e-002, 6.186342592592570e-002, -7.421874999999956e-002, 8.560130070546657e-002, -9.602416776895803e-002, 3.401597495304081e-001},
 { 0, 0, 0, -2.775557561562891e-017, 4.166666666666671e-002, -8.333333333333337e-002, 1.180555555555556e-001, -1.458333333333333e-001, 1.678819444444443e-001, -1.854166666666662e-001, 1.994268077601399e-001, -2.106757054673695e-001, 2.197447273662498e-001, -7.318714958320032e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.499999999999999e-001, 2.916666666666666e-001, -3.125000000000000e-001, 3.222222222222222e-001, -3.256944444444445e-001, 3.255180776014106e-001, -3.231646825396810e-001, 3.195039682539639e-001, -3.150677910052809e-001, 9.997443383430656e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666666e-001, 3.805555555555557e-001, -3.500000000000004e-001, 3.241071428571435e-001, -3.019841269841277e-001, 2.828968253968255e-001, -2.662698412698387e-001, 2.516564454064369e-001, -7.693590663625261e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000000e-001, -1.666666666666668e-001, 1.428571428571432e-001, -1.250000000000006e-001, 1.111111111111118e-001, -1.000000000000005e-001, 9.090909090909052e-002, -8.333333333333075e-002, 2.479235688909577e-001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD15[15][15] = {
{ 0, 0, 0, -8.077935669463161e-028, -3.231174267785264e-027, -4.846761401677897e-027, 8.885729236409477e-027, -1.130910993724843e-026, 1.262177448353619e-026, -1.292469707114106e-026, 1.231885189593132e-026, -1.050131637030211e-026, 8.279884061199740e-027, -3.231174267785264e-026, 7.818942808874530e-010},
{ 0, -1.654361225106055e-024, 8.271806125530277e-025, -6.203854594147708e-025, 4.135903062765138e-025, -8.788794008375919e-025, 1.654361225106055e-024, -2.584939414228212e-024, 3.405657678245669e-024, -3.929107909626882e-024, 4.148827759836279e-024, -4.135903062765138e-024, 3.877409121342317e-024, 5.175840099301827e-010, -7.115237956075797e-008},
{ 0, 1.058791184067875e-022, -5.293955920339377e-023, 3.639594695233322e-023, -3.970466940254533e-023, 4.632211430296955e-023, -7.610061635487855e-023, 1.091878408569997e-022, -1.302809464771019e-022, 1.323488980084844e-022, -1.162188760637004e-022, 8.271806125530277e-023, 2.087675698786772e-009, -4.037155277455509e-008, 2.917247561991086e-006},
{ 0, 0, 0, -1.058791184067875e-022, 0, -3.176373552203626e-022, 7.411538288475128e-022, -1.111730743271269e-021, 1.164670302474663e-021, -8.470329472543003e-022, 1.654361225106055e-022, 2.505210838544245e-008, -1.377865961199311e-007, 1.406275754980341e-006, -7.122353194031895e-005},
{ 0, 2.710505431213761e-020, -1.355252715606881e-020, 1.016439536705160e-020, -6.776263578034403e-021, 5.082197683525802e-021, -6.776263578034403e-021, 1.101142831430590e-020, -1.641126335305207e-020, 2.032879073410321e-020, 2.755731922398387e-007, -1.377865961199279e-006, 4.018775720164597e-006, -2.886566023380679e-005, 1.152882006022958e-003},
{ 0, 0, 0, 0, 0, -1.355252715606881e-020, 9.486769009248164e-020, -2.371692252312041e-019, 3.642241673193492e-019, 2.755731922398134e-006, -1.240079365079315e-005, 3.306878306878255e-005, -6.820436507936449e-005, 3.879100648343091e-004, -1.303390634507821e-002},
{ 0, 0, -4.336808689942018e-019, 4.336808689942018e-019, -4.336808689942018e-019, 3.252606517456513e-019, -1.084202172485504e-018, 2.168404344971009e-018, 2.480158730158389e-005, -9.920634920634452e-005, 2.397486772486715e-004, -4.546957671957603e-004, 7.461833112874690e-004, -3.585115001038764e-003, 1.055842459499107e-001},
{ 0, 0, 3.469446951953614e-018, -3.469446951953614e-018, 0, -1.734723475976807e-018, 6.071532165918825e-018, 1.984126984126851e-004, -6.944444444444233e-004, 1.504629629629601e-003, -2.604166666666629e-003, 3.952546296296247e-003, -5.506365740740666e-003, 2.328622416866524e-002, -6.184339278377696e-001},
{ 0, 1.110223024625157e-016, -4.163336342344337e-017, 2.081668171172169e-017, -1.387778780781446e-017, 1.040834085586084e-017, 1.388888888888867e-003, -4.166666666666614e-003, 7.986111111111024e-003, -1.249999999999987e-002, 1.743634259259239e-002, -2.259837962962934e-002, 2.784862305261564e-002, -1.066586145639135e-001, 2.608492199134465e+000},
{ 0, 0, 0, 0, 2.775557561562891e-017, 8.333333333333297e-003, -2.083333333333328e-002, 3.472222222222211e-002, -4.861111111111089e-002, 6.186342592592550e-002, -7.421874999999928e-002, 8.560130070546618e-002, -9.602416776895736e-002, 3.401597495304019e-001, -7.785871617587367e+000},
{ 0, 4.440892098500626e-016, -1.110223024625157e-016, 5.551115123125783e-017, 4.166666666666663e-002, -8.333333333333332e-002, 1.180555555555555e-001, -1.458333333333331e-001, 1.678819444444439e-001, -1.854166666666656e-001, 1.994268077601391e-001, -2.106757054673686e-001, 2.197447273662489e-001, -7.318714958319950e-001, 1.588320736912066e+001},
{ 0, 0, 0, 1.666666666666667e-001, -2.500000000000001e-001, 2.916666666666667e-001, -3.124999999999997e-001, 3.222222222222215e-001, -3.256944444444432e-001, 3.255180776014087e-001, -3.231646825396785e-001, 3.195039682539611e-001, -3.150677910052783e-001, 9.997443383430542e-001, -2.079582095646540e+001},
{ 0, 4.440892098500626e-016, 4.999999999999998e-001, -4.999999999999999e-001, 4.583333333333333e-001, -4.166666666666664e-001, 3.805555555555550e-001, -3.499999999999990e-001, 3.241071428571413e-001, -3.019841269841243e-001, 2.828968253968205e-001, -2.662698412698328e-001, 2.516564454064311e-001, -7.693590663625061e-001, 1.548366403916549e+001},
{ 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333334e-001, -2.500000000000000e-001, 1.999999999999998e-001, -1.666666666666664e-001, 1.428571428571424e-001, -1.249999999999993e-001, 1.111111111111098e-001, -9.999999999999774e-002, 9.090909090908705e-002, -8.333333333332699e-002, 2.479235688909449e-001, -4.868871950486066e+000},
{ 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD16[16][16] = {
 { 0, 1.615587133892632e-027, -8.077935669463161e-028, -1.615587133892632e-027, 2.827277484312106e-027, -3.534096855390133e-027, 3.837019442995001e-027, -4.266159775435232e-027, 4.846761401677897e-027, -5.578824321722996e-027, 6.866245319043687e-027, -9.125542951596665e-027, 1.259653093456912e-026, -5.593970451103239e-026, 1.589737739750350e-024, 4.989248130364881e-010},
 { 0, 0, -2.584939414228212e-026, 2.067951531382569e-025, -3.618915179919496e-025, 4.911384887033602e-025, -5.686866711302065e-025, 6.656218991637645e-025, -7.754818242684635e-025, 9.031132078459814e-025, -1.072749856904708e-024, 1.319732739998544e-024, -1.659207986507733e-024, 6.643294294566504e-024, 7.818942808872849e-010, -5.238710536883159e-008},
 { 0, 0, 0, 0, 1.654361225106055e-024, -5.790264287871194e-024, 8.271806125530277e-024, -1.137373342260413e-023, 1.488925102595450e-023, -1.912855166528877e-023, 2.646977960169689e-023, -3.931692849041110e-023, 5.955700410381799e-023, 5.175840099299126e-010, -7.115237956075005e-008, 2.497118689247629e-006},
 { 0, 0, -5.293955920339377e-023, 4.235164736271502e-022, -6.882142696441190e-022, 8.470329472543003e-022, -8.999725064576941e-022, 9.926167350636332e-022, -1.111730743271269e-021, 1.297019200483147e-021, -1.641126335305207e-021, 2.283018490646356e-021, 2.087675698783468e-009, -4.037155277453942e-008, 2.917247561990624e-006, -7.150839882845188e-005},
 { 0, 0, 0, -1.016439536705160e-020, 1.524659305057741e-020, -1.905824131322176e-020, 2.159934015498466e-020, -2.456395547037471e-020, 2.795208725939191e-020, -3.224019155486681e-020, 3.981054852095212e-020, 2.505210838538786e-008, -1.377865961198519e-007, 1.406275754979971e-006, -7.122353194030805e-005, 1.371917007872563e-003},
 { 0, -5.421010862427522e-020, 2.710505431213761e-020, 5.421010862427522e-020, -1.219727444046193e-019, 1.694065894508601e-019, -2.032879073410321e-019, 2.456395547037471e-019, -2.981555974335137e-019, 3.710004308973836e-019, 2.755731922393627e-007, -1.377865961198568e-006, 4.018775720163491e-006, -2.886566023380136e-005, 1.152882006022794e-003, -1.861601982833958e-002},
 { 0, 0, -1.084202172485504e-019, -8.673617379884036e-019, 1.517883041479706e-018, -1.897353801849633e-018, 2.168404344971009e-018, -2.561427632497004e-018, 3.144186300207963e-018, 2.755731922394627e-006, -1.240079365078829e-005, 3.306878306877514e-005, -6.820436507935272e-005, 3.879100648342507e-004, -1.303390634507643e-002, 1.838096961343281e-001},
 { 0, 3.469446951953614e-018, -8.673617379884036e-019, 1.387778780781446e-017, -1.908195823574488e-017, 2.168404344971009e-017, -2.168404344971009e-017, 2.423191855505102e-017, 2.480158730155859e-005, -9.920634920631432e-005, 2.397486772486312e-004, -4.546957671957010e-004, 7.461833112873777e-004, -3.585115001038322e-003, 1.055842459498977e-001, -1.337843823357720e+000},
 { 0, 0, 3.469446951953614e-018, -2.775557561562891e-017, 5.551115123125783e-017, -7.459310946700271e-017, 8.673617379884036e-017, 1.984126984125923e-004, -6.944444444443101e-004, 1.504629629629458e-003, -2.604166666666432e-003, 3.952546296295948e-003, -5.506365740740204e-003, 2.328622416866305e-002, -6.184339278377090e-001, 7.189168747834084e+000},
 { 0, 0, 1.387778780781446e-017, 1.110223024625157e-016, -2.220446049250313e-016, 3.122502256758253e-016, 1.388888888888530e-003, -4.166666666666218e-003, 7.986111111110555e-003, -1.249999999999931e-002, 1.743634259259168e-002, -2.259837962962829e-002, 2.784862305261406e-002, -1.066586145639066e-001, 2.608492199134309e+000, -2.827075966674896e+001},
 { 0, 2.220446049250313e-016, -1.110223024625157e-016, -6.661338147750939e-016, 9.992007221626409e-016, 8.333333333332138e-003, -2.083333333333204e-002, 3.472222222222073e-002, -4.861111111110933e-002, 6.186342592592379e-002, -7.421874999999725e-002, 8.560130070546350e-002, -9.602416776895391e-002, 3.401597495303908e-001, -7.785871617587300e+000, 7.968907225177995e+001},
 { 0, 0, 0, 8.881784197001252e-016, 4.166666666666519e-002, -8.333333333333143e-002, 1.180555555555534e-001, -1.458333333333307e-001, 1.678819444444413e-001, -1.854166666666630e-001, 1.994268077601365e-001, -2.106757054673658e-001, 2.197447273662466e-001, -7.318714958320010e-001, 1.588320736912164e+001, -1.551602586014341e+002},
 { 0, 0, -1.110223024625157e-016, 1.666666666666661e-001, -2.499999999999987e-001, 2.916666666666647e-001, -3.124999999999974e-001, 3.222222222222189e-001, -3.256944444444407e-001, 3.255180776014069e-001, -3.231646825396781e-001, 3.195039682539627e-001, -3.150677910052848e-001, 9.997443383431157e-001, -2.079582095646863e+001, 1.956567570353576e+002},
 { 0, 0, 5.000000000000000e-001, -4.999999999999996e-001, 4.583333333333323e-001, -4.166666666666651e-001, 3.805555555555534e-001, -3.499999999999973e-001, 3.241071428571400e-001, -3.019841269841246e-001, 2.828968253968234e-001, -2.662698412698396e-001, 2.516564454064454e-001, -7.693590663626030e-001, 1.548366403916965e+001, -1.414280451113939e+002},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333328e-001, -2.499999999999993e-001, 1.999999999999992e-001, -1.666666666666656e-001, 1.428571428571416e-001, -1.249999999999988e-001, 1.111111111111102e-001, -9.999999999999960e-002, 9.090909090909112e-002, -8.333333333333474e-002, 2.479235688909923e-001, -4.868871950487935e+000, 4.349541263781754e+001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

/*****************************************************************************/
float cachedBinomialCoefficients[11][11] = {
  { 1.000000000000000e+000f, 1.000000000000000e+000f, 5.000000000000000e-001f, 1.666666666666667e-001f, 4.166666666666666e-002f,
    8.333333333333333e-003f, 1.388888888888889e-003f, 1.984126984126984e-004f, 2.480158730158730e-005f, 2.755731922398589e-006f, 2.755731922398589e-007f},
  { 1.000000000000000e+000f, 1.000000000000000e+000f, 5.000000000000000e-001f, 1.666666666666667e-001f, 4.166666666666666e-002f,
    8.333333333333333e-003f, 1.388888888888889e-003f, 1.984126984126984e-004f, 2.480158730158730e-005f, 2.755731922398589e-006f, 2.755731922398589e-007f},
  { 1.000000000000000e+000f, 2.000000000000000e+000f, 1.000000000000000e+000f, 3.333333333333333e-001f, 8.333333333333333e-002f,
    1.666666666666667e-002f, 2.777777777777778e-003f, 3.968253968253968e-004f, 4.960317460317460e-005f, 5.511463844797179e-006f, 5.511463844797179e-007f},
  { 1.000000000000000e+000f, 3.000000000000000e+000f, 3.000000000000000e+000f, 1.000000000000000e+000f, 2.500000000000000e-001f,
    5.000000000000000e-002f, 8.333333333333333e-003f, 1.190476190476190e-003f, 1.488095238095238e-004f, 1.653439153439153e-005f, 1.653439153439153e-006f},
  { 1.000000000000000e+000f, 4.000000000000000e+000f, 6.000000000000000e+000f, 4.000000000000000e+000f, 1.000000000000000e+000f,
    2.000000000000000e-001f, 3.333333333333333e-002f, 4.761904761904762e-003f, 5.952380952380952e-004f, 6.613756613756613e-005f, 6.613756613756613e-006f},
  { 1.000000000000000e+000f, 5.000000000000000e+000f, 1.000000000000000e+001f, 1.000000000000000e+001f, 5.000000000000000e+000f,
    1.000000000000000e+000f, 1.666666666666667e-001f, 2.380952380952381e-002f, 2.976190476190476e-003f, 3.306878306878307e-004f, 3.306878306878306e-005f},
  { 1.000000000000000e+000f, 6.000000000000000e+000f, 1.500000000000000e+001f, 2.000000000000000e+001f, 1.500000000000000e+001f,
    6.000000000000000e+000f, 1.000000000000000e+000f, 1.428571428571429e-001f, 1.785714285714286e-002f, 1.984126984126984e-003f, 1.984126984126984e-004f},
  { 1.000000000000000e+000f, 7.000000000000000e+000f, 2.100000000000000e+001f, 3.500000000000000e+001f, 3.500000000000000e+001f,
    2.100000000000000e+001f, 7.000000000000000e+000f, 1.000000000000000e+000f, 1.250000000000000e-001f, 1.388888888888889e-002f, 1.388888888888889e-003f},
  { 1.000000000000000e+000f, 8.000000000000000e+000f, 2.800000000000000e+001f, 5.600000000000000e+001f, 7.000000000000000e+001f,
    5.600000000000000e+001f, 2.800000000000000e+001f, 8.000000000000000e+000f, 1.000000000000000e+000f, 1.111111111111111e-001f, 1.111111111111111e-002f},
  { 1.000000000000000e+000f, 9.000000000000000e+000f, 3.600000000000000e+001f, 8.400000000000000e+001f, 1.260000000000000e+002f,
    1.260000000000000e+002f, 8.400000000000000e+001f, 3.600000000000000e+001f, 9.000000000000000e+000f, 1.000000000000000e+000f, 1.000000000000000e-001f},
  { 1.000000000000000e+000f, 1.000000000000000e+001f, 4.500000000000000e+001f, 1.200000000000000e+002f, 2.100000000000000e+002f,
    2.520000000000000e+002f, 2.100000000000000e+002f, 1.200000000000000e+002f, 4.500000000000000e+001f, 1.000000000000000e+001f, 1.000000000000000e+000f},
};

/*****************************************************************************/
const double rtable2[2][2][2] = {{{1, 0}, {0, 0}}, {{0, 0}, {0, 1}}};

const double rtable3[3][3][3] = {
    {{1, 0, 0}, {0, 0, 0}, {0, 0, 0}}, 
    {{0, 0, 0}, {0, 1, 0}, {0, -1./2, 1./2}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 1}}};

const double rtable4[4][4][4] = {
    {{1, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 
    {{0, 0, 0, 0}, {0, 1, 0, 0}, {0, -1./2, 1./2, 0}, {0, 1./3, -1./2, 1./6}}, 
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 1, 0}, {0, 0, -1, 1}}, 
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 1}}};

const double rtable5[5][5][5] = {
    {{1, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0}, {0, 1, 0, 0, 0}, {0, -1./2, 1./2, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0}, {0, -1./4, 11./24, -1./4, 1./24}}, 
    {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 1, 0, 0}, {0, 0, -1, 1, 0}, 
     {0, 0, 11./12, -3./2, 7./12}}, 
    {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, 
     {0, 0, 0, -3./2, 3./2}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 1}}};

const double rtable6[6][6][6] = {
    {{1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0}, {0, 1./5, -5./12, 7./24, -1./12, 1./120}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0}, {0, 0, 11./12, -3./2, 7./12, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0}, {0, 0, 0, -3./2, 3./2, 0}, {0, 0, 0, 7./4, -3, 5./4}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, -2, 2}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1}}};

const double rtable7[7][7][7] = {
    {{1, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0}, {0, 0, 11./12, -3./2, 7./12, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, -3./2, 3./2, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0}, {0, 0, 0, -15./8, 17./4, -25./8, 3./4}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, -2, 2, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1}}};

const double rtable8[8][8][8] = {
    {{1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0}, {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0}, {0, 0, 0, 7./4, -3, 5./4, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, -2, 2, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0}, {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0}, {0, 0, 0, 0, 0, 25./6, -15./2, 10./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 0, -3, 3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable9[9][9][9] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, -2, 2, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 0, -3, 3, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable10[10][10][10] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, 
      -1./80, 13./8640, -1./10080, 1./362880}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, 
      -31./40, 91./480, -127./5040, 17./12096}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0}, 
     {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, -23./40, 
      605./12096}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0}, {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -3, 3, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -4, 4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable11[11][11][11] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, 
      -1./80, 13./8640, -1./10080, 1./362880, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, 
      -31./40, 91./480, -127./5040, 17./12096, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, -21./64, 
      3683./60480, -17./2688, 73./259200}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0}, 
     {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, -23./40, 
      605./12096, 0}, {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, 
      -301./64, 667./480, -605./2688, 311./20160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable12[12][12][12] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 
      1069./17280, -1./80, 13./8640, -1./10080, 1./362880, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 
      1069./576, -31./40, 91./480, -127./5040, 17./12096, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, 
      -23./40, 605./12096, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240, 0}, {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 
      4781./144, -297./16, 37./6, -6821./6048, 265./3024}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 0}, 
     {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0}, 
     {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 259./80}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable13[13][13][13] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 
      1069./17280, -1./80, 13./8640, -1./10080, 1./362880, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0}, 
     {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 
      1069./576, -31./40, 91./480, -127./5040, 17./12096, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 511./124416, 
      -341./1209600, 2047./239500800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, 
      -23./40, 605./12096, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240, 0, 0}, {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 
      4781./144, -297./16, 37./6, -6821./6048, 265./3024, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 0, 
      0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024, 0}, {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, 
      -13321./144, 54155./576, -3641./64, 2625./128, -24673./6048, 1045./3024}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 259./80, 
      0}, {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, 
      -2079./16, 38045./576, -2849./160, 30083./15120}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable14[14][14][14] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, 
      -23./40, 605./12096, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0}, {0, 0, 0, 128977./69300, -412009./50400, 1148963./72576, 
      -48035./2688, 13528531./1036800, -20631./3200, 211387./96768, -4043./8064, 
      541519./7257600, -437./67200, 115./456192}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 0, 
      0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, 
      -37./16, 6821./30240, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0}, 
     {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 314617./5184, 
      -72657./1600, 64639./2880, -88673./12096, 55385./36288, -55591./302400, 
      253./25920}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 0, 
      0, 0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 
      331./12, -225./32, 2243./3024, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 
      259./80, 0, 0}, {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 
      205789./1440, -2079./16, 38045./576, -2849./160, 30083./15120, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, -4819./60, 
      123./10}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable15[15][15][15] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0, 
      0, 0, 0}, {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, 
      -1./1440, 1./40320, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 0}\
, {0, -1./14, 1145993./5045040, -9061./29700, 9301169./39916800, 
      -355277./3110400, 1666393./43545600, -112879./12441600, 944311./609638400, 
      -793./4147200, 491./29030400, -13./12441600, 41./958003200, -1./958003200, 
      1./87178291200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, -13481./138240, 
      35843./2073600, -4433./2073600, 83927./479001600, -13./1520640, 
      8191./43589145600}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 
      3913./1440, -23./40, 605./12096, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0}, {0, 0, 0, 128977./69300, -412009./50400, 
      1148963./72576, -48035./2688, 13528531./1036800, -20631./3200, 
      211387./96768, -4043./8064, 541519./7257600, -437./67200, 115./456192, 0}, 
     {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 1666393./80640, 
      -33976579./2073600, 21719153./2419200, -95953./27648, 152701./161280, 
      -370513./2073600, 17917./806400, -1495./912384, 289./5322240}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, 
      -37./16, 6821./30240, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0}, 
     {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 314617./5184, 
      -72657./1600, 64639./2880, -88673./12096, 55385./36288, -55591./302400, 
      253./25920, 0}, {0, 0, 0, 0, 9301169./1663200, -355277./12960, 
      21663109./362880, -790153./10368, 2832933./44800, -205387./5760, 
      3349111./241920, -37895./10368, 2279231./3628800, -3289./51840, 
      7613./2661120}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 
      0, 0, 0, 0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 
      331./12, -225./32, 2243./3024, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0}, 
     {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 
      259./80, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 
      205789./1440, -2079./16, 38045./576, -2849./160, 30083./15120, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, -4819./60, 
      123./10, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, 
      -1001./2, 197579./720, -1599./20, 1828./189}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, -7007./16, 5535./16, 
      -5447./40, 171./8}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, -3575./24, 
      94./3}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable16[16][16][16] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 
      0, 0, 0, 0, 0}, {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 
      23./2880, -1./1440, 1./40320, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0, 0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 
      0, 0}, {0, -1./14, 1145993./5045040, -9061./29700, 9301169./39916800, 
      -355277./3110400, 1666393./43545600, -112879./12441600, 
      944311./609638400, -793./4147200, 491./29030400, -13./12441600, 
      41./958003200, -1./958003200, 1./87178291200, 0}, 
     {0, 1./15, -1171733./5405400, 30946717./103194000, -406841./1710720, 
      21939781./179625600, -22463./518400, 899683./81648000, -35717./17418240, 
      515261./1828915200, -71./2488320, 2747./1306368000, -1./9123840, 
      1./261273600, -1./12454041600, 1./1307674368000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, 
      -7./80, 127./20160, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, 
      -13481./138240, 35843./2073600, -4433./2073600, 83927./479001600, 
      -13./1520640, 8191./43589145600, 0}, 
     {0, 0, -1171733./2702700, 30946717./17199000, -2847887./855360, 
      21939781./5987520, -696353./259200, 899683./648000, -4536059./8709120, 
      8759437./60963840, -36281./1244160, 936727./217728000, -2047./4561920, 
      13./414720, -8191./6227020800, 5461./217945728000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0, 0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 
      3913./1440, -23./40, 605./12096, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0, 0}, {0, 0, 0, 128977./69300, -412009./50400, 
      1148963./72576, -48035./2688, 13528531./1036800, -20631./3200, 
      211387./96768, -4043./8064, 541519./7257600, -437./67200, 115./456192, 0, 
      0}, {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 
      1666393./80640, -33976579./2073600, 21719153./2419200, -95953./27648, 
      152701./161280, -370513./2073600, 17917./806400, -1495./912384, 
      289./5322240, 0}, {0, 0, 0, 30946717./17199000, -406841./47520, 
      21939781./1197504, -22463./960, 38686369./1944000, -821491./69120, 
      62346581./12192768, -22081./13824, 78292247./217728000, -437./7680, 
      1495./248832, -289./760320, 2375101./217945728000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 
      783./80, -37./16, 6821./30240, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0, 0}, 
     {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 314617./5184, 
      -72657./1600, 64639./2880, -88673./12096, 55385./36288, -55591./302400, 
      253./25920, 0, 0}, {0, 0, 0, 0, 9301169./1663200, -355277./12960, 
      21663109./362880, -790153./10368, 2832933./44800, -205387./5760, 
      3349111./241920, -37895./10368, 2279231./3628800, -3289./51840, 
      7613./2661120, 0}, {0, 0, 0, 0, -406841./71280, 21939781./748440, 
      -292019./4320, 899683./9720, -107151./1280, 19064657./362880, 
      -484291./20736, 1601501./217728, -55591./34560, 36179./155520, 
      -7613./380160, 3103./3991680}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 
      45./32, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, 
      -1375./24, 331./12, -225./32, 2243./3024, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0, 0}, 
     {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384, 0}, 
     {0, 0, 0, 0, 0, 21939781./1496880, -22463./288, 899683./4860, 
      -892925./3456, 170551391./725760, -37275./256, 67776731./1088640, 
      -5225./288, 1072643./311040, -2669./6912, 19301./997920}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, 
      -1087./48, 259./80, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, -2079./16, 
      38045./576, -2849./160, 30083./15120, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960, 0}, {0, 0, 0, 0, 0, 0, -22463./720, 899683./5400, 
      -678623./1728, 515261./960, -540239./1152, 7826203./28800, -30083./288, 
      13871./540, -63373./17280, 6671./28800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 899683./16200, -250019./864, 5667871./8640, 
      -121765./144, 58590763./86400, -33271./96, 178607./1620, -539./27, 
      136111./86400}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, 
      -4819./60, 123./10, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, -1001./2, 
      197579./720, -1599./20, 1828./189, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -35717./432, 515261./1260, -62125./72, 30217./30, 
      -33733./48, 5863./20, -1828./27, 2104./315}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, -7007./16, 
      5535./16, -5447./40, 171./8, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 515261./5040, -7455./16, 211519./240, 
      -14175./16, 59917./120, -1197./8, 46943./2520}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, -3575./24, 
      94./3, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2485./24, 30217./72, -5425./8, 
      39325./72, -658./3, 1265./36}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30217./360, -1155./4, 26741./72, -847./4, 
      8129./180}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -105./2, 143, -259./2, 39}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143./6, -91./2, 65./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -7, 7}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable17[17][17][17] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 
      0, 0, 0, 0, 0, 0, 0}, {0, -1./8, 363./1120, -469./1440, 967./5760, 
      -7./144, 23./2880, -1./1440, 1./40320, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0, 0, 0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0, 0, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 
      0, 0, 0}, {0, -1./14, 1145993./5045040, -9061./29700, 9301169./39916800, 
      -355277./3110400, 1666393./43545600, -112879./12441600, 
      944311./609638400, -793./4147200, 491./29030400, -13./12441600, 
      41./958003200, -1./958003200, 1./87178291200, 0, 0}, 
     {0, 1./15, -1171733./5405400, 30946717./103194000, -406841./1710720, 
      21939781./179625600, -22463./518400, 899683./81648000, -35717./17418240, 
      515261./1828915200, -71./2488320, 2747./1306368000, -1./9123840, 
      1./261273600, -1./12454041600, 1./1307674368000, 0}, 
     {0, -1./16, 1195757./5765760, -13215487./44844800, 
      35118025721./145297152000, -2065639./15966720, 277382447./5748019200, 
      -2271089./174182400, 54576553./20901888000, -4783./12192768, 
      324509./7315660800, -109./29030400, 26921./114960384000, -1./95800320, 
      47./149448499200, -1./174356582400, 1./20922789888000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 
      0, 0, 0, 0, 0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 
      713./1440, -7./80, 127./20160, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0, 0, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0, 0, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, 
      -13481./138240, 35843./2073600, -4433./2073600, 83927./479001600, 
      -13./1520640, 8191./43589145600, 0, 0}, 
     {0, 0, -1171733./2702700, 30946717./17199000, -2847887./855360, 
      21939781./5987520, -696353./259200, 899683./648000, -4536059./8709120, 
      8759437./60963840, -36281./1244160, 936727./217728000, -2047./4561920, 
      13./414720, -8191./6227020800, 5461./217945728000, 0}, 
     {0, 0, 1195757./2882880, -39646461./22422400, 35118025721./10378368000, 
      -2065639./532224, 8598855857./2874009600., -2271089./1382400., 
      6931222231./10450944000, -406555./2032128, 23689157./522547200, 
      -37169./4838400, 55107287./57480192000, -13./152064, 384977./74724249600, 
      -5461./29059430400, 4681./1494484992000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 
      0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, 
      -27./4, 3913./1440, -23./40, 605./12096, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0, 0, 0}, 
     {0, 0, 0, 128977./69300, -412009./50400, 1148963./72576, -48035./2688, 
      13528531./1036800, -20631./3200, 211387./96768, -4043./8064, 
      541519./7257600, -437./67200, 115./456192, 0, 0, 0}, 
     {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 1666393./80640, 
      -33976579./2073600, 21719153./2419200, -95953./27648, 152701./161280, 
      -370513./2073600, 17917./806400, -1495./912384, 289./5322240, 0, 0}, 
     {0, 0, 0, 30946717./17199000, -406841./47520, 21939781./1197504, 
      -22463./960, 38686369./1944000, -821491./69120, 62346581./12192768, 
      -22081./13824, 78292247./217728000, -437./7680, 1495./248832, 
      -289./760320, 2375101./217945728000, 0}, 
     {0, 0, 0, -39646461./22422400, 35118025721./4036032000., -10328195./532224, 
      277382447./10644480, -97656827./4147200, 1255260719./82944000, 
      -14468575./2032128, 100922299./40642560, -3106609./4838400, 
      11764477./96768000, -7475./456192, 13583./9123840, -2375101./29059430400, 
      1190281./581188608000}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 
      0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, 
      -175./8, 783./80, -37./16, 6821./30240, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0, 0, 
      0}, {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 
      314617./5184, -72657./1600, 64639./2880, -88673./12096, 55385./36288, 
      -55591./302400, 253./25920, 0, 0, 0}, 
     {0, 0, 0, 0, 9301169./1663200, -355277./12960, 21663109./362880, 
      -790153./10368, 2832933./44800, -205387./5760, 3349111./241920, 
      -37895./10368, 2279231./3628800, -3289./51840, 7613./2661120, 0, 0}, 
     {0, 0, 0, 0, -406841./71280, 21939781./748440, -292019./4320, 
      899683./9720, -107151./1280, 19064657./362880, -484291./20736, 
      1601501./217728, -55591./34560, 36179./155520, -7613./380160, 
      3103./3991680, 0}, {0, 0, 0, 0, 35118025721./6054048000, -2065639./66528, 
      3605971811./47900160, -2271089./20736, 54576553./512000, -884855./12096, 
      2213475889./60963840, -317735./24192, 1496565311./435456000, -3289./5184, 
      357811./4561920, -3103./532224, 171798901./871782912000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 
      45./32, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384, 0, 0}, 
     {0, 0, 0, 0, 0, 21939781./1496880, -22463./288, 899683./4860, 
      -892925./3456, 170551391./725760, -37275./256, 67776731./1088640, 
      -5225./288, 1072643./311040, -2669./6912, 19301./997920, 0}, 
     {0, 0, 0, 0, 0, -2065639./133056, 277382447./3193344, -2271089./10368, 
      54576553./165888, -7915865./24192, 1622545./7168, -2689357./24192, 
      5626489./145152, -97513./10368, 125443./82944, -19301./133056, 
      8923./1419264}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, 
      -1087./48, 259./80, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, -2079./16, 
      38045./576, -2849./160, 30083./15120, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960, 0, 0}, {0, 0, 0, 0, 0, 0, -22463./720, 899683./5400, 
      -678623./1728, 515261./960, -540239./1152, 7826203./28800, -30083./288, 
      13871./540, -63373./17280, 6671./28800, 0}, 
     {0, 0, 0, 0, 0, 0, 277382447./7983360, -2271089./11520, 
      1036954507./2073600, -23915./32, 352741283./483840, -310541./640, 
      809864443./3628800, -1261./18, 2978531./207360, -6671./3840, 
      5009023./53222400}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 
      8575./72, -21329./480, 4753./720, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 899683./16200, -250019./864, 5667871./8640, 
      -121765./144, 58590763./86400, -33271./96, 178607./1620, -539./27, 
      136111./86400, 0}, {0, 0, 0, 0, 0, 0, 0, -2271089./34560, 
      382035871./1036800, -263065./288, 2271563./1728, -2324861./1920, 
      127955513./172800, -16237./54, 25333./324, -136111./11520, 273217./345600}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, 
      -4819./60, 123./10, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, -1001./2, 
      197579./720, -1599./20, 1828./189, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -35717./432, 515261./1260, -62125./72, 30217./30, 
      -33733./48, 5863./20, -1828./27, 2104./315, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 54576553./518400, -23915./42, 8112725./6048, 
      -3597./2, 129732299./86400, -1599./2, 21479./81, -1052./21, 4992457./1209600}
}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, -7007./16, 
      5535./16, -5447./40, 171./8, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 515261./5040, -7455./16, 211519./240, 
      -14175./16, 59917./120, -1197./8, 46943./2520, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -23915./168, 324509./448, -25179./16, 
      242289./128, -5447./4, 18753./32, -46943./336, 12755./896}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, 
      -3575./24, 94./3, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2485./24, 
      30217./72, -5425./8, 39325./72, -658./3, 1265./36, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324509./2016, -5995./8, 834551./576, 
      -17875./12, 15463./18, -6325./24, 135493./4032}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30217./360, -1155./4, 26741./72, 
      -847./4, 8129./180, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1199./8, 
      296131./480, -12155./12, 39809./48, -8129./24, 8833./160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -105./2, 143, -259./2, 39, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26921./240, -390, 12173./24, -585./2, 
      15149./240}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143./6, -91./2, 65./3, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65, 4277./24, -325./2, 1183./24}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -7, 7, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329./12, -105./2, 301./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15./2, 15./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable18[18][18][18] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0, 0, 0, 0}, {0, -1./12, 83711./332640, -190553./604800, 
      341747./1555200, -139381./1451520, 242537./8709120, -1903./345600, 
      10831./14515200, -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0, 
      0, 0, 0}, {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 
      0, 0, 0, 0}, {0, -1./14, 1145993./5045040, -9061./29700, 
      9301169./39916800, -355277./3110400, 1666393./43545600, 
      -112879./12441600, 944311./609638400, -793./4147200, 491./29030400, 
      -13./12441600, 41./958003200, -1./958003200, 1./87178291200, 0, 0, 0}, 
     {0, 1./15, -1171733./5405400, 30946717./103194000, -406841./1710720, 
      21939781./179625600, -22463./518400, 899683./81648000, -35717./17418240, 
      515261./1828915200, -71./2488320, 2747./1306368000, -1./9123840, 
      1./261273600, -1./12454041600, 1./1307674368000, 0, 0}, 
     {0, -1./16, 1195757./5765760, -13215487./44844800, 
      35118025721./145297152000, -2065639./15966720, 277382447./5748019200, 
      -2271089./174182400, 54576553./20901888000, -4783./12192768, 
      324509./7315660800, -109./29030400, 26921./114960384000, -1./95800320, 
      47./149448499200, -1./174356582400, 1./20922789888000, 0}, 
     {0, 1./17, -143327./720720, 58433327./201801600, -4446371981./18162144000, 
      2195261857./16144128000, -38101097./718502400, 86853967./5748019200, 
      -8424673./2612736000., 76492463./146313216000., -59279./914457600, 
      44941./7315660800, -6341./14370048000, 2713./114960384000, 
      -17./18681062400, 1./41845579776, -1./2615348736000, 1./355687428096000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 
      0, 0, 0, 0, 0, 0, 0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 
      713./1440, -7./80, 127./20160, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0, 0, 0, 
      0}, {0, 0, 83711./166320, -190553./100800, 2392229./777600, 
      -139381./48384, 7518647./4354560, -13321./19200, 1375537./7257600, 
      -187./5376, 511./124416, -341./1209600, 2047./239500800, 0, 0, 0, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0, 0, 0, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, 
      -13481./138240, 35843./2073600, -4433./2073600, 83927./479001600, 
      -13./1520640, 8191./43589145600, 0, 0, 0}, 
     {0, 0, -1171733./2702700, 30946717./17199000, -2847887./855360, 
      21939781./5987520, -696353./259200, 899683./648000, -4536059./8709120, 
      8759437./60963840, -36281./1244160, 936727./217728000, -2047./4561920, 
      13./414720, -8191./6227020800, 5461./217945728000, 0, 0}, 
     {0, 0, 1195757./2882880, -39646461./22422400, 35118025721./10378368000, 
      -2065639./532224, 8598855857./2874009600., -2271089./1382400, 
      6931222231./10450944000, -406555./2032128, 23689157./522547200, 
      -37169./4838400, 55107287./57480192000, -13./152064, 384977./74724249600, 
      -5461./29059430400, 4681./1494484992000, 0}, 
     {0, 0, -143327./360360, 58433327./33633600, -4446371981./1297296000, 
      2195261857./538137600, -1181134007./359251200, 86853967./45619200, 
      -1069933471./1306368000, 1300371871./4877107200, -4327367./65318400, 
      15324881./1219276800, -12980027./7185024000, 35269./182476800, 
      -139247./9340531200, 5461./6974263296, -4681./186810624000, 
      257./697426329600}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 
      0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, -23./40, 
      605./12096, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 128977./69300, -412009./50400, 1148963./72576, -48035./2688, 
      13528531./1036800, -20631./3200, 211387./96768, -4043./8064, 
      541519./7257600, -437./67200, 115./456192, 0, 0, 0, 0}, 
     {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 1666393./80640, 
      -33976579./2073600, 21719153./2419200, -95953./27648, 152701./161280, 
      -370513./2073600, 17917./806400, -1495./912384, 289./5322240, 0, 0, 0}, 
     {0, 0, 0, 30946717./17199000, -406841./47520, 21939781./1197504, 
      -22463./960, 38686369./1944000, -821491./69120, 62346581./12192768, 
      -22081./13824, 78292247./217728000, -437./7680, 1495./248832, 
      -289./760320, 2375101./217945728000, 0, 0}, 
     {0, 0, 0, -39646461./22422400, 35118025721./4036032000., 
      -10328195./532224, 277382447./10644480, -97656827./4147200, 
      1255260719./82944000, -14468575./2032128, 100922299./40642560, 
      -3106609./4838400, 11764477./96768000, -7475./456192, 13583./9123840, 
      -2375101./29059430400, 1190281./581188608000, 0}, 
     {0, 0, 0, 58433327./33633600, -4446371981./504504000, 
      2195261857./107627520, -38101097./1330560, 3734720581./136857600, 
      -193767479./10368000, 9255588023./975421440, -18435769./5080320, 
      1280863441./1219276800, -2771017./12096000, 811187./21897216, 
      -4913./1140480, 2375101./6974263296, -1190281./72648576000, 
      50489./139485265920}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 
      0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 
      314617./5184, -72657./1600, 64639./2880, -88673./12096, 55385./36288, 
      -55591./302400, 253./25920, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 9301169./1663200, -355277./12960, 21663109./362880, 
      -790153./10368, 2832933./44800, -205387./5760, 3349111./241920, 
      -37895./10368, 2279231./3628800, -3289./51840, 7613./2661120, 0, 0, 0}, 
     {0, 0, 0, 0, -406841./71280, 21939781./748440, -292019./4320, 
      899683./9720, -107151./1280, 19064657./362880, -484291./20736, 
      1601501./217728, -55591./34560, 36179./155520, -7613./380160, 
      3103./3991680, 0, 0}, {0, 0, 0, 0, 35118025721./6054048000, 
      -2065639./66528, 3605971811./47900160, -2271089./20736, 54576553./512000, 
      -884855./12096, 2213475889./60963840, -317735./24192, 
      1496565311./435456000, -3289./5184, 357811./4561920, -3103./532224, 
      171798901./871782912000, 0}, 
     {0, 0, 0, 0, -4446371981./756756000, 2195261857./67267200, 
      -495314261./5987520, 86853967./684288, -8424673./64000, 
      2830221131./29030400, -404342059./7620480, 131003015./6096384, 
      -352502531./54432000, 8923057./6220800, -129421./570240, 77575./3193344, 
      -171798901./108972864000, 4084337./87178291200}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, 
      -331./32, 45./32, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 21939781./1496880, -22463./288, 899683./4860, 
      -892925./3456, 170551391./725760, -37275./256, 67776731./1088640, 
      -5225./288, 1072643./311040, -2669./6912, 19301./997920, 0, 0}, 
     {0, 0, 0, 0, 0, -2065639./133056, 277382447./3193344, -2271089./10368, 
      54576553./165888, -7915865./24192, 1622545./7168, -2689357./24192, 
      5626489./145152, -97513./10368, 125443./82944, -19301./133056, 
      8923./1419264, 0}, {0, 0, 0, 0, 0, 2195261857./134534400, 
      -38101097./399168, 86853967./342144, -8424673./20736, 
      25319005253./58060800, -296395./896, 1108829293./6096384, -1325269./18144, 
      264552769./12441600, -45373./10368, 482525./798336, -8923./177408, 
      332514803./174356582400}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, 
      -1087./48, 259./80, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, -2079./16, 
      38045./576, -2849./160, 30083./15120, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -22463./720, 899683./5400, 
      -678623./1728, 515261./960, -540239./1152, 7826203./28800, -30083./288, 
      13871./540, -63373./17280, 6671./28800, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 277382447./7983360, -2271089./11520, 
      1036954507./2073600, -23915./32, 352741283./483840, -310541./640, 
      809864443./3628800, -1261./18, 2978531./207360, -6671./3840, 
      5009023./53222400, 0}, {0, 0, 0, 0, 0, 0, -38101097./997920, 
      86853967./380160, -160068787./259200, 76492463./76800, -64436273./60480, 
      18290987./23040, -190756303./453600, 3421093./21600, -1077341./25920, 
      33355./4608, -5009023./6652800, 89809./2534400}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 
      0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, 
      -2541./16, 8575./72, -21329./480, 4753./720, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 899683./16200, -250019./864, 5667871./8640, 
      -121765./144, 58590763./86400, -33271./96, 178607./1620, -539./27, 
      136111./86400, 0, 0}, {0, 0, 0, 0, 0, 0, 0, -2271089./34560, 
      382035871./1036800, -263065./288, 2271563./1728, -2324861./1920, 
      127955513./172800, -16237./54, 25333./324, -136111./11520, 273217./345600, 
      0}, {0, 0, 0, 0, 0, 0, 0, 86853967./1140480, -58972711./129600, 
      841417093./691200, -414953./216, 136935227./69120, -30138773./21600, 
      44050981./64800, -18326./81, 680555./13824, -273217./43200, 
      2769673./7603200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, 
      -4819./60, 123./10, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, -1001./2, 
      197579./720, -1599./20, 1828./189, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -35717./432, 515261./1260, -62125./72, 30217./30, 
      -33733./48, 5863./20, -1828./27, 2104./315, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 54576553./518400, -23915./42, 8112725./6048, 
      -3597./2, 129732299./86400, -1599./2, 21479./81, -1052./21, 
      4992457./1209600, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -8424673./64800, 
      76492463./100800, -1481975./756, 494351./168, -30557279./10800, 
      1446029./800, -62152./81, 13150./63, -4992457./151200, 77761./33600}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 
      419./20, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, 
      -7007./16, 5535./16, -5447./40, 171./8, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 515261./5040, -7455./16, 211519./240, 
      -14175./16, 59917./120, -1197./8, 46943./2520, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -23915./168, 324509./448, -25179./16, 
      242289./128, -5447./4, 18753./32, -46943./336, 12755./896, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 76492463./403200, -59279./56, 494351./192, 
      -57069./16, 14777711./4800, -6783./4, 1173575./2016, -12755./112, 
      186653./19200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, 
      -3575./24, 94./3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2485./24, 30217./72, -5425./8, 39325./72, 
      -658./3, 1265./36, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324509./2016, 
      -5995./8, 834551./576, -17875./12, 15463./18, -6325./24, 135493./4032, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -59279./252, 2471755./2016, -196571./72, 
      1939795./576, -22372./9, 158125./144, -135493./504, 113465./4032}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30217./360, -1155./4, 
      26741./72, -847./4, 8129./180, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1199./8, 296131./480, -12155./12, 
      39809./48, -8129./24, 8833./160, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494351./2016, -69751./60, 6595303./2880, 
      -14399./6, 203225./144, -8833./20, 1158509./20160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -105./2, 143, -259./2, 39, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26921./240, -390, 12173./24, 
      -585./2, 15149./240, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6341./30, 
      35269./40, -4403./3, 4875./4, -15149./30, 3341./40}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143./6, -91./2, 65./3, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65, 4277./24, -325./2, 1183./24, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35269./240, -1547./3, 
      8125./12, -1183./3, 6877./80}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -7, 7, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329./12, -105./2, 301./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -238./3, 875./4, -602./3, 
      245./4}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15./2, 15./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125./4, -60, 115./4}},
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -8, 8}},
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

// export ratio tables
const double    *evalRetessTables[NV_PATCH_MAX_RETESS] = {
    NULL,
    NULL,
    &rtable2[0][0][0],
    &rtable3[0][0][0],
    &rtable4[0][0][0],
    &rtable5[0][0][0],
    &rtable6[0][0][0],
    &rtable7[0][0][0],
    &rtable8[0][0][0],
    &rtable9[0][0][0],
    &rtable10[0][0][0],
    &rtable11[0][0][0],
    &rtable12[0][0][0],
    &rtable13[0][0][0],
    &rtable14[0][0][0],
    &rtable15[0][0][0],
    &rtable16[0][0][0],
    //ff&rtable17[0][0][0],
    //ff&rtable18[0][0][0],
};

/*****************************************************************************/
// Exports
float *bsplineBasis[16] = {
    &bsplineBasis1[0][0],
    &bsplineBasis2[0][0],
    &bsplineBasis3[0][0],
    &bsplineBasis4[0][0],
    &bsplineBasis5[0][0],
    &bsplineBasis6[0][0],
    &bsplineBasis7[0][0],
    &bsplineBasis8[0][0],
    &bsplineBasis9[0][0],
    &bsplineBasis10[0][0],
    &bsplineBasis11[0][0],
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

float *catmullRomBasis[16] = {
    NULL,
    NULL,
    NULL,
    &catmullRomBasis4[0][0],
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

float *bezBasis[16] = {
    &bezBasis1[0][0],
    &bezBasis2[0][0],
    &bezBasis3[0][0],
    &bezBasis4[0][0],
    &bezBasis5[0][0],
    &bezBasis6[0][0],
    &bezBasis7[0][0],
    &bezBasis8[0][0],
    &bezBasis9[0][0],
    &bezBasis10[0][0],
    &bezBasis11[0][0],
    &bezBasis12[0][0],
    &bezBasis13[0][0],
    &bezBasis14[0][0],
    &bezBasis15[0][0],
    &bezBasis16[0][0],
};

#if 0
float *invBezBasis[16] = {
    &invBezBasis1[0][0],
    &invBezBasis2[0][0],
    &invBezBasis3[0][0],
    &invBezBasis4[0][0],
    &invBezBasis5[0][0],
    &invBezBasis6[0][0],
    &invBezBasis7[0][0],
    &invBezBasis8[0][0],
    &invBezBasis9[0][0],
    &invBezBasis10[0][0],
    &invBezBasis11[0][0],
    &invBezBasis12[0][0],
    &invBezBasis13[0][0],
    &invBezBasis14[0][0],
    &invBezBasis15[0][0],
    &invBezBasis16[0][0],
};
#endif

float *powerToFD[16] = {
    &powerToFD1[0][0],
    &powerToFD2[0][0],
    &powerToFD3[0][0],
    &powerToFD4[0][0],
    &powerToFD5[0][0],
    &powerToFD6[0][0],
    &powerToFD7[0][0],
    &powerToFD8[0][0],
    &powerToFD9[0][0],
    &powerToFD10[0][0],
    &powerToFD11[0][0],
    &powerToFD12[0][0],
    &powerToFD13[0][0],
    &powerToFD14[0][0],
    &powerToFD15[0][0],
    &powerToFD16[0][0],
};

float *inversePowerToFD[16] = {
    &inversePowerToFD1[0][0],
    &inversePowerToFD2[0][0],
    &inversePowerToFD3[0][0],
    &inversePowerToFD4[0][0],
    &inversePowerToFD5[0][0],
    &inversePowerToFD6[0][0],
    &inversePowerToFD7[0][0],
    &inversePowerToFD8[0][0],
    &inversePowerToFD9[0][0],
    &inversePowerToFD10[0][0],
    &inversePowerToFD11[0][0],
    &inversePowerToFD12[0][0],
    &inversePowerToFD13[0][0],
    &inversePowerToFD14[0][0],
    &inversePowerToFD15[0][0],
    &inversePowerToFD16[0][0],
};

#if 0
// Inverse Bezier basis matrices
static float invBezBasis1[1][1] = {
    {1},
};

static float invBezBasis2[2][2] = {
    {0, 1},
    {1, 1},
};

static float invBezBasis3[3][3] = {
    {0,     0, 1},
    {0, 1.0/2, 1},
    {1,     1, 1},
};

static float invBezBasis4[4][4] = {
    {0,     0,     0, 1},
    {0,     0, 1.0/3, 1},
    {0, 1.0/3, 2.0/3, 1},
    {1,     1,     1, 1},
};

static float invBezBasis5[5][5] = {
    {0, 0, 0, 0, 1},
    {0, 0, 0, 1.0/4, 1},
    {0, 0, 1.0/6, 1.0/2, 1},
    {0, 1.0/4, 1.0/2, 3.0/4, 1},
    {1, 1, 1, 1, 1},
};

static float invBezBasis6[6][6] = {
    {0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 1.0/5, 1},
    {0, 0, 0, 1.0/10, 2.0/5, 1},
    {0, 0, 1.0/10, 3.0/10, 3.0/5, 1},
    {0, 1.0/5, 2.0/5, 3.0/5, 4.0/5, 1},
    {1, 1, 1, 1, 1, 1},
};

static float invBezBasis7[7][7] = {
    {0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 1.0/6, 1},
    {0, 0, 0, 0, 1.0/15, 1.0/3, 1},{0, 0, 0, 1.0/20, 1.0/5, 1.0/2, 1},
    {0, 0, 1.0/15, 1.0/5, 2.0/5, 2.0/3, 1},{0, 1.0/6, 1.0/3, 1.0/2, 2.0/3, 5.0/6, 1},
    {1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis8[8][8] = {
    {0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 1.0/7, 1},{0, 0, 0, 0, 0, 1.0/21, 2.0/7, 1},
    {0, 0, 0, 0, 1.0/35, 1.0/7, 3.0/7, 1},{0, 0, 0, 1.0/35, 4.0/35, 2.0/7, 4.0/7, 1},
    {0, 0, 1.0/21, 1.0/7, 2.0/7, 10.0/21, 5.0/7, 1},
    {0, 1.0/7, 2.0/7, 3.0/7, 4.0/7, 5.0/7, 6.0/7, 1},{1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis9[9][9] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 0, 0, 1.0/8, 1},
    {0, 0, 0, 0, 0, 0, 1.0/28, 1.0/4, 1},{0, 0, 0, 0, 0, 1.0/56, 3.0/28, 3.0/8, 1},
    {0, 0, 0, 0, 1.0/70, 1.0/14, 3.0/14, 1.0/2, 1},
    {0, 0, 0, 1.0/56, 1.0/14, 5.0/28, 5.0/14, 5.0/8, 1},
    {0, 0, 1.0/28, 3.0/28, 3.0/14, 5.0/14, 15.0/28, 3.0/4, 1},
    {0, 1.0/8, 1.0/4, 3.0/8, 1.0/2, 5.0/8, 3.0/4, 7.0/8, 1},{1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis10[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 0, 0, 0, 1.0/9, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/36, 2.0/9, 1},
    {0, 0, 0, 0, 0, 0, 1.0/84, 1.0/12, 1.0/3, 1},
    {0, 0, 0, 0, 0, 1.0/126, 1.0/21, 1.0/6, 4.0/9, 1},
    {0, 0, 0, 0, 1.0/126, 5.0/126, 5.0/42, 5.0/18, 5.0/9, 1},
    {0, 0, 0, 1.0/84, 1.0/21, 5.0/42, 5.0/21, 5.0/12, 2.0/3, 1},
    {0, 0, 1.0/36, 1.0/12, 1.0/6, 5.0/18, 5.0/12, 7.0/12, 7.0/9, 1},
    {0, 1.0/9, 2.0/9, 1.0/3, 4.0/9, 5.0/9, 2.0/3, 7.0/9, 8.0/9, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis11[11][11] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/10, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/45, 1.0/5, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/120, 1.0/15, 3.0/10, 1},
    {0, 0, 0, 0, 0, 0, 1.0/210, 1.0/30, 2.0/15, 2.0/5, 1},
    {0, 0, 0, 0, 0, 1.0/252, 1.0/42, 1.0/12, 2.0/9, 1.0/2, 1},
    {0, 0, 0, 0, 1.0/210, 1.0/42, 1.0/14, 1.0/6, 1.0/3, 3.0/5, 1},
    {0, 0, 0, 1.0/120, 1.0/30, 1.0/12, 1.0/6, 7.0/24, 7.0/15, 7.0/10, 1},
    {0, 0, 1.0/45, 1.0/15, 2.0/15, 2.0/9, 1.0/3, 7.0/15, 28.0/45, 4.0/5, 1},
    {0, 1.0/10, 1.0/5, 3.0/10, 2.0/5, 1.0/2, 3.0/5, 7.0/10, 4.0/5, 9.0/10, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis12[12][12] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/11, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/55, 2.0/11, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/165, 3.0/55, 3.0/11, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/330, 4.0/165, 6.0/55, 4.0/11, 1},
    {0, 0, 0, 0, 0, 0, 1.0/462, 1.0/66, 2.0/33, 2.0/11, 5.0/11, 1},
    {0, 0, 0, 0, 0, 1.0/462, 1.0/77, 1.0/22, 4.0/33, 3.0/11, 6.0/11, 1},
    {0, 0, 0, 0, 1.0/330, 1.0/66, 1.0/22, 7.0/66, 7.0/33, 21.0/55, 7.0/11, 1},
    {0, 0, 0, 1.0/165, 4.0/165, 2.0/33, 4.0/33, 7.0/33, 56.0/165, 28.0/55, 8.0/11, 1},
    {0, 0, 1.0/55, 3.0/55, 6.0/55, 2.0/11, 3.0/11, 21.0/55, 28.0/55, 36.0/55, 9.0/11, 1},
    {0, 1.0/11, 2.0/11, 3.0/11, 4.0/11, 5.0/11, 6.0/11, 7.0/11, 8.0/11, 9.0/11, 10.0/11, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis13[13][13] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/12, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/66, 1.0/6, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/220, 1.0/22, 1.0/4, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/495, 1.0/55, 1.0/11, 1.0/3, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/792, 1.0/99, 1.0/22, 5.0/33, 5.0/12, 1},
    {0, 0, 0, 0, 0, 0, 1.0/924, 1.0/132, 1.0/33, 1.0/11, 5.0/22, 1.0/2, 1},
    {0, 0, 0, 0, 0, 1.0/792, 1.0/132, 7.0/264, 7.0/99, 7.0/44, 7.0/22, 7.0/12, 1},
    {0, 0, 0, 0, 1.0/495, 1.0/99, 1.0/33, 7.0/99, 14.0/99, 14.0/55, 14.0/33, 2.0/3, 1},
    {0, 0, 0, 1.0/220, 1.0/55, 1.0/22, 1.0/11, 7.0/44, 14.0/55, 21.0/55, 6.0/11, 3.0/4, 1},
    {0, 0, 1.0/66, 1.0/22, 1.0/11, 5.0/33, 5.0/22, 7.0/22, 14.0/33, 6.0/11, 15.0/22, 5.0/6, 1},
    {0, 1.0/12, 1.0/6, 1.0/4, 1.0/3, 5.0/12, 1.0/2, 7.0/12, 2.0/3, 3.0/4, 5.0/6, 11.0/12, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis14[14][14] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/78, 2.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/286, 1.0/26, 3.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/715, 2.0/143, 1.0/13, 4.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/1287, 1.0/143, 5.0/143, 5.0/39, 5.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/1716, 2.0/429, 3.0/143, 10.0/143, 5.0/26, 6.0/13, 1},
    {0, 0, 0, 0, 0, 0, 1.0/1716, 7.0/1716, 7.0/429, 7.0/143, 35.0/286, 7.0/26, 7.0/13, 1},
    {0, 0, 0, 0, 0, 1.0/1287, 2.0/429, 7.0/429, 56.0/1287, 14.0/143, 28.0/143, 14.0/39, 
    8.0/13, 1},{0, 0, 0, 0, 1.0/715, 1.0/143, 3.0/143, 7.0/143, 14.0/143, 126.0/715, 
    42.0/143, 6.0/13, 9.0/13, 1},{0, 0, 0, 1.0/286, 2.0/143, 5.0/143, 10.0/143, 35.0/286, 
    28.0/143, 42.0/143, 60.0/143, 15.0/26, 10.0/13, 1},
    {0, 0, 1.0/78, 1.0/26, 1.0/13, 5.0/39, 5.0/26, 7.0/26, 14.0/39, 6.0/13, 15.0/26, 55.0/78, 
    11.0/13, 1},{0, 1.0/13, 2.0/13, 3.0/13, 4.0/13, 5.0/13, 6.0/13, 7.0/13, 8.0/13, 9.0/13, 
    10.0/13, 11.0/13, 12.0/13, 1},{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis15[15][15] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/14, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/91, 1.0/7, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/364, 3.0/91, 3.0/14, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/1001, 1.0/91, 6.0/91, 2.0/7, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/2002, 5.0/1001, 5.0/182, 10.0/91, 5.0/14, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/3003, 3.0/1001, 15.0/1001, 5.0/91, 15.0/91, 3.0/7, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/3432, 1.0/429, 3.0/286, 5.0/143, 5.0/52, 3.0/13, 1.0/2, 1},
    {0, 0, 0, 0, 0, 0, 1.0/3003, 1.0/429, 4.0/429, 4.0/143, 10.0/143, 2.0/13, 4.0/13, 4.0/7, 
    1},{0, 0, 0, 0, 0, 1.0/2002, 3.0/1001, 3.0/286, 4.0/143, 9.0/143, 18.0/143, 3.0/13, 
    36.0/91, 9.0/14, 1},{0, 0, 0, 0, 1.0/1001, 5.0/1001, 15.0/1001, 5.0/143, 10.0/143, 
    18.0/143, 30.0/143, 30.0/91, 45.0/91, 5.0/7, 1},
    {0, 0, 0, 1.0/364, 1.0/91, 5.0/182, 5.0/91, 5.0/52, 2.0/13, 3.0/13, 30.0/91, 165.0/364, 
    55.0/91, 11.0/14, 1},{0, 0, 1.0/91, 3.0/91, 6.0/91, 10.0/91, 15.0/91, 3.0/13, 4.0/13, 
    36.0/91, 45.0/91, 55.0/91, 66.0/91, 6.0/7, 1},
    {0, 1.0/14, 1.0/7, 3.0/14, 2.0/7, 5.0/14, 3.0/7, 1.0/2, 4.0/7, 9.0/14, 5.0/7, 11.0/14, 6.0/7, 
    13.0/14, 1},{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis16[16][16] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/105, 2.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/455, 1.0/35, 1.0/5, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/1365, 4.0/455, 2.0/35, 4.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/3003, 1.0/273, 2.0/91, 2.0/21, 1.0/3, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/5005, 2.0/1001, 1.0/91, 4.0/91, 1.0/7, 2.0/5, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/6435, 1.0/715, 1.0/143, 1.0/39, 1.0/13, 1.0/5, 7.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/6435, 8.0/6435, 4.0/715, 8.0/429, 2.0/39, 8.0/65, 4.0/15, 
    8.0/15, 1},
    {0, 0, 0, 0, 0, 0, 1.0/5005, 1.0/715, 4.0/715, 12.0/715, 6.0/143, 6.0/65, 
    12.0/65, 12.0/35, 3.0/5, 1},
    {0, 0, 0, 0, 0, 1.0/3003, 2.0/1001, 1.0/143, 8.0/429, 
    6.0/143, 12.0/143, 2.0/13, 24.0/91, 3.0/7, 2.0/3, 1},
    {0, 0, 0, 0, 1.0/1365, 1.0/273, 1.0/91, 1.0/39, 2.0/39, 6.0/65, 2.0/13, 22.0/91, 33.0/91, 
    11.0/21, 11.0/15, 1},
    {0, 0, 0, 1.0/455, 4.0/455, 2.0/91, 4.0/91, 1.0/13, 8.0/65, 12.0/65, 
    24.0/91, 33.0/91, 44.0/91, 22.0/35, 4.0/5, 1},
    {0, 0, 1.0/105, 1.0/35, 2.0/35, 2.0/21, 1.0/7, 1.0/5, 4.0/15, 12.0/35, 3.0/7, 11.0/21, 22.0/35, 
    26.0/35, 13.0/15, 1},
    {0, 1.0/15, 2.0/15, 1.0/5, 4.0/15, 1.0/3, 2.0/5, 7.0/15, 8.0/15, 3.0/5, 
    2.0/3, 11.0/15, 4.0/5, 13.0/15, 14.0/15, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvPM.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvPM.h"

/*
#undef NV_PRAMDAC_TEST_CONTROL
#undef NV_PRAMDAC_CHECKSUM
#include "..\..\resman\kernel\inc\nv_ref.h"
#include "..\..\resman\kernel\inc\nv10\nv10_ref.h"
*/
#include "..\..\..\common\nv10\inc\nv10ppm.h"
#include <stdio.h>

/*
 * build specific aliases (aliaii?)
 */
#ifdef NVDD32

#define pmAllocMemory       AllocIPM
#define pmFreeMemory        FreeIPM

#define writeMethod140()                                                    \
    nvglSetObject(NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);                 \
    nvPushData (0,0x0004e140);                                              \
    nvPushData (1,0x00000001);                                              \
    nvPusherAdjust (2);                                                     \
    pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE;

#define flush()  getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

#elif defined(IS_OPENGL)

#define pmAllocMemory       malloc
#define pmFreeMemory        free

#define writeMethod140()                    \
{                                           \
    __GL_SETUP();                           \
    __GLNV_SETUP();                         \
    NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();  \
    nvCurrent[0].u = 0x0004e140;            \
    nvCurrent[1].u = 0x00000001;            \
    nvCurrent += 2;                         \
    NV_GET_SKID_SPACE_IF_NEEDED();          \
}

#define flush()                             \
{                                           \
    __GL_SETUP();                           \
    if (gc) (*gc->procs.finish)(gc);        \
}

#define DPF(_a, _b, _c, _d)

// define TRACE_QUAKE in nvTrace.h
extern int InQuake;
int reset = 1;

#else

#define pmAllocMemory       malloc
#define pmFreeMemory        free

#define writeMethod140()                    _error_
#define flush()                             _error_

#endif

/*
 * macros
 */
#define rdtsc  __asm _emit 0x0f __asm _emit 0x31

/*
 * globals
 */
DWORD g_dwPMTrigger      = PM_REG_PMTRIGGER_DISABLED;
DWORD g_dwPMTriggerCount = 0;
DWORD g_dwPMTriggerValue = 0;

HANDLE         hPMFile              = 0;
PM_PGM_HEADER *pbPMProgramSetup     = NULL;
PM_PGM_HEADER *pbPMProgramStart     = NULL;
PM_PGM_HEADER *pbPMProgramSample    = NULL;
BYTE          *pbPMEventBuffer      = NULL;
DWORD          dwPMEventBufferIndex = 0;
DWORD          dwPMHWLinearBase     = 0;
DWORD          dwPMHWArch           = 0;
DWORD          dwPMFirstTrigger     = 1;
DWORD          dwPMFlags            = 0;

/*
 * pmFlush
 *
 * commit capture buffer to disk
 */
void pmFlush
(
    void
)
{
#ifdef WINNT
#else
    /*
     * commit to disk
     */
    if (dwPMEventBufferIndex)
    {
        DWORD dw;
        WriteFile (hPMFile,pbPMEventBuffer,dwPMEventBufferIndex * sizeof(PM_LOG_EVENT),&dw,NULL);
        FlushFileBuffers (hPMFile);

        /*
         * reset
         */
        dwPMEventBufferIndex = 0;
    }
#endif
}

/*
 * pmLogEvent
 *
 * writes a single event into the log
 */
void pmLogEvent
(
    PM_LOG_EVENT *pEvent
)
{
#ifdef WINNT
#else
    /*
     * store it
     */
    ((PM_LOG_EVENT*)pbPMEventBuffer)[dwPMEventBufferIndex++] = *pEvent;

    /*
     * flush?
     */
    if (dwPMEventBufferIndex >= PM_LOG_EVENT_BUFFER_SIZE)
    {
        pmFlush();
    }
#endif
}

/*
 * pmExecuteProgram
 *
 * executes a program
 */
void pmExecuteProgram
(
    PM_PGM_HEADER *pPgm
)
{
#ifdef WINNT
#else
    /*
     * for all entries
     */
    DWORD dwIndex = 0;
    DWORD dwCount = pPgm->dwEntryCount;
    for (; dwCount; dwIndex++, dwCount--)
    {
        PM_PGM_ENTRY *pEntry = pPgm->Entry + dwIndex;

        if (pEntry->dwFlags & PM_PGM_FLAG_READ)
        {
            PM_LOG_EVENT event;

            /*
             * read operation
             */
            switch (pEntry->dwFlags & PM_PGM_MASK_SIZE)
            {
                case PM_PGM_VAL_SIZE_8:
                {
                    event.dwValueHi = 0;
                    event.dwValueLo = (DWORD)*(BYTE*)(dwPMHWLinearBase + pEntry->dwOffset);
                    DPF ("---pmread8(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
                case PM_PGM_VAL_SIZE_16:
                {
                    event.dwValueHi = 0;
                    event.dwValueLo = (DWORD)*(WORD*)(dwPMHWLinearBase + pEntry->dwOffset);
                    DPF ("---pmread16(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
                case PM_PGM_VAL_SIZE_32:
                {
                    event.dwValueHi = 0;
                    event.dwValueLo = (DWORD)*(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset);
                    DPF ("---pmread32(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
                case PM_PGM_VAL_SIZE_40:
                {
                    DWORD hi;
                    event.dwValueHi = (DWORD)*(BYTE*)(dwPMHWLinearBase + pEntry->dwOffset + 4);
                    do
                    {
                        hi = event.dwValueHi;
                        event.dwValueLo = (DWORD)*(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset);
                        event.dwValueHi = (DWORD)*(BYTE*) (dwPMHWLinearBase + pEntry->dwOffset + 4);
                    } while (hi != event.dwValueHi);
                    DPF ("---pmread40(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
            }

            /*
             * log it
             */
            pmLogEvent (&event);
        }
        else
        {
            /*
             * write operation
             */
            switch (pEntry->dwFlags & PM_PGM_MASK_SIZE)
            {
                case PM_PGM_VAL_SIZE_8:
                {
                    DPF ("---pmwrite8(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(BYTE*)(dwPMHWLinearBase + pEntry->dwOffset) = (BYTE)pEntry->dwValueLo;
                    break;
                }
                case PM_PGM_VAL_SIZE_16:
                {
                    DPF ("---pmwrite16(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(WORD*)(dwPMHWLinearBase + pEntry->dwOffset) = (WORD)pEntry->dwValueLo;
                    break;
                }
                case PM_PGM_VAL_SIZE_32:
                {
                    DPF ("---pmwrite32(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset) = (DWORD)pEntry->dwValueLo;
                    break;
                }
                case PM_PGM_VAL_SIZE_40:
                {
                    DPF ("---pmwrite40(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(BYTE*) (dwPMHWLinearBase + pEntry->dwOffset + 4) = (BYTE) pEntry->dwValueHi;
                    *(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset)     = (DWORD)pEntry->dwValueLo;
                    break;
                }
            }
        }
    }
#endif
}

/*
 * pmConnect
 *
 * connect to PM host (Locutus II)
 */
BOOL pmConnect
(
#if defined(IS_OPENGL)
    HDC hEscapeDC,
#else
    DWORD dwHeadNumber,
#endif
    DWORD dwHWLinearBase,
    DWORD dwArch
)
{
#ifdef WINNT
    return FALSE;
#else
    /*
     * open registry
     */
    DWORD dwSize  = sizeof(DWORD);
    DWORD dwType  = REG_DWORD;
    DWORD dwValue;
    HKEY  hKey;
    HKEY  hPrimaryKey;
    char  szLocalRegPath[128];
    char  szD3DSubKey[256];
    char  szLogFileName[256] = "\\lc2.tmp";
    PM_LOG_HEADER hdr;

    /*
     * save constants
     */
    dwPMHWArch       = dwArch;
    dwPMHWLinearBase = dwHWLinearBase;

    /*
     * get the registry path for this particular device
     * (of the many devices possible in a multi-mon configuration)
     */
#if defined(IS_OPENGL)
    ExtEscape (hEscapeDC,NV_ESC_GET_LOCAL_REGISTRY_PATH,0,NULL,128,szLocalRegPath);
#else
    MyExtEscape (dwHeadNumber,NV_ESC_GET_LOCAL_REGISTRY_PATH,0,NULL,128,szLocalRegPath);
#endif

    /*
     * the first DWORD of the value returned is the primary key (e.g. HKEY_LOCAL_MACHINE)
     */
    hPrimaryKey = (HKEY)(*(DWORD*)szLocalRegPath);

    /*
     * the NV subkey for this device starts after the first four bytes.
     * concatenate this with driver's subtree's name
     */
    sprintf (szD3DSubKey,"%s\\%s",szLocalRegPath + 4,PM_REGISTRY_SUBKEY);

    /*
     * finally open the key
     */
    if (RegOpenKeyEx(hPrimaryKey,szD3DSubKey,0,KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS)
    {
        /*
         * read master switch
         */
        DWORD dwConnectCount;
        if (!RegQueryValueEx(hKey,
                             PM_REG_CONNECTCOUNT,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwConnectCount,
                             &dwSize) == ERROR_SUCCESS)
        {
            dwConnectCount = 0;
        }

        //
        // read type of trigger
        //
        if (RegQueryValueEx(hKey,
                            PM_REG_PMTRIGGER,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > PM_REG_PMTRIGGER_MAX) dwValue = PM_REG_PMTRIGGER_DISABLED;
            g_dwPMTrigger = dwValue;
        }

        /*
         * if enabled, read other information
         */
        if (dwConnectCount && (g_dwPMTrigger != PM_REG_PMTRIGGER_DISABLED))
        {
            /*
             * decrement master switch
             */
            dwConnectCount--;
            RegSetValueEx(hKey,
                          PM_REG_CONNECTCOUNT,
                          (unsigned long)NULL,
                          dwType,
                          (LPBYTE)&dwConnectCount,
                          dwSize);

            /*
             * read log file name
             */
            dwType = REG_SZ;
            dwSize = sizeof(szLocalRegPath);
            if (RegQueryValueEx(hKey,
                                PM_REG_LOGFILENAME,
                                NULL,
                                &dwType,
                                (LPBYTE)szLogFileName,
                                &dwSize) != ERROR_SUCCESS)
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }

            /*
             * read PM trigger count
             */
            dwType = REG_DWORD;
            dwSize = sizeof(DWORD);
            if (RegQueryValueEx(hKey,
                                PM_REG_TRIGGERCOUNT,
                                NULL,
                                &dwType,
                                (LPBYTE)&g_dwPMTriggerCount,
                                &dwSize) != ERROR_SUCCESS)
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }
            g_dwPMTriggerValue = g_dwPMTriggerCount;

            /*
             * read PM flags
             */
            // no error checking on this for backwards compatability
            dwType = REG_DWORD;
            dwSize = sizeof(DWORD);
            RegQueryValueEx(hKey,
                                PM_REG_FLAGS,
                                NULL,
                                &dwType,
                                (LPBYTE)&dwPMFlags,
                                &dwSize);

            /*
             * read programs
             */
            dwType = REG_BINARY;
            if (RegQueryValueEx(hKey,
                                PM_REG_PROGRAM_SETUP,
                                NULL,
                                &dwType,
                                NULL,
                                &dwSize) == ERROR_SUCCESS)
            {
                pbPMProgramSetup = (PM_PGM_HEADER*)pmAllocMemory(dwSize);
                if (RegQueryValueEx(hKey,
                                    PM_REG_PROGRAM_SETUP,
                                    NULL,
                                    &dwType,
                                    (BYTE*)pbPMProgramSetup,
                                    &dwSize) != ERROR_SUCCESS)
                {
                    pmDisconnect();
                    g_dwPMTrigger = 0;
                    return FALSE;
                }
            }
            else
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }

            if (RegQueryValueEx(hKey,
                                PM_REG_PROGRAM_START,
                                NULL,
                                &dwType,
                                NULL,
                                &dwSize) == ERROR_SUCCESS)
            {
                pbPMProgramStart = (PM_PGM_HEADER*)pmAllocMemory(dwSize);
                if (RegQueryValueEx(hKey,
                                    PM_REG_PROGRAM_START,
                                    NULL,
                                    &dwType,
                                    (BYTE*)pbPMProgramStart,
                                    &dwSize) != ERROR_SUCCESS)
                {
                    pmDisconnect();
                    g_dwPMTrigger = 0;
                    return FALSE;
                }
            }
            else
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }

            if (RegQueryValueEx(hKey,
                                PM_REG_PROGRAM_SAMPLE,
                                NULL,
                                &dwType,
                                NULL,
                                &dwSize) == ERROR_SUCCESS)
            {
                pbPMProgramSample = (PM_PGM_HEADER*)pmAllocMemory(dwSize);
                if (RegQueryValueEx(hKey,
                                    PM_REG_PROGRAM_SAMPLE,
                                    NULL,
                                    &dwType,
                                    (BYTE*)pbPMProgramSample,
                                    &dwSize) != ERROR_SUCCESS)
                {
                    pmDisconnect();
                    g_dwPMTrigger = 0;
                    return FALSE;
                }
            }
            else
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }
        }
        else
        {
            pmDisconnect();
            g_dwPMTrigger = 0;
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    else
    {
        pmDisconnect();
        g_dwPMTrigger = 0;
        return FALSE;
    }

    /*
     * enable PM
     */
    switch (dwPMHWArch)
    {
        case 0x10:        
        case 0x20:
        {
            //
            // enable PM_TRIGGER bit for nv10/nv20
            //
            #define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
            #define NV_PGRAPH_DEBUG_3_PM_TRIGGER_ENABLED             0x00000001 /* RW--V */
            #define NV_PGRAPH_DEBUG_3_PM_TRIGGER                          15:15 /* RWIVF */

            DWORD dwAddr = dwPMHWLinearBase + NV_PGRAPH_DEBUG_3;
            DWORD dwBits = *(DWORD*)dwAddr;
            dwBits |= NV_PGRAPH_DEBUG_3_PM_TRIGGER_ENABLED << (0 ? NV_PGRAPH_DEBUG_3_PM_TRIGGER);
            *(DWORD*)dwAddr = dwBits;
            break;
        }                
        default: // HW not supported
        {
            pmDisconnect();
            return FALSE;
        }
    }

    /*
     * open log file
     */
    hPMFile = CreateFile(szLogFileName,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (hPMFile == INVALID_HANDLE_VALUE)
    {
        hPMFile = NULL;
        pmDisconnect();
        return FALSE;
    }

    /*
     * write header
     */
    strcpy (hdr.szID,PM_LOG_ID);
    hdr.dwVersion = PM_LOG_VERSION;
    WriteFile (hPMFile,&hdr,sizeof(hdr) - sizeof(hdr.Event),&dwValue,NULL);

    /*
     * create event buffer
     */
    pbPMEventBuffer = (BYTE*)pmAllocMemory(sizeof(PM_LOG_EVENT) * PM_LOG_EVENT_BUFFER_SIZE);
    if (!pbPMEventBuffer)
    {
        pmDisconnect();
        return FALSE;
    }
    dwPMEventBufferIndex = 0;

    /*
     * setup PM
     */
    pmExecuteProgram (pbPMProgramSetup);

    /*
     * start 1st experiment
     */
#ifdef NVDD32
    pmExecuteProgram (pbPMProgramStart);
    writeMethod140();
    dwPMFirstTrigger = 0;
#endif

    /*
     * done
     */
    return TRUE;
#endif
}

/*
 * pmDisconnect
 *
 * disconnect from PM host
 */
BOOL pmDisconnect
(
    void
)
{
#ifdef WINNT
    return FALSE;
#else
    /*
     * general clean up
     */
    g_dwPMTrigger      = PM_REG_PMTRIGGER_DISABLED;
    g_dwPMTriggerCount = 0;
    g_dwPMTriggerValue = 0;

    /*
     * close log file
     */
    if (hPMFile)
    {
        pmFlush();
        CloseHandle (hPMFile);
        hPMFile = NULL;
    }

    /*
     * free programs
     */
    if (pbPMProgramSetup)
    {
        pmFreeMemory (pbPMProgramSetup);
        pbPMProgramSetup = NULL;
    }
    if (pbPMProgramStart)
    {
        pmFreeMemory (pbPMProgramStart);
        pbPMProgramStart = NULL;
    }
    if (pbPMProgramSample)
    {
        pmFreeMemory (pbPMProgramSample);
        pbPMProgramSample = NULL;
    }

    /*
     * free event buffer
     */
    if (pbPMEventBuffer)
    {
        pmFreeMemory (pbPMEventBuffer);
        pbPMEventBuffer = NULL;
    }

    /*
     * done
     */
    return TRUE;
#endif
}

/*
 * pmSignal
 *
 * signals the end of an experiment
 *  wait for HW flush to capture data.
 *  logs results to log file.
 */
BOOL pmSignal
(
    void
)
{
#ifdef WINNT
    return FALSE;
#else
    PM_LOG_EVENT event;
    BOOL bTimedOut;

    /*
     * Return if this call to pmSignal() is just starting the trigger
     */
    if (dwPMFirstTrigger) {
        pmExecuteProgram (pbPMProgramStart);
        writeMethod140();
        dwPMFirstTrigger = 0;
        return TRUE;
    }

    /*
     * signal end-of-experiment (fe2pm_nop)
     */
    writeMethod140();
    flush();

    /*
     * wait for PM idle
     */
    bTimedOut = FALSE;
    
#if defined(IS_OPENGL)
    if (!(dwPMFlags & PM_FLAGS_IN_QUAKE3) || InQuake) 
    {
        if (reset && (dwPMFlags & PM_FLAGS_IN_QUAKE3))
        {
            reset = 0;
            pmExecuteProgram (pbPMProgramStart);
        }
        else
        {
#endif
            if (!(dwPMFlags & PM_FLAGS_NO_WAIT))
            {
                switch (dwPMHWArch)
                {
                    case 0x10:
                    case 0x20:
                    {
                        DWORD dwAddr    = dwPMHWLinearBase + NV_PPM_CONTROL;
                        DWORD dwBits;
                        DWORD dwTimeout = GetTickCount() + 2000; // 2s timeout window
                        do
                        {
                            bTimedOut   = GetTickCount() >= dwTimeout;
                            dwBits      = *(volatile DWORD*)dwAddr;
                            dwBits    >>= 0 ? NV_PPM_CONTROL_NV_STATE;
                            dwBits     &= (1 << ((1 ? NV_PPM_CONTROL_NV_STATE) - (0 ? NV_PPM_CONTROL_NV_STATE) + 1)) - 1;
                        } while ((dwBits != NV_PPM_CONTROL_STATE_IDLE)
                              && !bTimedOut);
                    }
                }
            }

            /*
             * if PM timed out, we do not log anything but we do reset the PM engine
             */

            if (!bTimedOut)
            {
                /*
                 * log current time
                 */
                __asm
                {
                    rdtsc
                    mov [event.dwValueLo],eax
                    mov [event.dwValueHi],edx
                }
                pmLogEvent (&event);

                /*
                 * sample PM and log events
                 */
                pmExecuteProgram (pbPMProgramSample);
            }
            else
            {
                /*
                 * reset engine by reprogramming state
                 */
                pmExecuteProgram (pbPMProgramSetup);
            }
#if defined(IS_OPENGL)
        }
    }
    else if (dwPMFlags & PM_FLAGS_IN_QUAKE3)
    {
        reset = 1;        
    }
#endif

    /*
     * start next experiment
     */
    if (!(dwPMFlags & PM_FLAGS_NO_RESET))
        pmExecuteProgram (pbPMProgramStart);

    writeMethod140();

    /*
     * done
     */
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvprocman.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"
#pragma hdrstop

// Local function
BOOL pmDeleteProcessPDD       (GLOBALDATA *pDriverData, DWORD processID);

// NB: This file is broken into 3 parts.  One for Win9x, Win2k, and WinNT4.
//     All functions are implemented in each section.

#if IS_WIN9X
// Event Services (Set,Reset,Wait)
//
HRESULT NvResetEvent(HDRVEVENT hEvent)
{
    return ResetEvent(hEvent);
}

HRESULT NvSetEvent(HDRVEVENT hEvent)
{
    return SetEvent(hEvent);
}

HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout)
{
    return WaitForSingleObject(hEvent,timeout);
}

// ------------------------------------------------------------------------------------------
// ConvertRing3EventToRing0
//      Converts a ring3 event handle to a ring0 event handle that RM can understand
HANDLE ConvertRing3EventToRing0 ( HANDLE hEventRing3 )
{
    HANDLE  hEventRing0;

#ifdef IKOS
    return (NULL);
#endif

    if ( hEventRing3 == NULL || global.pfOpenVxDHandle == NULL)
        return (NULL);

    /*
     * Create a ring0 event
     */
    hEventRing0 = (*global.pfOpenVxDHandle)(hEventRing3);

    return(hEventRing0);
}

// ------------------------------------------------------------------------------------------
// CloseRing0Handle
//      Closes the ring0 event handle
BOOL CloseRing0Handle( HANDLE hEventRing0 )
{
    HINSTANCE hKernel32Dll;
    HANDLE  (WINAPI *pfCloseVxDHandle)(HANDLE);

    if (hEventRing0 == NULL) return (FALSE);

    hKernel32Dll = LoadLibrary("kernel32.dll");
    if (!hKernel32Dll)
        return (FALSE);

    pfCloseVxDHandle = (HANDLE (WINAPI *)(HANDLE))GetProcAddress(hKernel32Dll, "CloseVxDHandle");
    if (!pfCloseVxDHandle) {
        FreeLibrary(hKernel32Dll);
        return (FALSE);
    }

    (*pfCloseVxDHandle)(hEventRing0);
    FreeLibrary(hKernel32Dll);

    return (TRUE);
}


// -------------------------------------------------------------------------
// pmGetProcess
//      Returns a pointer to the PROCESSINFO structure of the associated
//      process ID.  Returns NULL if not found.
LPPROCESSINFO pmGetProcess(GLOBALDATA *pDriverData, DWORD processID)
{
LPPROCESSINFO lpProcInfo;
static DWORD state=0;
DWORD mask;

    switch (pDXShare->dwHeadNumber) {
    case 1:  mask = 0x00000002; break;
    case 0:
    default: mask = 0x00000001; break;
    }

    // to prevent infinite recursion
    if ((pDXShare->dwHeadNumber == 0 && (state & 0x00000001)) ||
        (pDXShare->dwHeadNumber == 1 && (state & 0x00000002))) {
        return NULL;
    }

    for (lpProcInfo=pDriverData->lpProcessInfoHead; lpProcInfo!=NULL; lpProcInfo=lpProcInfo->lpNext) {
        if (lpProcInfo->dwProcessID == processID)
            return lpProcInfo;
    }

    state |= mask;
    pmAddProcess(pDriverData, processID);
    state &= ~mask;
    return pmGetProcess(pDriverData, processID);
}

// -------------------------------------------------------------------------
// pmAddProcess
//      Adds a process to the linked list, creates events and attaches them
//      to their respective objects.  Returns TRUE if succeeded.
BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID)
{
LPPROCESSINFO lpProcInfo;
SECURITY_ATTRIBUTES sec = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};

    if (pmGetProcess(pDriverData, processID) != NULL)
        return FALSE;

    lpProcInfo = (LPPROCESSINFO) AllocIPM(sizeof(PROCESSINFO));
    if (lpProcInfo == NULL)
        return FALSE;

    lpProcInfo->lpNext          = pDriverData->lpProcessInfoHead;
    lpProcInfo->dwProcessID     = processID;

    // under Win9x, events are created once under the parent process
    // all subsequent processes open the same user event

    if (pDriverData->lpProcessInfoHead == 0) {
        // first one, create and attach events
        // Idle event
        lpProcInfo->hIdleSyncEvent3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_IDLE);
        lpProcInfo->hIdleSyncEvent0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hIdleSyncEvent3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_ROP_GDI_RECT_AND_TEXT,
                       NV_DD_EVENT_IDLE_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV04A_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hIdleSyncEvent0);
        NvSetEvent(lpProcInfo->hIdleSyncEvent3);

        // Timer event
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0004_TIMER) {
            lpProcInfo->hTimer3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_TIMER);
            lpProcInfo->hTimer0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hTimer3);
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_TIMER_IID,
                           NV_DD_EVENT_TIMER, NV01_EVENT_WIN32_EVENT,
                           NV004_NOTIFIERS_SET_ALARM_NOTIFY, (void*) lpProcInfo->hTimer0);
            NvSetEvent(lpProcInfo->hTimer3);
        }

        // Overlay flip events
        lpProcInfo->hOvlFlipEvenEvent3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_OVL_FLIP_EVEN);
        lpProcInfo->hOvlFlipEvenEvent0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hOvlFlipEvenEvent3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                       NV_DD_EVENT_OVL_FLIP1, NV01_EVENT_WIN32_EVENT,
                       NV07A_NOTIFIERS_SET_OVERLAY(0), (void*) lpProcInfo->hOvlFlipEvenEvent0);
        NvSetEvent(lpProcInfo->hOvlFlipEvenEvent3);

        lpProcInfo->hOvlFlipOddEvent3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_OVL_FLIP_ODD);
        lpProcInfo->hOvlFlipOddEvent0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hOvlFlipOddEvent3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                       NV_DD_EVENT_OVL_FLIP2, NV01_EVENT_WIN32_EVENT,
                       NV07A_NOTIFIERS_SET_OVERLAY(1), (void*) lpProcInfo->hOvlFlipOddEvent0);
        NvSetEvent(lpProcInfo->hOvlFlipOddEvent3);

        // DMA to Video memory event
        lpProcInfo->hDMABlitToVid3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_DMA_TO_VID);
        lpProcInfo->hDMABlitToVid0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hDMABlitToVid3);
        NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID,
                       NV_DD_EVENT_DMABLT_TO_VID, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hDMABlitToVid0);
        NvSetEvent(lpProcInfo->hDMABlitToVid3);

        // Format conversion to YUV422 event
        lpProcInfo->hConvert3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_CONVERT);
        lpProcInfo->hConvert0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hConvert3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2V_FORMAT_Y_IID,
                       NV_DD_EVENT_CONVERT_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hConvert0);
        NvSetEvent(lpProcInfo->hConvert3);

        // DVD subpicture
        lpProcInfo->hSubPicture3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_SUBPICTURE);
        lpProcInfo->hSubPicture0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hSubPicture3);
        NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DVDPICT_NDX].classIID,
                       NV_DD_EVENT_DVD_SUBPICTURE, NV01_EVENT_WIN32_EVENT,
                       NV038_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hSubPicture0);
        NvSetEvent(lpProcInfo->hSubPicture3);

        // Colour control events
        lpProcInfo->hColourControl3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_COLOURCONTROL);
        lpProcInfo->hColourControl0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hColourControl3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2OSH_FORMAT_IID,
                       NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hColourControl0);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OSH2V_FORMAT_IID,
                       NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hColourControl0);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_ALPHA_BLIT_IID,
                       NV_DD_EVENT_ALPHA_BLIT_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV05F_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hColourControl0);
        NvSetEvent(lpProcInfo->hColourControl3);

        // Temporal filter event
        lpProcInfo->hTFilter3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_TFILTER);
        lpProcInfo->hTFilter0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hTFilter3);
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
            NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                           NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV097_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hTFilter0);
        } else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                           NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV056_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hTFilter0);
        } else {
            NvRmAllocEvent(pDriverData->dwRootHandle, D3D_DX6_MULTI_TEXTURE_TRIANGLE,
                           NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV055_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hTFilter0);
        }
        NvSetEvent(lpProcInfo->hTFilter3);

        // Skip this on NV4/NV5
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
        {
            // Deinterlace filter event
            lpProcInfo->hDFilter3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_DFILTER);
            lpProcInfo->hDFilter0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hDFilter3);
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
                NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                               NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                               NV097_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hDFilter0);
            } else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                               NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                               NV056_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hDFilter0);
            }
            NvSetEvent(lpProcInfo->hDFilter3);
        }

        // Full screen mirror event
        lpProcInfo->hFSMirror3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_FSMIRROR);
        lpProcInfo->hFSMirror0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hFSMirror3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE1_IID,
                       NV_DD_EVENT_FSMIRROR, NV01_EVENT_WIN32_EVENT,
                       NV089_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hFSMirror0);
        NvSetEvent(lpProcInfo->hFSMirror3);

        // 4CC blt event
        lpProcInfo->hFourCCBlt3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_FOURCCBLT);
        lpProcInfo->hFourCCBlt0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hFourCCBlt3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE2_IID,
                       NV_DD_EVENT_FOURCCBLT, NV01_EVENT_WIN32_EVENT,
                       NV089_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hFourCCBlt0);
        NvSetEvent(lpProcInfo->hFourCCBlt0);

        // Primary flip events
        lpProcInfo->hPrimary0FlipEven3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY0_FLIP_EVEN);
        lpProcInfo->hPrimary0FlipEven0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary0FlipEven3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                       NV_DD_EVENT_PRIMARY0_FLIP1, NV01_EVENT_WIN32_EVENT,
                       NV067_NOTIFIERS_SET_IMAGE(0), (void*) lpProcInfo->hPrimary0FlipEven0);
        NvSetEvent(lpProcInfo->hPrimary0FlipEven3);

        lpProcInfo->hPrimary0FlipOdd3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY0_FLIP_ODD);
        lpProcInfo->hPrimary0FlipOdd0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary0FlipOdd3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                       NV_DD_EVENT_PRIMARY0_FLIP2, NV01_EVENT_WIN32_EVENT,
                       NV067_NOTIFIERS_SET_IMAGE(1), (void*) lpProcInfo->hPrimary0FlipOdd0);
        NvSetEvent(lpProcInfo->hPrimary0FlipOdd3);

        if (pDriverData->dwHeads > 1)
        {
            lpProcInfo->hPrimary1FlipEven3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY1_FLIP_EVEN);
            lpProcInfo->hPrimary1FlipEven0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary1FlipEven3);
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                           NV_DD_EVENT_PRIMARY1_FLIP1, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(0), (void*) lpProcInfo->hPrimary1FlipEven0);
            NvSetEvent(lpProcInfo->hPrimary1FlipEven3);

            lpProcInfo->hPrimary1FlipOdd3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY1_FLIP_ODD);
            lpProcInfo->hPrimary1FlipOdd0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary1FlipOdd3);
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                           NV_DD_EVENT_PRIMARY1_FLIP2, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(1), (void*) lpProcInfo->hPrimary1FlipOdd0);
            NvSetEvent(lpProcInfo->hPrimary1FlipOdd3);
        }

    } else {
        lpProcInfo->hIdleSyncEvent3      = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_IDLE);
        lpProcInfo->hIdleSyncEvent0      = 0;
        lpProcInfo->hTimer3              = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_TIMER);
        lpProcInfo->hTimer0              = 0;
        lpProcInfo->hOvlFlipEvenEvent3   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_OVL_FLIP_EVEN);
        lpProcInfo->hOvlFlipEvenEvent0   = 0;
        lpProcInfo->hOvlFlipOddEvent3    = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_OVL_FLIP_ODD);
        lpProcInfo->hOvlFlipOddEvent0    = 0;
        lpProcInfo->hDMABlitToVid3       = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DMA_TO_VID);
        lpProcInfo->hDMABlitToVid0       = 0;
        lpProcInfo->hConvert3            = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_CONVERT);
        lpProcInfo->hConvert0            = 0;
        lpProcInfo->hSubPicture3         = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_SUBPICTURE);
        lpProcInfo->hSubPicture0         = 0;
        lpProcInfo->hColourControl3      = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_COLOURCONTROL);
        lpProcInfo->hColourControl0      = 0;
        lpProcInfo->hTFilter3            = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_TFILTER);
        lpProcInfo->hTFilter0            = 0;
        // Skip this on NV4/NV5
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
        {
            lpProcInfo->hDFilter3            = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DFILTER);
            lpProcInfo->hDFilter0            = 0;
        }
        lpProcInfo->hFSMirror3           = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_FSMIRROR);
        lpProcInfo->hFSMirror0           = 0;
        lpProcInfo->hFourCCBlt0          = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_FOURCCBLT);
        lpProcInfo->hFourCCBlt3          = 0;
        lpProcInfo->hPrimary0FlipEven3   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY0_FLIP_EVEN);
        lpProcInfo->hPrimary0FlipEven0   = 0;
        lpProcInfo->hPrimary0FlipOdd3    = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY0_FLIP_ODD);
        lpProcInfo->hPrimary0FlipOdd0    = 0;
        if (pDriverData->dwHeads > 1)
        {
            lpProcInfo->hPrimary1FlipEven3   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY1_FLIP_EVEN);
            lpProcInfo->hPrimary1FlipEven0   = 0;
            lpProcInfo->hPrimary1FlipOdd3    = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY1_FLIP_ODD);
            lpProcInfo->hPrimary1FlipOdd0    = 0;
        }
    }

    pDriverData->lpProcessInfoHead = lpProcInfo;
    return TRUE;
}

// -------------------------------------------------------------------------
// pmDeleteProcess
//      Deletes a process from the info list.  Destroy all associated
//      events.  Returns TRUE if succeeded
BOOL pmDeleteProcess(DWORD processID)
{
    return pmDeleteProcessPDD(pDriverData, processID);
}

BOOL pmDeleteProcessPDD(GLOBALDATA *pDriverData, DWORD processID)
{
    LPPROCESSINFO lpProcInfo, lpPrevProcInfo;

    for (lpProcInfo=pDriverData->lpProcessInfoHead; lpProcInfo!=NULL; lpProcInfo=lpProcInfo->lpNext) {
        if (lpProcInfo->dwProcessID == processID) {
            if (lpProcInfo == pDriverData->lpProcessInfoHead) {
                pDriverData->lpProcessInfoHead = lpProcInfo->lpNext;
            } else {
                lpPrevProcInfo->lpNext = lpProcInfo->lpNext;
            }

            /*  Rely on process termination to kill these, closing them seems to screw up Windows for unknown reasons
            if (lpProcInfo->hIdleSyncEvent3)
                WAITFORSINGLEOBJECT((HANDLE)lpProcInfo->hIdleSyncEvent3, 100);
            if (lpProcInfo->hIdleSyncEvent0) {
                CloseRing0Handle((HANDLE)lpProcInfo->hIdleSyncEvent0);
                lpProcInfo->hIdleSyncEvent0 = 0;
            }
            if (lpProcInfo->hIdleSyncEvent3) {
                CLOSE_HANDLE((HANDLE)lpProcInfo->hIdleSyncEvent3);
                lpProcInfo->hIdleSyncEvent3 = 0;
            }
            */

            FreeIPM(lpProcInfo);
            return TRUE;
        } else {
            lpPrevProcInfo = lpProcInfo;
        }
    }
    return FALSE;
}

// -------------------------------------------------------------------------
// pmDeleteAllProcesses
//      Deletes all processes
void pmDeleteAllProcesses(GLOBALDATA *pDriverData)
{
    LPPROCESSINFO lpProcInfo;

    // tells the ring0 code to not run any more!
    pDriverData->vpp.regRing0ColourCtlInterlockFlags = pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0xFFFFFFFE;
    {
        DWORD aCount = 16;
        while((pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0x02) && aCount-- ) {
            Sleep(1);  // waits 1 millisecond
        }
    }

    while (pDriverData->lpProcessInfoHead != 0) {
        lpProcInfo = pDriverData->lpProcessInfoHead;
        pmDeleteProcessPDD(pDriverData, lpProcInfo->dwProcessID);
    }
}

#elif IS_WINNT5

// Event Services (Set,Reset,Wait)
//
HRESULT NvResetEvent(HDRVEVENT hEvent)
{
    LARGE_INTEGER timeOut;
    timeOut.LowPart = -2000000;
    timeOut.HighPart = -1;
    return EngWaitForSingleObject(hEvent, &timeOut);
}

HRESULT NvSetEvent(HDRVEVENT hEvent)
{
    return EngSetEvent(hEvent);
}

HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout)
{
    HRESULT ddrval;
    LARGE_INTEGER bigTimeOut;
    bigTimeOut.LowPart = -((int)timeout) * 10000;   // measured in units of 100 fs in NT
    bigTimeOut.HighPart = (timeout == 0) ? 0:(-1);  // negative means relative to current time

    // note: DDK docs are wrong, it returns an error code, not a TRUE/FALSE result
    ddrval = EngWaitForSingleObject(hEvent, &bigTimeOut);
    EngSetEvent(hEvent);
    return ddrval;
}

LPPROCESSINFO pmGetProcess(GLOBALDATA *pDriverData, DWORD processID)
{
	if (pDriverData->lpProcessInfoHead == NULL) {
		pmAddProcess(pDriverData, processID);
	}

    return(pDriverData->lpProcessInfoHead);
}
   
BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID)
{
    LPPROCESSINFO lpProcInfo;

    lpProcInfo = &(pDriverData->procInfo);

    lpProcInfo->lpNext      = NULL;
    lpProcInfo->dwProcessID = processID;

    // under WIN2k, all driver events are shared among all processes
    // cannot use standard user event services, must use EngEvent services
    // set the ring3 event member to equal the ring0 event to make thing easier to macrotize

    // idle event
    if (lpProcInfo->hIdleSyncEvent0 == NULL) {
        EngCreateEvent(&lpProcInfo->hIdleSyncEvent0);
        lpProcInfo->hIdleSyncEvent3 = lpProcInfo->hIdleSyncEvent0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_ROP_GDI_RECT_AND_TEXT,
                           NV_DD_EVENT_IDLE_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV04A_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hIdleSyncEvent0)))) {
            EngDeleteEvent(pDriverData->procInfo.hIdleSyncEvent0);
            lpProcInfo->hIdleSyncEvent0 = NULL;
            lpProcInfo->hIdleSyncEvent3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hIdleSyncEvent3);
        }
    }

    // timer event
    if (lpProcInfo->hTimer0 == NULL &&
       (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0004_TIMER)) {
        EngCreateEvent(&lpProcInfo->hTimer0);
        lpProcInfo->hTimer3 = lpProcInfo->hTimer0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_TIMER_IID,
                           NV_DD_EVENT_TIMER, NV01_EVENT_WIN32_EVENT,
                           NV004_NOTIFIERS_SET_ALARM_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTimer0)))) {
            EngDeleteEvent(pDriverData->procInfo.hTimer0);
            lpProcInfo->hTimer0 = NULL;
            lpProcInfo->hTimer3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hTimer3);
        }
    }

    // DMA to Video memory event
    if (lpProcInfo->hDMABlitToVid0 == NULL) {
        EngCreateEvent(&lpProcInfo->hDMABlitToVid0);
        lpProcInfo->hDMABlitToVid3 = lpProcInfo->hDMABlitToVid0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID,
                           NV_DD_EVENT_DMABLT_TO_VID, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hDMABlitToVid0)))) {
            EngDeleteEvent(pDriverData->procInfo.hDMABlitToVid0);
            lpProcInfo->hDMABlitToVid0 = NULL;
            lpProcInfo->hDMABlitToVid3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hDMABlitToVid3);
        }
    }

    // Full screen mirror event
    if (lpProcInfo->hFSMirror0 == NULL) {
        EngCreateEvent(&lpProcInfo->hFSMirror0);
        lpProcInfo->hFSMirror3 = lpProcInfo->hFSMirror0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE1_IID,
                           NV_DD_EVENT_FSMIRROR, NV01_EVENT_WIN32_EVENT,
                           NV089_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hFSMirror0)))) {
            EngDeleteEvent(pDriverData->procInfo.hFSMirror0);
            lpProcInfo->hFSMirror0 = NULL;
            lpProcInfo->hFSMirror3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hFSMirror3);
        }
    }

    // FourCCBlt event
    if (lpProcInfo->hFourCCBlt0 == NULL) {
        EngCreateEvent(&lpProcInfo->hFourCCBlt0);
        lpProcInfo->hFourCCBlt3 = lpProcInfo->hFourCCBlt0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE2_IID,
                           NV_DD_EVENT_FOURCCBLT, NV01_EVENT_WIN32_EVENT,
                           NV089_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hFourCCBlt0)))) {
            EngDeleteEvent(pDriverData->procInfo.hFourCCBlt0);
            lpProcInfo->hFourCCBlt0 = NULL;
            lpProcInfo->hFourCCBlt3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hFourCCBlt3);
        }
    }

    // don't try to create overlay events if an overlay doesn't exist
    if (pDriverData->vpp.dwOverlaySurfaces == 0)
    {
        return TRUE;
    }

    // Overlay flip events
    if (lpProcInfo->hOvlFlipEvenEvent0 == NULL) {
        EngCreateEvent(&lpProcInfo->hOvlFlipEvenEvent0);
        lpProcInfo->hOvlFlipEvenEvent3 = lpProcInfo->hOvlFlipEvenEvent0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                           NV_DD_EVENT_OVL_FLIP1, NV01_EVENT_WIN32_EVENT,
                           NV07A_NOTIFIERS_SET_OVERLAY(0), (void*) (*((LPDWORD)lpProcInfo->hOvlFlipEvenEvent0)))) {
            // error because overlay not created yet, so do this later
            EngDeleteEvent(pDriverData->procInfo.hOvlFlipEvenEvent0);
            lpProcInfo->hOvlFlipEvenEvent0 = NULL;
            lpProcInfo->hOvlFlipEvenEvent3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hOvlFlipEvenEvent3);
        }
    }

    if (lpProcInfo->hOvlFlipOddEvent0 == NULL) {
        EngCreateEvent(&lpProcInfo->hOvlFlipOddEvent0);
        lpProcInfo->hOvlFlipOddEvent3 = lpProcInfo->hOvlFlipOddEvent0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                           NV_DD_EVENT_OVL_FLIP2, NV01_EVENT_WIN32_EVENT,
                           NV07A_NOTIFIERS_SET_OVERLAY(1), (void*) (*((LPDWORD)lpProcInfo->hOvlFlipOddEvent0)))) {
            // error because overlay not created yet, so do this later
            EngDeleteEvent(pDriverData->procInfo.hOvlFlipOddEvent0);
            lpProcInfo->hOvlFlipOddEvent0 = NULL;
            lpProcInfo->hOvlFlipOddEvent3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hOvlFlipOddEvent3);
        }
    }

    // Format conversion to YUV422 event
    if (lpProcInfo->hConvert0 == NULL) {
        EngCreateEvent(&lpProcInfo->hConvert0);
        lpProcInfo->hConvert3 = lpProcInfo->hConvert0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2V_FORMAT_Y_IID,
                           NV_DD_EVENT_CONVERT_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hConvert0)))) {
            EngDeleteEvent(pDriverData->procInfo.hConvert0);
            lpProcInfo->hConvert0 = NULL;
            lpProcInfo->hConvert3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hConvert3);
        }
    }

    // DVD subpicture
    if (lpProcInfo->hSubPicture0 == NULL) {
        EngCreateEvent(&lpProcInfo->hSubPicture0);
        lpProcInfo->hSubPicture3 = lpProcInfo->hSubPicture0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DVDPICT_NDX].classIID,
                           NV_DD_EVENT_DVD_SUBPICTURE, NV01_EVENT_WIN32_EVENT,
                           NV038_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hSubPicture0)))) {
            EngDeleteEvent(pDriverData->procInfo.hSubPicture0);
            lpProcInfo->hSubPicture0 = NULL;
            lpProcInfo->hSubPicture3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hSubPicture3);
        }
    }

    // Colour control events
    if (lpProcInfo->hColourControl0 == NULL) {
        EngCreateEvent(&lpProcInfo->hColourControl0);
        lpProcInfo->hColourControl3 = lpProcInfo->hColourControl0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2OSH_FORMAT_IID,
                           NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hColourControl0))) ||
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OSH2V_FORMAT_IID,
                           NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hColourControl0))) ||
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_ALPHA_BLIT_IID,
                           NV_DD_EVENT_ALPHA_BLIT_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV05F_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hColourControl0)))) {
            EngDeleteEvent(pDriverData->procInfo.hColourControl0);
            lpProcInfo->hColourControl0 = NULL;
            lpProcInfo->hColourControl3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hColourControl3);
        }
    }

    // Temporal filter event
    if (lpProcInfo->hTFilter0 == NULL) {
        DWORD result;
        EngCreateEvent(&lpProcInfo->hTFilter0);
        lpProcInfo->hTFilter3 = lpProcInfo->hTFilter0;
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
            result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                                    NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                                    NV097_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTFilter0)));
        } else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                                    NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                                    NV056_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTFilter0)));
        } else {
            result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_DX6_MULTI_TEXTURE_TRIANGLE,
                                    NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                                    NV055_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTFilter0)));
        }
        if (result) {
            EngDeleteEvent(pDriverData->procInfo.hTFilter0);
            lpProcInfo->hTFilter0 = NULL;
            lpProcInfo->hTFilter3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hTFilter3);
        }
    }

    // Skip this on NV4/NV5
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    {
        // Deinterlace filter event
        if (lpProcInfo->hDFilter0 == NULL) {
            DWORD result;
            EngCreateEvent(&lpProcInfo->hDFilter0);
            lpProcInfo->hDFilter3 = lpProcInfo->hDFilter0;
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
                result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                                        NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                                        NV097_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hDFilter0)));
            } else {
                result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                                        NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                                        NV056_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hDFilter0)));
            }
            if (result) {
                EngDeleteEvent(pDriverData->procInfo.hDFilter0);
                lpProcInfo->hDFilter0 = NULL;
                lpProcInfo->hDFilter3 = NULL;
            } else {
                EngSetEvent(lpProcInfo->hDFilter3);
            }
        }
    }

    // Primary flip events
    if (lpProcInfo->hPrimary0FlipEven0 == NULL) {
        EngCreateEvent(&lpProcInfo->hPrimary0FlipEven0);
        lpProcInfo->hPrimary0FlipEven3 = lpProcInfo->hPrimary0FlipEven0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                           NV_DD_EVENT_PRIMARY0_FLIP1, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(0), (void*) (*((LPDWORD)lpProcInfo->hPrimary0FlipEven0)))) {
            EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipEven0);
            lpProcInfo->hPrimary0FlipEven0 = NULL;
            lpProcInfo->hPrimary0FlipEven3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hPrimary0FlipEven3);
        }
    }

    if (lpProcInfo->hPrimary0FlipOdd0 == NULL) {
        EngCreateEvent(&lpProcInfo->hPrimary0FlipOdd0);
        lpProcInfo->hPrimary0FlipOdd3 = lpProcInfo->hPrimary0FlipOdd0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                           NV_DD_EVENT_PRIMARY0_FLIP2, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(1), (void*) (*((LPDWORD)lpProcInfo->hPrimary0FlipOdd0)))) {
            EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipOdd0);
            lpProcInfo->hPrimary0FlipOdd0 = NULL;
            lpProcInfo->hPrimary0FlipOdd3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hPrimary0FlipOdd3);
        }
    }

    // Conditionally create events for primary on 2nd head
    if (pDriverData->dwHeads > 1)
    {
        if (lpProcInfo->hPrimary1FlipEven0 == NULL) {
            EngCreateEvent(&lpProcInfo->hPrimary1FlipEven0);
            lpProcInfo->hPrimary1FlipEven3 = lpProcInfo->hPrimary1FlipEven0;
            if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                               NV_DD_EVENT_PRIMARY1_FLIP1, NV01_EVENT_WIN32_EVENT,
                               NV067_NOTIFIERS_SET_IMAGE(0), (void*) (*((LPDWORD)lpProcInfo->hPrimary1FlipEven0)))) {
                EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipEven0);
                lpProcInfo->hPrimary1FlipEven0 = NULL;
                lpProcInfo->hPrimary1FlipEven3 = NULL;
            } else {
                EngSetEvent(lpProcInfo->hPrimary1FlipEven3);
            }
        }

        if (lpProcInfo->hPrimary1FlipOdd0 == NULL) {
            EngCreateEvent(&lpProcInfo->hPrimary1FlipOdd0);
            lpProcInfo->hPrimary1FlipOdd3 = lpProcInfo->hPrimary1FlipOdd0;
            if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                               NV_DD_EVENT_PRIMARY1_FLIP2, NV01_EVENT_WIN32_EVENT,
                               NV067_NOTIFIERS_SET_IMAGE(1), (void*) (*((LPDWORD)lpProcInfo->hPrimary1FlipOdd0)))) {
                EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipOdd0);
                lpProcInfo->hPrimary1FlipOdd0 = NULL;
                lpProcInfo->hPrimary1FlipOdd3 = NULL;
            } else {
                EngSetEvent(lpProcInfo->hPrimary1FlipOdd3);
            }
        }
    }

    pDriverData->lpProcessInfoHead = lpProcInfo;
    return TRUE;
}

BOOL pmDeleteProcess(DWORD processID)
{
    return pmDeleteProcessPDD(pDriverData, processID);
}

BOOL pmDeleteProcessPDD(GLOBALDATA *pDriverData, DWORD processID)
{
    if (pDriverData->procInfo.hIdleSyncEvent0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_IDLE_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hIdleSyncEvent0);
        pDriverData->procInfo.hIdleSyncEvent0 = NULL;
        pDriverData->procInfo.hIdleSyncEvent3 = NULL;
    }
    
    if (pDriverData->procInfo.hTimer0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_TIMER);
        EngDeleteEvent(pDriverData->procInfo.hTimer0);
        pDriverData->procInfo.hTimer0 = NULL;
        pDriverData->procInfo.hTimer3 = NULL;
    }
    
    if (pDriverData->procInfo.hOvlFlipEvenEvent0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_OVL_FLIP1);
        EngDeleteEvent(pDriverData->procInfo.hOvlFlipEvenEvent0);
        pDriverData->procInfo.hOvlFlipEvenEvent0 = NULL;
        pDriverData->procInfo.hOvlFlipEvenEvent3 = NULL;
    }
    
    if (pDriverData->procInfo.hOvlFlipOddEvent0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_OVL_FLIP2);
        EngDeleteEvent(pDriverData->procInfo.hOvlFlipOddEvent0);
        pDriverData->procInfo.hOvlFlipOddEvent0 = NULL;
        pDriverData->procInfo.hOvlFlipOddEvent3 = NULL;
    }
    
    if (pDriverData->procInfo.hDMABlitToVid0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_DMABLT_TO_VID);
        EngDeleteEvent(pDriverData->procInfo.hDMABlitToVid0);
        pDriverData->procInfo.hDMABlitToVid0 = NULL;
        pDriverData->procInfo.hDMABlitToVid3 = NULL;
    }
    
    if (pDriverData->procInfo.hConvert0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_CONVERT_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hConvert0);
        pDriverData->procInfo.hConvert0 = NULL;
        pDriverData->procInfo.hConvert3 = NULL;
    }
    
    if (pDriverData->procInfo.hSubPicture0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_DVD_SUBPICTURE);
        EngDeleteEvent(pDriverData->procInfo.hSubPicture0);
        pDriverData->procInfo.hSubPicture0 = NULL;
        pDriverData->procInfo.hSubPicture3 = NULL;
    }
    
    if (pDriverData->procInfo.hColourControl0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC);
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC);
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_ALPHA_BLIT_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hColourControl0);
        pDriverData->procInfo.hColourControl0 = NULL;
        pDriverData->procInfo.hColourControl3 = NULL;
    }
    
    if (pDriverData->procInfo.hTFilter0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_COMBINER_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hTFilter0);
        pDriverData->procInfo.hTFilter0 = NULL;
        pDriverData->procInfo.hTFilter3 = NULL;
    }
    
    if (pDriverData->procInfo.hDFilter0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_DFILTER_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hDFilter0);
        pDriverData->procInfo.hDFilter0 = NULL;
        pDriverData->procInfo.hDFilter3 = NULL;
    }
    
    if (pDriverData->procInfo.hFSMirror0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_FSMIRROR);
        EngDeleteEvent(pDriverData->procInfo.hFSMirror0);
        pDriverData->procInfo.hFSMirror0 = NULL;
        pDriverData->procInfo.hFSMirror3 = NULL;
    }

    if (pDriverData->procInfo.hFourCCBlt0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_FOURCCBLT);
        EngDeleteEvent(pDriverData->procInfo.hFourCCBlt0);
        pDriverData->procInfo.hFourCCBlt0 = NULL;
        pDriverData->procInfo.hFourCCBlt3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary0FlipEven0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY0_FLIP1);
        EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipEven0);
        pDriverData->procInfo.hPrimary0FlipEven0 = NULL;
        pDriverData->procInfo.hPrimary0FlipEven3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary0FlipOdd0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY0_FLIP2);
        EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipOdd0);
        pDriverData->procInfo.hPrimary0FlipOdd0 = NULL;
        pDriverData->procInfo.hPrimary0FlipOdd3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary1FlipEven0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY1_FLIP1);
        EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipEven0);
        pDriverData->procInfo.hPrimary1FlipEven0 = NULL;
        pDriverData->procInfo.hPrimary1FlipEven3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary1FlipOdd0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY1_FLIP2);
        EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipOdd0);
        pDriverData->procInfo.hPrimary1FlipOdd0 = NULL;
        pDriverData->procInfo.hPrimary1FlipOdd3 = NULL;
    }
    
    pDriverData->lpProcessInfoHead = NULL;
    return(TRUE);
}

void pmDeleteAllProcesses(GLOBALDATA *pDriverData)
{
    pmDeleteProcessPDD(pDriverData, NULL);
    return;
}

#elif IS_WINNT4

// Events are not available for use by the WinNT4 driver,
// but since the 98 and 2k drivers use them, we stub these
// functions so that a valid pointer to a process structure is 
// returned.
//
// That makes the calling code more uniform across platforms.
//

HRESULT NvResetEvent(HDRVEVENT hEvent)               { return STATUS_WAIT_0; }
HRESULT NvSetEvent(HDRVEVENT hEvent)                 { return STATUS_WAIT_0; }
HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout) { return STATUS_WAIT_0; }


LPPROCESSINFO pmGetProcess(GLOBALDATA *pDriverData, DWORD processID)
{
	if (pDriverData->lpProcessInfoHead == NULL) {
		pmAddProcess(pDriverData, processID);
	}

    return(pDriverData->lpProcessInfoHead);
}
   
BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID)
{
    LPPROCESSINFO lpProcInfo;

    lpProcInfo = &(pDriverData->procInfo);

    // Make sure all event handles are NULL
    memset(lpProcInfo,0,sizeof(*lpProcInfo));

    lpProcInfo->lpNext      = NULL;
    lpProcInfo->dwProcessID = processID;

    pDriverData->lpProcessInfoHead = lpProcInfo;
    return TRUE;
}

BOOL pmDeleteProcess(DWORD processID)
{
    return TRUE;
}

void pmDeleteAllProcesses(GLOBALDATA *pDriverData)
{
    return;
}

#endif // OS determination
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvPatchUtil.c ===
/*
 * nvPatchUtil.c
 *
 * Software emulation for curved surfaces.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 */

// Constants defined in nvPatchConsts.c
extern float *bezBasis[16];
extern float *catmullRomBasis[16];
extern float *bsplineBasis[16];
extern float *invBezBasis[16];
extern float *powerToFD[16];
extern float *inversePowerToFD[16];
extern float cachedBinomialCoefficients[11][11];
static double factorial[1+NV_PATCH_MAX_RETESS];
static double oofactorial[1+NV_PATCH_MAX_RETESS];

#define DCR_COMPUTEFDMATRIXFLIP_OPT
#define DCR_COMPUTEFDCURVEFLIP_OPT
#define DCR_HOS_OPT
#if !defined(IS_OPENGL)
    //#define DCR_HOS_MATRIX_OPT
    #define DCR_HOS_RETESSCURVE_OPT     // XXX not yet thread safe for OpenGL
    #define DCR_HOS_RETESS_OPT          // XXX not yet thread safe for OpenGL
#endif

#if !defined(IS_OPENGL)
    #undef  NV_TRACE_COND
    #define NV_TRACE_COND(class, level, code)
    #undef  NV_TRACE_CODE
    #define NV_TRACE_CODE(code)
    #define TPRINTF(xx)
    #define EV_DRAW(code)
#ifdef MAX
#undef MAX
#endif
#ifdef MIN
#undef MIN
#endif
    #define MAX max
    #define MIN min

#else
    #define nvAssert assert
    #if defined(COMPILE_TRACE_LIBRARY)
        #define ENABLE_DEBUG_REVERSE_TRANSITIONS  // for testing reverse transitions
        #define ENABLE_DEBUG_SWATH // for testing swathing. I'll remove this when things are more stable. Thanks. Fred.
        static int evalTrace = 0;
        static int skipQuads = 0;   // set to draw only 1 quad of frac cases to simplify debugging
        static int retessit = 0;
        static int drawRef = 0;
        #define EV_DRAW(code) \
                if (drawRef  &&  (nvDebugLevel >= 2)) { \
                    { code; } \
                } \

    #else
        #define EV_DRAW(code)
    #endif
#endif

#define EV_GUARD_ATTR(index)        (((index) == NV_PATCH_ATTRIB_NORMAL) || ((index) == NV_PATCH_ATTRIB_POSITION))
#define EV_GUARD_BITS               ((1 << NV_PATCH_ATTRIB_NORMAL) | (1 << NV_PATCH_ATTRIB_POSITION))
#define EV_GUARD_BIT_VERTEX         ((1 << NV_PATCH_ATTRIB_POSITION))
#define EV_GUARD_BIT_NORMAL         ((1 << NV_PATCH_ATTRIB_NORMAL))

// note: conventions for specifying indices.
// For matrices, the ordering is [row][col] or [Vcoord][Ucoord].
// This matches how the control points are specified.
// For function arguments, it's tempting to use (Ucoord, Vcoord) since that
// is similar to (X, Y), but this can be confusing (matrices vs routines).
// Therefore, routines also take arguments in the (V, U) order.

// For the HW interface, integer step patches,
// the curve for the outside determines the direction of drawing the stitch.
// The inside curve may be evaluated in the reverse order. In these cases
// the n points are saved away in order to match the outside direction,
// then the stitch is drawn in the outside direction.

// Normally, matrices and curves are calculated with small step sizes.

// When swathing, the matrices are calculated with big steps, and
// converted during swathing. The low level routine DrawIntPatchGrid()
// receives matrices with small steps.
// Guard curves are calculated with big steps in nvEvalPatch(), then
// stepped and converted to small steps in DrawIntPatchSwaths()
// DrawIntStitch() receives a set of small step curves.

#define ASSERT_CURVE(PCURVE) nvAssert((PCURVE)->order > 0  &&  (PCURVE)->order < NV_PATCH_MAX_ORDER)
#define ASSERT_MATRIX(PMATRIX) nvAssert((PMATRIX)->rows > 0  &&  (PMATRIX)->rows < NV_PATCH_MAX_ORDER \
                                     && (PMATRIX)->cols > 0  &&  (PMATRIX)->cols < NV_PATCH_MAX_ORDER)

/*****************************************************************************/
#define EV_SWAP(a, b, t) { t = a; a = b; b = t; }

// index into curve*[]. For given attrib, and term of the curve equation, point to the 'X' of the attribute
static NV_INLINE int idxCurve(int attribIndex, int orderTerm)
{
    return (attribIndex*NV_PATCH_MAX_ORDER + orderTerm)*4;
}

static NV_INLINE float *pRawData(NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, float *rawData, int vCoord, int uCoord)
{
    int uOrder = map->uorder;//, ii;
    int vOrder = map->vorder;
    int ufStride = map->ufStride;
    int vfStride = map->vfStride;

    //ffif (info->flipT) {
        //ffEV_SWAP(uOrder, vOrder, ii);
        //ffEV_SWAP(ufStride, vfStride, ii);
    //ff}
    if (info->flipV) {
        vCoord = vOrder - 1 - vCoord;
    }
    if (info->flipU) {
        uCoord = uOrder - 1 - uCoord;
    }
    return (rawData + vCoord * vfStride + uCoord * ufStride);
}

static NV_INLINE void getRawData(NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, float *rawData, int vCoord, int uCoord, float *pOut)
{
    float *data = pRawData(info, map, rawData, vCoord, uCoord);
    pOut[0] = data[0]; pOut[1] = data[1]; pOut[2] = data[2]; pOut[3] = data[3];

}

/*****************************************************************************/
#if defined(COMPILE_TRACE_LIBRARY)

void TraceMatrix(NV_PATCH_INFO *info, const FDMatrix *m);

static float approxOK = 1E-5;
#define EV_ABS(x)       ((x) >=  0  ? (x) : -(x))
#define EV_MIN(x, y)    ((x) < (y) ? (x) : (y))
#define EV_MAX(x, y)    ((x) > (y) ? (x) : (y))

static NV_INLINE int FloatsIdentical(float src, float src2)
{
    if (EV_AS_INT(src) == EV_AS_INT(src2)) {
        return 1;
    }

    TPRINTF(("src=%g=x%x src2=%g=x%x\n", src, *(int *)&src, src2, *(int *)&src2));
    nvAssert(("FLOATS NOT IDENTICAL", 0));
    return 0;
}

static NV_INLINE int DoublesIdentical(double src, double src2)
{
    int *pSrc = (int *)&src;
    int *pSrc2 = (int *)&src2;

    if (pSrc[0] == pSrc2[0]  &&  pSrc[1] == pSrc2[1]) {
        return 1;
    }

    TPRINTF(("src=%g=x%X x%08X src2=%g=x%X x%08X\n", src, pSrc[0], pSrc[1], src2, pSrc2[0], pSrc2[1]));
    nvAssert(("DOUBLES NOT IDENTICAL", 0));
    return 0;
}

static NV_INLINE int FloatsEqual(float src, float src2)
{
    float fmin = EV_MIN(EV_ABS(src), EV_ABS(src2));
    float fmax = EV_MAX(EV_ABS(src), EV_ABS(src2));
    float fok = approxOK * fmax;

    if (src == 0.f) {
        if (fmax < approxOK) {
            return 1;
        }
        return 0;
    }
    if (src2 == 0.f) {
        if (fmax < approxOK) {
            return 1;
        }
        return 0;
    }
    if (EV_ABS(src - src2) <= fok) {
        return 1;
    }
    TPRINTF(("src=%g=x%x src2=%g=x%x\n", src, *(int *)&src, src2, *(int *)&src2));
    nvAssert(("FLOATS NOT EQUAL", 0));
    return 0;
}

static NV_INLINE int PointsEqual(float *src, float *src2)
{
    int ret = FloatsEqual(src[0], src2[0]);

    ret = ret && FloatsEqual(src[1], src2[1]);
    ret = ret && FloatsEqual(src[2], src2[2]);
    ret = ret && FloatsEqual(src[3], src2[3]);
    return ret;
}

// Compare the U curve from a FDMatrix to a curve
void CompareUCurveMatrix(NV_PATCH_CURVE_INFO *dst, FDMatrix *m)
{
    int i, stride = 4*sizeof(float);
    float *data = dst->coeffs[0];

    nvAssert(dst->order == m->columns);
    // Empty data
    for (i = 0; i < dst->order; i++) {
        // Compare data
        PointsEqual(data, m->data[0][i]);

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

static NV_INLINE void CompareCurves(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *src, NV_PATCH_CURVE_INFO *src2)
{
    int i;

    nvAssert(src->order == src2->order);
    for (i = 0;  i < src->order;  i++) {
        PointsEqual(src->coeffs[i], src2->coeffs[i]);
    }
}

static NV_INLINE int CompareMatrices(NV_PATCH_INFO *info, FDMatrix *src, FDMatrix *src2)
{
    int i, j, ret = 1;

    nvAssert(src->rows == src2->rows);
    nvAssert(src->columns == src2->columns);
    for (i=0; i < src->rows; i++) {
        for (j = 0; j < src->columns; j++) {
            ret = ret && FloatsEqual(src->data[i][j][0], src2->data[i][j][0]);
            ret = ret && FloatsEqual(src->data[i][j][1], src2->data[i][j][1]);
            ret = ret && FloatsEqual(src->data[i][j][2], src2->data[i][j][2]);
            ret = ret && FloatsEqual(src->data[i][j][3], src2->data[i][j][3]);
        }
    }
    if (!ret) {
        TPRINTF(("BAD MATRIX COMPARE\n"));
        TraceMatrix(info, src);
        TraceMatrix(info, src2);
    }
    return ret;
}

void CheckCache(NV_PATCH_INFO *info, FDMatrix *src)
{
    int i, j;
    double sum;

    for (i=0; i < src->rows; i++) {
        sum = 0.;
        for (j = 0; j < src->columns; j++) {
            FloatsIdentical(src->data[i][j][0], src->data[i][j][1]);
            FloatsIdentical(src->data[i][j][0], src->data[i][j][2]);
            FloatsIdentical(src->data[i][j][0], src->data[i][j][3]);
            sum += src->data[i][j][0];
        }
        TPRINTF(("CheckCache %2d) sum=%g\n", i, sum));
        if (!i) {
            FloatsEqual(sum, 1.f);
        } else {
            FloatsEqual(sum, 0.f);
        }
    }
}

void CheckCached(NV_PATCH_INFO *info, FDMatrixd *src)
{
    int i, j;
    double sum;

    for (i=0; i < src->rows; i++) {
        sum = 0.;
        for (j = 0; j < src->columns; j++) {
            DoublesIdentical(src->data[i][j][0], src->data[i][j][1]);
            DoublesIdentical(src->data[i][j][0], src->data[i][j][2]);
            DoublesIdentical(src->data[i][j][0], src->data[i][j][3]);
            sum += src->data[i][j][0];
        }
        TPRINTF(("CheckCache %2d) sum=%g\n", i, sum));
        if (!i) {
            //ffFloatsEqual(sum, 1.f);
            assert(sum == 1.);
        } else {
            //ffFloatsEqual(sum, 0.f);
            assert(sum == 0.);
        }
    }
}

#endif  // defined(COMPILE_TRACE_LIBRARY)

/*****************************************************************************/
// Print a matrix for tracing purposes
static int traceHex = 0;
static int traceWrap = 1;
void TraceMatrix(NV_PATCH_INFO *info, const FDMatrix *m)
{
    int row, col;
#if !defined(IS_OPENGL)
    DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "%dx%d matrix:\n", m->rows, m->columns);
    for (row = 0; row < m->rows; row++) {
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "  ");
        for (col = 0; col < m->columns; col++) {
            DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "[%f %f %f %f] ",
                m->data[row][col][0], m->data[row][col][1],
                m->data[row][col][2], m->data[row][col][3]);
        }
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "\n");
    }
#else
    NV_TRACE(TR_EVAL, 25, ("%dx%d matrix:\n", m->rows, m->columns));
    for (row = 0; row < m->rows; row++) {
        NV_TRACE(TR_EVAL, 25, ("row%d:", row));
        for (col = 0; col < m->columns; col++) {
            NV_TRACE(TR_EVAL, 25, ("%s%2d) [%13g %13g %13g %13g]%s",
                col && (m->columns > traceWrap) ? "      " : " ", col,
                m->data[row][col][0], m->data[row][col][1],
                m->data[row][col][2], m->data[row][col][3],
                m->columns > traceWrap ? "\n" : ""));
            if (traceHex) {
                NV_TRACE(TR_EVAL, 85, ("%2d) [x%08X x%08X x%08X x%08X] ", col,
                    *(const int *)&m->data[row][col][0], *(const int *)&m->data[row][col][1],
                    *(const int *)&m->data[row][col][2], *(const int *)&m->data[row][col][3]));
            }
        }
        NV_TRACE(TR_EVAL, 25, ("\n"));
    }
#endif
}

void TraceCurve(NV_PATCH_INFO *info, const NV_PATCH_CURVE_INFO *pCurve, char *pMess)
{
    int i;

    TPRINTF(("Curve '%s':\n", pMess));

    for (i = 0;  i < pCurve->order;  i++) {
        TPRINTF(("%2d) [%13g %13g %13g %13g]\n", i, pCurve->coeffs[i][0],
                pCurve->coeffs[i][1], pCurve->coeffs[i][2], pCurve->coeffs[i][3]));
    }
}

/*****************************************************************************/
NV_INLINE void CopyPoint(float *dst, const float *src)
// This will generate better code if dst and/or src are expressions or fancy structures.
// The reason is that dst and src are evaluated once.
// If done by hand in-line, the compiler may not optimize for the similarity of expressions.
// Looking at a few tests, without the inline function took 4*12=48 instructions,
// vs only 21 using CopyPoint
// Also, and just as important, I think it makes the code easier to read because
// it's more compact, not expanding x4 for each simple copy.
// And, as a bonus, if you are "watching" dst in the debugger, you may optionally
// step into this routine to see the values being copied. Otherwise, it may be a more
// laborious procedure to see what just happened.
{
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
}

static NV_INLINE void AddPoint(float *dst, float *src)
{
    dst[0] += src[0];
    dst[1] += src[1];
    dst[2] += src[2];
    dst[3] += src[3];
}

static NV_INLINE void AddPoint3(float *dst, float *src1, float *src2)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
    dst[3] = src1[3] + src2[3];
}

/*****************************************************************************/
static NV_INLINE void CopyCoeffs(NV_PATCH_INFO *info, NV_PATCH_CURVE_COEFFS *dst, NV_PATCH_CURVE_COEFFS *src)
// copy curve coeffs. Does not copy 'order'. May be used to copy matrix rows to curve coeffs.
{
    __NV_MEMCPY(dst, src, 4*info->maxOrder*sizeof(float));
}

void CopyCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, NV_PATCH_CURVE_INFO *src)
// copy curve, including order
{
#ifdef DCR_HOS_OPT
    float *srcptr, *dstptr;

    ASSERT_CURVE(src);
    switch (src->order) {
    case 2:
        dst->order = src->order;
        srcptr = (float*)(&src->coeffs[0][0]); dstptr = (float*)(&dst->coeffs[0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        return;
    case 4:
        dst->order = src->order;
        srcptr = (float*)(&src->coeffs[0][0]); dstptr = (float*)(&dst->coeffs[0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
        dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
        return;
    case 6:
        dst->order = src->order;
        srcptr = (float*)(&src->coeffs[0][0]); dstptr = (float*)(&dst->coeffs[0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
        dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
        dstptr[16] = srcptr[16]; dstptr[17] = srcptr[17]; dstptr[18] = srcptr[18]; dstptr[19] = srcptr[19];  //v4-xyzw
        dstptr[20] = srcptr[20]; dstptr[21] = srcptr[21]; dstptr[22] = srcptr[22]; dstptr[23] = srcptr[23];  //v5-xyzw
        return;
     default:
        ;   // fall thru to C code
    }
#endif

    ASSERT_CURVE(src);
    __NV_MEMCPY(dst, src, PATCH_CURVE_HEADER_SIZE + 4*info->maxOrder*sizeof(float));
}

static NV_INLINE void CopyCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *dst, FDCurveAttrSet *src)
{
    int index;
    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            CopyCurve(info, (*dst)[index], (*src)[index]);
        }
    }
}

/*****************************************************************************/
// copy one matrix
static NV_INLINE void CopyMatrix(NV_PATCH_INFO *info, FDMatrix *dst, const FDMatrix *src)
{
#ifdef DCR_HOS_OPT
    int i;
    float *srcptr, *dstptr;
#if !defined(IS_OPENGL)
    switch (src->rows) {
#else
    switch (MAX(src->rows, src->columns)) { // }
#endif
    case 2:
        dst->rows = src->rows;
        dst->columns = src->columns;
        srcptr = (float*)(&src->data[0][0][0]);
        dstptr = (float*)(&dst->data[0][0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        dstptr+=16*4; srcptr+=16*4;                                                                  //skip to next row
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v2-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v3-xyzw
        return;
    case 4:
        dst->rows = src->rows;
        dst->columns = src->columns;
        srcptr = (float*)(&src->data[0][0][0]);
        dstptr = (float*)(&dst->data[0][0][0]);
        for (i=0; i < 4; i++) {
            dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
            dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
            dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
            dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
            dstptr+=16*4; srcptr+=16*4;                                                                  //skip to next row
        }
        return;
    case 6:
        dst->rows = src->rows;
        dst->columns = src->columns;
        srcptr = (float*)(&src->data[0][0][0]);
        dstptr = (float*)(&dst->data[0][0][0]);
        for (i=0; i < 6; i++) {
            dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
            dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
            dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
            dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
            dstptr[16] = srcptr[16]; dstptr[17] = srcptr[17]; dstptr[18] = srcptr[18]; dstptr[19] = srcptr[19];  //v4-xyzw
            dstptr[20] = srcptr[20]; dstptr[21] = srcptr[21]; dstptr[22] = srcptr[22]; dstptr[23] = srcptr[23];  //v5-xyzw
            dstptr+=16*4; srcptr+=16*4;                                                                  //skip to next row
        }
        return;
    default:
        ;   // fall thru to C code
    }
#endif

    __NV_MEMCPY(dst, src, sizeof(FDMatrix));
}

static NV_INLINE void CopyMatrixTranspose(NV_PATCH_INFO *info, FDMatrix *dst, FDMatrix *src)
{
    int i,j;
    //THIS NEEDS TO BE IMPROVED!!!
    dst->rows = src->columns;
    dst->columns = src->rows;
    for (i=0; i < src->rows; i++) {
        for (j = 0; j < src->columns; j++) {
            dst->data[j][i][0] = src->data[i][j][0];
            dst->data[j][i][1] = src->data[i][j][1];
            dst->data[j][i][2] = src->data[i][j][2];
            dst->data[j][i][3] = src->data[i][j][3];
        }
    }
}

static NV_INLINE void CopyMatrixSet(NV_PATCH_INFO *info, int evalEnables, FDMatrixAttrSet *dst, FDMatrixAttrSet *src)
// copy set of matrices
{
    int index;
    for (index = 0; index < info->maxAttr; index++) {
        if (!(evalEnables & (1 << index))) {
            continue;
        }
        CopyMatrix(info, (*dst)[index], (*src)[index]);
    }
}

/*****************************************************************************/
void MatrixMult(NV_PATCH_INFO *info, FDMatrix *c, const FDMatrix *a, const FDMatrix *b)
{
    int row, col, term;

    NV_TRACE_COND(TR_EVAL, 55,
        TPRINTF(("MatrixMult:\n"));
        TraceMatrix(info, a);
        TraceMatrix(info, b);
    );

    c->rows    = a->rows;
    c->columns = b->columns;
    nvAssert(a->columns == b->rows);

#ifdef DCR_HOS_MATRIX_OPT
    if (g_FDGlobalData.cpuType) {
        switch (a->columns) {
        ??? what is this next line? Fred.
        PFMM p;
        case 4:
            p=(PFMM)(g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_4x4]);
            p(c, (FDMatrix*)a, (FDMatrix*)b);
            return;
        case 6:
            p=(PFMM)(g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_6x6]);
            p(c, (FDMatrix*)a, (FDMatrix*)b);
            return;
        case 2:
            //OFFSET_MATRIX_MULT_2x2
        default:
            //OFFSET_MATRIX_MULT_DEF
            ;   // fall thru to C code
        }
    }
#endif
    {
        for (row = 0; row < c->rows; row++) {
            for (col = 0; col < c->columns; col++) {
                c->data[row][col][0] = 0.0f;
                c->data[row][col][1] = 0.0f;
                c->data[row][col][2] = 0.0f;
                c->data[row][col][3] = 0.0f;
                for (term = 0; term < a->columns; term++) {
                    c->data[row][col][0] += a->data[row][term][0] * b->data[term][col][0];
                    c->data[row][col][1] += a->data[row][term][1] * b->data[term][col][1];
                    c->data[row][col][2] += a->data[row][term][2] * b->data[term][col][2];
                    c->data[row][col][3] += a->data[row][term][3] * b->data[term][col][3];
                }
            }
        }
    }
    NV_TRACE_COND(TR_EVAL, 45,
        TPRINTF(("... result:\n"));
        TraceMatrix(info, c);
    );
}

/*****************************************************************************/
// Fill in a column vector matrix using a sequence of strided xyzw values
void FillColumnVectorMatrix(int n, int stride, const float *data, FDMatrix *m, int col)
{
    int i;

    // nx1 matrix
    m->rows = n;
    //this implicitly assumes that  we are filling this one column at a time
    //such that we have the right value when we are done (i.e. the calls are made)
    //col = 1... n whe col=n is the LAST call.
    nvAssert(!col  ||  (col == m->columns));
    m->columns = (col+1);
    for (i = 0; i < n; i++) {
        m->data[i][col][0] = data[0]; m->data[i][col][1] = data[1];
        m->data[i][col][2] = data[2]; m->data[i][col][3] = data[3];
        data = (const float *)((const char *)data + stride);
    }
}

// Empty a column vector matrix into a sequence of strided xyzw values
void EmptyColumnVectorMatrix(int n, const FDMatrix *m, int stride, float *data, int col)
{
    int i;

    // Verify that it is a nx1 matrix
    nvAssert(m->rows == n);
    nvAssert(col < m->columns);

    // Empty data
    for (i = 0; i < n; i++) {
        // Copy data
        data[0] = m->data[i][col][0];
        data[1] = m->data[i][col][1];
        data[2] = m->data[i][col][2];
        data[3] = m->data[i][col][3];

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

/*****************************************************************************/
static FDMatrix bigToSmallMatrix[NV_PATCH_MAX_RETESS];
static FDMatrix smallToBigMatrix[NV_PATCH_MAX_RETESS];
static int retessGuard = 0xfeed1;

/*****************************************************************************/
// Compute FD coefficients from curve control points
void RetessCurveInOut(NV_PATCH_INFO *info, int smallToBig, NV_PATCH_CURVE_INFO *curve, NV_PATCH_CURVE_INFO *curveOut)
{
    FDMatrix *temp[3];

    ASSERT_CURVE(curve);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m0);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m1);
    temp[0] = &info->tempMatrix_m0;
    temp[1] = &info->tempMatrix_m1;

    if (smallToBig) {
        temp[2] = &smallToBigMatrix[curve->order];
    } else {
        temp[2] = &bigToSmallMatrix[curve->order];
    }

    // Compute FD curve coefficients
    FillColumnVectorMatrix(curve->order, 4*sizeof(float), &curve->coeffs[0][0], temp[0], 0);
    MatrixMult(info, temp[1], temp[2], temp[0]);
    EmptyColumnVectorMatrix(curve->order, temp[1], 4*sizeof(float), &curveOut->coeffs[0][0], 0);

    curveOut->order = curve->order;
    END_USING_TEMP_MATRIX(info->tempMatrix_m0);
    END_USING_TEMP_MATRIX(info->tempMatrix_m1);
}

// Compute FD coefficients from curve control points
void RetessCurveSetInOut(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDCurveAttrSet *pIn, FDCurveAttrSet *pOut)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessCurveInOut(info, smallToBig, (*pIn)[attr], (*pOut)[attr]);
        }
    }
}

void RetessCurve(NV_PATCH_INFO *info, int smallToBig, NV_PATCH_CURVE_INFO *curve)
{
    RetessCurveInOut(info, smallToBig, curve, curve);
}

/*****************************************************************************/
void RetessMatrixU(NV_PATCH_INFO *info, int smallToBig, FDMatrix *matrix)
{
    FDMatrix *temp[3];

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m0);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m1);
    temp[0] = &info->tempMatrix_m0;
    temp[1] = &info->tempMatrix_m1;

    if (smallToBig) {
        temp[2] = &smallToBigMatrix[matrix->columns];
    } else {
        temp[2] = &bigToSmallMatrix[matrix->columns];
    }

    // note: if we had MultTransposeMatrix then we could use the identity
    // transpose(AB) = transpose(B) * transpose(A)
    // and avoid a copy step
    CopyMatrixTranspose(info, temp[0], matrix);
    MatrixMult(info, temp[1], temp[2], temp[0]);
    CopyMatrixTranspose(info, matrix, temp[1]);
    END_USING_TEMP_MATRIX(info->tempMatrix_m0);
    END_USING_TEMP_MATRIX(info->tempMatrix_m1);
}

void RetessMatrixV(NV_PATCH_INFO *info, int smallToBig, FDMatrix *matrix)
{

    FDMatrix *temp[3];

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m0);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m1);
    temp[0] = &info->tempMatrix_m0;
    temp[1] = &info->tempMatrix_m1;
    if (smallToBig) {
        temp[2] = &smallToBigMatrix[matrix->rows];
    } else {
        temp[2] = &bigToSmallMatrix[matrix->rows];
    }

    // don't need a copy cause its not a transpose...
    MatrixMult(info, temp[1], temp[2], matrix);
    CopyMatrix(info, matrix, temp[1]);
    END_USING_TEMP_MATRIX(info->tempMatrix_m0);
    END_USING_TEMP_MATRIX(info->tempMatrix_m1);
}

void RetessMatrixUV(NV_PATCH_INFO *info, int smallToBig, FDMatrix *matrix)
{
    RetessMatrixU(info, smallToBig, matrix);
    RetessMatrixV(info, smallToBig, matrix);
}

void RetessMatrixSetU(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessMatrixU(info, smallToBig, (*pSet)[attr]);
        }
    }
}

void RetessMatrixSetV(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessMatrixV(info, smallToBig, (*pSet)[attr]);
        }
    }
}

void RetessMatrixSetUV(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessMatrixU(info, smallToBig, (*pSet)[attr]);
            RetessMatrixV(info, smallToBig, (*pSet)[attr]);
        }
    }
}

/*****************************************************************************/
/*****************************************************************************/
// Compare two vertices and return an edge direction
// a->b is 1, b->a is 0
static int CompareVertices(const float *a, const float *b)
{
    // Compare X
    if (a[0] > b[0]) {
        return 0;
    } else if (a[0] < b[0]) {
        return 1;
    }

    // Compare Y
    if (a[1] > b[1]) {
        return 0;
    } else if (a[1] < b[1]) {
        return 1;
    }

    // Compare Z
    if (a[2] > b[2]) {
        return 0;
    } else if (a[2] < b[2]) {
        return 1;
    }

    // Compare W
    if (a[3] > b[3]) {
        return 0;
    } else if (a[3] < b[3]) {
        return 1;
    }

    // actually, if the two points are equal, the "right" thing to do
    // would be to examine the interior control points to determine
    // a sorting.

    // Arbitrary case
    return 1;
}

#if defined(ENABLE_DEBUG_REVERSE_TRANSITIONS)
void
setDebugColors(int tri, NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, int *u0Dir, int *u1Dir, int *v0Dir, int *v1Dir)
{
    int uorder = map->uorder;
    int vorder = map->vorder;
    int ufStride = map->ufStride;
    int vfStride = map->vfStride;
    float *rawData = map->rawData;
    float *pf;

    // test to force reverse transitions whether colors altered or not
    if (nvDebugOptions & TRO_TEMP1) {
        *u0Dir ^= 1;
    }
    if (nvDebugOptions & TRO_TEMP2) {
        *u1Dir ^= 1;
    }
    if (nvDebugOptions & TRO_TEMP3) {
        *v0Dir ^= 1;
    }
    if (nvDebugOptions & TRO_TEMP4) {
        *v1Dir ^= 1;
    }

    if (uorder < 4  ||  vorder < 4) {
        return;
    }

    if (nvDebugOptions & TRO_TEMP1) {
        pf = pRawData(info, map, rawData, 0, 1);
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 0.f; pf[3] = 1.f;
        pf += ufStride;
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 0.f; pf[3] = 1.f;
    }

    if (nvDebugOptions & TRO_TEMP2) {
        pf = pRawData(info, map, rawData, vorder-1, 1);
        pf[0] = 0.f; pf[1] = 9.f; pf[2] = 0.f; pf[3] = 1.f;
        pf += ufStride;
        pf[0] = 0.f; pf[1] = 9.f; pf[2] = 0.f; pf[3] = 1.f;
    }

    if (nvDebugOptions & TRO_TEMP3) {
        pf = pRawData(info, map, rawData, 1, 0);
        pf[0] = 0.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
        pf += vfStride;
        pf[0] = 0.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
    }

    if (nvDebugOptions & TRO_TEMP4) {
        pf = pRawData(info, map, rawData, 1, uorder-1-tri);
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
        pf += vfStride;
        if (tri) {
            pf -= 4;
        }
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
    }
}
#endif

// Compute the directions of the four edges of a patch
void ComputeEdgeDirections(NV_PATCH_INFO *info, int tri, NV_PATCH_MAP_INFO *map,
                           int *u0Dir, int *u1Dir, int *v0Dir, int *v1Dir)
{
    int uorder = map->uorder;
    int vorder = map->vorder;
    float *rawData = map->rawData;
    const float *p00, *p10, *p01, *p11; //p[x][y]

    if (rawData == NULL) {
        // assuming that unenabled maps have a null pointer
        // if we don't have a position punt for now and assume no reversals
        *u0Dir = *u1Dir = *v0Dir = *v1Dir = 1;
        return;
    }

    p00 = pRawData(info, map, rawData, 0,        0);
    p10 = pRawData(info, map, rawData, 0,        uorder-1);
    p01 = pRawData(info, map, rawData, vorder-1, 0       );
    p11 = pRawData(info, map, rawData, vorder-1, uorder-1);

    if (tri) {
        *u0Dir = *u1Dir = CompareVertices(p00, p10);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p01);
    } else {
        *u0Dir = CompareVertices(p00, p10);
        *u1Dir = CompareVertices(p01, p11);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p11);
    }

#if defined(ENABLE_DEBUG_REVERSE_TRANSITIONS)
    NV_TRACE_COND(TR_EVAL, 1,
        setDebugColors(tri, info, &map[3], u0Dir, u1Dir, v0Dir, v1Dir);
    );
    NV_TRACE_COND(TR_EVAL, 20,
        if (nvDebugOptions & TRO_TEMP1) { TPRINTF(("Change u0dir to %d\n", *u0Dir)); }
        if (nvDebugOptions & TRO_TEMP2) { TPRINTF(("Change u1dir to %d\n", *u1Dir)); }
        if (nvDebugOptions & TRO_TEMP3) { TPRINTF(("Change v0dir to %d\n", *v0Dir)); }
        if (nvDebugOptions & TRO_TEMP4) { TPRINTF(("Change v1dir to %d\n", *v1Dir)); }
    );
#endif
}

void ComputeEdgeDirectionsFromCorners(NV_PATCH_INFO *info, int tri,
                           int *u0Dir, int *u1Dir, int *v0Dir, int *v1Dir)
{
    const float *p00, *p10, *p01, *p11; //p[x][y]

    //cornAttr[attrib][v][u][xyzw]
    p00 = &(info->quadInfo->cornAttr[0].corners[0][0][0]); //    p00 = pRawData(info, map, rawData, 0,        0);
    p10 = &(info->quadInfo->cornAttr[0].corners[0][1][0]); //    p10 = pRawData(info, map, rawData, 0,        uorder-1);
    p01 = &(info->quadInfo->cornAttr[0].corners[1][0][0]); //    p01 = pRawData(info, map, rawData, vorder-1, 0       );
    p11 = &(info->quadInfo->cornAttr[0].corners[1][1][0]); //    p11 = pRawData(info, map, rawData, vorder-1, uorder-1);

    if (tri) {
        *u0Dir = *u1Dir = CompareVertices(p00, p10);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p01);
    } else {
        *u0Dir = CompareVertices(p00, p10);
        *u1Dir = CompareVertices(p01, p11);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p11);
    }

#if defined(ENABLE_DEBUG_REVERSE_TRANSITIONS)
    nvAssert(0); //shouldn't ever really get this in OGL without Cached patches which they don't have
/*
    NV_TRACE_COND(TR_EVAL, 1,
        setDebugColors(tri, info, &map[3], u0Dir, u1Dir, v0Dir, v1Dir);
    );
    NV_TRACE_COND(TR_EVAL, 20,
        if (nvDebugOptions & TRO_TEMP1) { TPRINTF(("Change u0dir to %d\n", *u0Dir)); }
        if (nvDebugOptions & TRO_TEMP2) { TPRINTF(("Change u1dir to %d\n", *u1Dir)); }
        if (nvDebugOptions & TRO_TEMP3) { TPRINTF(("Change v0dir to %d\n", *v0Dir)); }
        if (nvDebugOptions & TRO_TEMP4) { TPRINTF(("Change v1dir to %d\n", *v1Dir)); }
    );
*/
#endif
}


#if defined(ENABLE_DEBUG_SWATH) && defined(IS_OPENGL)
/*****************************************************************************/
int onColor = 0;
float evalColors[8][3] = {
        {1, 0, 0},
        {0, 1, 0},
        {0, 0, 1},
        {0, 1, 1},
        {1, 0, 1},
        {1, 1, 0},
        {1, 1, 1},
        {0, 0, 0},
    };
void evalDrawCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *pCurve, int scaleDown)
{
    int ii, lColor;
    NV_PATCH_CURVE_INFO curve;

    if (scaleDown & 8) {
        scaleDown = (info->swatchFlags & NV_PATCH_SWATCH);
    }
    glColor3fv(evalColors[(onColor++) & 0x7]);
    CopyCurve(info, &curve, pCurve);
    if ((info->swatchFlags & NV_PATCH_SWATCH)  &&  scaleDown) {
        RetessCurveInOut(info, 0, &curve, &curve);
    }
    glBegin(GL_LINE_STRIP);
    for (ii = 0;  ii < 4;  ii++) {
        glVertex3fv(curve.coeffs[0]);
        OffsetCurve(info, &curve, 1);
    }
    glEnd();

    CopyCurve(info, &curve, pCurve);
    if (scaleDown) {
        RetessCurveInOut(info, 0, &curve, &curve);
    }
    lColor = 0;
    glPointSize(8.f);
    glBegin(GL_POINTS);
    for (ii = 0;  ii < 4;  ii++) {
        glColor3fv(evalColors[(lColor++) & 0x7]);
        glVertex3fv(curve.coeffs[0]);
        OffsetCurve(info, &curve, 1);
    }
    glEnd();
}

void evalDrawMatrix(NV_PATCH_INFO *info, const FDMatrix *m, int bigU, int bigV)
{
    NV_PATCH_CURVE_INFO curveU, curveV;
    FDMatrix lm;
    int row;

    ExtractUCurve(info, &curveU, m);
    ExtractVCurve(info, &curveV, m);

    evalDrawCurve(info, &curveU, bigU);

    evalDrawCurve(info, &curveV, bigV);

    CopyMatrix(info, &lm, m);

    if (bigV & 8) {
        bigV = (info->swatchFlags & NV_PATCH_SWATCH);
    }
    if (bigV) {
        RetessMatrixV(info, 0, &lm);
    }
    for (row = 0;  row < 3;  row++) {
        OffsetFDMatrix(info, &lm, 0, 1);
        ExtractUCurve(info, &curveU, &lm);
        evalDrawCurve(info, &curveU, bigU);
    }
}
#endif  // defined(ENABLE_DEBUG_SWATH) && defined(IS_OPENGL)

/*****************************************************************************/
// Load m with a Bezier basis matrix, or the inverse of a Bezier basis matrix
void ComputeBasis(int order, int inverse, FDMatrix *m)
{
    int row, col;
    float *matrix = NULL;

    // Inverse matrices have been pulled out for now, as the current code does not need them
    nvAssert(inverse == 0);

    // nxn matrix where n = order
    m->rows = m->columns = order;

    // Select the appropriate matrix
    matrix = bezBasis[order-1];

    if (!matrix) { nvAssert(0); return; }

    // Load matrix
    for (row = 0; row < order; row++) {
        for (col = 0; col < order; col++) {
            float coeff = *matrix++;
            m->data[row][col][0] = coeff;
            m->data[row][col][1] = coeff;
            m->data[row][col][2] = coeff;
            m->data[row][col][3] = coeff;
        }
    }
}

// Compute the matrix 'P' for FD coefficients, as defined by Henry's paper
void ComputeP(int order, float step, FDMatrix *m)
{
    int row, col, i;
    float f;

    // nxn matrix where n = order
    m->rows = m->columns = order;

    // Fill with zeros
    for (row = 0; row < order; row++) {
        for (col = 0; col < order; col++) {
            m->data[row][col][0] = 0.0f;
            m->data[row][col][1] = 0.0f;
            m->data[row][col][2] = 0.0f;
            m->data[row][col][3] = 0.0f;
        }
    }

    // Fill in diagonal
    for (i = order-1, f = 1.0f; i >= 0; i--, f *= step) {
        m->data[i][i][0] = f;
        m->data[i][i][1] = f;
        m->data[i][i][2] = f;
        m->data[i][i][3] = f;
    }
}

// Compute the matrix to convert from a power basis to an FD basis
void ComputePowerToFD(int order, FDMatrix *m, int flags)
{
    int row, col;
    float *matrix;

    // nxn matrix where n = order
    m->rows = m->columns = order;

    if (flags & 1) {
        matrix = inversePowerToFD[order-1];
    } else {
        matrix = powerToFD[order-1];
    }

    // Load matrix
    for (row = 0; row < order; row++) {
        for (col = 0; col < order; col++) {
            float coeff = *matrix++;
            if (flags & 2) {
                coeff *= oofactorial[row];
            }
            m->data[row][col][0] = coeff;
            m->data[row][col][1] = coeff;
            m->data[row][col][2] = coeff;
            m->data[row][col][3] = coeff;
        }
    }
}

/*****************************************************************************/
// Extract the U curve from a FDMatrix into a curve
void ExtractUCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m)
{
    dst->order = m->columns;
    __NV_MEMCPY(dst->coeffs[0], m->data[0][0], 4*m->columns*sizeof(float));
}

void ExtractUCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *dst, FDMatrixAttrSet *pSet)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            ExtractUCurve(info, (*dst)[index], (*pSet)[index]);
        }
    }
}

/*****************************************************************************/
// Compare the V curve from a FDMatrix to a curve
void CompareVCurveMatrix(NV_PATCH_CURVE_INFO *dst, FDMatrix *m)
{
    int i, stride = 4*sizeof(float);
    float *data = dst->coeffs[0];

    nvAssert(dst->order == m->rows);
    // Empty data
    for (i = 0; i < dst->order; i++) {
        // Compare data
        nvAssert(EV_AS_INT(data[0]) == EV_AS_INT(m->data[i][0][0]));
        nvAssert(EV_AS_INT(data[1]) == EV_AS_INT(m->data[i][0][1]));
        nvAssert(EV_AS_INT(data[2]) == EV_AS_INT(m->data[i][0][2]));
        nvAssert(EV_AS_INT(data[3]) == EV_AS_INT(m->data[i][0][3]));

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

// Extract the V curve from a FDMatrix into a curve
void ExtractVCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m)
{
    int i, stride = 4*sizeof(float);
    float *data = dst->coeffs[0];

    dst->order = m->rows;
    for (i = 0; i < dst->order; i++) {
        // Copy data
        CopyPoint(data, m->data[i][0]);

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

void ExtractVCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *dst, FDMatrixAttrSet *pSet)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            ExtractVCurve(info, (*dst)[index], (*pSet)[index]);
        }
    }
}

/*****************************************************************************/
extern const double *evalRetessTables[NV_PATCH_MAX_RETESS];
void evalFillPower(double r, double *prPower)
{
    prPower[1] = r;
    prPower[2] = r*r;
    prPower[3] = prPower[2] * r;
    prPower[4] = prPower[2] * prPower[2];
    prPower[5] = prPower[4] * r;
    prPower[6] = prPower[4] * prPower[2];
    prPower[7] = prPower[4] * prPower[3];
    prPower[8] = prPower[4] * prPower[4];
    prPower[9] = prPower[8] * r;
    prPower[10] = prPower[8] * prPower[2];
    prPower[11] = prPower[8] * prPower[3];
    prPower[12] = prPower[8] * prPower[4];
    prPower[13] = prPower[8] * prPower[5];
    prPower[14] = prPower[8] * prPower[6];
    prPower[15] = prPower[8] * prPower[7];
    //ffprPower[16] = prPower[8] * prPower[8];
    //ffprPower[17] = prPower[16] * r;
    //ffprPower[18] = prPower[16] * prPower[2];
}

void evalFillOneRetessMatrix(NV_PATCH_INFO *info, double *prPower, int order, FDMatrix *dst)
{
    int elem, idx, row, col;
    double dd;
    const double *prTable;

    (*dst).rows = order;
    (*dst).columns = order;
    for (row = 0;  row < order;  row++) {
        for (col = 0;  col < order;  col++) {
            idx = order * (order * row + col);
            prTable = &evalRetessTables[order][idx];
            dd = 0.;
            for (elem = 0;  elem < order;  elem++) {
                dd += prPower[elem] * prTable[elem];
            }
            (*dst).data[row][col][0] = dd;
            (*dst).data[row][col][1] = dd;
            (*dst).data[row][col][2] = dd;
            (*dst).data[row][col][3] = dd;
        }
    }
    NV_TRACE_COND(TR_EVAL, 55,
        TPRINTF(("calc retess matrix r=%g order=%d\n", prPower[1], order));
        TraceMatrix(info, dst);
    );
}

void evalFillOnePowerAndRetessMatrix(NV_PATCH_INFO *info, int order, float newOverOld, FDMatrix *dst)
{
    double rPower[NV_PATCH_MAX_RETESS] = {1.};

    evalFillPower(newOverOld, rPower);
    evalFillOneRetessMatrix(info, rPower, order, dst);
}

void evalFillAllRetessMatrices(NV_PATCH_INFO *info, float newOverOld, FDMatrix *dst)
{
    int order;
    double rPower[NV_PATCH_MAX_RETESS] = {1.};

    evalFillPower(newOverOld, rPower);
    for (order = 2;  order < NV_PATCH_MAX_RETESS;  order++) {
        evalFillOneRetessMatrix(info, rPower, order, &dst[order]);
    }
}

void evalFillRetessMatrices(NV_PATCH_INFO *info)
// note: order = (degree + 1)
{
    int degree;

    factorial[0] = 1.;
    factorial[1] = 1.;
    for (degree = 2;  degree <= NV_PATCH_MAX_RETESS;  degree++) {
        factorial[degree] = degree * factorial[degree-1];
    }
    for (degree = 0;  degree <= NV_PATCH_MAX_RETESS;  degree++) {
        oofactorial[degree] = 1. / factorial[degree];
    }

    evalFillAllRetessMatrices(info, info->maxSwatch,      smallToBigMatrix);
    evalFillAllRetessMatrices(info, 1. / info->maxSwatch, bigToSmallMatrix);
    nvAssert(retessGuard == 0xfeed1);   // attempt to catch init over-runs
}

/*****************************************************************************/
// Check the retessllation cache to see if we've cached some work here
int CheckRetessellationCache(NV_PATCH_INFO *info, unsigned int tag1, unsigned int tag2, FDMatrix **m)
{
    //m should be null because it will be overwritten here.
    nvAssert(*m==NULL);

    if (g_FDGlobalData.RetessFDtag[0][0] == tag1 && g_FDGlobalData.RetessFDtag[0][1] == tag2) {
        *m = g_FDGlobalData.RetessFDCache[0];
        g_FDGlobalData.RetessFDMRU = 0;
    } else if (g_FDGlobalData.RetessFDtag[1][0] == tag1 && g_FDGlobalData.RetessFDtag[1][1] == tag2) {
        *m = g_FDGlobalData.RetessFDCache[1];
        g_FDGlobalData.RetessFDMRU = 1;
    } else {
        *m = (FDMatrix *)__NV_MALLOC(info->context, sizeof(FDMatrix));

        //replace cache slot with newly computed value
        g_FDGlobalData.RetessFDMRU = (1-g_FDGlobalData.RetessFDMRU);
        if (g_FDGlobalData.RetessFDCache[g_FDGlobalData.RetessFDMRU]) {
            __NV_FREE(info->context, g_FDGlobalData.RetessFDCache[g_FDGlobalData.RetessFDMRU]);
        }
        g_FDGlobalData.RetessFDCache[g_FDGlobalData.RetessFDMRU] = *m;
        g_FDGlobalData.RetessFDtag[g_FDGlobalData.RetessFDMRU][0] = tag1;
        g_FDGlobalData.RetessFDtag[g_FDGlobalData.RetessFDMRU][1] = tag2;
        return 0;
    }

    return 1;
}

/*****************************************************************************/
// Compute FD coefficients from curve control points
void ComputeFDCurveFlip(NV_PATCH_INFO *info, int order, float step, NV_PATCH_CURVE_INFO *pCurve,
                const float *points, int stride, int dir, int flipped)
{
    float *coeffs = pCurve->coeffs[0];
    FDMatrix *basis, *m, *p;
    FDMatrix *temp[3];
    EV_ALLOC_DECL();
#ifdef DCR_COMPUTEFDCURVEFLIP_OPT
    unsigned int tag1, tag2;
#endif
    int mbytes = EV_ROUND(sizeof(FDMatrixd));

    EV_ALLOC_INIT_WITH_CACHE(info->context, /*16 + 2* */6 * mbytes, computeFDCurveCoeffsEnd, info->pCache[EV_CACHE_9FDMATRICES]);
#if 0
if (*(int *)evMemory.pBase & 8) {
    EV_ALLOC(basis, info->context, 8);
}

EV_ALLOC(ptemp, info->context, mbytes);
EV_ALLOC(ptemp, info->context, mbytes);
EV_ALLOC(ptemp, info->context, mbytes);
#endif
    EV_ALLOC(basis, info->context, mbytes);
    EV_ALLOC(m, info->context, mbytes);
    EV_ALLOC(p, info->context, mbytes);
    EV_ALLOC(temp[0], info->context, mbytes);
    EV_ALLOC(temp[1], info->context, mbytes);
    EV_ALLOC(temp[2], info->context, mbytes);
//ffEV_ALLOC(ptemp, info->context, mbytes);
//ffEV_ALLOC(ptemp, info->context, mbytes);
//ffEV_ALLOC(ptemp, info->context, mbytes);
    EV_ALLOC_FULL(info->context);

    if (flipped) {
        stride = -stride;
    }
    // Reverse direction of points if necessary
    if (!dir) {
        points = (const float *)((const char *)points + (order-1)*stride);
        stride = -stride;
    }

#if 0
if (order == 6 && dotime) {
dotime = 0;
tprintf("\ntime curve info: order %d\n", order);
PrintInt(mbytes);
PrintInt(basis);
PrintInt(p);
PrintInt(m);
PrintInt(temp[0]);
PrintInt(temp[1]);
PrintInt(temp[2]);

    ComputeBasisd(order, 0, (FDMatrixd *)basis);
    ComputePd(order, step, (FDMatrixd *)p);
    ComputePowerToFDd(order, (FDMatrixd *)m, 0);

    FillMatrixd(info, 0, (FDMatrixd *)basis);
    FillMatrixd(info, 0, (FDMatrixd *)p);
    FillMatrixd(info, 0, (FDMatrixd *)m);
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)p, (FDMatrixd *)basis);
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)m, (FDMatrixd *)temp[1]);
    FillMatrixd(info, 0, (FDMatrixd *)temp[0]);
    FillMatrixd(info, 0, (FDMatrixd *)temp[1]);
    FillMatrixd(info, 0, (FDMatrixd *)temp[2]);

//ffTIME_CODE_REPEAT(nRepeat, 1, "double 1 P B",
    //ffMatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
//ff); 
//ffTIME_CODE_REPEAT(nRepeat, 1, "double 2 M 1",
    //ffMatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)m, (FDMatrixd *)temp[1]);
//ff);

VtResumeSampling();
TIME_CODE_REPEAT(nRepeat, 1, "double P M B",
    MatrixMultd(info, (FDMatrixd *)p, (FDMatrixd *)m, (FDMatrixd *)basis);
);
VtPauseSampling();

TIME_CODE_REPEAT(nRepeat, 1, "double 0 M B",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)m, (FDMatrixd *)basis);
);
#if 0
TIME_CODE_REPEAT(nRepeat, 1, "double 1 M B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)m, (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 2 M B",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)m, (FDMatrixd *)basis);
);
//...
TIME_CODE_REPEAT(nRepeat, 1, "double P M B rev",
    MatrixMultd(info, (FDMatrixd *)p, (FDMatrixd *)basis, (FDMatrixd *)m);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 0 M B rev",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)basis, (FDMatrixd *)m);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 M B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)m);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 2 M B rev",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)basis, (FDMatrixd *)m);
);

TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)p, (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
);
//...
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)basis, (FDMatrixd *)p);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)p);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)p);
);

TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)temp[0], (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)temp[0], (FDMatrixd *)basis);
);
//...
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)temp[0]);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)basis, (FDMatrixd *)temp[0]);
);
#endif

}
#endif

#ifdef DCR_COMPUTEFDCURVEFLIP_OPT
    temp[2] = NULL;
    tag1 = (0xFFFF0000 | order);
    tag2 = *(unsigned int *)(&step);
    if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) 
    {
        // Compute matrices for the calculation
        ComputeBasis(order, 0, basis);
        ComputeP(order, step, p);
        ComputePowerToFD(order, m, 0);
        MatrixMult(info, temp[1], p, basis);
        MatrixMult(info, temp[2], m, temp[1]);
    }
    // Compute FD curve coefficients
    FillColumnVectorMatrix(order, stride, points, temp[0], 0);
    MatrixMult(info, temp[1], temp[2], temp[0]);
    EmptyColumnVectorMatrix(order, temp[1], 4*sizeof(float), coeffs, 0);
#else
    // Compute matrices for the calculation
    ComputeBasis(order, 0, basis);
    ComputeP(order, step, p);
    ComputePowerToFD(order, m, 0);

    // Compute FD curve coefficients
    FillColumnVectorMatrix(order, stride, points, temp[0], 0);
    MatrixMult(info, temp[1], basis, temp[0]);
    MatrixMult(info, temp[0], p, temp[1]);
    MatrixMult(info, temp[1], m, temp[0]);
    EmptyColumnVectorMatrix(order, temp[1], 4*sizeof(float), coeffs, 0);
#endif

    NV_TRACE_COND(TR_EVAL, 35,
        int i;

        TPRINTF(("FDCurve order=%d  stride=%d  dir=%d\n", order, stride, dir));
        for (i = 0;  i < order;  i++) {
            TPRINTF(("\t%d) [%7.5f %7.5f %7.5f %7.5f]\n", i, coeffs[i*4+0], coeffs[i*4+1], coeffs[i*4+2], coeffs[i*4+3]));
        }
        TPRINTF(("\n"));
    );
computeFDCurveCoeffsEnd:
    EV_FREE(basis, info->context);
    EV_FREE(m, info->context);
    EV_FREE(p, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
}

#define ONE_HALF 0.5
#define ONE_SIXTH 1.0f/6.0f
#define ONE_ONE_TWENTIETH 1.0f/120.0f
#define ONE_TWENTY_FOURTH 1.0f/24.0f
#define ONE_TWELFTH 1.0f/12.0f
#define ONE_FOURTH 1.0f/4.0f
void ComputeReversedRetessellation(NV_PATCH_INFO *info, int order, float a, float b, FDMatrix *temp[3], FDMatrix *m, FDMatrix *p, FDMatrix *mInv)
{
    float ib,ib2,ib3,ib4,ib5,b2,b3,b4;
    float r,r2,r3,r4,r5;    
    float ftemp;   
    FDMatrix *outMatrix = temp[2];
    r=a/b;
    switch(order-1) {                
    case 3: //cubic
        ib = 1/b; ib2 = ib*ib; ib3 = ib2*ib; r2 = r*r; r3 = r2*r;
        outMatrix->rows = outMatrix->columns = order;        
        outMatrix->data[0][0][3] = outMatrix->data[0][0][2] = outMatrix->data[0][0][1] = outMatrix->data[0][0][0] = 1;
        outMatrix->data[0][1][3] = outMatrix->data[0][1][2] = outMatrix->data[0][1][1] = outMatrix->data[0][1][0] = ib;    ftemp = (1-b)*ONE_HALF*ib2;
        outMatrix->data[0][2][3] = outMatrix->data[0][2][2] = outMatrix->data[0][2][1] = outMatrix->data[0][2][0] = ftemp; ftemp = (-1+b)*(-1+2*b)*ONE_SIXTH*ib3;
        outMatrix->data[0][3][3] = outMatrix->data[0][3][2] = outMatrix->data[0][3][1] = outMatrix->data[0][3][0] = ftemp;    

        outMatrix->data[1][0][3] = outMatrix->data[1][0][2] = outMatrix->data[1][0][1] = outMatrix->data[1][0][0] = 0;
        outMatrix->data[1][1][3] = outMatrix->data[1][1][2] = outMatrix->data[1][1][1] = outMatrix->data[1][1][0] = -r;    ftemp = r*(-2+b+b*r)*ONE_HALF*ib;
        outMatrix->data[1][2][3] = outMatrix->data[1][2][2] = outMatrix->data[1][2][1] = outMatrix->data[1][2][0] = ftemp; ftemp = -r*(3+b*(2+r)*(-3+b+b*r))*ONE_SIXTH*ib2;
        outMatrix->data[1][3][3] = outMatrix->data[1][3][2] = outMatrix->data[1][3][1] = outMatrix->data[1][3][0] = ftemp;    

        outMatrix->data[2][0][3] = outMatrix->data[2][0][2] = outMatrix->data[2][0][1] = outMatrix->data[2][0][0] = 0;
        outMatrix->data[2][1][3] = outMatrix->data[2][1][2] = outMatrix->data[2][1][1] = outMatrix->data[2][1][0] = 0;
        outMatrix->data[2][2][3] = outMatrix->data[2][2][2] = outMatrix->data[2][2][1] = outMatrix->data[2][2][0] = r2;    ftemp = -r2*(-1+b+b*r)*ib;
        outMatrix->data[2][3][3] = outMatrix->data[2][3][2] = outMatrix->data[2][3][1] = outMatrix->data[2][3][0] = ftemp;    

        outMatrix->data[3][0][3] = outMatrix->data[3][0][2] = outMatrix->data[3][0][1] = outMatrix->data[3][0][0] = 0;
        outMatrix->data[3][1][3] = outMatrix->data[3][1][2] = outMatrix->data[3][1][1] = outMatrix->data[3][1][0] = 0;
        outMatrix->data[3][2][3] = outMatrix->data[3][2][2] = outMatrix->data[3][2][1] = outMatrix->data[3][2][0] = 0;
        outMatrix->data[3][3][3] = outMatrix->data[3][3][2] = outMatrix->data[3][3][1] = outMatrix->data[3][3][0] = -r3;       
        return;        
    case 5:
        ib = 1/b; ib2 = ib*ib; ib3 = ib2*ib; ib4 = ib2*ib2; ib5 = ib4*ib; 
        r2 = r*r; r3 = r2*r, r4=r2*r2; r5=r3*r2;
        b2 = b*b; b3 = b2*b; b4 = b2*b2;
        outMatrix->rows = outMatrix->columns = order;        
        outMatrix->data[0][0][3] = outMatrix->data[0][0][2] = outMatrix->data[0][0][1] = outMatrix->data[0][0][0] = 1;
        outMatrix->data[0][1][3] = outMatrix->data[0][1][2] = outMatrix->data[0][1][1] = outMatrix->data[0][1][0] = ib;    ftemp = (1-b)*ONE_HALF*ib2;
        outMatrix->data[0][2][3] = outMatrix->data[0][2][2] = outMatrix->data[0][2][1] = outMatrix->data[0][2][0] = ftemp; ftemp = (-1+b)*(-1+2*b)*ONE_SIXTH*ib3;
        outMatrix->data[0][3][3] = outMatrix->data[0][3][2] = outMatrix->data[0][3][1] = outMatrix->data[0][3][0] = ftemp; ftemp = (1+b*(-6+(11-6*b)*b))*ONE_TWENTY_FOURTH*ib4;    
        outMatrix->data[0][4][3] = outMatrix->data[0][4][2] = outMatrix->data[0][4][1] = outMatrix->data[0][4][0] = ftemp; ftemp = (-1+b)*(-1+2*b)*(-1+3*b)*(-1+4*b)*ONE_ONE_TWENTIETH*ib5;
        outMatrix->data[0][5][3] = outMatrix->data[0][5][2] = outMatrix->data[0][5][1] = outMatrix->data[0][5][0] = ftemp;    

        outMatrix->data[1][0][3] = outMatrix->data[1][0][2] = outMatrix->data[1][0][1] = outMatrix->data[1][0][0] = 0;
        outMatrix->data[1][1][3] = outMatrix->data[1][1][2] = outMatrix->data[1][1][1] = outMatrix->data[1][1][0] = -r;    ftemp = r*(-2+b+b*r)*ONE_HALF*ib;
        outMatrix->data[1][2][3] = outMatrix->data[1][2][2] = outMatrix->data[1][2][1] = outMatrix->data[1][2][0] = ftemp; ftemp = -r*(3+b*(2+r)*(-3+b+b*r))*ONE_SIXTH*ib2;
        outMatrix->data[1][3][3] = outMatrix->data[1][3][2] = outMatrix->data[1][3][1] = outMatrix->data[1][3][0] = ftemp; ftemp = r*(2+b2*(1+r)*(2+r)-2*b*(3+r))*(-2+b*(3+r))*ONE_TWENTY_FOURTH*ib3;
        outMatrix->data[1][4][3] = outMatrix->data[1][4][2] = outMatrix->data[1][4][1] = outMatrix->data[1][4][0] = ftemp; ftemp = r*(-5+10*b*(4+r)-b4*(1+r)*(2+r)*(3+r)*(4+r)+5*b3*(4+r)*(5+r*(4+r))-5*b2*(21+2*r*(6+r)))*ONE_ONE_TWENTIETH*ib4;
        outMatrix->data[1][5][3] = outMatrix->data[1][5][2] = outMatrix->data[1][5][1] = outMatrix->data[1][5][0] = ftemp;    

        outMatrix->data[2][0][3] = outMatrix->data[2][0][2] = outMatrix->data[2][0][1] = outMatrix->data[2][0][0] = 0;
        outMatrix->data[2][1][3] = outMatrix->data[2][1][2] = outMatrix->data[2][1][1] = outMatrix->data[2][1][0] = 0;
        outMatrix->data[2][2][3] = outMatrix->data[2][2][2] = outMatrix->data[2][2][1] = outMatrix->data[2][2][0] = r2;    ftemp = -r2*(-1+b+b*r)*ib;
        outMatrix->data[2][3][3] = outMatrix->data[2][3][2] = outMatrix->data[2][3][1] = outMatrix->data[2][3][0] = ftemp; ftemp = r2*(6-6*b*(3+2*r)+b2*(1+r)*(11+7*r))*ib2*ONE_TWELFTH;
        outMatrix->data[2][4][3] = outMatrix->data[2][4][2] = outMatrix->data[2][4][1] = outMatrix->data[2][4][0] = ftemp; ftemp = -r2*(-1+b*(2+r))*(2-4*b*(2+r)+b2*(1+r)*(5+3*r))*ONE_TWELFTH*ib3;
        outMatrix->data[2][5][3] = outMatrix->data[2][5][2] = outMatrix->data[2][5][1] = outMatrix->data[2][5][0] = ftemp;    

        outMatrix->data[3][0][3] = outMatrix->data[3][0][2] = outMatrix->data[3][0][1] = outMatrix->data[3][0][0] = 0;
        outMatrix->data[3][1][3] = outMatrix->data[3][1][2] = outMatrix->data[3][1][1] = outMatrix->data[3][1][0] = 0;
        outMatrix->data[3][2][3] = outMatrix->data[3][2][2] = outMatrix->data[3][2][1] = outMatrix->data[3][2][0] = 0;
        outMatrix->data[3][3][3] = outMatrix->data[3][3][2] = outMatrix->data[3][3][1] = outMatrix->data[3][3][0] = -r3;   ftemp = r3*(-2+3*b*(1+r))*ONE_HALF*ib;     
        outMatrix->data[3][4][3] = outMatrix->data[3][4][2] = outMatrix->data[3][4][1] = outMatrix->data[3][4][0] = ftemp; ftemp = -r3*(2-2*b*(4+3*r)+b2*(1+r)*(7+5*r))*ONE_FOURTH*ib2;
        outMatrix->data[3][5][3] = outMatrix->data[3][5][2] = outMatrix->data[3][5][1] = outMatrix->data[3][5][0] = ftemp;       

        outMatrix->data[4][0][3] = outMatrix->data[4][0][2] = outMatrix->data[4][0][1] = outMatrix->data[4][0][0] = 0;
        outMatrix->data[4][1][3] = outMatrix->data[4][1][2] = outMatrix->data[4][1][1] = outMatrix->data[4][1][0] = 0;
        outMatrix->data[4][2][3] = outMatrix->data[4][2][2] = outMatrix->data[4][2][1] = outMatrix->data[4][2][0] = 0;
        outMatrix->data[4][3][3] = outMatrix->data[4][3][2] = outMatrix->data[4][3][1] = outMatrix->data[4][3][0] = 0;   
        outMatrix->data[4][4][3] = outMatrix->data[4][4][2] = outMatrix->data[4][4][1] = outMatrix->data[4][4][0] = r4;    ftemp = r4*(1-2*b*(1+r))*ib;
        outMatrix->data[4][5][3] = outMatrix->data[4][5][2] = outMatrix->data[4][5][1] = outMatrix->data[4][5][0] = ftemp;       

        outMatrix->data[5][0][3] = outMatrix->data[5][0][2] = outMatrix->data[5][0][1] = outMatrix->data[5][0][0] = 0;
        outMatrix->data[5][1][3] = outMatrix->data[5][1][2] = outMatrix->data[5][1][1] = outMatrix->data[5][1][0] = 0;
        outMatrix->data[5][2][3] = outMatrix->data[5][2][2] = outMatrix->data[5][2][1] = outMatrix->data[5][2][0] = 0;
        outMatrix->data[5][3][3] = outMatrix->data[5][3][2] = outMatrix->data[5][3][1] = outMatrix->data[5][3][0] = 0;
        outMatrix->data[5][4][3] = outMatrix->data[5][4][2] = outMatrix->data[5][4][1] = outMatrix->data[5][4][0] = 0;
        outMatrix->data[5][5][3] = outMatrix->data[5][5][2] = outMatrix->data[5][5][1] = outMatrix->data[5][5][0] = -r5;
        return;
    default: 
    case 1:
    case 9:
        //THESE CONVERSION MATRICES NEED TO BE ADDED.
        nvAssert(0);
        break;
    }

    // Compute matrices for the calculation
    ComputePowerToFD(order, m, 0);
    ComputeP(order, r, p);
    ComputePowerToFD(order, mInv, 1);
    MatrixMult(info, temp[1], p, mInv);
    MatrixMult(info, temp[2], m, temp[1]);
    return;
}

/*****************************************************************************/
// Compute FD coefficients from curve control points
void RetessellateFDCurveInOut(NV_PATCH_INFO *info, float stepOld, float stepNew,
                    NV_PATCH_CURVE_INFO *curve, NV_PATCH_CURVE_INFO *curveOut, int reverseDirection)
{
    FDMatrix *m, *p, *mInv;
    FDMatrix *temp[3];
    EV_ALLOC_DECL();
    float ratio;
#ifdef DCR_HOS_RETESSCURVE_OPT
    unsigned int tag1, tag2;
#endif

    EV_ALLOC_INIT_WITH_CACHE(info->context, 5 * sizeof(FDMatrix), computeFDCurveCoeffsEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(m, info->context, sizeof(FDMatrix));
    EV_ALLOC(p, info->context, sizeof(FDMatrix));
    EV_ALLOC(mInv, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

#ifdef DCR_HOS_RETESSCURVE_OPT
    ratio = stepNew / stepOld;
    temp[2] = NULL;
    tag1 = (*(unsigned int*)(&ratio));
    tag2 = (0x0000FFFF & (unsigned int)(curve->order)) | reverseDirection << 20;    
    if (ratio != 1.0) {
        if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
            if (reverseDirection) {
                //the direciton of the curve is reversed so we need an uglier
                //retessellation matrix to 'reverse' the control point order here
                ComputeReversedRetessellation(info, curve->order, stepNew, stepOld, temp, m, p, mInv);
            } else {
                // Compute matrices for the calculation
                ComputePowerToFD(curve->order, m, 0);
                ComputeP(curve->order, ratio, p);
                ComputePowerToFD(curve->order, mInv, 1);
                MatrixMult(info, temp[1], p, mInv);
                MatrixMult(info, temp[2], m, temp[1]);
            }
        }

        // Compute FD curve coefficients
        FillColumnVectorMatrix(curve->order, 4*sizeof(float), &curve->coeffs[0][0], temp[0], 0);
        MatrixMult(info, temp[1], temp[2], temp[0]);
        EmptyColumnVectorMatrix(curve->order, temp[1], 4*sizeof(float), &curveOut->coeffs[0][0], 0);
        curveOut->order = curve->order;
    }
#else
    ratio = stepNew / stepOld;
    // Compute matrices for the calculation
    ComputePowerToFD(curve->order, mInv, 1);
    ComputeP(curve->order, ratio, p);
    ComputePowerToFD(curve->order, m, 0);

    // Compute FD curve coefficients
    FillColumnVectorMatrix(curve->order, 4*sizeof(float), &curve->coeffs[0][0], temp[0], 0);
    MatrixMult(info, temp[1], mInv, temp[0]);
    MatrixMult(info, temp[0], p, temp[1]);
    MatrixMult(info, temp[1], m, temp[0]);
    EmptyColumnVectorMatrix(curve->order, temp[1], 4*sizeof(float), &curveOut->coeffs[0][0], 0);
    curveOut->order = curve->order;
#endif

computeFDCurveCoeffsEnd:
    EV_FREE(m, info->context);
    EV_FREE(p, info->context);
    EV_FREE(mInv, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
}

// Compute FD coefficients from curve control points
unsigned int RetessellateFDCurveSetInOut(NV_PATCH_INFO *info, int evalEnables,
                    float stepOld, float stepNew,
                    FDCurveAttrSet *pIn, FDCurveAttrSet *pOut)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            RetessellateFDCurveInOut(info, stepOld, stepNew, (*pIn)[index], (*pOut)[index], 0);
        }
    }
    return 0;
}

void RetessellateFDCurve(NV_PATCH_INFO *info, float stepOld, float stepNew,
                                NV_PATCH_CURVE_INFO *curve, int reverseDirection)
{
    RetessellateFDCurveInOut(info, stepOld, stepNew, curve, curve, reverseDirection);
}

/*****************************************************************************/

void OffsetCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *curve, int n)
{
    ASSERT_CURVE(curve);
#ifdef DCR_HOS_OPT
    if (g_FDGlobalData.cpuType) {
        PFOFSC p;
        switch (curve->order) {
        case 4:
            p=(PFOFSC)(g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_4x4]);
            p(curve,n);
            return;
        case 6:
            p=(PFOFSC)(g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_6x6]);
            p(curve,n);
            return;
        case 2:
           /* p=(PFOFSC)(g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_2x2]);
            p(curve,n);
            break;*/
        default:
            ;   // fall thru to C code
        }
    }
#endif
    {
        int i, j;

        for (i = 0; i < n; i++) {
            for (j = 0; j < curve->order-1; j++) {
                AddPoint(curve->coeffs[j], curve->coeffs[j+1]);
            }
        }
    }
}

void OffsetCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *pSet, int n)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            OffsetCurve(info, (*pSet)[index], n);
        }
    }
}

// Offset curve coefficients by n steps
void OffsetCoeffs(float *coeffs, int order, int n)
{
    int i, j;

    for (i = 0; i < n; i++) {
        for (j = 0; j < order-1; j++) {
            coeffs[4*j+0] += coeffs[4*(j+1)+0];
            coeffs[4*j+1] += coeffs[4*(j+1)+1];
            coeffs[4*j+2] += coeffs[4*(j+1)+2];
            coeffs[4*j+3] += coeffs[4*(j+1)+3];
        }
    }
}

/*****************************************************************************/
// Evaluate along a curve
static void EvalCurve(const float *curve, int order, int n, float *outputs, int stride, int revIdx)
{
    int i, j;
    float temp[NV_PATCH_MAX_ORDER][4];

    if (revIdx) {
        outputs = (float *)((char *)outputs + (n-1)*stride);
        stride = -stride;
    }

    // Initialize FD
    for (j = 0; j < order; j++) {
        temp[j][0] = curve[4*j + 0];
        temp[j][1] = curve[4*j + 1];
        temp[j][2] = curve[4*j + 2];
        temp[j][3] = curve[4*j + 3];
    }

    for (i = 0; i < n; i++) {
        // Output a vertex
        outputs[0] = temp[0][0];
        outputs[1] = temp[0][1];
        outputs[2] = temp[0][2];
        outputs[3] = temp[0][3];
        NV_TRACE_COND(TR_EVAL, 35,
            static int cnt = 0;
            TPRINTF(("EvalCurve#%d %d-->%d) %9g %9g %9g %9g\n", cnt++, i, revIdx ? n-i : i,
                        outputs[0], outputs[1], outputs[2], outputs[3]));
        );
        outputs = (float *)((char *)outputs + stride);

        // Step FD
        for (j = 0; j < order-1; j++) {
            AddPoint(temp[j], temp[j+1]);
        }
    }
}

// Evaluate all the enabled curves along a strip in either direction
void EvalStrip(NV_PATCH_INFO *info,
                       FDCurveAttrSet *curves,
                       int n, NV_PATCH_EVAL_OUTPUT *pOutput, int revIdx)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            NV_TRACE_COND(TR_EVAL, 35,
                TPRINTF(("attr %d\n", index));
            );
            ASSERT_CURVE((*curves)[index]);
            EvalCurve((*curves)[index]->coeffs[0], (*curves)[index]->order,
                n, &pOutput->vertexAttribs[0][index][0],
                4*sizeof(float)*NV_PATCH_NUMBER_OF_ATTRIBS, revIdx);
        }
    }
}

/*****************************************************************************/
#define EVAL_IWRAP(serial) ((serial) % NV_PATCH_MAX_SW_VERTICES)

// Evaluate attr0 along a curve
static void EvalCurveIdx(int attr, int order, const float *curve, int n, NV_PATCH_EVAL_OUTPUT *pOutput, int startIdx, int revIdx)
{
    int i, j, sign = 1, idx;
    float temp[NV_PATCH_MAX_ORDER][4];

    if (revIdx) {
        startIdx = startIdx + n - 1;
        sign = -1;
    }

    // Initialize FD
    for (j = 0; j < order; j++) {
        temp[j][0] = curve[4*j + 0];
        temp[j][1] = curve[4*j + 1];
        temp[j][2] = curve[4*j + 2];
        temp[j][3] = curve[4*j + 3];
    }

    for (i = 0; i < n; i++) {
        // Output a vertex
        nvAssert((startIdx + i*sign) >= 0);
        idx = EVAL_IWRAP(startIdx + i*sign);
        CopyPoint(pOutput->vertexAttribs[idx][0], temp[0]);
        NV_TRACE_COND(TR_EVAL, 35,
            static int cnt = 0;
            TPRINTF(("EvalCurveIdx#%d/%d %d-->%d) %9g %9g %9g %9g\n", cnt++, attr, i, idx,
                        temp[0][0], temp[0][1], temp[0][2], temp[0][3]));
        );

        // Step FD
        for (j = 0; j < order-1; j++) {
            AddPoint(temp[j], temp[j+1]);
        }
    }
}

// Evaluate all the enabled curves along a strip in either direction
void EvalStripIdx(NV_PATCH_INFO *info,
                       FDCurveAttrSet *curves,
                       int n, NV_PATCH_EVAL_OUTPUT *pOutput, int startIdx,
                       int revIdx)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            // call pretending current attr is attr0
            EvalCurveIdx(index, (*curves)[index]->order, (*curves)[index]->coeffs[0],
                n, (NV_PATCH_EVAL_OUTPUT *)&pOutput->vertexAttribs[0][index], startIdx, revIdx);
        }
    }
}

/*****************************************************************************/
// Compute a FD matrix
void ComputeFDMatrixFlip(NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, int uorder, int vorder, float ustep, float vstep,
                     FDMatrix *m,
                     const float *points, int vCoord, int uCoord,
                     int ufStride, int vfStride)
{
    FDMatrix *uCoeffs;
    FDMatrix *basisU, *basisV;
    FDMatrix *mU, *mV, *pU, *pV;
    FDMatrix *temp[3];
    int i, j;
#ifdef DCR_COMPUTEFDMATRIXFLIP_OPT
    unsigned int tag1, tag2;
#endif
    EV_ALLOC_DECL();

    EV_ALLOC_INIT_WITH_CACHE(info->context, 9 * sizeof(FDMatrix), computeFDMatrixEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(uCoeffs, info->context, sizeof(FDMatrix));
    EV_ALLOC(basisU, info->context, sizeof(FDMatrix));
    EV_ALLOC(basisV, info->context, sizeof(FDMatrix));
    EV_ALLOC(mU, info->context, sizeof(FDMatrix));
    EV_ALLOC(mV, info->context, sizeof(FDMatrix));
    EV_ALLOC(pU, info->context, sizeof(FDMatrix));
    EV_ALLOC(pV, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

    if (map) {
        if (info->flags & NV_PATCH_FLAG_FLIPPED_U) {
            uCoord = (uorder - 1 - uCoord);
            ufStride = -ufStride;
        }
        if (info->flags & NV_PATCH_FLAG_FLIPPED_V) {
            vCoord = (vorder - 1 - vCoord);
            vfStride = -vfStride;
        }
        points += vCoord * map->vfStride + uCoord * map->ufStride;
    }

    // The matrix will be mxn, where n = uorder and m = vorder
    m->rows = vorder;
    m->columns = uorder;
    uCoeffs->rows = vorder;
    uCoeffs->columns = uorder;

#ifdef DCR_COMPUTEFDMATRIXFLIP_OPT
    // Compute u-direction FD curve coefficients
    for (j = 0; j < vorder; j++) { FillColumnVectorMatrix(uorder, ufStride * sizeof(float), points + j*vfStride, temp[0], j); }
    temp[2] = NULL;
    tag1 = (0xFFFF0000 | uorder);
    tag2 = *(unsigned int *)(&ustep);
    if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
        // Compute matrices in each direction
        ComputeBasis(uorder, 0, basisU);
        ComputeP(uorder, ustep, pU);
        ComputePowerToFD(uorder, mU, 0);

        MatrixMult(info, temp[1], pU, basisU);
        MatrixMult(info, temp[2], mU, temp[1]);
    }
    MatrixMult(info, temp[1], temp[2], temp[0]);
    for (j = 0; j < vorder; j++) { EmptyColumnVectorMatrix(uorder, temp[1], 4*sizeof(float), &uCoeffs->data[j][0][0], j);}

    // Compute v-direction FD curve coefficients
    for (i = 0; i < uorder; i++) { FillColumnVectorMatrix(vorder, 4*sizeof(float)*NV_PATCH_MAX_ORDER, &uCoeffs->data[0][i][0], temp[0], i); }
    temp[2] = NULL;
    tag1 = (0xFFFF0000 | vorder);
    tag2 = *(unsigned int *)(&vstep);
    if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
        // Compute matrices in each direction
        ComputeBasis(vorder, 0, basisV);
        ComputeP(vorder, vstep, pV);
        ComputePowerToFD(vorder, mV, 0);

        MatrixMult(info, temp[1], pV, basisV);
        MatrixMult(info, temp[2], mV, temp[1]);
    }
    MatrixMult(info, temp[1], temp[2], temp[0]);
    for (i = 0; i < uorder; i++) { EmptyColumnVectorMatrix(vorder, temp[1], 4*sizeof(float)*NV_PATCH_MAX_ORDER, &m->data[0][i][0], i); }
#else
    // Compute matrices in each direction
    ComputeBasis(uorder, 0, basisU);
    ComputeP(uorder, ustep, pU);
    ComputePowerToFD(uorder, mU, 0);

    // Compute u-direction FD curve coefficients
    for (j = 0; j < vorder; j++) {
        FillColumnVectorMatrix(uorder, ufStride * sizeof(float), points + j*vfStride, temp[0], 0);
        MatrixMult(info, temp[1], basisU, temp[0]);
        MatrixMult(info, temp[0], pU, temp[1]);
        MatrixMult(info, temp[1], mU, temp[0]);
        EmptyColumnVectorMatrix(uorder, temp[1], 4*sizeof(float), &uCoeffs->data[j][0][0], 0);
    }
    NV_TRACE_COND(TR_EVAL, 25,
        TraceMatrix(info, temp[1]);
    );

    // Compute matrices in each direction
    ComputeBasis(vorder, 0, basisV);
    ComputeP(vorder, vstep, pV);
    ComputePowerToFD(vorder, mV, 0);

    // Compute v-direction FD curve coefficients
    for (i = 0; i < uorder; i++) {
        FillColumnVectorMatrix(vorder, 4*sizeof(float)*NV_PATCH_MAX_ORDER, &uCoeffs->data[0][i][0], temp[0], 0);
        MatrixMult(info, temp[1], basisV, temp[0]);
        MatrixMult(info, temp[0], pV, temp[1]);
        MatrixMult(info, temp[1], mV, temp[0]);
        EmptyColumnVectorMatrix(vorder, temp[1], 4*sizeof(float)*NV_PATCH_MAX_ORDER, &m->data[0][i][0], 0);
    }
#endif

computeFDMatrixEnd:
    EV_FREE(uCoeffs, info->context);
    EV_FREE(basisU, info->context);
    EV_FREE(basisV, info->context);
    EV_FREE(mU, info->context);
    EV_FREE(mV, info->context);
    EV_FREE(pU, info->context);
    EV_FREE(pV, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);

    NV_TRACE_COND(TR_EVAL, 25,
        TraceMatrix(info, m);
    );
}

void ComputeFDMatrix(NV_PATCH_INFO *info, int uorder, int vorder, float ustep, float vstep,
                             FDMatrix *m, const float *points, int ustride, int vstride)
// wrapper for now, eventually change all calls to be direct
{
    ComputeFDMatrixFlip(info, 0, uorder, vorder, ustep, vstep, m,
                (const float *)points, 0, 0, ustride, vstride);
}

// Offset an FD matrix by 'a' steps in u and 'b' steps in v
// Not particularly fast -- try to step along a curve when possible!
void OffsetFDMatrix(NV_PATCH_INFO *info, FDMatrix *m, int a, int b)
{
#ifdef DCR_HOS_OPT
#if !defined(IS_OPENGL)
    int order = m->rows;
#else
    int order = (m->rows == m->columns) ? m->rows : 0;
#endif
    PFOFSTM p;
    if (g_FDGlobalData.cpuType) {
        switch (order) {
        case 4:
            p=(PFOFSTM)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_4x4]);
            p(m, a, b);
            return;
        case 6:
            p=(PFOFSTM)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_6x6]);
            p(m, a, b);
            return;
        case 2:
            //OFFSET_FDMATRIX_2x2
        default:
            //OFFSET_FDMATRIX_DEF
            ;   // fall thru to C code
        }
    }
#endif
    {
        int i, row, col;
        // Step in u
        for (i = 0; i < a; i++) {
            for (row = 0; row < m->rows; row++) {
                for (col = 0; col < m->columns-1; col++) {
                    AddPoint(m->data[row][col], m->data[row][col+1]);
                }
            }
        }

        // Step in v
        for (i = 0; i < b; i++) {
            for (row = 0; row < m->rows-1; row++) {
                for (col = 0; col < m->columns; col++) {
                    AddPoint(m->data[row][col], m->data[row+1][col]);
                }
            }
        }
    }
}

void OffsetFDMatrix_Extract_Discard(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b)
{
#ifdef DCR_HOS_OPT
#if !defined(IS_OPENGL)
    int order = m->rows;
#else
    int order = (m->rows == m->columns) ? m->rows : 0;
#endif
    PFOFSTMED p;
    if (g_FDGlobalData.cpuType) {
        switch (order) {
        case 4:
            p=(PFOFSTMED)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_4x4]);
            p(dst, dir, m, a, b);
            return;
        case 2:
            /*p=(PFOFSTMED)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_2x2]);
            p(dst, dir, m, a, b);
            return;
        case 6:
            /*p=(PFOFSTMED)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_6x6]);
            p(dst, dir, m, a, b);
            break;*/
        default:
            ;   // fall thru to C code
        }
    }
#endif
    {
        BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
        CopyMatrix(info, &info->tempMatrix, m);
        OffsetFDMatrix(info, &info->tempMatrix, a, b);
        if (dir) ExtractVCurve(info, dst, &info->tempMatrix);
        else ExtractUCurve(info, dst, &info->tempMatrix);
        END_USING_TEMP_MATRIX(info->tempMatrix);
    }
}

void OffsetFDMatrixSet(NV_PATCH_INFO *info, int evalEnables, FDMatrixAttrSet *pSet, int a, int b)
{
    int attr;

    for (attr = 0;  attr < info->maxAttr;  attr++) {
        if (!(evalEnables & (1 << attr))) {
            continue;
        }
        OffsetFDMatrix(info, (*pSet)[attr], a, b);
    }
}

// Compute FD coefficients from curve control points
void RetessellateFDMatrix(NV_PATCH_INFO *info, float stepOldU, float stepOldV,
                                 float stepNewU, float stepNewV, FDMatrix *matrix)
{
    const int uorder = matrix->columns;
    const int vorder = matrix->rows;
#ifndef DCR_HOS_RETESS_OPT
    int i,j;
#else
    unsigned int tag1, tag2;
    int reverseDirection;
    float ratio;
#endif
    FDMatrix *m, *p, *mInv;
    FDMatrix *temp[3];
    int freeTemp2 = 1;

    EV_ALLOC_DECL();

    EV_ALLOC_INIT_WITH_CACHE(info->context, 5 * sizeof(FDMatrix), RetessellateFDMatrixEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(m, info->context, sizeof(FDMatrix));
    EV_ALLOC(p, info->context, sizeof(FDMatrix));
    EV_ALLOC(mInv, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

#ifdef DCR_HOS_RETESS_OPT
    // Compute matrices for the calculation
    ratio = stepNewU / stepOldU;
    if (ratio != 1.0) {
        temp[2] = NULL;
        reverseDirection = (info->quadInfo->uMaxDir != info->quadInfo->olduMaxDir ? 1 : 0);
        tag1 = (*(unsigned int*)(&ratio));
        tag2 = (0x0000FFFF & uorder) | reverseDirection << 20;
        if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {            
            //cache miss calculate the step matrix
            if (reverseDirection) {
                ComputeReversedRetessellation(info, uorder, stepNewU, stepOldU, temp, m, p, mInv);
            } else {
                ComputePowerToFD(uorder, m, 0);
                ComputeP(uorder, ratio, p);
                ComputePowerToFD(uorder, mInv, 1);
                MatrixMult(info, temp[0], p, mInv);
                MatrixMult(info, temp[2], m, temp[0]);
            }
        }
        CopyMatrixTranspose(info, temp[0], matrix);
        MatrixMult(info, temp[1], temp[2], temp[0]);
        CopyMatrixTranspose(info, matrix, temp[1]);
    }

    ratio = stepNewV / stepOldV;
    if (ratio != 1.0) {        
        temp[2] = NULL;
        reverseDirection = (info->quadInfo->vMaxDir != info->quadInfo->oldvMaxDir ? 1 : 0);
        tag1 = (*(unsigned int*)(&ratio));
        tag2 = (0x0000FFFF & vorder) | reverseDirection << 20;
        if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
            //cache miss calculate the step matrix
            if (reverseDirection) {
                ComputeReversedRetessellation(info, uorder, stepNewV, stepOldV, temp, m, p, mInv);
            } else {
                ComputePowerToFD(vorder, m, 0);
                ComputeP(vorder, ratio, p);
                ComputePowerToFD(vorder, mInv, 1);
                MatrixMult(info, temp[0], p, mInv);
                MatrixMult(info, temp[2], m, temp[0]);
            }
        }

        //don't need a copy cause its not a transpose...
        MatrixMult(info, temp[1], temp[2], matrix);
        CopyMatrix(info, matrix, temp[1]);
    }

#else
    // Compute matrices for the calculation
    ComputePowerToFD(uorder, mInv, 1);
    ComputeP(uorder, stepNewU / stepOldU, p);
    ComputePowerToFD(uorder, m, 0);

    // Recompute in u direction
    for (j = 0; j < vorder; j++) {
        FillColumnVectorMatrix(uorder, 4*sizeof(float), &matrix->data[j][0][0], temp[0], 0);
        MatrixMult(info, temp[1], mInv, temp[0]);
        MatrixMult(info, temp[0], p, temp[1]);
        MatrixMult(info, temp[1], m, temp[0]);
        EmptyColumnVectorMatrix(uorder, temp[1], 4*sizeof(float), &matrix->data[j][0][0], 0);
    }

    // Compute matrices for the calculation
    ComputePowerToFD(vorder, mInv, 1);
    ComputeP(vorder, stepNewV / stepOldV, p);
    ComputePowerToFD(vorder, m, 0);

    // Recompute in v direction
    for (i = 0; i < uorder; i++) {
        FillColumnVectorMatrix(vorder, 4*sizeof(float)*NV_PATCH_MAX_ORDER, &matrix->data[0][i][0], temp[0], 0);
        MatrixMult(info, temp[1], mInv, temp[0]);
        MatrixMult(info, temp[0], p, temp[1]);
        MatrixMult(info, temp[1], m, temp[0]);
        EmptyColumnVectorMatrix(vorder, temp[1], 4*sizeof(float)*NV_PATCH_MAX_ORDER, &matrix->data[0][i][0], 0);
    }
#endif

RetessellateFDMatrixEnd:
    EV_FREE(m, info->context);
    EV_FREE(p, info->context);
    EV_FREE(mInv, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
}
#undef RATIO
#undef ORDER

unsigned int RetessellateFDMatrixSet(NV_PATCH_INFO *info, int evalEnables,
                    float stepOldU, float stepOldV,
                    float stepNewU, float stepNewV, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  attr < info->maxAttr;  attr++) {
        if (!(evalEnables & (1 << attr))) {
            continue;
        }
        RetessellateFDMatrix(info, stepOldU, stepOldV, stepNewU, stepNewV, (*pSet)[attr]);
    }
    return 0;
}

/*****************************************************************************/
// Compute a Bezier curve's midpoint given its control points
// This uses the de Casteljau algorithm.

void ComputeCurvePoint(int order, float *point, const float *points,
                       int stride, float t)
{
    float temp[NV_PATCH_MAX_ORDER][4];
    int i, j;

    // Copy points
    for (i = 0; i < order; i++) {
        temp[i][0] = points[0]; temp[i][1] = points[1];
        temp[i][2] = points[2]; temp[i][3] = points[3];
        points = (const float *)((const char *)points + stride);
    }

    // Compute midpoint
    for (i = order-1; i >= 1; i--) {
        for (j = 0; j < i; j++) {
            temp[j][0] = (1-t) * temp[j][0] + (t)*temp[j+1][0];
            temp[j][1] = (1-t) * temp[j][1] + (t)*temp[j+1][1];
            temp[j][2] = (1-t) * temp[j][2] + (t)*temp[j+1][2];
            temp[j][3] = (1-t) * temp[j][3] + (t)*temp[j+1][3];
        }
    }

    //note that this is 'point' variable and not 'points'
    point[0] = temp[0][0];
    point[1] = temp[0][1];
    point[2] = temp[0][2];
    point[3] = temp[0][3];
}

void ComputePatchPoint(int uorder, int vorder,
                  float *point, const float *points,
                  int ustride, int vstride,
                  float u, float v) {

    int j;
    float curvePoints[NV_PATCH_MAX_ORDER][4];

    //calculate offset curve in v direction.
    for (j = 0; j < uorder; j++) {
        ComputeCurvePoint(vorder, &curvePoints[j][0], points + 4*j, vstride, v);
    }
    ComputeCurvePoint(uorder, point, &curvePoints[0][0], 4*sizeof(float), u);
}

void ComputeTriPatchCenter(int order, float *point, const float *points,
                           int ustride, int vstride)
{
    float temp[NV_PATCH_MAX_ORDER][NV_PATCH_MAX_ORDER][4];
    const float *ptemp;
    int i, j, k;

    // Copy points
    for (j = 0; j < order; j++) {
        ptemp = (const float *)((const char *)points + j*vstride);
        for (i = 0; i < order; i++) {
            temp[j][i][0] = ptemp[0];
            temp[j][i][1] = ptemp[1];
            temp[j][i][2] = ptemp[2];
            temp[j][i][3] = ptemp[3];
            ptemp = (const float *)((const char *)ptemp + ustride);
        }
    }

    // Compute midpoint
    for (i = order-1; i >= 1; i--) {
        for (j = 0; j < i; j++) {
            for (k = 0; k < i-j; k++) {
                temp[k][j][0] = (temp[k][j][0] + temp[k][j+1][0] + temp[k+1][j][0]) / 3.0f;
                temp[k][j][1] = (temp[k][j][1] + temp[k][j+1][1] + temp[k+1][j][1]) / 3.0f;
                temp[k][j][2] = (temp[k][j][2] + temp[k][j+1][2] + temp[k+1][j][2]) / 3.0f;
                temp[k][j][3] = (temp[k][j][3] + temp[k][j+1][3] + temp[k+1][j][3]) / 3.0f;
            }
        }
    }

    //note that this is 'point' variable and not 'points'
    point[0] = temp[0][0][0];
    point[1] = temp[0][0][1];
    point[2] = temp[0][0][2];
    point[3] = temp[0][0][3];
}

const static float triTo3QuadDomains[3][4][2] = {
    {
        {0, 0},
        {0.5f, 0},
        {0, 0.5f},
        {1/3.0f, 1/3.0f},
    },
    {
        {1, 0},
        {0.5f, 0},
        {0.5f, 0.5f},
        {1/3.0f, 1/3.0f},
    },
    {
        {0, 1},
        {0.5f, 0.5f},
        {0, 0.5f},
        {1/3.0f, 1/3.0f},
    },
};

const static float triTo1QuadDomain[4][2] = {
    {0, 0},
    {1.0f, 0},
    {0, 1.0f},
    {0, 1.0f},
};

static FDMatrix *ReduceTriPatch(NV_PATCH_INFO *info, int level, FDMatrix *p, float w0, float w1)
{
    FDMatrix *rp;
    int deg = p->rows-2;
    int i, j, k;
    float w2 = 1.0f - w0 - w1;

    rp = info->reduceTri[level];
    if (!rp) {
        return NULL;
    }
    rp->rows    = deg+1;
    rp->columns = deg+1;

    for (i = 0; i <= deg; i++) {
        for (j = 0; j <= deg-i; j++) {
            for (k = 0; k < 4; k++) {
                rp->data[i][j][k]  = w0*p->data[i+1][j][k];
                rp->data[i][j][k] += w1*p->data[i][j+1][k];
                rp->data[i][j][k] += w2*p->data[i][j][k];
            }
        }
    }
    return rp;
}

// NOTE: this is a recursive routine
static unsigned int ComputeTriToQuad(NV_PATCH_INFO *info, int level, FDMatrix *f, FDMatrix *g, FDMatrix *h,
                                    float **weights, int n, int mini,
                                    int si, int sj, float c, int mu)
{
    FDMatrix *fn;
    int indexi, indexj, firsti, i;
    unsigned int retVal;
    float bc[4];

    if (n == 0) {
        for (i = 0; i < 4; i++) {
            h->data[sj][si][i] += c * f->data[0][0][i];
        }
        weights[sj][si] += c;
        return 0;
    }

    firsti = 1;
    for (indexi = mini; indexi <= 1; indexi++) {
        if (firsti) {
            mu++;
            firsti = 0;
        } else {
            mu = 1;
        }
        for (indexj = 0; indexj <= 1; indexj++) {
            bc[0] = g->data[1 - indexi][indexj][0];
            bc[1] = g->data[1 - indexi][indexj][1];
            fn = ReduceTriPatch(info, level, f, bc[1], bc[0]);
            if (!fn) {
                return NV_PATCH_EVAL_ERR_OUT_OF_MEMORY;
            }
            retVal = ComputeTriToQuad(info, level+1, fn, g, h,
                                    weights, n-1, indexi,
                                    si + 1 - indexi,
                                    sj + indexj,
                                    c*n/mu,
                                    mu);
            if (retVal) {
                return retVal;
            }
        }
    }
    return 0;
}

static unsigned int ReparameterizeTriPatch(NV_PATCH_INFO *info, FDMatrix *in,
                                           FDMatrix *out, int domain, int frac)
{
    FDMatrix *domainMatrix = &info->tempMatrix;
    float *weights[NV_PATCH_MAX_ORDER], invWeight;
    int i, j;
    EV_ALLOC_DECL();

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
    EV_ALLOC_INIT_WITH_CACHE(info->context, NV_PATCH_MAX_ORDER*NV_PATCH_MAX_ORDER*sizeof(float)
                                            + (in->rows-1) * sizeof(FDMatrix),
                        reparameterizeTriPatchOutOfMemory, info->pCache[EV_CACHE_TRI_WEIGHTS]);

    for (i = 0; i < NV_PATCH_MAX_ORDER; i++) {
        EV_ALLOC(weights[i], info->context, NV_PATCH_MAX_ORDER*sizeof(float));
        for (j = 0; j < NV_PATCH_MAX_ORDER; j++) {
            out->data[i][j][0] = 0.0f;
            out->data[i][j][1] = 0.0f;
            out->data[i][j][2] = 0.0f;
            out->data[i][j][3] = 0.0f;
            weights[i][j] = 0.0f;
        }
    }
    for (i = 0;  i < in->rows-1;  i++) {
        EV_ALLOC(info->reduceTri[i], info->context, sizeof(FDMatrix));
    }
    EV_ALLOC_FULL(info->context);

    for (i = 0; i < 2; i++) {
        for (j = 0; j < 2; j++) {
            if (frac) {
                domainMatrix->data[i][j][0] = triTo3QuadDomains[domain][j*2+i][0];
                domainMatrix->data[i][j][1] = triTo3QuadDomains[domain][j*2+i][1];
            } else {
                domainMatrix->data[i][j][0] = triTo1QuadDomain[j*2+i][0];
                domainMatrix->data[i][j][1] = triTo1QuadDomain[j*2+i][1];
            }
        }
    }

    info->retVal |= ComputeTriToQuad(info, 0, in, domainMatrix, out,
                                    weights, in->rows-1, 0,
                                    0, 0, 1.0f, 0);

    out->rows = in->rows;
    out->columns = in->columns;
    for (i = 0; i < out->rows; i++) {
        for (j = 0; j < out->columns; j++) {
            invWeight = 1.0f / weights[i][j];
            out->data[i][j][0] *= invWeight;
            out->data[i][j][1] *= invWeight;
            out->data[i][j][2] *= invWeight;
            out->data[i][j][3] *= invWeight;
        }
    }

reparameterizeTriPatchOutOfMemory:
    for (i = 0; i < NV_PATCH_MAX_ORDER; i++) {
        if (weights[i]) {
            EV_FREE(weights[i], info->context);
        }
    }
    END_USING_TEMP_MATRIX(info->tempMatrix);

    return info->retVal;
}

NV_INLINE void SendTransitionEndPoints(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
                    FDCurveAttrSet **ppCurvesInnerList, int revTran, int nCurveIn,
                    int gridIdxV, int gridIdxU, int cornerIdxV, int cornerIdxU, int doFrac, int transitionFlag)
{
    int index;
    int dwCount;
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    // SEND THE OUTER ENDPOINT
    HOS_NOTE("Send Outer Transition endpoint"); // always send this...
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_OUTER_END_PT);
    HOS_PUSH_ADJUST(2);
    for (index = 0; index < info->maxAttr; index++) {
        dwCount = 0;
        if (info->evalEnables & (1 << index)) {
            HOS_NOTE("Set Curve Coefficients");
            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][0]));
            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][1]));
            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][2]));
            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][3]));
            dwCount+=5;
        }
        HOS_PUSH_ADJUST(dwCount);
    }
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    HOS_PUSH_ADJUST(2);

    if (!doFrac) {
        // SEND THE INNER ENDPOINT -- integer case
        // this should only happen in degenerate transitions cases
        //ffif (quadInfo->nv0 == 1 && quadInfo->nv1 == 1)
        {
            float *pPoint;

            //HACK HACK HACK  -- just testing out a theory on the degenerate case Fred gave me...
            //Fix this up.
            HOS_NOTE("Send Inner Transition endpoint");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
            HOS_PUSH_ADJUST(2);
            //ffif (transitionFlag == LAST_ROW || transitionFlag == FIRST_ROW)
            {
                for (index = 0; index < info->maxAttr; index++) {
                    dwCount = 0;
                    if (info->evalEnables & (1 << index)) {
                        //in degenerate case use patch corners not grid corners
                        // XXX gridCorner is not set up for some degen cases. WHY?
                        //ffpPoint = info->gridCorner[index][gridIdxV][gridIdxU];

                        if (transitionFlag == FIRST_ROW) {
                            //ffpPoint = quadInfo->pCorners[index][cornerIdxV][cornerIdxU];
                            pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][quadInfo->uMaxDir];

                        } else if (transitionFlag == LAST_ROW) {
                            pPoint = quadInfo->pCorners[index][1-quadInfo->vMaxDir][quadInfo->uMaxDir];

                        } else if (transitionFlag == FIRST_COL) {
                            pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][quadInfo->uMaxDir];

                        } else if (transitionFlag == LAST_COL) {
                            pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][1-quadInfo->uMaxDir];

                        } else {
                            pPoint = info->gridCorner[index][gridIdxV][gridIdxU];
                        }
                        HOS_NOTE("Set Curve Coefficients");
                        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                        HOS_PUSH4F(dwCount+1, pPoint);
                        dwCount+=5;
                    }
                    HOS_PUSH_ADJUST(dwCount);
                }
                HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
                HOS_PUSH_ADJUST(2);
            }
        }

    } else {
        // SEND THE INNER ENDPOINT -- fractional case
        if (transitionFlag == FIRST_ROW) {
            float *pPoint;
            HOS_NOTE("Send Inner Transition endpoint");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
            HOS_PUSH_ADJUST(2);
            for (index = 0; index < info->maxAttr; index++) {
                dwCount = 0;
                if (info->evalEnables & (1 << index)) {
                    if (quadInfo->uMaxSegs > 1) {
                        //ffpPoint = info->gridCorner[index][0][1];
                        pPoint = info->gridCorner[index][gridIdxV][gridIdxU];
                    } else {
                        //in degenerate case use patch corners not grid corners
                        //ffpPoint = quadInfo->pCorners[index][1][1];
                        //ffpPoint = quadInfo->pCorners[index][cornerIdxV][cornerIdxU];
                        pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][cornerIdxU];
                    }
                    HOS_NOTE("Set Curve Coefficients");
                    HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                    HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pPoint[0]));
                    HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pPoint[1]));
                    HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pPoint[2]));
                    HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pPoint[3]));
                    dwCount+=5;
                }
                HOS_PUSH_ADJUST(dwCount);
            }
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
            HOS_PUSH_ADJUST(2);
        } else if (transitionFlag == FIRST_COL) {
            float *pPoint;
            HOS_NOTE("Send Inner Transition endpoint");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
            HOS_PUSH_ADJUST(2);
            for (index = 0; index < info->maxAttr; index++) {
                dwCount = 0;
                if (info->evalEnables & (1 << index)) {
                    if (doFrac && (quadInfo->vMaxSegs == 1)) {
                        CopyCurve(info, &info->tempCurve, (*ppCurvesInnerList[!revTran ? 0 : nCurveIn-1])[index]);
                        OffsetCurve(info, &info->tempCurve,1);
                        pPoint = (float*)&info->tempCurve.coeffs[0];
                    } else if (quadInfo->vMaxSegs > 1) {
                        //ffpPoint = info->gridCorner[index][1][0];
                        pPoint = info->gridCorner[index][gridIdxV][gridIdxU];
                    } else {
                        //in degenerate case use patch corners not grid corners
                        //ffpPoint = quadInfo->pCorners[index][1][1];
                        pPoint = quadInfo->pCorners[index][cornerIdxV][cornerIdxU];
                    }
                    HOS_NOTE("Set Curve Coefficients");
                    HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                    HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pPoint[0]));
                    HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pPoint[1]));
                    HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pPoint[2]));
                    HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pPoint[3]));
                    dwCount+=5;
                }
                HOS_PUSH_ADJUST(dwCount);
            }
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
            HOS_PUSH_ADJUST(2);
        }
    }
}

/*****************************************************************************/
// where do the transition curves start?
// for INT cases, they all start on the swatch boundary
// for FRAC cases, curves are rooted as follows:
//  TOP:
//      LAST ROW outer, at actual UL corner that starts the stitch
//      LAST ROW inner, at left of swatch, like INT stitch top
//  RIGHT:
//      LAST COL outer, at actual LR corner that starts the stitch
//      LAST COL inner, at bot of swatch, like INT stitch right
//  BOT:
//      FIRST ROW outer, at LL of swatch, like INT stitch bot
//      FIRST ROW inner, at left of swatch, like INT stitch bot
//  LEFT:
//      FIRST COL outer, at LL of swatch, like INT stitch left
//      FIRST COL inner, at bot of swatch, like INT stitch left
//
// so, the normal "exceptions" are the TOP/RIGHT outer curves
// but, for degenerates:
// but, when there is no FRAC TOP stitch,   then the BOT FIRST ROW inner starts at actual UL of stitch (like TOP LAST ROW outer)
// and, when there is no FRAC RIGHT stitch, either nInnerU > nInnerV and there's no FRAC TOP, or transpose to get same case

NV_INLINE void SendFirstInnerTransitionCurve(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
                    FDCurveAttrSet **ppCurvesInnerList, int revTran, int nCurveIn, int doFrac, int transitionFlag)
{
    int index, i;
    int dwCount;
    NV_PATCH_CURVE_INFO *pCurve;
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    // SEND THE FIRST INNER TRANSITION CURVE
    HOS_NOTE("Begin Curve: Send Inner Transition");
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE);
    HOS_PUSH_ADJUST(2);
    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            dwCount = 0;
            pCurve = (*ppCurvesInnerList[!revTran ? 0 : nCurveIn-1])[index];
            if (doFrac && (quadInfo->vMaxSegs == 1) && (transitionFlag == FIRST_ROW)) {
                CopyCurve(info, &info->tempCurve, pCurve);
                OffsetCurve(info, &info->tempCurve,1);
                pCurve = &info->tempCurve;
            }

            // if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
            for (i = 0; i < pCurve->order; i++) {
                HOS_NOTE("Set Curve Coefficients");
                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pCurve->coeffs[i][0]));
                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pCurve->coeffs[i][1]));
                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pCurve->coeffs[i][2]));
                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pCurve->coeffs[i][3]));
                dwCount+=5;
            }
            HOS_PUSH_ADJUST(dwCount);
        }
    }
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    HOS_PUSH_ADJUST(2);
    HOS_FLUSH();
}

NV_INLINE void SendFirstOuterTransitionCurve(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDCurveAttrSet *pCurvesOuter,
                    int doFrac, int transitionFlag)
{
    int index, i;
    int dwCount;
    NV_PATCH_CURVE_INFO *pCurve;
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    // SEND THE FIRST OUTER TRANSITION CURVE
    HOS_NOTE("Send Outer Transition");
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE);
    HOS_PUSH_ADJUST(2);
    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            dwCount = 0;
            pCurve = (*pCurvesOuter)[index];
            //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
            if (doFrac && (transitionFlag == LAST_ROW || transitionFlag == LAST_COL)) {
                CopyCurve(info, &info->tempCurve, pCurve);
                OffsetCurve(info, &info->tempCurve,1);
                pCurve = &info->tempCurve;
            }

            for (i = 0; i < pCurve->order; i++) {
                HOS_NOTE("Set Curve Coefficients");
                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pCurve->coeffs[i][0]));
                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pCurve->coeffs[i][1]));
                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pCurve->coeffs[i][2]));
                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pCurve->coeffs[i][3]));
                dwCount+=5;
            }
            HOS_PUSH_ADJUST(dwCount);
        }
    }
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    HOS_PUSH_ADJUST(2);
    HOS_FLUSH();
}

/*****************************************************************************/
// Draw stitch for INT or FRAC cases
// gridIdx* are indices for inside endpoint:
//      info->gridCorner[index][gridIdxV][gridIdxU]
// cornerIdx* are indices for outside endpoint:
//      quadInfo->pCorners[index][cornerIdxV][cornerIdxU]

void DrawIntStitch(int stripU, NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
                    FDCurveAttrSet **ppCurvesOuter, FDCurveAttrSet **ppCurvesInnerList,
                    int outSegs, int inSegs,
                    NV_PATCH_EVAL_OUTPUT *pDataOut, NV_PATCH_EVAL_OUTPUT *pDataIn,
                    int gridIdxVBegin, int gridIdxUBegin,   // for inner beginpoint from regular grid corner
                    int gridIdxV, int gridIdxU,             // for inner endpoint from regular grid corner
                    int cornerIdxV, int cornerIdxU,         // for outer endpoint from patch corners[][]
                    int stitchLowOut, int stitchHighOut,
                    int stitchLowIn, int stitchHighIn,
                    int qDir, int qOtherDir, int qMaxDir,
                    int reverse, int ifEqualStepInner, int transitionFlag)
{
    // World's messiest state machine.  I wish this was cleaner. -- MJC
    // ... and now perhaps messier, but does swathing. -- FBF
    // and may even match the HW
    int dist, in, out, i, first;
    int inStrip, lastWasIn;
    int fanCenter, fanFirst, fanLast;
    int idxInnerEnd;
    int index;
    FDCurveAttrSet *pCurves;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    //ff// calc swaths WITHOUT including the ending FRAC-only stitches
    //ffint nSwatchU = (quadInfo->uMaxSegs - 1 - doFrac) / info->maxSwatch + 1;
    //ffint nSwatchV = (quadInfo->vMaxSegs - 1 - doFrac) / info->maxSwatch + 1;
    int nCurveOut;
    int nCurveIn; // = stripU ? nSwatchU : nSwatchV;
    int revTran = qDir != qMaxDir;          // qDir is from outerDir
    int revInner = qOtherDir != qMaxDir;    // qOtherDir
    int totalToDoOut, totalToDoIn;
    int onCurveOut = 1, onCurveIn = 1;
    int oneToDoOut, oneToDoIn;
    int onLowIn, onHighIn;
    int innerCurve;         // temp to hold curve number to select from ppCurvesInnerList
    int lastInsideCurve;    // means last in list. Not necessarily last drawn.
    int lastOutsideCurve;   // last drawn
    int usingHW = info->usingHW; // identifies places that probably need code for HW version
    int dwCount;
    int lastFrontFace;

    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    nCurveOut = (outSegs - 1) / info->maxSwatch + 1;
    nCurveIn =  (inSegs - 1 - doFrac) / info->maxSwatch + 1;
    NV_TRACE_COND(TR_EVAL, 30,
        TPRINTF(("DrawIntStitch out=%d in=%d stitchLowOut=%d stitchHighOut=%d\n",
                outSegs, inSegs, stitchLowOut, stitchHighOut));
        TPRINTF(("\t stitchLowIn=%d stitchHighIn=%d\n", stitchLowIn, stitchHighIn));
        TPRINTF(("\trev=%d ifEqualStepInner=%d\n", reverse, ifEqualStepInner));
    );
    nvAssert(qOtherDir == qMaxDir);
    nvAssert((outSegs <= inSegs)  ||  doFrac);

    if (!usingHW) {
        reverse ^= info->flipUV;
    }
    ifEqualStepInner ^= info->flipUV;

    out = 0;
    in = 0;
    if (stitchLowOut && (!usingHW /*|| doFrac*/)) {
        // these cases start the 'dist' algorithm at the first inner point
        in = 1;
        dist = inSegs - 3*outSegs;  // start with inside step
    } else {
        dist = inSegs - outSegs;
    }
    totalToDoOut = 1+outSegs; totalToDoIn = 1+inSegs;

    if (totalToDoOut > 1+info->maxSwatch) {
        oneToDoOut = info->maxSwatch;   // doesn't fit in one curve
        lastOutsideCurve = 0;
    } else {
        oneToDoOut = totalToDoOut;
        lastOutsideCurve = 1;
    }

    if (!usingHW) EvalStrip(info, ppCurvesOuter[0], oneToDoOut, pDataOut, 0); // outer

    if (totalToDoIn > 1+info->maxSwatch) {
        // doesn't fit in one curve
        if (revTran) {
            // reversed inner curve
            if (!usingHW) {
                oneToDoIn = inSegs % info->maxSwatch;
                assert(oneToDoIn >= 0);
                if (oneToDoIn <= 0) {
                    oneToDoIn += info->maxSwatch;
                }
            } else {
                oneToDoIn = inSegs % info->maxSwatch;
                assert(oneToDoIn >= 0);
                if ((oneToDoIn - stitchHighIn) <= 0) {
                    if ((oneToDoIn == 1)  &&  stitchHighIn /* && (nCurveIn == 2)*/) {
                        nCurveIn--;
                    }
                    oneToDoIn += info->maxSwatch; // + stitchHighIn;
                }
            }
            oneToDoIn++;
            lastInsideCurve = 1;
            onLowIn = 0;
            onHighIn = stitchHighIn;
        } else {
            if (doFrac && (nCurveIn == 1) && (totalToDoIn == (2+info->maxSwatch))) {
                oneToDoIn = 2+info->maxSwatch;
                lastInsideCurve = 1;
            } else {
                oneToDoIn = info->maxSwatch;
                lastInsideCurve = 0;
            }
            onLowIn = stitchLowIn;
            onHighIn = 0;
        }

    } else {
        // fits in one curve
        oneToDoIn = totalToDoIn;
        lastInsideCurve = 1;
        onLowIn = stitchLowIn;
        onHighIn = stitchHighIn;
    }

    if (!usingHW) {
        EvalStripIdx(info, ppCurvesInnerList[!revTran ? 0 : nCurveIn-1], oneToDoIn, pDataIn, 0, revTran); // inner
        if (onHighIn ) {
            //ffif (stitchHighIn) {
                oneToDoIn--;
                totalToDoIn--;
            //ff}
        }
    }

    if (revTran) {
        idxInnerEnd = in;
    } else {
        nvAssert(qDir == qOtherDir);
        idxInnerEnd = oneToDoIn-1;
    }
    if (!usingHW) {
        if (onLowIn) {
            oneToDoIn--;
            totalToDoIn--;
        }
    }

    if (usingHW) {
        //setup transition
        unsigned long TControl[3], order;
        unsigned long numcoeffs = 0x0;
        int hwAttr;
        TControl[0] = TControl[1] = TControl[2] = 0x0;
        for (hwAttr = 0; hwAttr <= 7; hwAttr++) {               //TPControl0
            if (info->evalEnables & (1 << hwAttr)) {
                order = (*ppCurvesOuter[0])[hwAttr]->order;
                assert((int)order == (*ppCurvesInnerList[0])[hwAttr]->order);
                TControl[0] |= ((order-1) << (hwAttr<<2));      //hwAttr*4
                numcoeffs += order;
            }
        }
        for (hwAttr = 8; hwAttr <= 15; hwAttr++) {              //TPControl1
            if (info->evalEnables & (1 << hwAttr)) {
                order = (*ppCurvesOuter[0])[hwAttr]->order;
                assert((int)order == (*ppCurvesInnerList[0])[hwAttr]->order);
                TControl[1] |= ((order-1) << ((hwAttr-8)<<2));
                numcoeffs += order;
            }
        }

        TControl[2] = (numcoeffs << 24) | (outSegs << 10) | inSegs;
        HOS_NOTE("Set Begin Transition");
        HOS_PUSH(0, ((0x3 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_TRANSITION0)));
        HOS_PUSH(1, TControl[0]);
        HOS_PUSH(2, TControl[1]);
        HOS_PUSH(3, TControl[2]);
        HOS_PUSH_ADJUST(4);

        //SEND Transition endpoints as necessary
        SendTransitionEndPoints(info, quadInfo, ppCurvesInnerList, revTran, nCurveIn,
                                gridIdxV, gridIdxU, cornerIdxV, cornerIdxU, doFrac, transitionFlag);

        //SEND Beginning Transition Curves
        SendFirstInnerTransitionCurve(info, quadInfo, ppCurvesInnerList, revTran, nCurveIn, doFrac, transitionFlag);
        SendFirstOuterTransitionCurve(info, quadInfo, ppCurvesOuter[0], doFrac, transitionFlag);

    } else {
        // Force first and last point
        for (index = 0; index < info->maxAttr; index++) {
            if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                continue;
            }
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            if (lastOutsideCurve) {
                CopyPoint(pDataOut->vertexAttribs[oneToDoOut-1][index], quadInfo->pCorners[index][cornerIdxV][cornerIdxU]);
            }
            if (!doFrac) {
                // for starting grid corner
                if (revTran) {
                    if (lastInsideCurve && (nCurveIn == 1)) {
                        CopyPoint(pDataIn->vertexAttribs[oneToDoIn-onLowIn][index], info->gridCorner[index][gridIdxVBegin][gridIdxUBegin]);
                    }
                } else {
                    CopyPoint(pDataIn->vertexAttribs[in][index], info->gridCorner[index][gridIdxVBegin][gridIdxUBegin]);
                }
            }
            if (lastInsideCurve) {
                CopyPoint(pDataIn->vertexAttribs[idxInnerEnd][index], info->gridCorner[index][gridIdxV][gridIdxU]);
            }
        }

        if (doFrac  &&  stitchHighOut) {
            out++;
            oneToDoOut--;
            totalToDoOut--;

            in++;
            oneToDoIn--;
            totalToDoIn--;
        }

        info->backend->setFrontFace(info, lastFrontFace = reverse ^ info->reverse);
        info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
        info->backend->sendVertex(info, pDataOut, out);
    }

    if (inSegs != outSegs) {
        // if we have a reversal, bias the stitching direction so it comes
        // out the same as the non reversed case.
        int lastTrans = (transitionFlag == LAST_ROW  || transitionFlag == LAST_COL) ? 1 : 0;
        int rowTrans =  (transitionFlag == FIRST_ROW || transitionFlag == LAST_ROW) ? 1 : 0;
        int fudge;
        if (rowTrans) {
            fudge = !(revTran ^ (lastTrans)); // row
        } else {
            fudge = !(revTran ^ (!lastTrans)); // col
        }
        if (!usingHW) {
            dist += fudge ^ quadInfo->uMaxDir ^ quadInfo->vMaxDir ^ info->flipUV;
        } else {
            dist += fudge;
        }
    } else {
        // when segs equal, initial dist == 0. if dist==0 means to select
        // inner edge first, then adjust 'dist' to step inner edge first.
        if (ifEqualStepInner) {
            dist += 1;
        }
    }

    // The algorithm in the Unit test (and presumably the actual HW) assumes
    // the first outside and inside points have been sent (accounted for), even
    // though the starting 'totalToDoIn' and 'oneToDoIn' do not reflect this.
    // Similarly for 'oneToDoOut' and 'totalToDoOut'. That's why they start out
    // with the total counts.
    // Here we fudge an "extra" loop to avoid duplicating the code to send
    // and inside curve (by setting 'first'). To compensate, adjust the
    // various counts.
    first = 1;
    dist += 2*outSegs;
    in--;
    oneToDoIn++;
    totalToDoIn++;
    inStrip = 1;
    lastWasIn = 0;

    // The FD unit test algorithm does "extra" steps at the end which don't
    // matter for HW, but cause extra lines for SW emulation.
    // That's why this code checks for "> 1" instead of "> 0"

    if (doFrac) {
        // fudge things to get alternating out-in-out-in-out ... out
        // NOTE: first 'out' already sent, so start with 'in' below.
        dist = 1;       // set up to alternate in-out-in-out ...
        outSegs = inSegs = 1;       // from now on, only used by 'dist' adjustment
        if (stitchLowOut && usingHW) {
            // for Bot and Left, adjust since first inner point skipped
            oneToDoIn--;
            totalToDoIn--;
        }
    }

    //tag:stst
    while (totalToDoOut > 1  ||  totalToDoIn > 1) {
        while (first || ((totalToDoIn > 1) && (dist > 0))) {
            // step and use an inside point
            first = 0;
            dist -= 2*outSegs;
            in++;
            oneToDoIn--;
            totalToDoIn--;

            if (oneToDoIn == 0  &&  totalToDoIn > 1) {
                // need another inside curve
                if (totalToDoIn > (1+info->maxSwatch+doFrac)) {
                    oneToDoIn = info->maxSwatch;
                    onLowIn = 0;
                    onHighIn = 0;
                    lastInsideCurve = 0;
                } else {
                    oneToDoIn = totalToDoIn;
                    onLowIn = stitchLowIn && revTran;
                    onHighIn = stitchHighIn && !revTran;
                    lastInsideCurve = 1;
                }

                innerCurve = !revTran ? onCurveIn : nCurveIn-1-onCurveIn;
                pCurves = ppCurvesInnerList[innerCurve];

                if (usingHW) {
                    // SEND NEXT INNER TRANSITION CURVE
                    HOS_NOTE("Send Inner Transition");
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE);
                    HOS_PUSH_ADJUST(2);
                    for (index = 0; index < info->maxAttr; index++) {
                        if (info->evalEnables & (1 << index)) {
                            dwCount = 0;
                            //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
                            //fffor (i = 0; i < (*ppCurvesInnerList[!revTran ? 0 : nCurveIn-1])[index]->order; i++) { // }
                            for (i = 0; i < (*pCurves)[index]->order; i++) {
                                HOS_NOTE("Set Curve Coefficients");
                                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][0]));
                                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][1]));
                                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][2]));
                                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][3]));
                                dwCount+=5;
                            }
                            HOS_PUSH_ADJUST(dwCount);
                        }
                    }
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
                    HOS_PUSH_ADJUST(2);
                    HOS_FLUSH();
                } else {
                    EvalStripIdx(info, pCurves, oneToDoIn, pDataIn, in, revTran); // inner
                    if (onHighIn) {
                        if (stitchHighIn) {
                            oneToDoIn--;
                            totalToDoIn--;
                        }
                    }
                    if (revTran) {
                        //ffidxInnerEnd = in+0;
                        idxInnerEnd = in+oneToDoIn-1-onLowIn;
                    } else {
                        idxInnerEnd = in+oneToDoIn-1;
                    }
                    if (onLowIn) {
                        oneToDoIn--;
                        totalToDoIn--;
                    }

                    // Force last point
                    for (index = 0; index < info->maxAttr; index++) {
                        if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                            continue;
                        }
                        if (!(info->evalEnables & (1 << index))) {
                            continue;
                        }
                        if (lastInsideCurve) {
                            if (revTran) {
                                CopyPoint(pDataIn->vertexAttribs[EVAL_IWRAP(idxInnerEnd)][index],
                                        info->gridCorner[index][gridIdxVBegin][gridIdxUBegin]);
                            } else {
                                CopyPoint(pDataIn->vertexAttribs[EVAL_IWRAP(idxInnerEnd)][index],
                                        info->gridCorner[index][gridIdxV][gridIdxU]);
                            }
                        }
                    }
                }
                onCurveIn++;
            }

            if (!usingHW) {
                if (inStrip && lastWasIn) {
                    info->backend->endPrimitive(info);
                    fanCenter = out;
                    fanFirst = in-1;
                    inStrip = 0;
                    if (lastFrontFace != (reverse ^ info->reverse)) {
                        info->backend->setFrontFace(info, lastFrontFace = !lastFrontFace);
                    }
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TFAN);
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(fanCenter));
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(fanFirst));

                } else if (!inStrip && !lastWasIn) {
                    info->backend->endPrimitive(info);
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(in-1));
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(out));
                    inStrip = 1;
                }
                if (inStrip) {
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(in));
                } else {
                    fanLast = in;
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(fanLast));
                }
                lastWasIn = 1;
            }

            if (doFrac) {
                if (totalToDoOut == 1) {
                    dist = 0xDAD;       // complete stitch with fan of inside pts
                }
            }
        }

        if (totalToDoOut > 1) {
            dist += 2*inSegs;
            out++;
            oneToDoOut--;
            totalToDoOut--;

            if (oneToDoOut == 0  &&  totalToDoOut > 1) {
                // need another outside curve
                if (totalToDoOut > 1+info->maxSwatch) {
                    oneToDoOut = info->maxSwatch;   // doesn't fit in one curve
                    lastOutsideCurve = 0;
                } else {
                    oneToDoOut = totalToDoOut;
                    lastOutsideCurve = 1;
                }

                pCurves = ppCurvesOuter[onCurveOut];

                if (usingHW) {
                    // SEND THE NEXT OUTER TRANSITION CURVE
                    HOS_NOTE("Send Outer Transition");
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE);
                    HOS_PUSH_ADJUST(2);
                    for (index = 0; index < info->maxAttr; index++) {
                        if (info->evalEnables & (1 << index)) {
                            // if this is a not a new swath... do we pre adjust that row???
                            // or just not send the last row in the previous patch?
                            dwCount = 0;
                            for (i = 0; i < (*pCurves)[index]->order; i++) {
                                HOS_NOTE("Set Curve Coefficients");
                                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][0]));
                                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][1]));
                                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][2]));
                                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][3]));
                                dwCount+=5;
                            }
                            HOS_PUSH_ADJUST(dwCount);
                        }
                    }
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
                    HOS_PUSH_ADJUST(2);
                    HOS_FLUSH();
                } else {
                    EvalStripIdx(info, pCurves, oneToDoOut, pDataOut, out, 0); // outer

                    // Force last point
                    if (lastOutsideCurve) {
                        for (index = 0; index < info->maxAttr; index++) {
                            if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                                continue;
                            }
                            if (info->evalEnables & (1 << index)) {
                                CopyPoint(pDataOut->vertexAttribs[EVAL_IWRAP(out+oneToDoOut-1)][index],
                                          quadInfo->pCorners[index][cornerIdxV][cornerIdxU]);
                            }
                        }
                    }

                }

                onCurveOut++;
            }

            if (!usingHW) {
                if (inStrip && !lastWasIn) {
                    info->backend->endPrimitive(info);
                    fanCenter = in;
                    fanFirst = out-1;
                    inStrip = 0;
                    if (lastFrontFace != (1 ^ reverse ^ info->reverse)) {
                        info->backend->setFrontFace(info, lastFrontFace = !lastFrontFace);
                    }
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TFAN);
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(fanCenter));
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(fanFirst));

                } else if (!inStrip && lastWasIn) {
                    info->backend->endPrimitive(info);
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(out-1));
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(in));
                    inStrip = 1;
                }
                if (inStrip) {
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(out));
                } else {
                    fanLast = out;
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(fanLast));
                }
                lastWasIn = 0;
            }

            //ffif (doFrac) {
                if (totalToDoIn == 1) {
                    dist = -0xDAD;      // complete stitch with fan of outside pts
                }
            //ff}
        }
    }
    nvAssert(totalToDoOut == 1);
    nvAssert(totalToDoIn == 1);
    nvAssert(onCurveOut == nCurveOut);
    nvAssert(onCurveIn == nCurveIn);

    if (usingHW) {
        HOS_NOTE("END Transition");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_END_TRANSITION)));
        HOS_PUSH(1, 0);
        HOS_PUSH_ADJUST(2);
        HOS_FLUSH();
    } else {
        info->backend->endPrimitive(info);

        info->backend->setFrontFace(info, 0);
    }
}


/*****************************************************************************/
unsigned int DrawIntPatch(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices);
unsigned int DrawIntPatchGrid(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices);

unsigned int DrawFracPatch(NV_PATCH_INFO *info,
                           int botOutSegs, int botInSegs,
                           int leftOutSegs, int leftInSegs,
                           int reverse, FDMatrix **matrices)
{
    unsigned int retVal;
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;

    // layer on top of DrawIntPatch() cases
    quadInfo->nu0 = botOutSegs;
    quadInfo->nu1 = botInSegs;
    quadInfo->nv0 = leftOutSegs;
    quadInfo->nv1 = leftInSegs;

    quadInfo->uMaxSegs = botInSegs;
    quadInfo->vMaxSegs = leftInSegs;
    quadInfo->uMinSegs = botOutSegs;
    quadInfo->vMinSegs = leftOutSegs;
    quadInfo->needUInner = 1;
    quadInfo->needVInner = 1;

    quadInfo->stitchLeft = 1;
    quadInfo->stitchRight = 0;
    quadInfo->stitchTop = 0;
    quadInfo->stitchBottom = 1;

    quadInfo->stitchUBegin = 1;
    quadInfo->stitchUEnd = 0;
    quadInfo->stitchVBegin = 1;
    quadInfo->stitchVEnd = 0;

    quadInfo->u0Dir = 1;
    quadInfo->v0Dir = 1;
    quadInfo->u1Dir = 1;
    quadInfo->v1Dir = 1;
    quadInfo->uMaxDir = 1;
    quadInfo->vMaxDir = 1;

    quadInfo->du0 = 1.f / quadInfo->nu0;
    quadInfo->du1 = 1.f / quadInfo->nu1;
    quadInfo->dv0 = 1.f / quadInfo->nv0;
    quadInfo->dv1 = 1.f / quadInfo->nv1;
    quadInfo->duMax = 1.f / quadInfo->uMaxSegs;
    quadInfo->dvMax = 1.f / quadInfo->vMaxSegs;

    //             *-*-*    the set frontface call will adjust for this
    // winding on  |X|O|
    // subpatches  *-*-*
    // X=CW        |O|X|
    // O=CCW       *-*-*

    info->reverse ^= reverse;
    retVal = DrawIntPatch(info, quadInfo, matrices);
    info->reverse ^= reverse;

    return retVal;
}

/*****************************************************************************/
void
evalPrepareInnerCurves(NV_PATCH_INFO *info, int bigStep, FDMatrix **matrices)
// XXX for swathing, calc the inner curves at the appropriate swatch
{
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    FDMatrix *pMatrix;
    int attr, needRetess;

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m2);
    if (!(info->swatchFlags & NV_PATCH_SWATCH)) {
        needRetess = 0;
    } else {
        needRetess = 1;
    }

    for (attr = 0;  attr < info->maxAttr;  attr++) {
        if (!(info->evalEnables & (1 << attr))) {
            continue;
        }

        // If we're stitching on the top or bottom, do a U inner guard
        if (quadInfo->needUInner) {
            if (needRetess) {
                pMatrix = &info->tempMatrix_m2;
                CopyMatrix(info, pMatrix, matrices[attr]);
                // big to small, only in V so extract produces a big-step curve
                RetessMatrixV(info, 0, pMatrix);
            } else {
                pMatrix = matrices[attr];
            }
            if (quadInfo->stitchVBegin) {
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pUInner[attr], 0, pMatrix, 0, 1);
            } else {
                nvAssert(quadInfo->stitchVEnd);
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pUInner[attr], 0, pMatrix, 0, quadInfo->vMaxSegs-1);
            }
            if (doFrac) {
                // Calc UInnerFrac
                OffsetFDMatrix_Extract_Discard(info, info->guardSetUInnerFrac[attr], 0, pMatrix, 0, quadInfo->vMaxSegs-1);
            }
        }

        // If we're stitching on the left or right, do a V inner guard
        if (quadInfo->needVInner) {
            if (needRetess) {
                pMatrix = &info->tempMatrix_m2;
                CopyMatrix(info, pMatrix, matrices[attr]);
                // big to small, only in U so extract produces a big-step curve
                RetessMatrixU(info, 0, pMatrix);
            } else {
                pMatrix = matrices[attr];
            }
            if (quadInfo->stitchUBegin) {
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pVInner[attr], 1, pMatrix, 1, 0);
            } else {
                nvAssert(quadInfo->stitchUEnd);
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pVInner[attr], 1, pMatrix, quadInfo->uMaxSegs-1, 0);
            }
            if (doFrac) {
                // Calc VInnerFrac
                OffsetFDMatrix_Extract_Discard(info, info->guardSetVInnerFrac[attr], 1, pMatrix, quadInfo->uMaxSegs-1, 0);
            }
        }
    }
    END_USING_TEMP_MATRIX(info->tempMatrix_m2);
}

/*****************************************************************************/
/*****************************************************************************/
static unsigned int
FillIntCornerLL(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;

    if (quadInfo->stitchVBegin) {
        nvAssert(!quadInfo->stitchVEnd);
        if (quadInfo->vMaxSegs > 1) {
            if (quadInfo->stitchUBegin) {
                CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
                OffsetCurve(info, tempCurve, 1);
                CopyPoint(pPoint, tempCurve->coeffs[0]);
                return 0;
            } else {
                // since outside edge takes priority, step along VBegin, and tweak pSwatchUBegin
                CopyCurve(info, tempCurve, (*quadInfo->pSwatchVBegin)[index]);
                OffsetCurve(info, tempCurve, 1);
                CopyPoint(pPoint, tempCurve->coeffs[0]);
                CopyPoint((*quadInfo->pSwatchUBegin)[index]->coeffs[0], pPoint);
                return 0;
            }
        }
        if (quadInfo->stitchUBegin) {
            // must step along ending patch edge
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
            OffsetCurve(info, tempCurve, 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][  quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUBegin) {
        nvAssert(!quadInfo->stitchUEnd);
        // must step along edge, even though (*quadInfo->pSwatchVBegin)[index]->coeffs[0] is about right
        CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
        OffsetCurve(info, tempCurve, 1);
        CopyPoint(pPoint, tempCurve->coeffs[0]);
        // Since the outside edge takes priority, we tweak start of pSwatchVBegin to be on the outside edge
        CopyPoint((*quadInfo->pSwatchVBegin)[index]->coeffs[0], pPoint);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
    }

    return 0;
}

/*****************************************************************************/
static unsigned int
FillIntCornerLR(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;

    if (quadInfo->stitchVBegin) {
        nvAssert(!quadInfo->stitchVEnd);
        if (quadInfo->vMaxSegs > 1) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchVEnd)[index]);
            OffsetCurve(info, tempCurve, 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        if (quadInfo->stitchUEnd) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
            OffsetCurve(info, tempCurve, quadInfo->uMaxSegs - 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][  quadInfo->vMaxDir][quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUEnd) {
        nvAssert(!quadInfo->stitchUBegin);
        CopyPoint(pPoint, (*quadInfo->pSwatchVEnd)[index]->coeffs[0]);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][quadInfo->uMaxDir]);
    }

    return 0;
}

/*****************************************************************************/
static unsigned int
FillIntCornerUL(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;

    if (quadInfo->stitchVEnd) {
        nvAssert(!quadInfo->stitchVBegin);
        if (quadInfo->vMaxSegs > 1) {
            if (quadInfo->stitchUBegin) {
                CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
                OffsetCurve(info, tempCurve, 1);
                CopyPoint(pPoint, tempCurve->coeffs[0]);
            } else {
                CopyPoint(pPoint, (*quadInfo->pSwatchUEnd)[index]->coeffs[0]);
            }
            return 0;
        }
        if (quadInfo->stitchUBegin) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
            OffsetCurve(info, tempCurve, 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUBegin) {
        nvAssert(!quadInfo->stitchUEnd);
        CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
        OffsetCurve(info, tempCurve, 1);
        CopyPoint(pPoint, tempCurve->coeffs[0]);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
    }
    return 0;
}

/*****************************************************************************/
static unsigned int
FillIntCornerUR(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int adjust = doFrac && (info->swatchFlags & NV_PATCH_SWATCH);

    if (quadInfo->stitchVEnd  ||  doFrac) {
        nvAssert(!quadInfo->stitchVBegin  ||  doFrac);
        if ((quadInfo->vMaxSegs > 1)  ||  doFrac) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchVEnd)[index]);
            OffsetCurve(info, tempCurve, quadInfo->vMaxSegs - 1 + adjust);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        if (quadInfo->stitchUEnd  ||  doFrac) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
            OffsetCurve(info, tempCurve, quadInfo->uMaxSegs - 1 + adjust);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        nvAssert(!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL));
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUEnd) {
        nvAssert(!quadInfo->stitchUBegin);
        CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
        OffsetCurve(info, tempCurve, quadInfo->uMaxSegs - 1);
        CopyPoint(pPoint, tempCurve->coeffs[0]);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][quadInfo->vMaxDir][quadInfo->uMaxDir]);
    }

    return 0;
}

/*****************************************************************************/
// routines for integer tessellations
// NOTE: tempVBegin and tempVEnd, are scratch storage.
// This means that the guards may be stepping without a copy.
// The guard setup is handled by the caller, which allows the caller
// to make intelligent choices about the setup and avoid double copies.
// However, the matrix doesn't have any options, so it's better to have
// this routine do the copy from 'matrices' to ppMatrixSetSS0
// since an attr loop is required here anyways.
// So, 'matrices' data must not be altered, and ppMatrixSetSS0[*] are scratch.

// For SW emulation, I tried a strategy of having the formation of the regular
// grid generate curves and guards in preparation for the transitions.
// This can work.
// One of the problems is that a swatch UR guard point is required
// by the HW, so it's not possible to simply write the "top" UInner guard
// from the matrix and just use it, there would still need to be
// a UR guard point to match the swatch to the right.
// In SW, we could save the results from EvalStrip() and feed that into
// the starting point for the next UInner transition (for both the
// FIRST_ROW and LAST_ROW), but not for the inner swatches which naturally get
// guard points and curves from the big step matrices and curves obtained
// while doing swaths.
// In SW, it's required to save all the UInner and VInner curves for later
// doing the transitions, so the storage issue is identical, but with HW it's
// not feasible to store arbitrary amounts of data for later use during the
// transitions.
// So, the "top" UEnd is calculated as a series of guard curves, and the
// guard UR comes from the next curve to the right of the current swatch.
// This could be optimized for SW emulation, but is not done in order to have
// SW emulation more closely match and test requirements for HW drawing.
// Similar reasoning applies to the swatch LR corner guard.
// Also, the VBegin and UBegin inner curves could be totally obtained from
// the matrix at appropriate times, feeding UL and LR to the next
// swatch curve along the outer boundaries of the regular grid.
// Finally, LL could always be obtained from the starting point of the matrix,
// or after one step to the regular grid (as needed for EvalStrip)

unsigned int
DrawIntPatchGrid(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices)
{
    int ix, iy, degen, ylimit, ymax, index, useVBegin, useVEnd;
    NV_PATCH_CURVE_INFO **tempVBegin, **tempVEnd, *tempCurve;
    FDMatrix **ppMatrixSetSS0;
    FDCurveAttrSet *pCurvesTop, *pCurvesBot, *pCurvesTemp;
    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2, *pTemp;
    int fixUL = 0, fixUR = 0;
    int fixLL = 0, fixLR = 0;
    int iEvalRight = quadInfo->uMaxSegs - quadInfo->stitchUEnd;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    NV_PATCH_CURVE_COEFFS *pCoeffs[NV_PATCH_NUMBER_OF_ATTRIBS];
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();
    int usingHW = info->usingHW;

    tempVBegin = info->tempVBegin;
    tempVEnd = info->tempVEnd;
    tempCurve = &info->tempCurve;
    ppMatrixSetSS0 = info->ppMatrixSetSS0;
    pCurvesTop = quadInfo->pCurvesTop;
    pCurvesBot = quadInfo->pCurvesBot;
    pOut1 = quadInfo->pOut1;
    pOut2 = quadInfo->pOut2;

#if defined(ENABLE_DEBUG_SWATH) && defined(IS_OPENGL)
    if (!usingHW && nvDebugLevel >= 3 && (evalTrace & 1)) {
        // draw red X through each sub-patch using corner points

        glDisable(GL_TEXTURE_2D);
        glPushMatrix();
        glTranslatef(0, 0, .1);
        glBegin(GL_LINE_STRIP);
            glColor3f(1, 0, 0); glVertex3fv(info->pSwatchCorner[0][0][0]);
            glColor3f(1, 0, 0); glVertex3fv(info->pSwatchCorner[0][0][1]);
            glColor3f(0, 1, 0); glVertex3fv(info->pSwatchCorner[0][1][0]); 
            glColor3f(0, 1, 0); glVertex3fv(info->pSwatchCorner[0][1][1]);
            glColor3f(1, 0, 0); glVertex3fv(info->pSwatchCorner[0][0][0]);
        glEnd();

        glPopMatrix();
        glColor3f(1, 1, 0);
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif

    // tag:iii
    // setup the swatch
    degen = 0;//(quadInfo->vMaxSegs == 1); // && (quadInfo->stitchVBegin || quadInfo->stitchVEnd);
    ymax = quadInfo->vMaxSegs - quadInfo->stitchVEnd - quadInfo->stitchVBegin;// + degen;

    // check for degenerate regular grid.
    if (!doFrac) {
        if ((ymax <= 0)  ||  ((iEvalRight - quadInfo->stitchUBegin) <= 0)) {
            return retVal;
        }
    } else {
        // this test is normal against <= 2 but we've already pre-subtracted
        // 1 from each before calling here assuming that the regular grid
        // has 1 less segment due to the additional 2 transitions in frac.
        if ((ymax <= 0)  ||  ((iEvalRight - quadInfo->stitchUBegin) <= 0)) {
            return retVal;
        }
    }

    // Note: the 'use' vars are for non-std-guard attributes
    useVBegin = 0;
    useVEnd = 0; //doFrac && (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL);

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {

            // copy and step the forward differencing matrix to the first row of regular grid (as for HW)
            CopyMatrix(info, ppMatrixSetSS0[index], matrices[index]);

#if defined(IS_OPENGL) && defined(COMPILE_TRACE_LIBRARY)
            if ((1 << index) & EV_GUARD_BITS) {
                if (!quadInfo->stitchVBegin) {
                    nvAssert(PointsEqual(tempVBegin[index]->coeffs[0], info->pSwatchCorner[index][0][0]));
                    nvAssert(PointsEqual(tempVEnd[index]->coeffs[0],   info->pSwatchCorner[index][0][1]));
                }

                if ((info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) && !quadInfo->stitchVBegin
                            &&  !quadInfo->stitchUBegin) { // && !quadInfo->needUInner ?
                    // the guard start should match pSwatchUBegin
                    nvAssert(PointsEqual(tempVBegin[index]->coeffs[0], (*quadInfo->pSwatchUBegin)[index]->coeffs[0]));
                    // tempVBegin should be extracted from matrix
                    nvAssert(PointsEqual(tempVBegin[index]->coeffs[0], ppMatrixSetSS0[index]->data[0][0]));
                }

                if (0 && nvDebugLevel >= 4) {
                    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) {
                        if (!(quadInfo->stitchVBegin)) {
                            CompareUCurveMatrix((*quadInfo->pSwatchUBegin)[index], matrices[index]);
                        }
                    }
                    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL) {
                        if (!(quadInfo->stitchUBegin)) {
                            CompareVCurveMatrix((*quadInfo->pSwatchVBegin)[index], matrices[index]);
                        }
                    }
                }

            }
#endif

            OffsetFDMatrix(info, ppMatrixSetSS0[index], 0, quadInfo->stitchVBegin);

            if (usingHW) {
                continue;
            }
            if (!EV_GUARD_ATTR(index)/*  &&  !doFrac*/) {
                continue;
            }

#if defined(IS_OPENGL) && defined(COMPILE_TRACE_LIBRARY)
            // test code for guard curve
            if (0 && nvDebugLevel >= 4) {
                if ((*quadInfo->pSwatchUBegin)[index]) {
                    CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
                    OffsetCurve(info, tempCurve, quadInfo->stitchUBegin);
                    CompareUCurveMatrix(tempCurve, ppMatrixSetSS0[index]);
                }

                if ((*quadInfo->pSwatchVBegin)[index]) {
                    CopyCurve(info, tempCurve, (*quadInfo->pSwatchVBegin)[index]);
                    OffsetCurve(info, tempCurve, quadInfo->stitchVBegin);
                    CompareVCurveMatrix(tempCurve, ppMatrixSetSS0[index]);
                }
            }
#endif

            // Step V Begin/End curves
            if (quadInfo->stitchVBegin) {
                OffsetCurve(info, tempVBegin[index], 1);
                OffsetCurve(info, tempVEnd[index], 1);
                if (!quadInfo->stitchUBegin) {
                    // tweak UInner curve to start at guard locations
                    CopyPoint((*quadInfo->pSwatchUBegin)[index]->coeffs[0], tempVBegin[index]->coeffs[0]);
                }
            }
        }
    }

    if (usingHW) {
        //BEGIN_END_SWATCH/SWATH?
        unsigned long dwFormat;
        dwFormat = NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_BEGIN;
        dwFormat |= (((info->swatchFlags  & NV_PATCH_SWATCH_FIRST_ROW) ? NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_NEW : NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_CONTINUE)   << 4);
        dwFormat |= ((quadInfo->stitchVBegin ? NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_TRUE : NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_FALSE) << 8);
        dwFormat |= ((quadInfo->stitchUBegin ? NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_TRUE : NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_FALSE) << 12);
        dwFormat |= (((quadInfo->vMaxSegs - quadInfo->stitchVEnd < info->maxSwatch) ?  NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_PARTIAL_HEIGHT : NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_FULL_HEIGHT) << 16);
        dwFormat |= (((quadInfo->uMaxSegs - quadInfo->stitchUEnd < info->maxSwatch) ?  NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_PARTIAL_WIDTH : NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_FULL_WIDTH) << 20);

        HOS_NOTE("Begin Swatch");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_SWATCH)));
        HOS_PUSH(1, dwFormat);
        HOS_PUSH_ADJUST(2);

        //send guard curves!!!!
        SendGuardCurve(NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE,  info, quadInfo, info->swatchFlags );
        SendGuardCurve(NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE, info, quadInfo, info->swatchFlags );
    }

    // prep INT patch
    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) {
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                pCoeffs[index] = &(*quadInfo->pSwatchUBegin)[index]->coeffs;

                if (!usingHW) {
                    // no UInner curve, the last curve should be taken from the patch edge
                    CopyCoeffs(info, &(*pCurvesBot)[index]->coeffs, pCoeffs[index]);
                }
            }
        }

        if (usingHW) {
            unsigned long dwCount;  //precount the first two methods.
            int i;
            HOS_NOTE("Begin Curve");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE);
            HOS_PUSH_ADJUST(2);
            for (index = 0; index < info->maxAttr; index++) {
                if (info->evalEnables & (1 << index)) {
                    //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
                    dwCount = 0;
                    for (i = 0; i < ppMatrixSetSS0[index]->columns; i++) {
                        HOS_NOTE("Set Curve Coefficients");
                        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                        HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCoeffs[index])[i][0]));
                        HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCoeffs[index])[i][1]));
                        HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCoeffs[index])[i][2]));
                        HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCoeffs[index])[i][3]));
                        dwCount+=5;
                    }
                    HOS_PUSH_ADJUST(dwCount);
                }
            }
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
            HOS_PUSH_ADJUST(2);

        } else {
            // first strip of regular grid. Will become first bot strip.
            EvalStrip(info, pCurvesBot, 1+quadInfo->uMaxSegs - quadInfo->stitchUEnd, pOut2, 0);
            for (index = 0; index < info->maxAttr; index++) {
                if (info->evalEnables & (1 << index)) {
                    if (EV_GUARD_ATTR(index) || useVBegin) {
                        if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL) {
                            // Force last point from grid corner
                            CopyPoint(pOut2->vertexAttribs[quadInfo->stitchUBegin][index],
                                                            info->gridCorner[index][1-quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
                        } else {
                            // Force first point from guard curve
                            CopyPoint(pOut2->vertexAttribs[quadInfo->stitchUBegin][index], tempVBegin[index]->coeffs[0]);
                        }
                    }
                    if (EV_GUARD_ATTR(index) || useVEnd) {
                        if (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) {
                            // Force last point from grid corner
                            CopyPoint(pOut2->vertexAttribs[iEvalRight][index],
                                                            info->gridCorner[index][1-quadInfo->vMaxDir][  quadInfo->uMaxDir]);
                        } else {
                            // Force last point from guard curve
                            CopyPoint(pOut2->vertexAttribs[iEvalRight][index], tempVEnd[index]->coeffs[0]);
                        }
                    }
                }
            }
        }

    } else {
        // not first row
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                // tweak 
            }
        }
    }

    if (doFrac) {
        // for FRAC patches, check after writing UBegin
        if ((ymax <= 0)  ||  ((iEvalRight - quadInfo->stitchUBegin) <= 0)) {
            return retVal;
        }
    }

    // tag:rrr
    // loop thru regular grid, plus 1 for top stitch to init info for "bot" of top stitch
    ylimit = ymax - 1;
    for (iy = 0; iy < ymax; iy++) {
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                OffsetFDMatrix(info, ppMatrixSetSS0[index], 0, 1);
                if (EV_GUARD_ATTR(index)  ||  useVBegin) {
                    OffsetCurve(info, tempVBegin[index], 1);
                }
                if (EV_GUARD_ATTR(index)  ||  useVEnd) {
                    OffsetCurve(info, tempVEnd[index], 1);
                }

                if ((iy == ylimit) && (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW)) {
                    if (quadInfo->stitchVEnd) {
                        float t4[4];
                        int doTweak = !quadInfo->stitchUBegin && EV_GUARD_ATTR(index);

                        if (doTweak) {
                            // save curve, but preserve starting point
                            // copy since swatchCorner may be the same as pSwatchUEnd
                            CopyPoint(t4, info->pSwatchCorner[index][1][0]);
                            ExtractUCurve(info, (*quadInfo->pSwatchUEnd)[index], ppMatrixSetSS0[index]);
                        }

                        if (doTweak) {
                            // but tweak to swatchCorner set up by higher level routine
                            CopyPoint((*quadInfo->pSwatchUEnd)[index]->coeffs[0], t4);
                        }
                    }
                    pCoeffs[index] = &(*quadInfo->pSwatchUEnd)[index]->coeffs;
                } else {
                    // "inside" regular grid
                    pCoeffs[index] = &ppMatrixSetSS0[index]->data[0];
                }

                if (!usingHW) {
                    CopyCoeffs(info, &(*pCurvesTop)[index]->coeffs, pCoeffs[index]);
                }
            }
        }

        if (iy == ylimit  &&  !doFrac  &&  (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW)) {
            //ffif (quadInfo->stitchVEnd && !quadInfo->stitchUBegin) {
            if (quadInfo->stitchVEnd) {
                // tweak UInner curve to start at guard locations
                //ffCopyPoint((*quadInfo->pSwatchUEnd)[ATTR_V]->coeffs[0], tempVBegin[ATTR_V]->coeffs[0]);
                //ff(*quadInfo->pSwatchUEnd)[ATTR_V]->coeffs[0][1] += .05;
            }
        }

        if (!usingHW) {
            // eval "top" strip
            EvalStrip(info, pCurvesTop, 1+quadInfo->uMaxSegs - quadInfo->stitchUEnd, pOut1, 0);

            if (iy == ylimit  &&  !doFrac) {
                // force first and last point from swatch corner
                for (index = 0; index < info->maxAttr; index++) {
                    if (!(info->evalEnables & (1 << index))) {
                        continue;
                    }
                    if (EV_GUARD_ATTR(index)) {
                        CopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], info->pSwatchCorner[index][1][0]);
                        CopyPoint(pOut1->vertexAttribs[iEvalRight][index], info->pSwatchCorner[index][1][1]);
                        continue;
                    }
                    if (!doFrac) {
                        continue;
                    }
                    if (!useVEnd) {
                        continue;
                    }
                    // Force first point from guard curve
                    //ffCopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], tempVBegin[index]->coeffs[0]);

                    if (!(info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW)) {
                        // Force last point from guard curve
                        //ffCopyPoint(pOut1->vertexAttribs[iEvalRight][index], tempVEnd[index]->coeffs[0]);
                    } else {
                        //ff// get first point from corner
                        //ffCopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], info->pSwatchCorner[index][1][0]);
                        // get end point from corner
                        CopyPoint(pOut1->vertexAttribs[iEvalRight][index], info->pSwatchCorner[index][1][1]);
                    }
                }

            } else {
                for (index = 0; index < info->maxAttr; index++) {
                    if (info->evalEnables & (1 << index)) {
                        if (EV_GUARD_ATTR(index)  ||  useVBegin) {
                            // Force first point from guard curve
                            CopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], tempVBegin[index]->coeffs[0]);
                        }
                        if (EV_GUARD_ATTR(index)  ||  useVEnd) {
                            // Force last point from guard curve
                            CopyPoint(pOut1->vertexAttribs[iEvalRight][index], tempVEnd[index]->coeffs[0]);
                        }
                    }
                }
            }
        }

        // avoid strip when degenerate regular grid (have only bottom stitch)
        // and avoid degenerate strip at top of regular grid
        if (!degen) {
            if (usingHW) {
                unsigned long dwCount;  //precount the first two methods.
                int i;
                HOS_NOTE("Begin Curve");
                HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE);
                HOS_PUSH_ADJUST(2);
                for (index = 0; index < info->maxAttr; index++) {
                    if (info->evalEnables & (1 << index)) {
                        dwCount = 0;
                        //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
                        for (i = 0; i < ppMatrixSetSS0[index]->columns; i++) {
                            HOS_NOTE("Set Curve Coefficients");
                            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCoeffs[index])[i][0]));
                            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCoeffs[index])[i][1]));
                            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCoeffs[index])[i][2]));
                            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCoeffs[index])[i][3]));
                            dwCount+=5;
                        }
                        HOS_PUSH_ADJUST(dwCount);
                    }
                }
                HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
                HOS_PUSH_ADJUST(2);

            } else {
                // output a strip of the regular grid
                info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
                if (!(quadInfo->uMaxDir ^ quadInfo->vMaxDir ^ info->flipUV)) {
                    // "normal", start with top-bot-top
                    for (ix = quadInfo->stitchUBegin; ix <= quadInfo->uMaxSegs - quadInfo->stitchUEnd; ix++) {
                        info->backend->sendVertex(info, pOut1, ix);
                        info->backend->sendVertex(info, pOut2, ix);
                    }
                } else {
                    // flipped case
                    for (ix = quadInfo->stitchUBegin; ix <= quadInfo->uMaxSegs - quadInfo->stitchUEnd; ix++) {
                        info->backend->sendVertex(info, pOut2, ix);
                        info->backend->sendVertex(info, pOut1, ix);
                    }
                }
                info->backend->endPrimitive(info);
            }
        }
        pTemp = pOut1;
        pOut1 = pOut2;
        pOut2 = pTemp;
        pCurvesTemp = pCurvesTop;
        pCurvesTop = pCurvesBot;
        pCurvesBot = pCurvesTemp;
    }

    if (usingHW) {
        HOS_NOTE("End Swatch");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_SWATCH)));
        HOS_PUSH(1, NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_END);
        HOS_PUSH_ADJUST(2);
    }

    quadInfo->pCurvesTop = pCurvesTop;
    quadInfo->pCurvesBot = pCurvesBot;
    quadInfo->pOut1 = pOut1;
    quadInfo->pOut2 = pOut2;

    return retVal;
}


void DrawAllPatchTransitions(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
            FDCurveAttrSet **ppSetU0, FDCurveAttrSet **ppSetU1, FDCurveAttrSet **ppSetUInner, FDCurveAttrSet **ppSetUInnerFrac,
            FDCurveAttrSet **ppSetV0, FDCurveAttrSet **ppSetV1, FDCurveAttrSet **ppSetVInner, FDCurveAttrSet **ppSetVInnerFrac)
{
    FDCurveAttrSet **ppCurvesOut, **ppCurvesInner;

    NV_TRACE_COND(TR_EVAL, 25,
        TPRINTF(("DrawAllPatchTransitions nU0=%d nU1=%d nV0=%d nV1=%d\n",
                quadInfo->nu0, quadInfo->nu1, quadInfo->nv0, quadInfo->nv1));
        TPRINTF(("\tdir U0=%d U1=%d V0=%d V1=%d\n",
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->v0Dir, quadInfo->v1Dir));
        TPRINTF(("\tmaxDir U=%d V=%d\n", quadInfo->uMaxDir, quadInfo->vMaxDir));
    );

    if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        int index;

        for (index = 0; index < info->maxAttr; index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }

            //These are INNER TRANSITION ENDPOINTS -- we are storing them in the grid corners
            //slot because they are free and the original data there won't be needed anymore
            //ffCopyCurve(info, &info->tempCurve, quadInfo->pU1[index]);
            CopyCurve(info, &info->tempCurve, (*ppSetU1[0])[index]);
            OffsetCurve(info, &info->tempCurve, 1);
            CopyPoint(info->gridCorner[index][1][0], (float*)&info->tempCurve.coeffs[0]);

            //ffCopyCurve(info, &info->tempCurve, quadInfo->pV1[index]);
            CopyCurve(info, &info->tempCurve, (*ppSetV1[0])[index]);
            OffsetCurve(info, &info->tempCurve, 1);
            CopyPoint(info->gridCorner[index][0][1], (float*)&info->tempCurve.coeffs[0]);
        }

        // do initial stitches for FRAC : RIGHT/TOP/LEFT
        nvAssert(quadInfo->v1Dir == quadInfo->vMaxDir);
        nvAssert(quadInfo->u1Dir == quadInfo->uMaxDir);

        // TOP/RIGHT/BOTTOM/LEFT
        // DCR HW must      *---*-----------*
        // render FRAC      |   |    0     /|
        // stitches in      |   *---------* |
        // order TOP /      |   |         | |
        // RIGHT / BOTTOM   | 3 |         |1|
        // LEFT             |   |         | |
        //                  |  _*---------*-*
        //                  |_/      2      |
        //                  *---------------*
        if (quadInfo->nu1 < quadInfo->nv1) {
assert(0);
            // this should not happen because we call MaybeTransposeFlipQuad() to
            // make nu1 >= nv1
            // Mostly this is an optimization, but it may be that
            // HW requires a transpose of the transitions when we are in a degenerate grid case.
        }

        {
            // TOP
            {
                if (quadInfo->uMaxSegs > 1 && quadInfo->vMaxSegs > 1) {
                    ppCurvesOut = ppSetU1;
                    ppCurvesInner = ppSetUInnerFrac;
                    DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner,
                        quadInfo->uMaxSegs, quadInfo->uMaxSegs,
                        quadInfo->pOut1, quadInfo->pOut2,
                        1, 1-quadInfo->uMaxDir,  // for inner beginpoint from regular grid corner
                        1, quadInfo->uMaxDir,  // for inner endpoint from regular grid corner
                        1, quadInfo->u1Dir,    // for outer endpoint from patch corners[][]
                        0, 1,                  // stitchLowOut, stitchHighOut,
                        0, 1,                  // stitchLowIn, stitchHighIn,
                        quadInfo->u1Dir, quadInfo->u0Dir, quadInfo->uMaxDir,
                        quadInfo->u1Dir, 1 ^ quadInfo->u1Dir, LAST_ROW);
                }
            }

            // RIGHT
            {
                if (quadInfo->uMaxSegs > 1 && quadInfo->vMaxSegs > 1) {
                    ppCurvesOut = ppSetV1;
                    ppCurvesInner = ppSetVInnerFrac;
                    //don't render a bottom transition if degenerate regular grid

                    DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMaxSegs, quadInfo->vMaxSegs,
                        quadInfo->pOut1, quadInfo->pOut2,
                        1-quadInfo->vMaxDir, 1,   // for inner beginpoint from regular grid corner
                        quadInfo->vMaxDir, 1,   // for inner endpoint from regular grid corner
                        quadInfo->v1Dir, 1,     // for outer endpoint from patch corners[][]
                        0, 1,                   // stitchLowOut, stitchHighOut,
                        0, 1,                   // stitchLowIn, stitchHighIn,
                        quadInfo->v1Dir, quadInfo->v0Dir, quadInfo->vMaxDir,
                        1 ^ quadInfo->v1Dir, 1 ^ quadInfo->v1Dir, LAST_COL);
                }
            }

            // BOT
            if (quadInfo->stitchBottom) {
                ppCurvesOut = ppSetU0;
                if (quadInfo->vMaxSegs != 2) {
                    ppCurvesInner = ppSetUInner;
                } else {
                    ppCurvesInner = ppSetUInnerFrac;
                }

                DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                    quadInfo->pOut1, quadInfo->pOut2,
                    0, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                    0, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                    0, quadInfo->u0Dir,     // for outer endpoint from patch corners[][]
                    quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                    quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                    quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                    quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->uMaxDir,
                    1 ^ quadInfo->u0Dir, quadInfo->u0Dir, FIRST_ROW);
            }

            // LEFT
            //ffif (quadInfo->stitchLeft && ((quadInfo->vMaxSegs > 1) || (quadInfo->uMaxSegs == 1)))
            if (quadInfo->stitchLeft)
            {
                ppCurvesOut = ppSetV0;
                ppCurvesInner = ppSetVInner;

                DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                    quadInfo->pOut1, quadInfo->pOut2,
                    1-quadInfo->vMaxDir, 0,   // for inner beginpoint from regular grid corner
                    quadInfo->vMaxDir, 0,   // for inner endpoint from regular grid corner
                    quadInfo->v0Dir, 0,     // for outer endpoint from patch corners[][]
                    quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                    quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                    quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                    quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->vMaxDir,
                    quadInfo->v0Dir, quadInfo->v0Dir, FIRST_COL );
            }
        }

        return;
    }

    // HW INT Transitions must be rendered in order TOP/RIGHT/BOTTOM/LEFT
    if (quadInfo->stitchVEnd) {
        if (quadInfo->stitchTop) {
            ppCurvesOut = ppSetU1;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                1, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                1, quadInfo->u1Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u1Dir, quadInfo->u0Dir, quadInfo->uMaxDir,
                quadInfo->u1Dir, 1 ^ quadInfo->u1Dir, LAST_ROW);
        } else {
            ppCurvesOut = ppSetU0;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                0, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                0, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                0, quadInfo->u0Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->uMaxDir,
                1 ^ quadInfo->u0Dir, quadInfo->u0Dir, LAST_ROW);
        }
    }

    if (quadInfo->stitchUEnd) {
        if (quadInfo->stitchRight) {
            ppCurvesOut = ppSetV1;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 1,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 1,   // for inner endpoint from regular grid corner
                quadInfo->v1Dir, 1,     // for outer endpoint from patch corners[][]
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v1Dir, quadInfo->v0Dir, quadInfo->vMaxDir,
                1 ^ quadInfo->v1Dir, 1 ^ quadInfo->v1Dir, LAST_COL);
        } else {
            ppCurvesOut = ppSetV0;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 0,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 0,   // for inner endpoint from regular grid corner
                quadInfo->v0Dir, 0,     // for outer endpoint from patch corners[][]
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->vMaxDir,
                quadInfo->v0Dir, quadInfo->v0Dir, LAST_COL);
        }
    }

    if (quadInfo->stitchVBegin) {
        if (quadInfo->stitchBottom) {
            ppCurvesOut = ppSetU0;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                0, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                0, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                0, quadInfo->u0Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->uMaxDir,
                1 ^ quadInfo->u0Dir, quadInfo->u0Dir, FIRST_ROW);
        } else {
            ppCurvesOut = ppSetU1;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                1, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                1, quadInfo->u1Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u1Dir, quadInfo->u0Dir, quadInfo->uMaxDir,
                quadInfo->u1Dir, 1 ^ quadInfo->u1Dir, FIRST_ROW);
        }
    }

    if (quadInfo->stitchUBegin) {
        if (quadInfo->stitchLeft) {
            ppCurvesOut = ppSetV0;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 0,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 0,   // for inner endpoint from regular grid corner
                quadInfo->v0Dir, 0,     // for outer endpoint from patch corners[][]
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->vMaxDir,
                quadInfo->v0Dir, quadInfo->v0Dir, FIRST_COL);
        } else {
            ppCurvesOut = ppSetV1;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 1,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 1,   // for inner endpoint from regular grid corner
                quadInfo->v1Dir, 1,     // for outer endpoint from patch corners[][]
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v1Dir, quadInfo->v0Dir, quadInfo->vMaxDir,
                1 ^ quadInfo->v1Dir, 1 ^ quadInfo->v1Dir, FIRST_COL);
        }
    }
}

/*****************************************************************************/
// For given GuardSet ptr, and attrib, point to the curve for the attribute
static NV_INLINE NV_PATCH_CURVE_INFO *
pGuardSetCurve(NV_PATCH_INFO *info, FDCurveAttrSet *pBase, int attribIndex)
{
    nvAssert(attribIndex < info->maxAttr);
    return (*pBase)[attribIndex];
}

// draw series of sub-patches in swaths.
// General algorithm:
//  1) high level code computes for "normal" step sizes. This is to optimize
//      for smaller cases where swathing is not needed.
//  2) This routine converts matrices and curves to stepping by 'maxSwatch'
//  3) guard curves and other info is set up stepping around the patch
//      using the larger maxSwatch steps.
//  4) curves and matrices are converted to the smaller step size as needed
//      and passed to DrawIntPatchGrid()
//  5) DrawAllPatchTransitions() is used to draw all transitions
//
// swaths are drawn in col-major order
//
// swatch stepping algorithm:
//          FOR EACH BIG COL
//              horz step BB0 to BB1
//              cvt BB0 to BS0 (in place, BB0 not needed any more)
//              extract BV1 from BB1
//
//              pUL points into BS0 (will be correct when ready for EACH SMALL ROW)
//              pUR points into BV1 (will be correct when ready for EACH SMALL ROW)
//
//              FOR EACH BIG ROW
//                  extract LL from BS0
//                  cvt BS0 to SS0
//                  extract SU0 from SS0
//                  extract SV0 from SS0
//
//                  step BS0 vert (whole matrix, but on last row may just step COL to get UL point)
//                  // note: pUL now points to UL
//
//                  extract LR from BV1
//                  cvt BV1 to SV1
//                  step BV1
//                  // note: pUR now points to UR
//
//                  FOR EACH SMALL ROW
//                      extract SH0 row from SS0 (send to HW, or EvalStrip for SW emulation)
//                      if not last row then step SS0 vert
//

unsigned int DrawIntPatchSwaths(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices)
{
    NV_PATCH_QUAD_INFO  sQuadInfo = *quadInfo;      // swatch quad info
    NV_PATCH_QUAD_INFO  *quadInfoOrig = quadInfo;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int onRow, onCol, index;
    int nSwatchU, nSwatchV;
    int stitch_nSwatchU, stitch_nSwatchV;
    int usingHW = info->usingHW;

    // each original guard curve is stepped 'maxSwatch' steps,
    // and intermediate big step curves are stored in a "GuardSet"
    // These get used once while drawing the regular grid,
    // and again when drawing the transition stitches.
    // Each GuardSet is an array of ptrs to info for each big step.
    // pp means ptr to ptr
    FDCurveAttrSet **ppGuardSetU0;  // pp to curves per attribute
    FDCurveAttrSet **ppGuardSetU1;  // [maxAttr][maxOrder][4]
    FDCurveAttrSet **ppGuardSetV0;  // ...
    FDCurveAttrSet **ppGuardSetV1;
    FDCurveAttrSet **ppGuardSetUInner, **ppGuardSetVInner;
    FDCurveAttrSet **ppGuardSetUInnerFrac, **ppGuardSetVInnerFrac;
    FDCurveAttrSet **ppGuardSetUBegin, **ppGuardSetUEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppGuardSetVBegin, **ppGuardSetVEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppStitchUInner = NULL, **ppStitchVInner = NULL; // inner curves for stitching
    FDCurveAttrSet **ppStitchUInnerFrac = NULL, **ppStitchVInnerFrac = NULL; // inner curves for stitching FRAC patches

    // for doing one swatch
    //ffFDCurveAttrSet lguardSetUBegin;
    //ffFDCurveAttrSet lguardSetUEnd;
    //ffFDCurveAttrSet lguardSetVBegin, lguardSetVEnd;

    // variables for stepping around the regular grid in col-major order
    //      U1-->
    //      UL      UR
    //      +-------+
    //      |       |
    //    ^ |       | ^     <--- one swatch
    //    | |       | |
    //    | |       | |
    //   V0 +-------+ V1
    //      LL      LR
    //      U0-->

    // matrix names have letters B and S to indicate big vs small steps in Vert and Horz directions
    FDMatrixAttrSet *pBB0;          // ptr to FD matrixSet at LL, Big steps Up and Right
    FDMatrixAttrSet *pBB1;          // ptr to FD matrixSet at LR, Big steps Up and Right
    FDMatrixAttrSet *pTempMatrix;   // for ptr swap
    FDMatrixAttrSet matrix0, matrix1;   // actual set of ptrs to matrix set
    FDMatrixAttrSet *pBS0;              // FD matrix at LL, Big steps Up, Small steps Right
    FDMatrixAttrSet SS0;                // ptrs to inner loop FD Matrices, small steps Up and Right

    int needBV0;
    int enablesSU0, enablesSU1, enablesSV0, enablesSV1;
    FDCurveAttrSet  BV0;        // curve from LL to UL, for UInner curve list, big steps
    FDCurveAttrSet  SV0;        // curve from LL to UL, for UInner curve list, small steps
    FDCurveAttrSet  BV1;        // curve from LR to UR, for UInner curve list, big steps
    FDCurveAttrSet  SV1;        // curve from LR to UR, for UInner curve list, small steps
    FDCurveAttrSet  *pSU0;      // ptr to SU0 or ppGuardSetUBegin[onCol]
    FDCurveAttrSet  *pSU1;      // ptr to SU1 or ppGuardSetUEnd[onCol]
    FDCurveAttrSet  *pSV0;      // ptr to SV0 or ppGuardSetVBegin[onRow]
    FDCurveAttrSet  *pSU1Next;  // ptr to next pSU1
    FDCurveAttrSet  *pSV0Next;  // ptr to next pSV0
    FDCurveAttrSet  *pSV1Next;  // ptr to next pSV1
    //ffFDCurveAttrSet  *pBV1;      // ptr to current BV1 (maybe really SV1, but only used to get start point)
    FDCurveAttrSet  *pSV1;      // ptr to current SV1 or ppGuardSetVEnd[onRow]
    //ffFDCurveAttrSet  *pTempCurveSet;

    float LL[NV_PATCH_NUMBER_OF_ATTRIBS][4];
    float LR[NV_PATCH_NUMBER_OF_ATTRIBS][4];
    float UL[NV_PATCH_NUMBER_OF_ATTRIBS][4];
    float UR[NV_PATCH_NUMBER_OF_ATTRIBS][4];        // vertex: for extracting from BS0 and BV1
    float *pLL[NV_PATCH_NUMBER_OF_ATTRIBS];
    float *pLR[NV_PATCH_NUMBER_OF_ATTRIBS];
    float *pUL[NV_PATCH_NUMBER_OF_ATTRIBS];
    float *pUR[NV_PATCH_NUMBER_OF_ATTRIBS];         // vertex: ptr to swatch corner points

    int bytesGuardCurve = EV_ROUND(PATCH_CURVE_HEADER_SIZE + (info->maxOrder * 4) * sizeof(float));   // truncated NV_PATCH_CURVE_INFO
    int bytesGuardCurveAllAttr = info->nAttr * bytesGuardCurve;                 // just the set of curve info

    EV_ALLOC_DECL();
    int nBytes;

    if (doFrac) {
        // The max for nSwatchU/V is not the whole story. The minSegs for the transitions
        // may actually have more steps in the frac case.
        // This is also complicated by the fact that for TRI FRAC, when drawing the
        // third sub-QUAD-FRAC, the U and V get transposed.
        // So, recalc here according to min/max
        int uMax = MAX(quadInfo->uMinSegs, quadInfo->uMaxSegs);

        int vMax = MAX(quadInfo->vMinSegs, quadInfo->vMaxSegs);

        // calc values including end stitch
        stitch_nSwatchU = (uMax - 1) / info->maxSwatch + 1;
        stitch_nSwatchV = (vMax - 1) / info->maxSwatch + 1;
    } else {
        stitch_nSwatchU = info->nSwatchU;
        stitch_nSwatchV = info->nSwatchV;
    }

    evalPrepareInnerCurves(info, 1, matrices);      // prepare the *Inner and *InnerFrac curves

    // use local quadInfo
    quadInfo = &sQuadInfo;
    quadInfo->needUInner = quadInfoOrig->needUInner;
    quadInfo->needVInner = quadInfoOrig->needVInner;

    // allocating full 16 attr's, 16 order, 1000x1000 steps, 16 maxSwatch, 2 Grid FDMatrix columns --> 9.4 Mbytes
    // 4 order --> 8.3 Mbytes
    // and 2 attr --> 1.0 Mbytes

    nBytes =  EV_ROUND(info->maxAttr * sizeof(NV_PATCH_CURVE_INFO *)); // for ppGuardSet's, for U and V
    nBytes += bytesGuardCurveAllAttr;
    nBytes *= (stitch_nSwatchU+1 + stitch_nSwatchV+1);
    nBytes += EV_ROUND((stitch_nSwatchU+1)*sizeof(FDCurveAttrSet *));
    nBytes += EV_ROUND((stitch_nSwatchV+1)*sizeof(FDCurveAttrSet *));
    nBytes *= (doFrac ? 4 : 3);
    nBytes += 6 * bytesGuardCurveAllAttr;                                                           // guards for current swatch
    nBytes += info->nAttr * sizeof(FDMatrix) * (3);                                                 // matrix0,1 and SS0
    nBytes += info->nAttr * bytesGuardCurve * (4);                                                  // BV0, BV1, SV0, SV1

    EV_ALLOC_INIT_WITH_CACHE(info->context, nBytes, drawIntPatchSwathsEnd, info->pCache[EV_CACHE_SWATHING]);

    nBytes = EV_ROUND((stitch_nSwatchU+1) * sizeof(FDCurveAttrSet *));
    EV_ALLOC(ppGuardSetU0,     info->context, nBytes );
    EV_ALLOC(ppGuardSetU1,     info->context, nBytes);
    EV_ALLOC(ppGuardSetUInner, info->context, nBytes);
    if (doFrac) {
        EV_ALLOC(ppGuardSetUInnerFrac, info->context, nBytes);
    }

    nBytes = EV_ROUND((stitch_nSwatchV+1) * sizeof(FDCurveAttrSet *));
    EV_ALLOC(ppGuardSetV0,     info->context, nBytes);
    EV_ALLOC(ppGuardSetV1,     info->context, nBytes);
    EV_ALLOC(ppGuardSetVInner, info->context, nBytes);
    if (doFrac) {
        EV_ALLOC(ppGuardSetVInnerFrac, info->context, nBytes);
    }

    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        EV_ALLOC(quadInfo->pU0[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pU1[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pV0[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pV1[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pUInner[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pVInner[index], info->context, bytesGuardCurve);

        EV_ALLOC(matrix0[index], info->context, sizeof(FDMatrix));
        EV_ALLOC(matrix1[index], info->context, sizeof(FDMatrix));
        EV_ALLOC(SS0[index], info->context, sizeof(FDMatrix));

        EV_ALLOC(BV0[index], info->context, bytesGuardCurve);
        EV_ALLOC(BV1[index], info->context, bytesGuardCurve);
        EV_ALLOC(SV0[index], info->context, bytesGuardCurve);
        EV_ALLOC(SV1[index], info->context, bytesGuardCurve);
    }
    //ffquadInfo->pSwatchVBegin = &lguardSetVBegin;
    //ffquadInfo->pSwatchVEnd = &lguardSetVEnd;

    // set up sets of guard curves for each big step
    // init pointers to guard sub-curves for each big step
    nBytes = EV_ROUND(info->maxAttr * sizeof(NV_PATCH_CURVE_INFO *));
    for (onCol = 0;  onCol <= stitch_nSwatchU;  onCol++) {
        EV_ALLOC(ppGuardSetU0[onCol], info->context, nBytes);
        EV_ALLOC(ppGuardSetU1[onCol], info->context, nBytes);
        EV_ALLOC(ppGuardSetUInner[onCol], info->context, nBytes);
        if (doFrac) {
            EV_ALLOC(ppGuardSetUInnerFrac[onCol], info->context, nBytes);
        }

        for (index = 0; index < info->maxAttr; index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            EV_ALLOC((*ppGuardSetU0[onCol])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetU1[onCol])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetUInner[onCol])[index], info->context, bytesGuardCurve);
            if (doFrac) {
                EV_ALLOC((*ppGuardSetUInnerFrac[onCol])[index], info->context, bytesGuardCurve);
                if (!onCol) {
                    // XXX maybe just point to this
                    CopyCurve(info, (*ppGuardSetUInnerFrac[0])[index], (*info->ppGuardSetUInnerFrac[0])[index]);
                }
            }
        }
    }

    // again for V
    nBytes = EV_ROUND(info->maxAttr * sizeof(NV_PATCH_CURVE_INFO *));
    for (onRow = 0;  onRow <= stitch_nSwatchV;  onRow++) {
        EV_ALLOC(ppGuardSetV0[onRow], info->context, nBytes);
        EV_ALLOC(ppGuardSetV1[onRow], info->context, nBytes);
        EV_ALLOC(ppGuardSetVInner[onRow], info->context, nBytes);
        if (doFrac) {
            EV_ALLOC(ppGuardSetVInnerFrac[onRow], info->context, nBytes);
        }

        for (index = 0; index < info->maxAttr; index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            EV_ALLOC((*ppGuardSetV0[onRow])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetV1[onRow])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetVInner[onRow])[index], info->context, bytesGuardCurve);
            if (doFrac) {
                EV_ALLOC((*ppGuardSetVInnerFrac[onRow])[index], info->context, bytesGuardCurve);
                if (!onRow) {
                    // XXX maybe just point to this
                    CopyCurve(info, (*ppGuardSetVInnerFrac[0])[index], (*info->ppGuardSetVInnerFrac[0])[index]);
                }
            }
        }
    }
    EV_ALLOC_FULL(info->context);

    /*****************************************************************************/
    // This code is analogous to code in DrawIntPatch() to calc quadInfo->guard[i]->pGuardXXX
    // BEGIN SIMILAR CODE
    if (quadInfo->vMaxDir == 1) {
        if (quadInfo->stitchTop) {
            ppGuardSetUBegin = ppGuardSetU0;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
        } else if (quadInfo->stitchBottom) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
            ppGuardSetUEnd = ppGuardSetU1;
        } else {
            ppGuardSetUBegin = ppGuardSetU0;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU1;
        }
    } else {
        if (quadInfo->stitchTop) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
            ppGuardSetUEnd = ppGuardSetU0;
        } else if (quadInfo->stitchBottom) {
            ppGuardSetUBegin = ppGuardSetU1;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
        } else {
            ppGuardSetUBegin = ppGuardSetU1;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU0;
        }
    }

    if (quadInfo->uMaxDir == 1) {
        if (quadInfo->stitchRight) {
            ppGuardSetVBegin = ppGuardSetV0;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
        } else if (quadInfo->stitchLeft) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
            ppGuardSetVEnd = ppGuardSetV1;
        } else {
            ppGuardSetVBegin = ppGuardSetV0;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV1;
        }
    } else {
        if (quadInfo->stitchRight) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
            ppGuardSetVEnd = ppGuardSetV0;
        } else if (quadInfo->stitchLeft) {
            ppGuardSetVBegin = ppGuardSetV1;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
        } else {
            ppGuardSetVBegin = ppGuardSetV1;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV0;
        }
    }
    if (doFrac) {
        ppStitchUInnerFrac = ppGuardSetUEnd = ppGuardSetUInnerFrac;
        ppStitchVInnerFrac = ppGuardSetVEnd = ppGuardSetVInnerFrac;
    }
    // END SIMILAR CODE

    /*****************************************************************************/
    // calc initial big step U guard curves
    // For now, use BV0, BV1, SV0, SV1  for BU0, BU1, BUInner, BUInnerFrac
    // XXX TODO: one of the outside curves may not require as many steps
    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        CopyCurve(info, BV0[index], quadInfoOrig->pU0[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pU0[index], pGuardSetCurve(info, ppGuardSetU0[0], index));
        CopyCurve(info, BV1[index], quadInfoOrig->pU1[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pU1[index], pGuardSetCurve(info, ppGuardSetU1[0], index));

        if (quadInfo->needUInner) {
            CopyCurve(info, SV0[index], quadInfoOrig->pUInner[index]);
            RetessCurveInOut(info, 0, quadInfoOrig->pUInner[index], pGuardSetCurve(info, ppGuardSetUInner[0], index));
        }
        //ffif (doFrac  &&  EV_GUARD_ATTR(index)) { // }
        if (doFrac) {
            CopyCurve(info, SV1[index], pGuardSetCurve(info, ppGuardSetUInnerFrac[0], index));
            RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetUInnerFrac[0], index));
        }
    }

    // make big steps and cvt to small for later
    for (onCol = 1;  onCol <= stitch_nSwatchU;  onCol++) {
        // copy all prev attrs
        __NV_MEMCPY(pGuardSetCurve(info, ppGuardSetU0[onCol], info->firstAttr),
                    pGuardSetCurve(info, ppGuardSetU0[onCol-1], info->firstAttr), 3*bytesGuardCurveAllAttr);
        for (index = 0;  index < info->maxAttr;  index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            OffsetCurve(info, BV0[index], 1);
            RetessCurveInOut(info, 0, BV0[index], pGuardSetCurve(info, ppGuardSetU0[onCol], index));
            OffsetCurve(info, BV1[index], 1);
            RetessCurveInOut(info, 0, BV1[index], pGuardSetCurve(info, ppGuardSetU1[onCol], index));
            //ffif (quadInfo->needUInner && quadInfo->stitchVEnd && (EV_GUARD_ATTR(index) || !usingHW)) { // }
            if (quadInfo->needUInner) {
                OffsetCurve(info, SV0[index], 1);
                RetessCurveInOut(info, 0, SV0[index], pGuardSetCurve(info, ppGuardSetUInner[onCol], index));
            }
            //ffif (doFrac  &&  EV_GUARD_ATTR(index)) { // }
            if (doFrac) {
                OffsetCurve(info, SV1[index], 1);
                RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetUInnerFrac[onCol], index));
            }
        }
    }

#if defined(ENABLE_DEBUG_SWATH)
    if (!usingHW && nvDebugLevel >= 4 && (evalTrace & 4)) {
        // red lines from "outside" to swatch boundaries for U0
        // grn lines from "outside" to swatch boundaries for U1
        // blue lines from center to swatch boundaries for UInner
        glDisable(GL_TEXTURE_2D);
        glBegin(GL_LINES);
        for (onCol = 0;  onCol <= stitch_nSwatchU;  onCol++) {
            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetU0[onCol], 3)->coeffs[0]);
            } else {
                glColor3f(1, 0, 0);
            }
            glVertex3f(.5, -1, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetU0[onCol], 0)->coeffs[0]);

            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetU1[onCol], 3)->coeffs[0]);
            } else {
                glColor3f(0, 1, 0);
            }
            glVertex3f(.5, 2, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetU1[onCol], 0)->coeffs[0]);

            if (quadInfo->needUInner) {
                if (info->evalEnables & (1 << 3)) {
                    glColor3fv(pGuardSetCurve(info, ppGuardSetUInner[onCol], 3)->coeffs[0]);
                } else {
                    glColor3f(0, 0, 1);
                }
                glVertex3f(.5, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetUInner[onCol], 0)->coeffs[0]);
            }
        }
        glEnd();
        if (!(info->evalEnables & (1 << 3))) {
            glColor3f(.5, .5, .5);
        }
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif

    /*****************************************************************************/
    /*****************************************************************************/
    // calc initial big step V guard curves
    // For now, use BV0, BV1, SV0, SV1  for BV0, BV1, BVInner, BVInnerFrac
    // XXX TODO: one of the outside curves may not require as many steps
    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        CopyCurve(info, BV0[index], quadInfoOrig->pV0[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pV0[index], pGuardSetCurve(info, ppGuardSetV0[0], index));
        CopyCurve(info, BV1[index], quadInfoOrig->pV1[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pV1[index], pGuardSetCurve(info, ppGuardSetV1[0], index));

        //ffif (quadInfo->needVInner && quadInfo->stitchUEnd) {
        if (quadInfo->needVInner) {
            CopyCurve(info, SV0[index], quadInfoOrig->pVInner[index]);
            RetessCurveInOut(info, 0, quadInfoOrig->pVInner[index], pGuardSetCurve(info, ppGuardSetVInner[0], index));
        }
        if (doFrac) {
            CopyCurve(info, SV1[index], pGuardSetCurve(info, ppGuardSetVInnerFrac[0], index));
            RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetVInnerFrac[0], index));
        }
    }

    // make big steps and cvt to small for later
    for (onRow = 1;  onRow <= stitch_nSwatchV;  onRow++) {
        // copy all prev attrs
        __NV_MEMCPY(pGuardSetCurve(info, ppGuardSetV0[onRow], info->firstAttr),
                    pGuardSetCurve(info, ppGuardSetV0[onRow-1], info->firstAttr), 3*bytesGuardCurveAllAttr);
        for (index = 0;  index < info->maxAttr;  index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            OffsetCurve(info, BV0[index], 1);
            RetessCurveInOut(info, 0, BV0[index], pGuardSetCurve(info, ppGuardSetV0[onRow], index));
            OffsetCurve(info, BV1[index], 1);
            RetessCurveInOut(info, 0, BV1[index], pGuardSetCurve(info, ppGuardSetV1[onRow], index));
            //ffif (quadInfo->needVInner && quadInfo->stitchUEnd) {
            if (quadInfo->needVInner) {
                OffsetCurve(info, SV0[index], 1);
                RetessCurveInOut(info, 0, SV0[index], pGuardSetCurve(info, ppGuardSetVInner[onRow], index));
            }
            if (doFrac) {
                OffsetCurve(info, SV1[index], 1);
                RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetVInnerFrac[onRow], index));
            }
        }
    }

#if defined(ENABLE_DEBUG_SWATH)
    if (!usingHW && nvDebugLevel >= 4 && (evalTrace & 8)) {
        // red lines from "outside" to swatch boundaries for V0
        // grn lines from "outside" to swatch boundaries for V1
        // violet lines from center to swatch boundaries for VInner
        glDisable(GL_TEXTURE_2D);
        glBegin(GL_LINES);
        for (onRow = 0;  onRow < stitch_nSwatchV;  onRow++) {
            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetV0[onRow], 3)->coeffs[0]);
            } else {
                glColor3f(1, 0, 0);
            }
            glVertex3f(-1, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetV0[onRow], 0)->coeffs[0]);

            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetV1[onRow], 3)->coeffs[0]);
            } else {
                glColor3f(0, 1, 0);
            }
            glVertex3f(2, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetV1[onRow], 0)->coeffs[0]);

            if (quadInfo->needVInner) {
                if (info->evalEnables & (1 << 3)) {
                    glColor3fv(pGuardSetCurve(info, ppGuardSetVInner[onRow], 3)->coeffs[0]);
                } else {
                    glColor3f(1, 0, 1);
                }
                glVertex3f(.5, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetVInner[onRow], 0)->coeffs[0]);
            }
        }
        glEnd();
        if (!(info->evalEnables & (1 << 3))) {
            glColor3f(.5, .5, .5);
        }
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif

    /*****************************************************************************/
    // work on regular grid

    // calc swaths WITHOUT including ending stitch
    index = 1 + doFrac; // index is a temp // adjust to not draw FRAC RIGHT and TOP stitch
    nSwatchU = (quadInfo->uMaxSegs - index - quadInfo->stitchUEnd) / info->maxSwatch + 1;
    nSwatchV = (quadInfo->vMaxSegs - index - quadInfo->stitchVEnd) / info->maxSwatch + 1;
    if (!doFrac) {
        // note: for FRAC cases, the quadInfo->uMaxSegs used at this point can be
        // quite different than the full MAX calculated in evalCommonSetup()
        // Therefore, the following is only generally true for INT cases.
        nvAssert((stitch_nSwatchU - nSwatchU) <= 1);
    }
    nvAssert((*ppGuardSetU0[0])[0]->order == (*ppGuardSetU1[0])[0]->order);
    nvAssert((*ppGuardSetV0[0])[0]->order == (*ppGuardSetV1[0])[0]->order);
    // note: ppStitchUInner and ppStitchVInner may not be formed yet

    // convert small to big steps for starting matrix BB0
    pBB0 = &matrix0;
    pBB1 = &matrix1;

    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        CopyMatrix(info, (*pBB0)[index], matrices[index]);
    }

    // tag:sss swathing loop
    for (onCol = 0;  onCol < nSwatchU;  onCol++) {          // ********** for each col in the patch
        int rem, rightSV1;

        CopyMatrixSet(info, info->evalEnables, pBB1, pBB0);     // horz step BB0 to BB1
        OffsetFDMatrixSet(info, info->evalEnables, pBB1, 1, 0); // ...

        // cvt BB0 to BS0 (in place)
        pBS0 = pBB0;
        RetessMatrixSetU(info, 0, info->evalEnables, pBS0);

        // if no left stitch, then BV0 may be extracted from BS0,
        // otherwise must create and step BV0 and SV0
        needBV0 = !onCol && quadInfoOrig->stitchUBegin;
        if (needBV0) {
            CopyMatrixSet(info, info->evalEnables, (FDMatrixAttrSet *)info->ppMatrixSetSS0, pBS0);
            // XXX: steps of '1'-and-never-more can be done with short-cut
            OffsetFDMatrixSet(info, info->evalEnables, (FDMatrixAttrSet *)info->ppMatrixSetSS0, 1, 0);
            ExtractVCurveSet(info, info->evalEnables, &BV0, (FDMatrixAttrSet *)info->ppMatrixSetSS0);
        }

        if (onCol != (nSwatchU-1)) {
            rightSV1 = 0;
            ExtractVCurveSet(info, info->evalEnables, &BV1, pBB1);  // extract BV1 from BB1
        } else {
            rightSV1 = 1;
        }

        if (info->evalEnables & EV_GUARD_BIT_VERTEX) {
            pUL[ATTR_V] = (*pBS0)[ATTR_V]->data[0][0];
        }
        if (info->evalEnables & EV_GUARD_BIT_NORMAL) {
            pUL[ATTR_N] = (*pBS0)[ATTR_N]->data[0][0];
        }

        // tag:roww
        for (onRow = 0;  onRow < nSwatchV;  onRow++) {      // ********** for each row in the col
            //ffint needUL = 0;
            int needLL = 0;

            info->swatchFlags = NV_PATCH_SWATCH;
            info->setGridCorner = 0;
            enablesSU0 = enablesSU1 = enablesSV0 = enablesSV1 = info->evalEnables;

// ... col
            if (!onCol) {
                info->swatchFlags |= NV_PATCH_SWATCH_FIRST_COL;
                quadInfo->stitchUBegin = quadInfoOrig->stitchUBegin;
                if (!onRow) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER00;
                }
                pSV0 = ppGuardSetVBegin[onRow];
                pSV0Next = ppGuardSetVBegin[onRow+1];

            } else {
                quadInfo->stitchUBegin = 0;
                pSV0 = &SV0;
                pSV0Next = NULL;
            }

            if (onCol == (nSwatchU-1)) {
                info->swatchFlags |= NV_PATCH_SWATCH_LAST_COL;
                quadInfo->stitchUEnd = quadInfoOrig->stitchUEnd;
                if (!onRow) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER01;
                }
                pSV1 = ppGuardSetVEnd[onRow];
                pSV1Next = ppGuardSetVEnd[onRow+1];

            } else {
                quadInfo->stitchUEnd = 0;
                pSV1 = &SV1;
                pSV1Next = NULL;
            }

            for (index = 0; index < info->maxAttr; index++) {
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }
                //ffif (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                    //ffcontinue;
                //ff}
                //ff(*quadInfo->pSwatchVEnd)[index] = (*pSV1)[index];
            }
// ... row
            if (!onRow) {
                info->swatchFlags |= NV_PATCH_SWATCH_FIRST_ROW;
                quadInfo->stitchVBegin = quadInfoOrig->stitchVBegin;
                pSU0 = ppGuardSetUBegin[onCol];

            } else {
                quadInfo->stitchVBegin = 0;
                pSU0 = NULL;
            }

            if (onRow == (nSwatchV-1)) {
                info->swatchFlags |= NV_PATCH_SWATCH_LAST_ROW;
                quadInfo->stitchVEnd = quadInfoOrig->stitchVEnd;
                quadInfo->pSwatchUEnd = pSU1 = ppGuardSetUEnd[onCol];
                pSU1Next = ppGuardSetUEnd[onCol+1];

                if (!onCol) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER10;
                }
                if (onCol==(nSwatchU-1)) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER11;
                }
            } else {
                quadInfo->stitchVEnd = 0;
                //ffquadInfo->pSwatchUEnd = &lguardSetUEnd;
                pSU1 = NULL;
                pSU1Next = NULL;
            }
// ... end row
            quadInfo->pSwatchUBegin = pSU0;
            quadInfo->pSwatchUEnd = pSU1;
            quadInfo->pSwatchVBegin = pSV0;
            quadInfo->pSwatchVEnd = pSV1;

            // ***** compute segs for this swatch, including any ending stitches
            quadInfo->uMaxSegs = info->maxSwatch;
            quadInfo->vMaxSegs = info->maxSwatch;
            rem = quadInfoOrig->uMaxSegs - doFrac - quadInfo->stitchUEnd - (onCol + 1) * info->maxSwatch;
            if (rem < 0) {
                quadInfo->uMaxSegs += rem;
            }
            rem = quadInfoOrig->vMaxSegs - doFrac - quadInfo->stitchVEnd - (onRow + 1) * info->maxSwatch;
            if (rem < 0) {
                quadInfo->vMaxSegs += rem;
            }
            quadInfo->uMaxSegs += quadInfo->stitchUEnd;
            quadInfo->vMaxSegs += quadInfo->stitchVEnd;

            // ***** prepare matrices and curves for this swatch *****
            CopyMatrixSet(info, info->evalEnables, &SS0, pBS0);
            RetessMatrixSetV(info, 0, info->evalEnables, &SS0);
            //ffEV_DRAW( evalDrawMatrix(info, SS0[0], 0, 0) );

            BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
            if (rightSV1 && !onRow /*&& quadInfo->stitchUEnd*/) {
                // prepare first BV1
                for (index = 0; index < info->maxAttr; index++) {
                    if (info->evalEnables & (1 << index)) {
                        CopyMatrix(info, &info->tempMatrix, (*pBS0)[index]);
                        OffsetFDMatrix(info, &info->tempMatrix, quadInfo->uMaxSegs, 0);
                        ExtractUCurve(info, BV1[index], &info->tempMatrix);
                    }
                }
            }
            END_USING_TEMP_MATRIX(info->tempMatrix);
            OffsetFDMatrixSet(info, info->evalEnables, pBS0, 0, 1); // up to next row

            if (!rightSV1) {
                RetessCurveSetInOut(info, 0, info->evalEnables, &BV1, pSV1);
                OffsetCurveSet(info, info->evalEnables & EV_GUARD_BITS, &BV1, 1);
            }

            // ***** prepare guard information
            // prepare U0 info
            BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
            for (index = 0; index < info->maxAttr; index++) {
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }
                if (!onRow && quadInfo->stitchVBegin) {
                    CopyMatrix(info, &info->tempMatrix, SS0[index]);
                    OffsetFDMatrix(info, &info->tempMatrix, 0, 1);
                    ExtractUCurve(info, (*pSU0)[index], &info->tempMatrix);
                }
                if ((info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) && quadInfo->stitchVEnd) {
                    //ffCopyMatrix(info, &info->tempMatrix, SS0[index]);
                    //ffOffsetFDMatrix(info, &info->tempMatrix, 0, quadInfo->vMaxSegs - 1);
                    //ffExtractUCurve(info, (*pSU1)[index], &info->tempMatrix);
                }
                if (!onCol && quadInfo->stitchUBegin) {
                    CopyMatrix(info, &info->tempMatrix, SS0[index]);
                    OffsetFDMatrix(info, &info->tempMatrix, 1, 0);
                    ExtractVCurve(info, (*pSV0)[index], &info->tempMatrix);
                }
                if ((info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) && !onRow) {
                    CopyMatrix(info, &info->tempMatrix, SS0[index]);
                    OffsetFDMatrix(info, &info->tempMatrix, quadInfo->uMaxSegs - quadInfo->stitchUEnd, 0);
                    ExtractVCurve(info, (*pSV1)[index], &info->tempMatrix);
                }
            }
            END_USING_TEMP_MATRIX(info->tempMatrix);

            // prepare V0 info
            if (needBV0) {
                int eset = info->evalEnables;// & ~EV_GUARD_BITS;

                // BV0-->SV0 will be saved away for VInner transition curve set
                RetessCurveSetInOut(info, 0, eset, &BV0, pSV0);
                OffsetCurveSet(info, eset, &BV0, 1);        // to next swatch row

            } else if (onCol) {
                // other columns extract SV0 from SS0
                ExtractVCurveSet(info, info->evalEnables & EV_GUARD_BITS, pSV0, &SS0);
            }

            // tag:ccorn prepare corner points
            for (index = 0; index < info->maxAttr; index++) {
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }

                if (quadInfo->stitchUBegin) {
                    nvAssert(needBV0);
                    if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                        // on the last row, always get from UEnd curve
                        AddPoint3(UL[index], (*pSU1)[index]->coeffs[0], (*pSU1)[index]->coeffs[1]);
                        pUL[index] = UL[index];
                    } else {
                        pUL[index] = (BV0)[index]->coeffs[0];
                    }
                    if (!(info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW)) {
                        pLL[index] = (*pSV0)[index]->coeffs[0];
                    } else {
                        // bot row
                        AddPoint3(LL[index], (*pSU0)[index]->coeffs[0], (*pSU0)[index]->coeffs[1]);
                        pLL[index] = LL[index];
                    }
                } else {
                    if (quadInfo->stitchVBegin) {
                        AddPoint3(LL[index], (*pSV0)[index]->coeffs[0], (*pSV0)[index]->coeffs[1]);
                        pLL[index] = LL[index];
                    } else {
                        pLL[index] = (*pSV0)[index]->coeffs[0];
                    }
                    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL) {
                        if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                            pUL[index] = (*pSU1)[index]->coeffs[0];
                        } else {
                            pUL[index] = (*pSV0Next)[index]->coeffs[0];
                        }
                    } else {
                        if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                            pUL[index] = (*pSU1)[index]->coeffs[0];
                        } else {
                            pUL[index] = (*pBS0)[index]->data[0][0];
                        }
                    }
                }

                if (quadInfo->stitchVBegin) {
                    AddPoint3(LR[index], (*pSV1)[index]->coeffs[0], (*pSV1)[index]->coeffs[1]);
                    pLR[index] = LR[index];
                } else {
                    pLR[index] = (*pSV1)[index]->coeffs[0];
                }

                if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                    if (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) {
                        // step cur U1 to get there
                        FillIntCornerUR(info, quadInfo, quadInfoOrig, index, UR[index]);
                        pUR[index] = UR[index];
                        //ffCopyCurve(info, &info->tempCurve, (*pSU1)[index]);
                        //ffOffsetCurve(info, &info->tempCurve, quadInfo->uMaxSegs - quadInfo->stitchVEnd);
                        //ffCopyPoint(UR, info->tempCurve.coeffs[0]);
                    } else {
                        pUR[index] = (*pSU1Next)[index]->coeffs[0];
                    }
                } else {
                    if (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) {
                        pUR[index] = (*pSV1Next)[index]->coeffs[0];
                    } else {
                        pUR[index] = (BV1)[index]->coeffs[0];
                    }
                }
                //ffCopyCurve(info, &info->tempCurve, (*pSV1)[index]);
                //ffOffsetCurve(info, &info->tempCurve, quadInfo->vMaxSegs - quadInfo->stitchVEnd);
                //ffCopyPoint(UR, info->tempCurve.coeffs[0]);
                //ffpUR[index] = UR;
                if (quadInfo->stitchVEnd) {
                } else {
                }

                info->pSwatchCorner[index][0][0] = pLL[index];
                info->pSwatchCorner[index][0][1] = pLR[index];
                info->pSwatchCorner[index][1][0] = pUL[index];
                info->pSwatchCorner[index][1][1] = pUR[index];

                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER00) {
                    CopyPoint(info->gridCorner[index][1-quadInfo->vMaxDir][ 1-quadInfo->uMaxDir], pLL[index]);
                }
                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER01) {
                    CopyPoint(info->gridCorner[index][1-quadInfo->vMaxDir][   quadInfo->uMaxDir], pLR[index]);
                }

                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER10) {
                    CopyPoint(info->gridCorner[index][  quadInfo->vMaxDir][ 1-quadInfo->uMaxDir], pUL[index]);
                }
                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER11) {
                    CopyPoint(info->gridCorner[index][  quadInfo->vMaxDir][   quadInfo->uMaxDir], pUR[index]);
                }
            }

            // Copy V guard curves
            // Note: must be done after FillIntCorner*() because the start values for
            // the pSwatch curves may be tweaked to match between the regular grid and stitches.
            for (index = 0; index < info->maxAttr; index++) {
                if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                    continue;
                }
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }
                CopyCurve(info, info->tempVEnd[index], (*quadInfo->pSwatchVEnd)[index]);
                if (!EV_GUARD_ATTR(index)) {
                    continue;
                }
                CopyCurve(info, info->tempVBegin[index], (*quadInfo->pSwatchVBegin)[index]);
            }

            // call to draw regular grid for each small row
            {
                //cache a ptr to the global patch data inside the subpatch structure.
                if (info->evalEnables & (1 << ATTR_N)) {
                    info->swatchFlags |= NV_PATCH_HAS_NORMAL;
                };

                if (usingHW) {
                    if ((info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) && (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL)) {
                        ComputeKelvinHOSControlWords(info, quadInfoOrig, info->swatchFlags);
                    }
                }

                retVal |= DrawIntPatchGrid(info, quadInfo, &SS0[0]);
            }
        }

        if (needBV0) {
            // complete generation of any inner curves
            for (onRow = nSwatchV;  onRow < stitch_nSwatchV;  onRow++) {
                RetessCurveSetInOut(info, 0, info->evalEnables, &BV0, &SV0);
                OffsetCurveSet(info, info->evalEnables, &BV0, 1);
                CopyCurveSet(info, info->evalEnables, ppGuardSetVBegin[onRow], &SV0);
            }
        }

        // swap ptrs for next big column
        pTempMatrix = pBB0; pBB0 = pBB1; pBB1 = pTempMatrix;
    }

    if (quadInfoOrig->stitchVBegin) { // now done in U1 setup || (quadInfo->stitchVEnd && (info->evalEnables & ~EV_GUARD_BITS))) { // }
        // last set of curves from regular grid was not written
        // because the regular grid is multiple of swatch size
        int lEnables = info->evalEnables;

        if (quadInfo->stitchVEnd) {
            if (!usingHW) {
                lEnables = info->evalEnables;
            } else {
                lEnables = info->evalEnables & ~EV_GUARD_BITS;
            }
        }
        for (onCol = nSwatchU;  onCol < stitch_nSwatchU;  onCol++) {
            //ffCopyMatrixSet(info, lEnables, pBB1, pBB0);     // horz step BB0 to BB1
            //ffOffsetFDMatrixSet(info, lEnables, pBB1, 1, 0); // ...

            // cvt BB0 to BS0 (in place)
            pBS0 = pBB0;
            RetessMatrixSetU(info, 0, lEnables, pBS0);

            // prepare matrices for swatch row 0
            CopyMatrixSet(info, lEnables, &SS0, pBS0);
            RetessMatrixSetV(info, 0, lEnables, &SS0);

            if (quadInfoOrig->stitchVBegin) {
                OffsetFDMatrixSet(info, lEnables, &SS0, 0, 1);
                ExtractUCurveSet(info, lEnables, ppGuardSetUBegin[onCol], &SS0);
            } else {
                OffsetFDMatrixSet(info, lEnables, &SS0, 0, quadInfo->vMaxSegs-1);
                ExtractUCurveSet(info, lEnables, ppGuardSetUEnd[onCol], &SS0);
            }

            // swap ptrs for next big column
            //ffpTempMatrix = pBB0; pBB0 = pBB1; pBB1 = pTempMatrix;
        }
    }

    // but restore everything else
    quadInfo = quadInfoOrig;

    nvAssert((*ppGuardSetU0[0])[0]->order == (*ppGuardSetU1[0])[0]->order);
    nvAssert((*ppGuardSetV0[0])[0]->order == (*ppGuardSetV1[0])[0]->order);
    if (ppStitchUInner) {
        nvAssert((*ppGuardSetU0[0])[0]->order == (*ppStitchUInner[0])[0]->order);
    }
    if (ppStitchVInner) {
        nvAssert((*ppGuardSetV0[0])[0]->order == (*ppStitchVInner[0])[0]->order);
    }
    DrawAllPatchTransitions(info, quadInfo,
                                    ppGuardSetU0, ppGuardSetU1, ppStitchUInner, ppStitchUInnerFrac,
                                    ppGuardSetV0, ppGuardSetV1, ppStitchVInner, ppStitchVInnerFrac);

    if (usingHW && (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) && (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL)) {
        HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

        HOS_NOTE("End Patch");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_END_PATCH)));
        HOS_PUSH(1, 0x0);
        HOS_PUSH_ADJUST(2);
    }

drawIntPatchSwathsEnd:
    EV_FREE(ppGuardSetU0, info->context);
    EV_FREE(ppGuardSetU1, info->context);
    EV_FREE(ppGuardSetUInner, info->context);
    EV_FREE(ppGuardSetV0, info->context);
    EV_FREE(ppGuardSetV1, info->context);
    EV_FREE(ppGuardSetVInner, info->context);

    return retVal;
}

unsigned int
DrawIntPatch(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices)
{
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int index;
    int usingHW = info->usingHW;

    FDCurveAttrSet curves1, curves2;
    FDCurveAttrSet guardSetU0, guardSetU1, guardSetUInner;
    FDCurveAttrSet guardSetV0, guardSetV1, guardSetVInner;

    FDCurveAttrSet *ppGuardSetU0[1];  // pp to curves per attribute
    FDCurveAttrSet *ppGuardSetU1[1];  // [maxAttr][maxOrder][4]
    FDCurveAttrSet *ppGuardSetV0[1];  // ...
    FDCurveAttrSet *ppGuardSetV1[1];
    FDCurveAttrSet *ppGuardSetUInner[1];
    FDCurveAttrSet *ppGuardSetVInner[1];

    FDCurveAttrSet **ppGuardSetUBegin, **ppGuardSetUEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppGuardSetVBegin, **ppGuardSetVEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppStitchUInner = NULL, **ppStitchVInner = NULL; // inner curves for stitching

    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2;
    EV_ALLOC_DECL();
    int nBytes;
    int bytesGuardCurve = EV_ROUND(PATCH_CURVE_HEADER_SIZE + (info->maxOrder * 4) * sizeof(float));   // truncated NV_PATCH_CURVE_INFO
    int bytesGuardCurveAllAttr = info->nAttr * bytesGuardCurve;                 // just the set of curve info
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();


    ppGuardSetU0[0] = &guardSetU0;  // pp to curves per attribute
    ppGuardSetU1[0] = &guardSetU1;  // [maxAttr][maxOrder][4]
    ppGuardSetV0[0] = &guardSetV0;  // ...
    ppGuardSetV1[0] = &guardSetV1;
    ppGuardSetUInner[0] = &guardSetUInner;
    ppGuardSetVInner[0] = &guardSetVInner;

    if (!usingHW) {
        // Reverse the front face direction
        info->backend->setFrontFace(info, 1 ^ info->reverse);

    } else {
        if (!doFrac) {
            info->reverse = info->reverse ^ (quadInfo->uMaxDir ^ quadInfo->vMaxDir);
        }
        info->backend->setFrontFace(info, 1 ^ info->reverse);
    }

    NV_TRACE_CODE(nUniqueVertices = 0);
    nBytes = 0;
    if (!usingHW) {
        nBytes += 2 * sizeof(NV_PATCH_EVAL_OUTPUT);
        nBytes += info->nAttr * 2*bytesGuardCurve;
    }
    if (nBytes) {
        EV_ALLOC_INIT_WITH_CACHE(info->context, nBytes, drawIntPatchEnd, info->pCache[EV_CACHE_DRAW_SW]);
    }

    if (!usingHW) {
        // current output points. pOut1 for outer, pOut2 for inner
        EV_ALLOC(pOut1, info->context, sizeof(NV_PATCH_EVAL_OUTPUT));
        EV_ALLOC(pOut2, info->context, sizeof(NV_PATCH_EVAL_OUTPUT));
    }

    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1<<index))) {
            continue;
        }

        if (!usingHW) {
            EV_ALLOC(curves1[index], info->context, bytesGuardCurve);
            EV_ALLOC(curves2[index], info->context, bytesGuardCurve);
            curves1[index]->order = info->maps[index].uorder;
            curves2[index]->order = info->maps[index].uorder;
        }

        if (info->swatchFlags & NV_PATCH_SWATCH) {
            continue;
        }

        guardSetU0[index]     = quadInfo->pU0[index];
        guardSetU1[index]     = quadInfo->pU1[index];
        guardSetUInner[index] = quadInfo->pUInner[index];
        guardSetV0[index]     = quadInfo->pV0[index];
        guardSetV1[index]     = quadInfo->pV1[index];
        guardSetVInner[index] = quadInfo->pVInner[index];
    }
    if (nBytes) {
        EV_ALLOC_FULL(info->context);
    }

    /*****************************************************************************/
    // This code is analogous to code in DrawIntPatchSwaths() to calc ppGuardXXX
    // BEGIN SIMILAR CODE
    if (quadInfo->vMaxDir == 1) {
        if (quadInfo->stitchTop) {
            ppGuardSetUBegin = ppGuardSetU0;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
        } else if (quadInfo->stitchBottom) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
            ppGuardSetUEnd = ppGuardSetU1;
        } else {
            ppGuardSetUBegin = ppGuardSetU0;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU1;
        }
    } else {
        if (quadInfo->stitchTop) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
            ppGuardSetUEnd = ppGuardSetU0;
        } else if (quadInfo->stitchBottom) {
            ppGuardSetUBegin = ppGuardSetU1;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
        } else {
            ppGuardSetUBegin = ppGuardSetU1;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU0;
        }
    }

    if (quadInfo->uMaxDir == 1) {
        if (quadInfo->stitchRight) {
            ppGuardSetVBegin = ppGuardSetV0;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
        } else if (quadInfo->stitchLeft) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
            ppGuardSetVEnd = ppGuardSetV1;
        } else {
            ppGuardSetVBegin = ppGuardSetV0;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV1;
        }
    } else {
        if (quadInfo->stitchRight) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
            ppGuardSetVEnd = ppGuardSetV0;
        } else if (quadInfo->stitchLeft) {
            ppGuardSetVBegin = ppGuardSetV1;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
        } else {
            ppGuardSetVBegin = ppGuardSetV1;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV0;
        }
    }
    if (doFrac) {
        ppGuardSetUEnd = /*ppGuardSetUInnerFrac =*/ info->ppGuardSetUInnerFrac;
        ppGuardSetVEnd = /*ppGuardSetVInnerFrac =*/ info->ppGuardSetVInnerFrac;
    }
    // END SIMILAR CODE

    quadInfo->pCurvesTop = &curves1;
    quadInfo->pCurvesBot = &curves2;
    quadInfo->pOut1 = pOut1;
    quadInfo->pOut2 = pOut2;

    info->setGridCorner = NV_PATCH_SET_GRID_CORNER_ALL;

    if (info->swatchFlags & NV_PATCH_SWATCH) {
        retVal |= DrawIntPatchSwaths(info, quadInfo, matrices);

    } else {
        // set up ptrs for writing U curves from matrix
        quadInfo->pSwatchUBegin = ppGuardSetUBegin[0];
        quadInfo->pSwatchUEnd = ppGuardSetUEnd[0];
        quadInfo->pSwatchVBegin = ppGuardSetVBegin[0];
        quadInfo->pSwatchVEnd = ppGuardSetVEnd[0];

        evalPrepareInnerCurves(info, 0, matrices);      // prepare the UInner and VInner curves

        for (index = 0; index < info->maxAttr; index++) {
            if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                continue;
            }
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            info->pSwatchCorner[index][0][0] = info->gridCorner[index][1-quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
            FillIntCornerLL(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][0][0]);

            info->pSwatchCorner[index][0][1] = info->gridCorner[index][1-quadInfo->vMaxDir][   quadInfo->uMaxDir];
            FillIntCornerLR(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][0][1]);

            info->pSwatchCorner[index][1][0] = info->gridCorner[index][  quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
            FillIntCornerUL(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][1][0]);

            info->pSwatchCorner[index][1][1] = info->gridCorner[index][  quadInfo->vMaxDir][   quadInfo->uMaxDir];
            FillIntCornerUR(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][1][1]);

            // Copy U and V guard curves
            // note: be sure to do after Fill*() routines in case pSwatchV* curves are tweaked.
            CopyCurve(info, info->tempVBegin[index], (*quadInfo->pSwatchVBegin)[index]);
            CopyCurve(info, info->tempVEnd[index], (*quadInfo->pSwatchVEnd)[index]);
        }

        if (info->evalEnables & (1 << ATTR_N)) {
            info->swatchFlags |= NV_PATCH_HAS_NORMAL;
        };

        if (usingHW) {
            //calculate and send the Patch control words
            ComputeKelvinHOSControlWords(info, quadInfo, info->swatchFlags);
        }

        quadInfo->uMaxSegs -= doFrac;
        quadInfo->vMaxSegs -= doFrac;
        retVal |= DrawIntPatchGrid(info, quadInfo, matrices);
        quadInfo->uMaxSegs += doFrac;
        quadInfo->vMaxSegs += doFrac;

        DrawAllPatchTransitions(info, quadInfo,
                            ppGuardSetU0, ppGuardSetU1, ppStitchUInner, info->ppGuardSetUInnerFrac,
                            ppGuardSetV0, ppGuardSetV1, ppStitchVInner, info->ppGuardSetVInnerFrac);

        if (usingHW) {
            //end patch
            HOS_NOTE("End Patch");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_END_PATCH)));
            HOS_PUSH(1, 0x0);
            HOS_PUSH_ADJUST(2);
        }
    }

#if defined(ENABLE_DEBUG_SWATH)
    if (!usingHW && nvDebugLevel >= 3 && (evalTrace & 2)) {
        // when all done with regular grid, draw green X through regular grid corners
        float *pGridLL = info->gridCorner[ATTR_V][1-quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
        float *pGridLR = info->gridCorner[ATTR_V][1-quadInfo->vMaxDir][   quadInfo->uMaxDir];
        float *pGridUL = info->gridCorner[ATTR_V][  quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
        float *pGridUR = info->gridCorner[ATTR_V][  quadInfo->vMaxDir][   quadInfo->uMaxDir];

        glDisable(GL_TEXTURE_2D);
        glPushMatrix();

        // and green X through gridCorner points
        glTranslatef(0, 0, .2);
        glColor3f(0, 1, 0);
        glEnable(GL_LINE_STIPPLE);
        glLineStipple(1, 0xFF00);
        glBegin(GL_LINE_STRIP);
            glVertex3fv(pGridLL); glVertex3fv(pGridLR);
            glVertex3fv(pGridUL); glVertex3fv(pGridUR);
            glVertex3fv(pGridLL);
        glEnd();
        glDisable(GL_LINE_STIPPLE);

        glPopMatrix();
        glColor3f(1, 1, 0);
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif


drawIntPatchEnd:
    if (!usingHW) {
        EV_FREE(pOut1, info->context);
        EV_FREE(pOut2, info->context);
    }

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            if (!usingHW) {
                EV_FREE(curves1[index], info->context);
                EV_FREE(curves2[index], info->context);
            }
        }
    }
    NV_TRACE_CODE( if (enableUniqueCheck && !usingHW  &&  (nvDebugLevel >= 2)) {
        int A = quadInfo->nu0;
        int B = quadInfo->nv0;
        int C = quadInfo->nu1;
        int D = quadInfo->nv1;
        int maxac = MAX(A,C);
        int maxbd = MAX(B,D);
        int minac = MIN(A,C);
        int minbd = MIN(B,D);
        int expect = MAX(A,C) * MAX(B,D) + MIN(A,C) + MIN(B,D) + 1;
        int expectedTris = (maxac-1)*(maxbd-1)*2+minbd+maxbd-1+minac+maxac-1;

        if (doFrac) {
            expect = quadInfo->uMaxSegs * quadInfo->vMaxSegs + quadInfo->uMinSegs + quadInfo->vMinSegs + 1;
            expectedTris = (quadInfo->uMaxSegs-1)*(quadInfo->vMaxSegs-1)
                                +quadInfo->uMinSegs+quadInfo->uMinSegs-1
                                +quadInfo->vMinSegs+quadInfo->vMinSegs-1;
        }
        nvAssert((nvDebugLevel & 1) || expect == nUniqueVertices);
        TPRINTF(("nUniqueVertices=%d    expectV=%d expectTri=%d\n",
                 nUniqueVertices, expect, expectedTris));
        if (expect != nUniqueVertices) {
            drawUniqueVertices();
        }
    } );
    NV_TRACE_COND(TR_EVAL, 20,
        TPRINTF(("nu0=%d nu1=%d nv0=%d nv1=%d maxU=%d maxV=%d minU=%d minV=%d\n",
                quadInfo->nu0, quadInfo->nu1, quadInfo->nv0, quadInfo->nv1,
                quadInfo->uMaxSegs, quadInfo->vMaxSegs, quadInfo->uMinSegs, quadInfo->vMinSegs));
        TPRINTF(("dir BTLR=[%d %d %d %d]  uMaxDir=%d vMaxDir=%d\n",
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->uMaxDir, quadInfo->vMaxDir));
        TPRINTF(("  stitch BTLR=[%d %d %d %d]  stitch UBE=[%d %d] VBE=[%d %d]\n",
                quadInfo->stitchBottom, quadInfo->stitchTop, quadInfo->stitchLeft, quadInfo->stitchRight,
                quadInfo->stitchUBegin, quadInfo->stitchUEnd, quadInfo->stitchVBegin, quadInfo->stitchVEnd ));
        TPRINTF(("force rev bits=%d %d %d %d  info->flags=x%X\n",
                (nvDebugOptions & TRO_TEMP1) != 0,
                (nvDebugOptions & TRO_TEMP2) != 0,
                (nvDebugOptions & TRO_TEMP3) != 0,
                (nvDebugOptions & TRO_TEMP4) != 0,
                info->flags));
        if (info->flipT && info->flipU && info->flipV) {
            TPRINTF(("\n\n***** transpose/flip alert %d <--> %d\n\n", quadInfo->nu1, quadInfo->nv1));
            TPRINTF(("***** flipU=%d flipV=%d\n", info->flipU, info->flipV));
        }
    );
    return retVal;
}

// Determine if a patch is rational (i.e. w != 1)
static int IsPatchRational(NV_PATCH_INFO *info, int attrib)
{
    NV_PATCH_MAP_INFO *map = &info->maps[attrib];
    unsigned int i, j;

/*    switch (type) {
    case NV_PATCH_VERTEX_FORMAT_FLOAT_4:*/
        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
            for (j = 0; j < map->vorder; j++) {
                for (i = 0; i < map->uorder - j; i++) {
                    if (map->rawData[4*(j*map->uorder + i) + 3] != 1.0f) {
                        return 1;
                    }
                }
            }
        } else {
            for (j = 0; j < map->vorder; j++) {
                for (i = 0; i < map->uorder; i++) {
                    if (map->rawData[4*(j*map->uorder + i) + 3] != 1.0f) {
                        return 1;
                    }
                }
            }
        }
/*        break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
    case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
    case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
        break;  // fall through we are guaranteed non-rational by our expansion methods
    default:
        nvAssert(0);
    }
*/
    return 0;
}

static float BinomialCoefficient(int n, int r)
{
    float x;
    if (n<=10 && r <= 10) {
        x = cachedBinomialCoefficients[n][r];
    }
    else {
        int i;
        x = 1.0f;
        for (i = 2; i <= n; i++) {
            x *= i;
        }
        for (i = 2; i <= r; i++) {
            x /= i;
        }
        for (i = 2; i <= n-r; i++) {
            x /= i;
        }
    }

    return x;
}

static float TrinomialCoefficient(int n, int r, float s)
{
    float x = 1.0f;
    int i;

    for (i = 2; i <= n; i++) {
        x *= i;
    }
    for (i = 2; i <= r; i++) {
        x /= i;
    }
    for (i = 2; i <= s; i++) {
        x /= i;
    }
    for (i = 2; i <= n-r-s; i++) {
        x /= i;
    }
    return x;
}

static void ComputeNormalPatch(NV_PATCH_INFO *info, float *normalPatch,
                                int uorder, int vorder, int rational)
{
    NV_PATCH_MAP_INFO *map = &info->maps[info->srcNormal];
    float *rawData = map->rawData;
    int pitch = map->pitch;
    int ufStride = 4;
    int vfStride = 4 * map->pitch;
    int i, j;
    FDMatrix *derivU, *derivV, *derivUTemp = NULL, *derivVTemp = NULL;
    FDMatrix *temp[6], *pFDMatrix;
    int normalUOrder, normalVOrder;
    int uRow, uCol, vRow, vCol;
    EV_ALLOC_DECL();

    EV_ALLOC_INIT_WITH_CACHE(info->context, 8 * sizeof(FDMatrix), computeNormalPatchEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(derivU, info->context, sizeof(FDMatrix));
    EV_ALLOC(derivV, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[2], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[3], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[4], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[5], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

    if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
        if (rational) {
            normalUOrder = normalVOrder = 4*uorder - 5;
        } else {
            normalUOrder = normalVOrder = 2*uorder - 3;
        }

        // Compute derivatives in u
        derivU->columns = uorder-1;
        derivU->rows = uorder-1;
        for (j = 0; j < uorder-1; j++) {
            FillColumnVectorMatrix(uorder-j, ufStride*sizeof(float), pRawData(info, map, rawData, j, 0), temp[0], 0);
            for (i = 0; i < uorder-1-j; i++) {
                derivU->data[j][i][0] = temp[0]->data[i+1][0][0] - temp[0]->data[i][0][0];
                derivU->data[j][i][1] = temp[0]->data[i+1][0][1] - temp[0]->data[i][0][1];
                derivU->data[j][i][2] = temp[0]->data[i+1][0][2] - temp[0]->data[i][0][2];
                derivU->data[j][i][3] = temp[0]->data[i+1][0][3] - temp[0]->data[i][0][3];
            }
        }

        // Compute derivatives in v
        derivV->columns = uorder-1;
        derivV->rows = uorder-1;
        for (i = 0; i < uorder; i++) {
            FillColumnVectorMatrix(uorder-i, vfStride * sizeof(float), pRawData(info, map, rawData, 0, i), temp[0], 0);
            for (j = 0; j < uorder-1-i; j++) {
                derivV->data[j][i][0] = temp[0]->data[j+1][0][0] - temp[0]->data[j][0][0];
                derivV->data[j][i][1] = temp[0]->data[j+1][0][1] - temp[0]->data[j][0][1];
                derivV->data[j][i][2] = temp[0]->data[j+1][0][2] - temp[0]->data[j][0][2];
                derivV->data[j][i][3] = temp[0]->data[j+1][0][3] - temp[0]->data[j][0][3];
            }
        }

        if (rational) {
            int derivRow, derivCol, vertRow, vertCol;

            // This code makes the assumption that type == NV_PATCH_VERTEX_FORMAT_FLOAT_4.
            // Seeing as the patch is rational, this is probably safe, unless people start
            // using unsigned byte types for rational patches.

            derivUTemp = temp[2];
            derivVTemp = temp[3];

            // Initialize matrices
            derivUTemp->columns = 2*uorder - 2;
            derivUTemp->rows    = 2*uorder - 2;
            derivVTemp->columns = 2*uorder - 2;
            derivVTemp->rows    = 2*uorder - 2;
            for (derivRow = 0; derivRow < derivUTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivUTemp->columns; derivCol++) {
                    derivUTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }
            for (derivRow = 0; derivRow < derivVTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivVTemp->columns; derivCol++) {
                    derivVTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }

            // derivU <-- derivU.xyz * vertices.w - derivU.w * vertices.xyz
            for (derivRow = 0; derivRow < derivU->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivU->columns-derivRow; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivU->data[derivRow][derivCol][0];
                    derivPoint[1] = derivU->data[derivRow][derivCol][1];
                    derivPoint[2] = derivU->data[derivRow][derivCol][2];
                    derivPoint[3] = derivU->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder-vertRow; vertCol++) {
                            float vert[4], *result;
                            float factor;

                            vert[0] = rawData[4*(vertRow*pitch + vertCol) + 0];
                            vert[1] = rawData[4*(vertRow*pitch + vertCol) + 1];
                            vert[2] = rawData[4*(vertRow*pitch + vertCol) + 2];
                            vert[3] = rawData[4*(vertRow*pitch + vertCol) + 3];

                            factor  = TrinomialCoefficient(derivU->rows-1, derivRow, derivCol);
                            factor *= TrinomialCoefficient(uorder-1, vertRow, vertCol);
                            factor /= TrinomialCoefficient(derivU->rows+uorder-2, derivRow+vertRow, derivCol+vertCol);

                            result = &derivUTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            // derivV <-- derivV.xyz * vertices.w - derivV.w * vertices.xyz
            for (derivRow = 0; derivRow < derivV->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivV->columns-derivRow; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivV->data[derivRow][derivCol][0];
                    derivPoint[1] = derivV->data[derivRow][derivCol][1];
                    derivPoint[2] = derivV->data[derivRow][derivCol][2];
                    derivPoint[3] = derivV->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder-vertRow; vertCol++) {
                            float vert[4], *result;
                            float factor;

                            vert[0] = rawData[4*(vertRow*pitch + vertCol) + 0];
                            vert[1] = rawData[4*(vertRow*pitch + vertCol) + 1];
                            vert[2] = rawData[4*(vertRow*pitch + vertCol) + 2];
                            vert[3] = rawData[4*(vertRow*pitch + vertCol) + 3];

                            factor  = TrinomialCoefficient(derivV->rows-1, derivRow, derivCol);
                            factor *= TrinomialCoefficient(uorder-1, vertRow, vertCol);
                            factor /= TrinomialCoefficient(derivV->rows+uorder-2, derivRow+vertRow, derivCol+vertCol);

                            result = &derivVTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            EV_SWAP(derivU, temp[2], pFDMatrix);
            EV_SWAP(derivV, temp[3], pFDMatrix);
        }

        for (uRow = 0; uRow < derivU->rows; uRow++) {
            for (uCol = 0; uCol < derivU->columns-uRow; uCol++) {
                float uPoint[3];

                uPoint[0] = derivU->data[uRow][uCol][0];
                uPoint[1] = derivU->data[uRow][uCol][1];
                uPoint[2] = derivU->data[uRow][uCol][2];

                for (vRow = 0; vRow < derivV->rows; vRow++) {
                    for (vCol = 0; vCol < derivV->columns-vRow; vCol++) {
                        float vPoint[3];
                        int normalIndex = 4*(normalUOrder*(uRow+vRow) + uCol + vCol);
                        float factor;

                        vPoint[0] = derivV->data[vRow][vCol][0];
                        vPoint[1] = derivV->data[vRow][vCol][1];
                        vPoint[2] = derivV->data[vRow][vCol][2];

                        factor  = TrinomialCoefficient(derivU->rows-1, uRow, uCol);
                        factor *= TrinomialCoefficient(derivV->rows-1, vRow, vCol);
                        factor /= TrinomialCoefficient(derivU->rows+derivV->rows-2, uRow+vRow, uCol+vCol);

                        // Accumulate x: uy*vz - uz*vy
                        normalPatch[normalIndex + 0] += factor*(uPoint[1]*vPoint[2] - uPoint[2]*vPoint[1]);
                        // Accumulate y: uz*vx - ux*vz
                        normalPatch[normalIndex + 1] += factor*(uPoint[2]*vPoint[0] - uPoint[0]*vPoint[2]);
                        // Accumulate z: ux*vy - uy*vx
                        normalPatch[normalIndex + 2] += factor*(uPoint[0]*vPoint[1] - uPoint[1]*vPoint[0]);
                    }
                }
            }
        }
    } else {
        if (rational) {
            normalUOrder = 4*uorder - 4;
            normalVOrder = 4*vorder - 4;
        } else {
            normalUOrder = 2*uorder - 2;
            normalVOrder = 2*vorder - 2;
        }

        // Compute derivatives in u
        derivU->columns = uorder-1;
        derivU->rows = vorder;
        for (j = 0; j < vorder; j++) {
            FillColumnVectorMatrix(uorder, ufStride*sizeof(float), pRawData(info, map, rawData, j, 0), temp[0], 0);
            for (i = 0; i < uorder-1; i++) {
                derivU->data[j][i][0] = temp[0]->data[i+1][0][0] - temp[0]->data[i][0][0];
                derivU->data[j][i][1] = temp[0]->data[i+1][0][1] - temp[0]->data[i][0][1];
                derivU->data[j][i][2] = temp[0]->data[i+1][0][2] - temp[0]->data[i][0][2];
                derivU->data[j][i][3] = temp[0]->data[i+1][0][3] - temp[0]->data[i][0][3];
            }
        }

        // Compute derivatives in v
        derivV->columns = uorder;
        derivV->rows = vorder-1;
        for (i = 0; i < uorder; i++) {
            FillColumnVectorMatrix(vorder, vfStride * sizeof(float), pRawData(info, map, rawData, 0, i), temp[0], 0);
            for (j = 0; j < vorder-1; j++) {
                derivV->data[j][i][0] = temp[0]->data[j+1][0][0] - temp[0]->data[j][0][0];
                derivV->data[j][i][1] = temp[0]->data[j+1][0][1] - temp[0]->data[j][0][1];
                derivV->data[j][i][2] = temp[0]->data[j+1][0][2] - temp[0]->data[j][0][2];
                derivV->data[j][i][3] = temp[0]->data[j+1][0][3] - temp[0]->data[j][0][3];
            }
        }

        if (rational) {
            int derivRow, derivCol, vertRow, vertCol;

            // This code makes the assumption that type == NV_PATCH_VERTEX_FORMAT_FLOAT_4.
            // Seeing as the patch is rational, this is probably safe, unless people start
            // using unsigned byte types for rational patches.

            derivUTemp = temp[4];
            derivVTemp = temp[5];

            // Initialize matrices
            derivUTemp->columns = 2*uorder - 2;
            derivUTemp->rows    = 2*vorder - 1;
            derivVTemp->columns = 2*uorder - 1;
            derivVTemp->rows    = 2*vorder - 2;
            for (derivRow = 0; derivRow < derivUTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivUTemp->columns; derivCol++) {
                    derivUTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }
            for (derivRow = 0; derivRow < derivVTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivVTemp->columns; derivCol++) {
                    derivVTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }

            // derivU <-- derivU.xyz * vertices.w - derivU.w * vertices.xyz
            for (derivRow = 0; derivRow < derivU->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivU->columns; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivU->data[derivRow][derivCol][0];
                    derivPoint[1] = derivU->data[derivRow][derivCol][1];
                    derivPoint[2] = derivU->data[derivRow][derivCol][2];
                    derivPoint[3] = derivU->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder; vertCol++) {
                            float vert[4], *result;
                            float factor;
                            int idx;
                            idx = 4*(vertRow*pitch + vertCol);
                            vert[0] = rawData[idx + 0];
                            vert[1] = rawData[idx + 1];
                            vert[2] = rawData[idx + 2];
                            vert[3] = rawData[idx + 3];

                            factor  = BinomialCoefficient(derivU->rows-1, derivRow);
                            factor /= BinomialCoefficient(derivU->rows+vorder-2, derivRow+vertRow);
                            factor *= BinomialCoefficient(derivU->columns-1, derivCol);
                            factor *= BinomialCoefficient(vorder-1, vertRow);
                            factor /= BinomialCoefficient(derivU->columns+uorder-2, derivCol+vertCol);
                            factor *= BinomialCoefficient(uorder-1, vertCol);

                            result = &derivUTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            // derivV <-- derivV.xyz * vertices.w - derivV.w * vertices.xyz
            for (derivRow = 0; derivRow < derivV->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivV->columns; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivV->data[derivRow][derivCol][0];
                    derivPoint[1] = derivV->data[derivRow][derivCol][1];
                    derivPoint[2] = derivV->data[derivRow][derivCol][2];
                    derivPoint[3] = derivV->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder; vertCol++) {
                            float vert[4], *result;
                            float factor;

                            vert[0] = rawData[4*(vertRow*pitch + vertCol) + 0];
                            vert[1] = rawData[4*(vertRow*pitch + vertCol) + 1];
                            vert[2] = rawData[4*(vertRow*pitch + vertCol) + 2];
                            vert[3] = rawData[4*(vertRow*pitch + vertCol) + 3];

                            factor  = BinomialCoefficient(derivV->rows-1, derivRow);
                            factor *= BinomialCoefficient(derivV->columns-1, derivCol);
                            factor *= BinomialCoefficient(vorder-1, vertRow);
                            factor *= BinomialCoefficient(uorder-1, vertCol);
                            factor /= BinomialCoefficient(derivV->rows+vorder-2, derivRow+vertRow);
                            factor /= BinomialCoefficient(derivV->columns+uorder-2, derivCol+vertCol);

                            result = &derivVTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            EV_SWAP(derivU, temp[4], pFDMatrix);
            EV_SWAP(derivV, temp[5], pFDMatrix);
        }

        for (uRow = 0; uRow < derivU->rows; uRow++) {
            for (uCol = 0; uCol < derivU->columns; uCol++) {
                float uPoint[3];

                uPoint[0] = derivU->data[uRow][uCol][0];
                uPoint[1] = derivU->data[uRow][uCol][1];
                uPoint[2] = derivU->data[uRow][uCol][2];

                for (vRow = 0; vRow < derivV->rows; vRow++) {
                    for (vCol = 0; vCol < derivV->columns; vCol++) {
                        float vPoint[3];
                        int normalIndex = 4*(normalUOrder*(uRow+vRow) + uCol+vCol);
                        float factor;

                        vPoint[0] = derivV->data[vRow][vCol][0];
                        vPoint[1] = derivV->data[vRow][vCol][1];
                        vPoint[2] = derivV->data[vRow][vCol][2];

                        factor  = BinomialCoefficient(derivU->rows-1, uRow);
                        factor *= BinomialCoefficient(derivV->rows-1, vRow);
                        factor *= BinomialCoefficient(derivU->columns-1, uCol);
                        factor *= BinomialCoefficient(derivV->columns-1, vCol);
                        factor /= BinomialCoefficient(derivU->rows+derivV->rows-2, uRow+vRow);
                        factor /= BinomialCoefficient(derivU->columns+derivV->columns-2, uCol+vCol);

                        // Accumulate x: uy*vz - uz*vy
                        normalPatch[normalIndex + 0] += factor*(uPoint[1]*vPoint[2] - uPoint[2]*vPoint[1]);

                        // Accumulate y: uz*vx - ux*vz
                        normalPatch[normalIndex + 1] += factor*(uPoint[2]*vPoint[0] - uPoint[0]*vPoint[2]);

                        // Accumulate z: ux*vy - uy*vx
                        normalPatch[normalIndex + 2] += factor*(uPoint[0]*vPoint[1] - uPoint[1]*vPoint[0]);
                    }
                }
            }
        }
    }

computeNormalPatchEnd:
    EV_FREE(derivU, info->context);
    EV_FREE(derivU, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
    EV_FREE(temp[2], info->context);
    EV_FREE(temp[3], info->context);
    EV_FREE(temp[4], info->context);
    EV_FREE(temp[5], info->context);
}

const static struct {
    int uSide;
    int vSide;
    int uDir;
    int vDir;
    int reverse;
    int centerCurve;
} TriPatchLayout[3] = {
    { 0, 2, 0, 1, 0, 0 },
    { 0, 1, 1, 0, 1, 1 },
    { 1, 2, 1, 0, 1, 1 },
};

// Compute the step size and number of segments in fractional tessellation
void ComputeFracStepInfo(float steps, float *du, int *segs)
{
    *du = 1.0f / steps;
    if (segs) {
        *segs = (int)(steps/2.0f + 0.999f);
    }
}

/*****************************************************************************/
// needs adjustment for 64-bit machines
#define SIZEOF_NV_PATCH_QUAD_INFO EV_ROUND(sizeof(NV_PATCH_QUAD_INFO))

int nvAllocInfoScratch(NV_PATCH_INFO *info)
{
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int attr, bytes;
    EV_ALLOC_DECL();

    bytes = info->nAttr * (sizeof(FDMatrix) + 2*info->bytesGuardCurve);

    if (doFrac) {
        bytes += info->nAttr * (2*info->bytesGuardCurve);
    }

    EV_ALLOC_INIT_WITH_CACHE(info->context, bytes, nvAllocInfoScratchEnd, info->pCache[EV_CACHE_INFO_SCRATCH]);
    info->pScratchBase = evMemory.pBase;

    for (attr = 0; attr < info->maxAttr; attr++) {
        if (!(info->evalEnables & (1 << attr))) {
            continue;
        }

        EV_ALLOC(info->ppMatrixSetSS0[attr], info->context, sizeof(FDMatrix));

        // for guard curves at begin or end of matrix stepping
        EV_ALLOC(info->tempVBegin[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(info->tempVEnd[attr], info->context, info->bytesGuardCurve);

        if (doFrac) {
            EV_ALLOC(info->guardSetUInnerFrac[attr], info->context, info->bytesGuardCurve);
            EV_ALLOC(info->guardSetVInnerFrac[attr], info->context, info->bytesGuardCurve);
            continue;
        }
    }
    EV_ALLOC_FULL(info->context);

    info->ppGuardSetUInnerFrac1[0] = &info->guardSetUInnerFrac;
    info->ppGuardSetVInnerFrac1[0] = &info->guardSetVInnerFrac;

    info->ppGuardSetUInnerFrac = &info->ppGuardSetUInnerFrac1[0];
    info->ppGuardSetVInnerFrac = &info->ppGuardSetVInnerFrac1[0];

nvAllocInfoScratchEnd:
    return retVal;
}

// alloc FDMatrices and other things for imm mode rendering
int nvAllocFDMatricesEtc(NV_PATCH_INFO *info)
{
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int attr, matrixBytes, totalBytes;
    NV_PATCH_QUAD_INFO *quadInfo;
    EV_ALLOC_DECL();

    // all styles need quadInfo
    totalBytes = SIZEOF_NV_PATCH_QUAD_INFO;

    if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
            matrixBytes = 3*sizeof(FDMatrix) + sizeof(NV_PATCH_FRAC_TRI_GUARD_INFO);
        } else {
            matrixBytes = 4*sizeof(FDMatrix) + sizeof(NV_PATCH_FRAC_QUAD_GUARD_INFO);
        }
    } else {
        matrixBytes = 1*sizeof(FDMatrix);
        totalBytes += 4 * info->bytesGuardCurve * info->nAttr;
    }
    matrixBytes = EV_ROUND(matrixBytes);

    // always alloc Inner guard curves
    totalBytes += 2 * info->bytesGuardCurve * info->nAttr;

    // all styles need matrices and guardInfo
    totalBytes += matrixBytes * info->nAttr;

    EV_ALLOC_INIT_WITH_CACHE(info->context, totalBytes, nvAllocFDMatricesEnd, info->pCache[EV_CACHE_QUADINFO_ETC]);

    //THIS MUST ALWAYS BE THE FIRST ALLOCATION FROM THIS GROUP!!!!!!!!!
    EV_ALLOC(info->quadInfo, info->context, SIZEOF_NV_PATCH_QUAD_INFO);
    quadInfo = info->quadInfo;

    for (attr = 0; attr < info->maxAttr; attr++) {
        if (!(info->evalEnables & (1 << attr))) {
            continue;
        }

        quadInfo->m00[attr] = quadInfo->m01[attr] = quadInfo->m10[attr] = quadInfo->m11[attr] = NULL;
        EV_ALLOC(quadInfo->m00[attr], info->context, matrixBytes);

        // alloc Inner for all cases
        EV_ALLOC(quadInfo->pUInner[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pVInner[attr], info->context, info->bytesGuardCurve);

        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            quadInfo->m01[attr] = &quadInfo->m00[attr][1];
            quadInfo->m10[attr] = &quadInfo->m00[attr][2];
            if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
                quadInfo->guardTF[attr] = (NV_PATCH_FRAC_TRI_GUARD_INFO *)&quadInfo->m00[attr][3];
            } else {
                quadInfo->m11[attr] = &quadInfo->m00[attr][3];
                quadInfo->guardQF[attr] = (NV_PATCH_FRAC_QUAD_GUARD_INFO *)&quadInfo->m00[attr][4];
            }
            continue;
        }

        // INT cases
        EV_ALLOC(quadInfo->pU0[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pU1[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pV0[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pV1[attr], info->context, info->bytesGuardCurve);

        quadInfo->pCorners[attr][0][0] = quadInfo->cornAttr[attr].corners[0][0];
        quadInfo->pCorners[attr][0][1] = quadInfo->cornAttr[attr].corners[0][1];
        quadInfo->pCorners[attr][1][0] = quadInfo->cornAttr[attr].corners[1][0];
        quadInfo->pCorners[attr][1][1] = quadInfo->cornAttr[attr].corners[1][1];
    }
    EV_ALLOC_FULL(info->context);

nvAllocFDMatricesEnd:
    return retVal;
}

/*****************************************************************************/
//int bFirstTimeInit = 0x1;              //global value to indicate if we've built dynamic inner loops yet or not.
float fracFudge = .01f;
unsigned int nvEvalPatchSetup(NV_PATCH_INFO *info)
{
    int ii;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    float *normalPatch = NULL;
    float *UVPatch = NULL;
    float segmin = 1.f;
    EV_ALLOC_DECL();
    static int onceOnlyDone = 0;

    EV_DRAW(onColor = 0);
    if (g_FDGlobalData.bFirstTimeInit) {
        nvPatchInitFD(info);
        g_FDGlobalData.bFirstTimeInit = 0;
    }    

    info->reverse = 0;
    info->usingHW = !g_FDGlobalData.bForceSoftware & (info->backendType == NV_PATCH_BACKEND_KELVIN ? 1 : 0); // identifies places that probably need code for HW version

    NV_TRACE_CODE(
        if (!info->usingHW) {
            nvControlOptions |= NCO_DID_SW;
        }
    );

    //INITIALIZE HERE BECAUSE Compute Normal Patch will read these.
    info->flipT = 0;
    info->flipU = 0;
    info->flipV = 0;
    info->flipTUV = 0;
    info->flipUV = 0;
    info->nAttr = 0;
    info->maxAttr = -1;
    info->maxOrder = 0;
    info->firstAttr = -1;

    if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
        // enforce minimums as required
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) { segmin = 2.f + fracFudge; }
        info->tess.tri.n1 = MAX(info->tess.tri.n1, segmin);
        info->tess.tri.n2 = MAX(info->tess.tri.n2, segmin);
        info->tess.tri.n3 = MAX(info->tess.tri.n3, segmin);

    } else {
        // enforce minimums as required
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            segmin = 2.f;
            if ((info->tess.tensor.nu0 == 2.f  &&  info->tess.tensor.nu1 == 2.f)
                    ||  (info->tess.tensor.nv0 == 2.f  &&  info->tess.tensor.nv1 == 2.f)) {
                segmin += fracFudge;
            }
        }
        info->tess.tensor.nu0 = MAX(info->tess.tensor.nu0, segmin);
        info->tess.tensor.nu1 = MAX(info->tess.tensor.nu1, segmin);
        info->tess.tensor.nv0 = MAX(info->tess.tensor.nv0, segmin);
        info->tess.tensor.nv1 = MAX(info->tess.tensor.nv1, segmin);
    }

    nvAssert(16 == NV_PATCH_NUMBER_OF_ATTRIBS); // fix all 16's if we hit this... fundamental assumption has changed
    NV_TRACE_CODE(nUniqueVertices = 0);

    // note: must use same value for HW & SW to use the same big<-->small matrices
    info->maxSwatch = NV_PATCH_KELVIN_SWATCH_SIZE;

#if defined(IS_OPENGL)
 #if defined(FREDS_DEBUG_CODE)
    NV_TRACE_CODE(if (nvDebugLevel & 1))
    {
        info->maxSwatch = 4;
    }
    //ffnvDebugMask |= TR_PUSHBUFFER;
    //ffnvDebugOptions &= ~(TRO_TEMP1 | TRO_TEMP2 | TRO_TEMP3 | TRO_TEMP4);
 #endif

    if (info->usingHW) {
        glBegin(GL_POINTS);     // perform validation for HW
        glEnd();
        info->backendType = NV_PATCH_BACKEND_KELVIN;
    }
#endif
    if (onceOnlyDone != info->maxSwatch) {
        evalFillRetessMatrices(info);
        onceOnlyDone = info->maxSwatch;     // note: setting after fill makes it thread safe
    }

//ff#ifdef DCR_SEMAPHORE
    if (info->usingHW) {info->backend->beginPatch(info);}
//ff#endif

    if (info->flags & NV_PATCH_FLAG_AUTO_NORMAL) {
        NV_PATCH_MAP_INFO *map;
        int uorder, vorder;
        int normalUOrder, normalVOrder;

        // init for ComputeNormalPatch
        map = &info->maps[info->srcNormal];
        uorder = map->uorder;
        vorder = map->vorder;
        map->ufStride = map->stride/sizeof(float);
        map->vfStride = map->ufStride * map->pitch;

        nvAssert(info->srcNormal >= 0 && info->srcNormal <= NV_PATCH_NUMBER_OF_ATTRIBS);
        nvAssert(info->dstNormal >= 0 && info->dstNormal <= NV_PATCH_NUMBER_OF_ATTRIBS);
        if (info->maps[info->srcNormal].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
            info->rational = IsPatchRational(info, info->srcNormal);
        }

        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
            if (info->rational) {
                normalUOrder = normalVOrder = 4*uorder - 5;
            } else {
                normalUOrder = normalVOrder = 2*uorder - 3;
            }
        } else {
            if (info->rational) {
                normalUOrder = 4*uorder - 4;
                normalVOrder = 4*vorder - 4;
            } else {
                normalUOrder = 2*uorder - 2;
                normalVOrder = 2*vorder - 2;
            }
        }

        // If control points are dirty, recalculate the actual normal patch
        if (info->maps[info->srcNormal].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
            int bytes;

            //init some storage
            if (normalUOrder == 1) {
                //degree lifting -- HW doesn't allow for a order1/degree0/constant function in the FD unit,
                //so allocate extra space here so I can lift it to linear later
                bytes = 4*(normalUOrder+1)*(normalVOrder+1)*sizeof(float);
            } else {
                bytes = 4*normalUOrder*normalVOrder*sizeof(float);
            }
            EV_ALLOC_INIT_WITH_CACHE(info->context, bytes, nvPatchSetupEnd, info->pCache[EV_CACHE_AUTO_NORMAL_SETUP]);
            EV_ALLOC(info->normalPatch, info->context, bytes);
            normalPatch = info->normalPatch;
            for (ii = 0; ii < 4*normalUOrder*normalVOrder; ii++) {
                if ((ii & 3) != 3) {
                    normalPatch[ii] = 0.0f;
                } else {
                    normalPatch[ii] = 1.0f;
                }
            }

            // XXXmjc We aren't handling constant position in one direction properly yet
            nvAssert(uorder > 1);
            nvAssert(vorder > 1);
            ComputeNormalPatch(info, normalPatch, uorder, vorder, info->rational); //type passed here is the data src type
            if (normalUOrder == 1) {
                float pt[4];
                //degree lifting -- HW doesn't allow for a order1/degree0/constant function in the FD unit,
                //expand the normal patch data here.
                pt[0] = normalPatch[0]; pt[1] = normalPatch[1]; pt[2] = normalPatch[2];
                for (ii=4; ii < 12; ii+=4) {
                    normalPatch[ii+0] = pt[0];
                    normalPatch[ii+1] = pt[1];
                    normalPatch[ii+2] = pt[2];
                    normalPatch[ii+3] = 1.f;
                }
            }
        }

        if (normalUOrder == 1) {
            //if the order is actually 1 then bump it up one because I lifted the degree
            //when the control pts were dirty.
            normalUOrder++;
            normalVOrder++;
        }

        // Force evaluation of the normal
        info->evalEnables |= (1 << info->dstNormal);
        info->maps[info->dstNormal].uorder = normalUOrder;
        info->maps[info->dstNormal].vorder = normalVOrder;
        info->maps[info->dstNormal].rawData = normalPatch;
        info->maps[info->dstNormal].stride = 4*sizeof(float);
        info->maps[info->dstNormal].pitch  = normalUOrder;
    }

    if (info->flags & NV_PATCH_FLAG_AUTO_UV) {
        int order = 2;
        int bytes = 0;
        for (ii=0; ii < 8; ii++) {
            if (info->dstUV[ii] != 0xFFFFffff) {
                if (info->maps[info->dstUV[ii]].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                    if (bytes == 0) {
                        //if this is the first UV coord build patch data for it
                        bytes = 4*order*order*sizeof(float);
                        EV_ALLOC_INIT_WITH_CACHE2(info->context, bytes, nvPatchSetupEnd, info->pCache[EV_CACHE_UV_SETUP]);
                        EV_ALLOC(UVPatch , info->context, bytes);
                        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
                            // DO THIS BECAUSE THERE IS AN IMPLICIT MIRROR IN THE
                            // FORMATS OF D3D/OGL        D3D= 0      OGL=2
                            //                                |\         |\
                            //                                1-2        0-1
                            // texture coordinates need to be mirrored in y.
                            // likewise winding needs to be inverted
                            UVPatch[0] = info->endu;   UVPatch[1] = info->endv;     UVPatch[2] = 0.f;   UVPatch[3] = 1.f;
                            UVPatch[4] = info->startu; UVPatch[5] = info->endv;     UVPatch[6] = 0.f;   UVPatch[7] = 1.f;
                            UVPatch[8] = info->startu; UVPatch[9] = info->startv;   UVPatch[10] = 0.f;  UVPatch[11] = 1.f;
                            UVPatch[12] = 0x0;         UVPatch[13] = 0x0;           UVPatch[14] = 0.f;  UVPatch[15] = 1.f;
                        } else {
                            UVPatch[0] = info->startu; UVPatch[1] = info->startv;   UVPatch[2] = 0.f;   UVPatch[3] = 1.f;
                            UVPatch[4] = info->endu;   UVPatch[5] = info->startv;   UVPatch[6] = 0.f;   UVPatch[7] = 1.f;
                            UVPatch[8] = info->startu; UVPatch[9] = info->endv;     UVPatch[10] = 0.f;  UVPatch[11] = 1.f;
                            UVPatch[12] = info->endu;   UVPatch[13] = info->endv;   UVPatch[14] = 0.f;  UVPatch[15] = 1.f;
                        }
                    }
                    info->UVPatch = UVPatch;
                }

                // Force evaluation of the texturecoord
                info->evalEnables |= (1 << info->dstUV[ii]);
                info->maps[info->dstUV[ii]].uorder = info->maps[info->dstUV[ii]].vorder = order;
                info->maps[info->dstUV[ii]].rawData = UVPatch;
                info->maps[info->dstUV[ii]].stride = 4*sizeof(float);
                info->maps[info->dstUV[ii]].pitch = order;
            }
        }
    }

    // ensure some flags are initialized
    info->flags &= ~(NV_PATCH_FLAG_SOME_DIRTY_TESS | NV_PATCH_FLAG_TRANSPOSE
                        | NV_PATCH_FLAG_FLIPPED_U | NV_PATCH_FLAG_FLIPPED_V);
    for (ii = 0;  ii < NV_PATCH_NUMBER_OF_ATTRIBS;  ii++) {
        if (info->evalEnables & (1 << ii)) {
            NV_PATCH_MAP_INFO *map = &info->maps[ii];

            if (!(map->dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS)) {
                if (map->dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                    info->flags |= NV_PATCH_FLAG_SOME_DIRTY_TESS;
                }
            }

            map->ufStride = map->stride/sizeof(float);
            map->vfStride = map->ufStride * map->pitch;

            if (map->uorder == 1) {
                map->uorder = 2;
                map->ufStride = 0;
            }
            if (map->vorder == 1) {
                map->vorder = 2;
                map->vfStride = 0;
            }

            EV_DRAW( if (0  &&  !ii  &&  (nvDebugLevel >= 4)) {
                unsigned int row;
                unsigned int col;

                /* draw lines through all the control points */
                glColor3f(1, 0, 1);
                for (row = 0; row < map->vorder;  row++) {
                    glBegin(GL_LINE_STRIP);
                    for (col = 0;  col < map->uorder;  col++) {
                        glVertex3fv(pRawData(info, map, map->rawData, row, col));
                    }
                    glEnd();
                }
            } );

            // calc MAX values
            info->nAttr++;
            if (info->firstAttr == -1) {
                info->firstAttr = ii;
            }
            if (ii > info->maxAttr) {
                info->maxAttr = ii;
            }
            if (map->uorder > info->maxOrder) {
                info->maxOrder = map->uorder;
            }
            if (map->vorder > info->maxOrder) {
                info->maxOrder = map->vorder;
            }
        }
    }
    info->maxAttr = info->maxAttr + 1;

    info->bytesGuardCurve = EV_ROUND(PATCH_CURVE_HEADER_SIZE + (info->maxOrder * 4) * sizeof(float)); // truncated NV_PATCH_CURVE_INFO
    info->bytesGuardCurveAllAttr = info->nAttr * info->bytesGuardCurve;                   // just the set of curve info

    if (!(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR)) {
        // setup QUADRILATERAL PATCH

        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        } else {    // setup QUADRILATERAL INTEGER TESSELLATION
        }

    } else {
        // setup TRIANGULAR PATCH
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        } else {    // setup TRIANGULAR INTEGER TESSELLATION
        }
    }

    return retVal;

nvPatchSetupEnd:
    nvEvalPatchCleanup(info);
    return retVal;
}

unsigned int nvEvalPatchCleanup(NV_PATCH_INFO *info)
{
    int ii;

    if (info->normalPatch && !info->pCache[EV_CACHE_AUTO_NORMAL_SETUP]) {
        __NV_FREE(info->context, info->normalPatch);
        info->normalPatch = NULL;
    }
    if (info->UVPatch && !info->pCache[EV_CACHE_UV_SETUP]) {
        __NV_FREE(info->context, info->UVPatch);
        info->UVPatch = NULL;
    }

    // indicate that all cache's are not in use
    for (ii = 0;  ii < MAX_EV_CACHE;  ii++) {
        if (info->pCache[ii]) {
            info->pCache[ii]->inUse = 0;
        }
    }

//ff#ifdef DCR_SEMAPHORE    
    if (info->usingHW) info->backend->endPatch(info);
//ff#endif

    info->backend->setFrontFace(info, 0);
#if defined(COMPILE_TRACE_LIBRARY) && defined(FREDS_DEBUG_CODE)
    nvDebugMask &= ~TR_PUSHBUFFER;
#endif


    return info->retVal;
}

/*****************************************************************************/
int noflip = 0;

int MaybeTransposeFlipQuad(NV_PATCH_INFO *info)
{
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int index, ii;
    int stitchLeft;
    int stitchBottom;
    float fnuMax, fnvMax, ftemp;

    quadInfo->nu0 = (int)(info->tess.tensor.nu0 + 0.999f);
    quadInfo->nu1 = (int)(info->tess.tensor.nu1 + 0.999f);
    quadInfo->nv0 = (int)(info->tess.tensor.nv0 + 0.999f);
    quadInfo->nv1 = (int)(info->tess.tensor.nv1 + 0.999f);
    if (!doFrac) {
        fnuMax = MAX(quadInfo->nu0, quadInfo->nu1);
        fnvMax = MAX(quadInfo->nv0, quadInfo->nv1);
    } else {
        fnuMax = (info->tess.tensor.nu0 + info->tess.tensor.nu1) / 2.0f;
        fnvMax = (info->tess.tensor.nv0 + info->tess.tensor.nv1) / 2.0f;
    }

if (noflip) {
    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

    return 1;
}
    if (fnvMax > fnuMax) {
        info->flipT = 1;
        info->flags |= NV_PATCH_FLAG_TRANSPOSE;
        EV_SWAP(quadInfo->nu0, quadInfo->nv0, ii);
        EV_SWAP(quadInfo->nu1, quadInfo->nv1, ii);
        EV_SWAP(info->tess.tensor.nu0, info->tess.tensor.nv0, ftemp);
        EV_SWAP(info->tess.tensor.nu1, info->tess.tensor.nv1, ftemp);
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                EV_SWAP(info->maps[index].uorder, info->maps[index].vorder, ii);
                EV_SWAP(info->maps[index].vfStride, info->maps[index].ufStride, ii);
            }
        }
        NV_TRACE_COND(TR_EVAL, 20,
            TPRINTF(("\n\n***** transpose alert %g <--> %g\n\n", fnuMax, fnvMax));
        );
    }

    stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
    if (stitchLeft  &&  !doFrac) {
        info->flags |= NV_PATCH_FLAG_FLIPPED_U;
        info->flipU = 1;
        EV_SWAP(quadInfo->nv0, quadInfo->nv1, ii);
        EV_SWAP(info->tess.tensor.nv0, info->tess.tensor.nv1, ftemp);
    }

    stitchBottom = (quadInfo->nu0 < quadInfo->nu1);
    if (stitchBottom  &&  !doFrac) {
        info->flags |= NV_PATCH_FLAG_FLIPPED_V;
        info->flipV = 1;
        EV_SWAP(quadInfo->nu0, quadInfo->nu1, ii);
        EV_SWAP(info->tess.tensor.nu0, info->tess.tensor.nu1, ftemp);
    }

    info->flipUV = info->flipU ^ info->flipV;
    info->flipTUV = info->flipU ^ info->flipV ^ !!(info->flags & NV_PATCH_FLAG_TRANSPOSE);

    if (!info->usingHW) {
        if (info->flipT) {
            info->reverse ^= 1;
        }

    } else {
        info->reverse ^= info->flipTUV;
    }

    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

    return 1;
}


int MaybeTransposeFlipTri(NV_PATCH_INFO *info)
{
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;
    int index, ii;
    int stitchLeft;
    float ftemp;

    quadInfo->nu0 = (int)(info->tess.tri.n1 + 0.999f);
    quadInfo->nu1 = 1;
    quadInfo->nv0 = (int)(info->tess.tri.n3 + 0.999f);
    quadInfo->nv1 = (int)(info->tess.tri.n2 + 0.999f);

    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

return 1;
    if (quadInfo->nv0 > quadInfo->nu0) {
        info->flipT = 1;
        info->flags |= NV_PATCH_FLAG_TRANSPOSE;
        EV_SWAP(quadInfo->nv0, quadInfo->nu0, ii);
        EV_SWAP(info->tess.tri.n3, info->tess.tri.n1, ftemp);
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                assert(info->maps[index].uorder == info->maps[index].vorder);
                EV_SWAP(info->maps[index].uorder, info->maps[index].vorder, ii);
                EV_SWAP(info->maps[index].vfStride, info->maps[index].ufStride, ii);
            }
        }
    }

    stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
    if (stitchLeft) {
        //ffinfo->flags |= NV_PATCH_FLAG_FLIPPED_U;
        //ffinfo->flipU = 1;
        EV_SWAP(quadInfo->nv0, quadInfo->nu0, ii);
        EV_SWAP(info->tess.tri.n3, info->tess.tri.n1, ftemp);
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                NV_PATCH_MAP_INFO *map = &info->maps[index];
                float *rawData = map->rawData, *dst, *src;
                int uorder = map->uorder;
                int vorder = map->vorder;
                int row, col;
                float diag[4];

                assert(info->maps[index].uorder == info->maps[index].vorder);
                for (row = 0; row < vorder; row++) {
                    src = rawData + row*uorder*4;
                    dst = rawData + ((vorder-1)*uorder + (uorder-1-row)) * 4;
                    for (col = 0; col < uorder - row - 1; col++) {
                        CopyPoint(dst, src);
                        src += 4;
                        dst -= uorder;
                    }
                    CopyPoint(diag, src);
                    CopyPoint(src, dst);
                    CopyPoint(dst, diag);
                }

                map->rawData = rawData + (vorder*uorder - 1) * 4;
                info->maps[index].ufStride = -info->maps[index].ufStride;
                info->maps[index].vfStride = -info->maps[index].vfStride;
            }
        }
    }

    info->flipUV = info->flipU ^ info->flipV;
    info->flipTUV = info->flipU ^ info->flipV ^ !!(info->flags & NV_PATCH_FLAG_TRANSPOSE);

    if (!info->usingHW) {
        if (info->flipT) {
            info->reverse ^= 1;
        }

    } else {
        info->reverse ^= info->flipTUV;
    }

    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

    return 1;
}

/*****************************************************************************/
// common setup code for patches
static void evalCommonSetup(NV_PATCH_INFO *info, float uMaxSegs, float  vMaxSegs)
{
    // determine if swathing is required

    if ((uMaxSegs > info->maxSwatch)  ||  (vMaxSegs > info->maxSwatch)) {
        info->swatchFlags = NV_PATCH_SWATCH;    // for lower level routine to know "swatch mode"
        // calc swatches including the Begin and End stitches
        info->nSwatchU = (uMaxSegs - 1) / info->maxSwatch + 1;
        info->nSwatchV = (vMaxSegs - 1) / info->maxSwatch + 1;

    } else {
        info->swatchFlags = (NV_PATCH_SWATCH_FIRST_ROW | NV_PATCH_SWATCH_LAST_ROW | NV_PATCH_SWATCH_FIRST_COL | NV_PATCH_SWATCH_LAST_COL);
        info->nSwatchU = 1;
        info->nSwatchV = 1;
    }
}

/*****************************************************************************/
unsigned int nvEvalPatch(NV_PATCH_INFO *info)
{
    int i, j;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;

    if ((info->evalEnables & EV_GUARD_BIT_VERTEX) != EV_GUARD_BIT_VERTEX) {
        nvAssert(0);    //HW absolutely requires position 0 to be active -- if we don't have one bail.
        return NV_PATCH_EVAL_ERR_NOT_HANDLED;

    }

    if (info->backendType == NV_PATCH_BACKEND_CELSIUS) {
        if (info->backend->InitBackend) info->backend->InitBackend(info);
    }

    if (!(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR)) {
        // QUAD FRACTIONAL TESSELLATION

        // Tensor product patch
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            int transpose = MaybeTransposeFlipQuad(info);
            float nu0 = info->tess.tensor.nu0;
            float nv0 = info->tess.tensor.nv0;
            float nu1 = info->tess.tensor.nu1;
            float nv1 = info->tess.tensor.nv1;
            float nuMid = (nu0 + nu1) / 2.0f;
            float nvMid = (nv0 + nv1) / 2.0f;
            float nu0Old = info->originaltess.tensor.nu0;
            float nv0Old = info->originaltess.tensor.nv0;
            float nu1Old = info->originaltess.tensor.nu1;
            float nv1Old = info->originaltess.tensor.nv1;
            float nuMidOld = (nu0Old + nu1Old) / 2.0f;
            float nvMidOld = (nv0Old + nv1Old) / 2.0f;
            float du0, du1, dv0, dv1, duMid, dvMid;
            float du0Old, du1Old, dv0Old, dv1Old, duMidOld, dvMidOld;
            int u0Segs, u1Segs, v0Segs, v1Segs, uMidSegs, vMidSegs;
            float curvePoints[NV_PATCH_MAX_ORDER][4];

            ComputeFracStepInfo(nu0, &du0, &u0Segs);
            ComputeFracStepInfo(nu1, &du1, &u1Segs);
            ComputeFracStepInfo(nv0, &dv0, &v0Segs);
            ComputeFracStepInfo(nv1, &dv1, &v1Segs);

            ComputeFracStepInfo(nuMid, &duMid, &uMidSegs);
            ComputeFracStepInfo(nvMid, &dvMid, &vMidSegs);

            ComputeFracStepInfo(nu0Old, &du0Old, NULL);
            ComputeFracStepInfo(nu1Old, &du1Old, NULL);
            ComputeFracStepInfo(nv0Old, &dv0Old, NULL);
            ComputeFracStepInfo(nv1Old, &dv1Old, NULL);

            ComputeFracStepInfo(nuMidOld, &duMidOld, NULL);
            ComputeFracStepInfo(nvMidOld, &dvMidOld, NULL);

            evalCommonSetup(info, MAX(u0Segs, u1Segs), MAX(v0Segs, v1Segs));      // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                du0 *= info->maxSwatch;
                du1 *= info->maxSwatch;
                dv0 *= info->maxSwatch;
                dv1 *= info->maxSwatch;
                duMid *= info->maxSwatch;
                dvMid *= info->maxSwatch;
            }
            if (MAX(u0Segs,u1Segs) > info->maxSwatch || MAX(v0Segs,v1Segs) > info->maxSwatch) {
                du0Old *= info->maxSwatch;
                du1Old *= info->maxSwatch;
                dv0Old *= info->maxSwatch;
                dv1Old *= info->maxSwatch;
                duMidOld *= info->maxSwatch;
                dvMidOld *= info->maxSwatch;
            }

            // Compute FD matrices in each of the 4 orientations
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;
                    int ufStride = map->ufStride;
                    int vfStride = map->vfStride;

                    nvAssert(quadInfo->m00[i]);
                    nvAssert(quadInfo->m10[i]);
                    nvAssert(quadInfo->m01[i]);
                    nvAssert(quadInfo->m11[i]);
                    nvAssert(quadInfo->guardQF[i]);

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Compute FD matrix for each subpatch
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m00[i],
                                                rawData, 0, 0, info->maps[i].ufStride, info->maps[i].vfStride);
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m10[i],
                                                rawData, 0, uorder-1, -info->maps[i].ufStride, info->maps[i].vfStride);
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m01[i],
                                                rawData, vorder-1, 0, info->maps[i].ufStride, -info->maps[i].vfStride);
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m11[i],
                                                rawData, vorder-1, uorder-1, -info->maps[i].ufStride, -info->maps[i].vfStride);

                        // Compute guard curves /

                        //  |-u10-->|<--u11-|
                        //  |       |       |
                        // v01 m01  |  m11 v11
                        //  |       |       |
                        // \|/      |      \|/
                        //  --------+--------
                        // /|\      |      /|\
                        //  |       |       |
                        // v00 m00  |  m10 v10
                        //  |       |       |
                        //  |-u00-->|<--u01-|
                        //

                        // u00, u01
                        quadInfo->guardQF[i]->guardU00.order = uorder;
                        quadInfo->guardQF[i]->guardU01.order = uorder;
                        ComputeFDCurveFlip(info, uorder, du0, &quadInfo->guardQF[i]->guardU00,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].ufStride * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du0, &quadInfo->guardQF[i]->guardU01,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].ufStride * sizeof(float), 0, info->flipU);

                        // u10, u11
                        quadInfo->guardQF[i]->guardU10.order = uorder;
                        quadInfo->guardQF[i]->guardU11.order = uorder;
                        ComputeFDCurveFlip(info, uorder, du1, &quadInfo->guardQF[i]->guardU10,
                            pRawData(info, map, rawData, vorder-1, 0), info->maps[i].ufStride * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du1, &quadInfo->guardQF[i]->guardU11,
                            pRawData(info, map, rawData, vorder-1, 0), info->maps[i].ufStride * sizeof(float), 0, info->flipU);

                        // v00, v01
                        quadInfo->guardQF[i]->guardV00.order = vorder;
                        quadInfo->guardQF[i]->guardV01.order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv0, &quadInfo->guardQF[i]->guardV00,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].vfStride * sizeof(float), 1, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv0, &quadInfo->guardQF[i]->guardV01,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].vfStride * sizeof(float), 0, info->flipV);

                        // v10, v11
                        quadInfo->guardQF[i]->guardV10.order = vorder;
                        quadInfo->guardQF[i]->guardV11.order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv1, &quadInfo->guardQF[i]->guardV10,
                            pRawData(info, map, rawData, 0, uorder-1), info->maps[i].vfStride * sizeof(float), 1, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv1, &quadInfo->guardQF[i]->guardV11,
                            pRawData(info, map, rawData, 0, uorder-1), info->maps[i].vfStride * sizeof(float), 0, info->flipV);

                        // uCenter0, uCenter1
                        quadInfo->guardQF[i]->guardUCenter0.order = uorder;
                        quadInfo->guardQF[i]->guardUCenter1.order = uorder;
                        for (j = 0; j < uorder; j++) {
                            ComputeCurvePoint(vorder, &curvePoints[j][0], pRawData(info, map, rawData, 0, j), vfStride * sizeof(float), .5);
                        }
                        ComputeFDCurveFlip(info, uorder, duMid, &quadInfo->guardQF[i]->guardUCenter0,
                            &curvePoints[0][0], 4 * sizeof(float), 1, 0);
                        ComputeFDCurveFlip(info, uorder, duMid, &quadInfo->guardQF[i]->guardUCenter1,
                            &curvePoints[0][0], 4 * sizeof(float), 0, 0);

                        // vCenter0, vCenter1
                        quadInfo->guardQF[i]->guardVCenter0.order = vorder;
                        quadInfo->guardQF[i]->guardVCenter1.order = vorder;
                        for (j = 0; j < vorder; j++) {
                            ComputeCurvePoint(uorder, &curvePoints[j][0], pRawData(info, map, rawData, j, 0),
                                                ufStride*sizeof(float),.5);
                        }
                        ComputeFDCurveFlip(info, vorder, dvMid, &quadInfo->guardQF[i]->guardVCenter0,
                            &curvePoints[0][0], 4 * sizeof(float), 1, 0);
                        ComputeFDCurveFlip(info, vorder, dvMid, &quadInfo->guardQF[i]->guardVCenter1,
                            &curvePoints[0][0], 4 * sizeof(float), 0, 0);

                        // Compute points
                        // DCR seems to me we computed these already above!!! why duplicate it here?
                        // u0Mid
                        ComputeCurvePoint(uorder, quadInfo->guardQF[i]->u0Mid, pRawData(info, map, rawData, 0, 0),
                                                ufStride * sizeof(float), .5);

                        // u1Mid
                        ComputeCurvePoint(uorder, quadInfo->guardQF[i]->u1Mid, pRawData(info, map, rawData, vorder-1, 0),
                                                ufStride * sizeof(float), .5);

                        // v0Mid
                        ComputeCurvePoint(vorder, quadInfo->guardQF[i]->v0Mid, pRawData(info, map, rawData, 0, 0),
                                                vfStride * sizeof(float), .5);

                        // v1Mid
                        ComputeCurvePoint(vorder, quadInfo->guardQF[i]->v1Mid, pRawData(info, map, rawData, 0, uorder-1),
                                                vfStride * sizeof(float), .5);

                        // center
                        for (j = 0; j < uorder; j++) {
                            ComputeCurvePoint(vorder, &curvePoints[j][0], pRawData(info, map, rawData, 0, j),
                                                vfStride * sizeof(float), .5);
                        }
                        ComputeCurvePoint(uorder, quadInfo->guardQF[i]->center, &curvePoints[0][0],
                                                4*sizeof(float), .5);

                        info->originaltess = info->tess;
                        info->maps[i].dirtyFlags = 0;

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m00[i]);
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m10[i]);
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m01[i]);
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m11[i]);

                        RetessellateFDCurve(info, du0Old, du0, &quadInfo->guardQF[i]->guardU00, 0);
                        RetessellateFDCurve(info, du0Old, du0, &quadInfo->guardQF[i]->guardU01, 0);
                        RetessellateFDCurve(info, du1Old, du1, &quadInfo->guardQF[i]->guardU10, 0);
                        RetessellateFDCurve(info, du1Old, du1, &quadInfo->guardQF[i]->guardU11, 0);
                        RetessellateFDCurve(info, dv0Old, dv0, &quadInfo->guardQF[i]->guardV00, 0);
                        RetessellateFDCurve(info, dv0Old, dv0, &quadInfo->guardQF[i]->guardV01, 0);
                        RetessellateFDCurve(info, dv1Old, dv1, &quadInfo->guardQF[i]->guardV10, 0);
                        RetessellateFDCurve(info, dv1Old, dv1, &quadInfo->guardQF[i]->guardV11, 0);

                        RetessellateFDCurve(info, duMidOld, duMid, &quadInfo->guardQF[i]->guardUCenter0, 0);
                        RetessellateFDCurve(info, duMidOld, duMid, &quadInfo->guardQF[i]->guardUCenter1, 0);
                        RetessellateFDCurve(info, dvMidOld, dvMid, &quadInfo->guardQF[i]->guardVCenter0, 0);
                        RetessellateFDCurve(info, dvMidOld, dvMid, &quadInfo->guardQF[i]->guardVCenter1, 0);

                        info->originaltess = info->tess;
                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }

            // DCR: should we be guard curving ALL attributes?  HW doesn't.
            // FBF: the names are mis-leading. They are actually full attribute curves
            // used when doing the regular grid and transitions. But, they are also "guards"
            // in the sense that they are used to provide a consistent set of values
            // for position and normal along the various sub-patch directions.
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU00;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV00;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter0;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter0;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m00[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u0Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v0Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u0Segs, uMidSegs, v0Segs, vMidSegs, 0, quadInfo->m00);
            NV_TRACE_CODE(
                if (skipQuads) {
                    goto nvEvalPatchEnd;
                }
                //ffevalTrace = 0;
            );

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU01;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV10;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter1;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter0;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m10[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u0Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v1Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u0Segs, uMidSegs, v1Segs, vMidSegs, 1, quadInfo->m10);

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU10;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV01;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter0;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter1;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m01[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u1Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v0Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u1Segs, uMidSegs, v0Segs, vMidSegs, 1, quadInfo->m01);

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU11;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV11;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter1;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter1;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m11[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u1Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v1Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u1Segs, uMidSegs, v1Segs, vMidSegs, 0, quadInfo->m11);

        /*****************************************************************************/
        } else {    // QUAD INTEGER TESSELLATION
            int transpose = MaybeTransposeFlipQuad(info);
            int stitchBottom = (quadInfo->nu0 < quadInfo->nu1);
            int stitchTop = (quadInfo->nu0 > quadInfo->nu1);
            int stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
            int stitchRight = (quadInfo->nv0 > quadInfo->nv1);

            float du0 = 1.0f / quadInfo->nu0;
            float du1 = 1.0f / quadInfo->nu1;
            float dv0 = 1.0f / quadInfo->nv0;
            float dv1 = 1.0f / quadInfo->nv1;

            float duMax = 1.0f / quadInfo->uMaxSegs;
            float dvMax = 1.0f / quadInfo->vMaxSegs;

            int nu0Old;
            int nv0Old;
            int nu1Old;
            int nv1Old;
            int nuMaxOld;
            int nvMaxOld;
            float du0Old;
            float du1Old;
            float dv0Old;
            float dv1Old;
            float duMaxOld;
            float dvMaxOld;
            int uMaxDir, vMaxDir;
            int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

            if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                ComputeEdgeDirections(info, 0, &info->maps[ATTR_V], &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }
            else if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                ComputeEdgeDirectionsFromCorners(info, 0, &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }

            if (quadInfo->uMaxSegs == 1) {
                // then reverse transitions in U do not matter
                quadInfo->u0Dir = quadInfo->u1Dir = 1;
            }
            if (quadInfo->vMaxSegs == 1) {
                // then reverse transitions in V do not matter
                quadInfo->v0Dir = quadInfo->v1Dir = 1;
            }

            // Fill in directions of max and min edges
            if (quadInfo->nu0 >= quadInfo->nu1) {
                uMaxDir = quadInfo->u0Dir;
            } else {
                uMaxDir = quadInfo->u1Dir;
            }
            if (quadInfo->nv0 >= quadInfo->nv1) {
                vMaxDir = quadInfo->v0Dir;
            } else {
                vMaxDir = quadInfo->v1Dir;
            }

            if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                quadInfo->olduMaxDir = quadInfo->uMaxDir;
                quadInfo->oldvMaxDir = quadInfo->vMaxDir;
                quadInfo->oldu0Dir   = quadInfo->u0Dir;
                quadInfo->oldu1Dir   = quadInfo->u1Dir;
                quadInfo->oldv0Dir   = quadInfo->v0Dir;
                quadInfo->oldv1Dir   = quadInfo->v1Dir;
            }

            if (info->flags & NV_PATCH_FLAG_SOME_DIRTY_TESS) {
                // compute the du/dvMaxOld for retessellations
                nu0Old = (int)(info->originaltess.tensor.nu0 + 0.999f);
                nv0Old = (int)(info->originaltess.tensor.nv0 + 0.999f);
                nu1Old = (int)(info->originaltess.tensor.nu1 + 0.999f);
                nv1Old = (int)(info->originaltess.tensor.nv1 + 0.999f);
                nuMaxOld = MAX(nu0Old,nu1Old);
                nvMaxOld = MAX(nv0Old,nv1Old);
                du0Old = 1.0f / nu0Old;
                du1Old = 1.0f / nu1Old;
                dv0Old = 1.0f / nv0Old;
                dv1Old = 1.0f / nv1Old;
                duMaxOld = 1.0f / nuMaxOld;
                dvMaxOld = 1.0f / nvMaxOld;
            }

            info->originaltess = info->tess;
            quadInfo->uMaxDir = uMaxDir;
            quadInfo->vMaxDir = vMaxDir;
            quadInfo->du0 = du0;
            quadInfo->du1 = du1;
            quadInfo->dv0 = dv0;
            quadInfo->dv1 = dv1;
            quadInfo->duMax = duMax;
            quadInfo->dvMax = dvMax;

            evalCommonSetup(info, quadInfo->uMaxSegs, quadInfo->vMaxSegs);      // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                du0 *= info->maxSwatch;
                du1 *= info->maxSwatch;
                dv0 *= info->maxSwatch;
                dv1 *= info->maxSwatch;
                duMax *= info->maxSwatch;
                dvMax *= info->maxSwatch;
            }
            if (nuMaxOld > info->maxSwatch || nvMaxOld > info->maxSwatch) {
                du0Old *= info->maxSwatch;
                du1Old *= info->maxSwatch;
                dv0Old *= info->maxSwatch;
                dv1Old *= info->maxSwatch;
                duMaxOld *= info->maxSwatch;
                dvMaxOld *= info->maxSwatch;
            }

            // We always tessellate in the "MaxDir" direction
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;

                    nvAssert(quadInfo->m00[i]);
                    nvAssert(quadInfo->pU0[i]);
                    nvAssert(quadInfo->pU1[i]);
                    nvAssert(quadInfo->pV0[i]);
                    nvAssert(quadInfo->pV1[i]);
                    nvAssert(quadInfo->pVInner[i]);
                    nvAssert(quadInfo->pVInner[i]);

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // compute FDMatrix given the modified origin according to u/vDir
                        if (vMaxDir == 1) {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, 0, 0, info->maps[i].ufStride, info->maps[i].vfStride);
                            } else {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, 0, uorder-1, -info->maps[i].ufStride, info->maps[i].vfStride);
                            }
                        } else {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, vorder-1, 0, info->maps[i].ufStride, -info->maps[i].vfStride);
                            } else {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, vorder-1, uorder-1, -info->maps[i].ufStride, -info->maps[i].vfStride);
                            }
                        }

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        RetessellateFDMatrix(info, duMaxOld, dvMaxOld, duMax, dvMax, quadInfo->m00[i]);
                    }
                }
            }

            // Reverse transitions may cause stitches
            // If dir's are not equal, AND there are no stitches for other reasons,
            // AND it's not degenerate in this direction, then ...
            if ((quadInfo->u0Dir != quadInfo->u1Dir) && !stitchBottom && !stitchTop && (quadInfo->nu0 > 1)) {
                nvAssert(quadInfo->nu0 == quadInfo->nu1);
                stitchTop = 1;          // make a stitch for the reversal
            }
            if ((quadInfo->v0Dir != quadInfo->v1Dir) && !stitchLeft && !stitchRight && (quadInfo->nv0 > 1)) {
                nvAssert(quadInfo->nv0 == quadInfo->nv1);
                stitchRight = 1;        // make a stitch for the reversal
            }

            // Decide where the stitching occurs w.r.t. the regular region
            if (uMaxDir == 1) {
                stitchUBegin = stitchLeft;
                stitchUEnd = stitchRight;
            } else {
                stitchUBegin = stitchRight;
                stitchUEnd = stitchLeft;
            }
            if (vMaxDir == 1) {
                stitchVBegin = stitchBottom;
                stitchVEnd = stitchTop;
            } else {
                stitchVBegin = stitchTop;
                stitchVEnd = stitchBottom;
            }

            quadInfo->stitchLeft   = stitchLeft;
            quadInfo->stitchRight  = stitchRight;
            quadInfo->stitchBottom = stitchBottom;
            quadInfo->stitchTop    = stitchTop;
            quadInfo->stitchUBegin = stitchUBegin;
            quadInfo->stitchUEnd   = stitchUEnd;
            quadInfo->stitchVBegin = stitchVBegin;
            quadInfo->stitchVEnd   = stitchVEnd;

            // calc if U/V inner guards required
            quadInfo->needUInner = (quadInfo->vMaxSegs > 1) && (stitchBottom || stitchTop);
            quadInfo->needVInner = (quadInfo->uMaxSegs > 1) && (stitchLeft || stitchRight);

            NV_TRACE_COND(TR_EVAL, 25,
                TPRINTF(("dir BTLR=[%d %d %d %d]  uMaxDir=%d vMaxDir=%d\n",
                        quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->v0Dir, quadInfo->v1Dir, uMaxDir, vMaxDir));
                TPRINTF(("  stitch BTLR=[%d %d %d %d]  stitch UBE=[%d %d] VBE=[%d %d]\n",
                        stitchBottom, stitchTop, stitchLeft, stitchRight,
                        stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd ));
                TPRINTF(("force rev bits=%d %d %d %d\n",
                        (nvDebugOptions & TRO_TEMP1) != 0,
                        (nvDebugOptions & TRO_TEMP2) != 0,
                        (nvDebugOptions & TRO_TEMP3) != 0,
                        (nvDebugOptions & TRO_TEMP4) != 0));
            );

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Store the corner points
                        getRawData(info, &info->maps[i], rawData, 0,               0, quadInfo->pCorners[i][0][0]);
                        getRawData(info, &info->maps[i], rawData, 0,        uorder-1, quadInfo->pCorners[i][0][1]);
                        getRawData(info, &info->maps[i], rawData, vorder-1, 0,        quadInfo->pCorners[i][1][0]);
                        getRawData(info, &info->maps[i], rawData, vorder-1, uorder-1, quadInfo->pCorners[i][1][1]);

                        // Compute U boundary curves
                        quadInfo->pU0[i]->order = uorder;
                        quadInfo->pU1[i]->order = uorder;
                        ComputeFDCurveFlip(info, uorder, du0, quadInfo->pU0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].ufStride * sizeof(float), quadInfo->u0Dir, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du1, quadInfo->pU1[i],
                            pRawData(info, map, rawData, vorder-1, 0),
                            info->maps[i].ufStride * sizeof(float), quadInfo->u1Dir, info->flipU);

                        // Compute V boundary curves
                        quadInfo->pV0[i]->order = vorder;
                        quadInfo->pV1[i]->order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv0, quadInfo->pV0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].vfStride * sizeof(float), quadInfo->v0Dir, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv1, quadInfo->pV1[i],
                            pRawData(info, map, rawData, 0, uorder-1),
                            info->maps[i].vfStride * sizeof(float), quadInfo->v1Dir, info->flipV);

                        info->maps[i].dirtyFlags = 0;

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        // Recompute U boundary curves
                        if (quadInfo->oldu0Dir == quadInfo->u0Dir) RetessellateFDCurve(info, du0Old, du0, quadInfo->pU0[i], 0);
                        else                                       RetessellateFDCurve(info, du0Old, du0, quadInfo->pU0[i], 1);                        
                        if (quadInfo->oldu1Dir == quadInfo->u1Dir) RetessellateFDCurve(info, du1Old, du1, quadInfo->pU1[i], 0);
                        else                                       RetessellateFDCurve(info, du1Old, du1, quadInfo->pU1[i], 1);

                        // Recompute V boundary curves
                        if (quadInfo->oldv0Dir == quadInfo->v0Dir) RetessellateFDCurve(info, dv0Old, dv0, quadInfo->pV0[i], 0);
                        else                                       RetessellateFDCurve(info, dv0Old, dv0, quadInfo->pV0[i], 1);
                        if (quadInfo->oldv1Dir == quadInfo->v1Dir) RetessellateFDCurve(info, dv1Old, dv1, quadInfo->pV1[i], 0);
                        else                                       RetessellateFDCurve(info, dv1Old, dv1, quadInfo->pV1[i], 1);

                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }
            
            //save off current diretions so we can assess if the traversal direction
            //changed on a subsequent render
            quadInfo->olduMaxDir = quadInfo->uMaxDir;
            quadInfo->oldvMaxDir = quadInfo->vMaxDir;               
            quadInfo->oldu0Dir   = quadInfo->u0Dir;
            quadInfo->oldu1Dir   = quadInfo->u1Dir;
            quadInfo->oldv0Dir   = quadInfo->v0Dir;
            quadInfo->oldv1Dir   = quadInfo->v1Dir;
            retVal |= DrawIntPatch(info, quadInfo, quadInfo->m00);
        }

    /*****************************************************************************/
    } else {
        // TRI FRAC TESSELLATION
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            int transpose = MaybeTransposeFlipTri(info);
            float n1 = info->tess.tri.n1;
            float n2 = info->tess.tri.n2;
            float n3 = info->tess.tri.n3;
            float nMid = (n1 + n2 + n3)/3.0f;
            float n1Old = info->originaltess.tri.n1;
            float n2Old = info->originaltess.tri.n2;
            float n3Old = info->originaltess.tri.n3;
            float nMidOld = (n1 + n2 + n3)/3.0f;
            float duv[3], duvMid, duvOld[3], duvMidOld;
            int segs[3], midSegs, vMax;
            FDMatrix *m[3][NV_PATCH_NUMBER_OF_ATTRIBS];

            //guard = NULL;
            for (i = 0; i < info->maxAttr; i++) {
                m[0][i] = quadInfo->m00[i];
                m[1][i] = quadInfo->m10[i];
                m[2][i] = quadInfo->m01[i];
            }

            ComputeFracStepInfo(n1, &duv[0], &segs[0]);
            ComputeFracStepInfo(n2, &duv[1], &segs[1]);
            ComputeFracStepInfo(n3, &duv[2], &segs[2]);

            ComputeFracStepInfo(nMid, &duvMid, &midSegs);
            duvMid *= 2;

            ComputeFracStepInfo(n1Old, &duvOld[0], NULL);
            ComputeFracStepInfo(n2Old, &duvOld[1], NULL);
            ComputeFracStepInfo(n3Old, &duvOld[2], NULL);

            ComputeFracStepInfo(nMidOld, &duvMidOld, NULL);
            duvMidOld *= 2;

            vMax = MAX(segs[1], segs[2]);
            evalCommonSetup(info, MAX(segs[0], midSegs), MAX(vMax, midSegs));        // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                duv[0] *= info->maxSwatch;
                duv[1] *= info->maxSwatch;
                duv[2] *= info->maxSwatch;
                duvMid *= info->maxSwatch;
            }

            // Compute FD matrices in each of the 3 orientations
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int order = map->uorder;
                    int ufStride = map->ufStride;
                    int vfStride = map->vfStride;
                    int k, l;

                    nvAssert(info->maps[i].uorder == info->maps[i].vorder);

                    // Compute FD matrix for each subpatch
                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        for (j = 0; j < 3; j++) {
                            info->reparam.rows = info->reparam.columns = order;
                            for (l = 0; l < order; l++) {       // V order
                                for (k = 0; k < order-l; k++) { // U order
                                    getRawData(info, &info->maps[i], rawData, l, k, info->reparam.data[l][k]);
                                }
                            }
                            ReparameterizeTriPatch(info, &info->reparam, m[j][i], j, 1);

                            quadInfo->guardTF[i]->guardCenter[j].order = order;
                            if (TriPatchLayout[j].centerCurve) {
                                ComputeFDCurveFlip(info, order, duvMid, &quadInfo->guardTF[i]->guardCenter[j],
                                    &m[j][i]->data[order-1][0][0],
                                    4 * sizeof(float), 1, 0);
                            } else {
                                ComputeFDCurveFlip(info, order, duvMid, &quadInfo->guardTF[i]->guardCenter[j],
                                    &m[j][i]->data[0][order-1][0],
                                    4*NV_PATCH_MAX_ORDER*sizeof(float), 1, 0);
                            }

                            ComputeFDMatrixFlip(info, 0, order, order, duvMid, duvMid, m[j][i],
                                &m[j][i]->data[0][0][0], 0, 0, 4, 4*NV_PATCH_MAX_ORDER);
                        }

                        // Compute guard curves /

                        //  |\
                        //  | \
                        //  |  \
                        // 20   11
                        //  |     \
                        //  |      \|
                        // \|/     -\
                        //  +        +
                        // /|\-    _/ \-
                        //  |  \-+/   |\
                        //  |     \     \
                        // 21      |    10
                        //  |      \      \
                        //  |       |      \
                        //  |--00-->|<---01-|
                        //
                        // 00, 01
                        quadInfo->guardTF[i]->guard[0][0].order = order;
                        quadInfo->guardTF[i]->guard[0][1].order = order;

                        ComputeFDCurveFlip(info, order, duv[0], &quadInfo->guardTF[i]->guard[0][0],
                            pRawData(info, map, rawData, 0, 0),
                            ufStride * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, order, duv[0], &quadInfo->guardTF[i]->guard[0][1],
                            pRawData(info, map, rawData, 0, 0),
                            ufStride * sizeof(float), 0, info->flipU);

                        // 10, 11
                        quadInfo->guardTF[i]->guard[1][0].order = order;
                        quadInfo->guardTF[i]->guard[1][1].order = order;
                        ComputeFDCurveFlip(info, order, duv[1], &quadInfo->guardTF[i]->guard[1][0],
                            pRawData(info, map, rawData, 0, order-1),
                            (vfStride-4) * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, order, duv[1], &quadInfo->guardTF[i]->guard[1][1],
                            pRawData(info, map, rawData, 0, order-1),
                            (vfStride-4) * sizeof(float), 0, info->flipU);

                        // 20, 21
                        quadInfo->guardTF[i]->guard[2][0].order = order;
                        quadInfo->guardTF[i]->guard[2][1].order = order;
                        ComputeFDCurveFlip(info, order, duv[2], &quadInfo->guardTF[i]->guard[2][0],
                            pRawData(info, map, rawData, 0, 0),
                            vfStride * sizeof(float), 0, info->flipU);
                        ComputeFDCurveFlip(info, order, duv[2], &quadInfo->guardTF[i]->guard[2][1],
                            pRawData(info, map, rawData, 0, 0),
                            vfStride * sizeof(float), 1, info->flipU);

                        // Compute points
                        // mid0,1,2
                        ComputeCurvePoint(order, quadInfo->guardTF[i]->mid[0],
                                            pRawData(info, map, rawData, 0, 0),
                                            ufStride * sizeof(float), .5);
                        ComputeCurvePoint(order, quadInfo->guardTF[i]->mid[1],
                                            pRawData(info, map, rawData, 0, order-1),
                                            (vfStride-4) * sizeof(float), .5);
                        ComputeCurvePoint(order, quadInfo->guardTF[i]->mid[2],
                                            pRawData(info, map, rawData, 0, 0),
                                            vfStride * sizeof(float), .5);

                        // center
                        ComputeTriPatchCenter(order, quadInfo->guardTF[i]->center, pRawData(info, map, rawData, 0, 0),
                            ufStride * sizeof(float), vfStride * sizeof(float));

                        info->maps[i].dirtyFlags = 0;
                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        for (j = 0; j < 3; j++) {
                            RetessellateFDMatrix(info, duvMidOld, duvMidOld, duvMid, duvMid, m[j][i]);
                            //BUG BUG WE NEED TO ASSES IF CURVES CHANGED DIRECTION
                            RetessellateFDCurve(info, duvOld[j], duv[j], &quadInfo->guardTF[i]->guard[j][0], 0);
                            RetessellateFDCurve(info, duvOld[j], duv[j], &quadInfo->guardTF[i]->guard[j][1], 0);

                            RetessellateFDCurve(info, duvMidOld, duvMid, &quadInfo->guardTF[i]->guardCenter[j], 0);
                        }

                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }
            info->originaltess = info->tess;

            for (j = 0; j < 3; j++) {
                int uSide   = TriPatchLayout[j].uSide;
                int vSide   = TriPatchLayout[j].vSide;
                int uDir    = TriPatchLayout[j].uDir;
                int vDir    = TriPatchLayout[j].vDir;
                int reverse = TriPatchLayout[j].reverse;

                for (i = 0; i < info->maxAttr; i++) {
                    if (info->evalEnables & (1 << i)) {
                        // Curves
                        quadInfo->pU0[i] = &quadInfo->guardTF[i]->guard[uSide][uDir];
                        quadInfo->pV0[i] = &quadInfo->guardTF[i]->guard[vSide][vDir];
                        quadInfo->pU1[i] = &quadInfo->guardTF[i]->guardCenter[vSide];
                        quadInfo->pV1[i] = &quadInfo->guardTF[i]->guardCenter[uSide];

                        // Points
                        quadInfo->pCorners[i][0][0] = m[j][i]->data[0][0];
                        quadInfo->pCorners[i][0][1] = quadInfo->guardTF[i]->mid[uSide];
                        quadInfo->pCorners[i][1][0] = quadInfo->guardTF[i]->mid[vSide];
                        quadInfo->pCorners[i][1][1] = quadInfo->guardTF[i]->center;
                    }
                }

                retVal |= DrawFracPatch(info, segs[uSide], midSegs, segs[vSide], midSegs, reverse, m[j]);
                NV_TRACE_CODE(
                    if (skipQuads) {
                        break;
                    }
                    //ffevalTrace = 0;
                );
            }

        /*****************************************************************************/
        } else {    // TRI INTEGER TESSELLATION
            int transpose = MaybeTransposeFlipTri(info);

            float du0 = 1.0f / quadInfo->nu0;
            float du1 = 1.0f;
            float dv0 = 1.0f / quadInfo->nv0;
            float dv1 = 1.0f / quadInfo->nv1;
            float duMax = 1.0f / quadInfo->uMaxSegs;
            float dvMax = 1.0f / quadInfo->vMaxSegs;

            int n1Old = (int)(info->originaltess.tri.n1 + 0.999f);
            int n2Old = (int)(info->originaltess.tri.n2 + 0.999f);
            int n3Old = (int)(info->originaltess.tri.n3 + 0.999f);
            int nuMaxOld = n1Old;
            int nvMaxOld = MAX(n2Old,n3Old);

            float du0Old = 1.0f / n1Old;
            float du1Old = 1.0f;
            float dv0Old = 1.0f / n3Old;
            float dv1Old = 1.0f / n2Old;
            float duMaxOld = 1.0f / nuMaxOld;
            float dvMaxOld = 1.0f / nvMaxOld;

            int uMaxDir, vMaxDir;
            int stitchBottom = 0;
            int stitchTop = (quadInfo->nu0 > 1);
            int stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
            int stitchRight = (quadInfo->nv0 > quadInfo->nv1);
            int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

            if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                //only compute edge directions when I have some map info around
                ComputeEdgeDirections(info, 1, &info->maps[ATTR_V],
                        &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }
            /*if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                ComputeEdgeDirectionsFromCorners(info, 1, &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }*/

            if (quadInfo->uMaxSegs == 1) {
                // then reverse transitions in U do not matter
                quadInfo->u0Dir = quadInfo->u1Dir = 1;
            }
            if (quadInfo->vMaxSegs == 1) {
                // then reverse transitions in V do not matter
                quadInfo->v0Dir = quadInfo->v1Dir = 1;
            }

            // Fill in directions of max and min edges
            uMaxDir = quadInfo->u0Dir;
            if (quadInfo->nv0 >= quadInfo->nv1) {
                vMaxDir = quadInfo->v0Dir;
            } else {
                vMaxDir = quadInfo->v1Dir;
            }

            info->originaltess = info->tess;
            quadInfo->uMaxDir = uMaxDir;
            quadInfo->vMaxDir = vMaxDir;
            quadInfo->du0 = du0;
            quadInfo->du1 = du1;
            quadInfo->dv0 = dv0;
            quadInfo->dv1 = dv1;
            quadInfo->duMax = duMax;
            quadInfo->dvMax = dvMax;

            evalCommonSetup(info, quadInfo->uMaxSegs, quadInfo->vMaxSegs);      // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                du0 *= info->maxSwatch;
                du1 *= info->maxSwatch;
                dv0 *= info->maxSwatch;
                dv1 *= info->maxSwatch;
                duMax *= info->maxSwatch;
                dvMax *= info->maxSwatch;
            }
            if (nuMaxOld > info->maxSwatch || nvMaxOld > info->maxSwatch) {      // various common init for patches
                du0Old *= info->maxSwatch;
                du1Old *= info->maxSwatch;
                dv0Old *= info->maxSwatch;
                dv1Old *= info->maxSwatch;
                duMaxOld *= info->maxSwatch;
                dvMaxOld *= info->maxSwatch;
            }

            // Compute FD matrices in each of the 3 orientations
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int order = map->uorder;
                    int ufStride = map->ufStride;
                    int vfStride = map->vfStride;
                    int k, l;

                    nvAssert(info->maps[i].uorder == info->maps[i].vorder);

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Compute FD matrix for each subpatch
                        info->reparam.rows = info->reparam.columns = order;
                        for (l = 0; l < order; l++) {
                            for (k = 0; k < order-l; k++) {
                                getRawData(info, &info->maps[i], rawData, l, k, info->reparam.data[l][k]);
                            }
                        }

                        ReparameterizeTriPatch(info, &info->reparam, quadInfo->m00[i], 0, 0);

                        if (vMaxDir == 1) {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[0][0][0], 0, 0, 4, 4 * NV_PATCH_MAX_ORDER);
                            } else {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[0][order-1][0], 0, 0, -4, 4 * NV_PATCH_MAX_ORDER);
                            }
                        } else {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[order-1][0][0], 0, 0, 4, -4 * NV_PATCH_MAX_ORDER);
                            } else {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[order-1][order-1][0], 0, 0, -4, -4 * NV_PATCH_MAX_ORDER);
                            }
                        }

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        RetessellateFDMatrix(info, duMaxOld, dvMaxOld, duMax, dvMax, quadInfo->m00[i]);
                    }

                }
            }

            // Reverse transitions may cause stitches
            // If dir's are not equal, AND there are no stitches for other reasons,
            // AND it's not degenerate in this direction, then ...
            if ((quadInfo->u0Dir != quadInfo->u1Dir) && !stitchBottom && !stitchTop && (quadInfo->nu0 > 1)) {
                stitchTop = 1;          // make a stitch for the reversal
            }
            if ((quadInfo->v0Dir != quadInfo->v1Dir) && !stitchLeft && !stitchRight && (quadInfo->nv1 > 1)) {
                nvAssert(quadInfo->nv1 == quadInfo->nv0);
                stitchRight = 1;        // make a stitch for the reversal
            }

            // Decide where the stitching occurs w.r.t. the regular region
            if (uMaxDir == 1) {
                stitchUBegin = stitchLeft;
                stitchUEnd = stitchRight;
            } else {
                stitchUBegin = stitchRight;
                stitchUEnd = stitchLeft;
            }
            if (vMaxDir == 1) {
                stitchVBegin = stitchBottom;
                stitchVEnd = stitchTop;
            } else {
                stitchVBegin = stitchTop;
                stitchVEnd = stitchBottom;
            }

            quadInfo->stitchLeft   = stitchLeft;
            quadInfo->stitchRight  = stitchRight;
            quadInfo->stitchBottom = stitchBottom;
            quadInfo->stitchTop    = stitchTop;
            quadInfo->stitchUBegin = stitchUBegin;
            quadInfo->stitchUEnd   = stitchUEnd;
            quadInfo->stitchVBegin = stitchVBegin;
            quadInfo->stitchVEnd   = stitchVEnd;

            // calc if U/V inner guards required
            quadInfo->needUInner = (quadInfo->vMaxSegs > 1) && (stitchBottom || stitchTop);
            quadInfo->needVInner = (quadInfo->uMaxSegs > 1) && (stitchLeft || stitchRight);

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Store the corner points
                        getRawData(info, &info->maps[i], rawData, 0,        0,        quadInfo->pCorners[i][0][0]);
                        getRawData(info, &info->maps[i], rawData, 0,        uorder-1, quadInfo->pCorners[i][0][1]);
                        getRawData(info, &info->maps[i], rawData, vorder-1, 0,        quadInfo->pCorners[i][1][0]);

                        CopyPoint(quadInfo->pCorners[i][1][1], quadInfo->pCorners[i][1][0]);

                        // Compute U boundary curves
                        quadInfo->pU0[i]->order = uorder;
                        quadInfo->pU1[i]->order = uorder;
                        ComputeFDCurveFlip(info, uorder, du0, quadInfo->pU0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].ufStride * sizeof(float),quadInfo->u0Dir, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du1, quadInfo->pU1[i],
                            pRawData(info, map, rawData, vorder-1, 0),
                            0 /* stride at top */, quadInfo->u1Dir, info->flipU);

                        // Compute V boundary curves
                        quadInfo->pV0[i]->order = vorder;
                        quadInfo->pV1[i]->order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv0, quadInfo->pV0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].vfStride * sizeof(float), quadInfo->v0Dir, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv1, quadInfo->pV1[i],
                            pRawData(info, map, rawData, 0, uorder-1),
                            (info->maps[i].vfStride-4) * sizeof(float), quadInfo->v1Dir, info->flipV);

                        info->maps[i].dirtyFlags = 0;

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        //BUG BUG WE NEED TO ASSES IF CURVES CHANGED DIRECTION
                        // Compute U boundary curves
                        RetessellateFDCurve(info, du0Old, du0, quadInfo->pU0[i], 0);
                        RetessellateFDCurve(info, du1Old, du1, quadInfo->pU1[i], 0);
                        // Compute V boundary curves
                        RetessellateFDCurve(info, dv0Old, dv0, quadInfo->pV0[i], 0);
                        RetessellateFDCurve(info, dv1Old, dv1, quadInfo->pV1[i], 0);

                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }

            retVal |= DrawIntPatch(info, quadInfo, quadInfo->m00);
        }
    }

NV_TRACE_CODE(
  nvEvalPatchEnd:
);

    if (info->backendType == NV_PATCH_BACKEND_CELSIUS) {
        if (info->backend->DestroyBackend) info->backend->DestroyBackend(info);
    }
    return retVal;
}

/*****************************************************************************/
int evAllocInitWithCache(NV_PATCH_INFO *info, void *context, NV_PATCH_ALLOC_CONTROL *pevMemory,
                            int tBytes, NV_PATCH_ALLOC_CACHE *pCache)
{
    nvAssert(!(tBytes & (sizeof(void *) - 1)));
    if (pCache && pCache->pBaseCache) {
        if (pCache->bytesAllocCache >= tBytes) {
            // requested allocation fit in cached allocation
            nvAssert(!pCache->inUse);
#if defined(IS_OPENGL)
            nvAssert(pCache->contextCache == context);
#endif
            pCache->inUse = 1;
            pCache->countFreeCheck = 0;
            pevMemory->context = context;
            pevMemory->pBase = pevMemory->pAvail = pCache->pBaseCache;
            pevMemory->bytesAlloc = tBytes;
            pevMemory->bytesUsed = 0;
            pevMemory->pCache = pCache;
            return 0;
        }
        // need new alloc, free up the old
        __NV_FREE(pevMemory->context, pCache->pBaseCache);
    }

    // must do new alloc
    pevMemory->context = context;
    pevMemory->pBase = __NV_MALLOC(context, tBytes);
    pevMemory->pAvail = pevMemory->pBase;
    pevMemory->bytesAlloc = tBytes;
    pevMemory->bytesUsed = 0;
    pevMemory->pCache = pCache;

    if (pCache) {
        pCache->contextCache = context;
        pCache->pBaseCache = pevMemory->pBase;
        pCache->bytesAllocCache = tBytes;
        pCache->inUse = 1;
        pCache->countFreeCheck = 0;
    }
    if (pevMemory->pBase) {
        return 0;
    }
    return 1;
}

/*****************************************************************************/
#if !defined(IS_OPENGL)
#undef nvAssert
#endif

#if 1 && defined(IS_OPENGL)
const int attrHwToSw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        NV_PATCH_ATTRIB_POSITION,
        NV_PATCH_ATTRIB_VERTEX_WEIGHT,
        NV_PATCH_ATTRIB_NORMAL,
        NV_PATCH_ATTRIB_COLOR,
        NV_PATCH_ATTRIB_SECONDARY_COLOR,
        NV_PATCH_ATTRIB_FOG_COORD,
        NV_PATCH_ATTRIB_UNUSED0,
        NV_PATCH_ATTRIB_UNUSED1,
        NV_PATCH_ATTRIB_TEXCOORD7,
        NV_PATCH_ATTRIB_TEXCOORD0,
        NV_PATCH_ATTRIB_TEXCOORD1,
        NV_PATCH_ATTRIB_TEXCOORD2,
        NV_PATCH_ATTRIB_TEXCOORD3,
        NV_PATCH_ATTRIB_TEXCOORD4,
        NV_PATCH_ATTRIB_TEXCOORD5,
        NV_PATCH_ATTRIB_TEXCOORD6,
    };

const int attrSwToHw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        NV_PATCH_ATTRIB_POSITION,
        NV_PATCH_ATTRIB_VERTEX_WEIGHT,
        NV_PATCH_ATTRIB_NORMAL,
        NV_PATCH_ATTRIB_COLOR,
        NV_PATCH_ATTRIB_SECONDARY_COLOR,
        NV_PATCH_ATTRIB_FOG_COORD,
        NV_PATCH_ATTRIB_UNUSED0,
        NV_PATCH_ATTRIB_UNUSED1,
        NV_PATCH_ATTRIB_TEXCOORD1,
        NV_PATCH_ATTRIB_TEXCOORD2,
        NV_PATCH_ATTRIB_TEXCOORD3,
        NV_PATCH_ATTRIB_TEXCOORD4,
        NV_PATCH_ATTRIB_TEXCOORD5,
        NV_PATCH_ATTRIB_TEXCOORD6,
        NV_PATCH_ATTRIB_TEXCOORD7,
        NV_PATCH_ATTRIB_TEXCOORD0,
    };

#else
const int attrHwToSw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 10, 11, 12, 13, 14, 15,
    };

const int attrSwToHw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 10, 11, 12, 13, 14, 15,
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvPriv.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#if (NVARCH >= 0x04)

#include "nvprecomp.h"
#include "wincommon.h"
#include "nvPriv.h"
#include "nvProcMan.h"
#pragma hdrstop


//extern BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID);
//extern BOOL pmDeleteProcess(DWORD processID);

// this is really global, do not move to pDriverData
// each element contains a pDriverData associated with an adapter
extern "C" 
{
	NV_ADAPTER_TYPE g_adapterData[MAX_ADAPTERS];
}

#if (IS_WIN9X || IS_WINNT5)
// -----------------------------------------------------------------------------
DWORD nvGetTextureFromSystemMemAddress(GLOBALDATA *pDriverData, FLATPTR fpVidMem)
{
    CNvObject *pNvObject = global.pNvObjectHead;
    while (pNvObject)
    {
        CTexture *pTexture = pNvObject->getTexture();
        if (pTexture)
        {
            if (pTexture->getLinear()->isValid())
            {
                if (pTexture->getLinear()->getAddress() == fpVidMem)
                {
                    CSimpleSurface *pSurf = pNvObject->getTexture()->getSwizzled();
                    return pSurf->getOffset();
                }
            }
        }
        pNvObject = pNvObject->getNext();
    }
    return -1;
}
#endif

static GLOBALDATA *getGlobalDataPtr(NvU32 dwDevice)
{
#if (IS_WINNT5)
    return g_adapterData[dwDevice].pDriverData;
#elif (IS_WINNT4)
    // device is always zero under winnt4
    return g_adapterData[0].pDriverData;
#else
    int i;
    if (dwDevice > MAX_ADAPTERS)
    {
        return NULL;
    }
    if (dwDevice != 0)
    {
        dwDevice -= 1;
    }
    for (i=0; i < MAX_ADAPTERS; i++)
    {
        if (g_adapterData[i].pDriverData &&
           (g_adapterData[i].pDriverData->dwDeviceIDNum == (dwDevice + 1)))
        {
            return g_adapterData[i].pDriverData;
        }
    }
    return NULL;
#endif
}


#ifdef __cplusplus
extern "C" {
#endif

// -----------------------------------------------------------------------------
// nvOverlayControl
//      Controls various overlay features
//      Commands:
//          GETCAPS - Returns overlay capabilities
//          SETCOLORCONTROL - Sets the colour controls
//          GETCOLORCONTROL - Returns colour control state
//          SETFEATURE - Sets overlay features
//          GETFEATURE - Gets overlay features

NVOCERROR __stdcall nvOverlayControl(LPNVOCDATATYPE lpOCData)
{
GLOBALDATA* pDriverData = NULL;          // override the global pDriverData
NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS displayParams[NV_MAX_HEADS];
int i;

    if (lpOCData->dwSize < sizeof(NVOCDATATYPE) || lpOCData->dwSize > 4096) {
        return NVOCERR_INVALID_PARMS;
    }

    pDriverData = getGlobalDataPtr(lpOCData->dwDevice);
    if (pDriverData == NULL) {
        return NVOCERR_BAD_DEVICE;
    }
    Vpp_t &vpp = pDriverData->vpp;

    // If the VPP constructor hasn't been called, don't return any info.
    if (!VppIsConstructed(&pDriverData->vpp))
    {
        return NVOCERR_BAD_DEVICE;
    }

    switch (lpOCData->cmd) {
    case NVOCCMD_NOOP:
        return NVOCERR_OK;

    case NVOCCMD_IDENTIFY:
        vpp.dwDecoderIdentity = lpOCData->caps.dwCaps1;
        vpp.dwDecoderCaps     = lpOCData->caps.dwCaps2;
        return NVOCERR_OK;

    case NVOCCMD_GETCAPS:
        lpOCData->caps.dwCaps1 = 0;
        lpOCData->caps.dwCaps2 = 0;
        lpOCData->caps.dwCaps3 = 0;
        lpOCData->caps.dwCaps4 = 0;
        lpOCData->caps.dwCaps5 = 0;
        if (vpp.regOverlayColourControlEnable ||
            pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            lpOCData->caps.dwCaps1 = NVOCCAPS1_BRIGHTNESS |
                                     NVOCCAPS1_CONTRAST |
                                     NVOCCAPS1_HUE |
                                     NVOCCAPS1_SATURATION;
        }

        lpOCData->caps.dwCaps2 |= NVOCCAPS2_TFILTER |
                                  NVOCCAPS2_OVLZOOM;
        if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            lpOCData->caps.dwCaps2 |= NVOCCAPS2_HQVUPSCALE;
        } else {
            lpOCData->caps.dwCaps2 |= NVOCCAPS2_DFILTER;
        }
        if (pDriverData->dwHeads > 1) {
            lpOCData->caps.dwCaps2 |= NVOCCAPS2_FSMIRROR;
        }

        lpOCData->caps.dwCaps3 |= NVOCCAPS3_SUBPICTURE;
        lpOCData->caps.dwCaps3 |= NVOCCAPS3_LATEFLIPSYNC;
        if (vpp.pSysInfo->dwNVClasses & NVCLASS_0004_TIMER) {
            lpOCData->caps.dwCaps3 |= NVOCCAPS3_DELIVERYCONTROL;
        }
        lpOCData->caps.dwCaps3 |= NVOCCAPS3_BLTCAPS;

        // TODO: figure out whether this is an SMA configuration
        lpOCData->caps.dwCaps4 |= NVOCCAPS4_IMB;
        if (vpp.dwOverlaySurfaces) {
            // set if this device has an open overlay
            lpOCData->caps.dwCaps4 |= NVOCCAPS4_DEVICEHASOVL;
        }
        lpOCData->caps.dwCaps4 |= (pDriverData->dwHeads & 0xF) << 16;
        lpOCData->caps.dwCaps4 |= (pDriverData->dwDesktopState & 0xF) << 20;

        for (i = 0; i < (int)pDriverData->dwHeads; i++) {
            displayParams[i].Head = i;
            NvRmConfigGetEx(pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                            NV_CFGEX_GET_DISPLAY_TYPE_MULTI,
                            &displayParams[i], sizeof(displayParams));
        }
        lpOCData->caps.dwCaps4 |= (displayParams[0].Type & 0xF) << 24;
        if (pDriverData->dwHeads > 1) {
            lpOCData->caps.dwCaps4 |= (displayParams[1].Type & 0xF) << 28;
        }

        lpOCData->caps.dwCaps5 |= NVOCCAPS5_BLT_YUV9_2_YUV422
                               |  NVOCCAPS5_BLT_YUV12_2_YUV422
                               |  NVOCCAPS5_BLT_YC12_2_YUV422
                               |  NVOCCAPS5_BLT_YUV422_2_YUV422
                               |  NVOCCAPS5_BLT_YUV422_2_RGB16
                               |  NVOCCAPS5_BLT_YUV422_2_RGB32
                               |  NVOCCAPS5_BLT_RGB16_2_RGB32
                               |  NVOCCAPS5_BLT_RGB32_2_RGB32
                               |  NVOCCAPS5_BLT_SYUV2VYUV
                               |  NVOCCAPS5_BLT_VYUV2SYUV
                               |  NVOCCAPS5_BLT_SYUV2VRGB
                               |  NVOCCAPS5_BLT_VYUV2VRGB
                               |  NVOCCAPS5_BLT_SRGB2VRGB
                               |  NVOCCAPS5_BLT_VRGB2VRGB
                               |  NVOCCAPS5_BLT_2RGBTEX;
        return NVOCERR_OK;

    case NVOCCMD_SETCOLORCONTROL:
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            // NV10 ranges
            if (lpOCData->ccData.dwCCFlags & NVOCCC_CONTRAST) {
                vpp.colorCtrl.lContrast = min(max(lpOCData->ccData.lContrast * 20000 / 200, 0), 20000);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_BRIGHTNESS) {
                vpp.colorCtrl.lBrightness = min(max(lpOCData->ccData.lBrightness * 10000 / 255, -10000), 10000);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_HUE) {
                vpp.colorCtrl.lHue = lpOCData->ccData.lHue;
                while (vpp.colorCtrl.lHue < -180) vpp.colorCtrl.lHue += 360;
                while (vpp.colorCtrl.lHue >= 180) vpp.colorCtrl.lHue -= 360;
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_SATURATION) {
                vpp.colorCtrl.lSaturation = min(max(lpOCData->ccData.lSaturation * 20000 / 200, 0), 20000);
            }
            VppSetOverlayColourControl(&vpp);
        } else {
            // NV4/5 ranges
            if (lpOCData->ccData.dwCCFlags & NVOCCC_CONTRAST) {
                vpp.colorCtrl.lContrast = min(max(lpOCData->ccData.lContrast * 511 / 200, 0), 511);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_BRIGHTNESS) {
                vpp.colorCtrl.lBrightness = min(max(lpOCData->ccData.lBrightness, -256), 255);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_HUE) {
                vpp.colorCtrl.lHue = lpOCData->ccData.lHue;
                while (vpp.colorCtrl.lHue < 0)    vpp.colorCtrl.lHue += 360;
                while (vpp.colorCtrl.lHue >= 360) vpp.colorCtrl.lHue -= 360;
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_SATURATION) {
                vpp.colorCtrl.lSaturation = min(max(lpOCData->ccData.lSaturation * 512 / 200, 0), 512);
            }
            vpp.regOverlayColourControlEnable    = lpOCData->ccData.dwEnable;
        }
        return NVOCERR_OK;

    case NVOCCMD_GETCOLORCONTROL:
        lpOCData->ccData.dwCCFlags = NVOCCC_CONTRAST |
                                     NVOCCC_BRIGHTNESS |
                                     NVOCCC_HUE |
                                     NVOCCC_SATURATION;
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            // NV10 ranges
            lpOCData->ccData.lContrast = vpp.colorCtrl.lContrast / 100;
            lpOCData->ccData.lBrightness = vpp.colorCtrl.lBrightness * 255 / 10000;
            lpOCData->ccData.lHue = vpp.colorCtrl.lHue;
            lpOCData->ccData.lSaturation = vpp.colorCtrl.lSaturation / 100;
            lpOCData->ccData.dwEnable = 3;
        } else {
            // NV4/5 ranges
            lpOCData->ccData.lContrast = vpp.colorCtrl.lContrast * 200 / 511;
            lpOCData->ccData.lBrightness = vpp.colorCtrl.lBrightness;
            lpOCData->ccData.lHue = vpp.colorCtrl.lHue;
            lpOCData->ccData.lSaturation = vpp.colorCtrl.lSaturation * 200 / 512;
            lpOCData->ccData.dwEnable = vpp.regOverlayColourControlEnable;
        }
        return NVOCERR_OK;

    case NVOCCMD_SETFEATURE:
        // turn on high quality vertical upscaling
        if (lpOCData->featureData.dwFeature1 & NVOCF1_HQVUPSCALE) {
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                return NVOCERR_NOT_SUPPORTED;
            }
            /*
            if (pDriverData->dwOverlaySurfaces > 0 &&
               (pDriverData->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)==0) {
                // if an overlay app is already running, and we are going from off to on,
                // no can do, must quit app first
                return NVOCERR_ALREADY_ACTIVE;
            }
            */
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_VUPSCALE;
        }
        // turn on temporal filtering
        if (lpOCData->featureData.dwFeature1 & NVOCF1_TFILTER) {
            if (lpOCData->featureData.lCoefficient[0] < 0 ||
                lpOCData->featureData.lCoefficient[0] > 255) {
                return NVOCERR_INVALID_PARMS;
            }
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_TFILTER;
            vpp.regOverlayMode &= ~0xFF00;
            vpp.regOverlayMode |= lpOCData->featureData.lCoefficient[0] << 8;
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_NOTFIRST;  // first frame
            if (lpOCData->dwCmdFlags & NVOCF_TF_PRECOPY) {
                vpp.regOverlayMode |= NV4_REG_OVL_MODE_TF_PRECOPY;
            } else {
                vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TF_PRECOPY;
            }
        }
        // turn on deinterlace filter
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DFILTER) {
            if (lpOCData->featureData.lCoefficient[1] < 0 ||
                lpOCData->featureData.lCoefficient[1] > 255) {
                return NVOCERR_INVALID_PARMS;
            }
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_DFILTER;
            vpp.regOverlayMode &= ~0xFF0000;
            vpp.regOverlayMode |= lpOCData->featureData.lCoefficient[1] << 16;
            if (lpOCData->dwCmdFlags & NVOCF_DF_PRECOPY) {
                vpp.regOverlayMode |= NV4_REG_OVL_MODE_DF_PRECOPY;
            } else {
                vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DF_PRECOPY;
            }
        }
        // turn on fullscreen mirror
        if (lpOCData->featureData.dwFeature1 & NVOCF1_FSMIRROR) {
            DWORD vppInvMaskSave;
            BOOL bNewDevice = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) != (DWORD)(lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSDEVICEMASK);
            if (vpp.dwOverlayFSNumSurfaces == 0 || bNewDevice ||
               (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSASPECTMASK) != (DWORD)(lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSASPECTMASK)) {
                // only reenable if already disabled, or aspect, or device change
                vpp.regOverlayMode2 = (vpp.regOverlayMode2 & ~NV4_REG_OVL_MODE2_FSMASK) |
                                               (lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSMASK);
                if (vpp.dwOverlaySurfaces) {
                    vppInvMaskSave = vpp.regVPPInvMask;
                    vpp.regVPPInvMask = 0xFFFFFFFF;    // shut off VPP pipe
#if IS_WINNT4
                    nvSpin(vpp.pSysInfo->dwSpinLoopCount * 3);
#else
                    Sleep(VPP_TIMEOUT_TIME * 3);                // make sure all flips are flushed
#endif
                    VppDestroyFSMirror(&vpp);
                    if (bNewDevice) {
                        // device changed, we need to reinstantiate the overlay too
                        VppDestroyOverlay(&vpp);
                        VppCreateOverlay(&vpp);
#ifndef WINNT
                        pmDeleteAllProcesses(pDriverData);
                        pmAddProcess(pDriverData, GetCurrentProcessId());
#endif
                    }
                    VppCreateFSMirror(&vpp, vpp.dwOverlayFSSrcWidth, vpp.dwOverlayFSSrcHeight);
                    vpp.regVPPInvMask = vppInvMaskSave;    // turn on VPP pipe again
                }
                if (bNewDevice && pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&
                   (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) == 0) {
                    // user has just disabled video mirror in clone mode, we must now tag all overlays as lost
                    vpp.dwOverlayFSOvlLost = TRUE;
                }
            } else {
                vpp.regOverlayMode2 = (vpp.regOverlayMode2 & ~NV4_REG_OVL_MODE2_FSMASK) |
                                               (lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSMASK);
            }
        }
        // turn on overlay zoom
        if (lpOCData->featureData.dwFeature1 & NVOCF1_OVLZOOM) {
            vpp.regOverlayMode3 = (vpp.regOverlayMode3 & ~NV4_REG_OVL_MODE3_OVLZOOMMASK) |
                                           (lpOCData->featureData.lCoefficient[5] & NV4_REG_OVL_MODE3_OVLZOOMMASK);
        }
        // turn on frame delivery control
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DELIVERYCONTROL) {
            NvNotification *pPioFlipOverlayNotifier = vpp.m_obj_a[OVERLAY_NDX].notifier_a;
            volatile NvNotification *pTimerNotifier = vpp.m_obj_a[TIMER_NDX].notifier_a;
            
            nvAssert(pTimerNotifier != NULL);

            vpp.llDeliveryPeriod = (__int64)lpOCData->featureData.lCoefficient[6] | 
                                              ((__int64)lpOCData->featureData.lCoefficient[7] << 32);

            // stop current timer
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_STOP_TRANSFER | 0x40000);
            vpp.pPusher->push(3, NV004_STOP_TRANSFER_VALUE);
            vpp.pPusher->adjust(4);
            vpp.pPusher->start(TRUE);

            // get current time
            while (pTimerNotifier->status == NV_IN_PROGRESS);
            pTimerNotifier->status = NV_IN_PROGRESS;
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME_RELATIVE | 0x80000);
            vpp.pPusher->push(3, 1); // wait a token nanosecond
            vpp.pPusher->push(4, 0);
            vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
            vpp.pPusher->push(6, NV004_SET_ALARM_NOTIFY_WRITE_ONLY);
            vpp.pPusher->adjust(7);
            vpp.pPusher->start(TRUE);
            pDriverData->dDrawSpareSubchannelObject = NV_VPP_TIMER_IID;
            while (pTimerNotifier->status == NV_IN_PROGRESS);
            vpp.llDeliveryStart = (__int64)pTimerNotifier->timeStamp.nanoseconds[0] |
                                             ((__int64)pTimerNotifier->timeStamp.nanoseconds[1] << 32);

            // next frame will be delivered at this time
            vpp.llDeliveryTime = vpp.llDeliveryStart + vpp.llDeliveryPeriod;

            // return pointers to overlay flip timecodes
            lpOCData->featureData.lCoefficient[6] = (long) &(pPioFlipOverlayNotifier[1].timeStamp.nanoseconds[0]);
            lpOCData->featureData.lCoefficient[7] = (long) &(pPioFlipOverlayNotifier[2].timeStamp.nanoseconds[0]);
        }
        // turn on late flip sync
        if (lpOCData->featureData.dwFeature1 & NVOCF1_LATEFLIPSYNC) {
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_LATEFLIPSYNC;
        }
        // set maximum number of VPP work surfaces
        if (lpOCData->featureData.dwFeature2 & NVOCF2_VPPMAXSURFACES) {
            vpp.regVPPMaxSurfaces = lpOCData->featureData.lCoefficient[2];
        }
        return NVOCERR_OK;

    case NVOCCMD_RESETFEATURE:
        if (lpOCData->featureData.dwFeature1 & NVOCF1_HQVUPSCALE) {
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_TFILTER) {
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
            vpp.regOverlayMode |= 0xFF00;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DFILTER) {
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
            vpp.regOverlayMode |= 0xFF0000;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_FSMIRROR) {
            DWORD vppInvMaskSave = vpp.regVPPInvMask;
            vpp.regVPPInvMask = 0xFFFFFFFF;    // shut off VPP pipe
#if IS_WINNT4
            nvSpin(vpp.pSysInfo->dwSpinLoopCount * 3);
#else
            Sleep(VPP_TIMEOUT_TIME * 3);                // make sure all flips are flushed
#endif
            vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSMASK;
            VppDestroyFSMirror(&vpp);
            vpp.regVPPInvMask = vppInvMaskSave;    // turn on VPP pipe again
            if (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
                // user has just disabled video mirror in clone mode, we must now tag all overlays as lost
                vpp.dwOverlayFSOvlLost = TRUE;
            }
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_OVLZOOM) {
            vpp.regOverlayMode3 &= ~NV4_REG_OVL_MODE3_OVLZOOMMASK;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DELIVERYCONTROL) {
            vpp.llDeliveryPeriod = 0;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_LATEFLIPSYNC) {
            vpp.regOverlayMode &= NV4_REG_OVL_MODE_LATEFLIPSYNC;
        }
        return NVOCERR_OK;

    case NVOCCMD_GETFEATURE:
        lpOCData->featureData.dwFeature1 = 0;
        lpOCData->featureData.dwFeature2 = 0;
        lpOCData->featureData.dwFeature3 = 0;
        lpOCData->featureData.dwFeature4 = 0;
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_HQVUPSCALE;
        }
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_TFILTER) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_TFILTER;
            lpOCData->featureData.lCoefficient[0] = (vpp.regOverlayMode >> 8) & 0xFF;
        }
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_DFILTER) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_DFILTER;
            lpOCData->featureData.lCoefficient[1] = (vpp.regOverlayMode >> 16) & 0xFF;
        }
        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_FSMIRROR;
            lpOCData->featureData.lCoefficient[4] = vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSMASK;
        }
        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_OVLZOOM;
            lpOCData->featureData.lCoefficient[5] = vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMMASK;
        }
        if (vpp.llDeliveryPeriod != 0) {
            NvNotification *pPioFlipOverlayNotifier = vpp.m_obj_a[OVERLAY_NDX].notifier_a;
            lpOCData->featureData.dwFeature1 |= NVOCF1_DELIVERYCONTROL;
            lpOCData->featureData.lCoefficient[6] = (DWORD)vpp.llDeliveryPeriod;
            lpOCData->featureData.lCoefficient[7] = (DWORD)(vpp.llDeliveryPeriod >> 32);
            lpOCData->featureData.lCoefficient[8]  = pPioFlipOverlayNotifier[1].timeStamp.nanoseconds[0];
            lpOCData->featureData.lCoefficient[9]  = pPioFlipOverlayNotifier[1].timeStamp.nanoseconds[1];
            lpOCData->featureData.lCoefficient[10] = pPioFlipOverlayNotifier[2].timeStamp.nanoseconds[0];
            lpOCData->featureData.lCoefficient[11] = pPioFlipOverlayNotifier[2].timeStamp.nanoseconds[1];
        }
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_LATEFLIPSYNC) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_LATEFLIPSYNC;
        }
        lpOCData->featureData.dwFeature2 = NVOCF2_VPPMAXSURFACES;
        lpOCData->featureData.lCoefficient[2] = vpp.regVPPMaxSurfaces;
        lpOCData->featureData.lCoefficient[3] = vpp.extraNumSurfaces;
        return NVOCERR_OK;

    default:
        return NVOCERR_BAD_COMMAND;
    }
}

#if (IS_WIN9X || IS_WINNT5)

// -----------------------------------------------------------------------------
// nvMoComp
//      Copies system YC12 data to video yuv422.  Returns error code
//      Event is shared with OCC.  Could affect QUERY_IDLE or WAIT_FOR_IDLE
//      Commands:
//          NOOP - Does nothing
//          INIT - Creates system memory DMA context and attaches it to necessary objects
//          RELEASE - Kills DMA context
//          BLIT - Does the system to video blit
//          QUERY_IDLE - Returns BUSY or OK
//          WAIT_FOR_IDLE - Waits for event to trigger

NVS2VERROR __stdcall nvMoComp(LPNVS2VDATATYPE lpS2VData)
{
NvNotification *dmaPusherSyncNotifier;
DWORD dwDstYOffset, dwDstCOffset, dwSrcYOffset, dwSrcCOffset, dwSrcUOffset, dwSrcVOffset, dwSurfSize;
DWORD dwFourCC, dwVPPFlags;
LPDDRAWI_DDRAWSURFACE_INT lpDstSurf;
FLATPTR fpDstSys;
static DWORD dwYPhase = 0;
static FLATPTR fpSrcSurf[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static FLATPTR fpDstSurf[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
LPPROCESSINFO lpProcInfo;
GLOBALDATA* pDriverData = NULL;          // override global pDriverData
DWORD dwSrcContextDma, dwDstContextDma;

    if (lpS2VData->dwSize < sizeof(NVS2VDATATYPE) || lpS2VData->dwSize > 4096)
        return NVS2VERR_INVALID_PARMS;

    pDriverData = getGlobalDataPtr(lpS2VData->dwDevice);
    if (pDriverData == NULL) {
        return NVS2VERR_BAD_DEVICE;
    }
    Vpp_t &vpp = pDriverData->vpp;

    lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

    dmaPusherSyncNotifier = pDriverData->pDmaPusherSyncNotifierFlat;

    switch (lpS2VData->dwCmd) {
// ************************************************************************
    case NVS2VCMD_BLIT:
// ************************************************************************

		// This sometimes uses the VPP_DMABLT_TO_VID object... which is only ready for use if 
		// we've gotten vppEnable()
		nvAssert(vpp.dwFlags & VPP_FLAG_ENABLED);

		if (!(vpp.dwFlags & VPP_FLAG_ENABLED))
		{
			return NVS2VERR_NOT_READY;
		}

        if (lpS2VData->dwIndex >= 16)
            return NVS2VERR_INVALID_PARMS;

        if (vpp.regVPPInvMask & (NV4_REG_VPP_DMABLIT_DISABLE | NV4_REG_VPP_MASTER_DISABLE)) {
            return NVS2VERR_OK;
        }

        switch (lpS2VData->dwDstType) {
        case NVS2V_RGB32:
        case NVS2V_RGB16:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            fpDstSys = (FLATPTR) lpS2VData->fpDst;
            dwYPhase = 0;
            break;

        case NVS2V_YUYV:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            fpDstSys = (FLATPTR) lpS2VData->fpDst;
            dwYPhase = 0;
            break;

        case NVS2V_UYVY:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            fpDstSys = (FLATPTR) lpS2VData->fpDst;
            dwYPhase = 1;
            break;

        case NVS2V_DDSURF:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            lpDstSurf = (LPDDRAWI_DDRAWSURFACE_INT) lpS2VData->lpDstDirectDrawSurface;
            if (lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY ||
                lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYNV) {
                dwYPhase = 1;
            } else {
                dwYPhase = 0;
            }
            fpDstSys = lpDstSurf->lpLcl->lpGbl->fpVidMem;
            break;

        case NVS2V_INDEXED:
            dwSurfSize = lpS2VData->dwDstSize;
            fpDstSys = fpDstSurf[lpS2VData->dwIndex];
            dwYPhase = 0;
            break;

        default:
            return NVS2VERR_INVALID_PARMS;
        }

        if (lpS2VData->dwDstFlags & NVS2VF_SYSTEM) {
            FLATPTR fpSrcSys = (FLATPTR)lpS2VData->fpSrc;

            if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET)
                fpSrcSys += pDriverData->BaseAddress;

            if (fpSrcSys < pDriverData->BaseAddress ||
               (fpSrcSys + dwSurfSize) >= (pDriverData->BaseAddress + pDriverData->TotalVRAM))
                return NVS2VERR_INVALID_PARMS;

            dwSrcContextDma = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
            dwDstContextDma = NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex;
            dwDstYOffset = dwDstCOffset = fpDstSys - fpSrcSurf[lpS2VData->dwIndex];
            dwDstYOffset += dwYPhase;
            dwDstCOffset += dwYPhase ^ 1;
            if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET) {
                dwSrcYOffset = (FLATPTR)lpS2VData->SrcYC12.fpY;
                dwSrcCOffset = (FLATPTR)lpS2VData->SrcYC12.fpC;
                dwSrcUOffset = (FLATPTR)lpS2VData->SrcYUV12.fpU;
                dwSrcVOffset = (FLATPTR)lpS2VData->SrcYUV12.fpV;
            } else {
                dwSrcYOffset = (FLATPTR)lpS2VData->SrcYC12.fpY - pDriverData->BaseAddress;
                dwSrcCOffset = (FLATPTR)lpS2VData->SrcYC12.fpC - pDriverData->BaseAddress;
                dwSrcUOffset = (FLATPTR)lpS2VData->SrcYUV12.fpU - pDriverData->BaseAddress;
                dwSrcVOffset = (FLATPTR)lpS2VData->SrcYUV12.fpV - pDriverData->BaseAddress;
            }
        } else {
            if (lpS2VData->dwDstFlags & NVS2VF_OFFSET)
                fpDstSys += pDriverData->BaseAddress;

            if (fpDstSys < pDriverData->BaseAddress ||
               (fpDstSys + dwSurfSize) >= (pDriverData->BaseAddress + pDriverData->TotalVRAM))
                return NVS2VERR_INVALID_PARMS;

            dwSrcContextDma = NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex;
            dwDstContextDma = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
            dwDstYOffset = dwDstCOffset = fpDstSys - pDriverData->BaseAddress;
            dwDstYOffset += dwYPhase;
            dwDstCOffset += dwYPhase ^ 1;
            dwSrcYOffset = (FLATPTR)lpS2VData->SrcYC12.fpY - fpSrcSurf[lpS2VData->dwIndex];
            dwSrcCOffset = (FLATPTR)lpS2VData->SrcYC12.fpC - fpSrcSurf[lpS2VData->dwIndex];
            dwSrcUOffset = (FLATPTR)lpS2VData->SrcYUV12.fpU - fpSrcSurf[lpS2VData->dwIndex];
            dwSrcVOffset = (FLATPTR)lpS2VData->SrcYUV12.fpV - fpSrcSurf[lpS2VData->dwIndex];
        }

        switch (lpS2VData->dwSrcType) {
        case NVS2V_YC12:
        case NVS2V_YUV12:
        case NVS2V_YV12:
            // move luma
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcYOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstYOffset);                        // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);               // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch);              // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth);                 // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight);                // LineCount
            vpp.pPusher->push (13, 0x201);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);
            break;

        case NVS2V_YUYV:
        case NVS2V_UYVY:
        case NVS2V_RGB32:
        case NVS2V_RGB16:
            // move all

            VppResetNotification(
                &vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1],
                lpProcInfo->hDMABlitToVid3
                );

            // NvResetEvent(lpProcInfo->hDMABlitToVid3);
            // pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, vpp.m_obj_a[DMABLT_TO_VID_NDX].contextIID); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                         // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                         // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcYOffset);                            // OffsetIn
            vpp.pPusher->push (8, dwDstYOffset);                            // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);                   // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch);                  // PitchOut
            if (lpS2VData->dwSrcType == NVS2V_RGB32) {
                vpp.pPusher->push (11, lpS2VData->dwWidth << 2);            // LineLengthIn
            } else {
                vpp.pPusher->push (11, lpS2VData->dwWidth << 1);            // LineLengthIn
            }
            vpp.pPusher->push (12, lpS2VData->dwHeight);                    // LineCount
            vpp.pPusher->push (13, 0x101);                                  // Format
            vpp.pPusher->push (14, VPP_NOTIFY_TYPE);                        // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID;
            break;

        default:
            return NVS2VERR_INVALID_PARMS;
        }

        // move chroma
        switch (lpS2VData->dwSrcType) {
        case NVS2V_YUYV:
        case NVS2V_UYVY:
        case NVS2V_RGB32:
        case NVS2V_RGB16:
            // already moved everything
            break;

        case NVS2V_YC12:
            // move chroma, even lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcCOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset);                        // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);               // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth);                 // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x201);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

//            NvResetEvent(lpProcInfo->hDMABlitToVid3);
//            pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
            VppResetNotification(
                &vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1],
                lpProcInfo->hDMABlitToVid3
                );

            // move chroma, odd lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, vpp.m_obj_a[DMABLT_TO_VID_NDX].contextIID); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                         // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                         // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcCOffset);                            // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + lpS2VData->dwDstPitch);    // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);                   // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);             // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth);                     // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);               // LineCount
            vpp.pPusher->push (13, 0x201);                                  // Format
            vpp.pPusher->push (14, VPP_NOTIFY_TYPE);                        // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID;
            break;

        case NVS2V_YUV12:
        case NVS2V_YV12:
            // move U, even lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcUOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset);                        // OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);      // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch); // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);            // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x401);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            // move V, even lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcVOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + 2);                    // OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);      // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch); // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);            // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x401);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            // move U, odd lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcUOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + lpS2VData->dwDstPitch);// OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);      // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch); // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);            // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x401);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

//            NvResetEvent(lpProcInfo->hDMABlitToVid3);
//            pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
            VppResetNotification(
                &vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1],
                lpProcInfo->hDMABlitToVid3
                );

            // move V, odd lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, vpp.m_obj_a[DMABLT_TO_VID_NDX].contextIID); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                         // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                         // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcVOffset);                            // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + lpS2VData->dwDstPitch + 2);// OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);          // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch);     // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);             // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);                // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);               // LineCount
            vpp.pPusher->push (13, 0x401);                                  // Format
            vpp.pPusher->push (14, VPP_NOTIFY_TYPE);                       // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID;
            break;

        default:
            return NVS2VERR_INVALID_PARMS;
        }

        // TBD: how do we get here with no event?  Is that normal?  How 
        // do I distinguish the case where we have no events period.
        if (lpS2VData->bWaitForCompletion) {

#ifdef VPP_USE_EVENT_NOTIFIERS
            if (lpProcInfo && lpProcInfo->hDMABlitToVid3) {

                if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hDMABlitToVid3, lpS2VData->dwTimeoutTime))) {
                    EVENT_ERROR;
                    return NVS2VERR_TIMEOUT;
                }
            } else {
                while (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS) 
                {
#if IS_WINNT4
                    nvSpin(vpp.pSysInfo->dwSpinLoopCount); // TBD: is this right? @mjl@
#else
                    Sleep(0);
#endif
                }
                return NVS2VERR_NO_EVENT;
            }
#else
            if (VppWaitForNotification(&vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1], lpProcInfo->hDMABlitToVid3,lpS2VData->dwTimeoutTime))
            {
                EVENT_ERROR;
                return NVS2VERR_TIMEOUT;
            }

#endif // USE EVENT NOTIFIERS
        }
        return NVS2VERR_OK;
// ************************************************************************
    case NVS2VCMD_INIT:
// ************************************************************************
        DWORD dwPitch;
        PVOID fpSys;
        NVS2VSURFTYPE surfType;

        if (lpS2VData->dwIndex >= 16)
            return NVS2VERR_INVALID_PARMS;

        if (lpS2VData->dwDstFlags & NVS2VF_SYSTEM) {
            // system surface they want to initialize is in destination
            dwPitch = lpS2VData->dwDstPitch;
            fpSys = lpS2VData->DstYC12.fpY;
            surfType = lpS2VData->dwDstType;
        } else {
            // system surface they want to initialize is in source
            dwPitch = lpS2VData->dwSrcPitch;
            fpSys = lpS2VData->SrcYC12.fpY;
            surfType = lpS2VData->dwSrcType;
        }

        switch (surfType) {
        case NVS2V_YC12:
        case NVS2V_YUV12:
        case NVS2V_YV12:
            dwSurfSize = dwPitch * lpS2VData->dwHeight * 3 / 2;
            break;
        case NVS2V_YUYV:
        case NVS2V_UYVY:
        case NVS2V_RGB16:
        case NVS2V_RGB32:
            dwSurfSize = dwPitch * lpS2VData->dwHeight;
            break;
        default:
            return NVS2VERR_INVALID_PARMS;
        }
        dwSurfSize += 4096;     // to prevent MTMF fault

        if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                fpSys,
                                (dwSurfSize - 1)) == 0) {

            // cache surface pointer
            fpSrcSurf[lpS2VData->dwIndex] = (FLATPTR) fpSys;

            // cache destination surface pointer (only used for indexed blits)
            switch (lpS2VData->dwDstType) {
            case NVS2V_YUYV:
                fpDstSurf[lpS2VData->dwIndex] = (FLATPTR) lpS2VData->fpDst;
                dwYPhase = 0;
                break;

            case NVS2V_UYVY:
                fpDstSurf[lpS2VData->dwIndex] = (FLATPTR) lpS2VData->fpDst;
                dwYPhase = 1;
                break;

            case NVS2V_DDSURF:
                lpDstSurf = (LPDDRAWI_DDRAWSURFACE_INT) lpS2VData->lpDstDirectDrawSurface;
                if (lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY ||
                    lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYNV) {
                    dwYPhase = 1;
                } else {
                    dwYPhase = 0;
                }
                fpDstSurf[lpS2VData->dwIndex] = lpDstSurf->lpLcl->lpGbl->fpVidMem;
                break;
            }
            if (lpS2VData->dwDstFlags & NVS2VF_OFFSET)
                fpDstSurf[lpS2VData->dwIndex] += pDriverData->BaseAddress;

            if (!lpProcInfo || lpProcInfo->hDMABlitToVid3 == 0 || lpProcInfo->hDMABlitToVid0 == 0)
                return NVS2VERR_NO_EVENT;
            return NVS2VERR_OK;
        } else
            return NVS2VERR_INIT_FAILED;

// ************************************************************************
    case NVS2VCMD_RELEASE:
// ************************************************************************
        if (lpS2VData->dwIndex >= 16)
            return NVS2VERR_INVALID_PARMS;

        fpSrcSurf[lpS2VData->dwIndex] = 0;
        fpDstSurf[lpS2VData->dwIndex] = 0;

        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex);
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_QUERY_IDLE:
// ************************************************************************
        if (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS)
            return NVS2VERR_BUSY;
        else
            return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_WAIT_FOR_IDLE:
// ************************************************************************
        if (lpProcInfo && lpProcInfo->hDMABlitToVid3) {
            if (!IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hDMABlitToVid3, lpS2VData->dwTimeoutTime))) {
                return NVS2VERR_OK;
            } else {
                EVENT_ERROR;
                return NVS2VERR_TIMEOUT;
            }
        } else {
            while (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS)
            {
#if IS_WINNT4
                    nvSpin(vpp.pSysInfo->dwSpinLoopCount); // TBD: is this right? @mjl@
#else
                    Sleep(0);
#endif
            };
            return NVS2VERR_NO_EVENT;
        }

// ************************************************************************
    case NVS2VCMD_SET_SUBPICTURE:
// ************************************************************************
        if (lpS2VData->fpSP == 0) {
            // disable subpicture
            vpp.subPicture.offset = 0;
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                vpp.subPicture.format = NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
            } else {
                vpp.subPicture.format = NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
            }
            return NVS2VERR_OK;
        }
        if (lpS2VData->dwSPType == NVS2V_YUVA16) {
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                vpp.subPicture.format = NV038_OVERLAY_FORMAT_COLOR_LE_A4V6YB6A4U6YA6;
            } else {
                vpp.subPicture.format = NV088_OVERLAY_FORMAT_COLOR_LE_A4CR6YB6A4CB6YA6;
            }
        } else if (lpS2VData->dwSPType == NVS2V_YUVA32) {
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                vpp.subPicture.format = NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8;
            } else {
                vpp.subPicture.format = NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8;
            }
        } else {
            return NVS2VERR_INVALID_PARMS;
        }
        if (lpS2VData->dwSPFlags & NVS2VF_OFFSET) {
            vpp.subPicture.offset = lpS2VData->fpSP;
        } else {
            vpp.subPicture.offset = lpS2VData->fpSP - pDriverData->BaseAddress;
        }
        vpp.subPicture.pitch = lpS2VData->dwSPPitch;
        if (lpS2VData->dwSPFlags & NVS2VF_SP_SUBRECT) {
            vpp.subPicture.pitch  |= NVS2VF_SP_SUBRECT;
            vpp.subPicture.originX = lpS2VData->dwSubRectX;
            vpp.subPicture.originY = lpS2VData->dwSubRectY;
            vpp.subPicture.width   = lpS2VData->dwSubRectWidth;
            vpp.subPicture.height  = lpS2VData->dwSubRectHeight;
        } else {
            vpp.subPicture.originX = 0xFFFFFFFF;
            vpp.subPicture.originY = 0xFFFFFFFF;
            vpp.subPicture.width   = 0xFFFFFFFF;
            vpp.subPicture.height  = 0xFFFFFFFF;
        }
        if (lpS2VData->dwSPFlags & NVS2VF_SP_ODD) {
            vpp.subPicture.pitch |= NVS2VF_SP_ODD;
        }
        if (lpS2VData->dwSPFlags & NVS2VF_SP_EVEN) {
            vpp.subPicture.pitch |= NVS2VF_SP_EVEN;
        }
        if ((lpS2VData->dwSPFlags & (NVS2VF_SP_ODD | NVS2VF_SP_EVEN)) == 0) {
            vpp.subPicture.pitch |= NVS2VF_SP_ODD | NVS2VF_SP_EVEN;
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_VPP_START:
// ************************************************************************
        if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET) {
            dwSrcYOffset = (DWORD) lpS2VData->fpSrc;
        } else {
            dwSrcYOffset = (DWORD) lpS2VData->fpSrc - pDriverData->BaseAddress;
        }
        switch (lpS2VData->dwSrcType) {
        case NVS2V_YUYV: dwFourCC = FOURCC_YUY2; break;
        case NVS2V_UYVY: dwFourCC = FOURCC_UYVY; break;
        default: return NVS2VERR_INVALID_PARMS;
        }
        dwVPPFlags = VPP_ALL | VPP_SAVE_STATE;
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_ODD) {
            dwVPPFlags |= VPP_ODD;
        }
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_EVEN) {
            dwVPPFlags |= VPP_EVEN;
        }
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_BOB) {
            dwVPPFlags |= VPP_BOB;
        }
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED;
        }
        VppDoFlip(&(vpp),dwSrcYOffset, lpS2VData->dwSrcPitch, lpS2VData->dwWidth, lpS2VData->dwHeight, dwFourCC, dwVPPFlags);
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_VPP_QUERY:
// ************************************************************************
        if (vpp.pipeState.dwOpCount > 0 && vpp.pipeState.hLastStage) {
            if (IS_EVENT_ERROR(NvWaitEvent(vpp.pipeState.hLastStage, 0))) {
                return NVS2VERR_BUSY;
            }
        } else if (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS) {
            // wait for any DMA blits to flush out before processing
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hDMABlitToVid3, 0))) {
                return NVS2VERR_BUSY;
            }
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_VPP_FLIP:
// ************************************************************************
        VppDoFlip(&(vpp),0, 0, 0, 0, 0, VPP_RESTORE_STATE);
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_4CC_TO_VRGB:
// ************************************************************************
        DWORD dwSrcOffset, dwDstOffset;
        DWORD dwSrcFormat, dwDstFormat;
        DWORD dwSrcSize, dwDstSize;
        DWORD dwDeltaX, dwDeltaY;
        DWORD dwCombinedPitch;
        DWORD dwSrcContextDma;

        if ((lpS2VData->dwDstFlags & NVS2VF_SYSTEM) ||
            (lpS2VData->dwSrcFlags & NVS2VF_SWIZZLED)) {
            return NVS2VERR_INVALID_PARMS;
        }

        pDriverData->blitCalled = TRUE;
        pDriverData->TwoDRenderingOccurred = 1;

        dwDeltaX = ((lpS2VData->dwWidth - 1) << 20)  / (lpS2VData->DstRGB.dwDstWidth - 1);    // 12.20 fixed point
        dwDeltaY = ((lpS2VData->dwHeight - 1) << 20)  / (lpS2VData->DstRGB.dwDstHeight - 1);    // 12.20 fixed point
        dwSrcSize = (lpS2VData->dwHeight << 16) | lpS2VData->dwWidth;
        dwDstSize = (lpS2VData->DstRGB.dwDstHeight << 16) | lpS2VData->DstRGB.dwDstWidth;

        // get surfaces info
        if (lpS2VData->dwIndex == 0xFFFFFFFF) {
            dwSrcContextDma = vpp.hInVideoMemContextDma;
            if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET) {
                dwSrcOffset = (DWORD)lpS2VData->fpSrc;
            } else {
                dwSrcOffset = VIDMEM_OFFSET((DWORD)lpS2VData->fpSrc);
            }
        } else {
            dwSrcContextDma = NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex;
            dwSrcOffset = 0;
        }
        if (lpS2VData->dwDstFlags & NVS2VF_OFFSET) {
            dwDstOffset = (DWORD)lpS2VData->fpDst;
        } else {
            dwDstOffset = VIDMEM_OFFSET((DWORD)lpS2VData->fpDst);
        }
        switch (lpS2VData->dwSrcType) {
        case NVS2V_YUYV:  dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8; break;
        case NVS2V_UYVY:  dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8; break;
        case NVS2V_RGB16: dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_R5G6B5;       break;
        case NVS2V_RGB32: dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_X8R8G8B8;     break;
        default:         return NVS2VERR_INVALID_PARMS;
        }

        if (lpS2VData->dwDstFlags & NVS2VF_SWIZZLED) {
            // swizzled
            DWORD dwLSBIndex, dwMSBIndex, dwLogWidth, dwLogHeight;

            // find log width
            dwLSBIndex = dwMSBIndex = lpS2VData->DstRGB.dwDstWidth;
            ASM_LOG2(dwLSBIndex);
            ASM_LOG2_R(dwMSBIndex);
            if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
            dwLogWidth = dwMSBIndex;

            // find log height
            dwLSBIndex = dwMSBIndex = lpS2VData->DstRGB.dwDstHeight;
            ASM_LOG2(dwLSBIndex);
            ASM_LOG2_R(dwMSBIndex);
            if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
            dwLogHeight = dwMSBIndex;

            // find surface format
            switch (lpS2VData->dwDstType) {
                case NVS2V_RGB16:  dwDstFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;    break;
                case NVS2V_RGB32:  dwDstFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;  break;
                default:           return NVS2VERR_INVALID_PARMS;
            }

            // set up swizzled surface
            // for now, assume destination is always in video memory
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, D3D_CONTEXT_SURFACE_SWIZZLED);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV052_SET_FORMAT | 0x80000);
            vpp.pPusher->push(3, dwDstFormat     |                     // SetFormat
                                  (dwLogWidth << 16) |
                                  (dwLogHeight << 24));
            vpp.pPusher->push(4, dwDstOffset);                         // SetOffset
            vpp.pPusher->adjust(5);

            // set mono pattern mask
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_DD_CONTEXT_PATTERN);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
            vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
            switch (lpS2VData->dwDstType) {
            case NVS2V_RGB32:
                vpp.pPusher->push(4,NV_ALPHA_1_032);
                vpp.pPusher->push(5,NV_ALPHA_1_032);
                break;
            case NVS2V_RGB16:
                vpp.pPusher->push(4,NV_ALPHA_1_016);
                vpp.pPusher->push(5,NV_ALPHA_1_016);
                break;
            default: return NVS2VERR_INVALID_PARMS;
            }
            vpp.pPusher->adjust(6);
            pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_PATTERN;
        } else {
            // not swizzled
            switch (lpS2VData->dwDstType) {
            case NVS2V_RGB16: dwDstFormat = NV063_SET_COLOR_FORMAT_LE_R5G6B5;   break;
            case NVS2V_RGB32: dwDstFormat = NV063_SET_COLOR_FORMAT_LE_X8R8G8B8; break;
            default:          return NVS2VERR_INVALID_PARMS;
            }
            dwCombinedPitch = (lpS2VData->dwDstPitch << 16) | lpS2VData->dwSrcPitch;
            if (lpS2VData->dwDstFlags & NVS2VF_SYSTEM) {
                dwCombinedPitch &= 0x0000FFFF;
                dwCombinedPitch |= dwCombinedPitch << 16;
            }
            if (lpS2VData->dwSrcFlags & NVS2VF_SYSTEM) {
                dwCombinedPitch &= 0xFFFF0000;
                dwCombinedPitch |= dwCombinedPitch >> 16;
            }
            if (pDriverData->bltData.dwLastColourFormat != dwDstFormat ||
                pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
                pDriverData->bltData.dwLastSrcOffset != dwSrcOffset ||
                pDriverData->bltData.dwLastDstOffset != dwDstOffset) {
                vpp.pPusher->push(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
                vpp.pPusher->push(1, dwDstFormat);     // SetColorFormat
                vpp.pPusher->push(2, dwCombinedPitch); // SetPitch
                vpp.pPusher->push(3, dwSrcOffset);     // SetSrcOffset
                vpp.pPusher->push(4, dwDstOffset);     // SetDstOffset
                vpp.pPusher->adjust(5);

                if (pDriverData->bltData.dwLastColourFormat != dwDstFormat) {
                    // set mono pattern mask
                    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
                    vpp.pPusher->push(1, NV_DD_CONTEXT_PATTERN);
                    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
                    vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
                    switch (lpS2VData->dwDstType) {
                    case NVS2V_RGB32:
                        vpp.pPusher->push(4,NV_ALPHA_1_032);
                        vpp.pPusher->push(5,NV_ALPHA_1_032);
                        break;
                    case NVS2V_RGB16:
                        vpp.pPusher->push(4,NV_ALPHA_1_016);
                        vpp.pPusher->push(5,NV_ALPHA_1_016);
                        break;
                    default: return NVS2VERR_INVALID_PARMS;
                    }
                    vpp.pPusher->adjust(6);
                    pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_PATTERN;
                }

                pDriverData->bltData.dwLastColourFormat = dwDstFormat;
                pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
                pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
                pDriverData->bltData.dwLastDstOffset = dwDstOffset;
            }
        }

        // update clip
        bltUpdateClip(pDriverData);

        // set blt state
        if (SRCCOPYINDEX != pDriverData->bltData.dwLastRop) {
            vpp.pPusher->push(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
            vpp.pPusher->push(1, SRCCOPYINDEX);
            vpp.pPusher->adjust(2);
            pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
        }
        // source key is disabled
        if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hContextColorKey);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
            vpp.pPusher->push(3, 0);
            vpp.pPusher->adjust(4);
            pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
            pDriverData->dDrawSpareSubchannelObject = vpp.hContextColorKey;
        }

        NvResetEvent(lpProcInfo->hFourCCBlt3);
        if (!lpProcInfo || !lpProcInfo->hFourCCBlt3) {
            vpp.pPusher->flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
            dmaPusherSyncNotifier->status = NV_IN_PROGRESS;
        }

        // frame delivery control
        if ((lpS2VData->dwCmdFlags & NVS2VF_USE_DELIVERY_CTL) &&
             vpp.llDeliveryPeriod != 0) {
            NvResetEvent(lpProcInfo->hTimer3);
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME | 0x80000);
            vpp.pPusher->push(3, (DWORD)(vpp.llDeliveryTime & 0x00000000FFFFFFFF));
            vpp.pPusher->push(4, (DWORD)(vpp.llDeliveryTime >> 32));
            vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
            vpp.pPusher->push(6, NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN);
            vpp.pPusher->adjust(7);
            vpp.pPusher->start(TRUE);
            pDriverData->dDrawSpareSubchannelObject = NV_VPP_TIMER_IID;
            vpp.llDeliveryTime += vpp.llDeliveryPeriod;
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hTimer3, lpS2VData->dwTimeoutTime))) {
                DPF(" *** TIMER event failure ***");
                EVENT_ERROR;
            }
        }

        // wait for the scanline to hit the right place
        if ((lpS2VData->dwCmdFlags & NVS2VF_CRTC_SYNC) && 
             getDC()->flipPrimaryRecord.nvTimingInfo[lpS2VData->dwHead].Head != 0xFFFFFFFF &&
            (vpp.pSysInfo->dwNVClasses & NVCLASS_0004_TIMER)) {
            NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
            DWORD dwScanDelta;
            __int64 llWaitTime;

            NvResetEvent(lpProcInfo->hTimer3);

            // get current scanline
            cfgParams.Head = lpS2VData->dwHead;
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));

            // calculate how many scanlines we have to wait for
            if (cfgParams.RasterPosition > lpS2VData->dwScanline) {
                dwScanDelta = lpS2VData->dwScanline + getDC()->flipPrimaryRecord.nvTimingInfo[lpS2VData->dwHead].VTotal - cfgParams.RasterPosition;
            } else {
                dwScanDelta = lpS2VData->dwScanline - cfgParams.RasterPosition;
            }

            // calculate how long that is in ns
            llWaitTime = (LONGLONG)dwScanDelta * getDC()->flipPrimaryRecord.llFlipDurationNs[lpS2VData->dwHead] / getDC()->flipPrimaryRecord.nvTimingInfo[lpS2VData->dwHead].VTotal;

            // Sleep and don't wake up until that time has elapsed
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME_RELATIVE | 0x80000);
            vpp.pPusher->push(3, (DWORD)(llWaitTime & 0x00000000FFFFFFFF));
            vpp.pPusher->push(4, (DWORD)(llWaitTime >> 32));
            vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
            vpp.pPusher->push(6, NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN);
            vpp.pPusher->adjust(7);
            vpp.pPusher->start(TRUE);
            pDriverData->dDrawSpareSubchannelObject = NV_VPP_TIMER_IID;
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hTimer3, lpS2VData->dwTimeoutTime))) {
                DPF(" *** TIMER event failure ***");
                EVENT_ERROR;
            }
        }

        // do the fourcc blit
        vpp.pPusher->push(0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
        vpp.pPusher->push(1, NV_VPP_SCALED_IMAGE2_IID);
        vpp.pPusher->push(2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
        vpp.pPusher->push(3, dwSrcContextDma);     // SetContextDmaImage
        vpp.pPusher->push(4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_SURFACE_OFFSET | 0x40000);
        if (lpS2VData->dwDstFlags & NVS2VF_SWIZZLED) {
            vpp.pPusher->push(5, D3D_CONTEXT_SURFACE_SWIZZLED);    // SetContextSurface
        } else {
            vpp.pPusher->push(5, NV_DD_SURFACES_2D);               // SetContextSurface
        }
        vpp.pPusher->push(6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
        vpp.pPusher->push(7, dwSrcFormat);         // SetColorFormat
        vpp.pPusher->push(8, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
        vpp.pPusher->push(9, 0);              // ClipPoint
        vpp.pPusher->push(10, dwDstSize);     // ClipSize
        vpp.pPusher->push(11, 0);             // ImageOutPoint
        vpp.pPusher->push(12, dwDstSize);     // ImageOutSize
        vpp.pPusher->push(13, dwDeltaX);      // DsDx
        vpp.pPusher->push(14, dwDeltaY);      // DtDy
        vpp.pPusher->push(15, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
        vpp.pPusher->push(16, dwSrcSize);     // ImageInSize
        vpp.pPusher->push(17, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                                    lpS2VData->dwSrcPitch);
        vpp.pPusher->push(18, dwSrcOffset);   // ImageInOffset
        vpp.pPusher->push(19, lpS2VData->dwSrcPixelBias);  // ImageInPoint
        vpp.pPusher->push(20, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_NOTIFY_OFFSET | 0x40000);
        vpp.pPusher->push(21, NV089_NOTIFY_WRITE_THEN_AWAKEN);
        vpp.pPusher->push(22, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_NO_OPERATION | 0x40000);
        vpp.pPusher->push(23, 0);
        vpp.pPusher->adjust(24);
        vpp.pPusher->start(TRUE);

        if (lpS2VData->bWaitForCompletion) {
            if (lpProcInfo && lpProcInfo->hFourCCBlt3) {
                if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hFourCCBlt3, lpS2VData->dwTimeoutTime))) {
                    EVENT_ERROR;
                    return NVS2VERR_TIMEOUT;
                }
            } else {
                vpp.pPusher->flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
                return NVS2VERR_NO_EVENT;
            }
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_GET_TEXTURE_OFFSET:
// ************************************************************************
        lpS2VData->fpTexture = (LPVOID) nvGetTextureFromSystemMemAddress(pDriverData, (FLATPTR)lpS2VData->fpTexture);
        if ((DWORD)lpS2VData->fpTexture == 0xFFFFFFFF) {
            return NVS2VERR_GENERIC_FATAL;
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_NOOP:
// ************************************************************************
        return NVS2VERR_OK;
    }

    return NVS2VERR_BAD_COMMAND;
}

#endif

// -----------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Sets the colour control for the hardware overlay.  This is a private
//      interface for changing the controls without owning the overlay.  The
//      colour controls will be applied to any flippable overlay to the target
//      surface. If the lpDDCC is NULL, then capabilities are returned,
//      otherwise returns TRUE if succeeded.

DWORD __stdcall nvSetOverlayColorControl(DWORD dwDevice, Nv_ColorControl_t *lpDDCC)
{
    GLOBALDATA* pDriverData = NULL; // override global pDriverData

    pDriverData = getGlobalDataPtr(dwDevice);
    if (pDriverData == NULL) {
        return NVS2VERR_INIT_FAILED;  // We cannot handle this -- we need a context ptr
    }
    Vpp_t &vpp = pDriverData->vpp;

    if (lpDDCC) {
        if (lpDDCC->dwSize != sizeof(Nv_ColorControl_t)) return FALSE;
        if ((lpDDCC->dwFlags & ~(NV_VPP_COLOR_CONTRAST | NV_VPP_COLOR_BRIGHTNESS | NV_VPP_COLOR_HUE | NV_VPP_COLOR_SATURATION)) != 0)
            return (FALSE);
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            while (lpDDCC->lHue < -180) lpDDCC->lHue += 360;
            while (lpDDCC->lHue >= 180) lpDDCC->lHue -= 360;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_CONTRAST)
                vpp.colorCtrl.lContrast   = min(max(lpDDCC->lContrast * 20000 / 200, 0), 20000);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_BRIGHTNESS)
                vpp.colorCtrl.lBrightness = min(max(lpDDCC->lBrightness * 100, -10000), 10000);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_HUE)
                vpp.colorCtrl.lHue        = lpDDCC->lHue;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_SATURATION)
                vpp.colorCtrl.lSaturation = min(max(lpDDCC->lSaturation * 20000 / 200, 0), 20000);
        } else {
            while (lpDDCC->lHue < 0)    lpDDCC->lHue += 360;
            while (lpDDCC->lHue >= 360) lpDDCC->lHue -= 360;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_CONTRAST)
                vpp.colorCtrl.lContrast   = min(max(lpDDCC->lContrast * 511 / 200, 0), 511);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_BRIGHTNESS)
                vpp.colorCtrl.lBrightness = min(max(lpDDCC->lBrightness, -256), 255);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_HUE)
                vpp.colorCtrl.lHue        = lpDDCC->lHue;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_SATURATION)
                vpp.colorCtrl.lSaturation = min(max(lpDDCC->lSaturation * 512 / 200, 0), 512);
            vpp.regOverlayColourControlEnable    = lpDDCC->dwReserved1 & 0x0000FFFF;
            vpp.regOverlayMode                   = lpDDCC->dwReserved1 >> 16;
        }
        return (TRUE);
    }
    else {
        if (!vpp.regOverlayColourControlEnable) return 0;
        return (NV_VPP_COLOR_CONTRAST | NV_VPP_COLOR_BRIGHTNESS | NV_VPP_COLOR_HUE | NV_VPP_COLOR_SATURATION);
    }
}

#ifdef __cplusplus
}       // extern "C"
#endif

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvPusher.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPusher.cpp
//      routines for creating, destroying, and interacting with a push buffer
//
// **************************************************************************
//
//  History:
//      Ben DeWaal              07Apr1999         original code
//      Craig Duttweiler        05Apr2000         cleanup, consolidation,
//                                                and C++'ification
//
// **************************************************************************

// #define LOG_GETPUT

#if (NVARCH >= 0x04)

#include "nvprecomp.h"
#pragma hdrstop

#ifdef _PC_CAPTURE
HANDLE hPusherFileBinary;
HANDLE hPusherFileAscii;
BOOL   bPusherCapture = FALSE;
#endif

#if IS_WINNT4
/*
 * Map System Memory Allocation to display driver functions.  Ignore heap-create/destroy.
 */
#define HeapCreate(nop, nop1, nop2)       (!NULL)
#define HeapDestroy(heap)                 (TRUE)
#define HeapAlloc(nop, nop1, size)            EngAllocMem(FL_ZERO_MEMORY, (size), ALLOC_TAG)
#define HeapFree(nop, nop1, ptr)              { \
    if (ptr != NULL)            \
    {                           \
    EngFreeMem((ptr));          \
    }                           \
}
#endif

//---------------------------------------------------------------------------

#ifdef LOG_GETPUT
// Store put/get/time

#define MAX_INDEX 25000

DWORD dwGet[MAX_INDEX];
DWORD dwPut[MAX_INDEX];
LARGE_INTEGER dwTime[MAX_INDEX];
DWORD dwIndex = 0;

void SaveData(void)
{
    static int FileNum = 0;
    char buff[128];

    nvSprintf (buff, "GPData%02d.txt", FileNum);
    FileNum++;
    HANDLE hFile = NvCreateFile(buff, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD dwWritten;
    LARGE_INTEGER dwFreq;
    QueryPerformanceFrequency(&dwFreq);
    nvSprintf (buff, "%9s %8s %8s Freq = %u\n", "Time", "Get", "Put", dwFreq.LowPart);
    NvWriteFile (hFile, buff, nvStrLen(buff), &dwWritten, NULL);
    for(DWORD i = 0; i < dwIndex; i++) {
        nvSprintf (buff, "%9u %08u %08u\n", dwTime[i].LowPart, dwGet[i], dwPut[i]);
        WriteFile (hFile, buff, nvStrLen(buff), &dwWritten, NULL);
    }
    NvCloseHandle(hFile);
    dwIndex = 0;
    _asm int 3
}

#define STORE_GETPUT()                                                                              \
{                                                                                                   \
    DWORD dwHWGet = _pdwHWGet;                                                                      \
    dwGet[dwIndex] = dwHWGet;                                                                       \
    dwPut[dwIndex] = m_dwPutLast - m_dwBase;                                                        \
    QueryPerformanceCounter((LARGE_INTEGER*)&dwTime[dwIndex]);                                      \
    dwIndex++;                                                                                      \
    if (dwIndex == MAX_INDEX) {                                                                     \
        SaveData();                                                                                 \
    }                                                                                               \
}

#endif // LOG_GETPUT

//---------------------------------------------------------------------------

// pusher debug helpers

#ifdef _PC_BREAK
DWORD dwPutOffsetBreak = ~0;
#endif //_PC_BREAK
#ifdef _PC_CHECK
DWORD dwPusherCount = ~0;
#endif //_PC_CHECK

//---------------------------------------------------------------------------
// public functions
//---------------------------------------------------------------------------

// CPushBuffer::allocate

BOOL CPushBuffer::allocate
(
    DWORD dwChannel
)
{
    setChannel (dwChannel);

    if (allocateMemory()     &&
        allocateContextDMA() &&
        openChannel())
    {
        m_dwFlags |= PB_FLAG_VALID;
        resetPut();
        return (TRUE);
    }

    return (FALSE);
}

//---------------------------------------------------------------------------

// CPushBuffer::free
// returns TRUE on success, FALSE on failure

BOOL CPushBuffer::free
(
    void
)
{
#if IS_WIN9X
    nvAssert (!global.b16BitCode);
#endif

    closeChannel();
    freeContextDMA();
    freeMemory();

    // mark buffer as being invalid
    m_dwFlags &= ~PB_FLAG_VALID;

    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::start
// kicks off the current push buffer. if bRequired is FALSE then this
// routine will only kick it off when there is NVPUSHER_MINIMUM bytes
// in the buffer

void CPushBuffer::start
(
    BOOL bRequired
)
{
#ifdef _PC_CHECK
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
    {
        if (!isValid()) {
            DPF ("caught attempt to start an invalid push buffer.");
            __asm int 3;
            return;
        }
        if (dwPusherCount != ~0) {
            DPF ("adjust() or inc() not called, data lost.");
            DPF ("F10 to return to caller.");
            __asm int 3;
            return;
        }
    }
#endif //_PC_CHECK

    // return if nothing has been buffered
    if (m_dwPutLast == m_dwPut) {
        return;
    }

    // handle optional case
    if (!bRequired) {
        if ((m_dwPut - m_dwPutLast) < NVPUSHER_MINIMUM) {
            return;
        }
    }

    // handle proper kick-off
    kickOff();
}

//---------------------------------------------------------------------------

// CPushBuffer::flush
// kicks off the push buffer and spin until it is consumed. If bWaitForHWIdle
// is specified, we also wait for the HW to go idle afterwards

void CPushBuffer::flush
(
    BOOL  bWaitForHWIdle,
    DWORD dwMode
)
{
    // kick off buffer
    start (TRUE);

    //
    // capture driver
    //
#ifdef CAPTURE
    if (!global.b16BitCode)
    {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwType               = bWaitForHWIdle ? CAPTURE_SYNC3_TYPE_CHIPIDLE : CAPTURE_SYNC3_TYPE_ZEROCOMMANDS;
            sync.dwCtxDMAHandle       = 0;
            sync.dwOffset             = 0;
            sync.dwValue              = 0;
            captureLog (&sync,sizeof(sync));
        }
    }
#endif

    // wait for idle
            #ifdef NV_PROFILE_PUSHER
            if (!global.b16BitCode) {
                NVP_START(NVP_T_FLUSH);
            }
            #endif

    switch (dwMode) {

        case FLUSH_WITH_DELAY:
            while (!isIdle(bWaitForHWIdle)) {
                nvSpin(_systemInfo.dwSpinLoopCount);
            }
            break;

        case FLUSH_HEAVY_POLLING:
            while (!isIdle(bWaitForHWIdle));
            break;

        default:
            DPF ("unknown flush mode");
            dbgError("NV Error!");
            break;

    }  // switch

            #ifdef NV_PROFILE_PUSHER
            if (!global.b16BitCode) {
                NVP_STOP(NVP_T_FLUSH);
                nvpLogTime (NVP_T_FLUSH,nvpTime[NVP_T_FLUSH]);
            }
            #endif
}

//---------------------------------------------------------------------------

// CPushBuffer::resetPut
// called to initialize a new, empty push buffer.
// sets up the put pointer, get pointer, and threshold

void CPushBuffer::resetPut
(
    void
)
{
#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("invalid push buffer in resetPut");
        __asm int 3;
        return;
    }
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

    // initialize to base temporarily to make CPushBuffer::calcThreshold happy
    m_dwPut = m_dwPutLast = m_dwBase;
    calcThreshold();
    // set put to get since technically, there is no strict guarantee
    // that the get pointer starts out at the beginning of a new buffer
    m_dwPut = m_dwPutLast = m_dwGet;

#ifdef _PC_PRINT
    DPF ("CPushBuffer::resetPut: base = %08x",m_dwBase);
    DPF ("                       put  = %08x",m_dwPut);
    DPF ("                       get  = %08x",m_dwGet);
#endif
}

//---------------------------------------------------------------------------

// CPushBuffer::isIdle
// returns TRUE if the push buffer is idle

BOOL CPushBuffer::isIdle
(
    BOOL bCheckHWAlso
)
{
    // pDriverData, dwFullScreenDOSStatus and the flag value are not available
    // on NT4.
#if !IS_WINNT4
    // degenerate case: monitor shutdown could occur with dma pending
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        return TRUE;
    }
#endif

    // is push buffer consumed?
    // STORE_GETPUT();
    m_dwGet = m_dwBase + _pdwHWGet;
    if (m_dwGet != m_dwPutLast) {
        return FALSE;
    }

    // is HW idle?
    if (bCheckHWAlso) {

        // check for stuff pending in the cache
        // (DCT clipping test fails on Win2K dual CPU without this test)
        if (((_ffCache1Push1  & 0x1f) == _dmaPusherChannelIndex) &&
            ((_ffCache1Status & 0x10) == 0)) {
            // we own the cache and it's got stuff in it
            return FALSE;
        }

        // check the graphics engine itself
        if (_pbHWBusy) {
            return FALSE;
        }

    }

    // idle
    return TRUE;
}

//---------------------------------------------------------------------------

// CPushBuffer::waitForOtherChannels
// waits for other channels to go idle before returning

void CPushBuffer::waitForOtherChannels
(
    void
)
{
    volatile DWORD *npNvBase;
    DWORD *pDW;

#ifdef _PC_CHECK
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
    {
        if (!_pDriverData) {
            DPF ("pDriverData not yet initialized in CPushBuffer::waitForOtherChannels.");
            __asm int 3;
            return;
        }
    }
#endif //_PC_CHECK
#ifdef CAPTURE
    if (!global.b16BitCode) {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwType               = CAPTURE_SYNC3_TYPE_CHANNELS;
            sync.dwCtxDMAHandle       = 0;
            sync.dwOffset             = 0;
            sync.dwValue              = 0;
            captureLog (&sync,sizeof(sync));
        }
    }
#endif

    m_dwFlags &= ~PB_FLAG_CHANNEL_SYNC;

    npNvBase = _nvBaseFlat;
    pDW      = _pCurrentChannelID;

    if (*pDW != _dmaPusherChannelIndex)
    {
        *pDW = _dmaPusherChannelIndex;
        while ((npNvBase[(NV_PFIFO_DMA >> 2)] & (~(1<<_dmaPusherChannelIndex))) != 0);
        if ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT)
         && ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F) != (WORD)_dmaPusherChannelIndex))
        {
            while ((npNvBase[NV_PFIFO_CACHE1_DMA_PUSH >> 2] & NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT) == 0);
        }
    }
}

//---------------------------------------------------------------------------

// CPushBuffer::makeSpace
// makes space for at least dwCount words in the push buffer

void CPushBuffer::makeSpace
(
    DWORD dwCount
)
{
    BOOL  bFirst = TRUE;
    DWORD dwMax  = m_dwBase                     // start
                 + m_dwSize                     // + base         -> end
                 - NVPUSHER_THRESHOLD_SIZE * 4  // - assumed      -> largest allowed end (with zero space)
                 - dwCount * 4;                 // - dwCount * 4  -> largest allowed end (with dwCount words)

#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to make space in an invalid push buffer.");
        __asm int 3;
        return;
    }
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

            #ifdef NV_PROFILE_PUSHER
            NVP_START(NVP_T_MAKESPACE);
            #endif
    // see if this size can fit between put and end of buffer
    if (m_dwPut >= dwMax) {
        // wrap around
        wrapAround();
#ifdef _PC_CHECK
        dwPusherCount = ~0; // reset
#endif //_PC_CHECK
        calcThreshold();
        bFirst = FALSE;
    }

    // wait until threshold is far enough away
    dwCount *= 4; // words -> bytes
    while (m_dwThreshold < (m_dwPut + dwCount)) {
        if (bFirst) {
            bFirst = FALSE;
        }
        else {
            nvSpin(_systemInfo.dwSpinLoopCount);
        }
        calcThreshold();
    }
            #ifdef NV_PROFILE_PUSHER
            NVP_STOP(NVP_T_MAKESPACE);
            nvpLogTime (NVP_T_MAKESPACE,nvpTime[NVP_T_MAKESPACE]);
            #endif
}

//---------------------------------------------------------------------------

#ifdef _NO_INLINE

// CPushBuffer::push
// push dwData at put + offset (in words)

void CPushBuffer::push
(
    DWORD dwOffset,
    DWORD dwData
)
{
#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to push data to an invalid push buffer.");
        __asm int 3;
        return;
    }
    if (dwOffset) {
        dwPusherCount ++;
        if (dwPusherCount != dwOffset) {
            DPF ("CPushBuffer::push: gap in offset sequence.");
            DPF ("ZAP or F5 to continue.");
            __asm int 3;
        }
    }
    else {
        dwPusherCount = 0;
        //memset ((void*)m_dwPut,0x55,NVPUSHER_THRESHOLD_SIZE * 4);
    }
#endif
#ifdef _PC_BREAK
    if ((m_dwPut - m_dwBase + dwOffset * 4) == dwPutOffsetBreak) {
        DPF ("CPushBuffer::push: desired put reached.");
        DPF ("ZAP or F5 to continue.");
        __asm int 3;
    }
#endif //_PC_BREAK

    ((DWORD*)m_dwPut)[dwOffset] = dwData;
}

//---------------------------------------------------------------------------

// CPushBuffer::adjust
// advance put by dwCount words

BOOL CPushBuffer::adjust
(
    DWORD dwCount
)
{
    BOOL bKickedOff;

#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to adjust an invalid push buffer.");
        __asm int 3;
        return (FALSE);
    }

    if (dwCount) {

        // check for push / adjust mismatch
        if (dwCount != (dwPusherCount + 1)) {
            dwPusherCount = ~0; // reset
            DPF ("CPushBuffer::adjust: incorrect amount adjusted.");
            DPF ("                     current object address: %08x",m_dwPut);
            DPF ("F10 to return to caller.");
            __asm int 3;
            return (FALSE);
        }

        else {
            // check for proper object size
            //  complete objects must be pushed since this may kick-off unexpectedly
            DWORD dwAddr = m_dwPut;
            DWORD dwCnt  = dwCount;

            while (dwCnt) {
                // get push buffer data
                DWORD dwValue = *(DWORD*)dwAddr;

                // process JMP command
                if (dwValue & 0x20000000) {
                    // extract jmp dest
                    DWORD dwDest = dwAddr & 0x1fffffff;
                    // test valid
                    //  - for now we assume only zero to be valid since we do not
                    //    jump anywhere else. Later we can make the test simply check
                    //    that dwDest lies within limits
                    if (dwDest > 0) {// (dwDest < m_dwSize)
                        dwPusherCount = ~0; // reset
                        DPF ("CPushBuffer::adjust: JUMP command out of range.");
                        DPF ("                     JUMP target    : %08x", dwDest);
                        DPF ("                     object address : %08x", dwAddr);
                        DPF ("F10 to return to caller.");
                        __asm int 3;
                        return (FALSE);
                    }
                    // apply jump
                    dwCnt  -= 1;
                    dwAddr  = m_dwBase + dwDest;
                }

                else if (dwValue & 0x00000002) {
                    // call command. just skip over it
                    // (maybe later we can be fancy by sanity checking the function)
                    dwCnt  -= 1;
                    dwAddr += 4;
                }

                else {
                    DWORD dwAdd = 1 + ((dwValue >> 18) & 0x7f);  // data count + 1 for the method itself
                    dwCnt -= dwAdd;
                    if (dwCnt > dwCount) { // includes going negative
                        dwPusherCount = ~0; // reset
                        DPF ("CPushBuffer::adjust: partial or incorrect object pushed.");
                        DPF ("                     object address: %08x", dwAddr);
                        DPF ("F10 to return to caller.");
                        __asm int 3;
                        return (FALSE);
                    }
                    dwAddr += dwAdd * 4;
                }
            }
        }
    }  // if (dwCount)...

    dwPusherCount = ~0; // reset
#endif

    // increment put
    inc (dwCount);

    // spin until we have enough space in the push buffer
    bKickedOff = getSpace();

#ifdef _PC_FLUSH_ON_ADJUST
    flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
#endif // _PC_FLUSH_ON_ADJUST

    return (bKickedOff);
}

//---------------------------------------------------------------------------

// CPushBuffer::inc
// increments put pointer

void CPushBuffer::inc
(
    DWORD dwCount
)
{
#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to increment an invalid push buffer.");
        __asm int 3;
        return;
    }
    DWORD dwDest = m_dwPut + (dwCount << 2);
    /*
    -- DO NOT REMOVE -- tests for put running past get but slows down too much
    DWORD dwGet = m_dwBase + _pdwHWGet;
    if (dwGet > m_dwPut)
    {
        if (dwDest >= dwGet)
        {
            DPF ("CPushBuffer::inc: increment past end of push buffer (current get).");
            DPF ("                  current put address: %08x",m_dwPut);
            DPF ("F10 to return to caller.");
            __asm int 3;
            return;
        }
    }
    */
    if (dwDest >= m_dwBase + m_dwSize) {
        DPF ("CPushBuffer::inc: increment past end of push buffer (top).");
        DPF ("                  current put address: %08x", m_dwPut);
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
    dwPusherCount = ~0; // reset
#endif //_PC_CHECK
    m_dwPut += (dwCount << 2);
}

#endif  // _NO_INLINE

//---------------------------------------------------------------------------
// private functions
//---------------------------------------------------------------------------

// CPushBuffer::setBase
// set the pusher base.
// put & get are discarded, leaving the push buffer in an invalid state;
// resetPut must be called subsequently to re-initialize things

void CPushBuffer::setBase
(
    DWORD dwBase
)
{
#ifdef _PC_CHECK
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

    m_dwBase      = dwBase;
    m_dwGet       = 0;
    m_dwPut       = 0;
    m_dwPutLast   = 0;
    m_dwThreshold = 0;

#ifdef _PC_PRINT
    DPF ("CPushBuffer::setBase: base = %08x", dwBase);
#endif
}

//---------------------------------------------------------------------------

// CPushBuffer::setSize
// set the pusher size.
// put & get are discarded, leaving the push buffer in an invalid state;
// resetPut must be called subsequently to re-initialize things

void CPushBuffer::setSize
(
    DWORD dwSize
)
{
#ifdef _PC_CHECK
    if (!_pDriverData) {
        DPF ("pDriverData not yet initialized in CPushBuffer::setSize.");
        __asm int 3;
        return;
    }
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

    m_dwSize      = dwSize;
    m_dwGet       = 0;
    m_dwPut       = 0;
    m_dwPutLast   = 0;
    m_dwThreshold = 0;

#ifdef _PC_PRINT
    DPF ("CPushBuffer::setSize: size = %08x",dwSize);
#endif
}

//---------------------------------------------------------------------------

// CPushBuffer::allocateMemory

BOOL CPushBuffer::allocateMemory
(
    void
)
{
    // check to see if the push buffer was already allocated (probably via updateNonLocalHeap)
    if (!m_dwBase) {
        // Ensure size of pushbuffer is initialized properly. Previously done in
        // DriverInit, but under NT DriverInit is only called once when GLOBALDATA
        // is created. Push buffer size is being reset on every mode change.
        setSize (_systemInfo.dwRecommendedPushBufferSize);

        if ((_pDriverData->regPBLocale == NV_REG_SYS_PB_LOCATION_VIDEO) ||
            (_systemInfo.dwPerformanceStrategy & PS_PUSH_VID)) {

            // allocate push buffer in video memory
            DWORD dwStatus, dwVidMemBase;
            NVHEAP_ALLOC (dwStatus, dwVidMemBase, m_dwSize, TYPE_IMAGE);
            nvAssert (dwStatus == 0);
            setBase (VIDMEM_ADDR(dwVidMemBase));

            m_dwHeap &= ~(CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI);
            m_dwHeap |=  CSimpleSurface::HEAP_VID;

        }

#if (!IS_WINNT4)	// AGP pushbuffer is not (yet) available on WinNT4

        else if (((_pDriverData->regPBLocale == NV_REG_SYS_PB_LOCATION_AGP) ||
                  (_pDriverData->regPBLocale == NV_REG_SYS_PB_LOCATION_DEFAULT))
                 &&
                 (_pDriverData->GARTLinearBase != NULL)) {

            // allocate push buffer from AGP memory
#ifdef NV_AGP			
            DWORD dwAgpAddr = (DWORD)nvAGPAlloc(m_dwSize);
            if (dwAgpAddr == ERR_DXALLOC_FAILED) {
                DPF ("CPushBuffer::allocateMemory: warning - failed to allocate required");
                DPF ("                             amount of AGP mem for pushbuffer!");
            }
            else {
                setBase (dwAgpAddr);
            }
#else
            DWORD dwAgpOffset = (DWORD)nvAGPAlloc(m_dwSize);
            if (dwAgpOffset == ERR_DXALLOC_FAILED) {
                DPF ("CPushBuffer::allocateMemory: warning - failed to allocate required");
                DPF ("                             amount of AGP mem for pushbuffer!");
            }
            else {
                setBase (AGPMEM_ADDR(dwAgpOffset));
            }

            if (!m_dwBase) {
                // mark AGP as invalid so that further allocations go to PCI memory
#ifdef WINNT
                NvWin2KUnmapAgpHeap(_pDriverData);
#endif // !WINNT
                _pDriverData->GARTLinearBase = 0;
            }
#endif

            m_dwHeap &= ~(CSimpleSurface::HEAP_PCI | CSimpleSurface::HEAP_VID);
            m_dwHeap |=  CSimpleSurface::HEAP_AGP;
        }
#endif // NT4

        if (!m_dwBase) {
            // we still haven't allocated a push buffer. this is either because we failed to do so
            // or because we didn't want it in video / AGP. either way, try now to put it in PCI

            if (m_dwPCIHeapHandle == 0) {

                // not allocated for PCI yet
                m_dwPCIHeapHandle = (DWORD) HeapCreate (HEAP_SHARED, m_dwSize, 0);
                m_dwPCIHeapBase   = (DWORD) HeapAlloc  ((HANDLE)m_dwPCIHeapHandle, HEAP_ZERO_MEMORY, m_dwSize);

                if (m_dwPCIHeapBase) {
                    // align things properly. both the base and limit need to be aligned to make nv10 happy.
                    DWORD dwAlignedBase  = (m_dwPCIHeapBase + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
                    DWORD dwAlignedLimit = (m_dwPCIHeapBase + m_dwSize) & ~NV_TEXTURE_OFFSET_ALIGN;
                    DWORD dwAlignedSize  = dwAlignedLimit - dwAlignedBase;
                    setBase (dwAlignedBase);
                    setSize (dwAlignedSize);
                    m_dwHeap &= ~(CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_VID);
                    m_dwHeap |=  CSimpleSurface::HEAP_PCI;
                } else {
                    // may see system alloc failure in win2k + 1G RAM
                    HeapDestroy((HANDLE)m_dwPCIHeapHandle);
                    m_dwPCIHeapHandle = 0;

                    // last resort, allocate push buffer in video memory
                    DWORD dwStatus, dwVidMemBase;
                    NVHEAP_ALLOC (dwStatus, dwVidMemBase, m_dwSize, TYPE_IMAGE);
                    nvAssert (dwStatus == 0);
                    setBase (VIDMEM_ADDR(dwVidMemBase));

                    m_dwHeap &= ~(CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI);
                    m_dwHeap |=  CSimpleSurface::HEAP_VID;
                }
            }
            else {
                DPF ("what the heck does this mean??");
                dbgError("NV Error!");
            }

        }

    }  // !m_dwBase

    return (m_dwBase ? TRUE : FALSE);
}

//---------------------------------------------------------------------------

// CPushBuffer::freeMemory

BOOL CPushBuffer::freeMemory
(
    void
)
{
    if (m_dwBase) {

#if (!IS_WINNT4)	// AGP pushbuffer is not (yet) available on WinNT4

        if (_pDriverData->GARTLinearBase && (m_dwHeap & CSimpleSurface::HEAP_AGP)) {
            nvAGPFree((void*)getfpVidMem());
        }
        else 
#endif // NT4
		if (m_dwHeap & CSimpleSurface::HEAP_VID)
		{
            NVHEAP_FREE (getfpVidMem());
        }
        else {
            // DMA push buffer in system mem
            HeapFree    ((HANDLE) m_dwPCIHeapHandle, 0, (PVOID) m_dwPCIHeapBase);
            HeapDestroy ((void*) m_dwPCIHeapHandle);
            m_dwPCIHeapHandle = m_dwPCIHeapBase = 0;
        }

        setBase (0);

    }

    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::allocateContextDMA

BOOL CPushBuffer::allocateContextDMA
(
    void
)
{
    NvU32 status;

    if (!m_dwContextDMASize) {
        status = NvRmAllocContextDma (_dwRootHandle,
                                 m_dwContextDMA,
                                 NV01_CONTEXT_DMA,
                                 DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                                 DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                 DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                 (PVOID) m_dwBase,
                                 m_dwSize - 1);
        if (status!=0)
        {
            DPF("Failed... Status = 0x%08x",status);
            return(FALSE);
        }
        m_dwContextDMASize = m_dwSize;
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::freeContextDMA

BOOL CPushBuffer::freeContextDMA
(
    void
)
{
    if (m_dwContextDMASize) {
        NvRmFree (_dwRootHandle, _dwRootHandle, m_dwContextDMA);
        m_dwContextDMASize = 0;
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::openChannel

BOOL CPushBuffer::openChannel
(
    void
)
{
    if (!m_dwControlDMA) {
        DWORD dwChannelFlavor = (_systemInfo.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA) ?
                                    NV20_CHANNEL_DMA :
                                    (_systemInfo.dwNVClasses1 & NVCLASS1_006E_CHANNELDMA) ?
                                        NV10_CHANNEL_DMA :
                                        NV04_CHANNEL_DMA;
        if (NvRmAllocChannelDma (_dwRootHandle, _hDevice,
                                 m_dwChannel, dwChannelFlavor, 0,
                                 m_dwContextDMA, 0,
                                 (PVOID*)&m_dwControlDMA)) {
            return(FALSE);
        }
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::closeChannel

BOOL CPushBuffer::closeChannel
(
    void
)
{
    if (m_dwControlDMA) {
        NvRmFree (_dwRootHandle, _hDevice, m_dwChannel);
        m_dwControlDMA = 0;
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::getfpVidMem
// returns the FLATPTR base of the push buffer

FLATPTR CPushBuffer::getfpVidMem
(
    void
)
{
#ifdef WINNT
    if (!m_dwBase) { return (NULL); }
#ifndef NV_AGP
    if (m_dwHeap & CSimpleSurface::HEAP_AGP) {
        return (m_dwBase - _pDriverData->GARTLinearBase);
    }
#endif
    else if (m_dwHeap & CSimpleSurface::HEAP_VID) {
#if IS_WINNT4
        return (m_dwBase - (ULONG) m_ppdev->pjFrameBufbase);
#else
        return (m_dwBase - (ULONG) ppdev->pjFrameBufbase);
#endif
    }
    else
#endif // WINNT
    return (m_dwBase);
}


//---------------------------------------------------------------------------

// CPushBuffer::syncAndFlushWC
// do a WC flush

inline void CPushBuffer::syncAndFlushWC (void)
{
    waitForOtherChannels();

    // wait for flip to complete if the flag is set
    if (m_dwFlags & PB_FLAG_FLIP_SYNC) {
#if IS_WINNT4
        // Flip sync is not implemented on NT4 -- need to port getFrameStatus...
        nvAssert(FALSE);
#else
        while (getFlipStatus (m_dwFlipSurfaceAddr, m_dwFlipSurfaceFlags) != DD_OK) {
            nvSpin(_systemInfo.dwSpinLoopCount);
        }
        m_dwFlags &= ~PB_FLAG_FLIP_SYNC;
#endif
    }

    // flush WC (Write Combine - not Water Closet)
    if (_hasSFENCE) {
        __asm _emit 0x0f
        __asm _emit 0xae
        __asm _emit 0xf8 // sfence
    }
    else {
        __asm mov edx,0x3d0
        __asm xor eax,eax
        __asm out dx,al
    }
}

//---------------------------------------------------------------------------

// CPushBuffer::kickOff
// writes put

void CPushBuffer::kickOff
(
    void
)
{
    DWORD dwPutOffset;

#ifdef _PC_PRINTPUT
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
        {
        DPF ("CPushBuffer::kickOff: put = %08x (rel %08x)", m_dwBase + dwPutOffset, dwPutOffset);
    }
#endif

#ifdef _PC_CHECK
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
        {
        if (!validate (m_dwPutLast, m_dwPut)) {
            DPF ("CPushBuffer::kickOff: warning - put was not written due to parse error.");
            return;
        }
    }
#endif

#if 0
    {
        static HANDLE h = 0;

        static DWORD totl = 0;
        static DWORD last = 0;
        if (!last) last = GetTickCount();
        DWORD now = GetTickCount();

        totl += (m_dwPut > m_dwPutLast)
                ? (m_dwPut - m_dwPutLast)
                : 0;

        //if ((now - last) > 50)
        {
            DWORD x = now - last;
            DWORD y = totl;
            totl = 0;

            last = now;

            if (!h) {
                h = NvCreateFile("c:\\data.txt",GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
                if (h == INVALID_HANDLE_VALUE) {
                    h = 0;
                }
                else {
                    SetFilePointer (h,0,NULL,FILE_END);
                }
            }

            if (h) {
                char sz[256];
                wsprintf (sz,"%d\t%d\r\n",x,y);
                NvWriteFile (h,sz,strlen(sz),&x,NULL);
            }

            static DWORD t = 0;
            if (!t) t = GetTickCount();
            DWORD n = GetTickCount();

            if ((n - t) > 1000) {
                t = n;
                NvCloseHandle (h);
                h = 0;
            }
        }
    }
#endif // 0

    // write put & update last put address
    syncAndFlushWC();

#ifdef CAPTURE
    if (!global.b16BitCode) {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            if (m_dwPutLast < m_dwPut) {
                captureLog ((void*)m_dwPutLast, m_dwPut - m_dwPutLast);
            }
        }
    }
#endif

    dwPutOffset = m_dwPut - m_dwBase;
    m_dwPutLast = m_dwPut;

//    STORE_GETPUT();

            #ifdef NV_PROFILE_PUSHER
            if (!global.b16BitCode) {
                DWORD dwGetOffset = _pdwHWGet;
                DWORD dwPending;
                if (dwGetOffset > dwPutOffset) {
                    dwPending = m_dwSize - (dwGetOffset - dwPutOffset);
                }
                else {
                    dwPending = dwPutOffset - dwGetOffset;
                }
                // static int   first = 1;
                // static DWORD dwLast;
                // if (first)
                // {
                    // first = 0;
                // }
                // else
                // {
                    // NVP_STOP(NVP_C_VELOCITY);
                // }
                // DWORD dwNow = dwGetOffset;
                // double vel  = double(int(dwNow) - int(dwLast)) * 1000.0 * double(global.dwProcessorSpeed) / double(nvpTime[NVP_C_VELOCITY]);
                // if (vel < 0) vel = 0;
                // if (vel > 10000) vel = 10000;
                // nvpLogCount (NVP_C_VELOCITY,DWORD(vel));

                 if (nvpGetLogPusher())
                 {
                    nvpLogCount (NVP_C_PENDINGSIZE,dwPending);
                    
                 }
                // nvpLogCount (NVP_C_PUT,dwPutOffset);
                // nvpLogCount (NVP_C_GET,dwGetOffset);
                // dwLast = dwNow;
                // NVP_START(NVP_C_VELOCITY);
            }
            #endif  // NV_PROFILE_PUSHER

    _pdwHWPut = dwPutOffset;

            #ifdef NV_PROFILE
            if (!global.b16BitCode) {
            #ifdef NV_PROFILE_PUSHER
                if (nvpGetLogPusher())
            #endif
                nvpLogEvent (NVP_E_PUT);
            }
            #endif  // NV_PROFILE

//    memset((void*)m_dwPutLast, 0xFA, (NVPUSHER_THRESHOLD_SIZE - 1)*4);
}

//---------------------------------------------------------------------------

// CPushBuffer::getSpace
// spins until we have space in push buffer

BOOL CPushBuffer::getSpace
(
    void
)
{
    #ifdef NV_PROFILE_PUSHER
    NVP_START(NVP_T_ADJUST);
    #endif

    BOOL bFirst     = TRUE;
    BOOL bKickedOff = FALSE;

    while (m_dwPut >= m_dwThreshold) {
        if (bFirst) {
            bFirst = FALSE;
        }
        else {
            nvSpin(_systemInfo.dwSpinLoopCount);
        }
        bKickedOff |= calcThreshold();
    }

    #ifdef NV_PROFILE_PUSHER
    NVP_STOP(NVP_T_ADJUST);
    nvpLogTime (NVP_T_ADJUST,nvpTime[NVP_T_ADJUST]);
    #endif

    return (bKickedOff);
}

//---------------------------------------------------------------------------

// CPushBuffer::calcThreshold
// recalculate pusher threshold

BOOL CPushBuffer::calcThreshold
(
    void
)
{
    BOOL  bKickedOff;
    DWORD dwMax;

#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("invalid push buffer in CPushBuffer::calcThreshold");
        __asm int 3;
        return (FALSE);
    }
#endif //_PC_CHECK

    dwMax = m_dwBase + m_dwSize - (4*NVPUSHER_THRESHOLD_SIZE);

    // have we crossed the largest possible threshold?
    if (m_dwPut >= dwMax) {
        // wrap push buffer around
        wrapAround();
#ifdef _PC_CHECK
        dwPusherCount = ~0; // reset
#endif //_PC_CHECK
        bKickedOff    = TRUE;
    }

    // read get pointer
//    STORE_GETPUT();
    m_dwGet = m_dwBase + _pdwHWGet;

    // figure out who is chasing whom
    if (m_dwPut >= m_dwGet) {
        // get is chasing put -- .....G*******P....T.
        m_dwThreshold = dwMax;
    }
    else {
        // put is chasing get -- *******P...T.G*****.
        // note that the threshold can actually be less that the push buffer base. this is okay.
        m_dwThreshold = m_dwGet - (4*NVPUSHER_THRESHOLD_SIZE);
    }

    return bKickedOff;
}

//---------------------------------------------------------------------------

// CPushBuffer::wrapAround
// wraps pushbuffer around. This is the only place where we can get put
// to chase get.

void CPushBuffer::wrapAround
(
    void
)
{
            #ifdef NV_PROFILE_PUSHER
            NVP_START(NVP_T_WRAPAROUND);
            #endif

    // in the case where get already points to the push buffer base
    // we have to first get it going before we can write put to the
    // base again. This is because writing put to the same value
    // as get will do nothing instead of running through the whole
    // push buffer like we want it to.
    if (m_dwGet == m_dwBase)
    {
        // check get again
        // STORE_GETPUT();
        m_dwGet = m_dwBase + _pdwHWGet;
        if (m_dwGet == m_dwBase) {
            // kick off buffer
            kickOff();
            // wait until get has progressed at least one word
            while (m_dwGet == m_dwBase) {
                // STORE_GETPUT();
                m_dwGet = m_dwBase + _pdwHWGet;
            }
        }
    }

    // wait for get to wrap around

    // the following line used to be:
    // while ((m_dwGet > m_dwPutLast) && (m_dwGet != m_dwBase)) {
    // but i'm almost certain the second check is meaningless. dwGet can't possibly
    // be both ==base and >putlast. this would imply (putlast < base)  -- CRD 16jun00
    while (m_dwGet > m_dwPutLast) {
        nvSpin(_systemInfo.dwSpinLoopCount);
        // STORE_GETPUT();
        m_dwGet = m_dwBase + _pdwHWGet;
    }

#ifdef CAPTURE
    // if capturing, write out the tail end of the push buffer now,
    // since we won't do it after issuing the jump and resetting put
    kickOff();
#endif

    // write the jump and start puller
    push (0, NVPUSHER_JUMP(0));
    m_dwPut = m_dwBase;
    m_dwWrapCount ++;
    kickOff();

            #ifdef NV_PROFILE_PUSHER
            NVP_STOP(NVP_T_WRAPAROUND);
            nvpLogTime (NVP_T_WRAPAROUND,nvpTime[NVP_T_WRAPAROUND]);
            #endif
}

//---------------------------------------------------------------------------

#ifdef _PC_CHECK

// CPushBuffer::validate
// walks a push buffer and check that we have no parser or other
// common pusher errors. This is a second check, since CPushBuffer::adjust
// does a simple pass already.

BOOL CPushBuffer::validate
(
    DWORD dwStart,
    DWORD dwEnd
)
{
    DWORD dwLastAddr     = 0;
    DWORD dwLastJumpAddr = 0;
    DWORD dwAddr         = dwStart;
    DWORD dwCount        = m_dwSize; // allow 4 times the number of commands before we time out

#ifdef _PC_CAPTURE
    if (bPusherCapture) {
        DWORD dwJunk;
        char  sz[256];

        for (DWORD dwAddr = dwStart; dwAddr != dwEnd;) {
            DWORD dwMethod = *(DWORD*)dwAddr;
            dwAddr += 4;

            // save method
            NvWriteFile (hPusherFileBinary, (LPBYTE)(&dwMethod), 4, &dwJunk, 0);
            nvSprintf (sz, "%08x: method %08x ----\r\n", dwAddr, dwMethod);
            NvWriteFile (hPusherFileAscii, sz, nvStrLen(sz), &dwJunk, 0);

            if (dwMethod & 0x20000000) {
                // jmp
                dwAddr = m_dwBase + (dwMethod & 0x1fffffff);
            }
            else {
                for (DWORD dwCount = ((dwMethod & 0x1fff0000) >> 18); dwCount; dwCount--) {
                    DWORD dwData = *(DWORD*)dwAddr;
                    dwAddr += 4;
                    // save data
                    NvWriteFile (hPusherFileBinary, (LPBYTE)(&dwData), 4, &dwJunk, 0);
                    nvSprintf (sz, "%08x:   data %08x\r\n", dwAddr, dwData);
                    NvWriteFile (hPusherFileAscii, sz, nvStrLen(sz), &dwJunk, 0);
                }
            }
        }
    }
#endif

    while (dwCount && (dwAddr != dwEnd)) {

        DWORD dwCommand;

        // check if we are still in range
        if ((dwAddr < m_dwBase) || (dwAddr >= m_dwBase + m_dwSize)) {
            DPF ("CPushBuffer::validate: Pointer out of push buffer range.");
            DPF ("                       Bad address  : %08x", dwAddr);
            DPF ("                       Last address : %08x", dwLastAddr);
            DPF ("F10 to return to caller.");
            __asm int 3;
            return (FALSE);
        }

        // get command
        dwLastAddr = dwAddr;
        dwCommand = *(DWORD*)dwAddr;

        // process
        if (dwCommand & 0x00000001) {
            PF("dwCommand = %08x", dwCommand);
            PF("Invalid low-order bit");
            _asm int 3;
        }
        else if (dwCommand & 0x00000002) {
            // call command
            dwAddr += 4;
        }
        else if (dwCommand & 0x20000000) {
            // jump instruction
            dwLastJumpAddr = dwAddr;
            dwAddr = m_dwBase + (dwCommand & 0x1fffffff);
        }
        else {
#ifdef _PC_CAPTURE_METHOD_DATA
            // capture data
            parseMethod (dwAddr);
#endif
            // skip past this method header and its data
            dwAddr += 4 * (1 + ((dwCommand & ~0xe0000000) >> 18));
        }

        dwCount--;

    }

    // if we timed out then we assume the push buffer has some kind of infine loop
    //  that does not cause the pointer to go out of range but will hang
    //  or cause other failures
    if (!dwCount) {
        DPF ("CPushBuffer::validate: Validation timed out.");
        DPF ("                       Current address   : %08x", dwAddr);
        DPF ("                       Last address      : %08x", dwLastAddr);
        DPF ("                       Last JUMP address : %08x", dwLastJumpAddr);
        DPF ("F10 to return to caller.");
        __asm int 3;
        return FALSE;
    }

    return TRUE;
}

#endif //_PC_CHECK

//---------------------------------------------------------------------------

#ifdef _PC_CAPTURE_METHOD_DATA

static DWORD g_adwMax[8] = {0,0,0,0,0,0,0,0};
static DWORD g_adwState[8][0x2000 / 4]; // a whole bunch of method info

#define _SUBCHANNEL(x)          (((x) >> 13) & 7)
#define _SIZE(x)                (((x) >> 18) & 0x7ff)
#define _METHOD(x)              (((x) >>  2) & 0x7ff)
#define _NOINC(x)               ((x) & 0x40000000)
#define _JMP(x)                 ((x) & 0x20000000)

// CPushBuffer::parseMethod

DWORD CPushBuffer::parseMethod (DWORD dwAddress)
{
    DWORD dwMethod     = *(DWORD*)dwAddress;
    DWORD dwSubChannel = _SUBCHANNEL(dwMethod);
    DWORD dwAdd        = _NOINC(dwMethod) ? 0 : 1;
    DWORD dwCount      = _SIZE(dwMethod);
          dwMethod     = _METHOD(dwMethod);

    dwAddress += 4;

    for (; dwCount; dwCount--) {
        DWORD dwData = *(DWORD*)dwAddress;

        // handle new object
        if ((dwMethod == 0)
            && (g_adwState[dwSubChannel][0] != dwData)) {
            memset (g_adwState[dwSubChannel],0xdd,sizeof(g_adwState[dwSubChannel]));
            g_adwMax[dwSubChannel] = 0;
        }

        // store state
        g_adwState[dwSubChannel][dwMethod] = dwData;
        if (dwMethod > g_adwMax[dwSubChannel]) {
            g_adwMax[dwSubChannel] = dwMethod;
        }

        // next
        dwMethod  += dwAdd;
        dwAddress += 4;
    }

    return dwAddress;
}

//---------------------------------------------------------------------------

// CPushBuffer::captureState

void CPushBuffer::captureState (DWORD dwSubChannel)
{
    char sz[512];

    nvSprintf (sz,"\\state_%d.txt",dwSubChannel);
    HANDLE f = NvCreateFile(sz, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD  dw;

    for (DWORD i = 0; i < g_adwMax[dwSubChannel]; i++) {
        nvSprintf (sz,"%08x: %08x\r\n",i * 4,g_adwState[dwSubChannel][i]);
        NvWriteFile (f,sz,nvStrLen(sz),&dw,0);
    }
    FlushFileBuffers (f);
    NvCloseHandle (f);
}

#endif  // !_PC_CAPTURE_METHOD_DATA

#endif  // (NVARCH >= 0x04)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvRegTool.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"
#include "nvRegTool.h"

NvU8 CRegTool::Open(NV_DRIVER_HANDLE driverHandle, int logicalHeadID, char *subKeyName)
{
#if IS_WIN9X
    char regStr[NV_MAX_REG_KEYNAME_LEN];
    MyExtEscape (logicalHeadID, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, NV_MAX_REG_KEYNAME_LEN, regStr);
    nvStrCat(&(regStr[4]),"\\");
    nvStrCat(&(regStr[4]), subKeyName);

    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, (HKEY *)&m_hKey) != ERROR_SUCCESS) {
        m_hKey = 0;
    }
    return (m_hKey!=0);
#elif IS_WINNT
    m_hDriver = driverHandle;
    return TRUE;
#endif
    dbgError("Unhandled case\n");
    return FALSE;
}


NvU8 CRegTool::Read(char *keyName, NvU32 &val)
{
    NvU32 readValue;
    NvU32 retStatus;
    NvU32 valueSize = sizeof(NvU32);
#if IS_WIN9X
    NvU32  dwType = REG_DWORD;

    retStatus = RegQueryValueEx((HKEY)m_hKey, keyName, NULL, &dwType, (LPBYTE)&readValue, &valueSize);

#elif IS_WINNT
    WCHAR cUniKeyName[NV_MAX_REG_KEYNAME_LEN];
    NvU32 dwUniKeyLen;
    NvU32 dwRetSize;

    EngMultiByteToUnicodeN((LPWSTR)cUniKeyName, NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR), &dwUniKeyLen,
                           keyName, (nvStrLen(keyName)+1)*sizeof(CHAR));
    retStatus = EngDeviceIoControl(m_hDriver, IOCTL_VIDEO_QUERY_REGISTRY_VAL, (LPVOID)cUniKeyName,
                                   dwUniKeyLen, (LPVOID) &readValue, valueSize, &dwRetSize);
#endif
    if (retStatus == ERROR_SUCCESS)
    {
        val = readValue;
    }
    return (retStatus == ERROR_SUCCESS);
}

NvU8 CRegTool::Read(char *keyName, NvS32 &signedVal)
{
    NvU32 unsignedVal;
    NvU8  bSuccess;

    bSuccess = Read(keyName, unsignedVal);
    if (bSuccess)
    {
        signedVal = (NvS32)unsignedVal;
    }
    return bSuccess;
}

void CRegTool::Close()
{
#if IS_WIN9X
    RegCloseKey((HKEY)m_hKey);
    m_hKey = 0;
#else
    m_hDriver = 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvUtil.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#include "nvprecomp.h" // Needed for winddi etc.

#include "nvUtil.h"
#include "nvDbg.h"
#include <ctype.h>  // For tolower()
#include <math.h>

EXTERN_C void nvSpin(NvU32 loopCount)
{
    __asm
    {
    push ecx
        mov ecx,[loopCount]
xxx:
        loop xxx
    pop ecx
    }
}

//-------------------------------------------------------------------------
// NV STRING UTILITIES
//-------------------------------------------------------------------------

EXTERN_C int __cdecl nvStrCmp (char *szStr1, char *szStr2)
{
    while (*szStr1 != '\0' && *szStr2 != '\0') {
        if (*szStr1 != *szStr2) {
            return *szStr1 - *szStr2;
        }
        szStr1++;
        szStr2++;
    }
    return *szStr1 - *szStr2;
}

//-------------------------------------------------------------------------

EXTERN_C int __cdecl nvStrLen (char *szStr)
{
    int dwLen = 0;
    while (*szStr != '\0') {
        dwLen ++;
        szStr ++;
    }
    return (dwLen);
}

//-------------------------------------------------------------------------

// strlen up to a maximum of n characters

EXTERN_C int __cdecl nvStrNLen (char *szStr, int n)
{
    int dwLen = 0;

    // normal NULL terminated string
    if (n == 0) return nvStrLen(szStr);

    // length limited string
    while ((*szStr != '\0') && (dwLen < n)) {
        dwLen ++;
        szStr ++;
    }
    return (dwLen);
}

//-------------------------------------------------------------------------

// NV analog to strcpy

EXTERN_C void __cdecl nvStrCpy (char *szDst, char *szSrc)
{
    while (*szSrc != '\0') {
        *szDst = *szSrc;
        szDst ++;
        szSrc ++;
    }
    *szDst = '\0';
}

//-------------------------------------------------------------------------

// NV analog to strncpy

EXTERN_C void __cdecl nvStrNCpy (char *szDst, char *szSrc, int n)
{
    int dwCount=0;
    while ((*szSrc != '\0') && (dwCount < n)) {
        *szDst = *szSrc;
        szDst ++;
        szSrc ++;
        dwCount ++;
    }
    if (dwCount < n) *szDst = '\0';
}

//-------------------------------------------------------------------------

// NV analog to strcat

EXTERN_C void __cdecl nvStrCat (char *szStr1, char *szStr2)
{
    szStr1 += nvStrLen (szStr1);
    nvStrCpy (szStr1, szStr2);
}

//-------------------------------------------------------------------------

// NV analog to strchr

EXTERN_C char* __cdecl nvStrChr(char *szStr, NvU8 c)
{
    while (szStr[0])
    {
        if (szStr[0] == c)
            return szStr;
        szStr++;
    }
    return NULL;
}

//-------------------------------------------------------------------------

// NV analog to strrchr

EXTERN_C char* __cdecl nvStrRChr(char *szStr, unsigned char c)
{
    int dwLen = nvStrLen(szStr);
    char *szStr1 = szStr + dwLen - 1;
    while (szStr1 >= szStr)
    {
        if (szStr1[0] == c)
            return szStr1;
        szStr1--;
    }
    return NULL;
}

//-------------------------------------------------------------------------

void nvPrintPad (char **pDst, char cPad, int iLen)
{
    int i;
    for (i=0; i < iLen; i++) {
         **pDst = cPad;
         (*pDst) ++;
    }
}

//-------------------------------------------------------------------------

// print a formatted string or number (decimal or hex)
// allowed format types are: %[0][1-9]{d,u,x,c,s}

// *pDst is a pointer to the destination string
// *pFormatStr is a pointer to the format string (positioned AFTER the %)
// dwData is the numerical data or a pointer to a constant string

// at function exit, *pFormatStr and *pData will both have been advanced

typedef enum _varType {vtInt, vtDouble, vtChar, vtString, vtPercent, vtUnknown} varType;

static varType nvPrintFormattedThing (char **pDst, char **pFormatStr, NvU8 *pData)
{
    // formatting variables
    BOOL    bLeftJustify;
    char    cFillChar;
    int     iFieldSize;
    int     iPrecision;
    // things to which pData might point
    NvU32   dwData;
    double  dData;
    char    cData;
    char   *szData;
    // other helpers
    NvU32   dwBase, dwDigit, dwInt, dwFrac;
    int     iIndex, i, iStrLen, iSize;
    char    szNumStr[64], szFmt[8];
    char    *pFmt;
    float   fData;
    varType vt;

    // check for left justification
    if (**pFormatStr == '-') {
        bLeftJustify = TRUE;
        (*pFormatStr) ++;   // yes, ++ binds tighter than *. #@&!$^!
    }
    else {
        bLeftJustify = FALSE;
    }

    // determine fill character
    if (**pFormatStr == '0') {
        cFillChar = '0';
        (*pFormatStr) ++;
    }
    else {
        cFillChar = ' ';
    }

    // get field size
    if ((**pFormatStr >= '1') && (**pFormatStr <= '9')) {
        iFieldSize = (int)(**pFormatStr) - (int)('0');
        (*pFormatStr) ++;
    }
    else {
        iFieldSize = 0;
    }

    // check for precision specifier
    iPrecision = 0;
    if (**pFormatStr == '.') {
        (*pFormatStr) ++;
        if ((**pFormatStr >= '1') && (**pFormatStr <= '9')) {
            iPrecision = (int)(**pFormatStr) - (int)('0');
            (*pFormatStr) ++;
        }
    }

    switch (tolower(**pFormatStr)) {

        case 'i':
        case 'd':
        case 'u':
        case 'x':
        case 'p':
            dwData = *(NvU32 *)pData;
            if (**pFormatStr == 'd') {
                if ((int)dwData < 0) {
                    // emit the '-' sign
                    **pDst = '-';
                    (*pDst) ++;
                    dwData = -((int)dwData);
                }
            }
            dwBase = ((**pFormatStr == 'x') || (**pFormatStr == 'p')) ? 16 : 10;
            iIndex = 0;
            if (dwData) {
                while (dwData) {
                    dwDigit = dwData % dwBase;
                    szNumStr[iIndex] = (dwDigit < 10) ?
                                       '0' + (char)dwDigit :
                                       'a' + (char)dwDigit - (char)10;
                    iIndex ++;
                    dwData /= dwBase;
                }
            }
            else {
                // 0 is a special case
                szNumStr[0] = '0';
                iIndex = 1;
            }
            // left fill as needed
            if (!bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iIndex);
            }
            // copy the number into the destination
            for (i=iIndex-1; i>=0; i--) {
                **pDst = szNumStr[i];
                (*pDst) ++;
            }
            // right fill as needed
            if (bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iIndex);
            }
            vt = vtInt;
            break;

        case 'f':
            dData = *(double *)pData;
            fData = (float)dData;
            // check for special floating point values first
            if ((FP_EXP_VAL(fData) == 0) && (FP_MAN_VAL(fData) != 0)) {
                // denormal
                nvStrCpy (*pDst, "denormal  ");
                (*pDst) += nvStrLen("denormal  ");
            }
            else if (DWORD_FROM_FLOAT(fData) == FP_INFINITY_BITS) {
                // infinity
                nvStrCpy (*pDst, "infinity  ");
                (*pDst) += nvStrLen("infinity  ");
            }
            else if (DWORD_FROM_FLOAT(fData) == FP_MIN_INFINITY_BITS) {
                // infinity
                nvStrCpy (*pDst, "-infinity ");
                (*pDst) += nvStrLen("-infinity ");
            }
            else if ((FP_EXP_VAL(fData) == 0xff) && (FP_MAN_VAL(fData) != 0)) {
                // NaN
                nvStrCpy (*pDst, "NaN       ");
                (*pDst) += nvStrLen("NaN       ");
            }
            else {
                // a 'normal' floating point number
                if (fData < 0.0) {
                    // emit the '-' sign
                    **pDst = '-';
                    (*pDst) ++;
                    fData = -fData;
                }
                dwInt  = (NvU32)fData;
                dwFrac = (NvU32)(100000000.0*(fData-dwInt)+0.5);
                if (dwFrac==100000000) { dwInt+=1; dwFrac=0; }
                nvStrCpy (szFmt, "d");
                pFmt = szFmt;
                nvPrintFormattedThing (pDst, &pFmt, (NvU8 *)(&dwInt));
                **pDst = '.';
                (*pDst) ++;
                nvStrCpy (szFmt, "08d");
                pFmt = szFmt;
                nvPrintFormattedThing (pDst, &pFmt, (NvU8 *)(&dwFrac));
            }
            vt = vtDouble;
            break;

        case 'c':
            cData = *(char *)(pData);
            // left fill as needed
            if (!bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-1);
            }
            **pDst = cData;
            (*pDst) ++;
            // right fill as needed
            if (bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-1);
            }
            vt = vtChar;
            break;

        case 's':
            szData = *(char **)pData;
            iStrLen = (int) nvStrNLen (szData, iPrecision);
            iSize = iPrecision ? MIN(iPrecision,iStrLen) : iStrLen;
            // left fill as needed
            if (!bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iSize);
            }
            for (i=0; i < iSize; i++) {
                **pDst = *szData;
                (*pDst) ++;
                szData ++;
            }
            // right fill as needed
            if (bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iSize);
            }
            vt = vtString;
            break;

        case '%':
            **pDst = '%';
            (*pDst) ++;
            vt = vtPercent;
            break;

        default:
            DPF ("got unknown format type '%c' in nvPrintFormattedThing", **pFormatStr);
            dbgError("NV Error!");
            vt = vtUnknown;
            break;
    }

    (*pFormatStr) ++;

    return (vt);
}

//-------------------------------------------------------------------------

// NV analog to sprintf in two flavors: va_list and ...

EXTERN_C void __cdecl nvSprintfVAL (char *szDest, char *szFormat, va_list vaList)
{
    char   *pDst, *pSrc;
    varType vt;

    pDst = szDest;
    pSrc = szFormat;

    while (*pSrc != '\0') {

        if (*pSrc == '%') {
            pSrc ++;
            vt = nvPrintFormattedThing (&pDst, &pSrc, (NvU8 *)vaList);
            // advance to the next argument
            switch (vt) {
                case vtInt:
                    va_arg (vaList, int);
                    break;
                case vtDouble:
                    va_arg (vaList, double);
                    break;
                case vtChar:
                    va_arg (vaList, char);
                    break;
                case vtString:
                    va_arg (vaList, char *);
                    break;
                case vtPercent:
                    break;
                case vtUnknown:
                    *pDst = '\0';
                    return;
                default:
                    DPF ("got unknown return type from nvPrintFormattedThing");
                    dbgError("NV Error!");
                    *pDst = '\0';
                    return;
            }
        }
        else {
            *pDst = *pSrc;
            pSrc ++;
            pDst ++;
        }
    }

    *pDst = '\0';
}

EXTERN_C void __cdecl nvSprintf (char *szDest, char *szFormat, ...)
{
    va_list vaList;
    va_start (vaList, szFormat);
    nvSprintfVAL (szDest, szFormat, vaList);
    va_end (vaList);
}

#pragma warning(disable: 4035)  // no return value
EXTERN_C NvU32 nvGetCurrentProcessId()
{
#if IS_WINNT4
  __asm
  {
    mov eax, fs:[0x18]
    mov eax, [eax + 0x20] // return value in eax
  }
#elif IS_WINNT5
  return (NvU32)EngGetCurrentProcessId();
#elif IS_WIN9X
  return GetCurrentProcessId();
#endif
}
#pragma warning(default: 4035)  // no return value

EXTERN_C void nvQueryPerformanceCounter(__int64  *pPerformanceCount)
{
#if IS_WINNT4 || IS_WINNT5
  EngQueryPerformanceCounter(pPerformanceCount);
#elif IS_WIN9X
  QueryPerformanceCounter((LARGE_INTEGER *)pPerformanceCount);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\targa.c ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: targa.c
//      routines for reading and writing targa files
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Jun00         filched from architects
//
// **************************************************************************

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <assert.h>
#include "targa.h"

static FILE *ft = NULL;

static char itype_names[12][16] = {"NULL", "MAP", "RGB", "MONO", "4", "5", "6", "7", "8", "RLE-MAP", "RLE-RGB", "RLE-MONO"};
static char mess[200];

static int  decode_rgb     (HANDLE hFile, int width, int height, DWORD dwBPP, unsigned char *dest);
static int  decode_rgb_rle (HANDLE hFile, int width, int height, DWORD dwBPP, unsigned char *dest);

// Read targa file "filename"
// Put pixels into **xbgr, and set *width and *height
// Pixels are xbgr words on the PC
// This routine copes with raw RGB and run-length encoded RGB targa files only

int read_targa_file (char *filename, unsigned char **xbgr, int *width, int *height)
{
    HANDLE     hFile;
    DWORD      dwBytesRead;
    int        err;
    TGA_Header header;
    char       id[2560];
    DWORD      dwBPP;

    *xbgr = NULL;

    hFile = CreateFile (filename, GENERIC_READ, 0,0, OPEN_EXISTING, 0,0);

    if (hFile == INVALID_HANDLE_VALUE) {
        return(-1);
    }

    ReadFile (hFile, &header, sizeof(TGA_Header), &dwBytesRead, NULL);
    if (!dwBytesRead) {
        return(-2);
    }

    if (header.ImageIDLength > 0) {
        ReadFile (hFile, id, header.ImageIDLength, &dwBytesRead, NULL);
        if (!dwBytesRead) {
            return(-3);
        }
    }

    if ((header.ImgType != TGA_RGB) && (header.ImgType != TGA_RLERGB)) {
        return(-4);
    }

    if ((header.PixelSize != 16) && (header.PixelSize != 24) && (header.PixelSize != 32)) {
        return(-5);
    }

    if (((header.Desc & TGA_DESC_ORG_MASK) != TGA_ORG_TOP_LEFT) &&
        ((header.Desc & TGA_DESC_ORG_MASK) != TGA_ORG_BOTTOM_LEFT)) {
        return(-6);
    }

    *width =  ((header.Width_hi)  << 8) | header.Width_lo;
    *height = ((header.Height_hi) << 8) | header.Height_lo;

    *xbgr = (unsigned char *) GlobalAlloc (GMEM_FIXED, *width * *height * sizeof(int));

    if (!(*xbgr)) {
        return (-100);
    }

    dwBPP = header.PixelSize >> 3;

    if ((header.ImgType == TGA_RGB) && ((header.Desc & TGA_DESC_ORG_MASK) == TGA_ORG_TOP_LEFT)) {
        err = decode_rgb (hFile, *width, *height, dwBPP, *xbgr);
    }
    else if ((header.ImgType == TGA_RLERGB) ) {
        err = decode_rgb_rle (hFile, *width, *height, dwBPP, *xbgr);
    }
    CloseHandle (hFile);

    return (err);
}

// Convert from 24 bits/pixel to 32 bits/pixel

static int decode_rgb
(
    HANDLE  hFile,
    int     width,
    int     height,
    DWORD   dwBPP,
    unsigned char *dest_array
)
{
    unsigned char *src, *dest, *scanline;
    int            y, x;
    DWORD          dwBytesRead;

    scanline = (unsigned char *) GlobalAlloc (GMEM_FIXED, width * dwBPP + 1);
    if (scanline == NULL) {
        return(-7);
    }

    for (y=0; y<height; y++) {

        dest = &dest_array[y * width * 4];

        ReadFile (hFile, scanline, dwBPP*width, &dwBytesRead, NULL);
        if (!dwBytesRead) {
            return(-8);
        }

        src = scanline;
        for (x=0; x<width; x++) {
#ifdef   WIN32
            dest[3] = 0;
            dest[2] = src[0];
            dest[1] = src[1];
            dest[0] = src[2];
#else
            dest[0] = 0;
            dest[1] = src[0];
            dest[2] = src[1];
            dest[3] = src[2];
#endif
            src += dwBPP;
            dest += 4;
        }
    }

    GlobalFree (scanline);

    return(0);
}

// Decode run-length encoded Targa into 32-bit pixels

static int decode_rgb_rle
(
    HANDLE  hFile,
    int     width,
    int     height,
    DWORD   dwBPP,
    unsigned char *dest_array)
{
    unsigned char *src, *dest, packet[520];
    int            i, j, count, raw;
    DWORD          dwBytesRead;
    int            dest_count = width*height;

    dest = dest_array;
    
    for (i=0; i<dest_count;) {
        
        
        ReadFile (hFile, packet, dwBPP+1, &dwBytesRead, NULL); // Read repetition count and first color value
        if (!dwBytesRead) {
            return(-9);
        }
        
        raw = (packet[0] & 0x80) == 0;     // Is this packet raw pixels or a repeating color
        count = (packet[0] & 0x7f) + 1;    // How many raw pixels or color repeats
        i += count;
        src = &packet[1];                  // src[0-(dwBPP-1)] are first color value
        
        if (raw && count > 1) {
            ReadFile (hFile, &packet[dwBPP+1], dwBPP*(count-1), &dwBytesRead, NULL); // Read remainder of raw packet into src[3+]
            if (!dwBytesRead) {
                return(-10);
            }
        }
        
        for (j=0; j<count; j++) {
            
            dest[3] = (dwBPP == 4) ? src[3] : 0;
            dest[2] = src[2];
            dest[1] = src[1];
            dest[0] = src[0];
            
            if (raw)                   // In raw mode, keep advancing "src" to subsequent values
                src += dwBPP;          // In RLE mode, just repeat the packet[1] RGB color
            dest += 4;
        }
        if (!raw) 
            src += dwBPP;             // In RLE mode, advance src beyond color
    }
    
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\nvVPP.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *
 *  File:       nvVPP.cpp
 *  Content:    Shared Video Post Processing Code
 *
 *
 *  VPP pipe for NV4/5:
 *
 *                                           /-----\   /-------\
 *  YUV12           YUV422                   |Scale|   |Colour |
 *    |  /---------\  |                  +-->|Down |-->|Control|--+
 *    +->|Convert  |  |   /----------\   |   \-----/   \-------/  |   /--------\   /----\   /-------\
 *    +->|to YUV422|--+-->|Subpicture|-->+                        +-->|Temporal|-->|Flip|-->|Overlay|
 *    |  \---------/      \----------/   |   /-------\   /-----\  |   |Filter  |   \----/   |Scale  |
 *  YUV9                                 +-->|Colour |-->|Scale|--+   \--------/            \-------/
 *                                           |Control|   |Up   |
 *                                           \-------/   \-----/
 *
 *
 *  VPP pipe for NV10/NV20:
 *
 *  YUV12            YUV422
 *    |  /---------\   |                                                                                     /-------\
 *    +->|Convert  |   |    /----------\   /-----------\   /--------\      /--------\   /----\   /-------\   |Overlay|
 *    +->|to YUV422|---+--->|Subpicture|-->|DeInterlace|-->|Temporal|--+-->|Prescale|-->|Flip|-->|Overlay|-->|Colour |
 *    |  \---------/        \----------/   |Filter     |   |Filter  |  |   \--------/   \----/   |Scale  |   |Control|
 *  YUV9                                   \-----------/   \--------/  |                         \-------/   \-------/
 *                                                                     |
 *                                                                     v
 *                                                                /---------\   /-------\
 *                                                                |FS Mirror|-->|FS Flip|
 *                                                                \---------/   \-------/
 *
 * Initialization/Use Sequence:
 *
 *     VppConstructor()          - Done @ DriverInit.  A few driver escapes to the VPP are safe (but no 4cc blts etc)
 *                                 Allocates DMA contexts.
 *        VppEnable()            - Done @ DirectDraw Enable.  4CC blts are okay using the driver escapes.
 *                                 Allocates object, sets up pointers for access to pusher etc.
 *           VppCreateOverlay()  - Done @ Overlay creation time.  Actually creates the overlay object
 * 
 *           VppDestroyOverlay() - Done when overlay surface is destroyed
 *
 *           [VppCreateFSMirror VPPDestroyFSMirror] - These are at this level as well
 *
 *        VppDisable()           - Done when DirectDraw is disabled (objects are freed, channel ptrs are cleared)
 *
 *     VppDestructor()           - Done @ Driver Exit.  DMA contexts are freed.
 *
 *  Extra surfaces:
 *      In addition to the overlay surfaces that the application creates, 4 extra
 *      (or 3 optimized) work surfaces are created for VPP usage.  The original
 *      data in the overlay surface is never modified.  Each run through the pipe
 *      uses 2 of the extra surfaces (the other two hold video data which is
 *      being displayed or pre-swizzled) and each stage alternates working on
 *      one surface to the other, i.e. the output of one stage is the input for
 *      the next.  On each flip, the 2 working surfaces are swapped with the 2
 *      holding surfaces.
 *
 *  Event protocol
 *      Each stage must generate a unique event (vppSubPicture and vppPrescale are
 *      excepted).  VppDoFlip waits for last event to complete before flipping.
 *      Note that because we can only have one DVD_SUBPICTURE per channel, we must
 *      wait until the previous instance completes before using it again.
 *
 *  Decision making:
 *      Gross level stage enable decisions are made in VppDoFlip.  More complex
 *      decision making which may require computation is made within the stage.  Each
 *      stage returns TRUE if it succeeds, FALSE if not.  If the stage returns FALSE,
 *      it must do nothing so that video can still proceed though the pipe.
 *
 *  State changes:
 *      Each stage is responsible for changing the surface parameters if a stage
 *      modifies them.  This can either be done within the stage, or in VppDoFlip
 *      upon successful completion of the stage.  E.g. the convert stage changes
 *      the fourcc code and the prescaler changes the width and height.
 *
 *  Stage enables and disables:
 *      There can be up to 3 levels of stage enables:
 *      1) Most (but not all) stages have registry enables
 *      2) Each stage is selectively enabled by the caller of VppDoFlip
 *      3) The enable flags passed by the caller are masked by an inverse mask set in the registry
 *      The final enable is determined by ((2 & ~3) && 1)
 *
 ***************************************************************************/

// For 9x and NT5, nvprecomp.h comes from the ddraw common area,
// for NT4, it comes from drivers/display/winnt4/ddraw/nv4/nvprecomp.h
#include "nvprecomp.h"
#include "wincommon.h"

#include "nvVPP.h"

// We define this as a null label to use instead of 'static' to indicate to the reader that a function
// is intended for use only within this file.  If we define the functions as static, we get reports off
// faults from the last exported function instead of the function we should be looking at.
#define LOCAL

#if (IS_WINNT4 || IS_WINNT5)
#undef GET_MODE_BPP
#define GET_MODE_BPP()       (vpp.m_ppdev->cBitsPerPel)
#define LOGICAL_HEAD_ID()    (vpp.m_ppdev->ulDeviceDisplay[0])
#define DRIVER_HANDLE()      (vpp.m_ppdev->hDriver)
#else
#define LOGICAL_HEAD_ID()    (pDXShare->dwHeadNumber)
#define DRIVER_HANDLE()      (0)
#endif

#if (IS_WINNT5)
extern "C" BOOL __cdecl NvSetDac(PDEV *ppdev, ULONG ulHead, RESOLUTION_INFO * pResolution);
extern "C" void __cdecl DisableHeadCursor(PDEV *ppdev, ULONG ulHead, ULONG ulDiable);
extern "C" void __cdecl NVMoveDisplayWindow(PDEV* ppdev, ULONG ulHead, RECTL * prclCurrentDisplay);
extern "C" void __cdecl NvSetDacImageOffset(PDEV* ppdev, ULONG ulDac, ULONG ulOffset);
#endif

// *********************************************************************
// Local Prototypes
// *********************************************************************
LOCAL void vppFreeOverlay(Vpp_t *pVpp);
LOCAL NvU8 vppAllocOverlay(Vpp_t *pVpp);
LOCAL void vppChooseOverlayHead(Vpp_t *pVpp);
LOCAL BOOL vppAllocateObjects(Vpp_t *pVpp);
LOCAL void vppFreeObjects(Vpp_t *pVpp);
LOCAL void vppInitObjects(Vpp_t *pVpp);
LOCAL BOOL vppAllocateContextDMAs(Vpp_t *pVpp);
LOCAL void vppFreeContextDMAs(Vpp_t *pVpp);
LOCAL BOOL vppInitCelsius(Vpp_t *pVpp);
LOCAL BOOL vppInitKelvin(Vpp_t *pVpp);
LOCAL BOOL vppValidateMode(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel,
                            DWORD dwNumSurfaces, DWORD dwHead, DWORD dwRefreshRate, DWORD dwDCHead, DWORD dwDeviceType);
LOCAL BOOL vppPreCopy(Vpp_t *pVpp, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                       DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight);
LOCAL BOOL vppConvert(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                       DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC);
LOCAL BOOL vppSubPicture(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                          DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC);
LOCAL BOOL vppPreScale(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset, DWORD dwDstPitch,
                        LPDWORD pWidth, LPDWORD pHeight, DWORD dwFourCC, LPDWORD dwField);
LOCAL BOOL vppFSMirror(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwWidth, DWORD dwHeight,
                        DWORD dwFourCC, DWORD dwFlags, DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY);
LOCAL BOOL vppColourControl(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset, DWORD dwDstPitch,
                             DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC, DWORD dwField);
LOCAL BOOL vppNv20Deinterlace(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                               DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags);
LOCAL BOOL vppNv20Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                            DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDWORD pPrevFrameOffset);
LOCAL BOOL vppNv10Deinterlace(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                               DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags);
LOCAL BOOL vppNv10Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                            DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDWORD pPrevFrameOffset);
LOCAL BOOL vppNv5Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                           DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, LPDWORD pPrevFrameOffset);
LOCAL BOOL vppFSFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait);
LOCAL BOOL vppFSFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex);
LOCAL BOOL vppFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait);
LOCAL BOOL vppFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                    DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight,
                    DWORD dwIndex, DWORD dwFourCC, DWORD dwFlags,
                    DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY);
LOCAL void vppBltFillBlock(Vpp_t *pVpp, NvU32 dwColor, NvU32 dwOffset, NvU32 dwPitch, NvU32 dwWidth, NvU32 dwHeight, NvU32 dwBytesPerPel);
LOCAL void vppBltWriteDword(Vpp_t *pVpp, NvU32 dwOffset, NvU32 dwIndex, NvU32 dwData);
LOCAL void vppBltUpdateClip(Vpp_t *pVpp);

extern NvU8 VppIsConstructed(Vpp_t *pVpp)
{
    nvAssert(pVpp);
    return ((pVpp->dwFlags & VPP_FLAG_CONSTRUCTED) != 0 );
}
extern NvU8 VppIsOverlayActive(Vpp_t *pVpp)
{
    nvAssert(pVpp);
    return ((pVpp->dwFlags & VPP_FLAG_OVERLAY_READY) != 0 );
}

// These substitute for the real constructor/destructor that we'd have in C++
static VppObjectRecord_t VppDefaultObjects[VPP_OBJECT_COUNT] =
{
    {VPP_OBJ_FREED, NV10_VIDEO_OVERLAY,            NV_VPP_OVERLAY_IID,         NV_VPP_OVERLAY_CONTEXT_IID,       3, NULL}, // May be NV4_OVERLAY
    {VPP_OBJ_NA,    NV04_SCALED_IMAGE_FROM_MEMORY, NV_VPP_SWIZZLE_BLIT_IID,    NV_VPP_SWIZZLE_BLIT_CONTEXT_IID,  1, NULL}, // Used on NV4/NV5 only
    {VPP_OBJ_NA,    NV01_TIMER,                    NV_VPP_TIMER_IID,           NV_VPP_TIMER_CONTEXT_IID,         2, NULL},
    {VPP_OBJ_FREED, NV04_IMAGE_BLIT,               NV_VPP_ALPHA_BLIT_IID,      NV_VPP_ALPHA_BLIT_CONTEXT_IID,    1, NULL},
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_V2V_FORMAT_Y_IID,    NV_VPP_V2V_FORMAT_Y_CONTEXT_IID,  2, NULL},
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_V2OSH_FORMAT_IID,    NV_VPP_V2OSH_FORMAT_CONTEXT_IID,  2, NULL},
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_OSH2V_FORMAT_IID,    NV_VPP_OSH2V_FORMAT_CONTEXT_IID,  2, NULL},
    {VPP_OBJ_FREED, NV10_SCALED_IMAGE_FROM_MEMORY, NV_VPP_SCALED_IMAGE1_IID,   NV_VPP_SCALED_IMAGE1_CONTEXT_IID, 1, NULL}, // will be NV4, NV5 or NV10
    {VPP_OBJ_FREED, NV10_SCALED_IMAGE_FROM_MEMORY, NV_VPP_SCALED_IMAGE2_IID,   NV_VPP_SCALED_IMAGE2_CONTEXT_IID, 1, NULL}, // will be NV4, NV5 or NV10
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_DMABLT_TO_VID_IID,   NV_VPP_DMABLT_TO_VID_CONTEXT_IID, 2, NULL},
    {VPP_OBJ_FREED, NV04_DVD_SUBPICTURE,           NV_VPP_DVD_SUBPICTURE_IID,  NV_VPP_DVD_SUBPICTURE_CONTEXT_IID,1, NULL}, // may upgrade to NV10

};

#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

//---------------------------------------------------------------------------
// vppDispatcher
//      Remote dispatcher for VppDoFlip
#define PDRIVERDATA     ((GLOBALDATA *)pData)
#define TIME_INFINITY   0x7FFFFFFF
LOCAL DWORD WINAPI vppDispatcher(Vpp_t *pVpp,LPVOID pData)
{
    // create signal
#if IS_WINNT5
    EngCreateEvent(&(vppDispatch.hSignalGo0));
    vppDispatch.hSignalGo3 = vppDispatch.hSignalGo0;
    EngCreateEvent(&(vppDispatch.hSignalDone0));
    vppDispatch.hSignalDone3 = vppDispatch.hSignalDone0;
#elif IS_WINNT4
    // Do something for NT4
#elif IS_WIN9X
    vppDispatch.hSignalGo3 = CreateEvent(NULL, TRUE, FALSE, EVENTNAME_DISPATCH_GO);
    vppDispatch.hSignalGo0 = ConvertRing3EventToRing0(vppDispatch.hSignalGo3);
    vppDispatch.hSignalDone3 = CreateEvent(NULL, FALSE, FALSE, EVENTNAME_DISPATCH_DONE);
    vppDispatch.hSignalDone0 = ConvertRing3EventToRing0(vppDispatch.hSignalDone3);
#endif
    if (vppDispatch.hSignalGo3 == NULL ||
        vppDispatch.hSignalGo0 == NULL ||
        vppDispatch.hSignalDone3 == NULL ||
        vppDispatch.hSignalDone0 == NULL) {

        vppDispatch.dwState |= VPPDSTATE_INITERROR | VPPDSTATE_TERMINATED;
        CLOSE_HANDLE(vppDispatch.hSignalGo3);
        CLOSE_HANDLE(vppDispatch.hSignalDone3);
        vppDispatch.hSignalGo3 = NULL;
        vppDispatch.hSignalGo0 = NULL;
        vppDispatch.hSignalDone3 = NULL;
        vppDispatch.hSignalDone0 = NULL;
        return -1;
    }

    vppDispatch.procInfo.hProcess = GetCurrentProcess();
    vppDispatch.procInfo.dwProcessId = nvGetCurrentProcessId();
    vppDispatch.dwOriginalThreadPriority = GetThreadPriority(GetCurrentThread());
    vppDispatch.dwOriginalProcessPriority = GetPriorityClass(GetCurrentProcess());

    vppDispatch.dwState &= ~VPPDSTATE_CMDERROR;
    vppDispatch.dwState &= ~VPPDSTATE_INITERROR;
    vppDispatch.dwState &= ~VPPDSTATE_TERMINATED;

    // explicitly reset these events, windows does not seem to set initial state properly
    VppResetNotification(NULL,vppDispatch.hSignalGo3);
    VppResetNotification(NULL,vppDispatch.hSignalDone3);

    while (vppDispatch.dwCommand != VPPDISPATCH_EXIT) {
        vppDispatch.dwState &= ~VPPDSTATE_BUSY;
        vppDispatch.dwState |= VPPDSTATE_WAITING;

        nvWaitEvent(vppDispatch.hSignalGo3, TIME_INFINITY);

        vppDispatch.dwState &= ~VPPDSTATE_WAITING;
        vppDispatch.dwState |= VPPDSTATE_BUSY;

        switch (vppDispatch.dwCommand) {
        case VPPDISPATCH_NOOP:
        case VPPDISPATCH_EXIT:
            break;

        case VPPDISPATCH_DISPATCH:
            vppDispatch.dwReturnCode = VppDoFlip(vppDispatch.dwOffset,
                                                                  vppDispatch.dwPitch,
                                                                  vppDispatch.dwWidth,
                                                                  vppDispatch.dwHeight,
                                                                  vppDispatch.dwFourCC,
                                                                  vppDispatch.dwFlags);
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;

        case VPPDISPATCH_SETPRIORITY:
            SetThreadPriority(GetCurrentThread(), vppDispatch.dwThreadPriority);
            SetPriorityClass(GetCurrentProcess(), vppDispatch.dwProcessPriority);
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;

        case VPPDISPATCH_RESTOREPRIORITY:
            SetThreadPriority(GetCurrentThread(), vppDispatch.dwOriginalThreadPriority);
            SetPriorityClass(GetCurrentProcess(), vppDispatch.dwOriginalProcessPriority);
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;

        default:
            vppDispatch.dwState |= VPPDSTATE_CMDERROR;
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;
        }

        VppResetNotification(NULL,vppDispatch.hSignalGo3);
        setEvent(NULL,vppDispatch.hSignalDone3);
    }

    SetThreadPriority(GetCurrentThread(), vppDispatch.dwOriginalThreadPriority);
    SetPriorityClass(GetCurrentProcess(), vppDispatch.dwOriginalProcessPriority);

    vppDispatch.dwState |= VPPDSTATE_TERMINATED;

    // destroy signal
    CLOSE_HANDLE((HANDLE)vppDispatch.hSignalGo3);
    vppDispatch.hSignalGo3 = NULL;
    vppDispatch.hSignalGo0 = NULL;
    CLOSE_HANDLE((HANDLE)vppDispatch.hSignalDone3);
    vppDispatch.hSignalDone3 = NULL;
    vppDispatch.hSignalDone0 = NULL;
    return 0;
}

//---------------------------------------------------------------------------
// vppInitDispatcher
//      Initializes vpp dispatcher, should be called from DriverInit
LOCAL BOOL vppInitDispatcher(Vpp_t *pVpp)
{
    vppDestroyDispatcher();

    vppDispatch.dwState = 0;
    vppDispatch.dwCommand = VPPDISPATCH_NOOP;

    vppDispatch.procInfo.hThread = CreateThread(NULL, 4096, vppDispatcher, pDriverData, 0, &vppDispatch.procInfo.dwThreadId);
    if (vppDispatch.procInfo.hThread == NULL) {
        vppDestroyDispatcher();
        return FALSE;
    }

    // may as well init some subpicture vars while we are here
    vpp.subPicture.originX = 0xFFFFFFFF;
    vpp.subPicture.originY = 0xFFFFFFFF;
    vpp.subPicture.width = 0xFFFFFFFF;
    vpp.subPicture.height = 0xFFFFFFFF;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppDestroyDispatcher
//      Destroys vpp dispatcher, should be called from DestroyDriver
LOCAL void vppDestroyDispatcher(Vpp_t *pVpp)
{
    if (vppDispatch.procInfo.hThread) {
        HDRVEVENT vppSignalGo, vppSignalDone;

#if IS_WINNT5
        vppSignalGo   = vppDispatch.hSignalGo0;
        vppSignalDone = vppDispatch.hSignalDone0;
#elif IS_WINNT4
        // Do something here
#elif IS_WIN9X
        vppSignalGo   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DISPATCH_GO);
        vppSignalDone = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DISPATCH_DONE);
#endif
        vppDispatch.dwCommand = VPPDISPATCH_EXIT;
        NvSetEvent(vppSignalGo);
        VppWaitForNotification(NULL, vppSignalDone, 1000);
    }

    vppDispatch.dwState = VPPDSTATE_TERMINATED;
    vppDispatch.dwCommand = VPPDISPATCH_EXIT;
    vppDispatch.dwThreadPriority = THREAD_PRIORITY_IDLE;
    vppDispatch.dwProcessPriority = IDLE_PRIORITY_CLASS;
    vppDispatch.dwOriginalThreadPriority = 0;
    vppDispatch.dwOriginalProcessPriority = 0;
    vppDispatch.procInfo.hProcess = 0;
    vppDispatch.procInfo.hThread = 0;
    vppDispatch.procInfo.dwProcessId = 0;
    vppDispatch.procInfo.dwThreadId = 0;
    vppDispatch.hSignalGo0 = NULL;
    vppDispatch.hSignalGo3 = NULL;
    vppDispatch.hSignalDone0 = NULL;
    vppDispatch.hSignalDone3 = NULL;
    vppDispatch.dwOffset = 0;
    vppDispatch.dwPitch = 0;
    vppDispatch.dwWidth = 0;
    vppDispatch.dwHeight = 0;
    vppDispatch.dwFourCC = 0;
    vppDispatch.dwFlags = 0;
}

#endif

//
// VppGetVideoScalerBandwidthStatus
// TBD: this probably needs a better interface @mjl@.
//
extern NvU8 VppGetVideoScalerBandwidthStatus(Vpp_t *pVpp, NvU16 wWidth)
{
    Vpp_t &vpp = *pVpp;
    NvU32 dwGetDownScaleRatioX;
    NvU32 dwAllowed;

    nvAssert(vpp.dwFlags & VPP_FLAG_CONSTRUCTED);

    if (wWidth <= 768) {
        dwGetDownScaleRatioX = NV_CFG_VIDEO_DOWNSCALE_RATIO_768;
    } else if (wWidth <= 1280) {
        dwGetDownScaleRatioX = NV_CFG_VIDEO_DOWNSCALE_RATIO_1280;
    } else {
        dwGetDownScaleRatioX = NV_CFG_VIDEO_DOWNSCALE_RATIO_1920;
    }

    // Get max overlay downscale
    NvRmConfigGet(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle, 
        dwGetDownScaleRatioX, &(vpp.dwOverlayMaxDownScale));

    if (vpp.dwOverlayMaxDownScale == 0)
    {
        vpp.dwOverlayMaxDownScale = 1;  // this can be reported as zero on NV4
    }
    vpp.dwOverlayMaxDownScaleX = vpp.dwOverlayMaxDownScale;
    vpp.dwOverlayMaxDownScaleY = vpp.dwOverlayMaxDownScale;

    // Ask the resource manager if a video scaler is allowed within the current
    // resolution, given the current clocks and bandwidth limitations
    NvRmConfigGet(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                   NV_CFG_VIDEO_OVERLAY_ALLOWED, &(dwAllowed));

    return (dwAllowed ? TRUE : FALSE);
}

#ifdef WINNT
extern NvU8 VppConstructor(PDEV *ppdev, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo)
#else
extern NvU8 VppConstructor(GLOBALDATA *pDriverData, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo)
#endif
{
    Vpp_t &vpp = *pVpp;
    DWORD dwArch;
#ifdef WINNT
    GLOBALDATA *pDriverData = ppdev->pDriverData;
#endif

    nvAssert(pVpp);
    nvAssert(pSysInfo);

    if (VppIsConstructed(pVpp))
    {
        dbgError("VPP: VppConstructor being called again -- before destructor\n");
        return TRUE;
    }

    // Much up everything so that we can easily see uninitialized data
    memset(pVpp, 0,sizeof(*pVpp));

    vpp.pDriverData = pDriverData;  // Hopefully this will someday go away

#ifdef WINNT
    vpp.m_ppdev = ppdev;            // Hopefully this will someday go away
#else
    vpp.m_ppdev = NULL;             // Hopefully this will someday go away
#endif

    vpp.pSysInfo = pSysInfo;    // This is used early in nvpriv routines (by control panel) so it MUST
                                // be set early in VppConstructor (@ Driver Init time)
    vpp.dwDecoderIdentity = 0;
    vpp.dwDecoderCaps = 0;
    
    vpp.dwFlags = 0;
    vpp.m_pContextDMABase = 0;
    vpp.dwOverlayEventsAllocated = FALSE;
    vpp.pPusher = NULL;
    vpp.pThreeDClassLastUser = NULL;

    vpp.hImageBlackRect = NULL;
    vpp.hContextPattern = NULL;
    vpp.hContextRop = NULL;
    vpp.hContextColorKey = NULL;
    vpp.hFloatingContextDmaInOverlayShadow = NULL;
    vpp.hVideoMemUtoVideoMemFormat = NULL;
    vpp.hVideoMemVtoVideoMemFormat = NULL;
    vpp.hVideoMemUVtoVideoMemFormat = NULL;
    vpp.hLutCursorDacBase = NULL;
    vpp.hMiscEventNotifier = NULL;
    vpp.hContextSurfaceSwizzled = NULL;
    vpp.hContextBeta4 = NULL;
    vpp.hSurfaces2D = NULL;
    vpp.hChannel = NULL;
    vpp.hThreeDClass = NULL;
    vpp.hInVideoMemContextDma = NULL;
    vpp.hFromVideoMemContextDma = NULL;
    vpp.hToVideoMemContextDma = NULL;
    vpp.hThreeDClass = NULL;
    vpp.hContextSurfacesARGB_ZS = NULL;
    vpp.hDX6MultiTextureTriangle = NULL;

    vpp.pFlipPrimaryNotifier = NULL;
    vpp.pPusherSyncNotifier = NULL;

    vpp.ropRectTextSubCh = 0xffffffff;
    vpp.ropSubCh = 0xffffffff;
    vpp.spareSubCh = 0xffffffff;
    vpp.surfaces2DSubCh = 0xffffffff;
    vpp.threeDClassSubCh = 0xffffffff;

    vpp.dwOverlayFSNumSurfaces = 0;
    vpp.dwOverlayFSOvlLost = FALSE;

    vpp.dwOverlayFSWidth     = 0;
    vpp.dwOverlayFSHeight    = 0;
    vpp.dwOverlayFSPitch     = 0;
    vpp.dwOverlayFSFormat    = 0;
    vpp.dwOverlayFSIndex     = 0;
    vpp.dwOverlayFSDeltaX    = 0;
    vpp.dwOverlayFSDeltaY    = 0;

    memset(&(vpp.dwOverlayFSOffset),0,sizeof(vpp.dwOverlayFSOffset));  // Init arrays to zero
    memset(&(vpp.extraOverlayOffset),0,sizeof(vpp.extraOverlayOffset));
    memset(&(vpp.dwOverlaySurfaceLCL),0,sizeof(vpp.dwOverlaySurfaceLCL));

    vpp.extraPitch       = 0;
    vpp.extraNumSurfaces = 0;
    vpp.extraIndex       = 0;

    vpp.dwOverlaySrcWidth  = 0;
    vpp.dwOverlaySrcHeight = 0;
    vpp.dwOverlayDstWidth  = 0;
    vpp.dwOverlayDstHeight = 0;
    vpp.dwOverlayDeltaX    = 0;
    vpp.dwOverlayDeltaY    = 0;

    vpp.dwOverlaySrcX      = 0;
    vpp.dwOverlaySrcY      = 0;
    vpp.dwOverlayDstX      = 0;
    vpp.dwOverlayDstY      = 0;
    vpp.dwOverlaySrcOffset = 0;
    vpp.dwOverlayFormat    = 0;
    vpp.dwOverlaySrcPitch  = 0;

    vpp.dwOverlayLastVisibleFpVidMem    = 0xffffffff;
    vpp.dwOverlayLastVisiblePitch       = 0xffffffff;
    vpp.dwOverlayLastVisiblePixelFormat = 0xffffffff;
    vpp.dwOverlayFlipCount              = 0;
    vpp.overlayBufferIndex              = 0;
    vpp.overlayRelaxOwnerCheck          = FALSE;
    vpp.dwOverlaySrcSize                = 0;
    vpp.dwOverlayColorKey               = 0;
    vpp.dwOverlaySrcPitch               = 0;
    vpp.dwOverlayCachedFlags            = 0;
    vpp.dwOverlayFSSrcWidth             = 0;
    vpp.dwOverlayFSSrcHeight            = 0;
    vpp.dwOverlayFSSrcMinX              = 0;
    vpp.dwOverlayFSSrcMinY              = 0;
    vpp.dwOverlayMaxDownScale           = 0;
    vpp.dwOverlayMaxDownScaleX          = 0;
    vpp.dwOverlayMaxDownScaleY          = 0;
    vpp.regRing0ColourCtlInterlockFlags = 0;

    memset(&(vpp.dwOverlayFSTwinData), 0,sizeof(vpp.dwOverlayFSTwinData));

    vpp.dwOverlayMode     = 0;
    vpp.dwPrevFrameOffset = 0;
    vpp.llDeliveryPeriod  = 0;
    vpp.llDeliveryTime    = 0;
    vpp.llDeliveryStart   = 0;

    memset(&(vpp.subPicture),0x0,sizeof(vpp.subPicture));
    memset(&(vpp.pipeState),0x0,sizeof(vpp.pipeState));
    memset(&(vpp.snoop),0x0,sizeof(vpp.snoop));

    // Initialize overlay alignment.

    if (NvRmConfigGet(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle, NV_CFG_ARCHITECTURE, &dwArch) != NVOS_CGE_STATUS_SUCCESS)
    {
        dbgError("Failed to query arch from RM in VPP constructor!");
        return FALSE;
	}

    if (dwArch >= 5) { // NV10
        vpp.dwOverlayByteAlignmentPad = NV_OVERLAY_BYTE_ALIGNMENT_PAD;
    }
    else {
        vpp.dwOverlayByteAlignmentPad = vpp.pDriverData->dwSurfaceAlignPad;
    }

    vpp.dwOverlaySurfaces              = 0;
    vpp.dwOverlayLastVisibleSurfaceLCL = 0;
    vpp.dwOverlayFSOvlHead             = 0xFFFFFFFF;
    vpp.dwOverlayFSOvlHeadSaved        = 0xFFFFFFFF;

    vpp.colorCtrl.dwSize = sizeof(vpp.colorCtrl);
    vpp.colorCtrl.dwFlags = NV_VPP_COLOR_BRIGHTNESS |
                            NV_VPP_COLOR_CONTRAST   |
                            NV_VPP_COLOR_SATURATION |
                            NV_VPP_COLOR_HUE;
    vpp.colorCtrl.lSharpness  = 0;
    vpp.colorCtrl.lHue        = 0;
    vpp.colorCtrl.dwReserved1 = 0;

    // Initialize overlay color control data to default Microsoft values
    if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10)
    {
        vpp.colorCtrl.lBrightness  =    0;
        vpp.colorCtrl.lContrast    =  255;
        vpp.colorCtrl.lHue         =    0;
        vpp.colorCtrl.lSaturation  =  256;
        vpp.colorCtrl.lGamma       =  255;
        vpp.colorCtrl.lColorEnable =    1;
        vpp.subPicture.format      = NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
    }
    else
    {
        vpp.colorCtrl.lBrightness  =   750;
        vpp.colorCtrl.lContrast    = 10000;
        vpp.colorCtrl.lSaturation  = 10000;
        vpp.colorCtrl.lGamma       =     0;
        vpp.colorCtrl.lColorEnable =     0;
        vpp.subPicture.format      = NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
    }

    vpp.fpOverlayShadow = 0;
    vpp.dwOverlayFSHead = 0xFFFFFFFF;

    // Overlay colour control stuff
    vpp.regOverlayColourControlEnable = 0;
    vpp.regOverlayMode    = 0;
    vpp.regOverlayMode2   = NV4_REG_OVL_MODE2_FSASPECT | NV4_REG_OVL_MODE2_FSTRACKOVLASPECT | NV4_REG_OVL_MODE2_FSSETMODE;
    vpp.regOverlayMode3   = 0;
    vpp.regVPPInvMask     = 0;
    vpp.regVPPMaxSurfaces = NV_VPP_MAX_EXTRA_SURFACES;

    memcpy(vpp.m_obj_a,&VppDefaultObjects,sizeof(VppDefaultObjects));

    if (vpp.pSysInfo->dwNVClasses & NVCLASS_0088_DVDPICT)
    {
        vpp.m_obj_a[DVDPICT_NDX].classNdx = NV10_DVD_SUBPICTURE;
    }
    else
    {
        nvAssert(vpp.pSysInfo->dwNVClasses & NVCLASS_0038_DVDPICT);
    }

    // Select the SCALED_IMAGE class based on what we have (in order of preference)
    if      (vpp.pSysInfo->dwNVClasses & NVCLASS_0089_SCALEDIMG) vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx = NV10_SCALED_IMAGE_FROM_MEMORY;
    else if (vpp.pSysInfo->dwNVClasses & NVCLASS_0063_SCALEDIMG) vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx = NV05_SCALED_IMAGE_FROM_MEMORY;
    else if (vpp.pSysInfo->dwNVClasses & NVCLASS_0077_SCALEDIMG) vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx = NV04_SCALED_IMAGE_FROM_MEMORY;
    vpp.m_obj_a[SCALED_IMAGE2_NDX].classNdx = vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx;

    // For NV4 & NV5:
    //
    // Can't have more than one surfaces type for each channel, so share NV_DD_SURFACES_2D,
    //  D3D_CONTEXT_SURFACE_SWIZZLED, and vpp.hContextSurfacesARGB_ZS instead of using
    //      objects comment out below
    //   For NV_DD_SURFACES_2D_A8R8G8B8, we only change the pixel depth so be sure to restore that
    //   For NV_DD_SURFACES_3D, call nvSetD3DSurfaceState(pContext) to restore
    //   For NV_DD_SURFACES_SWIZZLED, D3D restores its state on each usage, ok to dirty it
    //
    // @mjl@ the above are probably out of date... TBD

    if (vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)
    {
        vpp.dwFlags |= VPP_FLAG_KELVIN_3D;
    }
    else if (vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_CELSIUS)
    {
        vpp.dwFlags |= VPP_FLAG_CELSIUS_3D;
    }
    else
    {
        vpp.m_obj_a[OVERLAY_NDX].classNdx = NV04_VIDEO_OVERLAY; // Used NV04 overlay instead of NV10
        vpp.m_obj_a[SWIZZLE_NDX].status   = VPP_OBJ_FREED;      // 'Enables' this object
    }

    // If we have the timer class, turn it on
    if (vpp.pSysInfo->dwNVClasses & NVCLASS_0004_TIMER)
    {
        vpp.m_obj_a[TIMER_NDX].status = VPP_OBJ_FREED;      // 'Enables' this object
    }
    
    if (!vppAllocateContextDMAs(pVpp))
    {
        dbgError("Failed to allocate a context DMA in VPP constructor!");
        return FALSE;
    }

    vpp.dwFlags |= VPP_FLAG_CONSTRUCTED; // Construction is done

	return TRUE;
}

void VppDestructor(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    if (!VppIsConstructed(pVpp)) return;    // This can occur under special circumstance

    vppFreeContextDMAs(pVpp);

    if (vpp.fpOverlayShadow) {
        FreeIPM((void*)vpp.fpOverlayShadow);
    }

    // Wreck the data in VPP to make sure we don't make use of it somehow
    //  NB: This implicitly clears VPP_FLAG_CONSTRUCTED
    memset(pVpp, 0,sizeof(*pVpp));
}

//------------------------------------------------------------------------------
// some utility functions to manage switching between using notifiers and events
//
// These are not meant to be called by the general driver, but only the nvPriv
//

extern int VppWaitForNotification(NvNotification* pNotify, HDRVEVENT hEvent, unsigned long timeOut)
{
#ifdef VPP_USE_EVENT_NOTIFIERS
    nvAssert(hEvent);

    if (IS_EVENT_ERROR(NvWaitEvent(hEvent, timeOut)))
    {
        return -1;
    }
#else
    unsigned long count = timeOut;
    nvAssert(pNotify);

#ifdef IKOS
    while(pNotify->status == NV_IN_PROGRESS) // on IKOS we'll ignore timeOut; could be a very long time
#else
    while( (count>0) && (pNotify->status == NV_IN_PROGRESS) )
#endif
    {
        // TBD: find out how VPP_TIMEOUT_TIME was derived.  Use pSysInfo->dwSpinLoopCount instead perhaps @mjl@
        nvSpin(timeOut);
        count--;
    }
#endif
    return 0;
}

extern void VppResetNotification(NvNotification* pNotify, HDRVEVENT hEvent)
{
#ifdef VPP_USE_EVENT_NOTIFIERS
    nvAssert(hEvent);
    NvResetEvent(hEvent);
#else
    nvAssert(pNotify);
    pNotify->status = NV_IN_PROGRESS;
#endif
}

#if (NVARCH >= 0x10)
//---------------------------------------------------------------------------
// vppInitCelsius
//      Inits celsius object for temporal filter usage.  Celsius is a shared,
//      cached object, so these methods only get set when we are a new consumer
LOCAL BOOL vppInitCelsius(Vpp_t *pVpp)
{
    DWORD tmpVal;
    float fBuffer[16];
    unsigned long *ftol = (unsigned long *)&fBuffer[0];
    float xTrans, yTrans, zTrans;
    Vpp_t &vpp = *pVpp;

#if (NVARCH >= 0x20)
    nvAssert (!(vpp.dwFlags & VPP_FLAG_KELVIN_3D));
#endif
    nvAssert(vpp.dwFlags & VPP_FLAG_CELSIUS_3D);

    nvAssert(vpp.pThreeDClassLastUser);
    *vpp.pThreeDClassLastUser = MODULE_ID_DDRAW_VPP;

    // Let D3D code know that we have touched NV
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // Set object
    vpp.pPusher->setObject(vpp.threeDClassSubCh,vpp.hThreeDClass);

    if (vpp.dwFlags & VPP_FLAG_CELSIUS_3D)
    {
        NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

        // Reset the celsius context Dmas to use the default video context Dma
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_CONTEXT_DMA_A | 0x40000);
        vpp.pPusher->push(1, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_CONTEXT_DMA_B | 0x40000);
        vpp.pPusher->push(3, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_CONTEXT_DMA_VERTEX | 0x40000);
        vpp.pPusher->push(5, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_CONTEXT_DMA_STATE | 0x40000);
        vpp.pPusher->push(7, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_CONTEXT_DMA_COLOR | 0x40000);
        vpp.pPusher->push(9, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_CONTEXT_DMA_ZETA | 0x40000);
        vpp.pPusher->push(11, vpp.hInVideoMemContextDma);

        vpp.pPusher->adjust(12);

        // Set up one window clip rectangle to be the rendered area
        // All the other rectangles are deactivated
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
        vpp.pPusher->push(1, ((2047 << 16) | (-2048 & 0xfff)));
        vpp.pPusher->push(2, 0);
        vpp.pPusher->push(3, 0);
        vpp.pPusher->push(4, 0);
        vpp.pPusher->push(5, 0);
        vpp.pPusher->push(6, 0);
        vpp.pPusher->push(7, 0);
        vpp.pPusher->push(8, 0);

        vpp.pPusher->push(9, subchannel +
                      NV056_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
        vpp.pPusher->push(10, ((2047 << 16) | (-2048 & 0xfff)));
        vpp.pPusher->push(11, 0);
        vpp.pPusher->push(12, 0);
        vpp.pPusher->push(13, 0);
        vpp.pPusher->push(14, 0);
        vpp.pPusher->push(15, 0);
        vpp.pPusher->push(16, 0);
        vpp.pPusher->push(17, 0);

        vpp.pPusher->push(18, subchannel +
                       NV056_SET_WINDOW_CLIP_TYPE | 0x40000);
        vpp.pPusher->push(19, NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);
        vpp.pPusher->adjust(20);

        // Enable transforms
        tmpVal = (NV056_SET_TLMODE_W_DIVIDE_1_DISABLE << 2) |
                 (NV056_SET_TLMODE_W_DIVIDE_0_DISABLE << 1) |
                  NV056_SET_TLMODE_PASSTHROUGH_FALSE;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TLMODE | 0x40000);
        vpp.pPusher->push(1, tmpVal);
        vpp.pPusher->adjust(2);

        // Set Control0 defaults
        tmpVal = (NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
                 (NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
                 (NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
                 (NV056_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
                 (NV056_SET_CONTROL0_WBUFFER_SELECT_0 << 8) |
                 (NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_CONTROL0 | 0x40000);
        vpp.pPusher->push(1, tmpVal);

        vpp.pPusher->adjust(2);

        // Load ModelView matrix and inverse ModelView matrix with identity
        fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[4]);
        vpp.pPusher->push(3, ftol[8]);
        vpp.pPusher->push(4, ftol[12]);
        vpp.pPusher->push(5, ftol[1]);
        vpp.pPusher->push(6, ftol[5]);
        vpp.pPusher->push(7, ftol[9]);
        vpp.pPusher->push(8, ftol[13]);
        vpp.pPusher->push(9, ftol[2]);
        vpp.pPusher->push(10, ftol[6]);
        vpp.pPusher->push(11, ftol[10]);
        vpp.pPusher->push(12, ftol[14]);
        vpp.pPusher->push(13, ftol[3]);
        vpp.pPusher->push(14, ftol[7]);
        vpp.pPusher->push(15, ftol[11]);
        vpp.pPusher->push(16, ftol[15]);

        vpp.pPusher->push(17, subchannel +
                       NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
        vpp.pPusher->push(18, ftol[0]);
        vpp.pPusher->push(19, ftol[4]);
        vpp.pPusher->push(20, ftol[8]);
        vpp.pPusher->push(21, ftol[12]);
        vpp.pPusher->push(22, ftol[1]);
        vpp.pPusher->push(23, ftol[5]);
        vpp.pPusher->push(24, ftol[9]);
        vpp.pPusher->push(25, ftol[13]);
        vpp.pPusher->push(26, ftol[2]);
        vpp.pPusher->push(27, ftol[6]);
        vpp.pPusher->push(28, ftol[10]);
        vpp.pPusher->push(29, ftol[14]);
        vpp.pPusher->push(30, ftol[3]);
        vpp.pPusher->push(31, ftol[7]);
        vpp.pPusher->push(32, ftol[11]);
        vpp.pPusher->push(33, ftol[15]);

        vpp.pPusher->adjust(34);

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_SURFACE_FORMAT | 0x40000);
        vpp.pPusher->push(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
                       NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8);
        vpp.pPusher->adjust(2);

        // Set up viewport
        xTrans = (float)(-2048.0 - (1.0 / 32.0)); // hardware epsilon
        yTrans = (float)(-2048.0 - (1.0 / 32.0));
        zTrans = 0.0;

        // Load composite matrix assuming full pel scaling of surface coordinates
        fBuffer[0]  = 0.25; // quarter pel xScale
        fBuffer[1]  = 0.0;
        fBuffer[2]  = 0.0;
        fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;
        fBuffer[5]  = 0.25; // quarter pel pel yScale
        fBuffer[6]  = 0.0;
        fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;
        fBuffer[9]  = 0.0;
        fBuffer[10] = 1.0;
        fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;
        fBuffer[13] = 0.0;
        fBuffer[14] = 0.0;
        fBuffer[15] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[4]);
        vpp.pPusher->push(3, ftol[8]);
        vpp.pPusher->push(4, ftol[12]);
        vpp.pPusher->push(5, ftol[1]);
        vpp.pPusher->push(6, ftol[5]);
        vpp.pPusher->push(7, ftol[9]);
        vpp.pPusher->push(8, ftol[13]);
        vpp.pPusher->push(9, ftol[2]);
        vpp.pPusher->push(10, ftol[6]);
        vpp.pPusher->push(11, ftol[10]);
        vpp.pPusher->push(12, ftol[14]);
        vpp.pPusher->push(13, ftol[3]);
        vpp.pPusher->push(14, ftol[7]);
        vpp.pPusher->push(15, ftol[11]);
        vpp.pPusher->push(16, ftol[15]);

        vpp.pPusher->adjust(17);

        // Set viewport offset separately
        fBuffer[0] = xTrans;
        fBuffer[1] = yTrans;
        fBuffer[2] = zTrans;
        fBuffer[3] = 0.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_VIEWPORT_OFFSET(0) | 0x100000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[1]);
        vpp.pPusher->push(3, ftol[2]);
        vpp.pPusher->push(4, ftol[3]);

        vpp.pPusher->adjust(5);

        // Set front and back clipping
        fBuffer[0] = 0.0;
        fBuffer[1] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_CLIP_MIN | 0x80000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[1]);

        vpp.pPusher->adjust(3);

        // Disable almost everything

        // Disable alpha test
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_ALPHA_TEST_ENABLE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_ALPHA_TEST_ENABLE_V_FALSE);

        // Disable blending
        vpp.pPusher->push(2, subchannel +
                      NV056_SET_BLEND_ENABLE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_BLEND_ENABLE_V_FALSE);

        // Disable culling
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_CULL_FACE_ENABLE | 0x40000);
        vpp.pPusher->push(5, NV056_SET_CULL_FACE_ENABLE_V_FALSE);

        // Disable depth test
        vpp.pPusher->push(6, subchannel +
                      NV056_SET_DEPTH_TEST_ENABLE | 0x40000);
        vpp.pPusher->push(7, NV056_SET_DEPTH_TEST_ENABLE_V_FALSE);

        // Disable dither
        vpp.pPusher->push(8, subchannel +
                      NV056_SET_DITHER_ENABLE | 0x40000);
        vpp.pPusher->push(9, NV056_SET_DITHER_ENABLE_V_FALSE);

        // Disable lighting
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_LIGHTING_ENABLE | 0x40000);
        vpp.pPusher->push(11, NV056_SET_LIGHTING_ENABLE_V_FALSE);

        // Disable point parameters computation
        vpp.pPusher->push(12, subchannel +
                       NV056_SET_POINT_PARAMS_ENABLE | 0x40000);
        vpp.pPusher->push(13, NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);

        // Disable point smoothing
        vpp.pPusher->push(14, subchannel +
                       NV056_SET_POINT_SMOOTH_ENABLE | 0x40000);
        vpp.pPusher->push(15, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

        // Disable line smoothing
        vpp.pPusher->push(16, subchannel +
                       NV056_SET_LINE_SMOOTH_ENABLE | 0x40000);
        vpp.pPusher->push(17, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

        // Disable polygon smoothing
        vpp.pPusher->push(18, subchannel +
                       NV056_SET_POLY_SMOOTH_ENABLE | 0x40000);
        vpp.pPusher->push(19, NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE);

        // Disable skinning
        vpp.pPusher->push(20, subchannel +
                       NV056_SET_SKIN_ENABLE | 0x40000);
        vpp.pPusher->push(21, NV056_SET_SKIN_ENABLE_V_FALSE);

        // Disable stencil test
        vpp.pPusher->push(22, subchannel +
                       NV056_SET_STENCIL_TEST_ENABLE | 0x40000);
        vpp.pPusher->push(23, NV056_SET_STENCIL_TEST_ENABLE_V_FALSE);

        // Disable polygon offset point
        vpp.pPusher->push(24, subchannel +
                       NV056_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
        vpp.pPusher->push(25, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

        // Disable polygon offset line
        vpp.pPusher->push(26, subchannel +
                       NV056_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
        vpp.pPusher->push(27, NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

        // Disable polygon offset fill
        vpp.pPusher->push(28, subchannel +
                       NV056_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
        vpp.pPusher->push(29, NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);

        vpp.pPusher->adjust(30);

        // Set light control
        tmpVal = (NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE << 1) |
                  NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_LIGHT_CONTROL | 0x40000);
        vpp.pPusher->push(1, tmpVal);

        // Disable color material
        vpp.pPusher->push(2, subchannel +
                      NV056_SET_COLOR_MATERIAL | 0x40000);
        vpp.pPusher->push(3, NV056_SET_COLOR_MATERIAL_V_DISABLED);

        // Set material emission
        fBuffer[0] = 0.0;

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_MATERIAL_EMISSION(0) | 0xC0000);
        vpp.pPusher->push(5, ftol[0]);
        vpp.pPusher->push(6, ftol[0]);
        vpp.pPusher->push(7, ftol[0]);

        // Disable specular
        vpp.pPusher->push(8, subchannel +
                      NV056_SET_SPECULAR_ENABLE | 0x40000);
        vpp.pPusher->push(9, NV056_SET_SPECULAR_ENABLE_V_FALSE);

        // Disable all lights
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_LIGHT_ENABLE_MASK | 0x40000);
        vpp.pPusher->push(11, 0);

        vpp.pPusher->adjust(12);

        // Disable texgen modes for now (OpenGL default is EYE_LINEAR)

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXGEN_S(0) | 0x40000);
        vpp.pPusher->push(1, NV056_SET_TEXGEN_S_V_DISABLE);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_TEXGEN_T(0) | 0x40000);
        vpp.pPusher->push(3, NV056_SET_TEXGEN_T_V_DISABLE);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_TEXGEN_R(0) | 0x40000);
        vpp.pPusher->push(5, NV056_SET_TEXGEN_R_V_DISABLE);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_TEXGEN_Q(0) | 0x40000);
        vpp.pPusher->push(7, NV056_SET_TEXGEN_Q_V_DISABLE);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_TEXGEN_S(1) | 0x40000);
        vpp.pPusher->push(9, NV056_SET_TEXGEN_S_V_DISABLE);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_TEXGEN_T(1) | 0x40000);
        vpp.pPusher->push(11, NV056_SET_TEXGEN_T_V_DISABLE);

        vpp.pPusher->push(12, subchannel +
                       NV056_SET_TEXGEN_R(1) | 0x40000);
        vpp.pPusher->push(13, NV056_SET_TEXGEN_R_V_DISABLE);

        vpp.pPusher->push(14, subchannel +
                       NV056_SET_TEXGEN_Q(1) | 0x40000);
        vpp.pPusher->push(15, NV056_SET_TEXGEN_Q_V_DISABLE);

        vpp.pPusher->adjust(16);

        // Set default texgen planes
        fBuffer[0] = 0.0;
        fBuffer[1] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXGEN_SPLANE0(0) | 0x100000);
        vpp.pPusher->push(1, ftol[1]);
        vpp.pPusher->push(2, ftol[0]);
        vpp.pPusher->push(3, ftol[0]);
        vpp.pPusher->push(4, ftol[0]);

        vpp.pPusher->push(5, subchannel +
                      NV056_SET_TEXGEN_TPLANE0(0) | 0x100000);
        vpp.pPusher->push(6, ftol[0]);
        vpp.pPusher->push(7, ftol[1]);
        vpp.pPusher->push(8, ftol[0]);
        vpp.pPusher->push(9, ftol[0]);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_TEXGEN_RPLANE0(0) | 0x100000);
        vpp.pPusher->push(11, ftol[0]);
        vpp.pPusher->push(12, ftol[0]);
        vpp.pPusher->push(13, ftol[0]);
        vpp.pPusher->push(14, ftol[0]);

        vpp.pPusher->push(15, subchannel +
                       NV056_SET_TEXGEN_QPLANE0(0) | 0x100000);
        vpp.pPusher->push(16, ftol[0]);
        vpp.pPusher->push(17, ftol[0]);
        vpp.pPusher->push(18, ftol[0]);
        vpp.pPusher->push(19, ftol[0]);

        vpp.pPusher->push(20, subchannel +
                       NV056_SET_TEXGEN_SPLANE1(0) | 0x100000);
        vpp.pPusher->push(21, ftol[1]);
        vpp.pPusher->push(22, ftol[0]);
        vpp.pPusher->push(23, ftol[0]);
        vpp.pPusher->push(24, ftol[0]);

        vpp.pPusher->push(25, subchannel +
                       NV056_SET_TEXGEN_TPLANE1(0) | 0x100000);
        vpp.pPusher->push(26, ftol[0]);
        vpp.pPusher->push(27, ftol[1]);
        vpp.pPusher->push(28, ftol[0]);
        vpp.pPusher->push(29, ftol[0]);

        vpp.pPusher->push(30, subchannel +
                       NV056_SET_TEXGEN_RPLANE1(0) | 0x100000);
        vpp.pPusher->push(31, ftol[0]);
        vpp.pPusher->push(32, ftol[0]);
        vpp.pPusher->push(33, ftol[0]);
        vpp.pPusher->push(34, ftol[0]);

        vpp.pPusher->push(35, subchannel +
                       NV056_SET_TEXGEN_QPLANE1(0) | 0x100000);
        vpp.pPusher->push(36, ftol[0]);
        vpp.pPusher->push(37, ftol[0]);
        vpp.pPusher->push(38, ftol[0]);
        vpp.pPusher->push(39, ftol[0]);

        vpp.pPusher->adjust(40);

        // Set default fog mode
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FOG_MODE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_FOG_GEN_MODE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);

        // Disable fog
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_FOG_ENABLE | 0x40000);
        vpp.pPusher->push(5, NV056_SET_FOG_ENABLE_V_FALSE);

        // Set default fog parameters
        fBuffer[0] = 1.0;                           // K0
        fBuffer[1] = 1.0;                           // K1
        fBuffer[2] = 0.0;                           // K2

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_FOG_PARAMS(0) | 0xC0000);
        vpp.pPusher->push(7, ftol[0]);
        vpp.pPusher->push(8, ftol[1]);
        vpp.pPusher->push(9, ftol[2]);

        // Set default fog color
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_FOG_COLOR | 0x40000);
        vpp.pPusher->push(11, 0xFFFFFFFF);

        vpp.pPusher->adjust(12);

        // Set default alpha function
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_ALPHA_FUNC | 0x40000);
        vpp.pPusher->push(1, NV056_SET_ALPHA_FUNC_V_ALWAYS);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_ALPHA_REF | 0x40000);
        vpp.pPusher->push(3, 0);

        // Set default blend equation
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_BLEND_EQUATION | 0x40000);
        vpp.pPusher->push(5, NV056_SET_BLEND_EQUATION_V_FUNC_ADD);

        // Set default blend color
        vpp.pPusher->push(6, subchannel +
                      NV056_SET_BLEND_COLOR | 0x40000);
        vpp.pPusher->push(7, 0);

        // Set default blend func source factor
        vpp.pPusher->push(8, subchannel +
                      NV056_SET_BLEND_FUNC_SFACTOR | 0x40000);
        vpp.pPusher->push(9, NV056_SET_BLEND_FUNC_SFACTOR_V_ONE);

        // Set default blend func destination factor
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_BLEND_FUNC_DFACTOR | 0x40000);
        vpp.pPusher->push(11, NV056_SET_BLEND_FUNC_DFACTOR_V_ZERO);

        vpp.pPusher->adjust(12);

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FRONT_FACE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FRONT_FACE_V_CCW);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_CULL_FACE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_CULL_FACE_V_BACK);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_SHADE_MODE | 0x40000);
        vpp.pPusher->push(5, NV056_SET_SHADE_MODE_V_SMOOTH);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_FRONT_POLYGON_MODE | 0x40000);
        vpp.pPusher->push(7, NV056_SET_FRONT_POLYGON_MODE_V_FILL);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_BACK_POLYGON_MODE | 0x40000);
        vpp.pPusher->push(9, NV056_SET_BACK_POLYGON_MODE_V_FILL);

        fBuffer[0] = 0.0;

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
        vpp.pPusher->push(11, ftol[0]);

        vpp.pPusher->push(12, subchannel +
                       NV056_SET_POLYGON_OFFSET_BIAS | 0x40000);
        vpp.pPusher->push(13, ftol[0]);

        vpp.pPusher->push(14, subchannel +
                       NV056_SET_EDGE_FLAG | 0x40000);
        vpp.pPusher->push(15, 1);

        vpp.pPusher->adjust(16);

        // Initialize some vertex attributes
        fBuffer[0] = 0.0;
        fBuffer[1] = 1.0;

        // Set color for MODULATE blend mode
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_DIFFUSE_COLOR4F(0) | 0x100000);
        vpp.pPusher->push(1, ftol[1]);
        vpp.pPusher->push(2, ftol[1]);
        vpp.pPusher->push(3, ftol[1]);
        vpp.pPusher->push(4, ftol[1]);

        vpp.pPusher->push(5, subchannel +
                      NV056_SET_SPECULAR_COLOR3F(0) | 0xC0000);
        vpp.pPusher->push(6, ftol[0]);
        vpp.pPusher->push(7, ftol[0]);
        vpp.pPusher->push(8, ftol[0]);

        vpp.pPusher->push(9, subchannel +
                      NV056_SET_TEXCOORD0_4F(0) | 0x100000);
        vpp.pPusher->push(10, ftol[0]);
        vpp.pPusher->push(11, ftol[0]);
        vpp.pPusher->push(12, ftol[0]);
        vpp.pPusher->push(13, ftol[1]);

        vpp.pPusher->push(14, subchannel +
                       NV056_SET_TEXCOORD1_4F(0) | 0x100000);
        vpp.pPusher->push(15, ftol[0]);
        vpp.pPusher->push(16, ftol[0]);
        vpp.pPusher->push(17, ftol[0]);
        vpp.pPusher->push(18, ftol[1]);

        vpp.pPusher->push(19, subchannel +
                       NV056_SET_NORMAL3F(0) | 0xC0000);
        vpp.pPusher->push(20, ftol[0]);
        vpp.pPusher->push(21, ftol[0]);
        vpp.pPusher->push(22, ftol[1]);

        vpp.pPusher->push(23, subchannel +
                       NV056_SET_FOG1F | 0x40000);
        vpp.pPusher->push(24, ftol[0]);

        vpp.pPusher->push(25, subchannel +
                       NV056_SET_WEIGHT1F | 0x40000);
        vpp.pPusher->push(26, ftol[1]);

        vpp.pPusher->adjust(27);

        // Set depth function
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_DEPTH_FUNC | 0x40000);
        vpp.pPusher->push(1, NV056_SET_DEPTH_FUNC_V_ALWAYS);

        // Set color mask
        tmpVal = (NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
                 (NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
                 (NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
                  NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_COLOR_MASK | 0x40000);
        vpp.pPusher->push(3, tmpVal);

        // Set depth mask
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_DEPTH_MASK | 0x40000);
        vpp.pPusher->push(5, NV056_SET_DEPTH_MASK_V_FALSE);

        vpp.pPusher->adjust(6);

        // Initialize stencil state (test already disabled above)
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_STENCIL_FUNC | 0x40000);
        vpp.pPusher->push(1, NV056_SET_STENCIL_FUNC_V_ALWAYS);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_STENCIL_FUNC_REF | 0x40000);
        vpp.pPusher->push(3, 0);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_STENCIL_FUNC_MASK | 0x40000);
        vpp.pPusher->push(5, 0x000000FF);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_STENCIL_OP_FAIL | 0x40000);
        vpp.pPusher->push(7, NV056_SET_STENCIL_OP_FAIL_V_KEEP);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_STENCIL_OP_ZFAIL | 0x40000);
        vpp.pPusher->push(9, NV056_SET_STENCIL_OP_ZFAIL_V_KEEP);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_STENCIL_OP_ZPASS | 0x40000);
        vpp.pPusher->push(11, NV056_SET_STENCIL_OP_ZPASS_V_KEEP);

        vpp.pPusher->push(12, subchannel +
                       NV056_SET_STENCIL_MASK | 0x40000);
        vpp.pPusher->push(13, 0x000000FF);

        vpp.pPusher->adjust(14);

        // This is set once and forgotten. It puts the class in OGL flat shade mode.
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FLAT_SHADE_OP | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FLAT_SHADE_OP_V_LAST_VTX);

        vpp.pPusher->adjust(2);

        // Load texture matrices assuming quarter pel scaling of texture coordinates
        fBuffer[0]  = 0.25; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[4]);
        vpp.pPusher->push(3, ftol[8]);
        vpp.pPusher->push(4, ftol[12]);
        vpp.pPusher->push(5, ftol[1]);
        vpp.pPusher->push(6, ftol[5]);
        vpp.pPusher->push(7, ftol[9]);
        vpp.pPusher->push(8, ftol[13]);
        vpp.pPusher->push(9, ftol[2]);
        vpp.pPusher->push(10, ftol[6]);
        vpp.pPusher->push(11, ftol[10]);
        vpp.pPusher->push(12, ftol[14]);
        vpp.pPusher->push(13, ftol[3]);
        vpp.pPusher->push(14, ftol[7]);
        vpp.pPusher->push(15, ftol[11]);
        vpp.pPusher->push(16, ftol[15]);

        vpp.pPusher->push(17, subchannel +
            NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
        vpp.pPusher->push(18, ftol[0]);
        vpp.pPusher->push(19, ftol[4]);
        vpp.pPusher->push(20, ftol[8]);
        vpp.pPusher->push(21, ftol[12]);
        vpp.pPusher->push(22, ftol[1]);
        vpp.pPusher->push(23, ftol[5]);
        vpp.pPusher->push(24, ftol[9]);
        vpp.pPusher->push(25, ftol[13]);
        vpp.pPusher->push(26, ftol[2]);
        vpp.pPusher->push(27, ftol[6]);
        vpp.pPusher->push(28, ftol[10]);
        vpp.pPusher->push(29, ftol[14]);
        vpp.pPusher->push(30, ftol[3]);
        vpp.pPusher->push(31, ftol[7]);
        vpp.pPusher->push(32, ftol[11]);
        vpp.pPusher->push(33, ftol[15]);

        vpp.pPusher->adjust(34);

        vpp.pPusher->start(TRUE);

        // Enable both texture matrices since these texture coordinates are in quarter pel
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);
        vpp.pPusher->push(2, subchannel +
                      NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);
        vpp.pPusher->adjust(4);

        tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
                 (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                 (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
                 (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                 (1 << 12) | // 1 MIPMAP level
                 (NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
                 (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
                 (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
                 (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                  NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
        vpp.pPusher->push(1, tmpVal);
        vpp.pPusher->push(2, tmpVal);
        vpp.pPusher->push(3, subchannel +
                      NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
        vpp.pPusher->push(4, (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                      (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                      (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1 << 4) |
                      (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                      (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                       NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE);
        vpp.pPusher->push(5, (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                      (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                      (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                      (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                      (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                       NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE);
        vpp.pPusher->push(6, subchannel +
                      NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
        vpp.pPusher->push(7, 0);
        vpp.pPusher->push(8, 0);

        tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                 (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

        vpp.pPusher->push(9, subchannel +
                       NV056_SET_TEXTURE_FILTER(0) | 0x80000);
        vpp.pPusher->push(10, tmpVal);
        vpp.pPusher->push(11, tmpVal);

        vpp.pPusher->adjust(12);

        // Disable fog
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FOG_ENABLE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FOG_ENABLE_V_FALSE);

        vpp.pPusher->adjust(2);

        // Now setup combiners
        // Default register combiner settings are:
        // A = primary color
        // B = one
        // C = zero
        // D = zero

        // Our temporal filter moComp values
        // combiner0, RGB portion:   A = constantColor0
        // combiner0, RGB portion:   B = texture0
        // combiner0, RGB portion:   C = constantColor1
        // combiner0, RGB portion:   D = texture1

        // Initialize combiner ICW methods
        vpp.pPusher->push(0, subchannel | NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
        vpp.pPusher->push(1, (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                      (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                      (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1 << 8) |

                      (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                       NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9);

        vpp.pPusher->push(2, (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0 << 24) |

                      (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT << 21) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0 << 16) |

                      (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0 << 8) |

                      (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                       NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0);

        vpp.pPusher->push(3, subchannel | NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
        vpp.pPusher->push(4, (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9);

        vpp.pPusher->push(5, (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT << 21) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |

                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0);

        // Load combination factors
        vpp.pPusher->push(6, subchannel | NV056_SET_COMBINE_FACTOR(0) | 0x80000);
        vpp.pPusher->push(7, 0x80808080); // % of top field
        vpp.pPusher->push(8, 0x80808080); // % of bottom field

        vpp.pPusher->adjust(9);

        // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
        // Initialize combiner OCW methods
        vpp.pPusher->push(0, subchannel | NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
        vpp.pPusher->push(1, (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                      (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                      (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                      (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                       NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0);

        vpp.pPusher->push(2, (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                      (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                      (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                      (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                       NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0);

        vpp.pPusher->push(3, subchannel | NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
        vpp.pPusher->push(4, (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                      (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                      (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                      (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                      (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                      (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                       NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0);

        vpp.pPusher->push(5, subchannel | NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
        vpp.pPusher->push(6, (NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE << 28) |    \
                      (NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB << 27) |         \
                      (NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT << 15) |      \
                      (NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE << 14) |       \
                      (NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |    \
                      (NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |    \
                      (NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C << 8) |           \
                      (NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0 << 4) |            \
                       NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0);

        vpp.pPusher->adjust(7);

        // Load final stages with default values
        // Initialize combiner final CW methods
        vpp.pPusher->push(0, subchannel | NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
        vpp.pPusher->push(1, DEFAULT_FINAL_CW0);
        vpp.pPusher->push(2, subchannel | NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
        vpp.pPusher->push(3, DEFAULT_FINAL_CW1);
        vpp.pPusher->adjust(4);

        vpp.pPusher->start(TRUE);
    }
    return TRUE;
}
#endif // #if (NVARCH >= 0x10)


//---------------------------------------------------------------------------
// vppInitKelvin
//      Inits Kelvin object for temporal filter usage.  Kelvin is a shared,
//      cached object, so these methods only get set when we are a new consumer
LOCAL BOOL vppInitKelvin(Vpp_t *pVpp)
{
    DWORD tmpVal;
    float fBuffer[16];
    unsigned long *ftol = (unsigned long *)&fBuffer[0];
    float xTrans, yTrans, zTrans;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert(vpp.dwFlags & VPP_FLAG_KELVIN_3D);

    nvAssert(vpp.pThreeDClassLastUser);
    *vpp.pThreeDClassLastUser = MODULE_ID_DDRAW_VPP;

    // Let D3D code know that we have touched NV
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // Reset the celsius context Dmas to use the default video context Dma
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    vpp.pPusher->push(1, vpp.hToVideoMemContextDma);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_CONTEXT_DMA_A | 0x40000);
    vpp.pPusher->push(3, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_CONTEXT_DMA_B | 0x40000);
    vpp.pPusher->push(5, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_CONTEXT_DMA_STATE | 0x40000);
    vpp.pPusher->push(7, vpp.hToVideoMemContextDma);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_CONTEXT_DMA_COLOR | 0x40000);
    vpp.pPusher->push(9, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_CONTEXT_DMA_ZETA | 0x40000);
    vpp.pPusher->push(11, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_CONTEXT_DMA_VERTEX_A | 0x40000);
    vpp.pPusher->push(13, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_CONTEXT_DMA_VERTEX_B | 0x40000);
    vpp.pPusher->push(15, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(16, subchannel +
                          NV097_SET_CONTEXT_DMA_SEMAPHORE | 0x40000);
    vpp.pPusher->push(17, NV01_NULL_OBJECT);

    vpp.pPusher->push(18, subchannel +
                          NV097_SET_CONTEXT_DMA_REPORT | 0x40000);
    vpp.pPusher->push(19, NV01_NULL_OBJECT);

    vpp.pPusher->adjust(20);

    // Set up one window clip rectangle to be the rendered area
    // All the other rectangles are deactivated
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
    vpp.pPusher->push(1, ((2047 << 16) | 0));  // PG: used to be (-2048 & 0xfff)
    vpp.pPusher->push(2, 0);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->push(4, 0);
    vpp.pPusher->push(5, 0);
    vpp.pPusher->push(6, 0);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->push(8, 0);

    vpp.pPusher->push(9, subchannel +
                         NV097_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
    vpp.pPusher->push(10, ((2047 << 16) | 0));  // PG: used to be (-2048 & 0xfff)
    vpp.pPusher->push(11, 0);
    vpp.pPusher->push(12, 0);
    vpp.pPusher->push(13, 0);
    vpp.pPusher->push(14, 0);
    vpp.pPusher->push(15, 0);
    vpp.pPusher->push(16, 0);
    vpp.pPusher->push(17, 0);

    vpp.pPusher->push(18, subchannel +
                          NV097_SET_WINDOW_CLIP_TYPE | 0x40000);
    vpp.pPusher->push(19, NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);
    vpp.pPusher->adjust(20);

    // Set Control0 defaults
    tmpVal = (NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_PASS << 28) |
             (NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
             (NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
             (NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
             (NV097_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
             (NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_CONTROL0 | 0x40000);
    vpp.pPusher->push(1, tmpVal);
    vpp.pPusher->adjust(2);

    // Make sure to disable any transform program which may be running in D3D
    vpp.pPusher->push(0, subchannel + NV097_SET_TRANSFORM_EXECUTION_MODE | 0x40000);
    vpp.pPusher->push(1, ((NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV << 2) |
                           NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED));
    vpp.pPusher->adjust(2);

    // Load ModelView matrix and inverse ModelView matrix with identity
    fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_PROJECTION_MATRIX(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);
    vpp.pPusher->adjust(17);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);
    vpp.pPusher->adjust(17);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);

    vpp.pPusher->adjust(17);

    vpp.pPusher->push(0, subchannel +
                           NV097_NO_OPERATION | 0x40000);
    vpp.pPusher->push(1, 0);

    // PG - Modified 10/31/2000
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_SURFACE_FORMAT | 0x40000);
    vpp.pPusher->push(3, ((NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
                          (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
                          (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
                           NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8));

    vpp.pPusher->adjust(4);

    // Set up viewport
    xTrans = (float)(1.0 / 32.0); // hardware epsilon
    yTrans = (float)(1.0 / 32.0);
    zTrans = 0.0;

    // Load composite matrix assuming full pel scaling of surface coordinates
    fBuffer[0]  = 0.25; // quarter pel xScale
    fBuffer[1]  = 0.0;
    fBuffer[2]  = 0.0;
    fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;
    fBuffer[5]  = 0.25; // quarter pel pel yScale
    fBuffer[6]  = 0.0;
    fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;
    fBuffer[9]  = 0.0;
    fBuffer[10] = 1.0;
    fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;
    fBuffer[13] = 0.0;
    fBuffer[14] = 0.0;
    fBuffer[15] = 1.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);

    vpp.pPusher->adjust(17);

    // Set viewport offset separately
    fBuffer[0] = xTrans;
    fBuffer[1] = yTrans;
    fBuffer[2] = zTrans;
    fBuffer[3] = 0.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_VIEWPORT_OFFSET(0) | 0x100000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[1]);
    vpp.pPusher->push(3, ftol[2]);
    vpp.pPusher->push(4, ftol[3]);
    vpp.pPusher->adjust(5);

    // PG - Modified 10/31/2000
    // Set front and back clipping
    fBuffer[0] = 0.0;
    fBuffer[1] = KELVIN_Z_SCALE24;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_CLIP_MIN | 0x80000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[1]);
    vpp.pPusher->adjust(3);

    // Set light control
    tmpVal = (NV097_SET_LIGHT_CONTROL_SOUT_ZERO_OUT << 17) |
             (NV097_SET_LIGHT_CONTROL_LOCALEYE_FALSE << 16) |
              NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_LIGHT_CONTROL | 0x40000);
    vpp.pPusher->push(1, tmpVal);

    // Disable color material
    tmpVal = (NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DISABLE << 14) |
             (NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DISABLE << 12) |
             (NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DISABLE << 10) |
             (NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DISABLE << 8) |
             (NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE << 6) |
             (NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE << 4) |
             (NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE << 2) |
              NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DISABLE;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_COLOR_MATERIAL | 0x40000);
    vpp.pPusher->push(3, tmpVal);
    vpp.pPusher->adjust(4);

    // Set default fog mode
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_FOG_MODE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_FOG_MODE_V_LINEAR);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_FOG_GEN_MODE | 0x40000);
    vpp.pPusher->push(3, NV097_SET_FOG_GEN_MODE_V_FOG_X);

    // Disable fog
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_FOG_ENABLE | 0x40000);
    vpp.pPusher->push(5, NV097_SET_FOG_ENABLE_V_FALSE);

    // Set default fog color
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_FOG_COLOR | 0x40000);
    vpp.pPusher->push(7, 0xFFFFFFFF);
    vpp.pPusher->adjust(8);

    // Disable almost everything

    // Disable alpha test
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_ALPHA_TEST_ENABLE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);

    // Disable blending
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_BLEND_ENABLE | 0x40000);
    vpp.pPusher->push(3, NV097_SET_BLEND_ENABLE_V_FALSE);

    // Disable culling
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_CULL_FACE_ENABLE | 0x40000);
    vpp.pPusher->push(5, NV097_SET_CULL_FACE_ENABLE_V_FALSE);

    // Disable depth test
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_DEPTH_TEST_ENABLE | 0x40000);
    vpp.pPusher->push(7, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);

    // Disable dither
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_DITHER_ENABLE | 0x40000);
    vpp.pPusher->push(9, NV097_SET_DITHER_ENABLE_V_FALSE);

    // Disable lighting
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_LIGHTING_ENABLE | 0x40000);
    vpp.pPusher->push(11, NV097_SET_LIGHTING_ENABLE_V_FALSE);

    // Disable point parameters computation
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_POINT_PARAMS_ENABLE | 0x40000);
    vpp.pPusher->push(13, NV097_SET_POINT_PARAMS_ENABLE_V_FALSE);

    // Disable point smoothing
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_POINT_SMOOTH_ENABLE | 0x40000);
    vpp.pPusher->push(15, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable line smoothing
    vpp.pPusher->push(16, subchannel +
                          NV097_SET_LINE_SMOOTH_ENABLE | 0x40000);
    vpp.pPusher->push(17, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable polygon smoothing
    vpp.pPusher->push(18, subchannel +
                          NV097_SET_POLY_SMOOTH_ENABLE | 0x40000);
    vpp.pPusher->push(19, NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // Disable stippling
    vpp.pPusher->push(20, subchannel +
                          NV097_SET_STIPPLE_CONTROL | 0x40000);
    vpp.pPusher->push(21, NV097_SET_STIPPLE_CONTROL_V_OFF);

    // Disable skinning
    vpp.pPusher->push(22, subchannel +
                          NV097_SET_SKIN_MODE | 0x40000);
    vpp.pPusher->push(23, NV097_SET_SKIN_MODE_V_OFF);

    // Disable stencil test
    vpp.pPusher->push(24, subchannel +
                          NV097_SET_STENCIL_TEST_ENABLE | 0x40000);
    vpp.pPusher->push(25, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);

    // Disable polygon offset point
    vpp.pPusher->push(26, subchannel +
                          NV097_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
    vpp.pPusher->push(27, NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

    // Disable polygon offset line
    vpp.pPusher->push(28, subchannel +
                          NV097_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
    vpp.pPusher->push(29, NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

    // Disable polygon offset fill
    vpp.pPusher->push(30, subchannel +
                          NV097_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
    vpp.pPusher->push(31, NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);
    vpp.pPusher->adjust(32);

    // PG: This part unitl the material emission comment is new
    // Set default alpha function
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_ALPHA_FUNC | 0x40000);
    vpp.pPusher->push(1, NV097_SET_ALPHA_FUNC_V_ALWAYS);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_ALPHA_REF | 0x40000);
    vpp.pPusher->push(3, 0);

    // Initialize blend factors
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_BLEND_FUNC_SFACTOR | 0x40000);
    vpp.pPusher->push(5, NV097_SET_BLEND_FUNC_SFACTOR_V_ONE);

    // PG - Changed 11/01/2000
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_BLEND_FUNC_DFACTOR | 0x40000);
    vpp.pPusher->push(7, NV097_SET_BLEND_FUNC_DFACTOR_V_ZERO);

    // Set default blend color
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_BLEND_COLOR | 0x40000);
    vpp.pPusher->push(9, 0);

    // PG - Modified 10/31/2000 - SIGNED
    // Set default blend equation
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_BLEND_EQUATION | 0x40000);
    vpp.pPusher->push(11, NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED);
    vpp.pPusher->adjust(12);

    // Set depth function
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_DEPTH_FUNC | 0x40000);
    vpp.pPusher->push(1, NV097_SET_DEPTH_FUNC_V_ALWAYS);

    // Set color mask
    tmpVal = (NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
             (NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
             (NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
              NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_COLOR_MASK | 0x40000);
    vpp.pPusher->push(3, tmpVal);

    // Set depth mask
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_DEPTH_MASK | 0x40000);
    vpp.pPusher->push(5, NV097_SET_DEPTH_MASK_V_FALSE);
    vpp.pPusher->adjust(6);

    // Initialize stencil state (test already disabled above)
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_STENCIL_MASK | 0x40000);
    vpp.pPusher->push(1, 0x000000FF);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_STENCIL_FUNC | 0x40000);
    vpp.pPusher->push(3, NV097_SET_STENCIL_FUNC_V_ALWAYS);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_STENCIL_FUNC_REF | 0x40000);
    vpp.pPusher->push(5, 0);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_STENCIL_FUNC_MASK | 0x40000);
    vpp.pPusher->push(7, 0x000000FF);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_STENCIL_OP_FAIL | 0x40000);
    vpp.pPusher->push(9, NV097_SET_STENCIL_OP_FAIL_V_KEEP);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_STENCIL_OP_ZFAIL | 0x40000);
    vpp.pPusher->push(11, NV097_SET_STENCIL_OP_ZFAIL_V_KEEP);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_STENCIL_OP_ZPASS | 0x40000);
    vpp.pPusher->push(13, NV097_SET_STENCIL_OP_ZPASS_V_KEEP);
    vpp.pPusher->adjust(14);

    // PG - Modified 10/31/2000 - V_SMOOTH
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_SHADE_MODE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_SHADE_MODE_V_FLAT);

    fBuffer[0] = 0.0;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
    vpp.pPusher->push(3, ftol[0]);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_POLYGON_OFFSET_BIAS | 0x40000);
    vpp.pPusher->push(5, ftol[0]);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_FRONT_POLYGON_MODE | 0x40000);
    vpp.pPusher->push(7, NV097_SET_FRONT_POLYGON_MODE_V_FILL);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_BACK_POLYGON_MODE | 0x40000);
    vpp.pPusher->push(9, NV097_SET_BACK_POLYGON_MODE_V_FILL);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_CULL_FACE | 0x40000);
    vpp.pPusher->push(11, NV097_SET_CULL_FACE_V_BACK);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_FRONT_FACE | 0x40000);
    vpp.pPusher->push(13, NV097_SET_FRONT_FACE_V_CCW);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_NORMALIZATION_ENABLE | 0x40000);
    vpp.pPusher->push(15, NV097_SET_NORMALIZATION_ENABLE_V_FALSE);

    vpp.pPusher->push(16, subchannel +
                          NV097_SET_EDGE_FLAG | 0x40000);
    vpp.pPusher->push(17, NV097_SET_EDGE_FLAG_V_TRUE);
    vpp.pPusher->adjust(18);

    // Set material emission
    fBuffer[0] = 0.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_MATERIAL_EMISSION(0) | 0xC0000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[0]);
    vpp.pPusher->push(3, ftol[0]);

    // Disable specular
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_SPECULAR_ENABLE | 0x40000);
    vpp.pPusher->push(5, NV097_SET_SPECULAR_ENABLE_V_FALSE);

    // Disable all lights
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_LIGHT_ENABLE_MASK | 0x40000);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->adjust(8);

    // Disable texgen modes for now (OpenGL default is EYE_LINEAR)
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXGEN_S(0) | 0x40000);
    vpp.pPusher->push(1, NV097_SET_TEXGEN_S_V_DISABLE);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_TEXGEN_T(0) | 0x40000);
    vpp.pPusher->push(3, NV097_SET_TEXGEN_T_V_DISABLE);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_TEXGEN_R(0) | 0x40000);
    vpp.pPusher->push(5, NV097_SET_TEXGEN_R_V_DISABLE);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_TEXGEN_Q(0) | 0x40000);
    vpp.pPusher->push(7, NV097_SET_TEXGEN_Q_V_DISABLE);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_TEXGEN_S(1) | 0x40000);
    vpp.pPusher->push(9, NV097_SET_TEXGEN_S_V_DISABLE);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TEXGEN_T(1) | 0x40000);
    vpp.pPusher->push(11, NV097_SET_TEXGEN_T_V_DISABLE);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_TEXGEN_R(1) | 0x40000);
    vpp.pPusher->push(13, NV097_SET_TEXGEN_R_V_DISABLE);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXGEN_Q(1) | 0x40000);
    vpp.pPusher->push(15, NV097_SET_TEXGEN_Q_V_DISABLE);
    vpp.pPusher->adjust(16);

    // PG: This part until the fog parameters is new
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_SWATH_WIDTH | 0x40000);
    vpp.pPusher->push(1, NV097_SET_SWATH_WIDTH_V_OFF);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_SHADER_STAGE_PROGRAM | 0x40000);
    vpp.pPusher->push(3, ((NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE << 15) |
                          (NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE << 10) |
                          (NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE << 5) |
                           NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE));

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_SHADER_CLIP_PLANE_MODE | 0x40000);
    vpp.pPusher->push(5, 0);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_SHADER_OTHER_STAGE_INPUT | 0x40000);
    vpp.pPusher->push(7, 0);

    // This is set once and forgotten. It puts the class in OGL flat shade mode.
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_FLAT_SHADE_OP | 0x40000);
    vpp.pPusher->push(9, NV097_SET_FLAT_SHADE_OP_V_LAST_VTX);
    vpp.pPusher->adjust(10);

    // Set default fog parameters
    // PG - Modified - 11/03/2000
    fBuffer[0] = 0.0;   // K0
    fBuffer[1] = 1.0;   // K1
    //fBuffer[2] = 0.0;   // K2

    // PG - Modified 10/31/2000 - [0][1][2]
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_FOG_PARAMS(0) | 0xC0000);
    vpp.pPusher->push(1, ftol[1]); // K0
    vpp.pPusher->push(2, ftol[1]); // K1
    vpp.pPusher->push(3, ftol[0]); // K2

    // Set fog plane
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_FOG_PLANE(0) | 0x100000);
    vpp.pPusher->push(5, ftol[0]);
    vpp.pPusher->push(6, ftol[0]);
    vpp.pPusher->push(7, ftol[1]);
    vpp.pPusher->push(8, ftol[0]);

    // Set default fog color
    vpp.pPusher->push(9, subchannel +
                         NV097_SET_FOG_COLOR | 0x40000);
    vpp.pPusher->push(10, 0xFFFFFFFF);
    vpp.pPusher->adjust(11);

    // Set color for MODULATE blend mode
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_DIFFUSE_COLOR4F(0) | 0x100000);
    vpp.pPusher->push(1, ftol[1]);
    vpp.pPusher->push(2, ftol[1]);
    vpp.pPusher->push(3, ftol[1]);
    vpp.pPusher->push(4, ftol[1]);

    vpp.pPusher->push(5, subchannel +
                         NV097_SET_SPECULAR_COLOR3F(0) | 0xC0000);
    vpp.pPusher->push(6, ftol[0]);
    vpp.pPusher->push(7, ftol[0]);
    vpp.pPusher->push(8, ftol[0]);

    vpp.pPusher->push(9, subchannel +
                         NV097_SET_TEXCOORD0_4F(0) | 0x100000);
    vpp.pPusher->push(10, ftol[0]);
    vpp.pPusher->push(11, ftol[0]);
    vpp.pPusher->push(12, ftol[0]);
    vpp.pPusher->push(13, ftol[1]);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXCOORD1_4F(0) | 0x100000);
    vpp.pPusher->push(15, ftol[0]);
    vpp.pPusher->push(16, ftol[0]);
    vpp.pPusher->push(17, ftol[0]);
    vpp.pPusher->push(18, ftol[1]);

    vpp.pPusher->push(19, subchannel +
                          NV097_SET_NORMAL3F(0) | 0xC0000);
    vpp.pPusher->push(20, ftol[0]);
    vpp.pPusher->push(21, ftol[0]);
    vpp.pPusher->push(22, ftol[1]);

    vpp.pPusher->push(23, subchannel +
                          NV097_SET_FOG1F | 0x40000);
    vpp.pPusher->push(24, ftol[0]);

    vpp.pPusher->push(25, subchannel +
                          NV097_SET_WEIGHT1F | 0x40000);
    vpp.pPusher->push(26, ftol[1]);
    vpp.pPusher->adjust(27);

    // Load texture matrices assuming quarter pel scaling of texture coordinates
    fBuffer[0]  = 0.25; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);

    vpp.pPusher->push(17, subchannel +
                          NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
    vpp.pPusher->push(18, ftol[0]);
    vpp.pPusher->push(19, ftol[4]);
    vpp.pPusher->push(20, ftol[8]);
    vpp.pPusher->push(21, ftol[12]);
    vpp.pPusher->push(22, ftol[1]);
    vpp.pPusher->push(23, ftol[5]);
    vpp.pPusher->push(24, ftol[9]);
    vpp.pPusher->push(25, ftol[13]);
    vpp.pPusher->push(26, ftol[2]);
    vpp.pPusher->push(27, ftol[6]);
    vpp.pPusher->push(28, ftol[10]);
    vpp.pPusher->push(29, ftol[14]);
    vpp.pPusher->push(30, ftol[3]);
    vpp.pPusher->push(31, ftol[7]);
    vpp.pPusher->push(32, ftol[11]);
    vpp.pPusher->push(33, ftol[15]);
    vpp.pPusher->adjust(34);

    vpp.pPusher->start(TRUE);

    // Disable logic ops
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_LOGIC_OP_ENABLE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_LOGIC_OP_ENABLE_V_FALSE);

    // Disable Z min/max culling
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_ZMIN_MAX_CONTROL | 0x40000);
    vpp.pPusher->push(3, ((NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE << 8) |
                          (NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP << 4) |
                           NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE));

    // PG - New 10/31/2000
    // MUST set antialiasing control sample mask even though antialiasing is disabled
    // Disable antialiasing
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_ANTI_ALIASING_CONTROL | 0x40000);
    vpp.pPusher->push(5, ((0xFFFF0000) |
                         NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE));

    // Disable z buffer compression
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_COMPRESS_ZBUFFER_EN | 0x40000);
    vpp.pPusher->push(7, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);

    // Disable z stencil occlusion
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_OCCLUDE_ZSTENCIL_EN | 0x40000);
    vpp.pPusher->push(9, NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE);

    // Disable two sided lighting
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TWO_SIDE_LIGHT_EN | 0x40000);
    vpp.pPusher->push(11, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);

    // Disable z pass pixel counting
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_ZPASS_PIXEL_COUNT_ENABLE | 0x40000);
    vpp.pPusher->push(13, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE);
    vpp.pPusher->adjust(14);

    vpp.pPusher->start(TRUE);

    // Initialize some vertex attributes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Enable both texture matrices since these texture coordinates are in quarter pel
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    vpp.pPusher->push(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    vpp.pPusher->push(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    vpp.pPusher->push(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    vpp.pPusher->push(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    vpp.pPusher->adjust(5);

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    vpp.pPusher->push(1, tmpVal);
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    vpp.pPusher->push(3, tmpVal);
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    vpp.pPusher->push(5, tmpVal);
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    vpp.pPusher->push(7, tmpVal);

    // PG - Added 10/31/2000
    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    vpp.pPusher->push(9, tmpVal);
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    vpp.pPusher->push(11, tmpVal);
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    vpp.pPusher->push(13, tmpVal);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    vpp.pPusher->push(15, tmpVal);
    vpp.pPusher->adjust(16);

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    vpp.pPusher->push(1, tmpVal);

    // PG - Modified 11/02/2000 - ANISO_1
    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
        (15 << 18) | // MIN_LOD_CLAMP == 0.9
        (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
        (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1 << 4) |
        (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
        (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
        NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    vpp.pPusher->push(3, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    vpp.pPusher->push(5, tmpVal);
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    vpp.pPusher->push(7, tmpVal);


    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    vpp.pPusher->push(9, tmpVal);
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    vpp.pPusher->push(11, tmpVal);
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    vpp.pPusher->push(13, tmpVal);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    vpp.pPusher->push(15, tmpVal);

    tmpVal = (2044 << 16) | 2046; // Must be even and <= 4094

    vpp.pPusher->push(16, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    vpp.pPusher->push(17, tmpVal);
    vpp.pPusher->push(18, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    vpp.pPusher->push(19, tmpVal);
    vpp.pPusher->push(20, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    vpp.pPusher->push(21, tmpVal);
    vpp.pPusher->push(22, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    vpp.pPusher->push(23, tmpVal);

    vpp.pPusher->adjust(24);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our temporal filter moComp values
    // combiner0, RGB portion:   A = constantColor0
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1
    // combiner0, RGB portion:   D = texture1

    // Initialize combiner ICW methods
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    vpp.pPusher->push(1, (NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                         (NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                         (NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                         (NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                         (NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                         (NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                         (NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                         (NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                         (NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1 << 8) |

                         (NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                         (NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                          NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9);
    vpp.pPusher->push(2, DEFAULT_KELVIN_ALPHA_ICW);
    vpp.pPusher->push(3, DEFAULT_KELVIN_ALPHA_ICW);
    vpp.pPusher->push(4, DEFAULT_KELVIN_ALPHA_ICW);

    vpp.pPusher->push(5, subchannel | NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    vpp.pPusher->push(6, (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                         (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                         (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                         (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                         (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                         (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                         (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                         (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                         (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                         (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                         (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                          NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9);
    vpp.pPusher->push(7, DEFAULT_KELVIN_COLOR_ICW);
    vpp.pPusher->push(8, DEFAULT_KELVIN_COLOR_ICW);
    vpp.pPusher->push(9, DEFAULT_KELVIN_COLOR_ICW);
    vpp.pPusher->adjust(10);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    vpp.pPusher->push(1, 0x80808080); // % of top field

    vpp.pPusher->push(2, subchannel | NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    vpp.pPusher->push(3, 0x80808080); // % of bottom field
    vpp.pPusher->adjust(4);

    // combiner0, RGB portion:   texture0 + texture1
    // spare0 = A * B + C * D
    // Initialize combiner OCW methods
    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1

    // Initialize combiner OCW methods
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    vpp.pPusher->push(1, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->push(2, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->push(3, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->push(4, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->adjust(5);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    vpp.pPusher->push(1, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->push(2, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->push(3, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->push(4, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->adjust(5);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_CONTROL | 0x40000);
    vpp.pPusher->push(1, tmpVal);
    vpp.pPusher->adjust(2);

    // Load final stages with default values
    // Initialize combiner final CW methods
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    vpp.pPusher->push(1, DEFAULT_KELVIN_FINAL_CW0);
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    vpp.pPusher->push(3, DEFAULT_KELVIN_FINAL_CW1);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppValidateMode
//      Determine whether there is enough memory for this mode
LOCAL BOOL vppValidateMode(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel,
                            DWORD dwNumSurfaces, DWORD dwHead, DWORD dwRefreshRate, DWORD dwDCHead, DWORD dwDeviceType)
{
    NV_CFGEX_GET_SURFACE_PITCH_PARAMS params = {dwWidth, dwBytesPerPel * 8, 0};
    DWORD dwPitch, dwSize;
    Vpp_t &vpp = *pVpp;

    // get the pitch

    if (NvRmConfigGetEx(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                        NV_CFGEX_GET_SURFACE_PITCH,
                        &params, sizeof(params)) == NVOS_CGE_STATUS_SUCCESS) {
        dwPitch = params.Pitch;
    } else {
        // RM call failed, try to figure it out ourselves
        dwPitch  = ((dwWidth * dwBytesPerPel) + vpp.pDriverData->dwSurfaceAlignPad) & ~vpp.pDriverData->dwSurfaceAlignPad;
    }

    // calculate total size
    dwSize = dwPitch * dwHeight * dwNumSurfaces;

    // enough memory?
    if (dwSize > NV_GET_VIDEO_HEAP_FREE()) {
        return FALSE;
    }

#if (IS_WINNT4 || IS_WINNT5)
    MODE_ENTRY *lpMode = vpp.m_ppdev->PhysModeList[dwHead];
    DWORD dwNumModes = vpp.m_ppdev->ulNumPhysModes[dwHead];
    for (DWORD i = 0; i < dwNumModes; i++) {
        if (lpMode->ValidMode && lpMode->Width == dwWidth && lpMode->Height == dwHeight &&
            lpMode->Depth == (dwBytesPerPel * 8) && lpMode->RefreshRate == dwRefreshRate) {
            return TRUE;
        }
        lpMode++;
    }
    return FALSE;
#else
    // validate whether that display mode exists or not
    NVTWINVIEWDATA twinData;
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE;
    twinData.dwCrtc   = dwHead;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType = dwDeviceType;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes = dwWidth;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes = dwHeight;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp  = dwBytesPerPel * 8;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = dwRefreshRate;
    MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                 (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

    if (!twinData.dwSuccess) {
        return FALSE;
    }
#endif

    return TRUE;
}


//---------------------------------------------------------------------------
// vppCreateFSMirror
//      Initialize for fullscreen mirror mode
extern BOOL VppCreateFSMirror(Vpp_t *pVpp,  DWORD dwSrcWidth, DWORD dwSrcHeight)
{
    nvAssert(pVpp);
    nvAssert(dwSrcWidth>0);
    nvAssert(dwSrcHeight>0);

    // During modeset on win9x, this is called before enable (in nvEnable)
    //   Is that really necessary? @mjl@
    if (!(pVpp->dwFlags & VPP_FLAG_ENABLED))
    {
        return FALSE;
    }

    nvAssert(!(pVpp->dwFlags & VPP_FLAG_MIRROR_READY));

#ifdef IS_WINNT4    // No FullScreen mirror on NT4
    return FALSE;
#else
    DWORD i, dwStatus, dwBlockSize;
    NVTWINVIEWDATA twinData = {0};
    DWORD dwCrtcNumber = 0;
    DWORD dwDeviceType = 0;
    DWORD dwDCHead;
    DWORD dwPhysicalHead = 0;
    Vpp_t &vpp = *pVpp;
    LPPROCESSINFO lpProcInfo;

#if IS_WINNT5
    if (vpp.m_ppdev->TwinView_State != NVTWINVIEW_STATE_CLONE) {
        return FALSE;
    }
#elif IS_WIN9X
    if (vpp.pDriverData->dwDesktopState != NVTWINVIEW_STATE_DUALVIEW &&
        vpp.pDriverData->dwDesktopState != NVTWINVIEW_STATE_CLONE) {
        return FALSE;
    }
#endif

    // overlay creation has succeeded, now attempt to create fullscreen mirrors
    if ((vpp.pDriverData->dwHeads > 1) &&       
        (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) &&
        (vpp.dwOverlayFSNumSurfaces == 0)) {
        DWORD dwAdapterIndex = 0xFFFFFFFF;

        vpp.dwOverlayFSHead = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) - 1;

        if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) {
            vpp.dwOverlayFSHead = 14;
            vpp.regOverlayMode2 |= NV4_REG_OVL_MODE2_FSDEVICEMASK;  // set to autoselect
        }

        if (vpp.dwOverlayFSHead >= 14) {
            // auto head selection
            switch (vpp.pDriverData->dwDesktopState) {
            case NVTWINVIEW_STATE_DUALVIEW:
                // multimon mode uses the head which the overlay was not created on
                if (vpp.dwOverlayFSOvlHead == 0) {
                    vpp.dwOverlayFSHead = 1;
                } else if (vpp.dwOverlayFSOvlHead == 1) {
                    vpp.dwOverlayFSHead = 0;
                } else {
                    // no overlay, pick head 1
                    vpp.dwOverlayFSHead = 1;
                }
                break;
            case NVTWINVIEW_STATE_CLONE:
                // clone mode preferentially uses head 1
                vpp.dwOverlayFSHead = 1;
                break;
            default:
                // invalid condition, fail
                vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSMASK;
                return FALSE;
            }
        }

#if IS_WIN9X

        switch (vpp.pDriverData->dwDesktopState) {
        case NVTWINVIEW_STATE_DUALVIEW:
            dwCrtcNumber   = 0;       // need to use logical head numbers in multimon mode
            dwDCHead       = vpp.dwOverlayFSHead;
            dwPhysicalHead = vpp.dwOverlayFSHead;
            break;
        case NVTWINVIEW_STATE_CLONE:
            dwCrtcNumber = vpp.dwOverlayFSHead;
            dwDCHead     = pDXShare->dwHeadNumber;
            // get physical head number
            twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
            twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
            twinData.dwCrtc   = dwCrtcNumber;
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
            dwPhysicalHead = twinData.dwCrtc;
            break;
        default:
            // invalid condition, fail
            vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSMASK;
            return FALSE;
        }

        // get the current device type
        vpp.dwOverlayFSTwinData.dwFlag   = NVTWINVIEW_FLAG_GET;
        vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE;
        vpp.dwOverlayFSTwinData.dwCrtc   = dwCrtcNumber;
        MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &vpp.dwOverlayFSTwinData,
                     sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);
        twinData = vpp.dwOverlayFSTwinData;
        dwDeviceType = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType;

#elif IS_WINNT5
        vpp.dwOverlayFSHead = vpp.m_ppdev->ulDeviceDisplay[vpp.dwOverlayFSHead];
        dwDeviceType = vpp.m_ppdev->ulDeviceType[vpp.dwOverlayFSHead];
        dwDCHead = 0;
#endif

        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSSETMODE) {
            // driver will choose the display mode
            DWORD dwEncoderType;
            BOOL isDVDSized, isTV;
            NvRmConfigGet(
                vpp.pDriverData->dwRootHandle,
                vpp.pDriverData->dwDeviceHandle,
                     NV_CFG_VIDEO_ENCODER_TYPE, &dwEncoderType);

    // determine optimal mode
            // TODO: can do some interesting optimizations for anamorphic mode

            isTV = (dwDeviceType == MONITOR_TYPE_NTSC || dwDeviceType == MONITOR_TYPE_PAL);
            isDVDSized = (dwSrcWidth == 720 || dwSrcWidth == 704);

            if (isTV) {
                // if monitor is a TV, then attempt to set the native resolution
                if (dwEncoderType == NV_ENCODER_BROOKTREE_869 ||
                    dwEncoderType == NV_ENCODER_BROOKTREE_868) {
                    // Bt868/9 needs some weird modes because of locked and incorrect aspect ratios on those chips
                    if (dwDeviceType == MONITOR_TYPE_NTSC) {
                        vpp.dwOverlayFSWidth  = 720;
                        vpp.dwOverlayFSHeight = 512;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }

                        vpp.dwOverlayFSWidth  = 640;
                        vpp.dwOverlayFSHeight = 480;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }
                    }

                    if (dwDeviceType == MONITOR_TYPE_PAL) {
                        vpp.dwOverlayFSWidth  = 720;
                        vpp.dwOverlayFSHeight = 544;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }
                        vpp.dwOverlayFSWidth  = 800;
                        vpp.dwOverlayFSHeight = 600;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }
                    }
                } else if (dwEncoderType == NV_ENCODER_CHRONTEL_7007 ||
                           dwEncoderType == NV_ENCODER_CHRONTEL_7008) {
                    // optimal mode for Chrontel is 720x576
                    vpp.dwOverlayFSWidth  = 720;
                    vpp.dwOverlayFSHeight = 576;
                    vpp.dwOverlayFSFormat = 4;
                    if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                        goto vppFSMirrorModeFound;
                    }
                }
                // Note: if TV encoder is Brooktree/Conexant 871, we fall throught into the following
                // code, which handles more normal video mirror resolutions.
            }

            // Under some circumstances we use the source size, but not for TV.
            // Note 320x240 mode doesn't look right on TV.
            if (!isTV && !((dwDeviceType == MONITOR_TYPE_FLAT_PANEL) && isDVDSized)) {
                // first try a mode exactly equal to source size
                vpp.dwOverlayFSWidth  = dwSrcWidth;
                vpp.dwOverlayFSHeight = dwSrcHeight;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            }

            // select mode based on source size
            // Note 320x240 mode doesn't look right on TV.
            if (dwSrcWidth <= 320 && dwSrcHeight <= 240 && !isTV) {
                vpp.dwOverlayFSWidth  = 320;
                vpp.dwOverlayFSHeight = 240;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            // Note 512x384 mode doesn't look right on TV.
            } else if (dwSrcWidth <= 512 && dwSrcHeight <= 384 && !isTV) {
                vpp.dwOverlayFSWidth  = 512;
                vpp.dwOverlayFSHeight = 384;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 640 && dwSrcHeight <= 480) {
                vpp.dwOverlayFSWidth  = 640;
                vpp.dwOverlayFSHeight = 480;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 800 && dwSrcHeight <= 600) {
                vpp.dwOverlayFSWidth  = 800;
                vpp.dwOverlayFSHeight = 600;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 1024 && dwSrcHeight <= 768) {
                vpp.dwOverlayFSWidth  = 1024;
                vpp.dwOverlayFSHeight = 768;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 1280 && dwSrcHeight <= 960) {
                vpp.dwOverlayFSWidth  = 1280;
                vpp.dwOverlayFSHeight = 960;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 1600 && dwSrcHeight <= 1200) {
                vpp.dwOverlayFSWidth  = 1600;
                vpp.dwOverlayFSHeight = 1200;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            }
            // ok, we must be running into memory problems by now, try modes smaller that overlay source and downscale
            vpp.dwOverlayFSWidth  = 800;
            vpp.dwOverlayFSHeight = 600;
            vpp.dwOverlayFSFormat = 4;
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            // Try 8x6x32 with 2 buffers.
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 2, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            vpp.dwOverlayFSWidth  = 640;
            vpp.dwOverlayFSHeight = 480;
            vpp.dwOverlayFSFormat = 4;
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            // Try 6x4x32 with 2 buffers.
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 2, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            // last resort mode
            vpp.dwOverlayFSWidth  = 640;
            vpp.dwOverlayFSHeight = 480;
            vpp.dwOverlayFSFormat = 2;

            vppFSMirrorModeFound:
#if IS_WINNT5
            RESOLUTION_INFO res;
            BOOL success;

            // WIN2k works a little differently that win9x escape, it won't back down to a lower refresh
            // automatically so we have to do the explicit refresh rate validation
            if (dwDeviceType == MONITOR_TYPE_NTSC) {
                res.ulDisplayRefresh = 60;
            } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                res.ulDisplayRefresh = 50;
            } else {
                res.ulDisplayRefresh = 85;
                if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 85, dwDCHead, dwDeviceType)) {
                    res.ulDisplayRefresh = 75;
                    if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 75, dwDCHead, dwDeviceType)) {
                        res.ulDisplayRefresh = 60;
                    }
                }
            }

            res.ulDisplayWidth      = vpp.dwOverlayFSWidth;
            res.ulDisplayHeight     = vpp.dwOverlayFSHeight;
            switch (vpp.dwOverlayFSFormat) {
            case 1:  res.ulDisplayPixelDepth = BMF_8BPP;  break;
            case 4:  res.ulDisplayPixelDepth = BMF_32BPP; break;
            default: res.ulDisplayPixelDepth = BMF_16BPP; break;
            }
            success = NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);
#elif IS_WIN9X
            // lock the head CRTC
            // do not touch pDriverData->dwOverlayFSTwinData anymore until the CRTC unlock, display driver needs this context for unlocking
            vpp.dwOverlayFSTwinData.dwFlag   = NVTWINVIEW_FLAG_SET;
            vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_LOCK_HWCRTC;
            vpp.dwOverlayFSTwinData.dwCrtc   = dwPhysicalHead;   // leave this as the physical head number for lock
            MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);

            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            twinData = vpp.dwOverlayFSTwinData;

            if (!twinData.dwSuccess) {
                // lock failed, abort
                vpp.dwOverlayFSNumSurfaces = 0;
                return FALSE;
            }

            // set the mode
            twinData.dwFlag   = NVTWINVIEW_FLAG_SET;
            twinData.dwAction = NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE;
            if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
                twinData.dwCrtc   = dwPhysicalHead;
            } else {
                twinData.dwCrtc   = dwCrtcNumber;
            }
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes = vpp.dwOverlayFSWidth;
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes = vpp.dwOverlayFSHeight;
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp  = vpp.dwOverlayFSFormat * 8;
            if (dwDeviceType == MONITOR_TYPE_NTSC) {
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 60;
            } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 50;
            } else {
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 85;
            }
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

            vpp.dwOverlayFSWidth  = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes;
            vpp.dwOverlayFSHeight = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes;
            vpp.dwOverlayFSFormat = (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp + 1) / 8;
#endif
        } else {
            // use whatever mode is currently set

#if IS_WINNT5
            vpp.dwOverlayFSWidth  = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right -
                                             vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left;
            vpp.dwOverlayFSHeight = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom -
                                             vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top;
            vpp.dwOverlayFSFormat = vpp.m_ppdev->cjPelSize;
            vpp.dwOverlayFSPitch  = vpp.m_ppdev->lDelta;

            if (vpp.dwOverlayFSFormat == 1) {
                RESOLUTION_INFO res;
                BOOL success;

                // if other head was set to 8 bpp, then actually use a 16 bpp FS surface
                vpp.dwOverlayFSFormat = 2;
                // WIN2k works a little differently that win9x escape, it won't back down to a lower refresh
                // automatically so we have to do the explicite refresh rate validation
                if (dwDeviceType == MONITOR_TYPE_NTSC) {
                    res.ulDisplayRefresh = 60;
                } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                    res.ulDisplayRefresh = 50;
                } else {
                    res.ulDisplayRefresh = 85;
                    if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 85, dwDCHead, dwDeviceType)) {
                        res.ulDisplayRefresh = 75;
                        if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 75, dwDCHead, dwDeviceType)) {
                            res.ulDisplayRefresh = 60;
                        }
                    }
                }

                // promote the mode
                res.ulDisplayWidth      = vpp.dwOverlayFSWidth;
                res.ulDisplayHeight     = vpp.dwOverlayFSHeight;
                res.ulDisplayPixelDepth = BMF_16BPP;
                success = NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);
            }
#elif IS_WIN9X
            // get the physical mode
            twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
            twinData.dwAction = NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE;
            twinData.dwCrtc   = dwCrtcNumber;
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

            vpp.dwOverlayFSWidth  = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes;
            vpp.dwOverlayFSHeight = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes;
            vpp.dwOverlayFSFormat = (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp + 1) / 8;

            // lock the head CRTC
            // do not touch pDriverData->dwOverlayFSTwinData anymore until the CRTC unlock, display driver needs this context for unlocking
            vpp.dwOverlayFSTwinData.dwFlag   = NVTWINVIEW_FLAG_SET;
            vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_LOCK_HWCRTC;
            vpp.dwOverlayFSTwinData.dwCrtc   = dwPhysicalHead;   // leave this as the physical head number for lock
            MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);

            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            twinData = vpp.dwOverlayFSTwinData;

            if (!twinData.dwSuccess) {
                // lock failed, abort
                vpp.dwOverlayFSNumSurfaces = 0;
                return FALSE;
            }

            if (vpp.dwOverlayFSFormat == 1) {
                // if other head was set to 8 bpp, then actually use a 16 bpp FS surface
                vpp.dwOverlayFSFormat = 2;

                twinData.dwFlag   = NVTWINVIEW_FLAG_SET;
                twinData.dwAction = NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE;
                if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
                    twinData.dwCrtc   = dwPhysicalHead;
                } else {
                    twinData.dwCrtc   = dwCrtcNumber;
                }
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes = vpp.dwOverlayFSWidth;
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes = vpp.dwOverlayFSHeight;
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp  = 16;
                if (dwDeviceType == MONITOR_TYPE_NTSC) {
                    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 60;
                } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 50;
                } else {
                    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 85;
                }
                MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                             (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

                vpp.dwOverlayFSWidth  = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes;
                vpp.dwOverlayFSHeight = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes;
                vpp.dwOverlayFSFormat = (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp + 1) / 8;
            }
#endif
        }

        // Get the pitch from the RM for a given width/bpp
        NV_CFGEX_GET_SURFACE_PITCH_PARAMS params = {vpp.dwOverlayFSWidth, vpp.dwOverlayFSFormat * 8, 0};
        if (
            NvRmConfigGetEx(
                vpp.pDriverData->dwRootHandle,
                vpp.pDriverData->dwDeviceHandle,
                NV_CFGEX_GET_SURFACE_PITCH,
                &params, sizeof(params)) == NVOS_CGE_STATUS_SUCCESS) {
            vpp.dwOverlayFSPitch = params.Pitch;
        } else {
            // RM call failed, try to figure it out ourselves
            vpp.dwOverlayFSPitch  = ((vpp.dwOverlayFSWidth * vpp.dwOverlayFSFormat) + vpp.pDriverData->dwSurfaceAlignPad) & ~vpp.pDriverData->dwSurfaceAlignPad;
        }

        // create offscreen FS mirror surfaces
        dwBlockSize = vpp.dwOverlayFSPitch * vpp.dwOverlayFSHeight;
        for (i=0; i<NV_MAX_EXTRA_FS_SURFACES; i++) {
            NVHEAP_ALLOC (dwStatus, vpp.dwOverlayFSOffset[i], dwBlockSize, TYPE_IMAGE);
            if (dwStatus==0)
            {
                vpp.dwOverlayFSNumSurfaces++;
                vpp.dwOverlayFSOffset[i] = VIDMEM_OFFSET(vpp.dwOverlayFSOffset[i]);

                // strange bug: running vppBltFillBlock to zero out the FS mirror surfaces
                // makes the VPE overlay (in nvpecore.c) nonfunctional. Workaround:
                // don't do the blit if VPE is initialized. -FCF
                if (!vpp.pDriverData->nvpeState.bVPEInitialized) {
                if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSASPECT) {
                    // will be preserving aspect, need to zero these surfaces
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[i], vpp.dwOverlayFSPitch,
                        vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, max(vpp.dwOverlayFSFormat, 2));
                }
                }
            }
            else
            {
                dbgError("Failed to allocate offscreen FS-mirror surfaces");
            }
        }

        if (vpp.dwOverlayFSNumSurfaces == 0) {
#if IS_WINNT5
            // we failed restore the display mode
            RESOLUTION_INFO res;
            res.ulDisplayWidth      = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right -
                                      vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left;
            res.ulDisplayHeight     = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom -
                                      vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top;
            switch (vpp.m_ppdev->cjPelSize) {
            case 1:  res.ulDisplayPixelDepth = BMF_8BPP;  break;
            case 4:  res.ulDisplayPixelDepth = BMF_32BPP; break;
            default: res.ulDisplayPixelDepth = BMF_16BPP; break;
            }
            res.ulDisplayRefresh    = vpp.m_ppdev->ulRefreshRate[vpp.dwOverlayFSHead];
            NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);
#elif IS_WIN9X
            // we failed, unlock
            vpp.dwOverlayFSTwinData.dwFlag = NVTWINVIEW_FLAG_SET;
            vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_UNLOCK_HWCRTC;
            vpp.dwOverlayFSTwinData.dwCrtc = dwPhysicalHead;     // leave as physical head
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);
#endif
            return FALSE;
        } else {
/*
            if ((dwDeviceType == MONITOR_TYPE_NTSC || dwDeviceType == MONITOR_TYPE_PAL) ) {
                NV_CFGEX_SET_MACROVISION_MODE_PARAMS    mvParams;
                // To be safe, always turn on Macrovision even though we don't know that it's DVD playing.
                // Unfortunately, this is overkill but we have to be diligent legally. (Until we figure out
                // a better way to make our macrovision more secure.)
                mvParams.head = dwPhysicalHead;
                mvParams.resx = vpp.dwOverlayFSWidth;
                mvParams.resy = vpp.dwOverlayFSHeight;
                mvParams.mode = 3;  // modes are 1-3, arbitrarly use 3 (DVD players will reset it)
                // TODO:  We could define a macro (NvRmConfigSetEX) for this call in WinNT.  Every other RM config call has one.
#ifdef WINNT
                NvConfigSetEx(vpp.m_ppdev->hDriver, vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                                NV_CFGEX_SET_MACROVISION_MODE, &mvParams, sizeof(mvParams));
#else
                NvRmConfigSetEx(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                                NV_CFGEX_SET_MACROVISION_MODE, &mvParams, sizeof(mvParams));
#endif
            }
*/
            // fill in other info
            vpp.dwOverlayFSDeltaX = 0;
            vpp.dwOverlayFSDeltaY = 0;
            vpp.dwOverlayFSIndex = 0;
            switch (vpp.dwOverlayFSFormat) {
            case 1:  vpp.dwOverlayFSFormat = NV062_SET_COLOR_FORMAT_LE_Y8;                break;
            case 4:  vpp.dwOverlayFSFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8; break;
            default: vpp.dwOverlayFSFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;            break;
            }
        }
    } else {
        return FALSE;
    }

#if IS_WINNT5
   DisableHeadCursor(vpp.m_ppdev, vpp.dwOverlayFSHead, TRUE);
#endif

    // Perform a quick flip to clear out the full screen memory.
    lpProcInfo = pmGetProcess(vpp.pDriverData, nvGetCurrentProcessId());
    vppFSFlipSync(pVpp,lpProcInfo, 0, 0);
    vppFSFlip(pVpp,lpProcInfo, 0);

    vpp.dwFlags |= VPP_FLAG_MIRROR_READY;
    return TRUE;
#endif // End if IS_WINNT4
}


//---------------------------------------------------------------------------
// vppDestroyFSMirror
//      Frees all the objects created in vppCreateFSMirror
extern void VppDestroyFSMirror(Vpp_t *pVpp)
{
    nvAssert(pVpp);

    if (!(pVpp->dwFlags & VPP_FLAG_MIRROR_READY))   // It hasn't been created
    {
        return;
    }

#if (IS_WINNT5 || IS_WIN9X)
    DWORD i;
    Vpp_t &vpp = *pVpp;
    LPPROCESSINFO lpProcInfo = pmGetProcess(vpp.pDriverData, nvGetCurrentProcessId());

    // destroy FS mirror surfaces
    if (vpp.dwOverlayFSNumSurfaces > 0) {
#if IS_WINNT5
        RESOLUTION_INFO res;

        vppFSFlipSync(pVpp,lpProcInfo, 0, TRUE);
        vppFSFlipSync(pVpp,lpProcInfo, 1, TRUE);

        // restore the display mode
        res.ulDisplayWidth      = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right -
                                  vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left;
        res.ulDisplayHeight     = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom -
                                  vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top;

        switch (vpp.m_ppdev->cjPelSize) {
        case 1:  res.ulDisplayPixelDepth = BMF_8BPP;  break;
        case 4:  res.ulDisplayPixelDepth = BMF_32BPP; break;
        default: res.ulDisplayPixelDepth = BMF_16BPP; break;
        }
        res.ulDisplayRefresh    = vpp.m_ppdev->ulRefreshRate[vpp.dwOverlayFSHead];

        // Get DAC back into the correct resolution
        NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);

        // Re-enable the cursor
        DisableHeadCursor(vpp.m_ppdev, vpp.dwOverlayFSHead, FALSE);

        // Reset the current display rectangle to zero (resets panning values)
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right   = res.ulDisplayWidth;
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom  = res.ulDisplayHeight;
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left    = 0;
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top     = 0;

        // Get DAC pointing back to the proper memory area
        NvSetDacImageOffset(vpp.m_ppdev, vpp.dwOverlayFSHead, 0);

        // Reset panning
        NVMoveDisplayWindow(vpp.m_ppdev, vpp.dwOverlayFSHead,&vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead]);
#elif IS_WIN9X
        // get physical head number
        DWORD dwPhysicalHead;
        if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
            NVTWINVIEWDATA twinData;
            twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
            twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
            twinData.dwCrtc   = vpp.dwOverlayFSHead;
            MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
            dwPhysicalHead = twinData.dwCrtc;
        } else {
            dwPhysicalHead = vpp.dwOverlayFSHead;
        }

        // unlock the head CRTC
        vpp.dwOverlayFSTwinData.dwFlag = NVTWINVIEW_FLAG_SET;
        vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_UNLOCK_HWCRTC;
        vpp.dwOverlayFSTwinData.dwCrtc = dwPhysicalHead;
        MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);
#endif

        for (i=0; i<NV_MAX_EXTRA_FS_SURFACES; i++) {
            if (vpp.dwOverlayFSOffset[i]) {
                NVHEAP_FREE(vpp.dwOverlayFSOffset[i] + vpp.pDriverData->BaseAddress);
            }
            vpp.dwOverlayFSOffset[i] = 0;
        }
    }

    vpp.dwOverlayFSWidth = 0;
    vpp.dwOverlayFSHeight = 0;
    vpp.dwOverlayFSFormat = 0;
    vpp.dwOverlayFSPitch = 0;
    vpp.dwOverlayFSIndex = 0;
    vpp.dwOverlayFSNumSurfaces = 0;
    vpp.dwOverlayFSDeltaX = 0;
    vpp.dwOverlayFSDeltaY = 0;
    vpp.dwOverlayFSHead = 0xFFFFFFFF;

    vpp.dwFlags &= ~VPP_FLAG_MIRROR_READY;

#endif // End if (IS_WINNT5 || IS_WIN9X)
}



//---------------------------------------------------------------------------
// VppReadRegistry()
//
//---------------------------------------------------------------------------
extern NvU8 VppReadRegistry(Vpp_t *pVpp, HANDLE hDriver, NvU32 logicalHeadID)
{
    Vpp_t &vpp = *pVpp;

    nvAssert(pVpp);

    if (vpp.pDriverData==NULL || vpp.pSysInfo==NULL)
    {
        nvAssert(FALSE);  // On DBG builds, stop here... need to know if/when this occurs
        return TRUE;      // We were called before VppConstructor -- skip registry read benignly
    }

    if (vpp.regTool.Open(hDriver, logicalHeadID, NV4_REG_DIRECT_DRAW_SUBKEY))
    {
        vpp.regTool.Read(NV4_REG_OVL_MODE,  vpp.regOverlayMode);
        vpp.regTool.Read(NV4_REG_OVL_MODE2, vpp.regOverlayMode2);
        vpp.regTool.Read(NV4_REG_OVL_MODE3, vpp.regOverlayMode3);
        vpp.regTool.Read(NV4_REG_VPP_INV_MASK, vpp.regVPPInvMask);
        vpp.regTool.Read(NV4_REG_VPP_MAX_SURFACES, vpp.regVPPMaxSurfaces);
        vpp.regTool.Read(NV4_REG_OVLCC_ENABLE, vpp.regOverlayColourControlEnable);
#if IS_WIN9X
        vpp.regTool.Read(NV4_REG_VIDEO_BUS_MASTER_MODE, vpp.pDriverData->regTVTunerHack);
        vpp.regTool.Read(NV4_REG_ENUM_REFRESH, vpp.pDriverData->regEnumDDRefresh);
#endif

#if (IS_WIN9X || IS_WINNT5) && !defined(NVPE)
        vpp.regTool.Read(NV4_REG_VPE_ENABLE, vpp.pDriverData->bEnableVPE);  //check for VPE enable bit
#endif

        if (vpp.regTool.Read(NV4_REG_OVLCC_BRIGHTNESS, vpp.colorCtrl.lBrightness))
        {
            if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                // range should be from -10000 to +10000
                vpp.colorCtrl.lBrightness = min(max(vpp.colorCtrl.lBrightness * 10000 / 255, -10000), 10000);
            } else {
                // range should be from -100 to +100, but -256 to +255 is still legal
                vpp.colorCtrl.lBrightness = min(max(vpp.colorCtrl.lBrightness, -256), 255);
            }
        }

        if (vpp.regTool.Read(NV4_REG_OVLCC_CONTRAST, vpp.colorCtrl.lContrast))
        {
            if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                // convert range of 0 to 200% to 0 to 20000
                vpp.colorCtrl.lContrast = min(max(vpp.colorCtrl.lContrast * 20000 / 200, 0), 20000);
            } else {
                // convert range of 0 to 200% to 0 to 511
                vpp.colorCtrl.lContrast = min(max(vpp.colorCtrl.lContrast * 511 / 200, 0), 511);
            }
        }

        if (vpp.regTool.Read(NV4_REG_OVLCC_HUE, vpp.colorCtrl.lHue))
        {
            // range is 0 to 359 degrees
            while (vpp.colorCtrl.lHue < 0)    vpp.colorCtrl.lHue += 360;
            while (vpp.colorCtrl.lHue >= 360) vpp.colorCtrl.lHue -= 360;
        }

        if (vpp.regTool.Read(NV4_REG_OVLCC_SATURATION, vpp.colorCtrl.lSaturation))
        {
            if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                // convert range of 0 to 200% to 0 to 20000
                vpp.colorCtrl.lSaturation = min(max(vpp.colorCtrl.lSaturation * 20000 / 200, 0), 20000);
            } else {
                // convert range of 0 to 200% to 0 to 511
                vpp.colorCtrl.lSaturation = min(max(vpp.colorCtrl.lSaturation * 512 / 200, 0), 512);
            }
        }

        vpp.regTool.Close();
    }

    // can't do this unless more than 4M and MMX instructions available
    if (!(vpp.pSysInfo->dwCPUFeatureSet & CPU_FS_MMX) || (vpp.pDriverData->TotalVRAM <= 0x400000)) {
        vpp.regOverlayColourControlEnable = FALSE;
    }

    // Disable HQVUp on less than 16M
    if (vpp.pDriverData->TotalVRAM < 0x1000000) {
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
    }

    if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        // Disable HQVUp and sw colour controls on NV10/NV20
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
        vpp.regOverlayColourControlEnable = FALSE;
        if (vpp.pDriverData->TotalVRAM < 0x800000) {
            // Disable temporal and deinterlace filters on NV10/NV20 if less than 8M
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        }
    } else {
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        if (vpp.pDriverData->TotalVRAM < 0x1000000) {
            // Disable temporal filter on NV4/5 if less than 16M
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
        }
    }

    // Disable fullscreen mirror on non-dual head devices
    if (vpp.pDriverData->dwHeads < 2) {
        vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSDEVICEMASK;
    }

    return TRUE;
}

LOCAL BOOL vppAllocateObjects(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    int i;
    BOOL bSuccess = TRUE;

    nvAssert(vpp.hChannel != NULL);

    // Allocate each object in the array; skip OVERLAY (done @ vppEnable)
    //
    for(i=1; bSuccess && i<VPP_OBJECT_COUNT; i++)
    {
        if (vpp.m_obj_a[i].status == VPP_OBJ_FREED)
        {
            vpp.m_obj_a[i].status =
                NvRmAllocObject(vpp.pDriverData->dwRootHandle, vpp.hChannel,vpp.m_obj_a[i].classIID,vpp.m_obj_a[i].classNdx)
                ? VPP_OBJ_ERROR:VPP_OBJ_ALLOCATED;
            bSuccess = (vpp.m_obj_a[i].status == VPP_OBJ_ALLOCATED);
            if (!bSuccess)
            {
                dbgError("Failed object allocation in VPP.");
            }
        }
    }

    // Set the DMA context NOTIFIER on all objects (excluding overlay)
    //   Note: We use the NV07A_SET_CONTEXT_DMA_NOTIFIES member for ALL objects in our array.
    //         This loop assumes all objects have their notifier set method @ that offset (and they must!)
    //
    for(i=1; bSuccess && i<VPP_OBJECT_COUNT; i++)
    {
        if (vpp.m_obj_a[i].status == VPP_OBJ_ALLOCATED)
        {
            vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[i].classIID);
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
            vpp.pPusher->push(1, vpp.m_obj_a[i].contextIID);         // SetContextDmaNotifies
            vpp.pPusher->adjust(2);
        }
    }
    vpp.pPusher->start(TRUE);

    return bSuccess;
}

LOCAL void vppFreeObjects(Vpp_t *pVpp)
{
    int i;
    Vpp_t &vpp = *pVpp;

    nvAssert(vpp.hChannel != NULL);

    for(i=0; i<VPP_OBJECT_COUNT; i++)
    {
        if (vpp.m_obj_a[i].status == VPP_OBJ_ALLOCATED)
        {
            NvRmFree(vpp.pDriverData->dwRootHandle, vpp.hChannel,vpp.m_obj_a[i].classIID);
            vpp.m_obj_a[i].status = VPP_OBJ_FREED;
        }
    }
}

// Since different objects have different initialization requirements,
// this function is readily 'automated'.
LOCAL void vppInitObjects(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    int i;

    // Swizzle
    if (vpp.m_obj_a[SWIZZLE_NDX].status == VPP_OBJ_ALLOCATED)
    {
        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[SWIZZLE_NDX].classIID);
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV077_SET_CONTEXT_DMA_IMAGE | 0x40000);
        vpp.pPusher->push(1, vpp.hInVideoMemContextDma);       // SetContextDmaImage
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV077_SET_CONTEXT_SURFACE | 0x40000);
        vpp.pPusher->push(3, vpp.hContextSurfaceSwizzled);                // SetContextSurface
        vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | NV077_SET_COLOR_FORMAT | 0x80000);
        vpp.pPusher->push(5, NV077_SET_COLOR_FORMAT_LE_A8R8G8B8);          // SetColorFormat
        vpp.pPusher->push(6, NV077_SET_OPERATION_SRCCOPY);                 // SetOperation
        vpp.pPusher->adjust(7);
    }

    // Alpha Blt
    nvAssert(vpp.m_obj_a[ALPHA_BLT_NDX].status == VPP_OBJ_ALLOCATED);
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV05F_SET_CONTEXT_BETA4 | 0x40000);
    vpp.pPusher->push(1, vpp.hContextBeta4);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV05F_SET_OPERATION | 0x40000);
    vpp.pPusher->push(3, NV05F_SET_OPERATION_SRCCOPY_PREMULT);
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | NV05F_SET_CONTEXT_SURFACES | 0x40000);
    vpp.pPusher->push(5, vpp.hSurfaces2D);
    vpp.pPusher->adjust(6);

    // V2V Format
    nvAssert(vpp.m_obj_a[V2V_FORMAT_NDX].status == VPP_OBJ_ALLOCATED);
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[V2V_FORMAT_NDX].classIID);
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
    vpp.pPusher->push(1, vpp.hFromVideoMemContextDma);     // SetContextDmaBufferIn
    vpp.pPusher->push(2, vpp.hToVideoMemContextDma);       // SetContextDmaBufferOut
    vpp.pPusher->adjust(3);

    // Scaled Image (2 of them in sequence)
    nvAssert(SCALED_IMAGE2_NDX == SCALED_IMAGE1_NDX+1);
    for(i=0; i<2 ;i++)
    {
        int objNdx = SCALED_IMAGE1_NDX+i;
        if (vpp.m_obj_a[objNdx].status == VPP_OBJ_ALLOCATED)
        {
            vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[objNdx].classIID);

            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV063_SET_CONTEXT_PATTERN | 0x80000 );
            vpp.pPusher->push(1, vpp.hContextPattern);         // SetContextPattern
            vpp.pPusher->push(2, vpp.hContextRop);             // SetContextRop

            vpp.pPusher->push(3, SUB_CHANNEL(vpp.spareSubCh) | NV063_SET_OPERATION | 0x40000);
            vpp.pPusher->push(4, NV063_SET_OPERATION_ROP_AND);  // SetOperation

            vpp.pPusher->adjust(5);

            if (vpp.m_obj_a[objNdx].classNdx == NV05_SCALED_IMAGE_FROM_MEMORY)
            {
                vpp.pPusher->push(0,SUB_CHANNEL(vpp.spareSubCh) | NV063_SET_COLOR_CONVERSION | 0x40000);
                vpp.pPusher->push(1,NV063_SET_COLOR_CONVERSION_TRUNCATE);
                vpp.pPusher->adjust(2);
            }
        }
    }

    nvAssert(vpp.m_obj_a[DVDPICT_NDX].status == VPP_OBJ_ALLOCATED);
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[DVDPICT_NDX].classIID);
    vpp.pPusher->push(0,SUB_CHANNEL(vpp.spareSubCh) + NV038_SET_CONTEXT_DMA_OVERLAY | 0xC0000);
    vpp.pPusher->push(1,vpp.hFromVideoMemContextDma);
    vpp.pPusher->push(2,vpp.hFromVideoMemContextDma);
    vpp.pPusher->push(3,vpp.hToVideoMemContextDma);
    vpp.pPusher->adjust(4);

    vpp.pDriverData->dDrawSpareSubchannelObject = 0;
    vpp.pPusher->start(TRUE);
}


// NB: We don't yet know (since this is called at constructor time) whether or not
//     any given object is going to be valid.  Therefore we allocate a context DMA
//     for ALL of them.
LOCAL BOOL vppAllocateContextDMAs(Vpp_t *pVpp)
{
    NvU32 status;
    Vpp_t &vpp = *pVpp;
    int i;
    NvU32 contextSize;
    NvU8 *pContextBase;
    int notifierCount;
    NvU32 notifierMemSize;

// This is horrible!  This is so some of the code below which looks like function calls but
//  are actually macros, will get the right value! @mjl@ TBD
#ifdef WINNT
    PDEV *ppdev = pVpp->m_ppdev;
#endif
  
    // Determine how many notifiers total we have
    notifierCount = 0;
    for(i=0; i<VPP_OBJECT_COUNT; i++)
    {
        notifierCount += vpp.m_obj_a[i].notifierCount;
    }

    notifierMemSize = sizeof(NvNotification) * notifierCount;

    // Allocate memory for a bunch of notifiers and the scanline buffer.
    // We must allocate the memory for this structure out of SHARED or
    // SYSTEM space -- not out of App space so don't use GlobalAlloc.

    // TBD: Why doesn't this use AllocIPM? @mjl@
#if (IS_WINNT4 || IS_WINNT5)

    // Under Win2K and WinNT4 this routine is called once when the state is
    // created, and once again after every mode change. Only alloc
    // the notifier buffer and the notfier context DMAs once.
    if (!vpp.m_pContextDMABase)
    {
        vpp.m_pContextDMABase = (DWORD) EngAllocMem(FL_ZERO_MEMORY, (notifierMemSize), 'x_VN');
    }

#else // !WINNT
    {
        NvU32 dwMem[2];
        NvU32 notifierMemoryLimit;

        // Round up to nearest 4k or resman will fail the call
        //   The -1 changes this into a 'limit' which is what the call below requires
        //
        notifierMemoryLimit = ((notifierMemSize + 0xfff) & ~0xfff) - 1;

        if (NvRmAllocMemory (vpp.pDriverData->dwRootHandle,
                             vpp.pDriverData->dwDeviceHandle, NV_VPP_CONTEXT_DMA_MEMORY_IID,
                             NV01_MEMORY_SYSTEM,
                             (NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS << 4) |
                             (NVOS02_FLAGS_LOCATION_PCI << 8) |
                             (NVOS02_FLAGS_COHERENCY_CACHED << 12),
                             (PVOID *) dwMem, &notifierMemoryLimit))
        {
            vpp.m_pContextDMABase = NULL;
        }
        else
        {
            vpp.m_pContextDMABase = dwMem[0];
        }
    }

#endif // !WINNT

    if (vpp.m_pContextDMABase == NULL)
    {
        dbgError("Failed to allocate context DMA memory block");
        dbgTracePop();
        return(FALSE);
    }

    for(pContextBase=(NvU8 *)vpp.m_pContextDMABase,i=0; i<VPP_OBJECT_COUNT; i++)
    {
        contextSize = vpp.m_obj_a[i].notifierCount*sizeof(NvNotification);
        
        status = NvRmAllocContextDma(
            vpp.pDriverData->dwRootHandle,
            vpp.m_obj_a[i].contextIID,
            NV01_CONTEXT_DMA,
            DRF_DEF(OS03, _FLAGS, _ACCESS,    _READ_WRITE) |
            DRF_DEF(OS03, _FLAGS, _LOCKED,    _ALWAYS) |
            DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
            pContextBase,contextSize-1);
        
        vpp.m_obj_a[i].notifier_a = (volatile NvNotification *)pContextBase;   // Each of these context DMAs is used as a notifier
        
        pContextBase += contextSize;
        
        if (status!=0)
        {
            dbgError("VPP: Failed allocateContextDMAs()");
            return(FALSE);
        }
    }
    
    return (TRUE);
}

LOCAL void vppFreeContextDMAs(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    int i;
    
    nvAssert(pVpp != NULL);
    nvAssert(vpp.pDriverData != NULL);
    nvAssert(vpp.pDriverData->dwRootHandle != 0);
    nvAssert(vpp.pDriverData->dwDeviceHandle != 0);
    nvAssert(vpp.m_pContextDMABase != NULL);

// This is horrible!  This is so some of the code below which looks like function calls but
//  are actually macros, will get the right value! @mjl@ TBD
#ifdef WINNT
    PDEV *ppdev = pVpp->m_ppdev;
#endif

    for(i=0; i<VPP_OBJECT_COUNT; i++)
    {
        NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,vpp.m_obj_a[i].contextIID);
        vpp.m_obj_a[i].notifier_a = NULL;
    }
    
#if (IS_WINNT4 || IS_WINNT5)
    if (vpp.m_pContextDMABase)
    {
        EngFreeMem((PVOID) vpp.m_pContextDMABase);
        vpp.m_pContextDMABase = NULL;
    }
#else
    NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,NV_VPP_CONTEXT_DMA_MEMORY_IID);
#endif

}

//
// Determine which head the overlay will go on.  Result is stored
// in vpp.dwOverlayFSOvlHead.
//
LOCAL void vppChooseOverlayHead(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwOverlayDeviceType;
    NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS displayParams;

#if (!IS_WINNT4)
    ResetTwinViewState(vpp.pDriverData);
#endif

                                    // Logical index of the requested full screen device
    DWORD dwRequestedFSDevice = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) - 1;
    DWORD dwAssignedOvlDevice = 0;  // Logical index of the overlay device, default to first head

    if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&
        dwRequestedFSDevice != 0xFFFFFFFF)
    {
        // We are in clone mode AND Video Mirror is enabled
        if (dwRequestedFSDevice < 14) {
            // Not in Auto-Select mode, deduce overlay head from FS head
            dwAssignedOvlDevice = dwRequestedFSDevice ^ 1;
        }
#ifndef WINNT
    }
    else
    {
        // We are NOT in clone mode OR we are in clone mode with Video
        // Mirror disabled
        dwAssignedOvlDevice = pDXShare->dwHeadNumber;
#endif
    }
    
#if (IS_WIN9X)
    // RM needs physical head, map logical to physical
    NVTWINVIEWDATA twinData;
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
    twinData.dwCrtc   = dwAssignedOvlDevice;
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                 (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
    
    // Display device type retrieval will use the physical index of the overlay head
    displayParams.Head = twinData.dwCrtc;

    // Win9x will remember the overlay head with its -logical- index
    vpp.dwOverlayFSOvlHead = twinData.dwCrtc;
#else
    // Device type retrieval will use the physical index of the overlay head
    displayParams.Head = vpp.m_ppdev->ulDeviceDisplay[dwAssignedOvlDevice];
    
    // WinNT/2K/XP will remember the ovelay head with its -physical- index
    vpp.dwOverlayFSOvlHead = displayParams.Head;
#endif

    NvRmConfigGetEx(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                    NV_CFGEX_GET_DISPLAY_TYPE_MULTI,
                    &displayParams, sizeof(displayParams));
    dwOverlayDeviceType = displayParams.Type;

    // Set flag to say whether the overlay is on a flat panel.
    // This is used later by UpdateOverlay32.
    if (dwOverlayDeviceType == DISPLAY_TYPE_FLAT_PANEL)
    {
        vpp.dwNVOverlayFlags |= OVERLAY_FLAG_ON_PANEL;
    }
    else
    {
        vpp.dwNVOverlayFlags &= ~OVERLAY_FLAG_ON_PANEL;
    }
}

// The overlay object is SPECIAL since it requires a parameter to specify the
// head on which to create it.
LOCAL NvU8 vppAllocOverlay(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;
    nvAssert(vpp.m_obj_a[OVERLAY_NDX].status == VPP_OBJ_FREED);
    nvAssert(vpp.hChannel != NULL);

    nv07aAllocParms.logicalHeadId = vpp.dwOverlayFSOvlHead;
    vpp.m_obj_a[OVERLAY_NDX].status =
        NvRmAlloc(vpp.pDriverData->dwRootHandle,vpp.hChannel,
              vpp.m_obj_a[OVERLAY_NDX].classIID,
              vpp.m_obj_a[OVERLAY_NDX].classNdx,
              &nv07aAllocParms)
        ? VPP_OBJ_ERROR:VPP_OBJ_ALLOCATED;

    if (vpp.m_obj_a[OVERLAY_NDX].status == VPP_OBJ_ERROR)
    {
        dbgError("VPP overlay allocation failed!");
        return FALSE;
    }

    // Special Case -- we've created the overlay and it's notifiers as part of the VPP,
    // but much of the driver [currently] needs direct access to these notifiers.
    // For now, we re-initialize the driver value to the "correct one".  Eventually, all
    // driver components that need to wait for the overlay notifiers to clear should call
    // a vpp function to do it for them.

    // Tell the rest of the driver where the real overlay notifier is located
    vpp.pDriverData->pPioFlipOverlayNotifierFlat = vpp.m_obj_a[OVERLAY_NDX].notifier_a;

    // Don't know if this is necessary here... @mjl@
    // Deal with possible mode change during pending flip

//    if (vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status == NV_IN_PROGRESS) {
//        long countDown = 0x200000;
//        while ((vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status == NV_IN_PROGRESS) && (--countDown > 0));
//    }
//    if (vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status == NV_IN_PROGRESS) {
//        long countDown = 0x200000;
//        while ((vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status == NV_IN_PROGRESS) && (--countDown > 0));
//    }

    // clear all status flags before first use
    vpp.m_obj_a[OVERLAY_NDX].notifier_a[0].status = 0;
    vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status = 0;
    vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status = 0;

    // Initialize the overlay
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[OVERLAY_NDX].classIID);
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[OVERLAY_NDX].contextIID);         // SetContextDmaNotifies
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_CONTEXT_DMA_OVERLAY(0) | 0x80000);
    vpp.pPusher->push(3, vpp.hFromVideoMemContextDma);                 // SetContextDmaOverlay(0)
    vpp.pPusher->push(4, vpp.hFromVideoMemContextDma);                 // SetContextDmaOverlay(1)
    vpp.pPusher->adjust(5);
    return TRUE;
}

LOCAL void vppFreeOverlay(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    nvAssert(vpp.hChannel != NULL);

    NvRmFree(vpp.pDriverData->dwRootHandle, vpp.hChannel,vpp.m_obj_a[OVERLAY_NDX].classIID);
    vpp.m_obj_a[OVERLAY_NDX].status = VPP_OBJ_FREED;
}


//---------------------------------------------------------------------------
// VppCreateOverlay
//      Initializes some objects used by the VPP (TBD update this comment block @mjl@)
//
// Objects we don't need to create because they already exist:
//      D3D_CELSIUS_PRIMITIVE or D3D_KELVIN_PRIMITIVE (we initialize here)
//      NV_DD_CONTEXT_BETA4
//      NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT
//
// Events (created in nvProcMan):
//      NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC -> NV_VPP_V2OSH_FORMAT
//      NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC -> NV_VPP_OSH2V_FORMAT
//      NV_DD_EVENT_COMBINER_SYNC        -> vpp.hDX6MultiTextureTriangle
//
// Notifiers (created in ddDrv):
//      NV_DD_DMA_VPP_NOTIFIER

extern BOOL VppCreateOverlay(Vpp_t *pVpp)
{
    BOOL retCode = TRUE;
    Vpp_t &vpp = *pVpp;

    nvAssert(pVpp);

    // During modeset on win9x, this is called before enable (in nvEnable)
    //   Is that really necessary? @mjl@
    if (!(vpp.dwFlags & VPP_FLAG_ENABLED))
    {
        return FALSE;
    }

    nvAssert(!(vpp.dwFlags & VPP_FLAG_OVERLAY_READY));

    // This is only going to happen if one of the asserts fire... but this gives us
    // a chance to get further in the debug session...
#ifdef DEBUG
    if (vpp.pDriverData == NULL) return TRUE;
#endif

    vppChooseOverlayHead(pVpp);

    if (!vppAllocOverlay(pVpp)) 
    {
        return FALSE;
    }
    vpp.dwFlags |= VPP_FLAG_OVERLAY_READY;  // Set now so VppSetOverlayColourControl will know that overlay obj exists

    //
    // 3d object must already be created outside of the VPP, just fill in some default values
    //
    if (vpp.dwFlags & VPP_FLAG_CELSIUS_3D)
    {
        vppInitCelsius(pVpp);
    }
    else if (vpp.dwFlags & VPP_FLAG_KELVIN_3D)
    {
        vppInitKelvin(pVpp);
    }

    pmAddProcess(vpp.pDriverData, nvGetCurrentProcessId());

    VppSetOverlayColourControl(pVpp);

    vpp.dwOverlayFSOvlLost = FALSE;

    vpp.llDeliveryPeriod = 0;
    vpp.llDeliveryTime = 0;

    return retCode;
}

//---------------------------------------------------------------------------
// VppDestroyOverlay
//
extern void VppDestroyOverlay(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    if (!(pVpp->dwFlags & VPP_FLAG_OVERLAY_READY))   // It hasn't been created
    {
        return;
    }

#ifdef IKOS
    // To avoid a race (shows up in IKOS), make sure our push buffer is flushed before calling NvRmFree
    // NOTE:  enable this in non-IKOS builds once it's been tested more
    vpp.pPusher->flush(TRUE);
#endif

    // Delete events tied to objects before freeing the parent objects
    pmDeleteAllProcesses(vpp.pDriverData); // On NT4/2k this only removes all events

    vppFreeOverlay(pVpp);

    vpp.dwOverlayFSOvlHead = 0xFFFFFFFF;
    vpp.dwFlags &= ~VPP_FLAG_OVERLAY_READY;
}

//---------------------------------------------------------------------------
// VppDisable

extern void VppDisable(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    // In some shutdown scenarios, disable may be called regardless of current state
    if (!(vpp.dwFlags & VPP_FLAG_ENABLED)) return;

#ifdef IKOS
    // To avoid a race (shows up in IKOS), make sure our push buffer is flushed before calling NvRmFree
    // NOTE:  enable this in non-IKOS builds once it's been tested more
    vpp.pPusher->flush(TRUE);
#endif

    vppFreeObjects(pVpp);

    vpp.dwFlags &= ~VPP_FLAG_ENABLED;
}


//---------------------------------------------------------------------------
//  VppEnable
//
//    Defines and creates various resources needed to operate the VPP.
//
//---------------------------------------------------------------------------
extern NvU8 VppEnable(
    Vpp_t           *pVpp,
    PDEV            *ppdev,
    CPushBuffer     *pPusher,
    NvU32            hChannel,
    NvU32            hThreeDClass,
    NvU32            threeDClassSubCh,
    NvU32            *pThreeDClassLastUser,
    NvU32            hInVideoMemContextDma,
    NvU32            hFromVideoMemContextDma,
    NvU32            hToVideoMemContextDma,
    NvU32            hLutCursorDacBase,
    NvU32            hMiscEventNotifier,
    NvU32            hContextSurfaceSwizzled,
    NvU32            hContextBeta4,
    NvU32            hSurfaces2D,
    NvU32            surfaces2DSubCh,
    NvU32            hVideoMemUtoVideoMemFormat,     // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat,     // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat,    // V-conversion object

    NvU32            unused1,
    NvU32            hContextPattern,
    NvU32            hContextRop,
    NvU32            hContextColorKey,
    NvU32            hFloatingContextDmaInOverlayShadow,

    NvNotification  *pFlipPrimaryNotifier,
    NvNotification  *pPusherSyncNotifier,
    NvNotification  *pUnused,

    NvU32            hContextSurfacesARGB_ZS,
    NvU32            hDX6MultiTextureTriangle,
    NvU32            hImageBlackRect,

    NvU32            ropRectTextSubCh,
    NvU32            ropSubCh,
    NvU32            spareSubCh)
{
    Vpp_t &vpp = *pVpp;

    nvAssert(vpp.dwFlags & VPP_FLAG_CONSTRUCTED);
    nvAssert(!(vpp.dwFlags & VPP_FLAG_ENABLED));

    vpp.m_ppdev                            = ppdev;
    vpp.pPusher                            = pPusher;
    vpp.hThreeDClass                       = hThreeDClass;
    vpp.hChannel                           = hChannel;
    vpp.threeDClassSubCh                   = threeDClassSubCh;
    vpp.pThreeDClassLastUser               = pThreeDClassLastUser;
    vpp.hInVideoMemContextDma              = hInVideoMemContextDma;
    vpp.hFromVideoMemContextDma            = hFromVideoMemContextDma;
    vpp.hToVideoMemContextDma              = hToVideoMemContextDma;
    vpp.hLutCursorDacBase                  = hLutCursorDacBase;
    vpp.hMiscEventNotifier                 = hMiscEventNotifier;
    vpp.hContextSurfaceSwizzled            = hContextSurfaceSwizzled;
    vpp.hContextBeta4                      = hContextBeta4;
    vpp.hSurfaces2D                        = hSurfaces2D;
    vpp.surfaces2DSubCh                    = surfaces2DSubCh;
    vpp.hVideoMemUtoVideoMemFormat         = hVideoMemUtoVideoMemFormat;
    vpp.hVideoMemVtoVideoMemFormat         = hVideoMemVtoVideoMemFormat;
    vpp.hVideoMemUVtoVideoMemFormat        = hVideoMemUVtoVideoMemFormat;

    vpp.hContextPattern                    = hContextPattern;
    vpp.hContextRop                        = hContextRop;
    vpp.hContextColorKey                   = hContextColorKey;
    vpp.hFloatingContextDmaInOverlayShadow = hFloatingContextDmaInOverlayShadow;

    vpp.pFlipPrimaryNotifier               = pFlipPrimaryNotifier;
    vpp.pPusherSyncNotifier                = pPusherSyncNotifier;

    vpp.hContextSurfacesARGB_ZS            = hContextSurfacesARGB_ZS;
    vpp.hDX6MultiTextureTriangle           = hDX6MultiTextureTriangle;
    vpp.hImageBlackRect                    = hImageBlackRect;

    vpp.ropRectTextSubCh                   = ropRectTextSubCh;
    vpp.ropSubCh                           = ropSubCh;
    vpp.spareSubCh                         = spareSubCh;

    if (!vppAllocateObjects(pVpp))
    {
        dbgError("VPP object allocation failed!");
        VppDisable(pVpp);
        return FALSE;
    }

    vppInitObjects(pVpp);

    vpp.dwFlags |= VPP_FLAG_ENABLED;

    return TRUE;
}



//---------------------------------------------------------------------------
// vppPreCopy
//      Copies surface from source to destination.  Does not need to follow
//      the notifier protocol because it is not a stage by itself.
LOCAL BOOL vppPreCopy(Vpp_t *pVpp, DWORD dwSrcOffset, DWORD dwSrcPitch,
                DWORD dwDstOffset, DWORD dwDstPitch,
                DWORD dwWidth, DWORD dwHeight)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwMergeSize;

    dwMergeSize = (dwHeight << 16) | (dwWidth >> 1);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextBeta4);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
    vpp.pPusher->push(3, 0xFFFFFFFF);

    // This is sometimes used in it's own channel -- but here DD_SURFACES_2D is assigned to spare? -mjl
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(5, vpp.hSurfaces2D);
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_PITCH_OFFSET | 0xC0000);
    vpp.pPusher->push(7, (dwDstPitch << 16) | dwSrcPitch);     // SetPitch
    vpp.pPusher->push(8, dwSrcOffset);                         // SetOffsetSource
    vpp.pPusher->push(9, dwDstOffset);                         // SetOffsetDestin
    vpp.pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
    vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    vpp.pPusher->push(10, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
    vpp.pPusher->push(12, SUB_CHANNEL(vpp.spareSubCh) | BLIT_POINT_IN_OFFSET | 0xC0000);
    vpp.pPusher->push(13, 0);                                  // control point in
    vpp.pPusher->push(14, 0);                                  // control point out
    vpp.pPusher->push(15, dwMergeSize);                        // size

    vpp.pPusher->adjust(16);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[ALPHA_BLT_NDX].classIID;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppConvert
//      Converts YUV9 or YUV12 surface to YUV422.  Assume that we always
//      convert to YUY2 and not UYVY. Assume width, pitch, and height are
//      all divisible by the subsampling rate.
LOCAL BOOL vppConvert(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                DWORD dwSrcOffset, DWORD dwSrcPitch,
                DWORD dwDstOffset, DWORD dwDstPitch,
                DWORD dwWidth, DWORD dwHeight,
                DWORD dwFourCC)
{
    DWORD i;
    DWORD dwSrcUOffset, dwSrcVOffset, dwCOffset;
    Vpp_t &vpp = *pVpp;

    dwSrcVOffset = dwSrcOffset + dwSrcPitch * dwHeight;

    // move the chroma data
    switch (dwFourCC) {
    case FOURCC_IF09:
    case FOURCC_YVU9:
    case FOURCC_IV32:
    case FOURCC_IV31:
        dwSrcUOffset = dwSrcVOffset + (dwSrcPitch >> 2) * (dwHeight >> 2);
        dwCOffset    = dwSrcUOffset + (dwSrcPitch >> 2) * (dwHeight >> 2);

        // first weave U and V together in the horizontal direction and double up
        // move U even
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemUtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcUOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset);                       // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);

        // move V even
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemVtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcVOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset + 1);                   // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);
        vpp.pPusher->start(TRUE);

        // move U odd
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemUtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcUOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset + 2);                   // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);

        // move V odd
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemVtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcVOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset + 3);                   // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);
        vpp.pPusher->start(TRUE);

        // final move, 4x vertical resample
        for (i=0; i<4; i++) {
            DWORD dwDstAdd = i * dwDstPitch;

            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwCOffset);                       // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwDstAdd + 1);      // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch);                      // PitchIn
            vpp.pPusher->push(6, dwDstPitch << 2);                 // PitchOut
            vpp.pPusher->push(7, dwWidth);                         // LineLengthIn
            vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
            vpp.pPusher->push(9, 0x201);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
        }
        vpp.pPusher->start(TRUE);
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hVideoMemUVtoVideoMemFormat;
        break;

    case FOURCC_YV12:
    case FOURCC_420i:
        dwSrcUOffset = dwSrcVOffset + (dwSrcPitch >> 1) * (dwHeight >> 1);

        for (i=0; i<4; i++) {
            DWORD dwDstAdd = (i >> 1) * dwDstPitch + (i & 0x1) * 4;

            // move U
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcUOffset);                    // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwDstAdd + 1);      // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch >> 1);                 // PitchIn
            vpp.pPusher->push(6, dwDstPitch << 1);                 // PitchOut
            vpp.pPusher->push(7, dwWidth >> 1);                    // LineLengthIn
            vpp.pPusher->push(8, dwHeight >> 1);                   // LineCount
            vpp.pPusher->push(9, 0x401);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);

            // move V
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcVOffset);                    // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwDstAdd + 3);      // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch >> 1);                 // PitchIn
            vpp.pPusher->push(6, dwDstPitch << 1);                 // PitchOut
            vpp.pPusher->push(7, dwWidth >> 1);                    // LineLengthIn
            vpp.pPusher->push(8, dwHeight >> 1);                   // LineCount
            vpp.pPusher->push(9, 0x401);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
            vpp.pPusher->start(TRUE);
        }
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hVideoMemVtoVideoMemFormat;
        break;

    default:
        return FALSE;
        break;
    }

//    resetNotification(vpp.pPusherSyncNotifier, lpProcInfo->hConvert3);
    VppResetNotification(vpp.m_obj_a[V2V_FORMAT_NDX].notifier_a, lpProcInfo->hConvert3);

    // move the luma data
    vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push( 1, vpp.m_obj_a[V2V_FORMAT_NDX].classIID);
    vpp.pPusher->push( 2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    vpp.pPusher->push( 3, dwSrcOffset);                             // OffsetIn
    vpp.pPusher->push( 4, dwDstOffset);                             // OffsetOut
    vpp.pPusher->push( 5, dwSrcPitch);                              // PitchIn
    vpp.pPusher->push( 6, dwDstPitch);                              // PitchOut
    vpp.pPusher->push( 7, dwWidth);                                 // LineLengthIn
    vpp.pPusher->push( 8, dwHeight);                                // LineCount
    vpp.pPusher->push( 9, 0x201);                                   // Format
    vpp.pPusher->push(10, VPP_NOTIFY_TYPE);                         // BufferNotify
    vpp.pPusher->adjust(11);
    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppSubPicture
//      Composites DVD subpicture to YUV422 image
LOCAL BOOL vppSubPicture(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                   DWORD dwSrcOffset, DWORD dwSrcPitch,
                   DWORD dwDstOffset, DWORD dwDstPitch,
                   DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC)
{
    DWORD dwMergeSize, dwClipSize;
    DWORD dwOutFormat;
    DWORD dwInPoint, dwOutPoint;
    DWORD dwOverlayPoint;
    DWORD dwSubPictureOffset;
    Vpp_t &vpp = *pVpp;

    if (vpp.subPicture.pitch & NVS2VF_SP_SUBRECT) {
        DWORD dwBytesPerPixel = (vpp.subPicture.format == NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8 ||
                                 vpp.subPicture.format == NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8) ? 4:2;
        // codec requests in place subrectangle
        dwSubPictureOffset = vpp.subPicture.offset +
                             vpp.subPicture.originY * (vpp.subPicture.pitch & 0xFFFFFFF0) +
                             (vpp.subPicture.originX & ~0x1F) * dwBytesPerPixel;
        dwSrcOffset += vpp.subPicture.originY * dwSrcPitch + (vpp.subPicture.originX & ~0x1F) * 2;
        dwMergeSize = asmMergeCoords(vpp.subPicture.width, vpp.subPicture.height);
        dwOutPoint = asmMergeCoords(vpp.subPicture.originX & 0x1E, 0);
        dwInPoint = dwOutPoint << 4;
        dwOverlayPoint = dwInPoint;
        dwDstOffset = dwSrcOffset;
    } else {
        // otherwise blit the whole thing to next work surface
        dwSubPictureOffset = vpp.subPicture.offset;
        dwMergeSize = asmMergeCoords(dwWidth, dwHeight);
        dwInPoint = 0;
        dwOutPoint = 0;
        dwOverlayPoint = 0;
    }
    dwClipSize = asmMergeCoords(dwWidth, dwHeight);

    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
    } else {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
    }

    VppResetNotification(vpp.m_obj_a[DVDPICT_NDX].notifier_a, lpProcInfo->hSubPicture3);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[DVDPICT_NDX].classIID);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV038_IMAGE_OUT_POINT | 0x400000);
    vpp.pPusher->push(3, dwOutPoint);                              // ImageOutPoint
    vpp.pPusher->push(4, dwMergeSize);                             // ImageOutSize
    vpp.pPusher->push(5, (dwOutFormat << 16) | dwDstPitch);        // ImageOutFormat
    vpp.pPusher->push(6, dwDstOffset);                             // ImageOutOffset
    vpp.pPusher->push(7, 1 << 20);                                 // ImageInDeltaDuDx
    vpp.pPusher->push(8, 1 << 20);                                 // ImageInDeltaDvDy
    vpp.pPusher->push(9, dwClipSize);                              // ImageInSize
    vpp.pPusher->push(10, (dwOutFormat << 16) | dwSrcPitch);       // ImageInFormat
    vpp.pPusher->push(11, dwSrcOffset);                            // ImageInOffset
    vpp.pPusher->push(12, dwInPoint);                              // ImageInPoint
    vpp.pPusher->push(13, 1 << 20);                                // OverlayDeltaDuDx
    vpp.pPusher->push(14, 1 << 20);                                // OverlayDeltaDvDy
    vpp.pPusher->push(15, dwClipSize);                             // OverlaySize
    vpp.pPusher->push(16, (vpp.subPicture.format << 16) |  // OverlayFormat
                   (vpp.subPicture.pitch & 0xFFFFFFF0));
    vpp.pPusher->push(17, dwSubPictureOffset);                     // OverlayOffset
    vpp.pPusher->push(18, dwOverlayPoint);                         // OverlayPoint
    vpp.pPusher->push(19, SUB_CHANNEL(vpp.spareSubCh) | NV038_NOTIFY | 0x40000);
    vpp.pPusher->push(20, VPP_NOTIFY_TYPE);                        // Notify
    vpp.pPusher->push(21, SUB_CHANNEL(vpp.spareSubCh) | NV038_NO_OPERATION | 0x40000);
    vpp.pPusher->push(22, 0);
    vpp.pPusher->adjust(23);
    vpp.pPusher->start(TRUE);

    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DVDPICT_NDX].classIID;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppPreScale
//      Prescales YUV422 surface.  The new width and height are returned.  If
//      this routine does the field prescaling, it flips off the field flags
//      to indicate that the flip should not bob.
LOCAL BOOL vppPreScale(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                 DWORD dwSrcOffset, DWORD dwSrcPitch,
                 DWORD dwDstOffset, DWORD dwDstPitch,
                 LPDWORD pWidth, LPDWORD pHeight,
                 DWORD dwFourCC, LPDWORD pField)
{
    DWORD preScaleDeltaX;
    DWORD preScaleDeltaY;
    DWORD preScaleOverlay;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwXFactor, dwYFactor;
    DWORD dwSrcWidth, dwDstWidth, dwSrcHeight, dwDstHeight;
    DWORD dwOutSizeX, dwOutSizeY, dwOutFormat;
    DWORD dwInPitch, dwInOffset, dwInPoint, dwInSize;
    BOOL isField;
    Vpp_t &vpp = *pVpp;;

    dwSrcWidth = *pWidth;
    dwSrcHeight = *pHeight;
    dwDstWidth = vpp.dwOverlayDstWidth;
    dwDstHeight = vpp.dwOverlayDstHeight;

    if (dwDstWidth == 0 ||dwDstHeight == 0) {
        return FALSE;
    }

    isField = IS_FIELD(*pField);

    if (dwDstWidth <= 1) {
        dwDeltaX = 0x100000;
        dwXFactor = 1;
    } else {
        dwDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
        dwXFactor = dwSrcWidth / dwDstWidth;
    }

    if (dwDstHeight <= 1) {
        dwDeltaY = 0x100000;
        dwYFactor = 1;
    } else {
        dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
        dwYFactor = dwSrcHeight / dwDstHeight;
    }

    preScaleOverlay = 0;

    if (dwXFactor >= max(vpp.dwOverlayMaxDownScaleX,2) && vpp.extraNumSurfaces >= 4) {
        // use multipass X downscale, one pass reduces by a factor of 2
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = (dwSrcWidth >> 1);
        preScaleDeltaX = ((dwSrcWidth - 1) << 20) / (dwSrcWidth / 2 - 1);
        vpp.dwOverlayDeltaX = ((dwSrcWidth / 2 - 1) << 20) / (dwDstWidth - 1);
    } else if (dwSrcWidth > (dwDstWidth * vpp.dwOverlayMaxDownScale)) {
        // use X prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = dwDstWidth;
        preScaleDeltaX = dwDeltaX;
        vpp.dwOverlayDeltaX = 0x100000;
    } else {
        // use X overlay scaler
        dwOutSizeX = *pWidth;
        preScaleDeltaX = 0x100000;
        vpp.dwOverlayDeltaX = dwDeltaX;
    }

    if (dwYFactor >= max(vpp.dwOverlayMaxDownScaleY,2) && vpp.extraNumSurfaces >= 4) {
        // use multipass Y downscale, one pass reduces by a factor of 2
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = (dwSrcHeight >> 1) & ~1;
        preScaleDeltaY = ((dwSrcHeight - 1) << 20) / (dwSrcHeight / 2 - 1);
        vpp.dwOverlayDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwDstHeight - 1);
    } else if (dwSrcHeight > (dwDstHeight * vpp.dwOverlayMaxDownScale) ||
              (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)) {
        // use Y prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = dwDstHeight;
        preScaleDeltaY = dwDeltaY;
        vpp.dwOverlayDeltaY = 0x100000;
    } else {
        // use Y overlay scaler
        dwOutSizeY = *pHeight;
        preScaleDeltaY = 0x100000;
        vpp.dwOverlayDeltaY = dwDeltaY;
    }

    if ((vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) || (preScaleOverlay & NV_PRESCALE_OVERLAY_Y)) {
        if (isField) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            if (*pField & VPP_INTERLEAVED) {
                if (dwYFactor >= max(vpp.dwOverlayMaxDownScaleY,2) && vpp.extraNumSurfaces >= 4) {
                    // multipass
                    preScaleDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwSrcHeight / 2 - 1);
                } else if (dwSrcHeight > (dwDstHeight * vpp.dwOverlayMaxDownScale) ||
                          (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)) {
                    // use Y prescaler
                    preScaleDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwDstHeight - 1);
                } else {
                    // use Y overlay scaler
                    preScaleDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwSrcHeight - 1);
                }
            }
        }
    }

    if (preScaleOverlay == 0) {
        return FALSE;
    }

    dwInSize = asmMergeCoords( ((*pWidth+1) & 0xFFFE), *pHeight);
    dwInPoint = 0xFFF8FFF8;
    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField && (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        if (*pField & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            *pHeight >>= 1;
            if (*pField & VPP_ODD) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (*pField & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            if (*pField & VPP_ODD) {
                dwInPoint += 0x00040000;
            } else {
                dwInPoint += 0x000C0000;
            }
        }
    }
// I believe this code fixes a limit violation error (which should not be occuring so far as I can tell)
// however Sandy reports that visual quality is greatly reduced if we start on aligned boundary instead
// of -1/2 line. That results in a drop of our score on the Video2000 benchmark.  I could not get that
// to run.  Anyway, if no violation errors occur, we can remove this. @mjl@  
#if 0 
    else
    {
        dwInPoint = 0;
    }
#endif

    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
    } else {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
    }

    // HWBUG: Must serialize all usage of DVD subpicture
    // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hSubPicture3, VPP_TIMEOUT_TIME))) {
    if (VppWaitForNotification(vpp.m_obj_a[DVDPICT_NDX].notifier_a, lpProcInfo->hSubPicture3, VPP_TIMEOUT_TIME)) {
        dbgError(" *** SUBPICTURE event failure ***");
        EVENT_ERROR;
    }

    VppResetNotification(vpp.m_obj_a[DVDPICT_NDX].notifier_a, lpProcInfo->hSubPicture3);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[DVDPICT_NDX].classIID);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV038_IMAGE_OUT_POINT | 0x400000);
    vpp.pPusher->push(3, 0);                                       // ImageOutPoint
    vpp.pPusher->push(4, asmMergeCoords((dwOutSizeX + 1) & ~1, dwOutSizeY));  // ImageOutSize
    vpp.pPusher->push(5, (dwOutFormat << 16) | dwDstPitch);        // ImageOutFormat
    vpp.pPusher->push(6, dwDstOffset);                             // ImageOutOffset
    vpp.pPusher->push(7, preScaleDeltaX);                          // ImageInDeltaDuDx
    vpp.pPusher->push(8, preScaleDeltaY);                          // ImageInDeltaDvDy
    vpp.pPusher->push(9, dwInSize);                                // ImageInSize
    vpp.pPusher->push(10, (dwOutFormat << 16) | dwInPitch);        // ImageInFormat
    vpp.pPusher->push(11, dwInOffset);                             // ImageInOffset
    vpp.pPusher->push(12, dwInPoint);                              // ImageInPoint
    vpp.pPusher->push(13, preScaleDeltaX);                         // OverlayDeltaDuDx
    vpp.pPusher->push(14, preScaleDeltaY);                         // OverlayDeltaDvDy
    vpp.pPusher->push(15, dwInSize);                               // OverlaySize
    vpp.pPusher->push(16, (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwInPitch);  // OverlayFormat
    vpp.pPusher->push(17, dwInOffset);                             // OverlayOffset
    vpp.pPusher->push(18, 0);                                      // OverlayPoint
    vpp.pPusher->push(19, SUB_CHANNEL(vpp.spareSubCh) | NV038_NOTIFY | 0x40000);
    vpp.pPusher->push(20, VPP_NOTIFY_TYPE);                        // Notify
    vpp.pPusher->push(21, SUB_CHANNEL(vpp.spareSubCh) | NV038_NO_OPERATION | 0x40000);
    vpp.pPusher->push(22, 0);
    vpp.pPusher->adjust(23);
    vpp.pPusher->start(TRUE);

    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DVDPICT_NDX].classIID;

    // return changes in state
    if ((vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
        (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        // with HQVUp, we no longer use the overlay to bob
        *pField &= ~(VPP_ODD | VPP_EVEN | VPP_BOB | VPP_INTERLEAVED);
    }
    *pHeight = dwOutSizeY;
    *pWidth  = dwOutSizeX;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppFSMirror
//      Scale and colour convert YUV to RGB surface
LOCAL BOOL vppFSMirror(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                 DWORD dwSrcOffset, DWORD dwSrcPitch,
                 DWORD dwWidth, DWORD dwHeight,
                 DWORD dwFourCC, DWORD dwFlags,
                 DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY)
{
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwDstPitch, dwDstOffset, dwDstSize, dwSrcSize, dwDstPoint;
    DWORD dwSrcWidth, dwDstWidth, dwSrcHeight, dwDstHeight;
    DWORD dwCombinedPitch, dwColourFormat;
    DWORD dwInFormat, dwSrcX, dwSrcY;
    DWORD dwInPitch, dwInOffset, dwInPoint;
    BOOL isField, doZoom;
    DWORD dwBytesPerPel;
    DWORD dwColourFormat2;
    Vpp_t &vpp = *pVpp;

    dwSrcX      = (vpp.dwOverlayFSSrcMinX * dwPrescaleFactorX) >> 20;
    dwSrcY      = (vpp.dwOverlayFSSrcMinY * dwPrescaleFactorY) >> 20;
    dwSrcWidth  = (vpp.dwOverlayFSSrcWidth * dwPrescaleFactorX) >> 20;
    dwSrcHeight = (vpp.dwOverlayFSSrcHeight * dwPrescaleFactorY) >> 20;
    dwDstWidth  = vpp.dwOverlayFSWidth;
    dwDstHeight = vpp.dwOverlayFSHeight;
    dwDstPitch  = vpp.dwOverlayFSPitch;
    dwDstOffset = vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex];
    dwDstPoint  = 0;
    dwInPoint   = (((dwSrcX << 4) - 8) & 0x0000FFFF) | ((dwSrcY << 20) - 0x80000);

    // scaled image and gdi_rect will silently fail unless we set the pattern (?)
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextPattern);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
    vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
    switch (vpp.dwOverlayFSFormat) {
    case NV062_SET_COLOR_FORMAT_LE_Y8:
        dwBytesPerPel = 2;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_008);
        vpp.pPusher->push(5,NV_ALPHA_1_008);
        break;
    case NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8:
        dwBytesPerPel = 4;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_032);
        vpp.pPusher->push(5,NV_ALPHA_1_032);
        break;
    default:
        dwBytesPerPel = 2;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
        vpp.pPusher->push(4,NV_ALPHA_1_016);
        vpp.pPusher->push(5,NV_ALPHA_1_016);
        break;
    }
    vpp.pPusher->adjust(6);

    isField = IS_FIELD(dwFlags);

    if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSTRACKOVLZOOM) {
        doZoom = vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK;
    } else {
        doZoom = vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSZOOMQUADMASK;
    }
    if (doZoom) {
        // zoom
        DWORD dwZoomFactor, dwZoomQuad;
        DWORD dwNewSrcWidth, dwNewSrcHeight;

        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSTRACKOVLZOOM) {
            dwZoomFactor   = 384 - ((vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK) >> 12);
            dwZoomQuad     = (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) >> 8;
        } else {
            dwZoomFactor   = 384 - ((vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSZOOMFACTORMASK) >> 12);
            dwZoomQuad     = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSZOOMQUADMASK) >> 8;
        }
        dwNewSrcWidth  = dwSrcWidth  * dwZoomFactor / 384;
        dwNewSrcHeight = dwSrcHeight * dwZoomFactor / 384;

        // get start point
        switch (dwZoomQuad) {
        case 1:  break;
        case 2:  dwSrcX += dwSrcWidth - dwNewSrcWidth;          break;
        case 3:  dwSrcY += dwSrcHeight - dwNewSrcHeight;        break;
        case 4:  dwSrcX += dwSrcWidth - dwNewSrcWidth;
                 dwSrcY += dwSrcHeight - dwNewSrcHeight;        break;
        case 5:  dwSrcX += (dwSrcWidth - dwNewSrcWidth) >> 1;
                 dwSrcY += (dwSrcHeight - dwNewSrcHeight) >> 1; break;
        default: break;
        }
        dwSrcWidth = dwNewSrcWidth;
        dwSrcHeight = dwNewSrcHeight;
    }
    // align source
    dwSrcOffset += (dwSrcY * dwSrcPitch) + ((dwSrcX * 2) & ~NV_BYTE_ALIGNMENT_PAD);
    dwSrcX &= ((NV_BYTE_ALIGNMENT / 2) - 1);
    dwSrcY = 0;
    dwInPoint = (dwInPoint & 0xFFFF0000) | ((dwInPoint & 0x0000FFFF) + (dwSrcX << 4));

    dwDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
    dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
    dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwSrcX + 1) & ~1);

    if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSASPECT) {
        // preserve aspect
        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSTRACKOVLASPECT) {
            // track overlay aspect
            DWORD dwOverlayAspect = (vpp.dwOverlayDeltaX << 8) / vpp.dwOverlayDeltaY;
            DWORD dwNewDeltaY, dwNewDstHeight;

            dwNewDeltaY = (dwDeltaX << 8) / dwOverlayAspect;
            dwNewDstHeight = ((dwSrcHeight - 1) << 20) / dwNewDeltaY + 1;
            if (dwNewDstHeight <= dwDstHeight) {
                DWORD dwHeightPad;
                // X is wider
                dwDeltaY = dwNewDeltaY;
                dwDstHeight = dwNewDstHeight;
                dwHeightPad = ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
                dwDstOffset += vpp.dwOverlayFSPitch * dwHeightPad;
//                if (vpp.dwOverlayFSNumSurfaces == 1) {
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex], vpp.dwOverlayFSPitch,
                                 vpp.dwOverlayFSWidth, dwHeightPad, dwBytesPerPel);
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex] + (dwHeightPad + dwDstHeight) * vpp.dwOverlayFSPitch,
                                 vpp.dwOverlayFSPitch, dwDstWidth, dwHeightPad, dwBytesPerPel);
                    vpp.dwOverlayFSDeltaX = dwDeltaX;
                    vpp.dwOverlayFSDeltaY = dwDeltaY;
//                }
            } else {
                // Y is higher
                DWORD dwXOffsetPels;

                dwOverlayAspect = (vpp.dwOverlayDeltaY << 8) / vpp.dwOverlayDeltaX;
                dwDeltaX = (dwDeltaY << 8) / dwOverlayAspect;
                dwDstWidth = ((dwSrcWidth - 1) << 20) / dwDeltaX + 1;
                dwXOffsetPels = (vpp.dwOverlayFSWidth - dwDstWidth) >> 1;
                dwDstOffset += (dwXOffsetPels * dwBytesPerPel) & ~NV_BYTE_ALIGNMENT_PAD;
                dwDstPoint = dwXOffsetPels & ((NV_BYTE_ALIGNMENT / dwBytesPerPel) - 1);
                dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwDstPoint + dwSrcX + 1) & ~1);
//                if (vpp.dwOverlayFSNumSurfaces == 1) {
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex],
                                 vpp.dwOverlayFSPitch, dwXOffsetPels, dwDstHeight, dwBytesPerPel);
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex] + ((dwXOffsetPels + dwDstWidth) * dwBytesPerPel),
                                 vpp.dwOverlayFSPitch, dwXOffsetPels, dwDstHeight, dwBytesPerPel);
                    vpp.dwOverlayFSDeltaX = dwDeltaX;
                    vpp.dwOverlayFSDeltaY = dwDeltaY;
//                }
            }
        } else if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSFIXEDANIMORPHIC) {
            // fixed 16:9 aspect
            dwDstHeight = dwDstWidth * 9 / 16;
            dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
            dwDstOffset += vpp.dwOverlayFSPitch * ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
        } else if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSFIXEDTV) {
            // fixed 4:3 aspect
            if ((dwDstHeight * 4 / 3) >= dwDstWidth) {
                // use X as a reference
                dwDstHeight = dwDstWidth * 3 / 4;
                dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
                dwDstOffset += vpp.dwOverlayFSPitch * ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
            } else {
                DWORD dwXOffsetPels;

                // use Y as a reference
                dwDstWidth = dwDstHeight * 4 / 3;
                dwDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
                dwXOffsetPels = (vpp.dwOverlayFSWidth - dwDstWidth) >> 1;
                dwDstOffset += (dwXOffsetPels * dwBytesPerPel) & ~NV_BYTE_ALIGNMENT_PAD;
                dwDstPoint = dwXOffsetPels & ((NV_BYTE_ALIGNMENT / dwBytesPerPel) - 1);
                dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwDstPoint + dwSrcX + 1) & ~1);
            }
        } else {
            // preserve aspect
            DWORD dwNewDstHeight = ((dwSrcHeight - 1) << 20) / dwDeltaX + 1;

            if (dwNewDstHeight <= dwDstHeight) {
                // X is wider
                dwDeltaY = dwDeltaX;
                dwDstHeight = dwNewDstHeight;
                dwDstOffset += vpp.dwOverlayFSPitch * ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
            } else {
                //Y is wider
                DWORD dwXOffsetPels;

                dwDeltaX = dwDeltaY;
                dwDstWidth = ((dwSrcWidth - 1) << 20) / dwDeltaX + 1;
                dwXOffsetPels = (vpp.dwOverlayFSWidth - dwDstWidth) >> 1;
                dwDstOffset += (dwXOffsetPels * dwBytesPerPel) & ~NV_BYTE_ALIGNMENT_PAD;
                dwDstPoint = dwXOffsetPels & ((NV_BYTE_ALIGNMENT / dwBytesPerPel) - 1);
                dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwDstPoint + dwSrcX + 1) & ~1);
            }
        }
        if (vpp.dwOverlayFSDeltaX != dwDeltaX || vpp.dwOverlayFSDeltaY != dwDeltaY) {
            static DWORD dwCount = 0;
            // aspect has changed, clear surface first
            vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex], vpp.dwOverlayFSPitch,
                         vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, dwBytesPerPel);
            if (dwCount++ >= (4 * vpp.dwOverlayFSNumSurfaces)) {
                vpp.dwOverlayFSDeltaX = dwDeltaX;
                vpp.dwOverlayFSDeltaY = dwDeltaY;
                dwCount = 0;
            }
        }
    }

    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField) {
        // Set flag to say overlay has been in Bob mode.
        vpp.pDriverData->dwDXVAFlags |= DXVA_OVERLAY_WAS_BOBBED;

        if (dwFlags & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            dwSrcHeight >>= 1;
            dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight);
            if (dwFlags & VPP_ODD) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (dwFlags & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            if (dwFlags & VPP_ODD) {
                dwInPoint += 0x00040000;
            } else {
                dwInPoint += 0x000C0000;
            }
        }
    }
    else if (vpp.pDriverData->dwDXVAFlags & DXVA_OVERLAY_WAS_BOBBED) {
        // For Weave mode: if the overlay has ever been in Bob mode, we adjust the vertical
        // scale factor to match the Bob mode scaling, to improve Bob/Weave switches.
        dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight);
    }

    // set ROP
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropSubCh) | SET_ROP_OFFSET | 0x40000);
    vpp.pPusher->push(1, SRCCOPYINDEX);
    vpp.pPusher->adjust(2);
    vpp.pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

    // set colour key
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextColorKey);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->adjust(4);
    vpp.pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;

    if (dwFourCC == FOURCC_UYVY) {
        dwInFormat = NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8;
    } else {
        dwInFormat = NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8;
    }

    dwCombinedPitch = (dwDstPitch << 16) | dwInPitch;
    dwColourFormat = max(vpp.dwOverlayFSFormat, NV062_SET_COLOR_FORMAT_LE_R5G6B5);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    vpp.pPusher->push(1, dwColourFormat);                  // SetColorFormat
    vpp.pPusher->push(2, dwCombinedPitch);                 // SetPitch
    vpp.pPusher->push(3, dwInOffset);                      // SetSrcOffset
    vpp.pPusher->push(4, dwDstOffset);                     // SetDstOffset
    vpp.pPusher->adjust(5);
    vpp.pDriverData->bltData.dwLastColourFormat = dwColourFormat;
    vpp.pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
    vpp.pDriverData->bltData.dwLastSrcOffset = dwInOffset;
    vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    dwDstSize  = (dwDstHeight << 16) | dwDstWidth;

// TBD ask ###
    // wait for any backdoor FOURCC blits to complete
    if (VppWaitForNotification(vpp.pPusherSyncNotifier, lpProcInfo->hFSMirror3, VPP_TIMEOUT_TIME)) {
        dbgError(" *** FSMIRROR event failure ***");
        EVENT_ERROR;
    }

    VppResetNotification(vpp.pPusherSyncNotifier, lpProcInfo->hFSMirror3);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[SCALED_IMAGE1_NDX].classIID);
//    vpp.pPusher->push(1, NV_DD_SCALED_IMAGE_IID);

    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    vpp.pPusher->push(3, vpp.hInVideoMemContextDma);   // SetContextDmaImage
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_CONTEXT_SURFACE_OFFSET | 0x40000);
    vpp.pPusher->push(5, vpp.hSurfaces2D);                       // SetContextSurface
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    vpp.pPusher->push(7, dwInFormat);              // SetColorFormat
    vpp.pPusher->push(8, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    vpp.pPusher->push(9, dwDstPoint);              // ClipPoint
    vpp.pPusher->push(10, dwDstSize);              // ClipSize
    vpp.pPusher->push(11, dwDstPoint);             // ImageOutPoint
    vpp.pPusher->push(12, dwDstSize);              // ImageOutSize
    vpp.pPusher->push(13, dwDeltaX);               // DsDx
    vpp.pPusher->push(14, dwDeltaY);               // DtDy
    vpp.pPusher->push(15, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    vpp.pPusher->push(16, dwSrcSize);              // ImageInSize
    vpp.pPusher->push(17, (NV089_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                   (NV089_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                   dwInPitch);
    vpp.pPusher->push(18, dwInOffset);             // ImageInOffset
    vpp.pPusher->push(19, dwInPoint);              // ImageInPoint
    vpp.pPusher->push(20, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_NOTIFY_OFFSET | 0x40000);
    vpp.pPusher->push(21, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(22, SUB_CHANNEL(vpp.spareSubCh) | NV089_NO_OPERATION | 0x40000);
    vpp.pPusher->push(23, 0);
    vpp.pPusher->adjust(24);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[SCALED_IMAGE1_NDX].classIID;
//    vpp.pDriverData->dDrawSpareSubchannelObject = NV_DD_SCALED_IMAGE_IID;

    // restore surfaces2d, pattern, and rect formats
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextPattern);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
    vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
    switch ((GET_MODE_BPP() + 1) / 8) {
    case 1:
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_008);
        vpp.pPusher->push(5,NV_ALPHA_1_008);
        break;
    case 4:
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_032);
        vpp.pPusher->push(5,NV_ALPHA_1_032);
        break;
    default:
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
        vpp.pPusher->push(4,NV_ALPHA_1_016);
        vpp.pPusher->push(5,NV_ALPHA_1_016);
        break;
    }
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.ropRectTextSubCh) | NV04A_SET_COLOR_FORMAT | 0x40000);
    vpp.pPusher->push(7, dwColourFormat2);
    vpp.pPusher->push(8, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
    vpp.pPusher->push(9, NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
    vpp.pPusher->adjust(10);

    vpp.pDriverData->bltData.dwLastColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

    return TRUE;
}


//---------------------------------------------------------------------------
// vppColourControl
//      Software colour controls for NV4/5.  There is evidence that the
//      Windows kernel uses the floating point stack, which is why there
//      are extra EMMS instructions scattered through the code.
LOCAL BOOL vppColourControl(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                      DWORD dwSrcOffset, DWORD dwSrcPitch,
                      DWORD dwDstOffset, DWORD dwDstPitch,
                      DWORD dwWidth, DWORD dwHeight,
                      DWORD dwFourCC, DWORD dwFlags)
{
    BOOL bOverContrast;
    DWORD dwContrast, dwBrightness, cnt, brt;
    short hue, sat;
    DWORD dwYPhase, dwSysPitch;
    BOOL doContrastBlt, doLuma, doChroma;
    DWORD dwMergeSize;
    BOOL isField;
    Vpp_t &vpp = *pVpp;

    isField = IS_FIELD(dwFlags);

    if (isField) {
        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwSrcOffset += dwSrcPitch;
                dwDstOffset += dwDstPitch;
            }
            dwSrcPitch <<= 1;
            dwDstPitch <<= 1;
            dwHeight >>= 1;
        }
    }

    if (vpp.colorCtrl.lContrast > 0xFF) {
        cnt = vpp.colorCtrl.lContrast >> 1;
        bOverContrast = TRUE;
    } else {
        cnt = vpp.colorCtrl.lContrast;
        bOverContrast = FALSE;
    }
    if(vpp.colorCtrl.lBrightness  < 0 ) {
      brt = -vpp.colorCtrl.lBrightness;
    } else {
      brt = vpp.colorCtrl.lBrightness;
    }
    hue = (short) vpp.colorCtrl.lHue;
    sat = (short) vpp.colorCtrl.lSaturation;

    dwSysPitch = dwSrcPitch >> 1;
    if (dwFourCC == FOURCC_UYVY || dwFourCC == FOURCC_UYNV) {
        dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
        dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
        dwYPhase = 1;
    } else if (dwFourCC == FOURCC_YUY2 || dwFourCC == FOURCC_YUNV) {
        dwContrast   = cnt | (cnt << 16) | 0xFF00FF00;
        dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
        dwYPhase = 0;
    } else {
        dwContrast   = 0xFFFFFFFF;
        dwBrightness = 0;
        bOverContrast = FALSE;
        dwYPhase = 0;
    }
    if (dwFourCC == FOURCC_YV12 ||
        dwFourCC == FOURCC_YVU9 ||
        dwFourCC == FOURCC_IF09 ||
        dwFourCC == FOURCC_IV31 ||
        dwFourCC == FOURCC_IV32) {
        dwSrcPitch <<= 1;
        dwSysPitch <<= 1;
    }

    dwWidth = (dwWidth + 1) & ~1;      // width must be even
    //if (dwWidth > dwSysPitch)
    //   dwWidth -= 2;
    dwMergeSize = (dwHeight << 16) | (dwWidth >> 1);

    doContrastBlt = (dwContrast != 0xFFFFFFFF);
    doLuma        = (dwBrightness != 0 || bOverContrast);
    doChroma      = (hue != 0 || sat != 0x100);

    if (doChroma) {
        // Apply a chroma vector scale and rotation
        // [U'] = [ sat*cos(hue)  sat*sin(hue)] [U]
        // [V']   [-sat*sin(hue)  sat*cos(hue)] [V]
        short sinhue, coshue;
        __int64 c1, c2;
        static const __int64 bOneTwentyEight = 0x8080808080808080;
        static const __int64 evenMask        = 0x00FF00FF00FF00FF;
        static const __int64 oddMask         = 0xFF00FF00FF00FF00;
        static const __int64 zero            = 0;
        DWORD dwChromaOffset, dwAdjWidth, j;
        LPBYTE qPtr;
        // sin table normalized to 256
        static const short sintable[91] = {  0,  4,  9, 13, 18, 22, 27, 31,
                                            36, 40, 44, 49, 53, 58, 62, 66,
                                            71, 75, 79, 83, 88, 92, 96,100,
                                           104,108,112,116,120,124,128,132,
                                           136,139,143,147,150,154,158,161,
                                           165,168,171,175,178,181,184,187,
                                           190,193,196,199,202,204,207,210,
                                           212,215,217,219,222,224,226,228,
                                           230,232,234,236,237,239,241,242,
                                           243,245,246,247,248,249,250,251,
                                           252,253,254,254,255,255,255,256,
                                           256,256,256 };

        dwChromaOffset = dwSysPitch * dwHeight;

        // move chroma data to system memory
        _asm {emms};

        VppResetNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[V2OSH_FORMAT_NDX].classIID);
        vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push( 1, vpp.hFromVideoMemContextDma);              // SetContextDmaBufferIn
        vpp.pPusher->push( 2, vpp.hFloatingContextDmaInOverlayShadow);   // SetContextDmaBufferOut
        vpp.pPusher->push( 3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push( 4, dwSrcOffset + (dwYPhase ^ 1));             // OffsetIn
        vpp.pPusher->push( 5, dwChromaOffset);                           // OffsetOut
        vpp.pPusher->push( 6, dwSrcPitch);                               // PitchIn
        vpp.pPusher->push( 7, dwSysPitch);                               // PitchOut
        vpp.pPusher->push( 8, dwWidth);                                  // LineLengthIn
        vpp.pPusher->push( 9, dwHeight);                                 // LineCount
        vpp.pPusher->push(10, 0x102);                                    // Format
        vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                          // BufferNotify
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        // coefficient calculations
        // possible MMX multiply overflow later, so halve the coefficients now
        // and double the result later with saturation
        if (vpp.colorCtrl.lHue <= 90) {
            sinhue = (short)(((long)sat * sintable[hue]) >> 9);
            coshue = (short)(((long)sat * sintable[90 - hue]) >> 9);
        } else if (vpp.colorCtrl.lHue <= 180) {
            sinhue = (short)(((long)sat * sintable[180 - hue]) >> 9);
            coshue = (short)(((long)sat * -sintable[hue - 90]) >> 9);
        } else if (vpp.colorCtrl.lHue <= 270) {
            sinhue = (short)(((long)sat * -sintable[hue - 180]) >> 9);
            coshue = (short)(((long)sat * -sintable[270 - hue]) >> 9);
        } else {
            sinhue = (short)(((long)sat * -sintable[360 - hue]) >> 9);
            coshue = (short)(((long)sat * sintable[hue - 270]) >> 9);
        }

        // c1 = sat*cos(hue), sat*cos(hue), sat*cos(hue), sat*cos(hue)
        c1 = (__int64)coshue & 0xFFFF;
        c1 |= c1 << 16;
        c1 |= c1 << 32;
        // c2 = -sat*sin(hue), sat*sin(hue), -sat*sin(hue), sat*sin(hue)
        c2 = (__int64)sinhue & 0xFFFF;
        c2 |= ((__int64)-sinhue & 0xFFFF) << 16;
        c2 |= c2 << 32;

        // init MMX const data
        qPtr       = (LPBYTE) (vpp.fpOverlayShadow + dwChromaOffset);
        dwAdjWidth = (dwWidth + 7) / 8;
        _asm {
            movq        mm0, zero
            movq        mm1, bOneTwentyEight
        }

        // while we are doing some host MMX things, overlap with some luma operations
        // since we are main memory throughput bound, DO NOT overlap with operations that touch main memory
        if (doContrastBlt) {
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hContextBeta4);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
            vpp.pPusher->push(3, dwContrast);

            vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(5, vpp.hSurfaces2D);
            vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_PITCH_OFFSET | 0xC0000);
            if (doLuma) {
                // more stuff to do later, do this in place
                vpp.pPusher->push(7, (dwSrcPitch << 16) | dwSrcPitch); // set pitch
                vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
                vpp.pPusher->push(9, dwSrcOffset);                     // set offset destin
                vpp.pDriverData->bltData.dwLastCombinedPitch = (dwSrcPitch << 16) | dwSrcPitch;
                vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
                vpp.pDriverData->bltData.dwLastDstOffset = dwSrcOffset;
            } else {
                vpp.pPusher->push(7, (dwDstPitch << 16) | dwSrcPitch); // set pitch
                vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
                vpp.pPusher->push(9, dwDstOffset);                     // set offset destin
                vpp.pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
                vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
                vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;
            }

            vpp.pPusher->push(10, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
            vpp.pPusher->push(12, SUB_CHANNEL(vpp.spareSubCh) | BLIT_POINT_IN_OFFSET | 0xC0000);
            vpp.pPusher->push(13, 0);                                  // control point in
            vpp.pPusher->push(14, 0);                                  // control point out
            vpp.pPusher->push(15, dwMergeSize);                        // size

            vpp.pPusher->adjust(16);
            vpp.pPusher->start(TRUE);
        }

        if (!doContrastBlt && !doLuma) {
            // luma has not and will not move, do that now
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcOffset + dwYPhase);          // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwYPhase);          // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch);                      // PitchIn
            vpp.pPusher->push(6, dwDstPitch);                      // PitchOut
            vpp.pPusher->push(7, dwWidth);                         // LineLengthIn
            vpp.pPusher->push(8, dwHeight);                        // LineCount
            vpp.pPusher->push(9, 0x202);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
            vpp.pPusher->start(TRUE);
        }

        // wait for chroma to arrive in system memory
        _asm {emms};
        // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME)) {
            dbgError(" *** COLOUR CONTROL event failure ***");
            EVENT_ERROR;
        }

/*      // commented out because this appears to cause a cache coherency problem (bug in BX?)
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 2
                preld1: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld1
            }
            qPtr += dwSysPitch;
        }
*/
        // do the chroma vector scale and rotation, 2.25 cycles/pixel
        // mm0 = 0
        // mm1 = 128
        // mm2 = sign mask
        // mm3 = data quad / expanded data / result high
        // mm4 = expanded data / result low
        // mm5 = expanded data, UV swapped
        // mm6 = UV swapped quad / expanded swapped data
        // mm7 = work space
        if (vpp.regOverlayColourControlEnable == 2) {
            // full chroma resolution
            for (j=0; j<dwHeight; j++) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            mov         ebx, dwSysPitch
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc:  mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            punpcklbw   mm5, mm2        ; U  ; mm5 = unpacked signed low VU data
                            movq        mm7, mm3        ; V  ; move result to mm7 so we can reuse mm3 early
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            jnz         nextc
                }
                qPtr += dwSysPitch;
            }
        } else {
            // vertical chroma subsample
            // in this case, ESI is used for source and in-place destination, and EDI is used for next line in destination
            for (j=0; j<dwHeight; j+=2) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            add         edi, dwSysPitch
                            mov         ebx, dwSysPitch
                            shl         ebx, 1
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc2: mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            movq        mm7, mm3        ; U  ; move result to mm7 so we can reuse mm3 early
                            punpcklbw   mm5, mm2        ; V  ; mm5 = unpacked signed low VU data
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            movq        [esi-8], mm5    ; U  ; store same data on next line
                            jnz         nextc2          ; V
                }
                qPtr += dwSysPitch << 1;
            }
        }

        _asm {emms};

        VppResetNotification(vpp.m_obj_a[OSH2V_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        // move chroma data to back to video memory

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID);
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push(1, vpp.hFloatingContextDmaInOverlayShadow);          // SetContextDmaBufferIn
        vpp.pPusher->push(2, vpp.hToVideoMemContextDma);                       // SetContextDmaBufferOut
        vpp.pPusher->push(3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(4, dwChromaOffset);                                  // OffsetIn
        vpp.pPusher->push(5, dwDstOffset + (dwYPhase ^ 1));                    // OffsetOut
        vpp.pPusher->push(6, dwSysPitch);                                      // PitchIn
        vpp.pPusher->push(7, dwDstPitch);                                      // PitchOut
        vpp.pPusher->push(8, dwWidth);                                         // LineLengthIn
        vpp.pPusher->push(9, dwHeight);                                        // LineCount
        vpp.pPusher->push(10, 0x201);                                          // Format
        if (!doLuma) {
            vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                            // BufferNotify
        } else {
            vpp.pPusher->push(11, NV039_BUFFER_NOTIFY_WRITE_ONLY);             // BufferNotify
        }
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID;

    } else if (doContrastBlt) {
        // Contrast Blit, since the hardware can only do multiplies up to one (0xFF),
        // and if the contrast is from 100% to 200%, then divide contrast by 2 and worry
        // about left shift and saturation in the MMX routines below
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextBeta4);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, dwContrast);

        vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(5, vpp.hSurfaces2D);
        vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_PITCH_OFFSET | 0xC0000);
        if (doLuma) {
            // more stuff to do later, do this in place
            vpp.pPusher->push(7, (dwSrcPitch << 16) | dwSrcPitch); // set pitch
            vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
            vpp.pPusher->push(9, dwSrcOffset);                     // set offset destin
            vpp.pDriverData->bltData.dwLastCombinedPitch = (dwSrcPitch << 16) | dwSrcPitch;
            vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
            vpp.pDriverData->bltData.dwLastDstOffset = dwSrcOffset;
        } else {
            vpp.pPusher->push(7, (dwDstPitch << 16) | dwSrcPitch); // set pitch
            vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
            vpp.pPusher->push(9, dwDstOffset);                     // set offset destin
            vpp.pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
            vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
            vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;
        }

        vpp.pPusher->push(10, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
        vpp.pPusher->push(12, SUB_CHANNEL(vpp.spareSubCh) | BLIT_POINT_IN_OFFSET | 0xC0000);
        vpp.pPusher->push(13, 0);                                  // control point in
        vpp.pPusher->push(14, 0);                                  // control point out
        vpp.pPusher->push(15, dwMergeSize);                        // size
        vpp.pPusher->adjust(16);

        if (!doLuma) {
            // this is the only operation, be sure to trigger an event
            _asm {emms};

            VppResetNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV05F_NOTIFY | 0x40000);
            vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV05F_NO_OPERATION | 0x40000);
            vpp.pPusher->push(3, 0);
            vpp.pPusher->adjust(4);
        }
        vpp.pPusher->start(TRUE);
    }

    // OverContrast and Brightness calculations
    if (doLuma) {
        static const __int64 shiftMask   = 0xFEFEFEFEFEFEFEFE;
        static const __int64 cmpOverflow = 0xFFFFFFFFFFFFFFFF;
        DWORD j, dwAdjWidth;
        LPBYTE qPtr;

        // move Y data to system memory
        _asm {emms};

        VppResetNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[V2OSH_FORMAT_NDX].classIID);
        vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push( 1, vpp.hFromVideoMemContextDma);           // SetContextDmaBufferIn
        vpp.pPusher->push( 2, vpp.hFloatingContextDmaInOverlayShadow);// SetContextDmaBufferOut
        vpp.pPusher->push( 3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push( 4, dwSrcOffset + dwYPhase);                // OffsetIn
        vpp.pPusher->push( 5, 0);                                     // OffsetOut
        vpp.pPusher->push( 6, dwSrcPitch);                            // PitchIn
        vpp.pPusher->push( 7, dwSysPitch);                            // PitchOut
        vpp.pPusher->push( 8, dwWidth);                               // LineLengthIn
        vpp.pPusher->push( 9, dwHeight);                              // LineCount
        vpp.pPusher->push(10, 0x102);                                 // Format
        vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                       // BufferNotify
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        if (!doChroma) {
            // chroma has not and will not move, do that now
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcOffset + (dwYPhase ^ 1));    // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + (dwYPhase ^ 1));    // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch);                      // PitchIn
            vpp.pPusher->push(6, dwDstPitch);                      // PitchOut
            vpp.pPusher->push(7, dwWidth);                         // LineLengthIn
            vpp.pPusher->push(8, dwHeight);                        // LineCount
            vpp.pPusher->push(9, 0x202);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
            vpp.pPusher->start(TRUE);
        }

        // init MMX const data
        qPtr       = (LPBYTE) vpp.fpOverlayShadow;
        dwAdjWidth = (dwWidth + 15) / 16;
        _asm {
            movd        mm0, dwBrightness
            punpckldq   mm0, dwBrightness
            movq        mm2, shiftMask
            movq        mm3, cmpOverflow
        }

        // wait for luma data to arrive in system memory
        _asm {emms};
        // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME)) {
            dbgError(" *** COLOUR CONTROL event failure ***");
            EVENT_ERROR;
        }
/*
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 1
                preld2: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld2
            }
            qPtr += dwSysPitch;
        }
*/
        // do brightness and/or overcontrast
        // mm0 = brightness
        // mm1 = quad data chunk
        // mm2 = shift mask
        // mm3 = overflow compare value
        // mm4 = compare register
        // mm5 = next quad data chunk
        // mm6 = next compare register
        if (vpp.colorCtrl.lBrightness >= 0) {
            if (bOverContrast) {
                // overcontrast and positive brightness, 0.6875 cycles/pixel
                // AND is commented out for performance -> noise in the lowest bit of precision
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                       ;         shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq1: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                paddusb mm4, mm0        ; Vi    ; mm4 += brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                paddusb mm6, mm0        ; Vi+   ; mm6 += brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq1          ; V
                    }
                    qPtr += dwSysPitch;
                }
            } else {
                // positive brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq2: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                paddusb mm1, mm0        ; Vi    ; mm1 += brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                paddusb mm5, mm0        ; Vi+   ; mm5 += brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq2          ; V
                    }
                    qPtr += dwSysPitch;
                }
            }
        } else {
            if (bOverContrast) {
                // overcontrast and negative brightness
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq3: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                psubusb mm4, mm0        ; Vi    ; mm4 -= brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                psubusb mm6, mm0        ; Vi+   ; mm6 -= brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq3          ; V
                    }
                    qPtr += dwSysPitch;
                }
            } else {
                // negative brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq4: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                psubusb mm1, mm0        ; Vi    ; mm1 -= brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                psubusb mm5, mm0        ; Vi+   ; mm5 -= brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq4          ; V
                    }
                    qPtr += dwSysPitch;
                }
            }
        }

        // move Y data to back to video memory
        _asm {emms};

        VppResetNotification(vpp.m_obj_a[OSH2V_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID);
        vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push( 1, vpp.hFloatingContextDmaInOverlayShadow);// SetContextDmaBufferIn
        vpp.pPusher->push( 2, vpp.hToVideoMemContextDma);             // SetContextDmaBufferOut
        vpp.pPusher->push( 3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push( 4, 0);                                     // OffsetIn
        vpp.pPusher->push( 5, dwDstOffset + dwYPhase);                // OffsetOut
        vpp.pPusher->push( 6, dwSysPitch);                            // PitchIn
        vpp.pPusher->push( 7, dwDstPitch);                            // PitchOut
        vpp.pPusher->push( 8, dwWidth);                               // LineLengthIn
        vpp.pPusher->push( 9, dwHeight);                              // LineCount
        vpp.pPusher->push(10, 0x201);                                 // Format
        vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                       // BufferNotify
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID;
    }

    _asm {emms};
    return doContrastBlt || doLuma || doChroma;
}


//---------------------------------------------------------------------------
// vppNv20Deinterlace
//      Deinterlace filter for NV20.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL  BOOL vppNv20Deinterlace(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo,
                        DWORD dwSrcOffset, DWORD dwSrcPitch,
                        DWORD dwDstOffset, DWORD dwDstPitch,
                        DWORD dwWidth, DWORD dwHeight, DWORD dwFlags)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    int dwOppositeYOffset, dwCurrYOffset, dwDestYOffset;
    DWORD dwOppositeFieldOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert(vpp.dwFlags & VPP_FLAG_KELVIN_3D);

    // Let D3D code know that we have touched NV
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);

    if (!isField || !(dwFlags & VPP_INTERLEAVED)) {
        return FALSE;
    }

    dwCombineFactor = (vpp.regOverlayMode >> 16) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    dwOppositeFieldOffset = dwSrcOffset;

    if (dwFlags & VPP_ODD) {
        dwSrcOffset += dwSrcPitch;
        dwDstOffset += dwDstPitch;
    } else {
        dwOppositeFieldOffset += dwSrcPitch;
    }

    dwSrcPitch <<= 1;
    dwDstPitch <<= 1;
    dwHeight >>= 1;

    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitKelvin(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));
    vpp.pPusher->push(2, subchannel | NV097_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, subchannel | NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    vpp.pPusher->push(3, dwCombineFactor);
    vpp.pPusher->adjust(4);

    // Make sure offset is 128-byte aligned (in debug builds)
    nvAssert(!((dwSrcOffset % 128) || (dwOppositeFieldOffset & ~0x1) % 128));

    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    vpp.pPusher->push(3, dwSrcOffset);//dwOppositeFieldOffset & ~0x1);
    vpp.pPusher->push(4, subchannel | NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(5, dwDstOffset);
    vpp.pPusher->adjust(6);

    // IMPORTANT: Even if we are not using texture units 2 and 3, we need to give
    // them some kind of value other than zero in the following commands.
    // Without these, the hardware will behave incorrectly, probably exhibiting
    // a problem that looks like an invalid surface pitch.
    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    vpp.pPusher->push(3, dwMergeSize);
    vpp.pPusher->push(4, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    vpp.pPusher->push(5, 8 << 16 | 8);
    vpp.pPusher->push(6, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    vpp.pPusher->push(7, 8 << 16 | 8);
    vpp.pPusher->push(8, subchannel | NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    vpp.pPusher->push(9, dwSrcPitch << 16);
    vpp.pPusher->push(10, subchannel | NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    vpp.pPusher->push(11, dwSrcPitch << 16);
    vpp.pPusher->push(12, subchannel | NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    vpp.pPusher->push(13, 8 << 16 | 8);
    vpp.pPusher->push(14, subchannel | NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    vpp.pPusher->push(15, 8 << 16 | 8);
    vpp.pPusher->adjust(16);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000);
    vpp.pPusher->push(1, 0);
    vpp.pPusher->push(2, 0);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->push(4, 0);
    vpp.pPusher->push(5, 0);
    vpp.pPusher->push(6, 0);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->push(8, 0);
    vpp.pPusher->push(9, 0);
    vpp.pPusher->push(10, 4);
    vpp.pPusher->push(11, 8);
    vpp.pPusher->push(12, 0);
    vpp.pPusher->push(13, 0);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000);
    vpp.pPusher->push(15, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(16, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(17, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(18, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(19, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(20, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(21, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(22, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(23, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(24, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(25, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(26, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(27, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->adjust(28);

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    if (dwFlags & VPP_ODD) {
        dwOppositeYOffset = +1;
        dwCurrYOffset     = -1;
        dwDestYOffset     = -1;
    } else {
        dwOppositeYOffset = -1;
        dwCurrYOffset     = +1;
        dwDestYOffset     = +1;
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV097_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV097_INLINE_ARRAY | 0x40300000);

    vpp.pPusher->push(3, (dwDestYOffset << 16) | 0);   // destination
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current field
    vpp.pPusher->push(5, (dwOppositeYOffset << 16) | 0);   // opposite field
    
    vpp.pPusher->push(6, ((dwHeight+dwDestYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwOppositeYOffset) << 16) | 0);
    
    vpp.pPusher->push(9, ((dwHeight+dwDestYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11,  ((dwHeight+dwOppositeYOffset) << 16) | dwWidth);
    
    vpp.pPusher->push(12, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwOppositeYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hDFilter3);

    vpp.pPusher->push(0, subchannel | NV097_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV097_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppNv10Deinterlace
//      Deinterlace filter for NV10.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL BOOL vppNv10Deinterlace(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo,
                        DWORD dwSrcOffset, DWORD dwSrcPitch,
                        DWORD dwDstOffset, DWORD dwDstPitch,
                        DWORD dwWidth, DWORD dwHeight, DWORD dwFlags)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    unsigned long vertexSizeContext;
    int dwOppositeYOffset, dwCurrYOffset, dwDestYOffset;
    DWORD dwOppositeFieldOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert (NVARCH >= 0x10);

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);

    if (!isField || !(dwFlags & VPP_INTERLEAVED)) {
        return FALSE;
    }

    dwCombineFactor = (vpp.regOverlayMode >> 16) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    if (dwFlags & VPP_ODD) {
        dwOppositeFieldOffset = dwSrcOffset;
        dwSrcOffset += dwSrcPitch;
        dwDstOffset += dwDstPitch;
    } else {
        dwOppositeFieldOffset = dwSrcOffset + dwSrcPitch;
    }
    dwSrcPitch <<= 1;
    dwDstPitch <<= 1;
    dwHeight >>= 1;

    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitCelsius(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));

    vpp.pPusher->push(2, subchannel +
                   NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, dwCombineFactor);
    vpp.pPusher->adjust(3);

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, dwOppositeFieldOffset & ~0x1);
    vpp.pPusher->push(3, subchannel | NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(4, dwDstOffset);
    vpp.pPusher->adjust(5);

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, dwMergeSize);
    vpp.pPusher->push(3, subchannel | NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    vpp.pPusher->push(4, dwSrcPitch << 16);
    vpp.pPusher->push(5, dwSrcPitch << 16);
    vpp.pPusher->adjust(6);

    vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                        (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                        (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                        (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                        (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                        (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                        (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                        (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
    vpp.pPusher->push(0, subchannel | NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
    vpp.pPusher->push(1, vertexSizeContext); \
    vpp.pPusher->push(2, subchannel | NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
    vpp.pPusher->push(3, 0); \
    vpp.pPusher->push(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                  (12 << 8) | \
                  (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(5, 0); \
    vpp.pPusher->push(6, (12 << 8) | \
                  (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(7, 0); \
    vpp.pPusher->push(8, (12 << 8) | \
                  (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(9, 4); \
    vpp.pPusher->push(10, (12 << 8) | \
                  (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(11, 8); \
    vpp.pPusher->push(12, (12 << 8) | \
                   (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                    NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(13, 0); \
    vpp.pPusher->push(14, (12 << 8) | \
                   (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(15, 0); \
    vpp.pPusher->push(16, (12 << 8) | \
                   (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(17, 0); \
    vpp.pPusher->push(18, (12 << 8) | \
                   (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->adjust(19); \

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    if (dwFlags & VPP_ODD) {
        dwOppositeYOffset = +1;
        dwCurrYOffset     = -1;
        dwDestYOffset     = -1;
    } else {
        dwOppositeYOffset = -1;
        dwCurrYOffset     = +1;
        dwDestYOffset     = +1;
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV056_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV056_INLINE_ARRAY(0) | 0x300000);

    vpp.pPusher->push(3, (dwOppositeYOffset << 16) | 0);   // opposite field
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current field
    vpp.pPusher->push(5, (dwDestYOffset << 16) | 0);   // destination

    vpp.pPusher->push(6, ((dwHeight+dwOppositeYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwDestYOffset) << 16) | 0);

    vpp.pPusher->push(9,  ((dwHeight+dwOppositeYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11, ((dwHeight+dwDestYOffset) << 16) | dwWidth);

    vpp.pPusher->push(12, (+dwOppositeYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hDFilter3); // TBD: need de-interlace notifier ptr

    vpp.pPusher->push(0, subchannel | NV056_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV056_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);
    return TRUE;
}


//---------------------------------------------------------------------------
// vppNv20Temporal
//      Temporal filter for NV20.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL BOOL vppNv20Temporal(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo,
                     DWORD dwSrcOffset, DWORD dwSrcPitch,
                     DWORD dwDstOffset, DWORD dwDstPitch,
                     DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
                     LPDWORD pPrevFrameOffset)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    BOOL isPrevFieldOdd;
    int dwPrevYOffset, dwCurrYOffset, dwDestYOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert(vpp.dwFlags & VPP_FLAG_KELVIN_3D);

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);
    isPrevFieldOdd = (*pPrevFrameOffset & 0x1);

    dwCombineFactor = (vpp.regOverlayMode >> 8) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    if (isField) {
        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwSrcOffset += dwSrcPitch;
                dwDstOffset += dwDstPitch;
            }
            dwSrcPitch <<= 1;
            dwDstPitch <<= 1;
            dwHeight >>= 1;
        }
    }

    if (!(vpp.regOverlayMode & NV4_REG_OVL_MODE_NOTFIRST)) {
        // if first frame
        vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        if (isOddField) {
            // remember field polarity of previous frame
            *pPrevFrameOffset = dwSrcOffset | 0x1;
        } else {
            *pPrevFrameOffset = dwSrcOffset;
        }
        return FALSE;
    }

    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitKelvin(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));
    vpp.pPusher->push(2, subchannel | NV097_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, subchannel | NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    vpp.pPusher->push(3, dwCombineFactor);
    vpp.pPusher->adjust(4);

    // Make sure offset is 128-byte aligned (in debug builds)
    nvAssert(!((dwSrcOffset % 128) || (*pPrevFrameOffset & ~0x1) % 128));

    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    vpp.pPusher->push(3, *pPrevFrameOffset & ~0x1);
    vpp.pPusher->push(4, subchannel | NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(5, dwDstOffset);
    vpp.pPusher->adjust(6);

    if (isOddField) {
        // remember field polarity of previous frame
        *pPrevFrameOffset = dwSrcOffset | 0x1;
    } else {
        *pPrevFrameOffset = dwSrcOffset;
    }

    // IMPORTANT: Even if we are not using texture units 2 and 3, we need to give
    // them some kind of value other than zero in the following commands.
    // Without these, the hardware will behave incorrectly, probably exhibiting
    // a problem that looks like an invalid surface pitch.
    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    vpp.pPusher->push(3, dwMergeSize);
    vpp.pPusher->push(4, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    vpp.pPusher->push(5, 8 << 16 | 8);
    vpp.pPusher->push(6, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    vpp.pPusher->push(7, 8 << 16 | 8);
    vpp.pPusher->push(8, subchannel | NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    vpp.pPusher->push(9, dwSrcPitch << 16);
    vpp.pPusher->push(10, subchannel | NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    vpp.pPusher->push(11, dwSrcPitch << 16);
    vpp.pPusher->push(12, subchannel | NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    vpp.pPusher->push(13, 8 << 16 | 8);
    vpp.pPusher->push(14, subchannel | NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    vpp.pPusher->push(15, 8 << 16 | 8);
    vpp.pPusher->adjust(16);

    // Inspired by BMAC's SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE macro.
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000);
    vpp.pPusher->push(1, 0);
    vpp.pPusher->push(2, 0);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->push(4, 0);
    vpp.pPusher->push(5, 0);
    vpp.pPusher->push(6, 0);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->push(8, 0);
    vpp.pPusher->push(9, 0);
    vpp.pPusher->push(10, 4);
    vpp.pPusher->push(11, 8);
    vpp.pPusher->push(12, 0);
    vpp.pPusher->push(13, 0);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000);
    vpp.pPusher->push(15, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(16, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(17, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(18, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(19, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(20, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(21, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(22, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(23, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(24, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(25, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(26, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(27, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->adjust(28);

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    // PG - Modified 11/07/2000
    // I temporarily disabled the offsets to counter
    // the misalignment of the fields in the next few lines
    if (isField) {
        if (isOddField != isPrevFieldOdd) {
            // current field as opposite polarity as previous field
            if (dwFlags & VPP_ODD) {
                dwPrevYOffset = +1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                dwPrevYOffset = -1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        } else {
            // current field as identical polarity as previous field
            if (dwFlags & VPP_ODD) {
                // odd-odd
                dwPrevYOffset = -1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                // even-even
                dwPrevYOffset = +1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        }

    } else {    // weave
        dwPrevYOffset = 0;
        dwCurrYOffset = 0;
        dwDestYOffset = 0;
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV097_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV097_INLINE_ARRAY | 0x40300000);

    vpp.pPusher->push(3, (dwDestYOffset << 16) | 0);   // destination
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current frame
    vpp.pPusher->push(5, (dwPrevYOffset << 16) | 0);   // previous frame
    
    vpp.pPusher->push(6, ((dwHeight+dwDestYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwPrevYOffset) << 16) | 0);
    
    vpp.pPusher->push(9, ((dwHeight+dwDestYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11,  ((dwHeight+dwPrevYOffset) << 16) | dwWidth);
    
    vpp.pPusher->push(12, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwPrevYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hTFilter3);  // TBD: need temporal filter notifier ptr

    vpp.pPusher->push(0, subchannel | NV097_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV097_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppNv10Temporal
//      Temporal filter for NV10.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL BOOL vppNv10Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                     DWORD dwSrcOffset, DWORD dwSrcPitch,
                     DWORD dwDstOffset, DWORD dwDstPitch,
                     DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
                     LPDWORD pPrevFrameOffset)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    unsigned long vertexSizeContext;
    BOOL isPrevFieldOdd;
    int dwPrevYOffset, dwCurrYOffset, dwDestYOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert (NVARCH >= 0x10);

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);
    isPrevFieldOdd = (*pPrevFrameOffset & 0x1);

    dwCombineFactor = (vpp.regOverlayMode >> 8) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    if (isField) {
        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwSrcOffset += dwSrcPitch;
                dwDstOffset += dwDstPitch;
            }
            dwSrcPitch <<= 1;
            dwDstPitch <<= 1;
            dwHeight >>= 1;
        }
    }

    if (!(vpp.regOverlayMode & NV4_REG_OVL_MODE_NOTFIRST)) {
        // if first frame
        vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        if (isOddField) {
            // remember field polarity of previous frame
            *pPrevFrameOffset = dwSrcOffset | 0x1;
        } else {
            *pPrevFrameOffset = dwSrcOffset;
        }
        return FALSE;
    }


    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitCelsius(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));

    vpp.pPusher->push(2, subchannel +
                   NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, dwCombineFactor);
    vpp.pPusher->adjust(3);

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, *pPrevFrameOffset & ~0x1);
    vpp.pPusher->push(3, subchannel | NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(4, dwDstOffset);
    vpp.pPusher->adjust(5);
    if (isOddField) {
        // remember field polarity of previous frame
        *pPrevFrameOffset = dwSrcOffset | 0x1;
    } else {
        *pPrevFrameOffset = dwSrcOffset;
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, dwMergeSize);

    vpp.pPusher->push(3, subchannel | NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    vpp.pPusher->push(4, dwSrcPitch << 16);
    vpp.pPusher->push(5, dwSrcPitch << 16);
    vpp.pPusher->adjust(6);

    vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                        (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                        (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                        (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                        (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                        (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                        (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                        (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
    vpp.pPusher->push(0, subchannel | NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
    vpp.pPusher->push(1, vertexSizeContext); \
    vpp.pPusher->push(2, subchannel | NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
    vpp.pPusher->push(3, 0); \
    vpp.pPusher->push(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                  (12 << 8) | \
                  (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(5, 0); \
    vpp.pPusher->push(6, (12 << 8) | \
                  (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(7, 0); \
    vpp.pPusher->push(8, (12 << 8) | \
                  (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(9, 4); \
    vpp.pPusher->push(10, (12 << 8) | \
                  (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(11, 8); \
    vpp.pPusher->push(12, (12 << 8) | \
                   (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                    NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(13, 0); \
    vpp.pPusher->push(14, (12 << 8) | \
                   (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(15, 0); \
    vpp.pPusher->push(16, (12 << 8) | \
                   (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(17, 0); \
    vpp.pPusher->push(18, (12 << 8) | \
                   (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->adjust(19); \

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    if (isField) {
        if (isOddField != isPrevFieldOdd) {
            // current field as opposite polarity as previous field
            if (dwFlags & VPP_ODD) {
                dwPrevYOffset = +1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                dwPrevYOffset = -1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        } else {
            // current field as identical polarity as previous field
            if (dwFlags & VPP_ODD) {
                // odd-odd
                dwPrevYOffset = -1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                // even-even
                dwPrevYOffset = +1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        }

    } else {    // weave
        dwPrevYOffset = 0;
        dwCurrYOffset = 0;
        dwDestYOffset = 0;
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV056_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV056_INLINE_ARRAY(0) | 0x300000);

    vpp.pPusher->push(3, (dwPrevYOffset << 16) | 0);   // previous frame
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current frame
    vpp.pPusher->push(5, (dwDestYOffset << 16) | 0);   // destination

    vpp.pPusher->push(6, ((dwHeight+dwPrevYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwDestYOffset) << 16) | 0);

    vpp.pPusher->push(9,  ((dwHeight+dwPrevYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11, ((dwHeight+dwDestYOffset) << 16) | dwWidth);

    vpp.pPusher->push(12, (+dwPrevYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hTFilter3);  // TBD: need temporal filter notifier ptr

    vpp.pPusher->push(0, subchannel | NV056_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV056_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);
    return TRUE;
}

//---------------------------------------------------------------------------
// vppNv5Temporal
//      Temporal filter for NV5.  Surface dimensions must be a power of 2.
//      Previous frame must be swizzled.
LOCAL BOOL vppNv5Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                    DWORD dwSrcOffset, DWORD dwSrcPitch,
                    DWORD dwDstOffset, DWORD dwDstPitch,
                    DWORD dwWidth, DWORD dwHeight,
                    LPDWORD pPrevFrameOffset)
{
    DWORD dwLogWidth, dwLogHeight, dwPixWidth, dwLineHeight;
    DWORD dwOffsetA, dwOffsetB;
    NvF32 fWidth, fHeight, fU, fV;
    DWORD dwMergeSize;
    DWORD dwCombineFactor;
    Vpp_t &vpp = *pVpp;
    const NvU32 subchannel = SUB_CHANNEL(vpp.spareSubCh);

    // we shouldn't have a celsius or kelvin class if we're here
    nvAssert(!(vpp.dwFlags & (VPP_FLAG_KELVIN_3D | VPP_FLAG_CELSIUS_3D)));

    dwPixWidth = dwSrcPitch >> 2;
    if (dwPixWidth > 4096)      dwLogWidth = 13;
    else if (dwPixWidth > 2048) dwLogWidth = 12;
    else if (dwPixWidth > 1024) dwLogWidth = 11;
    else if (dwPixWidth > 512)  dwLogWidth = 10;
    else if (dwPixWidth > 256)  dwLogWidth = 9;
    else if (dwPixWidth > 128)  dwLogWidth = 8;
    else if (dwPixWidth > 64)   dwLogWidth = 7;
    else if (dwPixWidth > 32)   dwLogWidth = 6;
    else                        dwLogWidth = 5;

    if (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) {
        dwLineHeight = max(dwHeight, vpp.dwOverlayDstHeight);
    } else {
        dwLineHeight = dwHeight;
    }
    if (dwLineHeight > 4096)      dwLogHeight = 13;
    else if (dwLineHeight > 2048) dwLogHeight = 12;
    else if (dwLineHeight > 1024) dwLogHeight = 11;
    else if (dwLineHeight > 512)  dwLogHeight = 10;
    else if (dwLineHeight > 256)  dwLogHeight = 9;
    else if (dwLineHeight > 128)  dwLogHeight = 8;
    else if (dwLineHeight > 64)   dwLogHeight = 7;
    else if (dwLineHeight > 32)   dwLogHeight = 6;
    else if (dwLineHeight > 16)   dwLogHeight = 5;
    else if (dwLineHeight > 8)    dwLogHeight = 4;
    else if (dwLineHeight > 4)    dwLogHeight = 3;
    else if (dwLineHeight > 2)    dwLogHeight = 2;
    else                          dwLogHeight = 1;

//    _asm {emms};
    fWidth  = (NvF32) (dwWidth >> 1);
    fHeight = (NvF32) dwLineHeight;
    fU = fWidth  / (1 << dwLogWidth);
    fV = fHeight / (1 << dwLogHeight);

    dwCombineFactor = (vpp.regOverlayMode >> 8) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    dwMergeSize = (dwLineHeight << 16) | (dwWidth >> 1);

    // swizzle (used in next pass)
    vpp.pPusher->push(0, subchannel | 0x40000);
    vpp.pPusher->push(1, vpp.hContextSurfaceSwizzled);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV052_SET_FORMAT | 0x80000);
    vpp.pPusher->push(3, NV052_SET_FORMAT_COLOR_LE_A8R8G8B8 |  // SetFormat
                  (dwLogWidth << 16) |
                  (dwLogHeight << 24));
    vpp.pPusher->push(4, dwDstOffset);                         // SetOffset
    vpp.pPusher->adjust(5);

    vpp.pPusher->push(0, subchannel | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[SWIZZLE_NDX].classIID);
    vpp.pPusher->push(2, subchannel | NV077_CLIP_POINT | 0x180000);
    vpp.pPusher->push(3, 0);                               // ClipPoint
    vpp.pPusher->push(4, dwMergeSize);                     // ClipSize
    vpp.pPusher->push(5, 0);                               // ImageOutPoint
    vpp.pPusher->push(6, dwMergeSize);                     // ImageOutSize
    vpp.pPusher->push(7, 1 << 20);                         // DeltaDuDx
    vpp.pPusher->push(8, 1 << 20);                         // DeltaDvDy
    vpp.pPusher->push(9, subchannel | NV077_IMAGE_IN_SIZE | 0x100000);
    vpp.pPusher->push(10, (dwMergeSize + 1) & ~1);         // ImageInSize
    vpp.pPusher->push(11, (dwSrcPitch) |                   // ImageInFormat
                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                   (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24));
    vpp.pPusher->push(12, dwSrcOffset);                    // ImageInOffset
    vpp.pPusher->push(13, 0);                              // ImageInPoint
    vpp.pPusher->adjust(14);
    vpp.pPusher->start(TRUE);

    // offset A is current frame multiplied by factor
    // offset B is previous frame swizzled
    dwOffsetA = dwSrcOffset;
    dwOffsetB = *pPrevFrameOffset;
    *pPrevFrameOffset = dwDstOffset;

    // only do this part if this is not the first frame
    if (vpp.regOverlayMode & NV4_REG_OVL_MODE_NOTFIRST) {
        DWORD i;
        Tlmtvertex vertex[4] = {
            { 0.0f,   0.0f,    0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, 0.0f, 0.0f, 0.0f, 0.0f},
            { 0.0f,   fHeight, 0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, 0.0f, fV,   0.0f, fV},
            { fWidth, 0.0f,    0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, fU,   0.0f, fU,   0.0f},
            { fWidth, fHeight, 0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, fU,   fV,   fU,   fV}
        };

        // multiply current frame with factor, in place
        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hContextBeta4);
        vpp.pPusher->push(2, subchannel | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, dwCombineFactor);

        vpp.pPusher->push(4, subchannel | 0x40000);
        vpp.pPusher->push(5, vpp.hSurfaces2D);
        vpp.pPusher->push(6, subchannel | SURFACES_2D_PITCH_OFFSET | 0xC0000);
        vpp.pPusher->push(7, (dwSrcPitch << 16) | dwSrcPitch);     // set pitch
        vpp.pPusher->push(8, dwSrcOffset);                         // set offset source
        vpp.pPusher->push(9, dwSrcOffset);                         // set offset destin
        vpp.pDriverData->bltData.dwLastCombinedPitch = (dwSrcPitch << 16) | dwSrcPitch;
        vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
        vpp.pDriverData->bltData.dwLastDstOffset = dwSrcOffset;

        vpp.pPusher->push(10, subchannel | 0x40000);
        vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
        vpp.pPusher->push(12, subchannel | BLIT_POINT_IN_OFFSET | 0xC0000);
        vpp.pPusher->push(13, 0);                                  // control point in
        vpp.pPusher->push(14, 0);                                  // control point out
        vpp.pPusher->push(15, dwMergeSize);                        // size
        vpp.pPusher->adjust(16);
        vpp.pPusher->start(TRUE);

        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hContextSurfacesARGB_ZS);
        vpp.pPusher->push(2, subchannel | NV053_SET_FORMAT | 0x80000);
        vpp.pPusher->push(3, NV053_SET_FORMAT_COLOR_LE_A8R8G8B8 |          // SetFormat
                     (NV053_SET_FORMAT_TYPE_PITCH << 8) |
                     (dwLogWidth << 16) |
                     (dwLogHeight << 24));
        vpp.pPusher->push(4, dwMergeSize);                                 // SetClipSize
        vpp.pPusher->push(5, subchannel | NV053_SET_PITCH | 0x80000);
        vpp.pPusher->push(6, ((dwSrcPitch) << 16) | (dwSrcPitch));         // SetPitch
        vpp.pPusher->push(7, dwSrcOffset);                                 // SetOffsetColor
        vpp.pPusher->adjust(8);

        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hDX6MultiTextureTriangle);
        vpp.pPusher->push(2, subchannel | NV055_SET_CONTEXT_DMA_NOTIFIES | 0x100000);
        vpp.pPusher->push(3, vpp.hMiscEventNotifier);     // SetContextDmaNotifies
        vpp.pPusher->push(4, vpp.hInVideoMemContextDma);       // SetContextDmaA
        vpp.pPusher->push(5, vpp.hInVideoMemContextDma);       // SetContextDmaB
        vpp.pPusher->push(6, vpp.hContextSurfacesARGB_ZS);                // SetContextSurfaces
        vpp.pPusher->adjust(7);

        // add current frame with previous frame (multiplied by [1-factor]) in place
        // not using texture unit 0, but need to set everything anyways otherwise RM generates error and doesn't do it
        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hDX6MultiTextureTriangle);
        vpp.pPusher->push(2, subchannel | NV055_OFFSET(0) | 0x200000);
        vpp.pPusher->push(3, dwOffsetA);                                   // Offset(0)
        vpp.pPusher->push(4, dwOffsetB);                                   // Offset(1)
        vpp.pPusher->push(5, NV055_FORMAT_CONTEXT_DMA_A |                  // Format(0)
                      (NV055_FORMAT_ORIGIN_ZOH_CENTER << 4) |
                      (NV055_FORMAT_ORIGIN_FOH_CENTER << 6) |
                      (NV055_FORMAT_COLOR_LE_A8R8G8B8 << 8) |
                      (1 << 12) |
                      (dwLogWidth << 16) |
                      (dwLogHeight << 20) |
                      (NV055_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                      (NV055_FORMAT_WRAPU_FALSE << 27) |
                      (NV055_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                      (NV055_FORMAT_WRAPV_FALSE << 31));
        vpp.pPusher->push(6, NV055_FORMAT_CONTEXT_DMA_B |                  // Format(1)
                      (NV055_FORMAT_ORIGIN_ZOH_CENTER << 4) |
                      (NV055_FORMAT_ORIGIN_FOH_CENTER << 6) |
                      (NV055_FORMAT_COLOR_LE_A8R8G8B8 << 8) |
                      (1 << 12) |
                      (dwLogWidth << 16) |
                      (dwLogHeight << 20) |
                      (NV055_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                      (NV055_FORMAT_WRAPU_FALSE << 27) |
                      (NV055_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                      (NV055_FORMAT_WRAPV_FALSE << 31));
        vpp.pPusher->push(7, (1 << 4) |                                    // Filter(0)
                      (NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE << 15) |
                      (NV055_FILTER_TEXTUREMIN_NEAREST << 24) |
                      (NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE << 27) |
                      (NV055_FILTER_TEXTUREMAG_NEAREST << 28) |
                      (NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE << 31));
        vpp.pPusher->push(8, (1 << 4) |                                    // Filter(1)
                      (NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE << 15) |
                      (NV055_FILTER_TEXTUREMIN_NEAREST << 24) |
                      (NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE << 27) |
                      (NV055_FILTER_TEXTUREMAG_NEAREST << 28) |
                      (NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE << 31));
        vpp.pPusher->push(9, NV055_COMBINE_0_ALPHA_INVERSE_0_NORMAL |      // Combine0Alpha
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO << 2) |
                      (NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL << 8) |
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO << 10) |
                      (NV055_COMBINE_0_ALPHA_INVERSE_2_NORMAL << 16) |
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1 << 18) |
                      (NV055_COMBINE_0_ALPHA_INVERSE_3_INVERSE << 24) |
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO << 26) |
                      (NV055_COMBINE_0_ALPHA_OPERATION_ADD << 29));
        vpp.pPusher->push(10, NV055_COMBINE_0_COLOR_INVERSE_0_NORMAL |     // Combine0Color
                       (NV055_COMBINE_0_COLOR_ALPHA_0_COLOR << 1) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO << 2) |
                       (NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL << 8) |
                       (NV055_COMBINE_0_COLOR_ALPHA_1_COLOR << 9) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO << 10) |
                       (NV055_COMBINE_0_COLOR_INVERSE_2_NORMAL << 16) |
                       (NV055_COMBINE_0_COLOR_ALPHA_2_COLOR << 17) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1 << 18) |
                       (NV055_COMBINE_0_COLOR_INVERSE_3_INVERSE << 24) |
                       (NV055_COMBINE_0_COLOR_ALPHA_3_COLOR << 25) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO << 26) |
                       (NV055_COMBINE_0_COLOR_OPERATION_ADD << 29));

        vpp.pPusher->push(11, subchannel | NV055_COMBINE_1_ALPHA | 0x200000);
        vpp.pPusher->push(12, NV055_COMBINE_1_ALPHA_INVERSE_0_NORMAL |     // Combine1Alpha
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1 << 2) |
                       (NV055_COMBINE_1_ALPHA_INVERSE_1_INVERSE << 8) |
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR << 10) |
                       (NV055_COMBINE_1_ALPHA_INVERSE_2_NORMAL << 16) |
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO << 18) |
                       (NV055_COMBINE_1_ALPHA_INVERSE_3_NORMAL << 24) |
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO << 26) |
                       (NV055_COMBINE_1_ALPHA_OPERATION_ADD << 29));
        vpp.pPusher->push(13, NV055_COMBINE_1_COLOR_INVERSE_0_NORMAL |     // Combine1Color
                       (NV055_COMBINE_1_COLOR_ALPHA_0_COLOR << 1) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1 << 2) |
                       (NV055_COMBINE_1_COLOR_INVERSE_1_INVERSE << 8) |
                       (NV055_COMBINE_1_COLOR_ALPHA_1_COLOR << 9) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR << 10) |
                       (NV055_COMBINE_1_COLOR_INVERSE_2_NORMAL << 16) |
                       (NV055_COMBINE_1_COLOR_ALPHA_2_COLOR << 17) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO << 18) |
                       (NV055_COMBINE_1_COLOR_INVERSE_3_NORMAL << 24) |
                       (NV055_COMBINE_1_COLOR_ALPHA_3_COLOR << 25) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO << 26) |
                       (NV055_COMBINE_1_COLOR_OPERATION_ADD << 29));
        vpp.pPusher->push(14, dwCombineFactor);                            // CombineFactor
        vpp.pPusher->push(15, NV055_BLEND_MASK_BIT_LSB |                   // Blend
                       (NV055_BLEND_SHADEMODE_FLAT << 6) |
                       (NV055_BLEND_TEXTUREPERSPECTIVE_FALSE << 8) |
                       (NV055_BLEND_SPECULARENABLE_FALSE << 12) |
                       (NV055_BLEND_FOGENABLE_FALSE << 16) |
                       (NV055_BLEND_ALPHABLENDENABLE_TRUE << 20) |
                       (NV055_BLEND_SRCBLEND_ONE << 24) |
                       (NV055_BLEND_DESTBLEND_ONE << 28));
        vpp.pPusher->push(16, (NV055_CONTROL0_ALPHAFUNC_ALWAYS << 8) |     // Control0
                       (NV055_CONTROL0_ALPHATESTENABLE_FALSE << 12) |
                       (NV055_CONTROL0_ORIGIN_CENTER << 13) |
                       (NV055_CONTROL0_ZENABLE_FALSE << 14) |
                       (NV055_CONTROL0_ZFUNC_ALWAYS << 16) |
                       (NV055_CONTROL0_CULLMODE_NONE << 20) |
                       (NV055_CONTROL0_DITHERENABLE_FALSE << 22) |
                       (NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 23) |
                       (NV055_CONTROL0_ZWRITEENABLE_FALSE << 24) |
                       (NV055_CONTROL0_STENCIL_WRITE_ENABLE_FALSE << 25) |
                       (NV055_CONTROL0_ALPHA_WRITE_ENABLE_TRUE << 26) |
                       (NV055_CONTROL0_RED_WRITE_ENABLE_TRUE << 27) |
                       (NV055_CONTROL0_GREEN_WRITE_ENABLE_TRUE << 28) |
                       (NV055_CONTROL0_BLUE_WRITE_ENABLE_TRUE << 29) |
                       (NV055_CONTROL0_Z_FORMAT_FLOAT << 30));
        vpp.pPusher->push(17, NV055_CONTROL1_STENCIL_TEST_ENABLE_FALSE |   // Control1
                       (NV055_CONTROL1_STENCIL_FUNC_NEVER << 4));
        vpp.pPusher->push(18, NV055_CONTROL2_STENCIL_OP_FAIL_KEEP |        // Control2
                       (NV055_CONTROL2_STENCIL_OP_ZFAIL_KEEP << 4) |
                       (NV055_CONTROL2_STENCIL_OP_ZPASS_KEEP << 8));
        vpp.pPusher->push(19, 0);                                          // FogColor

        vpp.pPusher->push(20, subchannel | NV055_TLMTVERTEX(0) | 0xa00000);
        for (i=0; i<40; i++) {
            vpp.pPusher->push(21+i, ((DWORD *)(&vertex[0]))[i]);
        }
        vpp.pPusher->adjust(61);
        vpp.pPusher->start(TRUE);

        VppResetNotification(NULL, lpProcInfo->hTFilter3);  // TBD: need temporal filter notifier ptr

        vpp.pPusher->push(0, subchannel | NV055_NOTIFY | 0x40000);
        vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
        vpp.pPusher->push(2, subchannel | NV055_DRAW_PRIMITIVE(0) | 0x40000);
        vpp.pPusher->push(3, 0 | (1 << 4) | (2 << 8) | (1 << 12) | (2 << 16) | (3 << 20));
        vpp.pPusher->adjust(4);
        vpp.pPusher->start(TRUE);

        vpp.pDriverData->dDrawSpareSubchannelObject = 0;
        vpp.pDriverData->TwoDRenderingOccurred = 1;
    } else {
        // this was the first frame, next time it won't be
        vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
// vppFlip
//      Flip to surface.  Use the PIO channel in case we do a raw flip with
//      a bunch of 3D going on.
//
LOCAL BOOL vppFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
             DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight,
             DWORD dwIndex, DWORD dwFourCC, DWORD dwFlags,
             DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY)
{
    DWORD dwPointIn, dwSizeIn, dwOverlayFormat;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwDstX, dwDstY, dwDstWidth, dwDstHeight;
    BOOL doYBiasing;
    Vpp_t &vpp = *pVpp;

    // Remember this in case we get a SetOverlayPosition call
    vpp.dwOverlaySrcOffset = dwOffset;
    vpp.dwOverlaySrcPitch = dwPitch;

    dwDeltaX    = vpp.dwOverlayDeltaX;
    dwDeltaY    = vpp.dwOverlayDeltaY;
    dwDstX      = vpp.dwOverlayDstX;
    dwDstY      = vpp.dwOverlayDstY;
    dwDstWidth  = vpp.dwOverlayDstWidth;
    dwDstHeight = vpp.dwOverlayDstHeight;

    if (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) {
        // zoom
        DWORD dwSrcX         = (vpp.dwOverlayFSSrcMinX * dwPrescaleFactorX) >> 20;
        DWORD dwSrcY         = (vpp.dwOverlayFSSrcMinY * dwPrescaleFactorY) >> 20;
        DWORD dwSrcWidth     = (vpp.dwOverlayFSSrcWidth * dwPrescaleFactorX) >> 20;
        DWORD dwSrcHeight    = (vpp.dwOverlayFSSrcHeight * dwPrescaleFactorY) >> 20;
        DWORD dwZoomFactor   = 384 - ((vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK) >> 12);
        DWORD dwZoomQuad     = (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) >> 8;
        DWORD dwNewSrcWidth  = dwSrcWidth  * dwZoomFactor / 384;
        DWORD dwNewSrcHeight = dwSrcHeight * dwZoomFactor / 384;

        // get start point
        switch (dwZoomQuad) {
        case 1:  break;
        case 2:  dwSrcX += dwWidth - dwNewSrcWidth;          break;
        case 3:  dwSrcY += dwHeight - dwNewSrcHeight;        break;
        case 4:  dwSrcX += dwWidth - dwNewSrcWidth;
                 dwSrcY += dwHeight - dwNewSrcHeight;        break;
        case 5:  dwSrcX += (dwWidth - dwNewSrcWidth) >> 1;
                 dwSrcY += (dwHeight - dwNewSrcHeight) >> 1; break;
        default: break;
        }
        dwWidth = dwNewSrcWidth;
        dwHeight = dwNewSrcHeight;

        // if DX clips the source, we need to adjust our new source rectangle to match
        if (vpp.dwOverlaySrcWidth < dwSrcWidth) {
            DWORD xScale = (vpp.dwOverlaySrcWidth << 20) / dwSrcWidth;
            DWORD xRelative = vpp.dwOverlaySrcX - ((vpp.dwOverlayFSSrcMinX * dwPrescaleFactorX) >> 20);
            DWORD xPos   = (xRelative << 20) / dwSrcWidth;
            dwSrcX += (dwWidth * xPos) >> 20;
            dwWidth = (dwWidth * xScale) >> 20;
        }
        if (vpp.dwOverlaySrcHeight < dwSrcHeight) {
            DWORD yScale = (vpp.dwOverlaySrcHeight << 20) / dwSrcHeight;
            DWORD yRelative = vpp.dwOverlaySrcY - ((vpp.dwOverlayFSSrcMinY * dwPrescaleFactorY) >> 20);
            DWORD yPos   = (yRelative << 20) / dwSrcHeight;
            dwSrcY += (dwHeight * yPos) >> 20;
            dwHeight = (dwHeight * yScale) >> 20;
        }

        // calculate new source offset
        dwOffset += (dwSrcY * dwPitch) + (dwSrcX * 2);

        // recompute new scale factors
        dwDeltaX = ((dwWidth - 1) << 20) / (vpp.dwOverlayDstWidth - 1);
        dwDeltaY = ((dwHeight - 1) << 20) / (vpp.dwOverlayDstHeight - 1);
    }

    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;
    dwSizeIn = asmMergeCoords((dwWidth & ~1), dwHeight);
    dwSizeIn += dwPointIn >> 4;
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    // if downscaling in Y, throw in a Y bias of -1/2 pixel
    // don't do this on NV5 class chips because it doesn't properly bias it
    doYBiasing = (dwDeltaY > 0x100000 && vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10);
    if (doYBiasing) {
        dwPointIn -= 0x00080000;
    }

    if (IS_FIELD(dwFlags)) {
        // Set flag to say overlay has been in Bob mode.
        vpp.pDriverData->dwDXVAFlags |= DXVA_OVERLAY_WAS_BOBBED;

        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwOffset += dwPitch;
            }
            dwPitch <<= 1;
            dwHeight >>= 1;
            dwDeltaY = ((dwHeight) << 20) / (vpp.dwOverlayDstHeight);
            dwSizeIn = (dwSizeIn & 0x0000FFFF) | (dwHeight << 16);
        }
        if (dwFlags & VPP_BOB) {
            if (dwFlags & VPP_ODD) {
                if (doYBiasing) {
                    dwPointIn += 0x00040000;
                } else {
                    dwPointIn += 0xFFFC0000;
                }
            } else {
                if (doYBiasing) {
                    dwPointIn += 0x000C0000;
                } else {
                    dwPointIn += 0x00040000;
                }
            }
        }
    }

    // replace old surface pitch value with current pitch value
    dwOverlayFormat = vpp.dwOverlayFormat;
    dwOverlayFormat &= 0xFFFF0000;
    dwOverlayFormat |= dwPitch;
    dwOverlayFormat |= (VPP_NOTIFY_TYPE << 31);

    // reset notifiers
    //   Must clear notifier status even if we're using events.
    if (dwIndex & 0x1) {
        VppResetNotification(&vpp.m_obj_a[OVERLAY_NDX].notifier_a[2], lpProcInfo->hOvlFlipOddEvent3);
        vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status = NV_IN_PROGRESS;
    } else {
        VppResetNotification(&vpp.m_obj_a[OVERLAY_NDX].notifier_a[1], lpProcInfo->hOvlFlipEvenEvent3);
        vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status = NV_IN_PROGRESS;
    }

    // frame delivery control
    if (vpp.llDeliveryPeriod != 0)
    {
        VppResetNotification(vpp.m_obj_a[TIMER_NDX].notifier_a, lpProcInfo->hTimer3);
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.m_obj_a[TIMER_NDX].classIID);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME | 0x80000);
        vpp.pPusher->push(3, (DWORD)(vpp.llDeliveryTime & 0x00000000FFFFFFFF));
        vpp.pPusher->push(4, (DWORD)(vpp.llDeliveryTime >> 32));
        vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
        vpp.pPusher->push(6, VPP_NOTIFY_TYPE);
        vpp.pPusher->adjust(7);
        vpp.pPusher->start(TRUE);
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[TIMER_NDX].classIID;
        vpp.llDeliveryTime += vpp.llDeliveryPeriod;
        if (VppWaitForNotification(NULL, lpProcInfo->hTimer3, VPP_TIMEOUT_TIME * 4)) {
            DPF(" *** TIMER event failure ***");
            EVENT_ERROR;
        }
    }

    // HWFIX: NV20 overlay bug, if scale factor >= 0.5 && XPointIn >= 9.4375 then this must be FALSE:
    //        ((XSizeIn - 2) & 0x8) == 0x8
    // This code must not go through on NV < 20
    if ((vpp.pDriverData->NvDeviceVersion > NV_DEVICE_VERSION_10) &&
     ((((dwSizeIn & 0x0000FFFF) - 2) >> 3) & 0x1) &&
       ((dwPointIn & 0x0000FFFF) >= 0x97)) {
        // muck with source width so HWBUG does not happen
        dwSizeIn = (dwSizeIn & 0xFFFF0000) | ((dwSizeIn & 0x0000FFFF) + 8);
        // now muck with dwDeltaX so we don't see 1/2 pixel of crap on the right edge
        dwDeltaX -= (1 << 20) / ((dwSizeIn & 0xFFFF) * 3 / 2);  // should accumulate to 2/3 pixel over the span of the source
    }

    // do the overlay flip
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[OVERLAY_NDX].classIID);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_OVERLAY_COLORKEY(dwIndex) | 0x240000);
    vpp.pPusher->push(3, vpp.dwOverlayColorKey);                    // SetOverlayColorKey
    vpp.pPusher->push(4, dwOffset);                                        // SetOverlayOffset
    vpp.pPusher->push(5, dwSizeIn);                                        // SetOverlaySizeIn
    vpp.pPusher->push(6, dwPointIn);                                       // SetOverlayPointIn
    vpp.pPusher->push(7, dwDeltaX);                                        // SetOverlayDuDx
    vpp.pPusher->push(8, dwDeltaY);                                        // SetOverlayDvDy
    vpp.pPusher->push(9, asmMergeCoords(dwDstX, dwDstY));                  // SetOverlayPointOut
    vpp.pPusher->push(10, asmMergeCoords(dwDstWidth, dwDstHeight));        // SetOverlaySizeOut
    vpp.pPusher->push(11, dwOverlayFormat);                                // SetOverlayFormat
    vpp.pPusher->adjust(12);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[OVERLAY_NDX].classIID;

    return TRUE;
}

//---------------------------------------------------------------------------
// vppFSFlip
//      Flip full screen mirrored adapter
LOCAL BOOL vppFSFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex)
{
    DWORD dwDAC, dwLUTFormat;
    Vpp_t &vpp = *pVpp;

#ifndef WINNT
    if (pVpp->dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX == 0) {
        // ack! user has suddenly switched from clone mode to multimon
//        Sleep(VPP_TIMEOUT_TIME * 3);                // make sure all flips are flushed
        VppDestroyFSMirror(pVpp);
//        VppDestroyOverlay(pVpp);

        ResetTwinViewState (vpp.pDriverData);

        // special flag to indicate new display driver coming up
        pVpp->dwOverlayFSHead = 0xFFFFFFFE;

        // turn off mode setting bit to minimize impact of turning on FSmirror in the middle of a TwinView change
        vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSSETMODE;
        return TRUE;

//        VppCreateOverlay(pVpp);
//        VppCreateFSMirror(pVpp, pDriverData->dwOverlayFSSrcWidth, pDriverData->dwOverlayFSSrcHeight);
    }
#endif

    if (vpp.dwOverlayFSHead == 0) {
        dwDAC = vpp.hLutCursorDacBase;
        if (dwIndex & 0x1) {
            VppResetNotification(NULL, lpProcInfo->hPrimary0FlipOdd3);
            vpp.pFlipPrimaryNotifier[2].status = NV_IN_PROGRESS;
        } else {
            VppResetNotification(NULL, lpProcInfo->hPrimary0FlipEven3);
            vpp.pFlipPrimaryNotifier[1].status = NV_IN_PROGRESS;
        }
    } else {
        dwDAC = vpp.hLutCursorDacBase + 1;
        if (dwIndex & 0x1) {
            VppResetNotification(NULL, lpProcInfo->hPrimary1FlipOdd3);
            vpp.pFlipPrimaryNotifier[2].status = NV_IN_PROGRESS;
        } else {
            VppResetNotification(NULL, lpProcInfo->hPrimary1FlipEven3);
            vpp.pFlipPrimaryNotifier[1].status = NV_IN_PROGRESS;
        }
    }

    dwLUTFormat = vpp.dwOverlayFSPitch |
                 (VPP_NOTIFY_TYPE << 31) |
                 (NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, dwDAC);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV067_SET_IMAGE_OFFSET(dwIndex) | 0x80000);
    vpp.pPusher->push(3, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex]);   // SetImage[i].offset
    vpp.pPusher->push(4, dwLUTFormat);                                                     // SetImage[i].format
    vpp.pPusher->adjust(5);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = dwDAC;

    return TRUE;
}


//---------------------------------------------------------------------------
// vppSetSurfacesState
//      Sets the pixel format on all the surfaces we will use for video
//      post processing

LOCAL void vppSetSurfacesState(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    vpp.pDriverData->dwSharedClipChangeCount++;

    // set surfaces state

    // SURFACES_3D
    if (!(vpp.dwFlags & (VPP_FLAG_CELSIUS_3D | VPP_FLAG_KELVIN_3D))) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextSurfacesARGB_ZS);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV053_SET_FORMAT | 0x80000);
        vpp.pPusher->push(3, NV053_SET_FORMAT_COLOR_LE_A8R8G8B8 |      // SetFormat
                     (NV053_SET_FORMAT_TYPE_PITCH << 8) |
                     (9 << 16) |
                     (10 << 24));
        vpp.pPusher->push(4, (2048 << 16) | 512);                      // SetClipSize
        vpp.pPusher->adjust(5);
    }

    // SURFACES_2D
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hSurfaces2D);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
    vpp.pPusher->push(3, NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);      // SetColorFormat

    // SURFACE_SWIZZLED
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(5, vpp.hContextSurfaceSwizzled);
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | NV052_SET_FORMAT | 0x40000);
    vpp.pPusher->push(7, NV052_SET_FORMAT_COLOR_LE_A8R8G8B8 |     // SetFormat
                 (9 << 16) |
                 (10 << 24));

    vpp.pPusher->adjust(8);

    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextSurfaceSwizzled;
    vpp.pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
    vpp.pDriverData->TwoDRenderingOccurred = TRUE;
}

//---------------------------------------------------------------------------
// vppRestoreSurfacesState
//      Restores surfaces to default state.  Swizzled surface state is not
//      restored, D3D sets it before using it all the time

LOCAL void vppRestoreSurfacesState(Vpp_t *pVpp)
{
    DWORD dw2dFormat;
    Vpp_t &vpp = *pVpp;

    // restore surfaces2d
    switch (GET_MODE_BPP()) {
    case 8:
        dw2dFormat = NV062_SET_COLOR_FORMAT_LE_Y8;
        break;
    case 32:
        dw2dFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
        break;
    default:
        dw2dFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;
        break;
    }
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
    vpp.pPusher->push(1, dw2dFormat);
    vpp.pPusher->adjust(2);

    vpp.pDriverData->bltData.dwLastColourFormat = dw2dFormat;

    vpp.pPusher->start(TRUE);
}

//---------------------------------------------------------------------------
// vppFlipSync
//      Flushes out overlay flips.  Returns true if succeeded

LOCAL BOOL vppFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait)
{
    HDRVEVENT hEvent;
    __int64 timeNow = 0x7FFFFFFFFFFFFFFF;
    static DWORD dwRetryCount = 0;
    Vpp_t &vpp = *pVpp;

    if (dwIndex) {
        hEvent = lpProcInfo->hOvlFlipOddEvent3;
    } else {
        hEvent = lpProcInfo->hOvlFlipEvenEvent3;
    }

    if (bWait) {
        // if (IS_EVENT_ERROR(WaitForSingleObject(hEvent, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(&(vpp.m_obj_a[OVERLAY_NDX].notifier_a[dwIndex+1]), hEvent, VPP_TIMEOUT_TIME)) {
            // NV11 mobile workaround, sometimes overlay flips are getting lost for unknown reasons
            // check to see if enough time has passed to guarantee this flip has flushed out
            static DWORD dwRetryCount = 0;
            if (dwRetryCount == 0) {
                nvQueryPerformanceCounter(&timeNow);
                if ((timeNow - vpp.pDriverData->flipOverlayRecord.llPreviousFlipTime) >= (vpp.pDriverData->flipPrimaryRecord.dwFlipDuration * 4)) {
                    dwRetryCount++;
                    return TRUE;
                }
            } else {
                dwRetryCount = 0;
            }
            // otherwise this is a real failure
            DPF(" *** OVERLAY FLIP event failure ***");
            EVENT_ERROR;
            vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status = 0;
            vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status = 0;
        }
    } else {
        if (vpp.m_obj_a[OVERLAY_NDX].notifier_a[dwIndex + 1].status == NV_IN_PROGRESS) {
            // NV11 mobile workaround, sometimes overlay flips are getting lost for unknown reasons
            // check to see if enough time has passed to guarantee this flip has flushed out
            nvQueryPerformanceCounter(&timeNow);
            if ((timeNow - vpp.pDriverData->flipOverlayRecord.llPreviousFlipTime) >= (vpp.pDriverData->flipPrimaryRecord.dwFlipDuration * 4)) {
                return TRUE;
            }
            // otherwise we really haven't flipped yet
            return FALSE;
        }
    }
    return TRUE;
}


//---------------------------------------------------------------------------
// vppFSFlipSync
//      Flushes out overlay flips.  Returns true if succeeded

LOCAL BOOL vppFSFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait)
{
    HDRVEVENT hEvent;
    Vpp_t &vpp = *pVpp;

    if (vpp.dwOverlayFSHead == 0) {
        if (dwIndex) {
            hEvent = lpProcInfo->hPrimary0FlipOdd3;
        } else {
            hEvent = lpProcInfo->hPrimary0FlipEven3;
        }
    } else {
        if (dwIndex) {
            hEvent = lpProcInfo->hPrimary1FlipOdd3;
        } else {
            hEvent = lpProcInfo->hPrimary1FlipEven3;
        }
    }

    if (bWait) {
        // if (IS_EVENT_ERROR(WaitForSingleObject(hEvent, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(&(vpp.pFlipPrimaryNotifier[dwIndex+1]), hEvent, VPP_TIMEOUT_TIME)) {
            DPF(" *** PRIMARY FLIP event failure ***");
            EVENT_ERROR;
            vpp.pFlipPrimaryNotifier[1].status = 0;
            vpp.pFlipPrimaryNotifier[2].status = 0;
        }
    } else {
        if (vpp.pFlipPrimaryNotifier[dwIndex + 1].status == NV_IN_PROGRESS) {
            return FALSE;
        }
    }
    return TRUE;
}


//---------------------------------------------------------------------------
// VppDoFlip
//     Does all the video post processing.  We never know whether the post
//      processing pipe has changed configuration since the last time, so
//      always flip.
//     Requires a source surface and 2 or (usually) 4 work surfaces.  Normal
//      usage leaves the source surface intact (mpeg-2 re-uses them) and
//      operates on each stage of the pipe by leaving the result in the
//      next working surface.  After each stage, the source is made to be
//      the destination of the previous stage.
//     Temporal filtering is special in that it snoops the 2 work surfaces
//      of the previous frame.
#define NEXT_SURFACE { \
            dwSrcOffset = dwDstOffset;  \
            dwSrcPitch = dwDstPitch;    \
            dwDstOffset = dwNextOffset; \
            dwDstPitch = dwNextPitch;   \
            dwNextOffset = dwSrcOffset; \
            dwNextPitch = dwSrcPitch;   \
            dwOpCount++;                \
        }

extern BOOL VppDoFlip(Vpp_t *pVpp,
                   DWORD dwOffset,
                   DWORD dwPitch,
                   DWORD dwWidth,
                   DWORD dwHeight,
                   DWORD dwFourCC,
                   DWORD dwFlags)
{
    DWORD dwSrcOffset, dwSrcPitch;
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwNextOffset, dwNextPitch;
    DWORD dwOpCount;
    DWORD dwWorkSurfaces;
    DWORD dwIndex;
    enum eClassUsed { NV5Class, CelsiusClass, KelvinClass } classUsed;
    BOOL  isYUV9, isYUV12, isYUV422;
    BOOL  doConvert, doSubPicture, doXPreScale, doYPreScale, doPreScale, doCC;
    BOOL  doTemporal, doFSMirror, doDeinterlace = FALSE;
    BOOL  doLateFlipSync, doOvlZoom;
    BOOL  isDownScale;
    LPPROCESSINFO lpProcInfo = NULL;
    DWORD dwRoundX, dwRoundY;
    DWORD vppExec;
    BOOL  isField;
    DWORD dwPrescaleFactorX, dwPrescaleFactorY;
    Vpp_t &vpp = *pVpp;
    HDRVEVENT hLastStage, hLastFSStage;
    NvNotification *pLastStageNotifier, *pLastFSStageNotifier;
    NvU32 processID;

    nvAssert(pVpp);
    nvAssert(vpp.dwFlags & VPP_FLAG_OVERLAY_READY);

    if ((vpp.regVPPInvMask & VPP_MASTER_DISABLE) ||
        (vpp.dwOverlayDstHeight == 0) ||
        (vpp.dwOverlayDstWidth == 0)) {
        return TRUE;
    }

#ifdef VPP_SNOOP
    __int64 qwTime1, qwDelta, qwJitter;
    __int64 qwTime2 = 0;

    vpp.snoop.dwMarker1 = 0x11111111;
    vpp.snoop.qwMarker2 = 0x2222222222222222;

    vpp.snoop.dwLastFlags = dwFlags | 0x80000000;
    nvQueryPerformanceCounter(&qwTime1);
    qwDelta = qwTime1 - vpp.snoop.qwInterFrameTime;
    qwJitter = (qwDelta > vpp.snoop.qwInterFrameDelta) ?
               (qwDelta - vpp.snoop.qwInterFrameDelta) :
               (vpp.snoop.qwInterFrameDelta - qwDelta);
    vpp.snoop.qwInterFrameJitterAcc += qwJitter;
    if (qwJitter > vpp.snoop.qwInterFrameJitterPeak) {
        vpp.snoop.qwInterFrameJitterPeak = qwJitter;
    }
    vpp.snoop.qwInterFrameAcc += qwDelta;
    if (qwDelta > vpp.snoop.qwInterFramePeak) {
        vpp.snoop.qwInterFramePeak = qwDelta;
    }
    vpp.snoop.qwInterFrameDelta = qwDelta;
    vpp.snoop.qwInterFrameTime = qwTime1;
#else   // !VPP_SNOOP
#ifdef DEBUG
    char debugstr[256];
    debugstr[0] = '\0';
    if (dwFlags & VPP_ODD)           nvStrCat (debugstr, "odd  ");
    if (dwFlags & VPP_EVEN)          nvStrCat (debugstr, "even ");
    if (dwFlags & VPP_BOB)           nvStrCat (debugstr, "bob ");
    if (dwFlags & VPP_INTERLEAVED)   nvStrCat (debugstr, "int ");
    if (dwFlags & VPP_VIDEOPORT)     nvStrCat (debugstr, "vp ");
    if (dwFlags & VPP_WAIT)          nvStrCat (debugstr, "wait ");
    if (dwFlags & VPP_OPTIMIZEFLIP)  nvStrCat (debugstr, "opt ");
    nvStrCat (debugstr, "REQ: ");
    if (dwFlags & VPP_CONVERT)       nvStrCat (debugstr, "cvt ");
    if (dwFlags & VPP_SUBPICTURE)    nvStrCat (debugstr, "sp ");
    if (dwFlags & VPP_PRESCALE)      nvStrCat (debugstr, "ps ");
    if (dwFlags & VPP_COLOURCONTROL) nvStrCat (debugstr, "cc ");
    if (dwFlags & VPP_TEMPORAL)      nvStrCat (debugstr, "tf ");
    if (dwFlags & VPP_DEINTERLACE)   nvStrCat (debugstr, "df ");
    if (dwFlags & VPP_FSMIRROR)      nvStrCat (debugstr, "fs ");
#endif  // DEBUG
#endif  // VPP_SNOOP

    dwFlags &= ~(vpp.regVPPInvMask);

    dwIndex = vpp.overlayBufferIndex;

    processID = nvGetCurrentProcessId();

    lpProcInfo = pmGetProcess(vpp.pDriverData, processID);

    // last resort event creation
    if (lpProcInfo == NULL || lpProcInfo->hOvlFlipEvenEvent3 == NULL || lpProcInfo->hOvlFlipOddEvent3 == NULL) {
        pmAddProcess(vpp.pDriverData, processID);
        lpProcInfo = pmGetProcess(vpp.pDriverData, processID);
    }

    // we de-reference the <lpProcInfo> var to get event handles... even when we're not using events
    // so it HAS to point to something!
    nvAssert(lpProcInfo != NULL);
    if (lpProcInfo == NULL)
    {
        return FALSE;
    }

#if (IS_WINNT5 || IS_WIN9X)
    if (dwFourCC == FOURCC_NV12) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;
        DWORD dwNewOffset;

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&(vpp.pDriverData->nvMCSurfaceFlags[0]);

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != (dwOffset + vpp.pDriverData->BaseAddress)))
            lpSurfaceFlags++;

        // NV12 surfaces are preconverted to YUYV, just adjust some parameters
        dwNewOffset = lpSurfaceFlags->dwMCSurface422Offset;

        dwPitch = ((dwWidth + 3) & ~3);
        dwPitch = dwPitch << 1;
        dwPitch = (dwPitch + 127) & ~127;

        if (vpp.pDriverData->bMCOverlaySrcIsSingleField1080i) {
            dwFlags &= ~(VPP_ODD | VPP_EVEN | VPP_INTERLEAVED);
        }

        // Check if we should be displaying the default or the filtered portion of the surface
        if (lpSurfaceFlags->bMCFrameIsFiltered) {
            dwNewOffset += (dwPitch * dwHeight);
        }

        dwOffset = dwNewOffset;
        dwFourCC = FOURCC_YUY2;
    }
#endif

    hLastStage           = NULL;
    hLastFSStage         = NULL;
    pLastStageNotifier   = NULL;
    pLastFSStageNotifier = NULL;

    dwWorkSurfaces = vpp.extraNumSurfaces;
    vppExec = 0;
    dwOpCount = 0;
    dwPrescaleFactorX = 0x100000;
    dwPrescaleFactorY = 0x100000;
    dwSrcOffset = dwOffset;
    dwSrcPitch = dwPitch;
    dwDstOffset = vpp.extraOverlayOffset[vpp.extraIndex];
    dwDstPitch = vpp.extraPitch;
    dwNextOffset = vpp.extraOverlayOffset[vpp.extraIndex + 1];
    dwNextPitch = vpp.extraPitch;

    isYUV9 = (dwFourCC == FOURCC_IF09 ||
              dwFourCC == FOURCC_YVU9 ||
              dwFourCC == FOURCC_IV32 ||
              dwFourCC == FOURCC_IV31);

    isYUV12 = (dwFourCC == FOURCC_YV12 ||
               dwFourCC == FOURCC_420i);

    isYUV422 = (dwFourCC == FOURCC_YUY2 ||
                dwFourCC == FOURCC_UYVY ||
                dwFourCC == FOURCC_YUNV ||
                dwFourCC == FOURCC_UYNV);

    isField = IS_FIELD(dwFlags);

    if (!isYUV9 && !isYUV12 && !isYUV422) {
        return FALSE;
    }

    doConvert = (dwFlags & VPP_CONVERT) &&
                (isYUV9 || isYUV12);

    doSubPicture = (dwFlags & VPP_SUBPICTURE) &&
                   (vpp.subPicture.offset != 0) &&
                 (((vpp.subPicture.pitch & NVS2VF_SP_ODD) && (dwFlags & VPP_ODD)) ||
                  ((vpp.subPicture.pitch & NVS2VF_SP_EVEN) && (dwFlags & VPP_EVEN)) ||
                  ((dwFlags & (VPP_EVEN | VPP_ODD))==0));

    doXPreScale = (vpp.dwOverlaySrcWidth > (vpp.dwOverlayDstWidth * vpp.dwOverlayMaxDownScaleX));
    doYPreScale = (vpp.dwOverlaySrcHeight > (vpp.dwOverlayDstHeight * vpp.dwOverlayMaxDownScaleY));
    if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
        // NV4/5 also prescales:
        //  - all BOBed fields
        //  - vertical upscales when HQVUp is enabled
        doYPreScale = doYPreScale || (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) || isField;
    }

    doPreScale = (dwFlags & VPP_PRESCALE) &&
                 (doXPreScale || doYPreScale);

    isDownScale = FALSE;
    if (doPreScale) {
        DWORD dwSrcHeight, dwSrcArea, dwDstArea;

        dwSrcHeight = vpp.dwOverlaySrcHeight;
        if ((dwFlags & (VPP_ODD | VPP_EVEN)) && (dwFlags & VPP_INTERLEAVED)) {
            // bob mode
            dwSrcHeight >>= 1;
        }
        dwSrcArea = dwSrcHeight * vpp.dwOverlaySrcWidth;
        dwDstArea = vpp.dwOverlayDstHeight * vpp.dwOverlayDstWidth;
        if (dwSrcArea > dwDstArea) {
            isDownScale = TRUE;
        }
    }

    doCC = (dwFlags & VPP_COLOURCONTROL) &&
           (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) &&
           (vpp.fpOverlayShadow) &&
           (vpp.regOverlayColourControlEnable) &&
           (vpp.colorCtrl.lContrast != 0xFF ||
            vpp.colorCtrl.lBrightness != 0 ||
            vpp.colorCtrl.lHue != 0 ||
            vpp.colorCtrl.lSaturation != 0x100);

    doTemporal = (dwFlags & VPP_TEMPORAL) &&
                 (vpp.regOverlayMode & NV4_REG_OVL_MODE_TFILTER);

#if (NVARCH >= 10)
    doDeinterlace = (dwFlags & VPP_DEINTERLACE) && isField &&
                    (vpp.regOverlayMode & NV4_REG_OVL_MODE_DFILTER);
#endif

    if (vpp.dwFlags & VPP_FLAG_KELVIN_3D)
        classUsed = KelvinClass;
    else if (vpp.dwFlags & VPP_FLAG_CELSIUS_3D)
        classUsed = CelsiusClass;
    else
        classUsed = NV5Class;

    doFSMirror = (dwFlags & VPP_FSMIRROR) &&
                 (vpp.dwOverlayFSNumSurfaces > 0) &&
                 (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK);

    if (dwWorkSurfaces < 2) {
        // no work surfaces, can't do anything
        doConvert = FALSE;
        doSubPicture = FALSE;
        doTemporal = FALSE;
        doDeinterlace = FALSE;
        doPreScale = FALSE;
        doCC = FALSE;
    } else if (dwWorkSurfaces < 4) {
        // there are only 2 or 3 work surfaces, we can only do one VPP stage, so prioritize
        if (doConvert) {
            doPreScale = FALSE;
            doSubPicture = FALSE;
            doTemporal = FALSE;
            doDeinterlace = FALSE;
        } else if (doPreScale) {
            doSubPicture = FALSE;
            doTemporal = FALSE;
            doDeinterlace = FALSE;
        } else if (doSubPicture) {
            doTemporal = FALSE;
            doDeinterlace = FALSE;
        }
        doCC = FALSE;   // needs more than 2 work surfaces
        if (classUsed == NV5Class) {
            // NV4/5 requires 4 work surfaces for temporal filtering
            doTemporal = FALSE;
        }
    }

    doOvlZoom = (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK);

    doLateFlipSync = (vpp.regOverlayMode & NV4_REG_OVL_MODE_LATEFLIPSYNC);

    // never allow flips to queue up if we are post processing
    if (!doLateFlipSync) {
        // early sync handles all cases
        if (!vppFlipSync(&vpp,lpProcInfo, dwIndex, dwFlags & VPP_WAIT)) {
            return FALSE;
        }
    }

    if (doConvert || doSubPicture || doPreScale || doCC || doDeinterlace || doTemporal || doFSMirror) {
        vpp.pPusher->waitForOtherChannels();
        vppSetSurfacesState(&vpp);
    }

    if (doFSMirror) {
        // if FSMirror is enabled, then we want to process the entire video image, not just the subrectangle
        dwWidth = vpp.dwOverlayFSSrcWidth;
        dwHeight = vpp.dwOverlayFSSrcHeight;
    }

    // always convert the entire surface cuz it saves us alot of subrectangle calculation,
    //  who cares about non-YUV422 performance
    if (doConvert) {
        if (vppConvert(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset,
                       dwDstPitch, dwWidth, dwHeight, dwFourCC)) {
            hLastStage = lpProcInfo->hConvert3;
            pLastStageNotifier = vpp.m_obj_a[V2V_FORMAT_NDX].notifier_a;

            NEXT_SURFACE;
            dwFourCC = FOURCC_YUY2;
            vppExec |= VPP_CONVERT;
        }
    }

    // codec does the subrectangle optimization
    if (doSubPicture) {
        if (vppSubPicture(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset,
                          dwDstPitch, dwWidth, dwHeight, dwFourCC)) {
            hLastStage = lpProcInfo->hSubPicture3;
            pLastStageNotifier = vpp.m_obj_a[DVDPICT_NDX].notifier_a;

            if (vpp.subPicture.pitch & NVS2VF_SP_SUBRECT) {
                // codec has requested in place composition, don't do next_surface
            } else {
                NEXT_SURFACE;
            }
            vppExec |= VPP_SUBPICTURE;
        }
    }

    if (doFSMirror || doOvlZoom) {
        // adjust for the FS mirror subrectangle
        dwRoundX = vpp.dwOverlayFSSrcMinX & 0x1;
        dwRoundY = vpp.dwOverlayFSSrcMinY & 0x1;
        dwSrcOffset += (vpp.dwOverlayFSSrcMinY & ~0x1) * dwSrcPitch;
        dwSrcOffset += (vpp.dwOverlayFSSrcMinX & ~0x1) << 1;   // always YUV422
        // ????? There's a really weird interaction with DVD subpicture class with width set to 8 pixels or less,
        //       and some GDI operation.  Not sure if it's hw or sw, but setting minimum width of 16 pixels makes
        //       the problem go away.  Overlay surfaces should have a minimum pitch greater than this, so very
        //       small overlay surfaces will be unaffected.
        dwWidth = max(vpp.dwOverlayFSSrcWidth, 16);
        dwHeight = vpp.dwOverlayFSSrcHeight;
        if (dwRoundY) {
            dwHeight += 1;
        }
    } else {
        // adjust for the subrectangle
        dwRoundX = vpp.dwOverlaySrcX & 0x1;
        dwRoundY = vpp.dwOverlaySrcY & 0x1;
        dwSrcOffset += (vpp.dwOverlaySrcY & ~0x1) * dwSrcPitch;
        dwSrcOffset += (vpp.dwOverlaySrcX & ~0x1) << 1;   // always YUV422
        // ????? There's a really weird interaction with DVD subpicture class with width set to 8 pixels or less,
        //       and some GDI operation.  Not sure if it's hw or sw, but setting minimum width of 16 pixels makes
        //       the problem go away.  Overlay surfaces should have a minimum pitch greater than this, so very
        //       small overlay surfaces will be unaffected.
        dwWidth = max(vpp.dwOverlaySrcSize & 0xFFFF, 16);
        dwHeight = vpp.dwOverlaySrcSize >> 16;
        if (dwRoundY) {
            dwHeight += 1;
        }
    }

    if (doDeinterlace) {
        if (dwOpCount == 0 && (vpp.regOverlayMode & NV4_REG_OVL_MODE_DF_PRECOPY)) {
            // need to keep a copy of source data
            if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, dwWidth, dwHeight)) {
                NEXT_SURFACE;
            } else {
                nvAssert(FALSE);
            }
        }

        BOOL bDeinterlaceResult = FALSE;

        switch (classUsed)
        {
        case CelsiusClass:
            bDeinterlaceResult = vppNv10Deinterlace(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                    dwDstOffset, dwDstPitch,
                                                    dwWidth, dwHeight, dwFlags);
            break;

        case KelvinClass:
            bDeinterlaceResult = vppNv20Deinterlace(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                    dwDstOffset, dwDstPitch,
                                                    dwWidth, dwHeight, dwFlags);
            break;
        }

        if (bDeinterlaceResult)
        {
            hLastStage = lpProcInfo->hDFilter3;
            pLastStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            NEXT_SURFACE;
            vppExec |= VPP_DEINTERLACE;
        }
    }

    if (doTemporal) {
        if (dwOpCount == 0 && (vpp.regOverlayMode & NV4_REG_OVL_MODE_TF_PRECOPY)) {
            // need to keep a copy of source data
            if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, dwWidth, dwHeight)) {
                NEXT_SURFACE;
            } else {
                nvAssert(FALSE);
            }
        }

        BOOL bTemporalResult = FALSE;

        switch(classUsed)
        {
        case CelsiusClass:
            bTemporalResult = vppNv10Temporal(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                dwDstOffset, dwDstPitch,
                                                dwWidth, dwHeight, dwFlags,
                                                &vpp.dwPrevFrameOffset);
            break;

        case KelvinClass:
            bTemporalResult = vppNv20Temporal(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                dwDstOffset, dwDstPitch,
                                                dwWidth, dwHeight, dwFlags,
                                                &vpp.dwPrevFrameOffset);
            break;
        }

        if (bTemporalResult)
        {
            hLastStage = lpProcInfo->hTFilter3;
            pLastStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            NEXT_SURFACE;
            vppExec |= VPP_TEMPORAL;

            // not the first frame any more
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        }
    }

    if (doFSMirror) {
        if (vpp.dwOverlayFSNumSurfaces == 2) {
            // early flip sync for double buffered case
            vppFSFlipSync(pVpp,lpProcInfo, dwIndex, TRUE);
        } else if (vpp.dwOverlayFSNumSurfaces == 3) {
            // in 60 fps cases at 60 Hz, make sure only one flip is queued, may see tearing if 2 are queued
            vppFSFlipSync(pVpp,lpProcInfo, dwIndex ^ 1, TRUE);
        }
        if (vppFSMirror(pVpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwWidth, dwHeight, dwFourCC, dwFlags, dwPrescaleFactorX, dwPrescaleFactorY)) {
            hLastFSStage = lpProcInfo->hFSMirror3;
            pLastFSStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            vppExec |= VPP_FSMIRROR;
        }
    }

    // Since OCC is much slower that prescale, arrange it so that OCC operates
    // on the smaller data set.
    if (isDownScale) {
        // do prescale first and then OCC
        if (doPreScale) {
            DWORD dwStartWidth, dwStartHeight;
            dwStartWidth = dwWidth;
            dwStartHeight = dwHeight;
            do {
                if (vppPreScale(pVpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                            &dwWidth, &dwHeight, dwFourCC, &dwFlags)) {
                    hLastStage = lpProcInfo->hSubPicture3;
                    pLastStageNotifier = vpp.m_obj_a[DVDPICT_NDX].notifier_a;
                    NEXT_SURFACE;
                    vppExec |= VPP_PRESCALE;
                }
            } while ((dwWidth  > (vpp.dwOverlayDstWidth * vpp.dwOverlayMaxDownScaleX) &&
                      vpp.dwOverlayDstWidth > 4) ||
                     (dwHeight > (vpp.dwOverlayDstHeight * vpp.dwOverlayMaxDownScaleY) &&
                      vpp.dwOverlayDstHeight > 4));
            dwPrescaleFactorX = (dwWidth << 20) / dwStartWidth;
            dwPrescaleFactorY = (dwHeight << 20) / dwStartHeight;
        }
        if (doCC) {
            if (dwOpCount == 0 && vpp.colorCtrl.lContrast != 0xFF) {
                // need to copy source data because contrast may be done in place
                if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                               dwWidth, dwHeight)) {
                    NEXT_SURFACE;
                } else {
                    nvAssert(FALSE);
                }
            }
            if (vppColourControl(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                                 dwWidth, dwHeight, dwFourCC, dwFlags)) {
                hLastStage = lpProcInfo->hColourControl3;
                pLastStageNotifier = vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a;
                NEXT_SURFACE;
                vppExec |= VPP_COLOURCONTROL;
            }
        }
    } else {
        // do OCC first and then prescale
        if (doCC) {
            if (dwOpCount == 0 && vpp.colorCtrl.lContrast != 0xFF) {
                // need to copy source data because contrast may be done in place
                if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                               dwWidth, dwHeight)) {
                    NEXT_SURFACE;
                } else {
                    nvAssert(FALSE);
                }
            }
            if (vppColourControl(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                                 dwWidth, dwHeight, dwFourCC, dwFlags)) {
                hLastStage = lpProcInfo->hColourControl3;
                pLastStageNotifier = vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a;
                NEXT_SURFACE;
                vppExec |= VPP_COLOURCONTROL;
            }
        }
        if (doPreScale) {
            DWORD dwStartWidth, dwStartHeight;
            dwStartWidth = dwWidth;
            dwStartHeight = dwHeight;
            do {
                if (vppPreScale(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                                &dwWidth, &dwHeight, dwFourCC, &dwFlags)) {
                    hLastStage = lpProcInfo->hSubPicture3;
                    pLastStageNotifier = vpp.m_obj_a[DVDPICT_NDX].notifier_a;
                    NEXT_SURFACE;
                    vppExec |= VPP_PRESCALE;
                }
            } while ((dwWidth  > (vpp.dwOverlayDstWidth * vpp.dwOverlayMaxDownScaleX) &&
                      vpp.dwOverlayDstWidth > 4) ||
                     (dwHeight > (vpp.dwOverlayDstHeight * vpp.dwOverlayMaxDownScaleY) &&
                      vpp.dwOverlayDstHeight > 4));
            dwPrescaleFactorX = (dwWidth << 20) / dwStartWidth;
            dwPrescaleFactorY = (dwHeight << 20) / dwStartHeight;
        }
    }

    if (doTemporal && (classUsed == NV5Class)) {
        if (dwOpCount == 0) {
            // need to copy source data to a work area whose dimensions are a power of 2
            if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, dwWidth, dwHeight)) {
                NEXT_SURFACE;
            } else {
                nvAssert(FALSE);
            }
        }

        if (vppNv5Temporal(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                           dwWidth, dwHeight, &vpp.dwPrevFrameOffset)) {
            hLastStage = lpProcInfo->hTFilter3;
            pLastStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            vppExec |= VPP_TEMPORAL;
            // don't do a NEXT_SURFACE, temporal filter operates in place and leaves
            // a swizzled version at dwDstOffset for use on the next frame (NV4/5)

            // not the first frame any more
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        }
    }

    if (doConvert || doSubPicture || doPreScale || doCC || doDeinterlace || doTemporal || doFSMirror) {
        vppRestoreSurfacesState(&vpp);
    }

    if (!doTemporal) {
        // next time tfilter is enabled, it will be the first frame
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_NOTFIRST;
    }

    if ((dwFlags & VPP_OPTIMIZEFLIP) && dwOpCount == 0) {
        // nothing happened, don't flip
        return FALSE;
    }

    if (doFSMirror && !doOvlZoom) {
        // now do the subrectangle adjustments for FS mirror so things flip properly
        dwSrcOffset += vpp.dwOverlaySrcY * dwSrcPitch;
        dwSrcOffset += (vpp.dwOverlaySrcX & ~0x1) << 1;   // always YUV422
        // ????? There's a really weird interaction with DVD subpicture class with width set to 8 pixels or less,
        //       and some GDI operation.  Not sure if it's hw or sw, but setting minimum width of 16 pixels makes
        //       the problem go away.  Overlay surfaces should have a minimum pitch greater than this, so very
        //       small overlay surfaces will be unaffected.
        dwWidth = max(vpp.dwOverlaySrcSize & 0xFFFF, 16);
        dwHeight = vpp.dwOverlaySrcSize >> 16;
    } else {
        if (dwRoundY) {
            dwSrcOffset += dwSrcPitch;
            dwHeight -= 1;
        }
    }

    //
    // NB: any local variables or parameters used before & after this point must be saved
    //    (excluding lProcinfo)
    //     This SAVE/RESTORE feature is only used by Ravisent decoders
    //
    if (dwFlags & VPP_SAVE_STATE) {
        vpp.pipeState.dwOpCount            = dwOpCount;
        vpp.pipeState.hLastStage           = hLastStage;
        vpp.pipeState.pLastStageNotifier   = pLastStageNotifier;
        vpp.pipeState.hLastFSStage         = hLastFSStage;
        vpp.pipeState.pLastFSStageNotifier = pLastFSStageNotifier;
        vpp.pipeState.doLateFlipSync       = (NvU8)doLateFlipSync;
        vpp.pipeState.dwIndex              = dwIndex;
        vpp.pipeState.dwSrcOffset          = dwSrcOffset;
        vpp.pipeState.dwSrcPitch           = dwSrcPitch;
        vpp.pipeState.dwWidth              = dwWidth;
        vpp.pipeState.dwHeight             = dwHeight;
        vpp.pipeState.dwFourCC             = dwFourCC;
        vpp.pipeState.dwFlags              = dwFlags & ~VPP_SAVE_STATE;
        vpp.pipeState.dwWorkSurfaces       = dwWorkSurfaces;
        vpp.pipeState.dwPrescaleFactorX    = dwPrescaleFactorX;
        vpp.pipeState.dwPrescaleFactorY    = dwPrescaleFactorY;
        vpp.pipeState.doFSMirror           = (NvU8)doFSMirror;
#ifdef VPP_SNOOP
        vpp.pipeState.qwTime1              = qwTime1;
        vpp.pipeState.qwTime2              = qwTime2;
        vpp.pipeState.qwDelta              = qwDelta;
        vpp.pipeState.qwJitter             = qwJitter;
#endif
        return TRUE;
    }

    if (dwFlags & VPP_RESTORE_STATE) {
        dwOpCount            = vpp.pipeState.dwOpCount;
        hLastStage           = vpp.pipeState.hLastStage;
        pLastStageNotifier   = vpp.pipeState.pLastStageNotifier;
        hLastFSStage         = vpp.pipeState.hLastFSStage;
        pLastFSStageNotifier = vpp.pipeState.pLastFSStageNotifier;
        doLateFlipSync       = vpp.pipeState.doLateFlipSync;
        dwIndex              = vpp.pipeState.dwIndex;
        dwSrcOffset          = vpp.pipeState.dwSrcOffset;
        dwSrcPitch           = vpp.pipeState.dwSrcPitch;
        dwWidth              = vpp.pipeState.dwWidth;
        dwHeight             = vpp.pipeState.dwHeight;
        dwFourCC             = vpp.pipeState.dwFourCC;
        dwFlags              = vpp.pipeState.dwFlags;
        dwWorkSurfaces       = vpp.pipeState.dwWorkSurfaces;
        vppExec              = vpp.pipeState.vppExec;
        dwPrescaleFactorX    = vpp.pipeState.dwPrescaleFactorX;
        dwPrescaleFactorY    = vpp.pipeState.dwPrescaleFactorY;
        doFSMirror           = vpp.pipeState.doFSMirror;
#ifdef VPP_SNOOP
        qwTime1              = vpp.pipeState.qwTime1;
        qwTime2              = vpp.pipeState.qwTime2;
        qwDelta              = vpp.pipeState.qwDelta;
        qwJitter             = vpp.pipeState.qwJitter;
#endif
    }

    // wait for all stages to complete
    if (dwOpCount > 0 && hLastStage) {
        if (VppWaitForNotification(pLastStageNotifier, hLastStage, VPP_TIMEOUT_TIME)) {
            DPF(" *** A VPP stage notification failed to return during timeout period ***");
            EVENT_ERROR;
        }

    } else {
        if (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS) {
            // wait for any DMA blits to flush out before processing
            // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hDMABlitToVid3, VPP_TIMEOUT_TIME))) {
            if (VppWaitForNotification(&(vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1]), lpProcInfo->hDMABlitToVid3, VPP_TIMEOUT_TIME)) {
                DPF(" *** DMA BLIT event failure ***");
                EVENT_ERROR;
            }
        }
        // wait for any backdoor FOURCC blits to flush out
        if (VppWaitForNotification(vpp.pPusherSyncNotifier, lpProcInfo->hFSMirror3, VPP_TIMEOUT_TIME)) {
            DPF(" *** FOURCC BLIT event failure ***");
            EVENT_ERROR;
        }
    }

    if (doLateFlipSync) {
        // late sync only for decoders that use lots of stages, will not work for
        // fewer than 3 buffers, decoder must not go back and re-use a surface that
        // it just flipped away from
        if (!vppFlipSync(&vpp,lpProcInfo, dwIndex, TRUE)) {
            return FALSE;
        }
    }

    // always do the flip, even if we are not flipping
    if (vppFlip(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFourCC, dwFlags, dwPrescaleFactorX, dwPrescaleFactorY)) {
        vpp.pDriverData->dwTVTunerFlipCount = 0;
        vpp.dwOverlayFlipCount++;
        vpp.overlayBufferIndex ^= 1;
        if (dwWorkSurfaces == 0) {
            vpp.extraIndex = 0;
        } else if (dwWorkSurfaces <= 3) {
            vpp.extraIndex = (vpp.extraIndex + 1) % dwWorkSurfaces;
        } else {
            vpp.extraIndex = (vpp.extraIndex + 2) % dwWorkSurfaces;
        }

        // successful overlay flip, now match it with the FS mirror image
        if (doFSMirror) {
            if (hLastFSStage) {
                if (VppWaitForNotification(pLastFSStageNotifier, hLastFSStage, VPP_TIMEOUT_TIME)) {
                    dbgError(" *** FS event failure ***");
                    EVENT_ERROR;
                }
            }
            if (vpp.dwOverlayFSNumSurfaces > 3) {
                // late flip sync for quad buffered case
                vppFSFlipSync(pVpp,lpProcInfo, dwIndex, TRUE);
            }
            vppFSFlip(pVpp,lpProcInfo, dwIndex);
            if (vpp.dwOverlayFSNumSurfaces != 0) {
                vpp.dwOverlayFSIndex = (vpp.dwOverlayFSIndex + 1) % vpp.dwOverlayFSNumSurfaces;
            }
        }
    } else {
        return FALSE;
    }

#ifdef VPP_SNOOP

    vpp.snoop.dwLastExec = vppExec;
    nvQueryPerformanceCounter(&qwTime2);
    qwDelta = qwTime2 - qwTime1;
    qwJitter = (qwDelta > vpp.snoop.qwIntraFrameDelta) ?
               (qwDelta - vpp.snoop.qwIntraFrameDelta) :
               (vpp.snoop.qwIntraFrameDelta - qwDelta);
    vpp.snoop.qwIntraFrameJitterAcc += qwJitter;
    if (qwJitter > vpp.snoop.qwIntraFrameJitterPeak) {
        vpp.snoop.qwIntraFrameJitterPeak = qwJitter;
    }
    vpp.snoop.qwIntraFrameAcc += qwDelta;
    if (qwDelta > vpp.snoop.qwIntraFramePeak) {
        vpp.snoop.qwIntraFramePeak = qwDelta;
    }
    vpp.snoop.qwIntraFrameDelta = qwDelta;
    vpp.snoop.qwCount += 1;
    vpp.snoop.dwLastFlags &= 0x7FFFFFFF;

#else   // !VPP_SNOOP
#ifdef DEBUG
    nvStrCat (debugstr, "ENA: ");
    if (doConvert)                       nvStrCat (debugstr, "cvt ");
    if (doSubPicture)                    nvStrCat (debugstr, "sp ");
    if (doPreScale)                      nvStrCat (debugstr, "ps ");
    if (doCC)                            nvStrCat (debugstr, "cc ");
    if (doTemporal)                      nvStrCat (debugstr, "tf ");
    if (doDeinterlace)                   nvStrCat (debugstr, "df ");
    if (doFSMirror)                      nvStrCat (debugstr, "fs ");
    nvStrCat (debugstr, "EXEC: ");
    if (vppExec & VPP_CONVERT)           nvStrCat (debugstr, "cvt ");
    if (vppExec & VPP_SUBPICTURE)        nvStrCat (debugstr, "sp ");
    if (vppExec & VPP_PRESCALE)          nvStrCat (debugstr, "ps ");
    if (vppExec & VPP_COLOURCONTROL)     nvStrCat (debugstr, "cc ");
    if (vppExec & VPP_TEMPORAL)          nvStrCat (debugstr, "tf ");
    if (vppExec & VPP_DEINTERLACE)       nvStrCat (debugstr, "df ");
    if (vppExec & VPP_FSMIRROR)          nvStrCat (debugstr, "fs ");
    DPF(debugstr);
#endif  // DEBUG
#endif  // VPP_SNOOP

    return TRUE;
}

// -----------------------------------------------------------------------------------------
// VppSetOverlayColourControl
//      Sets the overlay colour controls
//
// Globals:
//      OverlayColourControl

extern NvU8 VppSetOverlayColourControl(Vpp_t *pVpp)
{
    long            newHWContrast;
    long            newHWBrightness;
    long            newHWSaturation;
    long            newHWSine;
    long            newHWCosine;
    float           fRadians;
    Vpp_t &vpp = *pVpp;

    if (!(pVpp->dwFlags & VPP_FLAG_OVERLAY_READY))
    {
       return FALSE;
    }

    if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        /* Convert to equivalent NV hardware values */
        newHWContrast = vpp.colorCtrl.lContrast;
        if (newHWContrast < 0)
            newHWContrast = 0;
        if (newHWContrast > 19999)
            newHWContrast = 19999;
        newHWContrast *= 8192;
        newHWContrast /= 20000;

        newHWBrightness = vpp.colorCtrl.lBrightness;
        newHWBrightness -= 750;
        newHWBrightness *= 256;
        newHWBrightness /= 10000;

        newHWSaturation = vpp.colorCtrl.lSaturation;
        if (newHWSaturation < 0)
            newHWSaturation = 0;
        if (newHWSaturation > 19999)
            newHWSaturation = 19999;
        newHWSaturation *= 8192;
        newHWSaturation /= 20000;

        fRadians = (float)((vpp.colorCtrl.lHue * 3.1415926) / 180);
        // TBD: using sin/cos in the driver may not be doable on all platforms.  Is the FPU ready in this
        //   cpu mode?  [it is for Windows systems in Ddraw] - @mjl
        newHWSine = (long)(sin(fRadians) * newHWSaturation);
        newHWCosine = (long)(cos(fRadians) * newHWSaturation);

        /* Merge luminance values */
        newHWBrightness <<= 16;
        newHWBrightness |= newHWContrast;

        /* Merge chrominance values */
        newHWCosine &= 0xFFFF;
        newHWSine <<= 16;
        newHWSine |= newHWCosine;

        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.m_obj_a[OVERLAY_NDX].classIID);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_OVERLAY_LUMINANCE_A | 0x80000);
        vpp.pPusher->push(3, newHWBrightness);     // SetOverlayLuminanceA
        vpp.pPusher->push(4, newHWSine);           // SetOverlayChrominanceA
        vpp.pPusher->adjust(5);
        vpp.pPusher->start(TRUE);
        vpp.pDriverData->dDrawSpareSubchannelObject = 0;
        return TRUE;
    }
    return FALSE;

}

// These blt support routines should be moved to a shared blt routine when that is made OS independant @mjl@

// -----------------------------------------------------------------------------
// vppBltUpdateClip
//      Updates the NV clipper state if necessary
// -----------------------------------------------------------------------------
LOCAL void vppBltUpdateClip(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    if (vpp.pDriverData->ddClipUpdate ||
        vpp.pDriverData->dwSharedClipChangeCount != vpp.pDriverData->dwDDMostRecentClipChangeCount)
    {
        // Why not use spare here? @mjl@
        vpp.pPusher->push (0,SUB_CHANNEL(vpp.surfaces2DSubCh) | 0x40000);
        vpp.pPusher->push (1,vpp.hImageBlackRect);
        vpp.pPusher->push (2,SUB_CHANNEL(vpp.surfaces2DSubCh) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
        vpp.pPusher->push (3,0);
        vpp.pPusher->push (4,asmMergeCoords(NV_MAX_X_CLIP,NV_MAX_Y_CLIP));
        vpp.pPusher->push (5,SUB_CHANNEL(vpp.surfaces2DSubCh) | 0x40000);
        vpp.pPusher->push (6,vpp.hSurfaces2D);

        vpp.pPusher->adjust (7);
        vpp.pPusher->start  (TRUE);

        vpp.pDriverData->dwSharedClipChangeCount++;
        vpp.pDriverData->dwDDMostRecentClipChangeCount = vpp.pDriverData->dwSharedClipChangeCount;
        vpp.pDriverData->ddClipUpdate = FALSE;
    }
}

// -----------------------------------------------------------------------------
// vppBltFillBlock
//      Fill a block of memory.  Self contained, for internal use only
//
// -----------------------------------------------------------------------------
LOCAL void vppBltFillBlock(Vpp_t *pVpp, NvU32 dwColor, NvU32 dwOffset, NvU32 dwPitch, NvU32 dwWidth, NvU32 dwHeight, NvU32 dwBytesPerPel)
{
    NvU32 dwCombinedPitch, dwColourFormat, dwColourFormat2;
    NvU32 dwDstX;
    Vpp_t &vpp = *pVpp;

    vpp.pDriverData->blitCalled = TRUE;
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // make sure we sync with other channels before writing put
    vpp.pPusher->setSyncChannelFlag();

    vppBltUpdateClip(pVpp);

    // alignment
    dwDstX = (dwOffset & NV_BYTE_ALIGNMENT_PAD) / dwBytesPerPel;
    dwOffset &= ~NV_BYTE_ALIGNMENT_PAD;

    // source key is disabled
    if (vpp.pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextColorKey);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, 0);
        vpp.pPusher->adjust(4);
        vpp.pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextColorKey;
    }

    // ROP is always SRCCOPY
    if (vpp.pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropSubCh) | SET_ROP_OFFSET | 0x40000);
        vpp.pPusher->push(1, SRCCOPYINDEX);
        vpp.pPusher->adjust(2);
        vpp.pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }

    // set surfaces 2d
    switch (dwBytesPerPel) {
    case 1:
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y8;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        break;
    case 4:
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        break;
    default:
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
        break;
    }
    dwCombinedPitch = (dwPitch << 16) | dwPitch;
    if (vpp.pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
        vpp.pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        vpp.pDriverData->bltData.dwLastSrcOffset != dwOffset ||
        vpp.pDriverData->bltData.dwLastDstOffset != dwOffset) {

        vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        vpp.pPusher->push(1, dwColourFormat);          // SetColorFormat
        vpp.pPusher->push(2, dwCombinedPitch);         // SetPitch
        vpp.pPusher->push(3, dwOffset);                // SetSrcOffset
        vpp.pPusher->push(4, dwOffset);                // SetDstOffset
        vpp.pPusher->adjust(5);
        vpp.pDriverData->bltData.dwLastColourFormat = dwColourFormat;
        vpp.pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        vpp.pDriverData->bltData.dwLastSrcOffset = dwOffset;
        vpp.pDriverData->bltData.dwLastDstOffset = dwOffset;

        // Also set mono pattern mask when pixel depth changes.
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextPattern);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
        vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
        switch (dwBytesPerPel) {
        case 1:
            vpp.pPusher->push(4,NV_ALPHA_1_008);
            vpp.pPusher->push(5,NV_ALPHA_1_008);
            break;
        case 4:
            vpp.pPusher->push(4,NV_ALPHA_1_032);
            vpp.pPusher->push(5,NV_ALPHA_1_032);
            break;
        default:
            vpp.pPusher->push(4,NV_ALPHA_1_016);
            vpp.pPusher->push(5,NV_ALPHA_1_016);
            break;
        }
        vpp.pPusher->adjust(6);
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextPattern;
    }

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropRectTextSubCh) | NV04A_SET_COLOR_FORMAT | 0x40000);
    vpp.pPusher->push(1, dwColourFormat2);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.ropRectTextSubCh) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
    vpp.pPusher->push(3, dwColor);
    vpp.pPusher->push(4, asmMergeCoords(0, dwDstX));
    vpp.pPusher->push(5, asmMergeCoords(dwHeight, dwWidth));
    vpp.pPusher->adjust(6);
    vpp.pPusher->start(TRUE);
}

// -----------------------------------------------------------------------------
// vppBltWriteDword
//      Fill a dword with data.  Self contained, for internal use only.  Useful
//      for writing data to video memory in win2k
void VppBltWriteDword(Vpp_t *pVpp, NvU32 dwOffset, NvU32 dwIndex, NvU32 dwData)
{
    Vpp_t &vpp = *pVpp;
    NvU32 dwCombinedPitch;

    vpp.pDriverData->blitCalled = TRUE;             // TBD: see that this is used or ignored properly in NT4 @mjl@
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // make sure we sync with other channels before writing put
    vpp.pPusher->setSyncChannelFlag();

    vppBltUpdateClip(pVpp);

    // source key is disabled
    if (vpp.pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextColorKey);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, 0);
        vpp.pPusher->adjust(4);
        vpp.pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextColorKey;
    }

    // ROP is always SRCCOPY
    if (vpp.pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropSubCh) | SET_ROP_OFFSET | 0x40000);
        vpp.pPusher->push(1, SRCCOPYINDEX);
        vpp.pPusher->adjust(2);
        vpp.pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }

    // set surfaces2D
    dwCombinedPitch = ((vpp.pDriverData->dwSurfaceAlignPad + 1) << 16) | (vpp.pDriverData->dwSurfaceAlignPad + 1);
    if (vpp.pDriverData->bltData.dwLastColourFormat != NV062_SET_COLOR_FORMAT_LE_Y32 ||
        vpp.pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        vpp.pDriverData->bltData.dwLastSrcOffset != dwOffset ||
        vpp.pDriverData->bltData.dwLastDstOffset != dwOffset) {

        vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        vpp.pPusher->push(1, NV062_SET_COLOR_FORMAT_LE_Y32);   // SetColorFormat
        vpp.pPusher->push(2, dwCombinedPitch);                 // SetPitch
        vpp.pPusher->push(3, dwOffset);                        // SetSrcOffset
        vpp.pPusher->push(4, dwOffset);                        // SetDstOffset
        vpp.pPusher->adjust(5);
        vpp.pDriverData->bltData.dwLastColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;
        vpp.pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        vpp.pDriverData->bltData.dwLastSrcOffset = dwOffset;
        vpp.pDriverData->bltData.dwLastDstOffset = dwOffset;
    }

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropRectTextSubCh) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
    vpp.pPusher->push(1, dwData);
    vpp.pPusher->push(2, asmMergeCoords(0, dwIndex));
    vpp.pPusher->push(3, asmMergeCoords(1, 1));
    vpp.pPusher->adjust(4);

    vpp.pPusher->flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\vpcompilex86.c ===
/*
 * nv10vpexec.c
 *
 * Copyright 2000 NVIDIA, Corporation.  All rights reserved.
 * 
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** This file should only be compiled if it's needed.  The normal OpenGL ifdefs:
**
**      #if defined(GL_NV_vertex_program) && __NV_ACCEL>=10
**      #ifdef __GL_USE_OG_INTEL_ASM
**
** and any OpenGL includes like:
**
**      #include "context.h"
**
** can't be used since this is used by D3D as well.
**
*/

#include <stddef.h>
#include <float.h>

#if defined(IS_OPENGL)
#include "nvassert.h"
#else
//#define assert()
#endif

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"
#include "x86.h"

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE 1
#endif

#if !defined(VIEW_AS_INT)
#define VIEW_AS_INT(x) (*(int *) &(x))
#endif

#define INCLUDE_MULTIPLY_BY_ZERO_CODE 1

#define FIX_SLT_ZERO_COMPARE 1

typedef enum ExprKind_Enum {
    E_NONE, E_MEM, E_MEMIX, E_IREG, E_FREG, E_AREG,
} ExprKind;

// Scalar types:

typedef struct ExprMem_Rec {
    ExprKind kind;
    int offset;
    int Negate;
} ExprMem;

typedef struct ExprAReg_Rec {
    ExprKind kind;
} ExprAReg;

typedef struct ExprIReg_Rec {
    ExprKind kind;
    int regNo;
} ExprIReg;

typedef struct ExprFReg_Rec {
    ExprKind kind;
    int regNo;
} ExprFReg;

typedef union Expr_Rec {
    ExprKind kind;
    ExprMem eMem;
    ExprAReg aReg;
    ExprIReg iReg;
    ExprFReg fReg;
} Expr;

// Vector types:

typedef struct Vector_Rec {
    Expr x;
    Expr y;
    Expr z;
    Expr w;
} Vector;

typedef struct Code_Rec {
    unsigned int ilcCount, ilcMax;
    unsigned char *ilcData;
    VtxProgCompileX86 *environment;
} Code;

typedef struct Coord_Rec {
    float x, y, z, w;
} Coord;

#if defined(IS_OPENGL)
    #define FP_BITS_LOG0 0xFF800000 // use -inf
#else
    #define FP_BITS_LOG0 0xFF7FFFFF // use a large negative number
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#define OP_LIT_128_MINUS_EPSILON (128.0f - 1.0f/256.0f)
#define F_EXP_BIAS 127
#define LOCAL_VAR_SIZE 32

struct VtxProgImports_Rec VtxProgImports;

static char watermark[] = "wa\0\0t\2\ffer\0\0\0ma\0\ff\frk\0\0#0";

int __internal_setup(int i) { return watermark[i]; }

/*
** lLitOpFun()
*/

#if defined(IS_OPENGL)
static void lLitOpFun(Coord *a)
#else
static void _cdecl lLitOpFun(Coord *a)
#endif
{
    Coord *t = a + 1;
    float x, y, w;

    //if (vinst->dst.mask & DST_X_BIT)
        t->x = 1.0f;
    //if (vinst->dst.mask & (DST_Y_BIT | DST_Z_BIT)) {
    //    if (vinst->src.Signed) {
    //        x = -a->x;
    //        y = -a->y;
    //        w = -a->w;
    //    } else {
            x = a->x;
            y = a->y;
            w = a->w;
    //    }
        if (x < 0.0f)
            x = 0.0f;
        if (y < 0.0f)
            y = 0.0f;
    //    if (vinst->dst.mask & DST_Y_BIT)
            t->y = x;
    //    if (vinst->dst.mask & DST_Z_BIT) {
            if (x > 0.0f) {
                if (y == 0.0f) {
                    if (w == 0.0f) {
                        t->z = 1.0f;
                    } else {
                        t->z = 0.0f;
                    }
                } else {
                    if (w > OP_LIT_128_MINUS_EPSILON) {
                        w = OP_LIT_128_MINUS_EPSILON;
                    } else {
                        if (w < -OP_LIT_128_MINUS_EPSILON) {
                            w = -OP_LIT_128_MINUS_EPSILON;
                        }
                    }
                    t->z = VtxProgImports.expf(w*VtxProgImports.logf(y));
                    //////////////t->z = __GL_EXPF(w*__GL_LOGF(y));
                }
            } else {
                t->z = 0.0f;
            }
    //    }
    //}
    //if (vinst->dst.mask & DST_W_BIT)
        t->w = 1.0f;
} // lLitOpFun

///////////////////////////////////////////////////////////////////////////////

/*
** lIsNegated()
*/

static int lIsNegated(Vector *v)
{
    if (v->x.kind == E_MEM || v->x.kind == E_MEMIX) {
        return v->x.eMem.Negate;
    } else {
        return FALSE;
    }
} // lIsNegated
  
/*
** lGenSrcReg()
*/

static void lGenSrcReg(VtxProgCompileX86 *env, Expr *v, SrcReg *r)
{
    int lreg = r->reg;

    switch (lreg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        v->kind = E_MEM;
        v->eMem.offset = (lreg - VA_0)*sizeof(float)*4 + env->attrib_offset;
        v->eMem.Negate = FALSE;
        break;
    case VR_0:  case VR_1:  case VR_2:  case VR_3:
    case VR_4:  case VR_5:  case VR_6:  case VR_7:
    case VR_8:  case VR_9:  case VR_10: case VR_11:
    case VR_12: case VR_13: case VR_14: case VR_15:
        v->kind = E_MEM;
        v->eMem.offset = (lreg - VR_0)*sizeof(float)*4 + env->result_offset;
        v->eMem.Negate = FALSE;
        break;
    case ARL:
        v->kind = E_AREG;
        break;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        if (r->AddrReg) {
            v->kind = E_MEMIX;
            v->eMem.offset = r->addrRegOffset*sizeof(float)*4 + env->param_offset;
            v->eMem.Negate = FALSE;
        } else {
            v->kind = E_MEM;
            v->eMem.offset = (lreg - PR_0)*sizeof(float)*4 + env->param_offset;
            v->eMem.Negate = FALSE;
        }
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        v->kind = E_MEM;
        v->eMem.offset = (lreg - TR_0)*sizeof(float)*4 + env->temp_offset;
        v->eMem.Negate = FALSE;
        break;
    default:
        assert(!"lGenSrcReg() - Bad register number");
        break;
    }
} // lGenSrcReg

/*
** lGenDstReg()
*/

static void lGenDstReg(VtxProgCompileX86 *env, Expr *v, Register_t freg)
{
    switch (freg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        v->kind = E_MEM;
        v->eMem.offset = (freg - VA_0)*sizeof(float)*4 + env->attrib_offset;
        v->eMem.Negate = FALSE;
        break;
    case VR_0:  case VR_1:  case VR_2:  case VR_3:
    case VR_4:  case VR_5:  case VR_6:  case VR_7:
    case VR_8:  case VR_9:  case VR_10: case VR_11:
    case VR_12: case VR_13: case VR_14: case VR_15:
        v->kind = E_MEM;
        v->eMem.offset = (freg - VR_0)*sizeof(float)*4 + env->result_offset;
        v->eMem.Negate = FALSE;
        break;
    case ARL:
        v->kind = E_AREG;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        v->kind = E_MEM;
        v->eMem.offset = (freg - PR_0)*sizeof(float)*4 + env->param_offset;
        v->eMem.Negate = FALSE;
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        v->kind = E_MEM;
        v->eMem.offset = (freg - TR_0)*sizeof(float)*4 + env->temp_offset;
        v->eMem.Negate = FALSE;
        break;
    default:
        assert(!"lGenDstReg() - Bad register number");
        break;
    }
} // lGenDstReg

/*
** lGenAddOffset()
*/

static void lGenAddOffset(Expr *e, int fOffset)
{
    switch (e->kind) {
    case E_IREG:
    case E_FREG:
        assert(!"lGenAddOffset(I/FREG)");
        break;
    case E_MEM:
    case E_MEMIX:
        e->eMem.offset += fOffset;
        break;
    default:
        assert(!"lGenAddOffset()");
        break;
    }
} // lGenAddOffset

//////////////////////// X86 Code Generation Functions ////////////////////////

/*
** lGenLoadIReg()
*/

static void lGenLoadIReg(Code *fCode, Expr *e, int DoNegate)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_IREG:
        break;
    case E_FREG:
        assert(!"lGenLoadIReg(E_FREG)");
        break;
    case E_MEM:
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(e->eMem.offset);  // mov  eax, offset[gc]
            if (DoNegate && e->eMem.Negate) {
                xXOR_rm_imm(rmREG(rEAX), 0x80000000);               // xor  eax, 0x80000000
            }
            e->kind = E_IREG;
            e->iReg.regNo = rEAX;
        break;
    case E_MEMIX:
            xMOV_r_rm(rEAX, rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // mov  eax, offset[gc,esi]
            if (DoNegate && e->eMem.Negate) {
                xXOR_rm_imm(rmREG(rEAX), 0x80000000);               // xor  eax, 0x80000000
            }
            e->kind = E_IREG;
            e->iReg.regNo = rEAX;
        break;
    default:
        assert(!"lGenLoadIReg()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenLoadIReg

/*
** lGenLoad()
*/

static void lGenLoad(Code *fCode, Expr *e, int IRegOK, int DoNegate)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_IREG:
        if (!IRegOK)
            assert(!"lGenLoad(E_IREG, FLOAT)");
        break;
    case E_FREG:
        break;
    case E_MEM:
        if (IRegOK) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(e->eMem.offset);  // mov  eax, offset[gc]
            if (DoNegate && e->eMem.Negate) {
                xXOR_rm_imm(rmREG(rEAX), 0x80000000);               // xor  eax, 0x80000000
            }
            e->kind = E_IREG;
            e->iReg.regNo = rEAX;
        } else {
            xFLD_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);          // fld  offset[gc]
            if (DoNegate && e->eMem.Negate) {
                xFCHS;                                              // xchs
            }
            e->kind = E_FREG;
        }            
        break;
    case E_MEMIX:
            xFLD_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);    // fld  offset[gc,esi]
            if (DoNegate && e->eMem.Negate) {
                xFCHS;                                              // xchs
            }
            e->kind = E_FREG;
        break;
    default:
        assert(!"lGenLoad()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenLoad

/*
** lGenStore()
*/

static void lGenStore(Code *fCode, Expr *v, Expr *e, int DontFree)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (v->kind) {
    case E_MEM:
        switch (e->kind) {
        case E_IREG:
            xMOV_rm_r(rmIND32(rEBX), e->iReg.regNo) xOFS32(v->eMem.offset); // mov  offset[gc], eReg
            break;
        case E_FREG:
            if (DontFree) {
                xFST_rm(rmIND32(rEBX)) xOFS32(v->eMem.offset);              // fst  offset[gc]
            } else {
                xFSTP_rm(rmIND32(rEBX)) xOFS32(v->eMem.offset);             // fstp offset[gc]
            }
            break;
        default:
            assert(!"lGenStore(E_MEM, BAD)");
        }
        break;
    default:
        assert(!"lGenStore()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenStore

/*
** lGenNop() - Insert NOP instruction.
*/

static void lGenNop(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xNOP;       // nop
    X86_CODE_RESTORE(fCode);
} // lGenNop

/*
** lGenChs() - Change Sign of TOS.
*/

static void lGenChs(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFCHS;      // xchs
    X86_CODE_RESTORE(fCode);
} // lGenChs

/*
** lGenFxch() - Swap TOS with TOS - 1.
*/

static void lGenFxch(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFXCH_st(1);        // fxch
    X86_CODE_RESTORE(fCode);
} // lGenFxch

/*
** lGenAdd() - Add E to TOS.
*/

static void lGenAdd(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFADDP_st(1);   // faddp st(1)
        break;
    case E_MEM:
        xFADD_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);         // fadd  offset[gc]
        break;
    case E_MEMIX:
        xFADD_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);   // fadd  offset[gc,esi]
        break;
    default:
        assert(!"lGenAdd()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenAdd

/*
** lGenSub() - Subtract E from TOS.
*/

static void lGenSub(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFSUBP_st(1);   // fsubp st(1)
        break;
    case E_MEM:
        xFSUB_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);         // fsub  offset[gc]
        break;
    case E_MEMIX:
        xFSUB_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);   // fsub  offset[gc,esi]
        break;
    default:
        assert(!"lGenSub()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenSub

/*
** lGenSubR() - Reverse Subtract E from TOS.
*/

static void lGenSubR(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFSUBRP_st(1);   // fsubrp st(1)
        break;
    case E_MEM:
        xFSUBR_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);        // fsubr  offset[gc]
        break;
    case E_MEMIX:
        xFSUBR_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // fsubr  offset[gc,esi]
        break;
    default:
        assert(!"lGenAdd()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenSubR

/*
** lGenAddVariant() - Add E to TOS, possibly negating either or both.
*/

static void lGenAddVariant(Code *fCode, Expr *e, int NegateA, int NegateB)
{
    if (NegateA) {
        if (NegateB) {
            lGenAdd(fCode, e);
            lGenChs(fCode);
        } else {
            lGenSubR(fCode, e);
        }
    } else {
        if (NegateB) {
            lGenSub(fCode, e);
        } else {
            lGenAdd(fCode, e);
        }
    }
} // lGenAddVariant

/*
** lGenFcomp() - Compare E to TOS.  Pop everything.
*/

static void lGenFcomp(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFCOMPP();                                          // fcompp
        break;
    case E_MEM:
        xFCOMP_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);        // fcomp  offset[gc]
        break;
    case E_MEMIX:
        xFCOMP_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // fcomp  offset[gc,esi]
        break;
    default:
        assert(!"lGenFcomp()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenFcomp

/*
** lGenPushFloatComp() - Push a 1.0 or 0.0 on the stack based on fpcc.
**         Uses 0[esp] to move data to fp stack.
*/

static void lGenPushFloatComp(Code *fCode, int fmask, int fSNZ)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFNSTSW;                            // fnstsw ax
    xTEST_rm_imm8(rmREG(rAH), fmask);   // test   ah, mask
    if (fSNZ) {
        xSETNZ_rm8(rmREG(rEAX));        // setnz al
    } else {
        xSETZ_rm8(rmREG(rEAX));         // setz  al
    }
    xAND_rm_imm(rmREG(rEAX), 1);        // and   eax, 1
    xMOV_rm_r(rmSIB, rEAX) xSIB_esp;    // mov   [esp], eax
    xFILD_rm(rmSIB) xSIB_esp;           // fild  [esp]
    X86_CODE_RESTORE(fCode);
} // lGenPushFloatComp

#if defined(FIX_SLT_ZERO_COMPARE)

/*
** lGenSgeVariantSignedZero() - Compare EAX to +/-E treating +0.0 > -0.0 and return
**         a 1.0 or 0.0 on TOS.  Use SLT or SGE depending on IsSLT.
**
** Method: Xor sign bit with the lower 31 bits and use signed int compare.
**         Sign/Magnitude int shown.  Also works for fp. Sign/BiasedExp/Mantissa.
**
**  Value   S/M   Mask  xor(MSK,Val)  Value
**    1     001    000       001        1
**   +0     000    000       000        0
**   -0     100    011       111       -1
**   -1     101    011       110       -2
*/

static void lGenSgeVariantSignedZero(Code *fCode, Expr *e, int NegateE, int IsSLT)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);

    // Convert EAX arg into EDX:

    xMOV_rm_r(rmREG(rEDX), rEAX);       // mov edx, eax
    xSAR_rm_imm8(rmREG(rEDX), 30);      // sar edx, 30
    xSHR_rm_1(rmREG(rEDX));             // shr edx
    xXOR_rm_r(rmREG(rEDX), rEAX);       // xor edx, eax

    // Load second arg int EAX and convert using ECX as scratch:

    X86_CODE_RESTORE(fCode);
    lGenLoadIReg(fCode, e, NegateE);
    X86_CODE_LOAD(fCode);

    xMOV_rm_r(rmREG(rECX), rEAX);       // mov ecx, eax
    xSAR_rm_imm8(rmREG(rECX), 30);      // sar ecx, 30
    xSHR_rm_1(rmREG(rECX));             // shr ecx
    xXOR_rm_r(rmREG(rEAX), rECX);       // xor eax, ecx

    // Compare and use SLT or SGE to get result:

    xXOR_rm_r(rmREG(rECX), rECX);       // xor ecx, ecx ; For result
    xCMP_r_rm(rEDX, rmREG(rEAX));       // cmp eax, edx
    if (IsSLT) {
        xSETL_rm8(rmREG(rCL));          // setl cl
    } else {
        xSETGE_rm8(rmREG(rCL));         // setge cl
    }

    // Load the sucker onto the fp stack:

    xMOV_rm_r(rmSIB, rECX) xSIB_esp;    // mov   [esp], ecx
    xFILD_rm(rmSIB) xSIB_esp;           // fild  [esp]

    X86_CODE_RESTORE(fCode);
} // lGenSgeVariantSignedZero

#else // defined(FIX_SLT_ZERO_COMPARE)

/*
** lGenSgeVariant() - Compare E to TOS and return a 1 if GE, else a 0.
**
**        Possibly negating either or both arg.
*/

static void lGenSgeVariant(Code *fCode, Expr *e, int NegateA, int NegateB, int IsSLT)
{
    if (NegateA) {
        lGenChs(fCode);
        if (NegateB) {
            lGenLoad(fCode, e, FALSE, TRUE);
            lGenFxch(fCode);
            lGenFcomp(fCode, e);
        } else {
            lGenFcomp(fCode, e);
        }
    } else {
        if (NegateB) {
            lGenLoad(fCode, e, FALSE, TRUE);
            lGenFxch(fCode);
            lGenFcomp(fCode, e);
        } else {
            lGenFcomp(fCode, e);
        }
    }
    lGenPushFloatComp(fCode, 0x01, IsSLT);
} // lGenSgeVariant

#endif // defined(FIX_SLT_ZERO_COMPARE)

/*
** lGenMax() - Set TOS =  MAX(TOS, E).
*/

static void lGenMinMax(Code *fCode, Expr *e, int IsMax)
{
    X86_CODE_DECLARE;
    unsigned int loc;

    switch (e->kind) {
    case E_FREG:
        assert(!"lGenMinMax(E_FREG)");
        break;
    case E_MEM:
        lGenLoad(fCode, e, FALSE, TRUE);
        X86_CODE_LOAD(fCode);
        xFCOM_st(1);                            //      fcom   st(1)
        xFNSTSW;                                //      fnstsw ax
        if (IsMax) {
            xTEST_rm_imm8(rmREG(rAH), 0x41);    //      test   ah, 41  JLE (TOS <= st(1))
            xLABEL(loc);
            xJNZ(0);                            //      jne    lab
        } else {
            xTEST_rm_imm8(rmREG(rAH), 0x01);    //      test   ah, 01  JGE (TOS >= st(1))
            xLABEL(loc);
            xJZ(0);                             //      je     lab
        }
        xFXCH_st(1);                            //      fxch
        xTARGET_b8(loc);                        // lab:
        xFSTP_st(0);                            //      fstp   st(0)
        X86_CODE_RESTORE(fCode);
        break;
    default:
        assert(!"lGenMinMax()");
        break;
    }
} // lGenMinMax

/*
** lGenMul() - Multiply TOS by E.
*/

static void lGenMul(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        assert(!"lGenMul(E_FREG)");
        break;
    case E_MEM:
        xFMUL_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);         // fmul  offset[gc]
        break;
    case E_MEMIX:
        xFMUL_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);   // fmul  offset[gc,esi]
        break;
    default:
        assert(!"lGenMul()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenMul

#if defined(INCLUDE_MULTIPLY_BY_ZERO_CODE)

/*
** lGenTestForZeroMul() - Special case multiply:  If either value is +/- 0.0, result is 0.0
*/

static void lGenTestForZeroMul(Code *fCode, Expr *a, Expr *b, int FNegate)
{
    int zero1, zero2, done;
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (a->kind) {
    case E_IREG:
        assert(!"lGenTestForZeroMul(E_IREG)");
        break;
    case E_FREG:
        assert(!"lGenTestForZeroMul(E_FREG)");
        break;
    case E_MEM:
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(a->eMem.offset);       // mov eax, offset[gc]
        break;
    case E_MEMIX:
        xMOV_r_rm(rEAX, rmSIB32) xSIB32(rEBX, rESI, a->eMem.offset); // mov eax, offset[gc,esi]
        break;
    default:
        assert(!"lGenTestForZeroMul()");
        break;
    }
    // Mask off sign bit:
    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //   and  eax, 0x7fffffff
    xLABEL(zero1);
    xJZ(0);                                     //   jz   zero

    switch (b->kind) {
    case E_IREG:
        assert(!"lGenTestForZeroMul(E_IREG)");
        break;
    case E_FREG:
        assert(!"lGenTestForZeroMul(E_FREG)");
        break;
    case E_MEM:
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(b->eMem.offset);       // mov eax, offset[gc]
        break;
    case E_MEMIX:
        xMOV_r_rm(rEAX, rmSIB32) xSIB32(rEBX, rESI, b->eMem.offset); // mov eax, offset[gc,esi]
        break;
    default:
        assert(!"lGenTestForZeroMul()");
        break;
    }
    // Mask off sign bit:
    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //   and  eax, 0x7fffffff
    xLABEL(zero2);
    xJZ(0);                                     //   jz   zero
    X86_CODE_RESTORE(fCode);

    // Things are OK.  Do the multiply.

    lGenLoad(fCode, a, FALSE, FALSE);
    lGenMul(fCode, b);
    if (FNegate)
        lGenChs(fCode);

    X86_CODE_LOAD(fCode);
    xLABEL(done);
    xJMP8(0);
    xTARGET_b8(zero1);                         // zero:
    xTARGET_b8(zero2);                         // zero:
    xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_zero_offset); //   fld   gc->float_zero
    xTARGET_b8(done);                            // done:
    X86_CODE_RESTORE(fCode);
} // lGenTestForZeroMul

#endif // INCLUDE_MULTIPLY_BY_ZERO_CODE

/*
** lGenDivr() - Divide TOS into E.
*/

static void lGenDivr(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        assert(!"lGenDivr(E_FREG)");
        break;
    case E_MEM:
        xFDIVR_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);        // fdivr  offset[gc]
        break;
    case E_MEMIX:
        xFDIVR_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // fdivr  offset[gc,esi]
        break;
    default:
        assert(!"lGenDivr()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenDivr

#if defined(NV_INTERNAL_OPCODES)

/*
** lGenRccr() - Divide TOS into E, clamped.
*/

static void lGenRccr(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;
    int test_neg, get_answer, done;

    // TOS = 1.0f/x;

    lGenDivr(fCode, e);

    X86_CODE_LOAD(fCode);

    // iexp = ((VIEW_AS_INT(f) & 0x7f800000) >> 23) - F_EXP_BIAS;
    // if (iexp >= 64) {
    //     VIEW_AS_INT(f) = ((64 + F_EXP_BIAS) << 23) |
    //                           (VIEW_AS_INT(f) & 0x80000000);
    // } else {
    //     if (iexp <= -64) {
    //         VIEW_AS_INT(f) = ((-64 + F_EXP_BIAS) << 23) |
    //                               (VIEW_AS_INT(f) & 0x80000000);
    //     }
    // }

    xFST_rm(rmSIB) xSIB_esp;                    //    fst  [esp]
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;            //    mov  eax, [esp]
    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //    and  eax, 0x7fffffff

    // Clamp min magnitude to 0x1f800000;

    xCMP_rm_imm(rmREG(rEAX), 0x1f800000);       //    cmp  eax, 0x1f800000
    xLABEL(test_neg);
    xJG(0)                                      //    jl   test_neg
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;            //    mov  eax, [esp]
    xAND_rm_imm(rmREG(rEAX), 0x80000000);       //    and  eax, 0x80000000
    xOR_rm_imm(rmREG(rEAX), 0x1f800000);        //    or   eax, 0x1f800000
    xLABEL(get_answer);
    xJMP8(0);                                   //    jmp  get_answer

    // Clamp max magnitude to 0x5f800000;

    xTARGET_b8(test_neg);                       // test_neg:
    xCMP_rm_imm(rmREG(rEAX), 0x5f800000);       //    cmp  eax, 0x5f800000
    xLABEL(done);
    xJL(0)                                      //    jl   done
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;            //    mov  eax, [esp]
    xAND_rm_imm(rmREG(rEAX), 0x80000000);       //    and  eax, 0x80000000
    xOR_rm_imm(rmREG(rEAX), 0x5f800000);        //    or   eax, 0x5f800000

    xTARGET_b8(get_answer);                     // get_answer:
    xMOV_rm_r(rmSIB, rEAX) xSIB_esp;            //    mov  eax, [esp]
    xFSTP_st(0);                                //    fstp st(0)
    xFLD_rm(rmSIB) xSIB_esp;                    //    fld  [esp]

    // Answer in TOS:

    xTARGET_b8(done);                            // done:

    X86_CODE_RESTORE(fCode);
} // lGenRccr
#endif // NV_INTERNAL_OPCODES

/*
** lGenAbsSqrt() - Take the Square Root of ABS(TOS).
*/

static void lGenAbsSqrt(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFABS();
    xFSQRT();
    X86_CODE_RESTORE(fCode);
} // lGenSqrt

/*
** lGenIFloor() - ireg = ifloor(TOS).  Pops TOS and scratches esp(0-7).
**
** Arguments:
**     [tos]  = x
**
** Results:
**     [esp]  = floor(x)
**
** Scratches:
*/

static void lGenIFloor(Code *fCode, int iReg, int PopFP)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xMOV_rm_imm(rmREG(iReg), 0x047f);   // mov   iReg, 0x047f ; Round -INF, 24b
    xMOV_rm_r(rmSIB, iReg) xSIB_esp;    // mov   [esp], iReg
    xFSTCW_rm(rmSIB8) xSIB8_esp(4);     // fstcw 4[esp]     ; Save old FPCW
    xFLDCW_rm(rmSIB) xSIB_esp;          // fldcw [esp]      ; Load Round -INF, 24
    if (PopFP) {
        xFISTP_rm(rmSIB) xSIB_esp;      // fistp [esp]      ; floor(x)
    } else {
        xFIST_rm(rmSIB) xSIB_esp;       // fist  [esp]      ; floor(x)
    }
    xFLDCW_rm(rmSIB8) xSIB8_esp(4);     // fldcw 4[esp]     ; Restore FPCW
//  xMOV_r_rm(iReg, rmSIB) xSIB_esp;    // mov   iReg, [esp]
    X86_CODE_RESTORE(fCode);
} // lGenIFloor

////////////////////////// NV20 Level Code Generation /////////////////////////

/*
** lGenFloatOne()
*/

static void lGenFloatOne(VtxProgCompileX86 *env, Expr *r)
{
    r->kind = E_MEM;
    r->eMem.Negate = FALSE;
    r->eMem.offset = env->float_one_offset;
} // lGenFloatOne

/*
** lGenScalarSrcReg()
*/

static void lGenScalarSrcReg(VtxProgCompileX86 *env, Expr *r, ScalarSrcReg *reg)
{
    Expr v;
    int ii;

    lGenSrcReg(env, &v, &reg->reg);
    switch (v.kind) {
    case E_MEM:
        r->kind = E_MEM;
        r->eMem.Negate = reg->Signed;
        ii = reg->com;
        r->eMem.offset = v.eMem.offset + (ii & 3)*sizeof(float);
        break;
    default:
        assert(!"lGenScalarSrcReg()");
        break;
    }
} // lGenScalarSrcReg

/*
** lGenSwizzleSrcReg()
*/

static void lGenSwizzleSrcReg(VtxProgCompileX86 *env, Vector *a, SwizzleSrcReg *reg)
{
    Expr v;
    int ii;

    lGenSrcReg(env, &v, &reg->reg);
    switch (v.kind) {
    case E_MEM:
        a->x.kind = a->y.kind = a->z.kind = a->w.kind = E_MEM;
        a->x.eMem.Negate = a->y.eMem.Negate = a->z.eMem.Negate = a->w.eMem.Negate = reg->Signed;
        ii = reg->com4;
        a->x.eMem.offset = v.eMem.offset + (ii & 3)*sizeof(float);
        a->y.eMem.offset = v.eMem.offset + ((ii >> 2) & 3)*sizeof(float);
        a->z.eMem.offset = v.eMem.offset + ((ii >> 4) & 3)*sizeof(float);
        a->w.eMem.offset = v.eMem.offset + ((ii >> 6) & 3)*sizeof(float);
        break;
    case E_MEMIX:
        a->x.kind = a->y.kind = a->z.kind = a->w.kind = E_MEMIX;
        a->x.eMem.Negate = a->y.eMem.Negate = a->z.eMem.Negate = a->w.eMem.Negate = reg->Signed;
        ii = reg->com4;
        a->x.eMem.offset = v.eMem.offset + (ii & 3)*sizeof(float);
        a->y.eMem.offset = v.eMem.offset + ((ii >> 2) & 3)*sizeof(float);
        a->z.eMem.offset = v.eMem.offset + ((ii >> 4) & 3)*sizeof(float);
        a->w.eMem.offset = v.eMem.offset + ((ii >> 6) & 3)*sizeof(float);
        break;
    default:
        assert(!"lGenSwizzleSrcReg()");
        break;
    }
} // lGenSwizzleSrcReg

/*
** lGenStoreMaskedDstReg()
*/

static void lGenStoreMaskedDstReg(Code *fCode, MaskedDstReg *reg, Vector *a)
{
    int lmask = reg->mask;
    Expr v;

    lGenDstReg(fCode->environment, &v, reg->reg);
    lGenAddOffset(&v, 12);
    if (lmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, TRUE, TRUE);
        lGenStore(fCode, &v, &a->w, FALSE);
    }
    lGenAddOffset(&v, -4);
    if (lmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, TRUE, TRUE);
        lGenStore(fCode, &v, &a->z, FALSE);
    }
    lGenAddOffset(&v, -4);
    if (lmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, TRUE, TRUE);
        lGenStore(fCode, &v, &a->y, FALSE);
    }
    lGenAddOffset(&v, -4);
    if (lmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, TRUE, TRUE);
        lGenStore(fCode, &v, &a->x, FALSE);
    }
} // lGenStoreMaskedDstReg

/*
** lGenStoreMaskedDstRegScalar()
*/

static void lGenStoreMaskedDstRegScalar(Code *fCode, MaskedDstReg *reg, Expr *a)
{
    int lmask = reg->mask & DST_XYZW_BITS;
    Expr v;

    lGenDstReg(fCode->environment, &v, reg->reg);
    if (lmask & DST_X_BIT) {
        lmask &= ~DST_X_BIT;
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode, &v, a, lmask);
    }
    lGenAddOffset(&v, 4);
    if (lmask & DST_Y_BIT) {
        lmask &= ~DST_Y_BIT;
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode, &v, a, lmask);
    }
    lGenAddOffset(&v, 4);
    if (lmask & DST_Z_BIT) {
        lmask &= ~DST_Z_BIT;
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode, &v, a, lmask);
    }
    lGenAddOffset(&v, 4);
    if (lmask & DST_W_BIT) {
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode,&v, a, FALSE);
    }
} // lGenStoreMaskedDstRegScalar

/*
** lGenAddOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenAddOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask)
{
    int NegateA = lIsNegated(a);
    int NegateB = lIsNegated(b);

    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenAddVariant(fCode, &b->x, NegateA, NegateB);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenAddVariant(fCode, &b->y, NegateA, NegateB);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenAddVariant(fCode, &b->z, NegateA, NegateB);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenAddVariant(fCode, &b->w, NegateA, NegateB);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenAddOp

/*
** lGenAlrOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenAlrOp(Code *fCode, Expr *a)
{
    X86_CODE_DECLARE;
    int test_neg, done1, done2;

    assert(LOCAL_VAR_SIZE >= 8);

    // Min usable value: -63, since A0.x+63 -> 0
    // Max usable value: 159, since A0.x-64 -> 95  (159 = 95 + 64)
    // Out of range values changed to -64, so we can index full speed
    // into 128 registers of 0's that are padded on each end.

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenIFloor(fCode, rESI, 1);
    X86_CODE_LOAD(fCode);
    xMOV_r_rm(rESI, rmSIB) xSIB_esp;//   mov   esi, [esp]

    xCMP_rm_imm(rmREG(rESI), 159);  //   cmp  esi, 159 ; Is value > 159?
    xLABEL(test_neg);
    xJLE(0);                        //   jle  test_neg
    xMOV_rm_imm(rmREG(rESI), -64);  //   mov  esi, -64
    xLABEL(done1);
    xJMP8(0);                       //   jmp  get_answer

    xTARGET_b8(test_neg);           // test_neg:
    xCMP_rm_imm(rmREG(rESI), -63);  //   cmp  esi, -63 ; Is value < -63?
    xLABEL(done2);
    xJGE(0);                        //   jge  test_neg
    xMOV_rm_imm(rmREG(rESI), -64);  //   mov  esi, -64

    xTARGET_b8(done1);              // done:
    xTARGET_b8(done2);
    xSHL_rm_imm8(rmREG(rESI), 4);   //   shl  esi, 4  ; 16 bytes/register
    X86_CODE_RESTORE(fCode);
} // lGenAlrOp

/*
** lGenDotProductOp() - Simple version:  Assumes all args in memory, leaves result on TOS
*/

static void lGenDotProductOp(Code *fCode, Expr *v, Vector *a, Vector *b, int size)
{
    int Negate = lIsNegated(a) ^ lIsNegated(b);

    lGenLoad(fCode, &a->x, FALSE, FALSE);
    lGenMul(fCode, &b->x);

    lGenLoad(fCode, &a->y, FALSE, FALSE);
    lGenMul(fCode, &b->y);

    lGenLoad(fCode, &a->z, FALSE, FALSE);
    lGenMul(fCode, &b->z);

    if (size == 4) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenMul(fCode, &b->w);
        lGenAdd(fCode, &a->z);
    } else {
        if (size == 0) {
            // DPH
            lGenAdd(fCode, &b->w);
        }
    }

    lGenAdd(fCode, &a->y);
    lGenAdd(fCode, &a->x);
    if (Negate)
        lGenChs(fCode);

    v->kind = E_FREG;
    v->fReg.regNo = 0;
} // lGenDotProductOp

/*
** lGenDstOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenDstOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask)
{
    X86_CODE_DECLARE;

    int NegateA = lIsNegated(a);
    int NegateB = lIsNegated(b);

    if (fmask & DST_X_BIT) {
        X86_CODE_LOAD(fCode);
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        X86_CODE_RESTORE(fCode);
        r->x.kind = E_FREG; // Could do: xor eax, eax
    } else {
        r->x.kind = E_NONE;
    }

    if (fmask & DST_Y_BIT) {
#if defined(INCLUDE_MULTIPLY_BY_ZERO_CODE)
        //
        // Special case multiply:  If either value is +/- 0.0, result is 0.0
        //

        lGenTestForZeroMul(fCode, &a->y, &b->y, NegateA ^ NegateB);
        r->y.kind = E_FREG;
#else
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenMul(fCode, &b->y);
        if (NegateA ^ NegateB)
            lGenChs(fCode);
        r->y.kind = E_FREG;
#endif // INCLUDE_MULTIPLY_BY_ZERO_CODE
    } else {
        r->y.kind = E_NONE;
    }

    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, TRUE);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }

    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &b->w, FALSE, TRUE);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenDstOp

/*
** lGenLitOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenLitOp(Code *fCode, Vector *r, Vector *a, int fmask)
{
    X86_CODE_DECLARE;

    // Create a temp area on the stack and store all args there:

    lGenLoad(fCode, &a->x, FALSE, TRUE);
    lGenLoad(fCode, &a->y, FALSE, TRUE);
    lGenLoad(fCode, &a->z, FALSE, TRUE);
    lGenLoad(fCode, &a->w, FALSE, TRUE);

    assert(LOCAL_VAR_SIZE >= 32);

    X86_CODE_LOAD(fCode);
    xFSTP_rm(rmSIB8) xSIB8_esp(12);             // fstp 12[esp]  w
    xFSTP_rm(rmSIB8) xSIB8_esp(8);              // fstp 8[esp]   z
    xFSTP_rm(rmSIB8) xSIB8_esp(4);              // fstp 4[esp]   y
    xFSTP_rm(rmSIB) xSIB_esp;                   // fstp [esp]    x

    // Call a "C" function to compute this one:

    xPUSH_r(rESP);                              // push esp
    xMOV_rm_imm(rmREG(rEAX), (int) &lLitOpFun); // mov  eax, &lLitOpFun
    xCALL_rm(rmREG(rEAX));
    xADD_rm_imm8(rmREG(rESP), 4);

    // Load the needed results and pop the stack:

    if (fmask & DST_X_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(16);          // fld  16[esp]  x' == 1.0f
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(20);          // fld  20[esp]  y'
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(24);          // fld  24[esp]  z'
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(28);          // fld  28[esp]  w' == 1.0f
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
    X86_CODE_RESTORE(fCode);

} // lGenLitOp

/*
** lGenMinMaxOp() - Simple version:  Assumes all args in memory,
**         leaves result on TOS.
*/

static void lGenMinMaxOp(Code *fCode, Vector *r, Vector *a,
                         Vector *b, int fmask, int IsMax)
{
    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, TRUE);
        lGenMinMax(fCode, &b->x, IsMax);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, TRUE);
        lGenMinMax(fCode, &b->y, IsMax);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, TRUE);
        lGenMinMax(fCode, &b->z, IsMax);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, TRUE);
        lGenMinMax(fCode, &b->w, IsMax);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenMinMaxOp

/*
** lGenMulOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenMulOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask)
{
    int Negate = lIsNegated(a) ^ lIsNegated(b);

    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenMul(fCode, &b->x);
        if (Negate)
            lGenChs(fCode);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenMul(fCode, &b->y);
        if (Negate)
            lGenChs(fCode);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenMul(fCode, &b->z);
        if (Negate)
            lGenChs(fCode);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenMul(fCode, &b->w);
        if (Negate)
            lGenChs(fCode);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenMulOp

/*
** lGenSgeOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenSgeOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask, int IsSLT)
{
    int NegateA = lIsNegated(a);
    int NegateB = lIsNegated(b);

    assert(LOCAL_VAR_SIZE >= 4);

    if (fmask & DST_X_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->x, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->x, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->x, NegateA, NegateB, IsSLT);
#endif
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->y, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->y, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->y, NegateA, NegateB, IsSLT);
#endif
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->z, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->z, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->z, NegateA, NegateB, IsSLT);
#endif
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->w, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->w, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->w, NegateA, NegateB, IsSLT);
#endif
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenSgeOp

/*
** lGenMadOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenMadOp(Code *fCode, Vector *r, Vector *a, Vector *b, Vector *c, int fmask)
{
    int NegateAB = lIsNegated(a) ^ lIsNegated(b), NegateC = lIsNegated(c);

    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenMul(fCode, &b->x);
        lGenAddVariant(fCode, &c->x, NegateAB, NegateC);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenMul(fCode, &b->y);
        lGenAddVariant(fCode, &c->y, NegateAB, NegateC);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenMul(fCode, &b->z);
        lGenAddVariant(fCode, &c->z, NegateAB, NegateC);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenMul(fCode, &b->w);
        lGenAddVariant(fCode, &c->w, NegateAB, NegateC);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenMadOp

#if defined(NV_INTERNAL_OPCODES)

/*
** lGenRccOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenRccOp(Code *fCode, Expr *r, Expr *a)
{
    Expr e;

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenFloatOne(fCode->environment, &e);
    lGenRccr(fCode, &e);
    r->kind = E_FREG;
} // lGenRccOp

#endif // NV_INTERNAL_OPCODES

/*
** lGenRcpOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenRcpOp(Code *fCode, Expr *r, Expr *a)
{
    Expr e;

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenFloatOne(fCode->environment, &e);
    lGenDivr(fCode, &e);
    r->kind = E_FREG;
} // lGenRcpOp

/*
** lGenRsqOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenRsqOp(Code *fCode, Expr *r, Expr *a)
{
    Expr e;

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenAbsSqrt(fCode);
    lGenFloatOne(fCode->environment, &e);
    lGenDivr(fCode, &e);
    r->kind = E_FREG;
} // lGenRsqOp

/*
** lGenLogOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenLogOp(Code *fCode, Vector *r, Expr *a, int fmask)
{
    X86_CODE_DECLARE;
    int zero, done;

    // Load x into EAX:

    lGenLoadIReg(fCode, a, FALSE);
    X86_CODE_LOAD(fCode);

    assert(LOCAL_VAR_SIZE >= 4);

    // Mask off sign bit:

    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //   and  eax, 0x7fffffff
    xLABEL(zero);
    xJZ(0);                                     //   jz   zero

    // tr.x = ((VIEW_AS_INT(x) & 0x7f800000) >> 23) - F_EXP_BIAS;

    if (fmask & DST_X_BIT) {
        xMOV_r_rm(rEDX, rmREG(rEAX));           //   mov  edx, eax
        xSHR_rm_imm8(rmREG(rEDX), 23);          //   shr  edx, 23
        xSUB_rm_imm8(rmREG(rEDX), F_EXP_BIAS);  //   sub  edx, F_EXP_BIAS
        xMOV_rm_r(rmSIB, rEDX) xSIB_esp;        //   mov  [esp], edx
        xFILD_rm(rmSIB) xSIB_esp;               //   fild [esp]
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }

    // VIEW_AS_INT(tr.y) = (VIEW_AS_INT(x) & 0x007fffff) | 0x3f800000;

    if (fmask & DST_Y_BIT) {
        xMOV_r_rm(rEDX, rmREG(rEAX));           //   mov  edx, eax
        xAND_rm_imm(rmREG(rEDX), 0x007fffff);   //   and  edx, 0x007fffff
        xOR_rm_imm(rmREG(rEDX), 0x3f800000);    //   or   edx, 0x3f800000
        xMOV_rm_r(rmSIB, rEDX) xSIB_esp;        //   mov  [esp], edx
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }

    // tr.z = __GL_LOGF(x)*LOG_E_BASE_2;

    if (fmask & DST_Z_BIT) {
        xMOV_rm_r(rmSIB, rEAX) xSIB_esp;        //   mov  [esp], eax
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        xFYL2X();                               //   fyl2x
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    xLABEL(done);
    xJMP8(0);                                   //   jmp  done
    xTARGET_b8(zero);                           // zero:

    // tr.x = F_NEG_INFINITY;
                
    if (fmask & (DST_X_BIT | DST_Z_BIT)) {
        xMOV_rm_imm(rmREG(rEAX), FP_BITS_LOG0); //   mov  eax, 0xff800000
        xMOV_rm_r(rmSIB, rEAX) xSIB_esp;        //   mov  [esp], eax
    }

    if (fmask & DST_X_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }

    // tr.y = 1.0f;
                
    if (fmask & DST_Y_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }

    // tr.z = F_NEG_INFINITY;

    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }

    xTARGET_b8(done);                           // done:

    // tr.w = 1.0f;

    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }

    X86_CODE_RESTORE(fCode);
} // lGenLogOp

/*
** lGenExpOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenExpOp(Code *fCode, Vector *r, Expr *a, int fmask)
{
    X86_CODE_DECLARE;
    int nottoobig, computeit, computeit2, done_a, done_b;
    float f;

    // Load x into EAX:

    lGenLoadIReg(fCode, a, FALSE);
    X86_CODE_LOAD(fCode);

    assert(LOCAL_VAR_SIZE >= 12);

    // if (floor(x) > FLT_MAX_EXP)

    f = FLT_MAX_EXP + 1;
    xCMP_rm_imm(rmREG(rEAX), VIEW_AS_INT(f));       // cmp  eax, 0xXXXXXXXX
    xLABEL(nottoobig);
    xJL(0);                                         //   jl   nottoobig

    // tr.x = F_POS_INFINITY;
    // tr.y = 0.0f;
    // tr.z = F_POS_INFINITY;
    // tr.w = 1.0f;

    if (fmask & (DST_X_BIT | DST_Z_BIT)) {
        xMOV_rm_imm(rmREG(rEAX), 0x7f800000);       //   mov  eax, 0x7f800000
        xMOV_rm_r(rmSIB, rEAX) xSIB_esp;            //   mov  [esp], eax
    }
    if (fmask & (DST_Y_BIT)) {
        xMOV_rm_imm(rmREG(rEAX), 0x00000000);       //   mov  eax, 0x00000000
        xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(4);       //   mov  4[esp], eax
    }
    if (fmask & DST_X_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                    //   fld  [esp]
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(4);               //   fld  4[esp]
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                   //   fld  [esp]
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }

    xLABEL(done_a);
    xJMP(0);                                        //   jmp  done;  Can be bigger that 128 bytes
    xTARGET_b8(nottoobig);                          // nottoobig:

    // if (x >= 0) goto computeit

    xTEST_rm_imm(rmREG(rEAX), 0x80000000);          //   tst  eax, 0x80000000
    xLABEL(computeit);
    xJZ(0);                                         //   jz   computeit

    // if (floor(x) < FLT_MIN_EXP)

    xMOV_rm_r(rmREG(rEDX), rEAX);                   //   mov  edx, eax
    xAND_rm_imm(rmREG(rEDX), 0x7fffffff);           //   and  edx, 0x7fffffff
    f = FLT_MIN_EXP;
    VIEW_AS_INT(f) = VIEW_AS_INT(f) & 0x7fffffff;
    xCMP_rm_imm(rmREG(rEDX), VIEW_AS_INT(f));       // cmp  eax, 0xXXXXXXXX
    xLABEL(computeit2);
    xJL(0);                                         //   jl   computeit

    // X is too small:  X < FLT_MIN_EXP
    //
    // tr.x = tr.y = tr.z = tr.w = { 0.0f, floor(x), 0.0f, 1.0f };

    if (fmask & DST_X_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_zero_offset); //   fld   gc->float_zero
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(8);           //   mov   8[esp], x
        xFLD_rm(rmSIB8) xSIB8_esp(8);                   //   fld   8[esp]      ; TOS = x
        X86_CODE_RESTORE(fCode);
        lGenIFloor(fCode, rEAX, 0);                     //   [esp] = floor(x), [tos] = x
        X86_CODE_LOAD(fCode);
        xFILD_rm(rmSIB) xSIB_esp;                       //   fld   [esp];  x, floor(x)
        xFSUBP_st(1);                                   //   fsubp [tos - 1];  x - floor(x)
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_zero_offset); //   fld   gc->float_zero
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }

    xLABEL(done_b);
    xJMP8(0);                                       //   jmp  done
    xTARGET_b8(computeit);                          // computeit:
    xTARGET_b8(computeit2);                         // computeit2:

    // f = floor(x);
    // ii = f;
    // ii = (ii << 23) + 0x3f800000;
    // tr.x = __GL_VIEW_AS_FLOAT(ii);
    // tr.y = x - f;
    // tr.z = tr.x*__GL_EXPF(tr.y*LOG_2_BASE_E);
    // tr.w = 1.0f;

    xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(8);           //   mov  8[esp], x
    xFLD_rm(rmSIB8) xSIB8_esp(8);                   //   fld  8[esp]      ; TOS = x
    X86_CODE_RESTORE(fCode);

    lGenIFloor(fCode, rEAX, 1);                     //   [esp] = ifloor(TOS)

    X86_CODE_LOAD(fCode);
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;                //   mov  eax, [esp]
    xSHL_rm_imm8(rmREG(rEAX), 23);                  //   shl  eax, 23
    xADD_rm_imm(rmREG(rEAX), 0x3f800000);           //   or   eax, 0x3f800000
    xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(4);           //   mov  4[esp], eax; float 2**ii

    xFLD_rm(rmSIB8) xSIB8_esp(4);                   //   fld  4[esp];  X: 2.0**ii
    xFILD_rm(rmSIB) xSIB_esp;                       //   fild [esp];      floor(x)
    xFSUBR_rm(rmSIB8) xSIB8_esp(8);                 //   fsubr 8[esp]; Y: x - floor(x)
    xFLD_st(0);                                     //   fld  st(0);   Z: x - floor(x)
    xF2XM1();                                       //   fyl2x;           2**(x - floor(x)) - 1.0
    xFADD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); // fadd  1,0f;      2**(x - floor(x))
    xFMUL_st(2);                                    //   fmul  st(2);  Z: (2**ii)*(2**(x - floor(x)))

    if (fmask & DST_X_BIT) {
        r->x.kind = E_FREG;
    } else {
        xFXCH_st(2);                                //   fxch st(2)
        xFSTP_st(0);                                //   fstp st(0); Pop
        xFXCH_st(1);                                //   fxch st(1)
        r->x.kind = E_NONE;
    }

    if (fmask & DST_Y_BIT) {
        r->y.kind = E_FREG;
    } else {
        xFXCH_st(1);                                //   fxch st(1)
        xFSTP_st(0);                                //   fstp st(0); Pop
        r->y.kind = E_NONE;
    }
    
    if (fmask & DST_Z_BIT) {
        r->z.kind = E_FREG;
    } else {
        xFSTP_st(0);                                //   fstp st(0); Pop
        r->z.kind = E_NONE;
    }

    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
    
    xTARGET_jmp(done_a);                            // done_a:
    xTARGET_b8(done_b);                             // done_b:

    X86_CODE_RESTORE(fCode);
} // lGenExpOp

/*
** lInitLiveRegs() - Initialize:
**         1) temp registers that are read before written to 0,0,0,0
**         2) output registers that aren't written to 0,0,0,1
*/

static void lInitLiveRegs(Code *fCode, ParsedProgram *parsed)
{
    X86_CODE_DECLARE;
    unsigned int ii, bits, addr, mask, maskbar;
    int HaveZero = 0, HaveOne = 0;

    X86_CODE_LOAD(fCode);

    // Clear A0 register:

    xXOR_rm_r(rmREG(rESI), rESI);       // xor esi, esi

    // Clear temp registers that are read before they are written to 0:

    bits = parsed->liveOnEntry & ((1 << __GL_NUMBER_OF_TEMPORARY_REGISTERS) - 1);
    if (bits) {
        HaveZero = 1;
        xXOR_r_rm(rEAX, rmREG(rEAX));
        for (ii = 0; bits; ii++, bits >>= 1) {
            if (bits & 1) {
                addr = ii*sizeof(float)*4 + fCode->environment->temp_offset;
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr);                   // mov  offset[gc], eax
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float));   // mov  offset[gc], eax
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float)*2); // mov  offset[gc], eax
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float)*3); // mov  offset[gc], eax
            }
        }
    }

    // Set unset parts of result registers to 0/0/0/1:

    for (ii = 0; ii < __GL_NUMBER_OF_RESULT_REGISTERS; ii++) {
        if (parsed->resultRegsWritten[ii] != DST_XYZW_BITS) {

            // Only fill in partially written result regs:

            mask = (parsed->resultRegsWritten[ii] != DST_NONE_BITS);
            if (mask) {
                maskbar = DST_XYZW_BITS & ~mask;
                if ((maskbar & DST_XYZ_BITS) && !HaveZero) {
                    HaveZero = 1;
                    xXOR_r_rm(rEAX, rmREG(rEAX));
                }
                if ((maskbar & DST_W_BIT) && !HaveOne) {
                    HaveOne = 1;
                    xMOV_rm_imm(rmREG(rECX), 0x3f800000);
                }
                addr = ii*sizeof(float)*4 + fCode->environment->result_offset;
                if (maskbar & DST_X_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr);                    // mov  offset[gc], eax
                }
                if (maskbar & DST_Y_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float));    // mov  offset[gc], eax
                }
                if (maskbar & DST_Z_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float)*2);  // mov  offset[gc], eax
                }
                if (maskbar & DST_W_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rECX) xOFS32(addr + sizeof(float)*3);  // mov  offset[gc], ecx
                }
            }
        }
    }

    X86_CODE_RESTORE(fCode);
} // lInitLiveRegs

/*
** lGrowCode() - Increase the generated code buffer.
*/

static int lGrowCode(Code *fCode, int fSize)
{
    unsigned char *newData;
    unsigned int ii;

    newData = (unsigned char *) fCode->environment->malloc(fCode->environment->mallocArg, fSize);
    if (!newData)
        return FALSE;
    for (ii = 0; ii < fCode->ilcCount; ii++)
        newData[ii] = fCode->ilcData[ii];
    fCode->environment->free(fCode->environment->mallocArg, fCode->ilcData);
    fCode->ilcData = newData;
    fCode->ilcMax = fSize;
    return TRUE;
} // lGrowCode

/*
** vp_CompileX86() - Compile a vertex program into X86 instructions.
*/

int vp_CompileX86(VtxProgCompileX86 *environment, ParsedProgram *parsed,
                int numInstructions, VertexProgramOutput *outArgs)
{
    unsigned char *theCode = NULL;
    unsigned int  ilcCount, ilcMax;
    unsigned char *ilcData;
    Code lCode;

    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    Vector a, b, c, r;
    Expr e;
    int lop, lsize, pc;
    unsigned int ii;

    ilcCount = 0;
    ilcMax = 16385;
    ilcData = (unsigned char *) environment->malloc(environment->mallocArg, ilcMax);
    if (!ilcData)
        return FALSE;

    VtxProgImports.logf = environment->logf;
    VtxProgImports.expf = environment->expf;

    xPUSH_r(rEBP);
    xMOV_r_rm(rEBP, rmREG(rESP));
    //xPUSH_r(rEAX);
    xPUSH_r(rEBX);
    //xPUSH_r(rECX);
    //xPUSH_r(rEDX);
    xPUSH_r(rESI);          // Holds address register X 16
    xPUSH_r(rEDI);

    xMOV_r_rm(rEBX, rmIND8(rEBP)) xOFS8(8)          // mov  ebx, gc

    xADD_rm_imm8(rmREG(rESP), -LOCAL_VAR_SIZE);     // Alloc local stack space

    X86_CODE_RESTORE(&lCode);
    lCode.environment = environment;

    lInitLiveRegs(&lCode, parsed);

    inst = parsed->firstInstruction;
    for (pc = 0; pc < numInstructions; inst++, pc++) {

        // Make sure there's room for the next instruction:

        if (lCode.ilcCount + 200 >= lCode.ilcMax) {
            if (!lGrowCode(&lCode, ((lCode.ilcMax*3 >> 1) + 15) & ~15)) {
                environment->free(environment->mallocArg, lCode.ilcData);
                return FALSE;
            }
        }

        lGenNop(&lCode); // Mark instructions
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &ainst->src);
            lGenAlrOp(&lCode, &a.x);
            break;

        // SCALAR ops:

        case OP_EXP:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenExpOp(&lCode, &r, &a.x, sinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &sinst->dst, &r);
            break;

        case OP_LOG:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenLogOp(&lCode, &r, &a.x, sinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &sinst->dst, &r);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenRccOp(&lCode, &e, &a.x);
            lGenStoreMaskedDstRegScalar(&lCode, &sinst->dst, &e);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_RCP:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenRcpOp(&lCode, &e, &a.x);
            lGenStoreMaskedDstRegScalar(&lCode, &sinst->dst, &e);
            break;

        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenRsqOp(&lCode, &e, &a.x);
            lGenStoreMaskedDstRegScalar(&lCode, &sinst->dst, &e);
            break;

        // VECTOR ops:

        case OP_LIT:
            vinst = (Vector_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &vinst->src);
            lGenLitOp(&lCode, &r, &a, vinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &vinst->dst, &r);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &vinst->src);
            lGenStoreMaskedDstReg(&lCode, &vinst->dst, &a);
            break;

        // BIN ops:

        case OP_ADD:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenAddOp(&lCode, &r, &a, &b, binst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_DP3:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDotProductOp(&lCode, &e, &a, &b, 3);
            lGenStoreMaskedDstRegScalar(&lCode, &binst->dst, &e);
            break;

        case OP_DP4:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDotProductOp(&lCode, &e, &a, &b, 4);
            lGenStoreMaskedDstRegScalar(&lCode, &binst->dst, &e);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDotProductOp(&lCode, &e, &a, &b, 0);
            lGenStoreMaskedDstRegScalar(&lCode, &binst->dst, &e);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDstOp(&lCode, &r, &a, &b, binst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_MAX:
        case OP_MIN:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenMinMaxOp(&lCode, &r, &a, &b, binst->dst.mask, lop == OP_MAX);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_MUL:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenMulOp(&lCode, &r, &a, &b, binst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_SGE:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenSgeOp(&lCode, &r, &a, &b, binst->dst.mask, FALSE);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenSgeOp(&lCode, &r, &a, &b, binst->dst.mask, TRUE);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &tinst->srcA);
            lGenSwizzleSrcReg(environment, &b, &tinst->srcB);
            lGenSwizzleSrcReg(environment, &c, &tinst->srcC);
            lGenMadOp(&lCode, &r, &a, &b, &c, tinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &tinst->dst, &r);
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            break;
        }
    }

    X86_CODE_LOAD(&lCode);

    xADD_rm_imm8(rmREG(rESP), LOCAL_VAR_SIZE);  // Free local stack space

    xPOP_r(rEDI)
    xPOP_r(rESI)
    //xPOP_r(rEDX)
    //xPOP_r(rECX)
    xPOP_r(rEBX)
    //xPOP_r(rEAX)

    xPOP_r(rEBP)
    xRET

    lsize = (ilcCount + 15) & ~15;
    theCode = (unsigned char *) environment->exec_malloc(environment->mallocArg, lsize);
    outArgs->residentSize = __internal_setup(lsize & 15); // so linker won't delete watermark
    if (theCode) {
        for (ii = 0; ii < ilcCount; ii++)
            theCode[ii] = ilcData[ii];
        outArgs->residentProgram = theCode;
        outArgs->residentSize = lsize;
    } else {
        outArgs->residentProgram = NULL;
        outArgs->residentSize = 0;
    }
    environment->free(environment->mallocArg, ilcData);

    return outArgs->residentProgram != NULL;
} // vp_CompileX86

/*
** vp_OutputCelsiusX86() - Compile a vertex program into X86 instructions.
*/

// Macros copied from nv32.h, nvhw.h, etc. so they don't have to be included by D3D:

#define __NV_COUNT_SHIFT                18
#define __NV_SUBCHANNEL_SHIFT           13
#define __NV_METHOD_SHIFT               0
#define __NV_METHOD(_SC,_M,_NUM)        (((_NUM) << __NV_COUNT_SHIFT) | ((_SC) << __NV_SUBCHANNEL_SHIFT) | (_M))

#define __NV056_SET_VERTEX4F(i)         (0x00000c18+(i)*4)
#define __NV056_SET_DIFFUSE_COLOR4F(i)  (0x00000c50+(i)*4)
#define __NV056_SET_DIFFUSE_COLOR3F(i)  (0x00000c60+(i)*4)
#define __NV056_SET_SPECULAR_COLOR4F(i) (0x00000c70+(i)*4)
#define __NV056_SET_SPECULAR_COLOR3F(i) (0x00000c80+(i)*4)
#define __NV056_SET_TEXCOORD0_2F(i)     (0x00000c90+(i)*4)
#define __NV056_SET_TEXCOORD0_4F(i)     (0x00000ca0+(i)*4)
#define __NV056_SET_TEXCOORD1_2F(i)     (0x00000cb8+(i)*4)
#define __NV056_SET_TEXCOORD1_4F(i)     (0x00000cc8+(i)*4)

#define C_METHOD(e, _M,_NUM)            __NV_METHOD((e)->channel_number, _M, _NUM)

#define OUT_OFFSET(n, k, e)             ((((n)*4) + (k))*sizeof(float) + (e)->result_offset)

int vp_OutputCelsiusX86(VtxProgCompileX86 *environment, ParsedProgram *parsed,
                        int numInstructions, VertexProgramOutput *outArgs)
{
    unsigned char *theCode = NULL;
    unsigned int  ilcCount, ilcMax;
    unsigned char *ilcData;
    Code lCode;

    unsigned int ii;
    int offset, lsize, mask, is_cube_map;

    ilcCount = 0;
    ilcMax = 1024;
    ilcData = (unsigned char *) environment->malloc(environment->mallocArg, ilcMax);
    if (!ilcData)
        return FALSE;
    offset = 0;
    lCode.environment = environment;

    xPUSH_r(rEBP);
    xMOV_r_rm(rEBP, rmREG(rESP));
    //xPUSH_r(rEAX);
    xPUSH_r(rEBX);
    //xPUSH_r(rECX);
    //xPUSH_r(rEDX);
    //xPUSH_r(rESI);          // Holds address register X 16
    xPUSH_r(rEDI);      // Points to output area

    xMOV_r_rm(rEBX, rmIND8(rEBP)) xOFS8(8)          // mov  ebx, gc
    xMOV_r_rm(rEDI, rmIND8(rEBP)) xOFS8(12)         // mov  edi, nvCurrent

    xADD_rm_imm8(rmREG(rESP), -LOCAL_VAR_SIZE);     // Alloc local stack space

    // Output Color:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_COL0];
    if (mask) {
        if (mask & 0x08) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_DIFFUSE_COLOR4F(0),4)); // mov  eax, #SET_DIFFUSE_COLOR4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_DIFFUSE_COLOR3F(0),3)); // mov  eax, #SET_DIFFUSE_COLOR3F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,0,environment));      // mov  eax, o[COL0].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,1,environment));      // mov  eax, o[COL0].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,2,environment));      // mov  eax, o[COL0].z
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                      // mov  nvCurrent[3], eax
        if (mask & 0x08) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,3,environment));  // mov  eax, o[COL0].w
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 4;
        }
    }

    // Output Secondary Color:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_COL1];
    if (mask) {
        if (mask & 0x08) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_SPECULAR_COLOR4F(0),4)); // mov  eax, #SET_SPECULAR_COLOR4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_SPECULAR_COLOR3F(0),3)); // mov  eax, #SET_SPECULAR_COLOR3F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,0,environment));      // mov  eax, o[COL1].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,1,environment));      // mov  eax, o[COL1].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,2,environment));      // mov  eax, o[COL1].z
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                      // mov  nvCurrent[3], eax
        if (mask & 0x08) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,3,environment));  // mov  eax, o[COL1].w
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 4;
        }
    }

    // Output Texture 0:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_TEX0];
    if (mask) {
        if (mask & 0x0c) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD0_4F(0),4));    // mov  eax, #SET_TEXCOORD0_4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD0_2F(0),2));    // mov  eax, #SET_TEXCOORD0_2F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,0,environment));      // mov  eax, o[TEX0].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,1,environment));      // mov  eax, o[TEX0].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        if (mask & 0x0c) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,2,environment));  // mov  eax, o[TEX0].z
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                  // mov  nvCurrent[3], eax
            // See if cube maps are enabled on texture 0:
            xTEST_rm_imm(rmIND32(rEBX), environment->enables_offset);
                         xOFS32(__GL_PROGRAM_ENABLE_TEXTURE0); // Fields are BACKWARDS in macro!!!
            xLABEL(is_cube_map);
            xJNZ(0);                                                             // jnz  is_cube_map
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,3,environment));  // mov  eax, o[TEX0].w
            xTARGET_b8(is_cube_map);                                             // is_cube_map:
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 3;
        }
    }

    // Output Texture 1:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_TEX1];
    if (mask) {
        if (mask & 0x0c) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD1_4F(0),4));    // mov  eax, #SET_TEXCOORD1_4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD1_2F(0),2));    // mov  eax, #SET_TEXCOORD1_2F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,0,environment));     // mov  eax, o[TEX1].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,1,environment));     // mov  eax, o[TEX1].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        if (mask & 0x0c) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,2,environment)); // mov  eax, o[TEX1].z
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                  // mov  nvCurrent[3], eax
            // See if cube maps are enabled on texture 1:
            xTEST_rm_imm(rmIND32(rEBX), environment->enables_offset);
                         xOFS32(__GL_PROGRAM_ENABLE_TEXTURE1); // Fields are BACKWARDS in macro!!!
            xLABEL(is_cube_map);
            xJNZ(0);                                                             // jnz  is_cube_map
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,3,environment)); // mov  eax, o[TEX1].w
            xTARGET_b8(is_cube_map);                                             // is_cube_map:
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 3;
        }
    }

    // Output vertex data:

#if 000
    // invW = 1.0f/pRegs->result[0].w;
    // NV_CELSIUS_METHOD_4F(NV056_SET_VERTEX4F(0),
    //                      pRegs->result[__GL_ATTRIB_OUTPUT_HPOS].x*vp->xScale*invW + vp->xCenter - xAdjust,
    //                      pRegs->result[__GL_ATTRIB_OUTPUT_HPOS].y*vp->yScale*invW + vp->yCenter - yAdjust,
    //                      pRegs->result[__GL_ATTRIB_OUTPUT_HPOS].z*vp->zScale*invW + vp->zCenter,
    //                     invW);
    
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->float_one_offset);     // fld   1.0f
    xFDIV_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,3,environment));      // fdiv  o[HPOS].w
    xFLD_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,0,environment));       // fld   o[HPOS].x
    xFLD_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,1,environment));       // fld   o[HPOS].y
    xFLD_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,2,environment));       // fld   o[HPOS].z
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->vp_scale_offset);      // fld   vpScale.x
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->vp_scale_offset+4);    // fld   vpScale.y
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->vp_scale_offset+8);    // fld   vpScale.z  ; Sz  Sy  Sx  Oz  Oy  Ox  1/Ow
    xFMULP_st(3);                                                     // fmulp st(3)      ; Sy  Sx  Oz*Sz  Oy  Ox  1/Ow
    xFMULP_st(3);                                                     // fmulp st(3)      ; Sx  Oz*Sz  Oy*Sy  Ox  1/Ow
    xFMULP_st(3);                                                     // fmulp st(3)      ; Oz*Sz  Oy*Sy  Ox*Sx  1/Ow
    xFMULP_st(3);                                                     // fmul  st(3)      ; Oz*Sz/Ow  Oy*Sy  Ox*Sx  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_center_offset+8);  // fadd  vpCenter.z ; Oz*Sz/Ow+Cz  Oy*Sy  Ox*Sx  1/Ow
    xFXCH_st(2);                                                      // fxch  st(2)      ; Ox*Sx  Oy*Sy  Oz*Sz/Ow+Cz  1/Ow
    xFMULP_st(3);                                                     // fmul  st(3)      ; Ox*Sx/Ow  Oy*Sy  Oz*Sz/Ow+Cz  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_center_offset);    // fadd  vpCenter.x ; Ox*Sx/Ow+Cx  Oy*Sy  Zout  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_adjust_offset);    // fsub  vpAdjust.x ; Ox*Sx/Ow+Cx-Ax  Oy*Sy  Zout  1/Ow
    xFXCH_st(1);                                                      // fxch  st(1)      ; Oy*Sy  Ox*Sx/Ow+Cx-Ax  Zout  1/Ow
    xFMULP_st(3);                                                     // fmul  st(3)      ; Oy*Sy/Ow  Xout  Zout  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_center_offset+4);  // fadd  vpCenter.y ; Oy*Sy/Ow+Cy  Xout  Zout  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_adjust_offset+4);  // fsub  vpAdjust.y ; Oy*Sy/Ow+Cy-Ay  Xout  Zout  1/Ow
    xFXCH_st(1);                                                      // fxch  st(1)      ; Xout  Yout  Zout  Wout
    xMOV_rm_imm(rmREG(rEAX), C_METHOD(__NV056_SET_VERTEX4F(0),4));    // mov   eax, #SET_VERTEX4F
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset);                    // mov   nvCurrent[0], eax
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+4);                         // fstp  nvCurrent[1]
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+8);                         // fstp  nvCurrent[2]
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+12);                        // fstp  nvCurrent[3]
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+16);                        // fstp  nvCurrent[4]
#endif
    xMOV_rm_imm(rmREG(rEAX),
                C_METHOD(environment,__NV056_SET_VERTEX4F(0),4));        // mov  eax, #SET_VERTEX4F
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                     // mov  nvCurrent[0], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,0,environment));  // mov  eax, o[HPOS].x
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                   // mov  nvCurrent[1], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,1,environment));  // mov  eax, o[HPOS].y
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                   // mov  nvCurrent[2], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,2,environment));  // mov  eax, o[HPOS].z
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                  // mov  nvCurrent[3], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,3,environment));  // mov  eax, o[HPOS].w
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
    offset += 5;

    // Clean-up and go home:

    xADD_rm_imm8(rmREG(rESP), LOCAL_VAR_SIZE);  // Free local stack space

    xPOP_r(rEDI)
    //xPOP_r(rESI)
    //xPOP_r(rEDX)
    //xPOP_r(rECX)
    xPOP_r(rEBX)
    //xPOP_r(rEAX)

    xPOP_r(rEBP)
    xRET

    lsize = (ilcCount + 15) & ~15;
    theCode = (unsigned char *) environment->exec_malloc(environment->mallocArg, lsize);
    if (theCode) {
        for (ii = 0; ii < ilcCount; ii++)
            theCode[ii] = ilcData[ii];
        outArgs->residentProgram = theCode;
        outArgs->residentSize = lsize;
    } else {
        outArgs->residentProgram = NULL;
        outArgs->residentSize = 0;
        offset = 0;
    }
    environment->free(environment->mallocArg, ilcData);

    return offset;
} // vp_OutputCelsiusX86
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\vesa\vesadata.h ===
#ifndef _VESADATA_H_
#define _VESADATA_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/


//*****************************************************************************
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

#ifndef BUFFER_HSYNC_NEGATIVE
// nvrm.h also defines these. So check if it is already defined.
#define BUFFER_HSYNC_NEGATIVE           1
#define BUFFER_HSYNC_POSITIVE           0
#define BUFFER_VSYNC_NEGATIVE           1
#define BUFFER_VSYNC_POSITIVE           0

#endif

typedef struct _mode_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} MODE_TIMING_VALUES;

unsigned int vesaGetGTFTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);
unsigned int vesaGetDMTTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);

unsigned int vesaGetNumGTFEntries(void);


#endif // _VESADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\vesa\vesadata.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

#include "vesadata.h"
#include "nvMultiMon.h"

//*****************************************************************************
//
// This file contains the display timing tables required for all supported
// VESA (DMT, GTF) modes.
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

//*****************************************************************************
//
// GTF Timings 
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use pure floating point).
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Sync Start, Sync End
// Vertical Total, Sync Start, Sync End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
// Blank End == Total.
//
unsigned int GTFTimingTable[][12] =
{
    // Settings for 2048x1536:
    {2048,1536,6000, 2800,2200,2424,1589,1537,1540,26695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7000, 2816,2208,2432,1599,1537,1540,31519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7200, 2816,2208,2432,1600,1537,1540,32440,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7500, 2832,2216,2440,1603,1537,1540,34048,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,8500, 2832,2216,2440,1612,1537,1540,38804,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1920x1440:
    {1920,1440,6000, 2624,2064,2272,1490,1441,1444,23459,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7000, 2640,2072,2280,1499,1441,1444,27702,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7200, 2640,2072,2280,1500,1441,1444,28512,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7500, 2640,2072,2280,1503,1441,1444,29759,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,8500, 2656,2072,2288,1512,1441,1444,34135,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 1920x1200:
    {1920,1200,6000, 2592,2048,2256,1242,1201,1204,19316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7000, 2608,2056,2264,1249,1201,1204,22802,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7200, 2624,2064,2272,1251,1201,1204,23635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7500, 2624,2064,2272,1253,1201,1204,24659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7600, 2624,2064,2272,1253,1201,1204,24988,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,8500, 2640,2072,2280,1260,1201,1204,28274,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,10000,2656,2072,2288,1271,1201,1204,33758,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,12000,2672,2080,2296,1286,1201,1204,41234,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1080:
    {1920,1080,6000, 2576,2040,2248,1118,1081,1084,17280,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7000, 2608,2056,2264,1124,1081,1084,20520,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7200, 2608,2056,2264,1126,1081,1084,21144,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7500, 2608,2056,2264,1128,1081,1084,22064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,8500, 2624,2064,2272,1134,1081,1084,25293,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,10000,2640,2072,2280,1144,1081,1084,30202,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,12000,2656,2072,2288,1157,1081,1084,36876,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1800x1440:
    {1800,1440,6000, 2456,1928,2128,1490,1441,1444,21957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7000, 2472,1936,2136,1499,1441,1444,25939,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7200, 2472,1936,2136,1500,1441,1444,26698,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7500, 2472,1936,2136,1503,1441,1444,27866,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,8500, 2488,1944,2144,1512,1441,1444,31976,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,10000,2504,1952,2152,1525,1441,1444,38186,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1200:
    {1600,1200,6000, 2160,1704,1880,1242,1201,1204,16096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7000, 2176,1712,1888,1249,1201,1204,19025,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7200, 2176,1712,1888,1251,1201,1204,19600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7500, 2192,1720,1896,1253,1201,1204,20599,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,8500, 2192,1720,1896,1260,1201,1204,23476,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,10000,2208,1728,1904,1272,1201,1204,28064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,12000,2224,1736,1912,1286,1201,1204,34321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,14000,2240,1744,1920,1301,1201,1204,40799,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x1024:
    {1600,1024,6000, 2144,1704,1872,1060,1025,1028,13636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7000, 2160,1704,1880,1066,1025,1028,16118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7200, 2160,1704,1880,1067,1025,1028,16594,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7500, 2176,1712,1888,1069,1025,1028,17446,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7600, 2176,1712,1888,1070,1025,1028,17695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,8500, 2176,1712,1888,1075,1025,1028,19883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,10000,2192,1720,1896,1085,1025,1028,23783,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,12000,2208,1728,1904,1097,1025,1028,29066,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x900:
    {1600,900,6000, 2128,1696,1864,932,901,904,11900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7000, 2144,1704,1872,937,901,904,14062,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7200, 2144,1704,1872,938,901,904,14480,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7500, 2160,1704,1880,940,901,904,15228,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,8500, 2176,1712,1888,945,901,904,17479,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,10000,2192,1720,1896,953,901,904,20890,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,12000,2208,1728,1904,965,901,904,25569,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14000,2224,1736,1912,976,901,904,30389,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14400,2224,1736,1912,978,901,904,31321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,15000,2224,1736,1912,982,901,904,32760,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,17000,2224,1736,1912,994,901,904,37581,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x880:
    {1600,880,6000, 2112,1688,1856,911,881,884,11544,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7000, 2144,1704,1872,916,881,884,13747,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7200, 2144,1704,1872,917,881,884,14156,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7500, 2144,1704,1872,919,881,884,14778,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,8500, 2160,1704,1880,924,881,884,16965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,10000,2192,1720,1896,932,881,884,20429,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,12000,2208,1728,1904,943,881,884,24986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14000,2208,1728,1904,954,881,884,29490,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14400,2224,1736,1912,957,881,884,30648,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,15000,2224,1736,1912,960,881,884,32026,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,17000,2224,1736,1912,972,881,884,36749,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1400x1050:
    {1400,1050,6000, 1880,1488,1640,1087,1051,1054,12261,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7000, 1896,1496,1648,1093,1051,1054,14506,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7200, 1896,1496,1648,1094,1051,1054,14934,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7500, 1896,1496,1648,1096,1051,1054,15585,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,8500, 1912,1504,1656,1103,1051,1054,17926,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,10000,1928,1512,1664,1112,1051,1054,21439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,12000,1944,1520,1672,1125,1051,1054,26244,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14000,1944,1520,1672,1139,1051,1054,30999,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14400,1944,1520,1672,1141,1051,1054,31941,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,15000,1944,1520,1572,1146,1051,1054,33417,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    
    // Settings for 1280x1024:
    {1280,1024,6000, 1712,1360,1496,1060,1025,1028,10888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7000, 1728,1368,1504,1066,1025,1028,12894,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7200, 1728,1368,1504,1067,1025,1028,13275,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7500, 0x6B0,0x550,0x5d8,0x424,0x401,0x404,0x2a88,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,8500, 1744,1376,1512,1075,1025,1028,15936,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,10000,1760,1376,1520,1085,1025,1028,19096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,12000,1776,1384,1528,1097,1025,1028,23379,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14000,1776,1384,1528,1111,1025,1028,27624,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14400,1776,1384,1528,1113,1025,1028,28464,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,15000,1776,1384,1528,1117,1025,1028,29757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,17000,1792,1392,1536,1131,1025,1028,34455,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,20000,1729,1392,1536,1152,1025,1028,41288,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1280x960:
    {1280,960,6000, 1712,1360,1496,994, 961,964,10210,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7000, 1728,1368,1504,999, 961,964,12084,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7200, 1728,1368,1504,1001,961,964,12454,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7500, 1728,1368,1504,1002,961,964,12986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,8500, 1744,1376,1512,1008,961,964,14943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,10000,1760,1376,1520,1017,961,964,17899,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,12000,1760,1376,1520,1029,961,964,21732,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14000,1776,1384,1528,1041,961,964,25883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14400,1776,1384,1528,1044,961,964,26700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,15000,1776,1384,1528,1047,961,964,27892,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,17000,1792,1392,1536,1060,961,964,32292,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,20000,1792,1392,1536,1080,961,964,38707,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1152x864:
    {1152,864,6000, 1520,1216,1336,895,865,868,8162,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7000, 1536,1224,1344,900,865,868,9677,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7200, 1536,1224,1344,901,865,868,9964,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7500, 1552,1224,1352,902,865,868,10499,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,8500, 1552,1224,1352,907,865,868,11965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,10000,1568,1232,1360,915,865,868,14347,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,12000,1584,1240,1368,926,865,868,17601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14000,1600,1248,1376,937,865,868,20989,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14400,1600,1248,1376,939,865,868,21635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,15000,1600,1248,1376,943,865,868,22632,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,17000,1600,1248,1376,954,865,868,25949,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,20000,1616,1256,1384,972,865,868,31415,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,24000,1616,1256,1384,997,865,868,38668,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1024x768:
    //Use DMT for 60Hz: 1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,6000, 1344,1048,1184,806,771,777,6500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {1024,768,7000, 1360,1080,1192,800,769,772,7616,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7200, 1360,1080,1192,801,769,772,7843,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7500, 1360,1080,1192,802,769,772,8180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,8500, 1376,1088,1200,807,769,772,9439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    //Adjust 100Hz due to DAC feedback
    //1392,1096,1208,814,769,772,11331,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,10000,1392,1096,1208,814,769,772,11370,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,12000,1408,1104,1216,823,769,772,13905,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14000,1408,1104,1216,833,769,772,16420,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14400,1408,1104,1216,835,769,772,16930,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,15000,1408,1104,1216,838,769,772,17699,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,17000,1424,1112,1224,848,769,772,20528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,20000,1424,1112,1224,864,769,772,24607,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,24000,1440,1120,1232,886,769,772,30620,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 960x720:
    {960,720,6000, 1248,1008,1104,746,721,724,5586,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7000, 1264,1008,1112,750,721,724,6636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7200, 1264,1008,1112,751,721,724,6835,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7500, 1280,1016,1120,752,721,724,7219,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,8500, 1280,1016,1120,756,721,724,8225,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,10000,1296,1024,1128,763,721,724,9888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,12000,1312,1032,1136,772,721,724,12154,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14000,1312,1032,1136,781,721,724,14345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14400,1328,1040,1144,783,721,724,14973,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,15000,1328,1040,1144,786,721,724,15657,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,17000,1328,1040,1144,795,721,724,17948,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,20000,1344,1048,1152,810,721,724,21773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,24000,1344,1048,1152,831,721,724,26805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 864x480:
    {864,480,6000, 1072,880,968,497,481,484,3197,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7000, 1104,896,984,500,481,484,3864,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7200, 1104,896,984,501,481,484,3982,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7500, 1104,896,984,502,481,484,4157,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,8500, 1120,904,992,505,481,484,4808,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,10000,1136,912,1000,509,481,484,5782,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,12000,1152,912,1008,515,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14000,1168,920,1016,521,481,484,8519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14400,1168,920,1016,522,481,484,8780,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,15000,1168,920,1016,524,481,484,9180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,17000,1184,928,1024,531,481,484,10688,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,20000,1184,928,1024,540,481,484,12787,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,24000,1200,936,1032,554,481,484,15955,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 856x480:
    {856,480,6000, 1064,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 852x480:
    {852,480,6000, 1046,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 848x480:
    {848,480,6000, 1056,864,952,497,481,484,3149,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7000, 1072,872,960,500,481,484,3752,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7200, 1088,880,968,501,481,484,3925,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7500, 1088,880,968,502,481,484,4096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,8500, 1104,888,976,505,481,484,4739,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,10000,1120,896,984,509,481,484,5701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,12000,1136,904,992,515,481,484,7020,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14000,1152,904,1000,521,481,484,8403,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14400,1152,904,1000,522,481,484,8659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,15000,1152,904,1000,524,481,484,9055,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,17000,1152,904,1000,531,481,484,10399,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,20000,1168,912,1008,540,481,484,12614,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,24000,1168,912,1008,554,481,484,15530,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 800x600:
    // Use DMT for 60: 1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {800,600,6000, 1056,840,968,628,601,605,4000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7000, 1040,840,920,625,601,604,4550,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7200, 1040,840,920,626,601,604,4687,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7500, 1040,840,920,627,601,604,4891,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,8500, 1056,840,928,630,601,604,5655,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,10000,1072,848,936,636,601,604,6818,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,12000,1088,856,944,643,601,604,8395,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14000,1088,856,944,651,601,604,9916,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14400,1088,856,944,653,601,604,10231,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,15000,1088,856,944,655,601,604,10690,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,17000,1104,864,952,663,601,604,12443,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,20000,1104,864,952,675,601,604,14904,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,24000,1120,872,960,692,601,604,18601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 720x480:
    {720,480,6000, 896,736,808,497,481,484,2672,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7000, 912,744,816,500,481,484,3192,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7200, 912,744,816,501,481,484,3290,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7500, 928,752,824,502,481,484,3494,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,8500, 928,752,824,505,481,484,3983,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,10000,944,760,832,509,481,484,4805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,12000,960,760,840,515,481,484,5933,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14000,976,768,848,521,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14400,976,768,848,522,481,484,7336,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,15000,976,768,848,524,481,484,7671,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,17000,976,768,848,531,481,484,8810,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,20000,992,776,856,540,481,484,10714,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,24000,992,776,856,554,481,484,13190,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x480:
    // Use DMT for 60: 800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,480,6000, 800,656,752,525,490,492,2518,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {640,480,7000, 816,664,728,500,481,484,2856,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7200, 816,664,728,501,481,484,2943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7500, 816,664,728,502,481,484,3072,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,8500, 832,672,736,505,481,484,3571,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,10000,848,680,744,509,481,484,4316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,12000,848,680,744,515,481,484,5241,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14000,864,680,752,521,481,484,6302,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14400,864,680,752,522,481,484,6495,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,15000,864,680,752,524,481,484,6791,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,17000,880,688,760,531,481,484,7944,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,20000,880,688,760,540,481,484,9504,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,24000,880,688,760,554,481,484,11700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x400:
    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.  There is no 60Hz 
    // timings for 640x400 as defined by IBM VGA.
    //
    // Use GTF 75: 784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,6000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7200, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,7500, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,8500, 816,664,728,421,401,404,2920,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,10000,832,672,736,424,401,404,3528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,12000,848,680,744,429,401,404,4366,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14000,848,680,744,434,401,404,5152,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14400,848,680,744,435,401,404,5312,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,15000,864,680,752,437,401,404,5664,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,17000,864,680,752,442,401,404,6492,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,20000,880,688,760,451,401,404,7938,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,24000,880,688,760,462,401,404,9757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    {512,384,6000, 672,536,592,795,769,772,3205,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {512,384,7000, 672,536,592,800,769,772,3763,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7200, 688,544,600,801,769,772,3968,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7500, 688,544,600,802,769,772,4138,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,8500, 688,544,600,807,769,772,4719,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,10000,688,544,600,814,769,772,5600,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,12000,704,552,608,823,769,772,6953,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14000,704,552,608,833,769,772,8210,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14400,704,552,608,835,769,772,8465,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,15000,704,552,608,838,769,772,8849,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,17000,704,552,608,848,769,772,10149,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,20000,720,560,616,864,769,772,12442,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,24000,720,560,616,886,769,772,15310,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    {480,360,6000, 624,504,552,746,721,724,2793,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7000, 640,512,560,750,721,724,3360,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7200, 640,512,560,751,721,724,3461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7500, 640,512,560,752,721,724,3610,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,8500, 640,512,560,756,721,724,4113,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,10000,656,512,568,763,721,724,5005,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,12000,656,512,568,772,721,724,6077,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14000,656,512,568,781,721,724,7173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14400,656,512,568,783,721,724,7397,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,15000,656,512,568,786,721,724,7734,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,17000,672,520,576,795,721,724,9082,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,20000,672,520,576,810,721,724,10886,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,24000,672,520,576,831,721,724,13402,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    {400,300,6000, 512,416,456,622,601,604,1911,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7000, 528,424,464,625,601,604,2310,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7200, 528,424,464,626,601,604,2380,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7500, 528,424,464,627,601,604,2483,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,8500, 528,424,464,630,601,604,2827,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,10000,528,424,464,636,601,604,3358,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,12000,544,432,472,643,601,604,4198,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14000,544,432,472,651,601,604,4958,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14400,544,432,472,653,601,604,5115,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,15000,544,432,472,655,601,604,5345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,17000,544,432,472,663,601,604,6131,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,20000,560,432,480,675,601,604,7560,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,24000,560,432,480,692,601,604,9300,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    {320,240,6000, 400,328,360,497,481,484,1193,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7000, 400,328,360,500,481,484,1400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7200, 416,336,368,501,481,484,1501,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7500, 416,336,368,502,481,484,1566,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,8500, 416,336,368,505,481,484,1786,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,10000,416,336,368,509,481,484,2117,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,12000,432,344,376,515,481,484,2670,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14000,432,344,376,521,481,484,3151,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14400,432,344,376,522,481,484,3247,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,15000,432,344,376,524,481,484,3396,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,17000,432,344,376,531,481,484,3900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,20000,432,344,376,540,481,484,4666,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,24000,448,352,384,554,481,484,5957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {320,200,6000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7200, 400,328,360,418,401,404,1204,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7500, 400,328,360,418,401,404,1254,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,8500, 416,336,368,421,401,404,1489,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,10000,416,336,368,424,401,404,1764,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,12000,416,336,368,429,401,404,2142,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14000,432,344,376,434,401,404,2625,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14400,432,344,376,435,401,404,2706,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,15000,432,344,376,437,401,404,2832,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,17000,432,344,376,442,401,404,3246,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,20000,432,344,376,451,401,404,3897,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,24000,448,352,384,462,401,404,4967,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE}
};

//*****************************************************************************
//
// VESA 1.0 rev 0.7 DMT timings
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
// Monitor Timing Specifications.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: Unlike GTF timings, DMT does not dictate zero border widths.
// Therefore we must include blank start and end positions. 
//
unsigned int DMTTimingTableNT[][16] =
{

    // Settings for 320x200 (mode doubled 640x400):
    //  NOTE: There is no 60Hz 320x200, so use 70Hz if anyone wants 60Hz
    {320,200,6000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,7000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,8500,832/2,640/2,672/2,736/2,832/2,445,400,401,404,445,3150/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 320x240 (mode doubled 640x480):
	{320,240,6000,800/2,648/2,656/2,752/2,792/2,525,488,490,492,517,2518/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7200,832/2,648/2,664/2,704/2,824/2,520,488,489,492,512,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7500,840/2,640/2,656/2,720/2,840/2,500,480,481,484,500,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,8500,832/2,640/2,696/2,752/2,832/2,509,480,481,484,509,3600/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 400x300 (mode doubled 800x600):
	{400,300,6000,1056/2,800/2,840/2,968/2,1056/2,628,600,601,605,628,4000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7200,1040/2,800/2,856/2,976/2,1040/2,666,600,637,643,666,5000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7500,1056/2,800/2,816/2,896/2,1056/2,625,600,601,604,625,4950/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,8500,1048/2,800/2,832/2,896/2,1048/2,631,600,601,604,631,5625/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 512x384 (mode doubled 1024x768):
	{512,384,6000,1344/2,1024/2,1048/2,1184/2,1344/2,806,768,771,777,806,6500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7000,1328/2,1024/2,1048/2,1184/2,1328/2,806,768,771,777,806,7500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7500,1312/2,1024/2,1040/2,1136/2,1312/2,800,768,769,772,800,7875/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{512,384,8500,1376/2,1024/2,1072/2,1168/2,1376/2,808,768,769,772,808,9450/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 640x400:
    //  NOTE: There is no 60Hz 640x400, so use 70Hz if anyone wants 60Hz
    {640,400,6000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,7000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,8500,832,640,672,736,832,445,400,401,404,445,3150,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 640x480:
	{640,480,6000,800,648,656,752,792,525,488,490,492,517,2518,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7200,832,648,664,704,824,520,488,489,492,512,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7500,840,640,656,720,840,500,480,481,484,500,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,8500,832,640,696,752,832,509,480,481,484,509,3600,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 800x600:
	{800,600,6000,1056,800,840,968,1056,628,600,601,605,628,4000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7200,1040,800,856,976,1040,666,600,637,643,666,5000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7500,1056,800,816,896,1056,625,600,601,604,625,4950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,8500,1048,800,832,896,1048,631,600,601,604,631,5625,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1024x768:
	{1024,768,6000,1344,1024,1048,1184,1344,806,768,771,777,806,6500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7000,1328,1024,1048,1184,1328,806,768,771,777,806,7500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7500,1312,1024,1040,1136,1312,800,768,769,772,800,7875,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1024,768,8500,1376,1024,1072,1168,1376,808,768,769,772,808,9450,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1152x864:
	{1152,864,7500,1600,1152,1216,1344,1600,900,864,865,868,900,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1280x1024:
	{1280,1024,6000,1688,1280,1328,1440,1688,1066,1024,1025,1028,1066,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,7500,1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,8500,1728,1280,1344,1504,1728,1072,1024,1025,1028,1072,15750,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1024 (OEM requested version of 76Hz)
    {1600,1024,7600,2096,1600,1632,1792,2096,1070,1024,1027,1030,1070,17045,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 1600x1200:
	{1600,1200,6000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,16200,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,6500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,17550,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,18900,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,20250,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,8500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,22950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1200 (OEM requested version of 76Hz)
    {1920,1200,7600,2584,1920,1984,2240,2584,1250,1200,1203,1206,2584,24548,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE}
};

// This function scans the GTF table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetGTFTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }


    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (GTFTimingTable[i][0] == hRes &&
            GTFTimingTable[i][1] == vRes &&
            GTFTimingTable[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            // NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
            // Blank End == Total.
            timingInfo->HorizontalVisible       = GTFTimingTable[i][0]; 
            timingInfo->VerticalVisible         = GTFTimingTable[i][1];
            timingInfo->Refresh                 = GTFTimingTable[i][2];
            timingInfo->HorizontalTotal         = GTFTimingTable[i][3]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = GTFTimingTable[i][4]; 
            timingInfo->HorizontalRetraceEnd    = GTFTimingTable[i][5]; 
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalTotal;
            timingInfo->VerticalTotal           = GTFTimingTable[i][6]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = GTFTimingTable[i][7]; 
            timingInfo->VerticalRetraceEnd      = GTFTimingTable[i][8]; 
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalTotal;
            timingInfo->PixelClock              = GTFTimingTable[i][9];
            timingInfo->HSyncpolarity           = GTFTimingTable[i][10]; 
            timingInfo->VSyncpolarity           = GTFTimingTable[i][11]; 

            // return success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetGTFTimings

// This function scans the DMT table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetDMTTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }

    // For each mode, there are 16 (unsigned int) timing values
    numEntries = sizeof(DMTTimingTableNT) / (sizeof(unsigned int) * 16);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (DMTTimingTableNT[i][0] == hRes &&
            DMTTimingTableNT[i][1] == vRes &&
            DMTTimingTableNT[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            timingInfo->HorizontalVisible       = DMTTimingTableNT[i][0]; 
            timingInfo->VerticalVisible         = DMTTimingTableNT[i][1];
            timingInfo->Refresh                 = DMTTimingTableNT[i][2];
            timingInfo->HorizontalTotal         = DMTTimingTableNT[i][3]; 
            // timingInfo->HorizontalBlankStart    = DMTTimingTableNT[i][4]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = DMTTimingTableNT[i][5]; 
            timingInfo->HorizontalRetraceEnd    = DMTTimingTableNT[i][6]; 
            // timingInfo->HorizontalBlankEnd      = DMTTimingTableNT[i][7];
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalBlankStart
                            + (timingInfo->HorizontalTotal - DMTTimingTableNT[i][7]);
            timingInfo->VerticalTotal           = DMTTimingTableNT[i][8]; 
            // timingInfo->VerticalBlankStart      = DMTTimingTableNT[i][9]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = DMTTimingTableNT[i][10]; 
            timingInfo->VerticalRetraceEnd      = DMTTimingTableNT[i][11]; 
            // timingInfo->VerticalBlankEnd        = DMTTimingTableNT[i][12];
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalBlankStart 
                            + (timingInfo->VerticalTotal - DMTTimingTableNT[i][12]);
            timingInfo->PixelClock              = DMTTimingTableNT[i][13];
            timingInfo->HSyncpolarity           = DMTTimingTableNT[i][14]; 
            timingInfo->VSyncpolarity           = DMTTimingTableNT[i][15]; 

            // success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetDMTTimings


// This function simply returns the number of entries in the GTF table
// 

unsigned int vesaGetNumGTFEntries
(
void
)
{
    unsigned int numEntries;

    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    return(numEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\surfaces.h ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: surfaces.h                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/


#ifndef surfaces_h
#define surfaces_h

//#define MAXDATASTORE (0x640)
#define MAXDATASTORE (0x640*4)

/*  FIXES TO GET THIS TO COMPILE UNDER MY NV3 DIRECTORY */

#include "VidTex.h"
#include "VPCallbk.h"
#include "transfer.h"
#include "timing.h"

#ifndef RESMANSIDE

#include "nvddobj.h"

#ifdef NV3

#define info32  otherInfo32
#define info16  otherInfo16
#define nvContextDmaToMemory contextDmaToMemory
#define nv03ExternalVideoDecoder    externalVideoDecoder
#define NV04D_NOTIFICATION_STATUS_IN_PROGRESS   NV_STATUS_IN_PROGRESS
#define NV04D_NOTIFICATION_STATUS_DONE_SUCCESS  NV_STATUS_DONE_OK

#endif // NV3

#endif // !RESMANSIDE

// this file will include the definitions of the common
// data structures between the Ring3 VPE code
// and the ring0 VXD code which will actually program
// things

//---------------------------------------------------------------------------

// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)

// these next three are measured in Pixels ie 2 byte chunks
#define NV4_MAX_FIELDWIDTH (0x1000)
#define NV4_MAX_FIELDHEIGHT (0x5dc)	//1500. current max.height=1080p for HD
#define NV4_MAX_VBIWIDTH (0x1000)
#define NV4_MAX_BUFFERLENGTH (0x80000)

#define NV4_MAX_PIXELRATE ( 27000000)

// these next three are measured in Pixels ie 2 byte chunks
#define NV10_MAX_FIELDWIDTH (0x1000)
#define NV10_MAX_FIELDHEIGHT (0x5dc)	//1500. current max.height=1080p for HD
#define NV10_MAX_VBIWIDTH (0x1000)
#define NV10_MAX_BUFFERLENGTH (0x800000)

#define NV10_MAX_PIXELRATE ( 100000000)     // a little arbitrary, need to confirm (jsun)

// Here we'll put chip specific info which may change from part to part...
#ifdef NV3
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH (0x1000)
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#endif // NV3

//---------------------------------------------------------------------------

#ifdef NV4
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH 2000	//since max now is 1920
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#define NV_MAX_FIELDHEIGHT	1200	//since max now is 1080i
#endif //NV4

//---------------------------------------------------------------------------

#ifdef NV5
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH (0x1000)
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)

const DWORD MY_CONNECTION_CAPS= //DDVPCONNECT_DOUBLECLOCK           |
                                            //DDVPCONNECT_VACT                  |
                                            //DDVPCONNECT_INVERTPOLARITY        |
                                            DDVPCONNECT_DISCARDSVREFDATA    |
                                            //DDVPCONNECT_HALFLINE              |
                                            DDVPCONNECT_INTERLACED          |
                                            //DDVPCONNECT_SHAREEVEN         |
                                            //DDVPCONNECT_SHAREODD              |
                                            0;
#endif //NV5

//---------------------------------------------------------------------------

#ifdef NV10
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH 2000	//since max now is 1920
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#define NV_MAX_FIELDHEIGHT	1200	//since max now is 1080i
#endif //NV10

//---------------------------------------------------------------------------

// since many compiler have poor enum implementations
// I'll reserve the right to do this manually
//#define DECENTENUMS

#ifdef DECENTENUMS

enum    {
    VP_NOT_RUNNING = 0,
    VP_VBI_CAPTURING =1,
    VP_IMAGE_CAPTURING =2,
    VP_BOTH_CAPTURING = 3
} VPSTATE;

enum {

    MY_EXTERNAL_DECODER_OBJECT      = 0x80024000,
    MY_EXTERNAL_DECODER_NOTIFIER,
    MY_IMAGE0_BUFFER_CONTEXT,
    MY_IMAGE1_BUFFER_CONTEXT,
    MY_VBI0_BUFFER_CONTEXT,
    MY_VBI1_BUFFER_CONTEXT

} MYINSTANCES;

enum {
    VBISURF = (0xFEEDC0DE),
    IMAGESURF
} SURFKIND;

enum {
    NOVPERROR               = 0,
    TOOMANYSURFACESERROR = 20,
    CANTCREATESURFACE,
    SURFACENOTFOUND = 9999,
    NOSURFACEPROGRAMED = 999
} VPERRORS;


enum {
    EVENODD =1,
    EVENEVEN,
    ODDODD
} CAPTUREMODE;

enum {
    SEPERATEBUF = 10,
    INTERLEAVBUF  = 20
} SCANMODE;

// These constants are designed to correspond with the NV3 hardware.
enum {
    ODD = 0,
    EVEN,
    UNKNOWN
} FIELDTYPE;


#else
#define SURFKIND   U032
#define VBISURF (0xFEEDC0DE)
#define IMAGESURF   (0xBAD0BEEF)

#define VPSTATE         U032
#define VP_NOT_RUNNING          (0)
#define VP_VBI_CAPTURING        (1)
#define VP_IMAGE_CAPTURING  (2)
#define VP_BOTH_CAPTURING   (3)

// standard decoder object handle values
#define MY_EXTERNAL_DECODER_OBJECT      (0x80024000)
#define MY_EXTERNAL_DECODER_NOTIFIER    (0x80024001)
#define MY_IMAGE0_BUFFER_CONTEXT        (0x80024002)
#define MY_IMAGE1_BUFFER_CONTEXT        (0x80024003)
#define MY_VBI0_BUFFER_CONTEXT          (0x80024004)
#define MY_VBI1_BUFFER_CONTEXT          (0x80024005)
#define MY_IMAGE1_BUFFER_EVENT          (0x80024006)
#define MY_IMAGE0_BUFFER_EVENT          (0x80024007)
#define MY_VBI1_BUFFER_EVENT                (0x80024008)
#define MY_VBI0_BUFFER_EVENT                (0x80024009)
#define MY_VPE_CHANNEL                      (0x8002400A)
#define  MY_TIMER_NOTIFIER                  (0x8002400B)
#define  MY_TIMER_OBJECT                    (0x8002400C)
#define  MY_TIMER_EVENT                     (0x8002400D)
// handle values for MTM
#define MY_MTM_OBJECT                       (0x80024010)
#define MY_MTM_NOTIFIER                 (0x80024011)
#define MY_MTM_FROM_CONTEXT             (0x80024012)
#define MY_MTM_TO_CONTEXT                   (0x80024013)
#define MY_MTM_EVENT                        (0x80024014)
//#define   MY_MTM_EVENT2                       (0x80024015)
// values for the texture surface
#define MY_SWIZ_OBJECT                      (0x80024020)
#define MY_SWIZ_NOTIFIER                    (0x80024021)
#define  MY_2DSWIZD_OBJECT                  (0x80024022)
#define  MY_2DSWIZD_NOTIFIER                (0x80024023)

#define MY_OVERLAY0_BUFFER_EVENT                (0x80024025)
#define MY_OVERLAY1_BUFFER_EVENT                (0x80024026)

#define MY_DVD_SUBPICTURE_OBJECT                (0x80024027)

#define MYINSTANCES (U032)

#define SURFKIND   U032
#define VBISURF (0xFEEDC0DE)
#define IMAGESURF   (0xBAD0BEEF)

#define STARTINGBUF (99)
#define UNKNOWNBUF  (123)


#define NOVPERROR               (0)
#define TOOMANYSURFACESERROR (20)
#define CANTCREATESURFACE       (21)
#define SURFACENOTFOUND     (0x9999)
#define NOSURFACEPROGRAMED  (0x999)
#define VPERRORS                U032

// Note that PROGRESSIVE is the currently defined to be ODD ODD
#define CAPTUREMODE             U032
#define EVENODD                 (1)
#define EVENEVEN                (2)
#define PROGRESSIVE             (3)
#define ODDODD                  (3)

#define SCANMODE                    U032
#define SEPERATEBUF             (10)
#define INTERLEAVBUF            (20)

// These constants are designed to correspond with the NV3 hardware.
#define FIELDTYPE               U032
#define ODD                     0
#define EVEN                        1
#define UNKNOWN                 3

#endif //DECENTENUMS

// the maximum frame period should be 20% more than 1/24 of a second measured in nanosecs
//    this is  1/24  * 1.2  * 1,000,000,000 = 50000000  = 0x2faf080
#define MAXFRAMEPERIOD          (0x2faf080)

//  There are 9 notifiers for the externalvideodecoder class
//    there are an additional  2 notifiers for the timer class
//    2 notifiers for the MTM class
//    1 notifier for the nvo3 sclaed image
//    1 notifier for the stretch swizzle class
#define  NUM04DNOTIFIER     (9)
#define  NUM004NOTIFIER    (2)
#define NUM039NOTIFIER      (2)
#define  NUM077NOTIFIER    (1)
#define  NUM052NOTIFIER    (1)
#define  NUM04DOFFSET       (0)
#define  NUM004OFFSET       (NUM04DOFFSET+NUM04DNOTIFIER)
#define  NUM039OFFSET       (NUM004OFFSET+NUM004NOTIFIER)

// for swizzler class
#define  NUM077OFFSET       (NUM039OFFSET+NUM039NOTIFIER)

// for swizzled surface
#define  NUM052OFFSET       (NUM077OFFSET+NUM077NOTIFIER)
#define NUMVPNOTIFIERS      (NUM052OFFSET+NUM052NOTIFIER)


// This little goodies is going to be used so that we can distinguish between
// two states which the architecture has traditionally considered to be ONE.
// these states are to distinguish between a notification where Status indicates
// that the HW is done, but the SW has not dealt with that even
// this is DONE_SUCESS
// the second state is HW done and SW dealt with the event, but no new
// task has been delivered back to the HW.    Theoretically this should
// be the power-on state.

#define NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED                     (0x42)


/* Debug stuff */
#ifndef RESMANSIDE
#ifdef DEBUG
    #define ASSERT(ParamAssert)     (ParamAssert)? \
            (void)0:DPF("Assertion failed in %s at line %i\n", __FILE__, __LINE__)

    #define strASSERT( Condition, string )  (Condition)?\
            (void)0:DPF("Assertion failed in %s at line %i, %s", __FILE__, __LINE__, strAssert)

#else
    #define ASSERT( ParamAssert )               (void)0
    #define strASSERT( Condition, string )      (void)0
#endif
#else
    #define ASSERT(x)  (void)0
    #define strASSERT(Condition,string)   (void)0
#endif

// this is the maximum for both VBI and IMAGE combined
#define MAXVPSURFACES   (10)

// used to timeout while's which are depedant on HW so which may never terminate
#define WHILETIMEOUT                        (0x800000)


// this next one can't conflict with MS defined things...
//#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
//#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

#define VDD_IOCTL_NV_FILLTABLE   0x20000667

typedef struct _NVVDDPROCTABLE
{

    U032        dwPDDDriver;
    MINIPROC    getStoragePointer;
    MINIPROC handleBufferInterrupts;

} NVVDDPROCTABLE;

typedef struct _vpSurfaceInfo
{
    HANDLE              surfHandle;             // directDraw surface handle
    FLATPTR             pVidMem;                    // flat pointer to the surface
    U032                    dwOffset;               // offset from the base of the frame buffer
    U032                    dwPitch;
    U032                    dwLength;
    U032                    dwHeight;
    U032                    dwWidth;                    // ignored for VBI
    U032                    dwStartLine;            // programs Y-crop for image, and startline for vbi
    U032                    dwPreScaleSize;     // ignored for VBI.. represented in 16..16 format
    DWORD                   ddsCaps;                    // capabilites of this DD surface
    NvNotification*     pNvNotify;              // pointer to typical notification structure that was most recently used
    U032                    bAutoFlip;              // do we turn around and auto program this surface?
    U032                    nextSurfaceNum;     // which is the next surface to fire off?
    FIELDTYPE           field;                  // what field was this surface setup to capture?
    U032                    dwRes1;         // for storing the pointer to the "second" surface for the DVD subpicture stuff
} vpSurfaceInfo;

typedef struct _DropSys {
   U032 dwTargetSurface;
   U032 dwbIsBobFromInterleave;
   U032 dwFieldType;
   U032 dwFullBool;
   U032 dwDropFields;
} DropSys;


typedef struct _vpSurfaces {
    U032                    numberOfSurfaces;               // total number of surfaces that we're keeping track of
    vpSurfaceInfo*      Surfaces[MAXVPSURFACES];    // this will be a pointer to an array of surfaces
    U032                    CurrentBufferSurface[4];    // to associate the HW buffer with an arrary index
    CAPTUREMODE         CurrentCaptureMode;         // indicates which fields will be capture Even
    SCANMODE                CurrentScanMode;                // seperate or interleaved buffersx
    FIELDTYPE           lastField;                      // the last buffer programmed was to capture a field of this type
    FIELDTYPE           lastVBIField;                           //same but for VBI
    U032                    bInputInterLaced;               // TRUE if we're running with an interlaced input
    U032                    VBIstart;                       // which surface is the first one which has VBI data?
    // general information
    U032                    bSkipNextField;             // set to true to indicate that the next field should be skipped.  reset by upon skip
    U032                    dwInHeight;                    // input height (into the surface)
    U032                    dwInWidth;                      // input width (into the surface)
    U032                    dwImageStartLine;               // first line of image data to capture
    U032                    dwVBIStartLine;             // the first VBI line to capture
    U032                    dwVBIHeight;                    // total number of lines of VBI to capture
    U032                    dwPreHeight;                    // height and width before prescaling
    U032                    dwPreWidth;                     // width before prescaling
    U032                    dwOriginX;                      // orgins to move data within the surface
    U032                    dwOriginY;
    U032                    bThreadDead;                    // TRUE indicates that the thread has decided to exit
    U032                    bThreadRunning;             // if true, indicates that the thread should continue to run
//  LPVOID              hVPInterruptEvent;          // handle to the event used to notify the thread to wake up
//  DWORD                   VpInterruptId;                  // the thread ID of the thread
//  HANDLE              hThreadHandle;                  // Handle to the thread
    U032                    bStopVP;                            // indicates to the thread that it should NOT reprogram..
    HANDLE              myVXDhandle;                    // used to store the handle to access the mini-vdd

    U032                    CallbackSelector;
    U032                    pNotifyCallbackProcI0;
    U032                    pNotifyCallbackProcI1;
    U032                    pNotifyCallbackProcV0;
    U032                    pNotifyCallbackProcV1;
    U032                    pTimerNotifyProc;
    U032                    pMTMNotifyCallback;
    U032                    pNotifyOverlay0NotifyProc;
    U032                    pNotifyOverlay1NotifyProc;

    DDMINIVDDTABLE      myKMVTTable;                    // for storing the locations of the KVMT functions
    U032*                   pNvDevBase;
    U032                    bInvertedFields;
    // these are temporarly while I do information about the speed of things

    timeStore           Timings;
#if 0
    U032                    marker;
    U032                    storCount;
    U032                    mpFlipTime0[MAXDATASTORE];  // these next are for collection timing statistics
    U032                    mpFlipTime1[MAXDATASTORE];
    U032                    mpFlip[MAXDATASTORE];

    U032                    ovReqTime0[MAXDATASTORE];
    U032                    ovReqTime1[MAXDATASTORE];
    U032                    ovReq[MAXDATASTORE];

    U032                    ovFlipTime0[MAXDATASTORE];  // this should be in MicroSeconds
    U032                    ovFlipTime1[MAXDATASTORE];      // this should be in MicroSeconds
    U032                    ovFlip[MAXDATASTORE];

    U032                    surfPlace[MAXDATASTORE];    // a "packed" version of current surfaces
    U032                    mpLoopCount;
    U032                    ovLoopCount;
    U032                    ovFlLoopCount;
    U032                    loopCount;
#endif
    U032                    curImageSurf;
    U032                    curVBISurf;
    U032                    curSurf;
    U032                    intermediateCycle;

    FLATPTR             pBuffer0Mem;                    // to keep track of which surface is programmed in the VDD
    FLATPTR             pBuffer1Mem;
    U032                    curOverlay;
    NVVDDPROCTABLE      myTable;
    NvChannel*          pVPChanPtr;
    NvChannel*          pOverlayChanPtr;                // used to store the Pointer to the NV channel
                                                                // because of potential multithreading issues we try to keep the overlay in
                                                                // it's own channel.  However, we do a SetObject on it just incase before use
    U032                    dwOverlaySubChan;               // used to store the subchannel in which we'll talk to the Overlay
    U032                    dwOverlayObjectID;          // used to store the OverlayObject ID...
    U032                    dwScalerObjectID;
    U032                    dwDVDObjectID;
    NvNotification* pTheNotifiers;

    CALLBPROC           ImageCallbackRoutine;
    CALLBPROC           VBICallbackRoutine;
    sCallBack           myIMGCallbackInfo;
    sCallBack           myVBICallbackInfo;
    GLOBALDATA*         pDriverData;
    U032                    myFreeCount;
    // THESE are the big ugly so we dont' have to worry about which context the ring0 stuff was called from and there
    // where these guys were allocated from
    U032                    lastsrcDeltaY;
    U032                    surfMemAllocCount;
    vpSurfaceInfo       surfMemory[MAXVPSURFACES];  // this will be a pointer to an array of surfaces
    U032                    DXIRQCallbackSources;       // flags for the callback determination
    U032                    pDXIRQCallback;             // address of the callback proc for the DX stuff
    U032                    dwIrqContext;
    U032                    dwVPFlags;              // same flags as passed in to UpdateVideoPort
    VPSTATE             dwVideoPortStatus;  // yet another global silly
    U032                    bFlipRequested;         // used during non-auto-flip to determine if a flip occurred
    U032                    lastSurfaceFlippedTo;
    volatile U032*                  pNvTimer;

    aTransfer           MyTransfers[MAXTRANSFERS];  // array of transfers from which to allocate
    U032                    dwNextEmpty;    //Points to the location in the array of the next empty we should fill
    U032                    dwLastEmpty;    //Points to the location in the arry which was just emptied...
    //pTransfer         pLastTransfer;                  // the last one which was added
    pTransfer           pCurrentTransfer;               // the current one which just just put into the HW
    U032                    bContextCreated;                // has the context object been created or not
    U032                    savedStart;
    U032                    savedLimit;
    U032                    dwMostRecentFinishTransferId;  // used to store the ID of the most recently finished transfer
    U032                    SetupComplete;
    U032                    dwOvSurfaceOffset;
    U032                    lastSurface;            // bob-interleave field delay
    U032                    lastBuffer;             // bob-interleave field delay
    U032                    bDoingDropFrame;        // used to indicate that we just dropped a field and the leap frogging should stop for one frame
    VidTexSurf*         pVidTexSurf;
    U032                    bRing0Flip;
    DropSys                 DropSystem;
    U032                    lastOvLowTime;          // used to store the last overlay callback time to eliminate duplicates
    U032                    bFirstTime;           // used to indicate first time through on seperate buffer starts to eliminate an NV10 bug!
} vpSurfaces;




vpSurfaces* getStoragePointer(void );
DWORD SetupVP (LPDDHAL_CREATEVPORTDATA lpInput);
BOOL    GetField(void);
DWORD getCurLine(void);
void    tearDownVP(void);
void    StopVP(void);
U032    findSurface(LPDDRAWI_DDRAWSURFACE_LCL pNewSurface );
U032    ProgramBufferWithSurface(U032   dwBufferIndex,U032  newSurfaceIndex, U032 bZeroLength);
VPERRORS replaceSurfaceList(DWORD dwNumAutoflip,DWORD dwNumVBIAutoflip,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface,
                                        U032 bAutoflip );

// used by surfaces.h internally
DWORD WINAPI VPInterruptThread(PVOID daParameter);

VPERRORS    addSurface(vpSurfaceInfo*   pNewSurface);
VPERRORS replaceSurfaceWithSurface(U032 surfaceToReplace,
                                        LPDDRAWI_DDRAWSURFACE_LCL pNewSurface,
                                        U032  bVBI);

vpSurfaceInfo* createSurface(LPDDRAWI_DDRAWSURFACE_INT pNewSurface, U032 bAutoflip,
                                        U032 bVBI, NvNotification* pToNotify,U032 nextSurface);
VPERRORS clearAllSurfaces();

U032    getNextSurface(U032 currentSurface, U032 bSingleAdvance);
U032    getPrevSurface(U032 currentSurface);
U032    getPrevOverlaySurface(U032 targetSurface);
void    getCurrentNanoTimer(U032*   Most, U032* Least);

U032    HookUpVxdStorage(void);


#define INIT_FREE_COUNT(a) unsigned long freeCount = a;

#ifdef NV3
#define CHECK_FREE_COUNT(a,b)                       \
    ASSERT(b < NV_GUARANTEED_FIFO_SIZE );           \
    while (freeCount < b)                               \
        freeCount = NvGetFreeCount(a, 0);           \
    freeCount -= b;
#else
#define CHECK_FREE_COUNT(a,b)                       \
    ASSERT(b < NV06A_FIFO_GUARANTEED_SIZE );            \
    while (freeCount < b)                               \
        freeCount = NvGetFreeCount(a, 0);           \
    freeCount -= b;

#endif


#ifndef VPE_NT      // this is for win9x

#ifndef INVDDCODE
#define  GLOBDATAPTR         ((GLOBALDATA*)(pMySurfaces->pDriverData))
#else
#define  GLOBDATAPTR         ((GLOBALDATA*)(MySurfaces.pDriverData))
#endif  // INVDDCODE

#define  PBASEADDRESS    BaseAddress
#define  DWFBUFFERLEN    (GLOBDATAPTR->VideoHeapEnd - GLOBDATAPTR->BaseAddress)
#define  DEVHANDLE       dwDeviceHandle
#define  ROOTHANDLE      dwRootHandle
#define  CLIENTHANDLE    hClient

#else           // this is for NT
#define  GLOBDATAPTR        ((PDEV*)(pMySurfaces->pDriverData))
#define  PBASEADDRESS    pjFrameBufbase
#define  DWFBUFFERLEN    cbFrameBuf - 1

#define  DEVHANDLE       hDevice
#define  ROOTHANDLE      hDriver
#define  CLIENTHANDLE    hClient
#define

#endif


#endif //surfaces_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\src\vpoptimize.c ===
/*
 * vpoptimize.c
 *
 * Copyright 2000 NVIDIA, Corporation.  All rights reserved.
 * 
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** This file should only be compiled if it's needed.  The normal OpenGL ifdefs:
**
**      #if defined(GL_NV_vertex_program) && __NV_ACCEL>=10
**      #ifdef __GL_USE_OG_INTEL_ASM
**
** and any OpenGL includes like:
**
**      #include "context.h"
**
** can't be used since this is used by D3D as well.
**
*/

#include <stddef.h>

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"

#if !defined(TPRINTF)
#define TPRINTF(X)
#define NV_TRACE(X, Y, Z)
#define NV_TRACE_COND(X, Y, Z)
#endif

typedef struct vpOptimize_Rec {
    unsigned char LiveDead[__GL_NUMBER_OF_TEMPORARY_REGISTERS][4];
    unsigned char LiveMask[__GL_MAX_NUMBER_OF_INSTRUCTIONS];
    unsigned char resultRegsWritten[__GL_NUMBER_OF_RESULT_REGISTERS];
    int optimizeMask;
} vpOptimize;

/*
** lPrintVertexProgram() - Print a vertex program using TPRINTF.
*/

#if defined(_DEBUG)

static char *opcodes[] = { VERTEX_PROGRAM_OPCODE_NAMES };

static void lPrintReg(int freg, int Relative, int Offset)
{
    switch (freg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        TPRINTF(("v[%i]", freg - VA_0));
        break;
    case VR_0:  case VR_1:  case VR_2:  case VR_3:
    case VR_4:  case VR_5:  case VR_6:  case VR_7:
    case VR_8:  case VR_9:  case VR_10: case VR_11:
    case VR_12: case VR_13: case VR_14: case VR_15:
        TPRINTF(("o[%i]", freg - VR_0));
        break;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        if (Relative) {
            TPRINTF(("c[A0.x+%i]", Offset));
        } else {
            TPRINTF(("c[%i]", freg - PR_0));
        }
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        TPRINTF(("R%i", freg - TR_0));
        break;
    default:
        TPRINTF(("<<Bad Reg #%02x>>", freg));
    }
} // lPrintSrcReg

static void lPrintScalarSrcReg(ScalarSrcReg *reg)
{
    if (reg->Signed)
        TPRINTF((", -"));
    else
        TPRINTF((", "));
    lPrintReg(reg->reg.reg, reg->reg.AddrReg, reg->reg.addrRegOffset);
    TPRINTF((".%c", "xyzw"[reg->com & 3]));
} // lPrintScalarSrcReg

static void lPrintSwizzleSrcReg(SwizzleSrcReg *reg)
{
    char s[6];

    if (reg->Signed)
        TPRINTF((", -"));
    else
        TPRINTF((", "));
    lPrintReg(reg->reg.reg, reg->reg.AddrReg, reg->reg.addrRegOffset);
    if (reg->com4 != XYZW) {
        s[0] = '.';
        s[1] = "xyzw"[reg->com4 & 3];
        s[2] = "xyzw"[(reg->com4 >> 2) & 3];
        s[3] = "xyzw"[(reg->com4 >> 4) & 3];
        s[4] = "xyzw"[(reg->com4 >> 6) & 3];
        s[5] = '\0';
        TPRINTF(("%s", s));
    }
} // lPrintSwizzleSrcReg

static void lPrintMaskedDstReg(MaskedDstReg *reg)
{
    int mask;

    lPrintReg(reg->reg, 0, 0);
    if (reg->mask != DST_XYZW_BITS) {
        mask = reg->mask;
        TPRINTF(("."));
        if (mask & DST_X_BIT)
            TPRINTF(("x"));
        if (mask & DST_Y_BIT)
            TPRINTF(("y"));
        if (mask & DST_Z_BIT)
            TPRINTF(("z"));
        if (mask & DST_W_BIT)
            TPRINTF(("w"));
    }
} // lPrintMaskedDstReg

static void lPrintVertexProgram(ParsedProgram *parsed, int numInstructions, char *LiveMask)
{
    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int pc, lop, lmask, DeadInstruction;

    inst = parsed->firstInstruction;
    for (pc = 0; pc < numInstructions; inst++, pc++) {
        lop = inst->end_op.opcode;
        DeadInstruction = 0;
        TPRINTF(("%03d:  ", pc));
        if (LiveMask) {
            lmask = LiveMask[pc];
            if (lmask & 0x10) {
                TPRINTF(("      "));
            } else if (lmask & 0x20) {
                TPRINTF(("....  "));
                DeadInstruction = 1;
            } else {
                TPRINTF(("%c%c%c%c  ", "-*"[lmask & 1], "-*"[(lmask >> 1) & 1],
                                       "-*"[(lmask >> 2) & 1], "-*"[(lmask >> 3) & 1]));
                if (!(lmask & 0xf))
                    DeadInstruction = 1;
            }
        }
        TPRINTF(("%s  ", opcodes[lop]));
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            TPRINTF(("A0.x"));
            lPrintScalarSrcReg(&ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
        case OP_LOG:
#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
#endif // NV_INTERNAL_OPCODES
        case OP_RCP:
        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lPrintMaskedDstReg(&sinst->dst);
            lPrintScalarSrcReg(&sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lPrintMaskedDstReg(&vinst->dst);
            lPrintSwizzleSrcReg(&vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
        case OP_DP3:
        case OP_DP4:
#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
#endif // NV_INTERNAL_OPCODES
        case OP_DST:
        case OP_MAX:
        case OP_MIN:
        case OP_MUL:
        case OP_SGE:
        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lPrintMaskedDstReg(&binst->dst);
            lPrintSwizzleSrcReg(&binst->srcA);
            lPrintSwizzleSrcReg(&binst->srcB);
            break;

        // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lPrintMaskedDstReg(&tinst->dst);
            lPrintSwizzleSrcReg(&tinst->srcA);
            lPrintSwizzleSrcReg(&tinst->srcB);
            lPrintSwizzleSrcReg(&tinst->srcC);
            break;

        // NOPops:

        case OP_NOP:
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            TPRINTF((" ???"));
            break;
        }
        if (DeadInstruction) {
            TPRINTF(("  <<---<< Dead Instruction"));
        }
        TPRINTF(("\n"));
    }
} // lPrintVertexProgram
#endif // defined(_DEBUG)

#define LIVE 1
#define DEAD 0

/*
** lSetMaskedDstReg() - Mark registers set as "dead" prior to this point.
*/

static void lSetMaskedDstReg(vpOptimize *opData, int pc, MaskedDstReg *reg)
{
    unsigned char *LiveDead, *LiveMask;
    int mask, lreg;

    LiveMask = &opData->LiveMask[pc];
    lreg = reg->reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = opData->LiveDead[lreg - TR_0];
        mask = reg->mask;

        // Save current live bits for this register:

        LiveMask[0] = 0; // Mark as a temp register
        if (LiveDead[0] && (mask & DST_X_BIT))
            LiveMask[0] |= DST_X_BIT;
        if (LiveDead[1] && (mask & DST_Y_BIT))
            LiveMask[0] |= DST_Y_BIT;
        if (LiveDead[2] && (mask & DST_Z_BIT))
            LiveMask[0] |= DST_Z_BIT;
        if (LiveDead[3] && (mask & DST_W_BIT))
            LiveMask[0] |= DST_W_BIT;

        // Are we computing any values that won't be used?

        if (mask & ~LiveMask[0]) {
            NV_TRACE(TR_PROGRAM, 30, ("** Dead values: %03d  R%d sets=%d, but live=%d",
                                      pc, lreg - TR_0, mask, LiveMask[0]));
            mask = mask & LiveMask[0];
            if (opData->optimizeMask & (OPT_LIVE_DEAD | OPT_HPOS_ONLY)) {
                reg->mask = (unsigned char) mask;
                NV_TRACE(TR_PROGRAM, 30, ("\n"))
            } else {
                NV_TRACE(TR_PROGRAM, 30, (" ** Optimization Disabled\n"))
            }
        }

        // Mark any registers set as dead:

        if (mask & DST_X_BIT)
            LiveDead[0] = DEAD;
        if (mask & DST_Y_BIT)
            LiveDead[1] = DEAD;
        if (mask & DST_Z_BIT)
            LiveDead[2] = DEAD;
        if (mask & DST_W_BIT)
            LiveDead[3] = DEAD;
    } else {
        if (lreg >= VR_0 && lreg <= VR_15) {
            if ((opData->optimizeMask & OPT_HPOS_ONLY) && lreg != VR_0) {
                reg->mask = 0;
                LiveMask[0] = 0x20; // Dead write to non HPOS output register
            }
            opData->resultRegsWritten[lreg - VR_0] |= reg->mask;
        }
    }
} // lSetMaskedDstReg

/*
** lUseScalarSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lUseScalarSrcReg(vpOptimize *opData, char mask, ScalarSrcReg *reg)
{
    unsigned char *LiveDead;
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = opData->LiveDead[lreg - TR_0];
        if (mask) // Any output means we need the input
            LiveDead[reg->com & 3] = LIVE;
    }
} // lUseScalarSrcReg

/*
** lUseSwizzleSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lUseSwizzleSrcReg(vpOptimize *opData, char mask, SwizzleSrcReg *reg)
{
    unsigned char *LiveDead;
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = opData->LiveDead[lreg - TR_0];
        if (mask & DST_X_BIT)
            LiveDead[reg->com4 & 3] = LIVE;
        if (mask & DST_Y_BIT)
            LiveDead[(reg->com4 >> 2) & 3] = LIVE;
        if (mask & DST_Z_BIT)
            LiveDead[(reg->com4 >> 4) & 3] = LIVE;
        if (mask & DST_W_BIT)
            LiveDead[(reg->com4 >> 6) & 3] = LIVE;
    }
} // lUseSwizzleSrcReg

/*
** vp_Optimize() - Optimize a vertex program.
*/

void vp_Optimize(ParsedProgram *parsed, int numInstructions, int optimizeMask)
{
    vpOptimize opData;
    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int lop, pc, bit;
    char dstMask;

    NV_TRACE_COND(TR_PROGRAM, 30, {
        TPRINTF(("************ Entering optimizer.  Initial program is: ***************\n"));
        lPrintVertexProgram(parsed, numInstructions, NULL);
    });
    NV_TRACE_COND(TR_PROGRAM, 30, {
        if (optimizeMask & OPT_HPOS_ONLY) {
            TPRINTF(("************************************\n"));
            TPRINTF(("*** Generating HPOS-only Program ***\n"));
            TPRINTF(("************************************\n"));
        }
    });

    for (pc = numInstructions - 1; pc >= 0; pc--)
        opData.LiveMask[pc] = 0;
    for (pc = __GL_NUMBER_OF_TEMPORARY_REGISTERS - 1; pc >= 0; pc--)
        opData.LiveDead[pc][0] = opData.LiveDead[pc][1] =
                opData.LiveDead[pc][2] = opData.LiveDead[pc][3] = 0;
    for (pc = 0; pc < __GL_NUMBER_OF_RESULT_REGISTERS; pc++)
        opData.resultRegsWritten[pc] = 0;
    opData.optimizeMask = optimizeMask;

    for (pc = numInstructions - 1; pc >= 0; pc--) {
        opData.LiveMask[pc] = 0x10; // Not a temp register
        inst = &parsed->firstInstruction[pc];
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            lUseScalarSrcReg(&opData, DST_X_BIT, &ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
        case OP_LOG:
#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
#endif // NV_INTERNAL_OPCODES
        case OP_RCP:
        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &sinst->dst);
            lUseScalarSrcReg(&opData, sinst->dst.mask, &sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
            vinst = (Vector_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &vinst->dst);
            dstMask = (vinst->dst.mask != DST_NONE_BITS) ? DST_XYW_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &vinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &vinst->dst);
            lUseSwizzleSrcReg(&opData, vinst->dst.mask, &vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
        case OP_MAX:
        case OP_MIN:
        case OP_MUL:
        case OP_SGE:
        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            lUseSwizzleSrcReg(&opData, binst->dst.mask, &binst->srcA);
            lUseSwizzleSrcReg(&opData, binst->dst.mask, &binst->srcB);
            break;

        case OP_DP3:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZ_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;

        case OP_DP4:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZW_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZ_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZW_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? (DST_Y_BIT | DST_Z_BIT) : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? (DST_Y_BIT | DST_W_BIT) : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;

       // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &tinst->dst);
            lUseSwizzleSrcReg(&opData, tinst->dst.mask, &tinst->srcA);
            lUseSwizzleSrcReg(&opData, tinst->dst.mask, &tinst->srcB);
            lUseSwizzleSrcReg(&opData, tinst->dst.mask, &tinst->srcC);
            break;

        // NOPops:

        case OP_NOP:
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            break;
        }
    }

    // Remember which result registers are written:

    for (pc = 0; pc < __GL_NUMBER_OF_RESULT_REGISTERS; pc++)
        parsed->resultRegsWritten[pc] = opData.resultRegsWritten[pc];

    NV_TRACE_COND(TR_PROGRAM, 30, {
        TPRINTF(("** Output 0: "));
        for (pc = 0; pc < __GL_NUMBER_OF_RESULT_REGISTERS; pc++) {
            if (pc == 8)
                TPRINTF(("\n**        8: "));
            lop = opData.resultRegsWritten[pc];
            TPRINTF((" %c%c%c%c", "-*"[lop & 1], "-*"[(lop >> 1) & 1],
                      "-*"[(lop >> 2) & 1], "-*"[(lop >> 3) & 1]));
        }
        TPRINTF(("\n"));
    });

    // Mark any Live on Entry temp registers:

    parsed->liveOnEntry = 0;
    for (bit = 1, pc = 0; pc < __GL_NUMBER_OF_TEMPORARY_REGISTERS; bit <<= 1, pc++) {
        if (opData.LiveDead[pc][0] | opData.LiveDead[pc][1] |
            opData.LiveDead[pc][2] | opData.LiveDead[pc][3])
            parsed->liveOnEntry |= bit;
    };
    NV_TRACE_COND(TR_PROGRAM, 30, {
        if (parsed->liveOnEntry) {
            TPRINTF(("** Live On Entry Temps: "));
            for (pc = 0; pc < __GL_NUMBER_OF_TEMPORARY_REGISTERS; pc++) {
                TPRINTF((" %c%c%c%c", "-*"[opData.LiveDead[pc][0]], "-*"[opData.LiveDead[pc][1]],
                          "-*"[opData.LiveDead[pc][2]], "-*"[opData.LiveDead[pc][3]]));
            }
            TPRINTF(("\n"));
        } else {
            TPRINTF(("** No Live On Entry Temps.\n"));
        }
    });

    // Remove any dead instructions:

    for (pc = numInstructions - 1; pc >= 0; pc--) {
        if (opData.LiveMask[pc] == 0 || opData.LiveMask[pc] == 0x20) {
            inst = &parsed->firstInstruction[pc];
            inst->end_op.opcode = OP_NOP;
            NV_TRACE(TR_PROGRAM, 30, ("** Dead instruction at %03d **\n", pc));
        }
    }

    NV_TRACE_COND(TR_PROGRAM, 30, {
        TPRINTF(("************ Final program is: ***************\n"));
        lPrintVertexProgram(parsed, numInstructions, opData.LiveMask);
        TPRINTF(("************ Leaving optimizer ***************\n"));
    });
} // vp_Optimize
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\Surfaces.inc ===
; This file should mirror info in Surfaces.h ,vpcallnk.h, and VidTex.h where necessary

ifndef __SURFACES_INCLUDED__
__SURFACES_INCLUDED__   EQU     1


VDD_IOCTL_NV_FILLTABLE     EQU     20000667H
VDD_IOCTL_NV_GETSETCALLBACK	EQU     20000668H		
VDD_IOCTL_NV_SETVIDTEXSURF	EQU     20000669H		
 		

_NVVDDPROCTABLE STRUC
dwPDDDriver					DWORD   <>
getStoragePointer   		DD      ?
handleBufferInterrupts	DD      ?

_NVVDDPROCTABLE ENDS
LPNVVDDPROCTABLE STRUC  
        DD      ?
LPNVVDDPROCTABLE ENDS


endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\timing.h ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: timing.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           9/23/98                                          *
*                                                                           *
\***************************************************************************/

#ifndef timing_h
#define timing_h


#define	TIMINGTYPES			U032
#define  NOTIFYTRAN			(0x0 + 1 )

#define  NOTIFYIMG			(0x0 + 2 )
#define 	OVFLIPREQ			(0x0 + 3 )
#define 	OVFLIPNOT			(0x0 + 4 )
#define  TRANSFERRECRE		(0x0 + 5 )
#define  TRANSBUFTYPE      (0x0 + 6 ) 
#define  OVERLAYFAIL       (0x0 + 7 )
#define  PROGRAMVBI        (0x0 + 8 )
#define  PROGRAMIMG        (0x0 + 9 )
#define  NOTIFYVBI         (0x0 + 10 )
#define  CHECKCURBUF       (0x0 + 11 )
#define  CHECKLASTBUF      (0x0 + 12 )
#define  CHECKCURFLD       (0x0 + 13 )
// for the color control section
#define  ENTERCOLORCTL     (0x0 + 14 )
#define  LEAVECOLORCTL     (0x0 + 15 )
#define  WAITOCCCOLORCTL   (0x0 + 16 )
#define  WAITCHROMAARRIVE  (0x0 + 17 )
#define  WAITCHROMARETURN  (0x0 + 18 )
#define  WAITLUMAARIVE     (0x0 + 19 )
#define  WAITLUMARETURN    (0x0 + 20 )
#define  OVERLAYFLIPDEFERED (0x0 + 21 )
#define  DEFEREDOVERFLIP    (0x0 + 22 )

#define  TRANSFERLAUNCH		(0x0 + 23 )
#define  ALMEMRESTART      (0x0 + 24)

#define  NUMTIMTYPES 			 (ALMEMRESTART)


// this next one is used when the indice is hard to define in  that particular location
#define  INCNOTAP				(0xE)

#define  makeInd(vbibuf,vbisurf,imgbug,imgsurf) \
        (((((MySurfaces.DropSystem.dwDropFields & 0x3) | (MySurfaces.DropSystem.dwFullBool << 2))  & 0x0f) << 20)  |          \
			   ((INCNOTAP   & 0x0f) << 16)  |				\
			   ((vbibuf  & 0x0f) << 12)  |				\
			   ((vbisurf & 0x0f) << 8)  |				\
			   ((imgbug  & 0x0f) << 4 )  |				\
			   ((imgsurf & 0x0f)      )  )


#define  makeInd2(vbibuf,vbisurf,imgbug,imgsurf,field) \
         ( ((field   & 0x0f) << 16)  |          \
			  ((vbibuf  & 0x0f) << 12)  |				\
			  ((vbisurf & 0x0f) << 8)  |				\
			  ((imgbug  & 0x0f) << 4 )  |				\
			  ((imgsurf & 0x0f)      )  )


typedef struct _timeStore {

	U032					marker;
	U032					LoopCount;
	U032					Time0[MAXDATASTORE];
	U032					Time1[MAXDATASTORE];
	U032					SurfDat[MAXDATASTORE];
	U032					SurfIndex[MAXDATASTORE];
	U032					SurfPtr[MAXDATASTORE];
} timeStore;

void MarkTimingNot(TIMINGTYPES timingType,NvNotification*  pNot, U032 pSurf, U032 Indices);
void	MarkTiming(TIMINGTYPES timingType,U032 pSurf, U032 Indices);
void InitTiming(void);


#endif //timing_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\transfer.h ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: transfer.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/
// Implements a FIFO scheme to queue up transfer which the MTM engine will use

#ifndef TRANSFER_H
#define TRANSFER_H


#define MAXTRANSFERS	(10)
#define TRANSFERNOTINUSE (0xFEEDC0DE)

#ifdef DECENTENUMS
enum {
	QUEUED	= 30,
	PROGRAMMED,
	FINISHED,
	
} TRANSSTAT;
#else

#define TRANSSTAT U032
#define QUEUED      (30)
#define PROGRAMMED  (31)
#define FINISHED    (32)
#define ERRORED     (33)

#endif //DECENTENUMS

typedef struct _aTransfer
{
	U032			TransferID;		// if not equal to TRANSFERNOTINUSE then in use!
	TRANSSTAT	transferStatus;
	U032*			pNextTransfer;
	// "real" data from MS
	U032	SurfaceData;
	U032	StartLine;
	U032  EndLine;
	U032	TransferFlags;
	PMDL	DestMDL;
	
} aTransfer;

typedef aTransfer*	pTransfer;

// adds a transfer to the next position on the list
pTransfer AddTransfer(U032 TransferID);

pTransfer GetNextTransfer();

pTransfer FindTransfer(U032 TransferID);

U032 RemoveTransfer(U032 TransferID);

void CheckForLaunch(void);
U032 SetupMTM(void);
void TearDownMTM(void);

U032 checkNvAllocArchError(U032 error);

U032 UpdateStatus(void);

U032 CancelTransfer(DDTRANSFERININFO* pTransferInInfo);


#endif //TRANSFER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\vpcallbk.h ===
#ifndef __VPCALLBK_H__
#define __VPCALLBK_H__

/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: VPcallbk.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           5/28/98                                          *
*                                                                           *
\***************************************************************************/



typedef struct _sCallBack {
    DWORD       dwSize;             // should be set to the size of this structure
    DWORD       dwVersion;          // set this to 0x100
    DWORD       dwFlags;                //
    DWORD       lastBufferAddr; // address of just finished buffer ( the one the client should unload )
    DWORD    curBufferAddr;    // address of current input buffer ( one that is now being written to by MP )
    DWORD       intCount;           // free running interrupt counter - incremented for each time the callback is made
} sCallBack;

/* callback procedure pointer definition */

typedef VOID (* CALLBPROC)(sCallBack*);

/*  These macros should will be ORed together to form the flags field  */

/* field type */                        // Bit 0
#define     ODDFIELD            0x1
#define     EVENFIELD       0x0
/* address type */                  // bits 1-2 
                                            // indicates that the buffer address really an offset from the base of the frame buffer memory
#define     BUFFADROFFSET   0x2 
                                            // indicates that the buffer address is a Physical address
#define     BUFFADRPHYS     0x4
                                            // indicates that the buffer address is a linear address ( see note below)
#define     BUFFADRLIN      0x6
                                            // indicates that the buffer address is an index into the list from DDRAW
#define     BUFFADRINDEX    0x0     
/* surface type */                  //bits 4
                                            // indicates that the surface contains VBI data
#define     VBISURFACE      0x10        
                                            // indicates that the surface contains IMAGE data
#define     IMAGESURFACE    0x00        
                                            
                                            // should always be ORed in to indicate that the flags are valid
#define     USINGFLAGS      0x80        

/*   NOTES

Notes for the client:

Allways hold the callback routine in locked memory.
When setting the callback, it can be called even before SetCallback returned. In this
case the callback routine cannot know about the context. So the callback routine needs
to ignore calls until it knows about the context.

Notes about Linear Address:

If a linear address is used, this address must be a ring 3 addressable Address in System range.
It should be the same address as ddSurface->Lock method returns.

Notes about Surface Index:

If this is to be used the index order should be the determined by the
attachment order when the surfaces are created (FrontBuffer = 0,BackBuffer = 1 ....)
This is nornally indetically to the flipping order. ???

*/



// USE THIS IOCTL CODE TO GET YOUR SETCALLBACK FUNCTION POINTER:
#define VDD_IOCTL_NV_GETSETCALLBACK  0x20000668     
//  This IOCTL allows you to get an address for a routine which can be called to set the callback.
//  The idea behind the indirection is that an application can use the IOCTL to get an address
//  which an associated VXD can use to set callbacks into itself.  The VXD is also capable of resetting
//  the callbacks in the situation where the application has crashed and the VXD is unloading itself.
//  input to IOCTL is U032 and is ignored
//  output to IOCTL is U032 and is a function pointer to a function ie  SETCALLBPROC



// USE the following structures to actually SET a callback
// input pointer points to a structure
typedef struct _inSCBStruct {
    DWORD       flags;
    CALLBPROC   pTheCallback;
} inSCBStruct;
// output pointer points to a structure
typedef struct _outSCBStruct {
    DWORD   returnValue;
} outSCBStruct;

// USE THIS FUNCTION POINTER TO SET YOUR CALLBACK:

//DWORD vddSetCallback(inSCBStruct* inbuffer, outSCBStruct* outbuffer);
typedef VOID (* SETCALLBPROC)(inSCBStruct*  inbuffer, outSCBStruct* outbuffer);


/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */


// Here is some real basic example code

#ifdef JUST_EXAMPLE_CODE
        HANDLE bVXDHandle;
        U032     inBuffer;
        U032     outputSize;
        SETCALLBPROC    pSetCallback;
        
        inBuffer = 0;       
        
#ifdef NV3      
        bVXDHandle = CreateFile("\\\\.\\NV3", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
        bVXDHandle = CreateFile("\\\\.\\NV4", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif  // NV4      
        if((bVXDHandle != NULL ) && (bVXDHandle != INVALID_HANDLE_VALUE ) ){
            if(!DeviceIoControl(bVXDHandle,
                                        VDD_IOCTL_NV_GETSETCALLBACK,        // control code of operation to perform
                                        &inBuffer,                          // pointer to buffer to supply input data
                                        4,                                      // size of input buffer
                                        &pSetCallback,                      // pointer to buffer to receive output data
                                        4,                                      // size of output buffer
                                        &outputSize,                        // pointer to variable to receive output byte count
                                        NULL                                    // pointer to overlapped structure for asynchronous operation
                                    )
                 ){                 
                        // things worked, the
                        inSCBStruct     inBuf;
                        outSCBStruct    outBuf;
                        // NOTE USE OF FLAGS FROM VPCALLBk.h
                        inBuf.flags = IMAGESURFACE;
                        inBuf.pTheCallback = JoeCoolDudesCallbackRoutine;
                        
                        (pSetCallback)(&inBuf,&outBuf);
                        
            } else {
                        
                        // bummer, for some reason, we were unable to set your callback
            
            }
                    
            CloseHandle(bVXDHandle);
                                    
        }
        
        
#endif  //JUST_EXAMPLE_CODE 
    
    

#endif //__VPCALLBK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\VidTex.h ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: VidTex.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           11/16/98                                          *
*                                                                           *
\***************************************************************************/

#ifndef VidTex_h
#define VidTex_h

#ifndef U032
#define U032  unsigned long
#endif //U032

typedef struct _VidTexSurf {
	// this first record is probably not necessary
//	U032		frameBufferOffsetConv; // input	// bytes from base of FB to begin of color space converted image
	U032		frameBufferOffsetSwiz; // input	// bytes from base of FB to begin of swized image
	U032		width;				// input		//pixels			should be power of 2
	U032		height;				// input		//pixels			should be power of 2
	U032		pitch;				// input		// bytes			should be width * (bytes/pixel)
	U032		format;				// input		//Same as NV052_SET_FORMAT_COLOR_LE_XXXXXX  color
	U032		dwFrameCount;		// output	// is incremented each frame, and will simply wrap
	U032		bUpdateSystem;		// N/A/     this should be set to true each time you update the input records
										//          the VXD will set it back to false after updating context DMA etc
	U032		bContextsAllocated;	// N/A  used by VXD to keep track of contexts
} VidTexSurf;

void fillVidTexSurface(DWORD surface );
void initTextureSurf(void);
void DestroyTextureSurf(void);

#define VDD_IOCTL_NV_SETVIDTEXSURF 		0x20000669


/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */


// Here is some real basic example code

#ifdef JUST_EXAMPLE_CODE
	{
		HANDLE bVXDHandle;
		
		// These should _NOT NOT NOT_ be declared on the stack.. this is just _example_ code
		VidTexSurf MyVidTexureSurface;
		U032	 		outBuffer;
		U032			outputSize;
		
		VidTexSurf*	pVidTextureSurface = &MyVidTexureSurface;
		
		
		
		bVXDHandle = CreateFile("\\\\.\\NV4", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);

		if((bVXDHandle != NULL ) && (bVXDHandle != INVALID_HANDLE_VALUE ) ){
			if(!DeviceIoControl(bVXDHandle,
										VDD_IOCTL_NV_SETVIDTEXSURF,		// control code of operation to perform
										&pVidTextureSurface,							// pointer to buffer to supply input data
										4,										// size of input buffer
										&outBuffer,						// pointer to buffer to receive output data
										4,										// size of output buffer
										&outputSize,						// pointer to variable to receive output byte count
										NULL 									// pointer to overlapped structure for asynchronous operation
									)
				 ){					
					// things worked, the 
					if(outBuffer != 0 ) {
						// error check outBuffer error code
					
					}						
			} else {
							// error check outBuffer error code
			}
					
			CloseHandle(bVXDHandle);
									
		}
		
		
#endif  //JUST_EXAMPLE_CODE	
	
	


#endif //VidTex_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\inc\nvpecntx.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1993-1999. All rights reserved.

    nvpecntx.h

    VPE kernel context definition. This is a shared file with Win9x minivdd

    Dec 17, 1999

==============================================================================
*/
#ifndef _NVPECNTX_H
#define _NVPECNTX_H

#define NVP_MAX_VPORTS				1
#define NVP_MAX_SURFACES    		5
#define NVP_MAX_TRANSFER_BUFFERS	10
#define NVP_MAX_EXTRA422            10
#define NVP_MAX_SYNC_EVENTS         3   // defined also in nvpesrvc.h and nvpkrnl.c !!!

//
// Surface definition (Video or VBI) and related data
//
typedef struct _NVP_SURFACE_INFO
{
    //HANDLE              hSurface;           // DirectDraw surface handle
    ULONG               dwCaps;             // capabilites of this DD surface
    ULONG               pVidMem;            // Flat pointer to the surface
    ULONG               dwOffset;           // Offset from the base of the frame buffer
    ULONG               dwPitch;
    ULONG               dwLength;               
    ULONG               dwHeight;               
    ULONG               dwWidth;            // Ignored for VBI
    ULONG               dwStartLine;        // Programs Y-crop for image, and startline for vbi
    ULONG               dwPreScaleSizeX;    // Ignored for VBI.. prescale size width
    ULONG               dwPreScaleSizeY;    // Ignored for VBI.. prescale size height
    ULONG               dwFieldType;        // what field was this surface setup to capture?
    //ULONG               bAutoFlip;          // do we turn around and auto program this surface?
	ULONG				bIsFirstFieldCaptured;

    LONG                nNextSurfaceIdx;     // the next surface idx in the chain
    LONG                nPrevSurfaceIdx;     // the previous surface, used for FS Mirror

} NVP_SURFACE_INFO, *PNVP_SURFACE_INFO;

// Overlay info
typedef struct _NVP_OVERLAY {
	ULONG 	dwOverlayFormat;
	ULONG 	dwOverlaySrcX;
	ULONG 	dwOverlaySrcY;
	ULONG 	dwOverlaySrcPitch;
	ULONG 	dwOverlaySrcSize;
	ULONG 	dwOverlaySrcWidth;
	ULONG 	dwOverlaySrcHeight;
	ULONG 	dwOverlayDstWidth;
	ULONG 	dwOverlayDstHeight;
	ULONG   dwOverlayDstX;
    ULONG   dwOverlayDstY;
	ULONG   dwOverlayDeltaX;
	ULONG   dwOverlayDeltaY;
	ULONG   dwOverlayColorKey;
	ULONG   dwOverlayMode;
    ULONG   aExtra422OverlayOffset[NVP_MAX_EXTRA422];	// extra memory space used for prescaling
    ULONG   dwExtra422Index;			// index of current extra surface
    ULONG   dwExtra422NumSurfaces;      // number of extra allocated surfaces
	ULONG   dwExtra422Pitch;            // extra surface pitch
	ULONG   pNvPioFlipOverlayNotifierFlat;
	ULONG   dwOverlayMaxDownScale;
	ULONG   dwOverlayBufferIndex;
	ULONG 	dwReserved1;
	ULONG 	dwReserved2;
} NVP_OVERLAY, *PNVP_OVERLAY;

// Transfer
typedef struct _NVP_TRANSFER_BUFFER
{
	ULONG	dwTransferId;
	ULONG	dwTransferStatus;
	ULONG	pSurfaceData;
	//LONG	nSurfaceIdx;	// Idx of surface we're transfering from
	LONG	lStartLine;
	LONG 	lEndLine;
	ULONG	dwTransferFlags;
	ULONG	pDestMDL;
	LONG	nNextTransferIdx;
	LONG	nPrevTransferIdx;
} NVP_TRANSFER_BUFFER, *PNVP_TRANSFER_BUFFER;

// transfer status 
#define NVP_TRANSFER_QUEUED			0x01
#define NVP_TRANSFER_IN_PROGRESS	0x02
#define NVP_TRANSFER_DONE			0x03
#define NVP_TRANSFER_FAILURE		0x04
#define NVP_TRANSFER_FREE			0xFFFFFFFF

//
// NVidia Video Port context
//
typedef struct _NVP_CONTEXT
{
    NVP_SURFACE_INFO    aVideoSurfaceInfo[NVP_MAX_SURFACES];
    NVP_SURFACE_INFO    aVBISurfaceInfo[NVP_MAX_SURFACES];
 
    // Full screen mirror context information
    ULONG               dwOverlayFSOvlHead;    
    int                 MultiMon;               // True/False: whether there are multiple monitors
    NVP_SURFACE_INFO    aFSMirrorSurfaceInfo[NVP_MAX_SURFACES];  //Fullscreen mirror surface pointers 
    int                 nNumFSSurf;			    // number of allocated fullscreen mirror surfaces 
    int                 nFSFlipSurfIdx;         // current fullscreen mirror surface index 
    int                 nFSMirrorIdx;           // current completed
    int                 nFSFlipIdx;             // simple flip modifier for CRTC
    ULONG               regOverlayMode;         // pass these down from pDriver Data and through to kernel
    ULONG               regOverlayMode2;        // might even need zoom modes , and aspect ratios.
    ULONG               regOverlayMode3;
    ULONG               dwOverlayFSHead;        // which head is the overlay on? not sure if we need this
    ULONG               dwFsMirrorOn;           // signifies that Fsmirror is currently on.
    ULONG               dwDesktopState;
    UCHAR               adacNotifiers[16*9];    // (DAC notifiers) NvNotification 
    UCHAR               as2mNotifiers[16*1];    // s2m notifiers NvNotification
    UCHAR               asrfNotifiers[16*1];    // cont surface 2d notifiers , we need NVP_MAX_SURFACES
    
    int                 nNumVidSurf;			// number of allocated video surfaces
    int                 nNumVBISurf;			// number of allocated vbi surfaces
    int                 nVidSurfIdx;    		// current video surface index
    int                 nVBISurfIdx;    		// current vbi surface index

	int 				nNextVideoSurfId;
	int 				nNextVBISurfId;

	int 				nLastFieldId;			// Id of last field captured
	ULONG				bLastFieldType;			// type of last field captured (TRUE if VBI, FALSE if VIDEO)

	ULONG				dwVPState;				// NVP_STATE_STOPPED, NVP_STATE_STARTED
	ULONG				dwVPFlags;
	ULONG				dwVPConFlags;			// connection flags

	ULONG				dwChipId;				// chip version Id
	ULONG				hClient;
	ULONG				dwDeviceId;				// NV_WIN_DEVICE
    ULONG               pFrameBuffer;  // frame buffer base address
    ULONG               dwFBLen;       // frame buffer length

	ULONG				dwOverlayObjectID;		// overlay object Id (shared object!)
	ULONG				dwScalerObjectID;		// scaler object Id
	ULONG				dwDVDSubPicObjectID;	// used for prescaling on nv4 and nv5 
	ULONG               dwDVDObjectCtxDma;      // context dma used for synchronization.
	int					nFreeCount;		// fifo free count

    // BUGBUG: hacking declerations to avoid including hardware dependent header files 
    //         in "nv.h"
    ULONG               pNVPChannel;            // NvChannel *pNVPChannel; // VPE pio channel
    UCHAR               avpNotifiers[16*9];     // (Media port notifiers) NvNotification avpNotifiers[NVP_CLASS04D_MAX_NOTIFIERS];
    UCHAR               aovNotifiers[16*3];     // (Overlay notifiers) NvNotification aovNotifiers[NVP_CLASS07A_MAX_NOTIFIERS];

	// overlay
	NVP_OVERLAY			nvpOverlay;				// information retrieved from UpdateOverlay32() in Ring3
	ULONG				pOverlayChannel;		// NvChannel *pOverlayChannel; // Overlay channel
	ULONG				dwOvrSubChannel;
    ULONG                          pOvrRing0FlipFlag;

	// vidmem to sysmem transfer (vbi and video capture !)
	NVP_TRANSFER_BUFFER aTransferBuffers[NVP_MAX_TRANSFER_BUFFERS];
	UCHAR				axfNotifiers[16*6];	// 
	int					nCurTransferIdx;	// current transfer buffer index
	int					nLastTransferIdx;
	int					nRecentTransferIdx;	// index of most recently transfered buffer
	int					nNumTransfer;		// current number of transfer buffer in queue
	ULONG				bxfContextCreated;	// TRUE if context already created
	ULONG				bxfContextFlushed;	// TRUE if context flushed
	ULONG				dwTransferCtxStart;	// old transfer context start
	ULONG				dwTransferCtxSize;	// transfer size

	PVOID				hNVPSyncEvent[NVP_MAX_SYNC_EVENTS];		// media port and overlay sync event handle // PKEVENT hVSyncEvent;

	// DMA push buffer
	PVOID				pDmaChannel;
	ULONG				*nvDmaFifo;
	ULONG				nvDmaCount;
	ULONG				DmaPushBufTotalSize;	// 32k DWORDs
	UCHAR				DmaPushBufErrNotifier[16*1];

	// WDM prescale stuff
	ULONG				ulVPECaptureFlag;			//hack for WDM ME prescaling when capturing to disk
	ULONG				ulVPECapturePrescaleYFactor;	//hack for WDM ME prescale. Y-scale factor
	ULONG				ulVPECapturePrescaleXFactor;	//hack for WDM ME prescale. X-scale factor
	ULONG				ulVPNotUseOverSurf;			//flag for VP using over surf.

	//m2m xfer stuff
	PVOID				pSysBuf;				//dst surf for dma xfer
	ULONG				ulCap;					//capture flag

	ULONG				dwDecoderHeight;			//need this to determine single or dual field capture

} NVP_CONTEXT, *PNVP_CONTEXT;

#endif // _NVPECNTX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\inc\nvpecore.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    nvpecore.h

    Local definitions used by vpe and kernel mode video transport

    Dec 17, 1999

==============================================================================
*/

#ifdef _WIN32_WINNT

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv32.h"
#include "nvos.h"
#include "nvpeos.h"

#include "nvpekmvt.h"

#else // _WIN32_WINNT

// MS includes
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <vwin32.h>

// NV includes 
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include <nvrmr0api.h>

#include "ddkmmini.h"

#include "nvpeos.h"

#endif // _WIN32_WINNT

//// VPE/kernel interface 
#include "nvpesrvc.h"


#define BUFSIZE	720*(576+4)*2	//size of sys mem buffer for dma xfer

//some debug stuff

extern int DebugLevel;

#ifndef _WIN32_WINNT
#define KdPrint(DBG_STR)	{	_Debug_Printf_Service("NVPECORE: ");	\
								_Debug_Printf_Service(DBG_STR);			\
								_Debug_Printf_Service("\n");}

#define KdPrintValue(DBG_STR, DBG_VALUE)	{	_Debug_Printf_Service("NVPECORE: ");	\
								_Debug_Printf_Service("%s %d", DBG_STR, DBG_VALUE);				\
								_Debug_Printf_Service("\n");}
#else
#define KdPrint(DBG_STR)	{	DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVPECORE: ");	\
								DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, DBG_STR);			\
								DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "\n");}

#define KdPrintValue(DBG_STR, DBG_VALUE)	{	DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVPECORE: ");	\
								DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, DBG_STR, DBG_VALUE);			\
								DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "\n");}
#endif

#define DBGERROR	0
#define DBGWARN		1
#define DBGINFO		2
#define DBGTRACE	3
#define DBGPRINT(DbgLevel, DbgStr)	{if(DebugLevel >= DbgLevel) {KdPrint(DbgStr);}}
#define DBGPRINTVALUE(DbgLevel, DbgStr, DbgValue)	{if(DebugLevel >= DbgLevel) {KdPrintValue(DbgStr, DbgValue);}}
								
#define NVP_CLASS04D_MAX_NOTIFIERS			9
#define NVP_CLASS039_MAX_NOTIFIERS			2
#define NVP_CLASS07A_MAX_NOTIFIERS          3

#ifdef VPEFSMIRROR
// [XW:09/29/2000]
#define NVP_CLASS089_MAX_NOTIFIERS          1
#define NVP_CLASS07C_MAX_NOTIFIERS          9

#define NVP_VIDEO_LUT_DAC_SUBCHANNEL 3
#define NVP_SCALED_IMAGE_SUBCHANNEL  4
#define NVP_FREE_SUBCHANNEL          7

// [XW:09/26/2000] FS Mirror Functions
VP_STATUS NVPIsFsMirrorEnabled(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pInCmdObj);
VP_STATUS NVPFsRegSurface(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPFsMirrorEnable(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPFsMirrorDisable(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPFsFlip(PNVP_CONTEXT pVPEContext,int nFieldId);
VP_STATUS NVPFsMirror(PNVP_CONTEXT pVPEContext,PNVP_OVERLAY pOverlayInfo,DWORD dwOffset,DWORD dwPitch,DWORD dwWidth,DWORD dwHeight,DWORD dwIndex,DWORD dwFlags);

#ifdef _WIN32_WINNT

void NVPFsCRTCField0Notify(PVOID pHwDeviceExtension);
void NVPFsCRTCField1Notify(PVOID pHwDeviceExtension);
#else

void NVPFsCRTCField0Notify();
void NVPFsCRTCField1Notify();
extern nvpeDevExtension;
#endif


#endif

#ifndef NV01_CONTEXT_DMA
#define NV01_CONTEXT_DMA   NV01_CONTEXT_DMA_FROM_MEMORY
#endif 

#define NVP_VPP_TIME_OUT    10000

///////
/// BUGBUG: taken from dvp.h !!! 
#define DDVP_AUTOFLIP                   0x00000001l
#define DDVP_INTERLEAVE 				0x00000008l
#define DDVP_SKIPEVENFIELDS				0x00000080l
#define DDVP_SKIPODDFIELDS				0x00000100l
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l
#define DDVPCONNECT_INTERLACED			0x00000020l

#define DDFLIP_EVEN                     0x00000002L
#define DDFLIP_ODD                      0x00000004L

#define NV_VFM_FORMAT_BOBFROMINTERLEAVE 0x08000000l

/// equivalent in nvReg.h
#define VPP_ODD            0x001
#define VPP_EVEN           0x002
#define VPP_BOB            0x004
#define VPP_INTERLEAVED    0x008
#define VPP_PRESCALE       0x400

#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4

#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifndef NV_IN_PROGRESS
#define NV_IN_PROGRESS (0x8000)
#endif

#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L


#ifdef	asmMergeCoords
#undef	asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif // mmioFOURCC

///////////
// external services
//

#ifndef NvGetFreeCount
#if defined NV10 || defined NV4
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.Free
#else   /* !(NV10 || NV4) */
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.free
#endif  /* !(NV10 || NV4) */
#endif

//////////
// DMA channel macros
//
#define NVP_JUMP(ADDR)		(0x20000000 | (ADDR))
#define NVP_DECODER_SUBCHANNEL	0
#define NVP_M2M_SUBCHANNEL		1
#define NVP_DMAPUSH_WRITE1(SUBCH, METHOD_OFFSET, METHOD_VALUE)              			\
{\
	pVPEContext->nvDmaFifo[nvDmaCount++] = ((1 <<18) | ((SUBCH)<<13) | (METHOD_OFFSET)); \
    pVPEContext->nvDmaFifo[nvDmaCount++] = METHOD_VALUE;                        			\
}
// assuming the FIFO is at least twice (2x + 1) the size of NEEDED_DWORDS
#define NVP_DMAPUSH_CHECK_FREE_COUNT(NEEDED_DWORDS)		\
{	\
	if ((nvDmaCount + (NEEDED_DWORDS)) >= (pVPEContext->DmaPushBufTotalSize >> 2))	\
	{	\
		pVPEContext->nvDmaFifo[nvDmaCount] = 0x20000000;	\
		nvDmaCount = 0;	\
		DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "nvpecore: DMA wrap around...\n");\
	}	\
}

////////////
// local functions prototypes
//
void VideoField0Notify(PVOID pHwDeviceExtension);
void VideoField1Notify(PVOID pHwDeviceExtension);
void VBIField0Notify(PVOID pHwDeviceExtension);
void VBIField1Notify(PVOID pHwDeviceExtension);
void NVPProgVideoField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId, U032 dwSurfPitch, U032 dwInterleaveOffset, BOOL bGrab);
void NVPProgVBIField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId);
VP_STATUS NVPProcessState(PHW_DEVICE_EXTENSION pHwDevExt, int nFieldId,	BOOL bVBIField);
VP_STATUS NVPScheduleOverlayFlip(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int  nImageId, U032 dwSrcPitch, U032 dwMoveDownOffset);
VP_STATUS DoProgressive(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoWeave(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBob(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBobFromInterleaved(PNVP_CONTEXT pVPEContext, int nFieldId);
BOOL NVPGetSurface(	PNVP_CONTEXT pVPEContext,U032 dwSurfOffset, PNVP_SURFACE_INFO *pSurface);
void NVPTransferNotify(PVOID pHwDevExtension);
DWORD NVPCheckTransferStatus(PHW_DEVICE_EXTENSION pHwDevExt);
DWORD NVPCancelTransfer(PNVP_CONTEXT pVPEContext, DDTRANSFERININFO* pInInfo);
DWORD NVPRemoveTransfer(PNVP_CONTEXT pVPEContext, int nTransferIdx);
DWORD NVPAddTransfer(PNVP_CONTEXT pVPEContext, PNVP_DDTRANSFERININFO pInInfo, BOOL bIsOddField);
DWORD NVPGetTransferStatus(PVOID pContext, PVOID pNotUsed, PNVP_DDGETTRANSFEROUTINFO pOutInfo);
DWORD NVPCheckForLaunch(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface);
DWORD NVPRecreateContext(PNVP_CONTEXT pVPEContext, PMDL pDestMDL);
DWORD NVPTransfer(PVOID pContext, PNVP_DDTRANSFERININFO pInInfo, PNVP_DDTRANSFEROUTINFO pOutInfo);
PVOID GetHwInfo(PVOID HwDevExt);
BOOL NVPPrescaleAndFlip(PNVP_CONTEXT pVPEContext, PNVP_OVERLAY pOverlayInfo, DWORD dwOffset, DWORD dwPitch, DWORD dwIndex, DWORD dwFlags);
VP_STATUS NVPFlipVideoPort(PHW_DEVICE_EXTENSION pHwDevExt, NVP_CMD_OBJECT *pCmdObj);
DWORD kmvtNVPCallbackDxApi(PVOID *pContext, DWORD dwIRQSource);
VP_STATUS NVPInitialize(PHW_DEVICE_EXTENSION pHwDevExt,	NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPIsVPEEnabled(PHW_DEVICE_EXTENSION pHwDevExt, NVP_CMD_OBJECT *pInCmdObj, NVP_CMD_OBJECT *pOutCmdObj);

#ifdef _WIN32_WINNT
VP_STATUS NVRegistryCallbackPnpId(PVOID HwDeviceExtension, PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\inc\nvpkrnl.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright
    1996,1997,1998,1999. All rights reserved.

    nvpkrnl.h

    DDrawVPE-Miniport interface header

    Feb 10, 1999

==============================================================================
*/

#ifndef _NVPKRNL_H
#define _NVPKRNL_H

#include "nvprecomp.h"

// event indices
#define NVP_EVENT_MEDIAPORT 0
#define NVP_EVENT_OVERLAY1  1
#define NVP_EVENT_OVERLAY2  2
#define NVP_EVENT_MAX       3

typedef enum _NVP_STATUS {
    NVP_STATUS_SUCCESS  = 0x0,
    NVP_STATUS_FAILURE,
    NVP_STATUS_NOT_IMPLEMENTED,
    MVP_STATUS_INVALID_ARGUMENT
} NVP_STATUS;

// interface to Miniport
NVP_STATUS NVPInitialize(	GLOBALDATA *pDriverData, DWORD dwVPConnectionFlags, 
							LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
NVP_STATUS NVPUninitialize(GLOBALDATA *pDriverData);
NVP_STATUS NVPStartVideo(LPDDHAL_UPDATEVPORTDATA lpInput);
NVP_STATUS NVPStopVideo(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
NVP_STATUS NVPUpdateVideo(LPDDHAL_UPDATEVPORTDATA lpInput);
NVP_STATUS NVPWaitForSync(GLOBALDATA *pDriverData, DWORD dwIndex, DWORD dwTimeOut);
NVP_STATUS NVPFlipVideoPort(LPDDHAL_FLIPVPORTDATA lpInput);

#ifdef VPEFSMIRROR

// [XW:09/27/2000] FS Mirror 
NVP_STATUS NVPFsMirrorEnable(GLOBALDATA *pDriverData);
NVP_STATUS NVPFsMirrorDisable(GLOBALDATA *pDriverData);

#endif

#ifdef __cplusplus
extern "C" {
#endif
DWORD __stdcall NVPUpdateOverlay(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
BOOL  __stdcall NVPIsVPEEnabled(GLOBALDATA *pDriverData, DWORD);
DWORD __stdcall NVPCleanUp(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\inc\nvpe.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    nvpe.h

    NVIDIA's VPE driver header

    Jan 27, 1999

==============================================================================
*/

#ifndef _NVPE_H
#define _NVPE_H

// NVP defines
#define NVPAPI  __stdcall

//limit values for VP config
#define NV_MAX_FIELDWIDTH 2000	//since max now is 1920
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#define NV_MAX_FIELDHEIGHT	1200	//since max now is 1080i

// provides access to the global data structures in ddmini.h
//extern GLOBALDATA *pDriverData;

// NVP function prototypes
DWORD NVPAPI CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput);
DWORD NVPAPI CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput);
DWORD NVPAPI FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput);
DWORD NVPAPI GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput);
DWORD NVPAPI GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput);
DWORD NVPAPI GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput);
DWORD NVPAPI GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput);
DWORD NVPAPI GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput);
DWORD NVPAPI GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput);
DWORD NVPAPI DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput);
DWORD NVPAPI GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput);
DWORD NVPAPI UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput);
DWORD NVPAPI WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput);
DWORD NVPAPI GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput);	

//
// NVIDIA VP caps
// 
const DDVIDEOPORTCAPS g_ddNVideoPortCaps =
{
    sizeof(DDVIDEOPORTCAPS),    // size of the DDVIDEOPORTCAPS structure
    DDVPD_WIDTH             |
    DDVPD_HEIGHT            |
    DDVPD_ID                |
    DDVPD_CAPS              |
    DDVPD_FX                |
    DDVPD_AUTOFLIP          |
    DDVPD_ALIGN             |
    0,
    4096,                       // VP max width
    4096,                       // max VBI data width
    640,                        // VP max height
    0,                          // VP ID (0 - (dwMaxVideoPorts-1))
    DDVPCAPS_AUTOFLIP       |   // suport autoflip buffers
    DDVPCAPS_INTERLACED     |
    DDVPCAPS_NONINTERLACED  |
    DDVPCAPS_READBACKFIELD  |
//  DDVPCAPS_READBACKLINE   |   // not supported
//  DDVPCAPS_SHAREABLE      |   // not supported 
    DDVPCAPS_SKIPEVENFIELDS |   // can skip even fields
    DDVPCAPS_SKIPODDFIELDS  |   // can skip odd fields
//  DDVPCAPS_SYNCMASTER     |   // not supported
    DDVPCAPS_VBISURFACE     |   // VBI support
	DDVPCAPS_OVERSAMPLEDVBI |
	DDVPCAPS_VBIANDVIDEOINDEPENDENT |	
//  DDVPCAPS_COLORCONTROL   |   // not supported
    0,
    DDVPFX_CROPTOPDATA      |   // 
//  DDVPFX_CROPX            |
//  DDVPFX_CROPY            |
    DDVPFX_INTERLEAVE       |
//  DDVPFX_MIRRORLEFTRIGHT  |   // not supported
//  DDVPFX_MIRRORUPDOWN     |   // not supported
//  DDVPFX_PRESHRINKX       |   // not supported
    DDVPFX_PRESHRINKY       |   // not supported
//  DDVPFX_PRESHRINKXS      |   // not supported
//  DDVPFX_PRESHRINKYS      |   // not supported
    DDVPFX_PRESHRINKXB      |   // down to 1/2, 1/4, 1/8 or 1/16
//  DDVPFX_PRESHRINKYB      |   // 
//  DDVPFX_PRESTRETCHX      |   // LPB never stretches
//  DDVPFX_PRESTRETCHY      |   // LPB never stretches
//  DDVPFX_PRESTRETCHXN     |   // LPB never stretches
//  DDVPFX_PRESTRETCHYN     |   // LPB never stretches
    DDVPFX_VBICONVERT       |
    DDVPFX_VBINOSCALE       |
    DDVPFX_VBINOINTERLEAVE  |
    DDVPFX_IGNOREVBIXCROP   |
    0,
    5,                          // Number of autoflippable surfaces
    8,                          // Byte restriction of placement within surface    ////// BUGBUG must change to NV_BYTE_ALIGNMENT
    1,                          // Byte restriction of width after prescaling
    1,                          // Byte restriction of left cropping
    1,                          // Byte restriction of cropping width
    24,                         // shrink in steps of original width
    0x400,                      // shrink in steps of original height
    5,							// Max number of VBI autoflippable surfaces allowed
    3,							// Optimal number of autoflippable surfaces for hardware
    2,                          // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    1                           // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)

};

//
// NVIDIA VP Callbacks
//
const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks =
{
    sizeof(DDHAL_DDVIDEOPORTCALLBACKS),
    DDHAL_VPORT32_CANCREATEVIDEOPORT |
    DDHAL_VPORT32_CREATEVIDEOPORT |
    DDHAL_VPORT32_FLIP |
    DDHAL_VPORT32_GETBANDWIDTH |
    DDHAL_VPORT32_GETINPUTFORMATS |
    DDHAL_VPORT32_GETOUTPUTFORMATS |
    DDHAL_VPORT32_GETFIELD |
    DDHAL_VPORT32_GETLINE |
    DDHAL_VPORT32_GETCONNECT |
    DDHAL_VPORT32_DESTROY |
    DDHAL_VPORT32_GETFLIPSTATUS |
    DDHAL_VPORT32_UPDATE |
    DDHAL_VPORT32_WAITFORSYNC |
    DDHAL_VPORT32_GETSIGNALSTATUS |
    //DDHAL_VPORT32_COLORCONTROL |
    0,
    &CanCreateVideoPort32,
    &CreateVideoPort32,
    &FlipVideoPort32,
    &GetVideoPortBandwidth32,
    &GetVideoPortInputFormat32,
    &GetVideoPortOutputFormat32,
    NULL,
    &GetVideoPortField32,
    &GetVideoPortLine32,
    &GetVideoPortConnectInfo,
    &DestroyVideoPort32,
    &GetVideoPortFlipStatus32,
    &UpdateVideoPort32,
    &WaitForVideoPortSync32,
    &GetVideoSignalStatus32,
    NULL
};

//
// Kernel callbacks table exported through the GetDriverInfo interface
//
const DDHAL_DDKERNELCALLBACKS KernelCallbacks =
{
    sizeof(DDHAL_DDKERNELCALLBACKS),
    // DDHAL_KERNEL_SYNCSURFACEDATA | 
    // DDHAL_KERNEL_SYNCVIDEOPORTDATA | 
    0,
    NULL,	// SafeSyncSurfaceData
    NULL	// SafeSyncVideoPortData
};

//
// NVIDIA VP connection caps
// 
const DWORD g_dwNVPConnectionCaps = { 
	//DDVPCONNECT_DOUBLECLOCK			|
	//DDVPCONNECT_VACT					|
	DDVPCONNECT_INVERTPOLARITY		|
	/* we discard at least until the V bit goes low, and potentially more depending
	  on the setting of YCROP  as well as the current VBI situation  */
	//DDVPCONNECT_DISCARDSVREFDATA	|
	DDVPCONNECT_HALFLINE			|
	/*  these next are "client" only 
	//DDVPCONNECT_INTERLACED			|
	//DDVPCONNECT_SHAREEVEN			|
	//DDVPCONNECT_SHAREODD				|
	*/
	0 
};

// video format
DDPIXELFORMAT g_aNVPVideoFormat[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC, mmioFOURCC('U','Y','V','Y'), 16, (DWORD)-1, (DWORD)-1, (DWORD)-1},
};

// VBI format
DDPIXELFORMAT g_aNVPVBIFormat[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC, mmioFOURCC('R','A','W','8'), 8, (DWORD)-1, (DWORD)-1, (DWORD)-1},
};

// driver global data
//extern 		GLOBALDATA*			pDriverData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\inc\nvpesrvc.h ===
#ifndef _NVPESRVC_H
#define _NVPESRVC_H

#define _USE_DMA

#define NVP_MAX_EXTRA_SURF_422    10
#define NVP_SYNC_EVENT_MAX        3


// data structure used to communicate with miniport
typedef struct _NVP_CMD_OBJECT {
	U032		dwSize;
	U032		dwChipId;	// chip version Id
	U032		dwPortId;	// usually 0 unless there are more than one VP on the chip
	U032		dwDeviceId;	// NV_WIN_DEVICE
	U032		dwSrvId;	// service ID	
	U032		hClient;
	U032        pChannel;		// VPE pio channel
	U032        pOvrChannel;  	// Overlay channel
	U032		dwOvrSubChannel;
	U032		pFrameBuffer;
	U032		dwFBLen;


	U032		dwOverlayObjectID;
	U032		dwScalerObjectID;
	U032		dwDVDObjectID;
    U032        dwDVDObjectCtxDma;
	// VP flags
	U032		dwVPTypeFlags;	// VP connection flag
	U032		dwVPInfoFlags;

	// image attributes
	U032		dwImageStartLine;
	U032		dwVBIStartLine;
	U032		dwInWidth;
	U032		dwInHeight;
	U032		dwPreWidth;
	U032		dwPreHeight;
	U032		dwOriginX;
	U032		dwOriginY;
	U032		dwVBIHeight;

	// surface
	U032		pSurfVidMem;	// address of surface
	U032		dwSurfaceId;	// 0 based surface index 
	U032		dwSurfPitch;	// in bytes
	U032		dwSurfOffset;	// offset from the beginning of the framebuffer
	U032		bSurfVBI;		// TRUE if VBI surface, FALSE for video
	U032		bSurfUpdate;	// TRUE if updating the surfaces attibutes only

	// overlay
	U032 		dwOverlayFormat;
	U032 		dwOverlaySrcX;
	U032 		dwOverlaySrcY;
	U032 		dwOverlaySrcPitch;
	U032 		dwOverlaySrcSize;
	U032 		dwOverlaySrcWidth;
	U032 		dwOverlaySrcHeight;
	U032 		dwOverlayDstWidth;
	U032 		dwOverlayDstHeight;
	U032        dwOverlayDstX;

    U032        dwOverlayDstY;
	U032        dwOverlayDeltaX;
    
	U032        dwOverlayDeltaY;


    U032        dwOverlayColorKey;    
	U032        dwOverlayMode;

    // For FS Mirror
    U032        dwOverlayFSOvlHead;
    U032        MultiMon;
    U032        regOverlayMode2;
    U032        regOverlayMode3;
    U032        regOverlayMode;
    U032        dwOverlayFSHead;
    U032        dwDesktopState;
    U032        dwSurfHeight;
    U032        dwSurfWidth;    
    
	U032        dwOverlayMaxDownScale;
	U032 		aExtra422OverlayOffset[NVP_MAX_EXTRA_SURF_422];
    U032        dwExtra422NumSurfaces;
	U032        dwExtra422Index;
	U032        dwExtra422Pitch;
    U032        pNvPioFlipOverlayNotifierFlat;

    // VPE vsync events
    U032        hNVPSyncEvent[NVP_SYNC_EVENT_MAX];

    // point to a shared flag between DDraw and VPE kernel (indicates who flips overlay!)
    U032        pOvrRing0FlipFlag;

} NVP_CMD_OBJECT, *PNVP_CMD_OBJECT;


// Service ID used by NVP_CMD_OBJECT
#define NVP_SRV_INITIALIZE		0x01
#define NVP_SRV_UNINITIALIZE	0x02
#define NVP_SRV_START_VIDEO		0x03
#define NVP_SRV_STOP_VIDEO		0x04
#define NVP_SRV_UPDATE_VIDEO	0x05
#define NVP_SRV_REG_SURFACE		0x06
#define NVP_SRV_UPDATE_OVERLAY	0x07
#define NVP_SRV_PROG_STATE		0x08
#define NVP_SRV_FLIP_VIDEOPORT  0x09
#define NVP_SRV_IS_VPE_ENABLED  0x0A

// For FS Mirror
// #define NVP_SRV_IS_FSMIRROR_ENABLED   0x0B
#define NVP_SRV_REG_FSMIRROR_SURFACE  0x0C
#define NVP_SRV_ENABLE_FSMIRROR       0x0D
#define NVP_SRV_DISABLE_FSMIRROR      0x0E

// NVP object, channels and events
#define NVP_VPE_CHANNEL						0xA0010001
#define NVP_EXTERNAL_DECODER_OBJECT			0xA0010002
#define NVP_EXTERNAL_DECODER_NOTIFIER		0xA0010003
#define NVP_VIDEO_FIELD0_BUFFER_CONTEXT		0xA0010004
#define NVP_VIDEO_FIELD1_BUFFER_CONTEXT		0xA0010005
#define NVP_VBI_FIELD0_BUFFER_CONTEXT		0xA0010006
#define NVP_VBI_FIELD1_BUFFER_CONTEXT		0xA0010007
#define NVP_VIDEO_FIELD0_BUFFER_EVENT		0xA0010008
#define NVP_VIDEO_FIELD1_BUFFER_EVENT		0xA0010009
#define NVP_VBI_FIELD0_BUFFER_EVENT			0xA001000A
#define NVP_VBI_FIELD1_BUFFER_EVENT			0xA001000B
#define NVP_M2M_OBJECT						0xA001000C
#define NVP_M2M_NOTIFIER					0xA001000D
#define NVP_M2M_CONTEXT						0xA001000E
#define NVP_M2M_FROM_CONTEXT				0xA001000F
#define NVP_M2M_EVENT						0xA0020001
#define NVP_DMA_PUSHBUF_ERROR_NOTIFIER		0xA0020002
#define NVP_DMA_FROM_MEMORY_PUSHBUF			0xA0020003

#define NVP_OVERLAY_OBJECT                  0xA0020004
#define NVP_DVD_SUBPICTURE_OBJECT           0xA0020005
#define NVP_OVERLAY_NOTIFIER                0xA0020006
#define NVP_DVD_SUBPICTURE_CONTEXT          0xA0020007
#define NVP_OVERLAY_BUFFER_CONTEXT          0xA0020008

#define NVP_VSYNC_EVENT0					0xA0020009
#define NVP_VSYNC_EVENT1					0xA002000A
#define NVP_OV_SYNC_EVENT0                  0xA002000B
#define NVP_OV_SYNC_EVENT1                  0xA002000C

// for FS Mirror
#define NVP_VIDEO_LUT_DAC_OBJ_ID                0xA0030001
#define NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID  0xA0030002
#define NVP_VIDEO_LUT_DAC_EVENT0_ID             0xA0030003
#define NVP_VIDEO_LUT_DAC_EVENT1_ID             0xA0030004
#define NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT 0xA0030005
#define NVP_VIDEO_LUT_DAC_FIELD1_BUFFER_CONTEXT	0xA0030006

#define NVP_SCALED_IMAGE_OBJ_ID                 0xA0030007
#define NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID   0xA0030008
#define NVP_SCALED_IMAGE_BUFFER_CONTEXT         0xA0030009
#define NVP_SCALED_IMAGE_EVENT_ID               0xA003000A

// There can be multiple surface_2d objects
#define NVP_CONTEXT_SURFACE_2D_OBJECT               (0xA0030010)
#define NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID (0xA0030011)
#define NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT       (0xA0030012)

///// methods are equivalent to NV10_VIDEO_OVERLAY
#ifndef NV04_VIDEO_OVERLAY
#define NV04_VIDEO_OVERLAY (0x00000047)
#endif

// field definition (corresponds to H/W def)
#define NVP_FIELD_EVEN			0x00
#define NVP_FIELD_ODD			0x01

// VP state
#define NVP_STATE_STOPPED		0x01L
#define NVP_STATE_STARTED		0x02L
#define NVP_STATE_STARTED_VIDEO	0x04L
#define NVP_STATE_STARTED_VBI	0x10L

#define NVP_STOP_VIDEO          0x01L
#define NVP_STOP_VBI            0x02L

// End of Queue
#define NVP_EOQ		(-1)
#define NVP_UNDEF	(0xFFFFFFFF)

#define NVPE_VSYNC_EVENT_NAME	L"NVPE_VSYNc_EVENT"

// NV chip versions
#define NVP_GET_CHIP_VER(ver)	((ver) & 0xFFFF)

#define NVP_CHIP_VER_03			0x03
#define NVP_CHIP_VER_04			0x04
#define NVP_CHIP_VER_05			0x05
#define NVP_CHIP_VER_10			0x10

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010

#endif // _NVPESRVC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\src\nvpe.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*
==============================================================================

    NVIDIA Corporation, (C) Copyright
    1996,1997,1998,1999. All rights reserved.

    nvpe.cpp

    DDraw Video Port implementation

    Jan 27, 1999

==============================================================================
*/

#ifdef NVPE

#include "nvpkrnl.h"
#include "nvpe.h"

// VPE states
#define NVP_STATE_STOPPED   0x01
#define NVP_STATE_RUNNING   0x02

/*
==============================================================================

    CanCreateVideoPort32

    Description:    Determines whether a Videoport can be created. Sometimes
                    this function is called twice with the same VideoPort ID.
                    In such case, the video port can be created (VIDEO and
                    VBI)

==============================================================================
*/
DWORD NVPAPI CanCreateVideoPort32(LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***CanCreateVideoPort32");

    //ASSERT(lpInput!=NULL);
    //ASSERT(lpInput->lpDDVideoPortDesc !=NULL);    
    
    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);
    
    if (pDriverData == NULL)
    {
        DPF("NVPE: error - VideoPort not creatable  -->  pDriverData = NULL");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    
    // Check structure size
    if (lpInput->lpDDVideoPortDesc->dwSize < sizeof(DDVIDEOPORTDESC))
    {
        DPF("NVPE: error - VideoPort not creatable  -->  stucture length is not large enough");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    
    // check input connection GUID
    if (!IsEqualGUID_C((lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_CCIR656))
    {
        DPF("NVPE: error - VideoPort not creatable  --> GUID should be DDVPTYPE_CCIR656");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // check to see if there are videoports available... by looking at local allocation
    if (pDriverData->dwVideoPortsAvailable <= 0)
    {
        // check to see if there are ports available... by looking at IDs
        if (lpInput->lpDDVideoPortDesc->dwVideoPortID != 0)
        {
            DPF("NVPE: error - VideoPort not creatable  --> not enough video ports");
            NvReleaseSemaphore(pDriverData);
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        DPF("NVPE: second VP with the same ID allowed !");
    }


	
	// the restrictions we have FieldWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...
	if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_FIELDWIDTH) {
		DPF("   ***VideoPort not creatable  --> field Width is too great");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have VBIWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...  but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV_MAX_VBIWIDTH) {
		DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have on Field Height are dependant on maximum length specifiable
	//  length is 2^19 in size... which is but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwFieldHeight > NV_MAX_FIELDHEIGHT) {
		DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV_MAX_PIXELRATE) {
		DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

    
	if ((lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 8) && (lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 16)) 
	{
		DPF("NVPE: error - VideoPort not creatable  --> port width is not 8 or 16");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}


    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    CreateVideoPort32

    Description:    Create a Videoport. Initialize context.

    Notes:          This function allows the HAL to set internal flags and
                    become aware that a video port has been created. It
                    should always return DDHAL_DRIVER_HANDLED.
                    According to DDHAL documentation, this procedure can
                    return DDHAL_DRIVER_NOTHANDLED as well, signifying that
                    the createvideoport fn could not be completed.
                    DirectDraw MS layer will prevent creating more videoports
                    that is available.

==============================================================================
*/
DWORD NVPAPI CreateVideoPort32(LPDDHAL_CREATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***CreateVideoPort32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    if (NVPInitialize(	pDriverData, 
						lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags,
						lpInput->lpDD->lpGbl))
    {
        DPF("NVPE: error - VideoPort driver failed to initialize !");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // one down !
    (pDriverData->dwVideoPortsAvailable)--;

    pDriverData->nvpeState.dwVPEState = NVP_STATE_STOPPED;

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    GetVideoPortBandwidth32

    Description:    Determine how much bandwidth is available for the
                    specified output format and fill in the information

==============================================================================
*/
DWORD NVPAPI GetVideoPortBandwidth32(LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{
    DPF("***GetVideoPortBandwidth32");

    if (lpInput->dwFlags & DDVPB_TYPE)
    {
        lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay
    }
    
    if (lpInput->dwFlags & DDVPB_VIDEOPORT)
    {
        // The following four should indicate the MINIMUM stretch values represented as percentages times 10
        //  so if we could not stretch below 75% of the orginal size, the we should put in 750
        lpInput->lpBandwidth->dwOverlay                 = 1000;
        lpInput->lpBandwidth->dwColorkey                = 1000;  // Overlay/video port/colorkey works at 1X
        lpInput->lpBandwidth->dwYInterpolate            = 1000;  // Overlay/video port works at 1X
        lpInput->lpBandwidth->dwYInterpAndColorkey      = 1000;  // Overlay/video port/interpolation works at 2X
    }
    
    if (lpInput->dwFlags & DDVPB_OVERLAY)
    {
        DPF("NVPE: We are NOT an overlay limited device but a destination ");
        DPF("      limited device we should not have been called");
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortInputFormat32

    Description:    retrieves the VP input format (UYVY 422)

==============================================================================
*/
DWORD NVPAPI GetVideoPortInputFormat32(LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
    DPF("***GetVideoPortInputFormat32");

    // Only 1 input format supported UYVY 4:2:2
    // Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24]
    if (lpInput->dwFlags & DDVPFORMAT_VIDEO)
    {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL)
        {
            memcpy (lpInput->lpddpfFormat, &g_aNVPVideoFormat[0], sizeof(DDPIXELFORMAT));
        }
    }

    // VBI raw 8 bit
    if (lpInput->dwFlags & DDVPFORMAT_VBI)
    {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL)
        {
            memcpy (lpInput->lpddpfFormat, &g_aNVPVBIFormat[0], sizeof(DDPIXELFORMAT));
        }
    }

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    GetVideoPortOutputFormat32

    Description:    retrieves the VP output format (UYVY 422)

==============================================================================
*/
DWORD NVPAPI GetVideoPortOutputFormat32(LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
    DPF("***GetVideoPortOutputFormat32");

    lpInput->dwNumFormats = 1;
    if (lpInput->lpddpfOutputFormats != NULL)
    {
        memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
    }

    // UYVY 4:2:2
    if (lpInput->dwFlags & DDVPFORMAT_VIDEO)
    {
        // BES converts (overlay) and not the video port !
        if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y'))
        {
            lpInput->dwNumFormats = 1;
            if (lpInput->lpddpfOutputFormats != NULL)
            {
                memcpy (lpInput->lpddpfOutputFormats, &g_aNVPVideoFormat[0], sizeof(DDPIXELFORMAT));
            }
        }
    }

    // VBI raw 8 bit
    if (lpInput->dwFlags & DDVPFORMAT_VBI)
    {
        if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('R','A','W','8'))
        {
            lpInput->dwNumFormats = 1;
            if (lpInput->lpddpfOutputFormats != NULL)
            {
                memcpy (lpInput->lpddpfOutputFormats, &g_aNVPVBIFormat[0], sizeof(DDPIXELFORMAT));
            }
        }
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortConnectInfo

    Description:    Returns the GUIDs describing the connections that can be
                    supported, port widths and CAPS

==============================================================================
*/
DWORD NVPAPI GetVideoPortConnectInfo(LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    DPF("***GetVideoPortConnectInfo");

#if (NVARCH < 0x10)
    lpInput->dwNumEntries = 1;
    if(lpInput->lpConnect == NULL)
    {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    }
    else
    {
        // fill in the one structure that we asked for..    
        lpInput->lpConnect->dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy(&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect->dwPortWidth = 8;
        lpInput->lpConnect->dwFlags = g_dwNVPConnectionCaps;
    }
#else
    lpInput->dwNumEntries = 2;
    if(lpInput->lpConnect == NULL)
    {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    }
    else
    {
        // fill in the one structure that we asked for..    
        lpInput->lpConnect[0].dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy(&(lpInput->lpConnect[0].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[0].dwPortWidth = 8;
        lpInput->lpConnect[0].dwFlags = g_dwNVPConnectionCaps;

        lpInput->lpConnect[1].dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy(&(lpInput->lpConnect[1].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[1].dwPortWidth = 16; // NV10 and up we support 16 bit port width
        lpInput->lpConnect[1].dwFlags = g_dwNVPConnectionCaps;

    }
#endif

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    DestroyVideoPort32

    Description:    This optional function notifies the HAL when the video
                    port has been destroyed

==============================================================================
*/
DWORD NVPAPI DestroyVideoPort32(LPDDHAL_DESTROYVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***DestroyVideoPort32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

	//Dst width & height =0 will shutdown overlay
	//changing size values are not recommended but since these values
	//are updated when you call updateoverlay, I guess this is fine.
	//and we are destroying VP anyway...
    
    // Should create a better method for this @mjl@

	pDriverData->vpp.dwOverlayDstWidth = 0;
	pDriverData->vpp.dwOverlayDstHeight = 0;
	NVPUpdateOverlay(pDriverData, lpInput->lpDD->lpGbl);
    NVPStopVideo(pDriverData, lpInput->lpDD->lpGbl);
    NVPUninitialize(pDriverData);

    // available again !
    (pDriverData->dwVideoPortsAvailable)++;

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortField32

    Description:    readback of the current field

==============================================================================
*/
DWORD NVPAPI GetVideoPortField32(LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    DPF("***GetVideoPortField32");

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortLine32

    Description:    readback of the current video line number (0 relative)

==============================================================================
*/
DWORD NVPAPI GetVideoPortLine32(LPDDHAL_GETVPORTLINEDATA lpInput)
{
    DPF("***GetVideoPortLine32");

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoSignalStatus32

    Description:    any incoming video signal ?

==============================================================================
*/
DWORD NVPAPI GetVideoSignalStatus32(LPDDHAL_GETVPORTSIGNALDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***GetVideoSignalStatus32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    if (pDriverData->nvpeState.dwVPEState == NVP_STATE_STOPPED)
    {
        DPF("GetVideoSignalStatus32: could not get the signal status, the video port is not running... ");
        NvReleaseSemaphore(pDriverData);
        // we'll return no signal in this case....
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;
        lpInput->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // check vp sync event to see if things are running down there !
    if (NVPWaitForSync(pDriverData, NVP_EVENT_MEDIAPORT, 35) == NVP_STATUS_SUCCESS)    // 35 msec for a complete frame to pass through !
        lpInput->dwStatus = DDVPSQ_SIGNALOK;
    else
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortFlipStatus32

    Description:    This required function allows DDRAW to restrict access to
                    a surface until the physical flip has occurred, allowing
                    doubled buffered capture.
                    If the physical flip has not yet occurred, return
                    DDERR_WASSTILLDRAWING

==============================================================================
*/
DWORD NVPAPI GetVideoPortFlipStatus32(LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***GetVideoPortFlipStatus32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // check vp sync event and return immediatly
    if (NVPWaitForSync(pDriverData, NVP_EVENT_MEDIAPORT, 0) != NVP_STATUS_SUCCESS)
    {
        // we'll return still drawing in this case....
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    NvReleaseSemaphore(pDriverData);
    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    WaitForVideoPortSync32

    Description:    Waits for the LPB Video VSYNC (note: this is entirely
                    different from the screen refresh VGA VSYNC)

==============================================================================
*/
DWORD NVPAPI WaitForVideoPortSync32(LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
    GLOBALDATA *pDriverData;
    DWORD dwTimeOut;

    DPF("***WaitForVideoPortSync32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    if (pDriverData->nvpeState.dwVPEState == NVP_STATE_STOPPED)
    {
        DPF("WaitForVideoPortSync32: could not wait for VP Sync, the video port is not running... ");
        NvReleaseSemaphore(pDriverData);
        // we'll return an error in this case....
        lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
        return DDHAL_DRIVER_HANDLED;
    }

    dwTimeOut = (lpInput->dwTimeOut != 0) ? lpInput->dwTimeOut : 2000; // wait for 2 sec (2000 msec)

    if (NVPWaitForSync(pDriverData, NVP_EVENT_MEDIAPORT, dwTimeOut) != NVP_STATUS_SUCCESS)
    {
        DPF("WaitForVideoPortSync32: VP Sync timed-out !");
        NvReleaseSemaphore(pDriverData);
        // we'll return an error in this case....
        lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
        return DDHAL_DRIVER_HANDLED;
    }

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    FlipVideoPort32

    Description:    Program registers to do the actual flip

==============================================================================
*/
DWORD NVPAPI FlipVideoPort32(LPDDHAL_FLIPVPORTDATA lpInput)
{
    DPF("***FlipVideoPort32");

    NVPFlipVideoPort(lpInput);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    UpdateVideoPort32

    Description:    Sets up the video port. Might be called separately for
                    VBI and Video.

==============================================================================
*/
DWORD NVPAPI UpdateVideoPort32(LPDDHAL_UPDATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***UpdateVideoPort32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    lpInput->ddRVal = DD_OK;

    //if (pDriverData->NvDevFlatDma == 0)
	if(pDriverData->nvpeState.bVPEInitialized == FALSE){
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    if (lpInput->dwFlags == DDRAWI_VPORTUPDATE)
    {
        DPF("UpdateVideoPort32: update videoport");
        NVPUpdateVideo(lpInput);
    }
    else if (lpInput->dwFlags == DDRAWI_VPORTSTART)
    {
        // if already running, consider this as an update !!!
        if (pDriverData->nvpeState.dwVPEState == NVP_STATE_RUNNING)
        {
            DPF("UpdateVideoPort32: update videoport");
            NVPUpdateVideo(lpInput);
        }
        else
        {
            DPF("UpdateVideoPort32: start videoport");
            NVPStartVideo(lpInput);
            pDriverData->nvpeState.dwVPEState = NVP_STATE_RUNNING;
        }
    }
    else
    {
        DPF("UpdateVideoPort32: stop videoport");
        // stop grabbing video !
        NVPStopVideo(pDriverData, lpInput->lpDD->lpGbl);
        pDriverData->nvpeState.dwVPEState = NVP_STATE_STOPPED;
    }

    NvReleaseSemaphore(pDriverData);

    return DDHAL_DRIVER_HANDLED;
}


#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\src\nvpkrnl.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*
==============================================================================

    NVIDIA Corporation, (C) Copyright
    1996,1997,1998,1999. All rights reserved.

    nvpkrnl.cpp

    Video Port kernel interface (Miniport/MiniVDD)

    Feb 10, 1999

==============================================================================
*/
#ifdef NVPE

#include "nvpkrnl.h"

// NVPE inludes
#include "nvpesrvc.h"  // shared structure and definitions (miniport/DDraw)

// Win9x and NT differences
#ifdef WINNT

#define     NVP_CLIENT              (ppdev->hClient)
#define     NVP_DRIVER_HANDLE       (pDriverData->nvpeState.hVPEKernel)      // (pDriverData->ppdev->hDriver)
#define     NVP_VPE_CHANNEL_PTR     (pDriverData->NvDevFlatVPE)
#define     NVP_OVERLAY_CHANNEL_PTR (pDriverData->NvDevVideoFlatPio)
#define     NVP_FB_BASE_ADDRESS     (ppdev->pjFrameBufbase)
#define     NVP_FB_LENGTH           (ppdev->cbFrameBuf)
#define     PNVP_DDRAW_SURFACE      PDD_SURFACE_INT     // LPDDRAWI_DDRAWSURFACE_INT for Win9x
#define     NVP_OVERLAY_SUBCHANNEL  7 //DD_SPARE            // NV_DD_SPARE for Win9x
#define     NVP_GET_SURFACE_OFFSET(x) ((U032)(x))
#define     NVP_GET_SURFACE_POINTER(x) ((U032)(x) + (U032)(ppdev->pjFrameBufbase)) // on win2k, pVidMem are offsets not linear pointers !!!

#else
// Win9x version

#define     IOCTL_VIDEO_VPE_COMMAND 0x300cafe0
#define     VPE_EVENT               "VPE_Event"
#define     NVP_CLIENT              pDriverData->dwRootHandle //(pDriverData->ppdev->hClient)
#define     NVP_DRIVER_HANDLE       (pDriverData->nvpeState.hVPEKernel)     //(pDriverData->ppdev->hDriver)
#define     NVP_VPE_CHANNEL_PTR     (pDriverData->NvDevFlatVPE)
#define     NVP_OVERLAY_CHANNEL_PTR (pDriverData->NvDevVideoFlatPio)
#define     NVP_FB_BASE_ADDRESS     pDriverData->VideoHeapBase   //(pDriverData->ppdev->pjScreen)
#define     NVP_FB_LENGTH           (pDriverData->VideoHeapEnd - pDriverData->VideoHeapBase) //(pDriverData->ppdev->cbFrameBuf)
#define     PNVP_DDRAW_SURFACE      LPDDRAWI_DDRAWSURFACE_INT//PDD_SURFACE_INT     // LPDDRAWI_DDRAWSURFACE_INT for Win9x
#define     NVP_OVERLAY_SUBCHANNEL  7 //DD_SPARE            // NV_DD_SPARE for Win9x
#define     NVP_GET_SURFACE_OFFSET(x)  ((U032)(x) - (U032)(pDriverData->BaseAddress))
#define     NVP_GET_SURFACE_POINTER(x) ((U032)(x))

#endif //WINNT

// local prototypes
NVP_STATUS NVPGetImageDim(
    LPDDVIDEOPORTDESC pVPDesc,
    LPDDVIDEOPORTINFO pVideoInfo,
    PNVP_CMD_OBJECT pnvCmdObj,
    BOOL bIsVideoSurf);
NVP_STATUS NVPRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_DDRAW_SURFACE pDDSurface, //LPDDRAWI_DDRAWSURFACE_INT *pDDSurface, // lpInput->lplpDDSurface,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId);





NVP_STATUS NVPCreateEvents(GLOBALDATA *pDriverData, PNVP_CMD_OBJECT pnvInitObj);
NVP_STATUS NVPDestroyEvents(GLOBALDATA *pDriverData);
NVP_STATUS NVPCallKernel(HANDLE hDevice, PNVP_CMD_OBJECT pnvInCmdObj, PNVP_CMD_OBJECT pnvOutCmdObj);
NVP_STATUS NVPEGetHandleToKernel(GLOBALDATA *pDriverData, HANDLE hDevice);
NVP_STATUS NVPDumpVPSurfInfo(LPDDHAL_UPDATEVPORTDATA lpInput, NVP_CMD_OBJECT *pnvCmdObj);
NVP_STATUS NVPDumpVPConnectInfo(DWORD dwVPConnectionFlags);

#ifdef VPEFSMIRROR
// [XW] added for FS Mirror
NVP_STATUS NVPFsRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId,
    DWORD dwSurfPitch,
    DWORD dwSurfOffset,
    DWORD dwSurfHeight,
    DWORD dwSurfWidth
    );

/*
==============================================================================

    NVPFsRegSurface

    Description:  Interface to the miniport... register surfaces etc.


    Parameters:


    Note:       Xun Wang September 25, 2000

==============================================================================
*/

NVP_STATUS NVPFsRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId,
    DWORD dwSurfPitch,
    DWORD dwSurfOffset,
    DWORD dwSurfHeight,
    DWORD dwSurfWidth
    )
{

    // register the fullscreen mirror surface in the kernel.
    dwSurfOffset = (U032)(pDriverData->BaseAddress+dwSurfOffset);

    pnvCmdObj->pSurfVidMem = NVP_GET_SURFACE_POINTER(dwSurfOffset);
    pnvCmdObj->dwSurfPitch = dwSurfPitch;
    pnvCmdObj->dwSurfWidth = dwSurfWidth;
    pnvCmdObj->dwSurfHeight = dwSurfHeight;

    pnvCmdObj->dwSurfOffset = NVP_GET_SURFACE_OFFSET(dwSurfOffset);

    pnvCmdObj->dwSurfaceId = dwSurfaceId;
    pnvCmdObj->dwSrvId = NVP_SRV_REG_FSMIRROR_SURFACE;

     // call vpe kernel to register surface
    NVPCallKernel(NVP_DRIVER_HANDLE, pnvCmdObj, NULL);

    return NVP_STATUS_SUCCESS;

}
/*
==============================================================================

    NVPFsMirrorEnable

    Description:  Interface to the miniport... register surfaces etc.


    Parameters:


    Note:       Xun Wang September 25, 2000

==============================================================================
*/
NVP_STATUS NVPFsMirrorEnable(GLOBALDATA *pDriverData)
{
    NVP_CMD_OBJECT nvInObj;
    int i;

    DPF("nvpkrnl.cpp: NVPFsMirrorEnable()\n");

    if (!pDriverData->nvpeState.bVPEInitialized) {
        return NVP_STATUS_SUCCESS;
    }

    if (pDriverData->nvpeState.bFsMirrorEnabled) {
        NVPFsMirrorDisable(pDriverData);
    }

//    if (NVPEGetHandleToKernel(pDriverData, NULL) != NVP_STATUS_SUCCESS) {
//        return NVP_STATUS_FAILURE;
//    }

    // NVP_SRV_ENABLE_FSMIRROR to send down the other information
    nvInObj.dwPortId      = 0;    // use 0 for now !
    nvInObj.dwSrvId = NVP_SRV_ENABLE_FSMIRROR;
    nvInObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvInObj.regOverlayMode2 = pDriverData->vpp.regOverlayMode2;
    nvInObj.dwOverlayFSHead = pDriverData->vpp.dwOverlayFSHead;
    nvInObj.dwDesktopState = pDriverData->dwDesktopState;

    // figure out which device to put the overlay on (copied from VPP)
    DWORD dwFSMirrorDevice = (pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) - 1;
    if (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE && dwFSMirrorDevice != 0xFFFFFFFF) {
        if (dwFSMirrorDevice >= 14) {
            dwFSMirrorDevice = 1;
        }
        nvInObj.dwOverlayFSOvlHead = dwFSMirrorDevice ^ 1;
        } else {
#if (IS_WINNT4 || IS_WINNT5)
            nvInObj.dwOverlayFSOvlHead = (ppdev->ulDeviceDisplay[0]);
#else
            nvInObj.dwOverlayFSOvlHead = (pDXShare->dwHeadNumber);
#endif
        }

    // call vpe kernel to enable FS Mirror
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInObj, NULL);

    // NVP_SRV_REG_FSMIRROR_SURFACE  to register surfaces

    for (i = 0; i < (int)(pDriverData->vpp.dwOverlayFSNumSurfaces); i++)
    {
        NVPFsRegSurface(pDriverData,
                        &nvInObj,
                        i,
                        pDriverData->vpp.dwOverlayFSPitch,
                        pDriverData->vpp.dwOverlayFSOffset[i],
                        pDriverData->vpp.dwOverlayFSHeight,
                        pDriverData->vpp.dwOverlayFSWidth
                        );
    }

    //CloseHandle(NVP_DRIVER_HANDLE);
    //NVP_DRIVER_HANDLE = 0;

    pDriverData->nvpeState.bFsMirrorEnabled = TRUE;

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPFsMirrorDisable

    Description:  Interface function to the miniport.. cleanup


    Parameters:


    Note:       Xun Wang September 25, 2000

==============================================================================
*/
NVP_STATUS NVPFsMirrorDisable(GLOBALDATA *pDriverData)
{
    NVP_CMD_OBJECT nvInitObj;

    DPF("nvpkrnl.cpp: NVPFsMirrorDisable()\n");

    if (!pDriverData->nvpeState.bFsMirrorEnabled) {
        return NVP_STATUS_SUCCESS;
    }

    // fill up structure with data needed for uninitialization
    nvInitObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvInitObj.dwSrvId = NVP_SRV_DISABLE_FSMIRROR;
    nvInitObj.hClient = NVP_CLIENT;
    nvInitObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR;    // pDriverData->NvDevFlatVPE
    nvInitObj.dwPortId = 0; // use 0 for now !
    nvInitObj.dwDeviceId = NV_WIN_DEVICE;

    // call vpe kernel to disable FS Mirror
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInitObj, NULL);

    pDriverData->nvpeState.bFsMirrorEnabled = FALSE;

    return NVP_STATUS_SUCCESS;
}

#endif

/*
==============================================================================

    NVPIsVPEEnabled

    Description:    On Win2k: call vpe kernel which to check the regitry
                              to see if VPPEEnable=0 is set in regsitry !
                    On Win9x: read VPEEnable key registry here.

                    Both platforms: pass shared flag "pOvrRing0FlipFlag"
                                    to kernel

   Parameters:      DWORD hDevice:  - handle to the kernel device
                                    - if handle is NULL, then try to connect here

   Note:            this function is called at DDraw initialization time !

==============================================================================
*/
BOOL __stdcall NVPIsVPEEnabled(
    GLOBALDATA *pDriverData,
    DWORD hDevice)
{
    NVP_CMD_OBJECT nvInObj, nvOutObj;
    BOOL bEnableVPE;
#ifndef WINNT
    int i, j;
    char regStr[256];
    const char ddSubKey[] = NV4_REG_DIRECT_DRAW_SUBKEY;
    HKEY hKey;
#endif

    if (NVPEGetHandleToKernel(pDriverData, (HANDLE)hDevice) != NVP_STATUS_SUCCESS)
        return FALSE;

    // fill up structure with initialization data
    nvOutObj.dwSize         = sizeof(NVP_CMD_OBJECT);
    nvOutObj.dwPortId       = 0;

    nvInObj.dwSize          = sizeof(NVP_CMD_OBJECT);
    nvInObj.dwSrvId         = NVP_SRV_IS_VPE_ENABLED;
    nvInObj.dwPortId        = 0;

#ifndef WINNT
    nvInObj.pOvrRing0FlipFlag = (DWORD)&(pDriverData->bRing0FlippingFlag);

    // call vpe kernel
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInObj, NULL);

    CloseHandle(NVP_DRIVER_HANDLE);
    NVP_DRIVER_HANDLE = 0;

    // Grab the local registry path and append the DirectDraw subkey to the string
    // without using the C runtime library.
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 256, regStr);

    for (i = 4; i < 255; i++)
    {
        if (regStr[i] == '\0')
            break;
    }
    regStr[i] = '\\';
    j = 0;
    while (ddSubKey[j] != '\0' && (i+j+1) < 256)
    {
        regStr[i+j+1] = ddSubKey[j++];
    }
    regStr[i+j+1] = '\0';

    // VPE enabled by default
    bEnableVPE = 1;

    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        //check for VPE enable bit
        if (RegQueryValueEx(hKey, NV4_REG_VPE_ENABLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (!lValue)
                bEnableVPE = FALSE;
        }
        RegCloseKey(hKey);
    }

#else
    nvInObj.pOvrRing0FlipFlag = 0;

    // win2k: call vpe kernel to read registry !
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInObj, &nvOutObj);

    bEnableVPE = ((nvOutObj.dwPortId == 1) ? TRUE : FALSE);
#endif // !WINNT

    return bEnableVPE;
}

/*
==============================================================================

    NVPEGetHandleToKernel

    Description:    get a handle to minivdd(Win9x) or miniport(Win2k)

==============================================================================
*/
NVP_STATUS NVPEGetHandleToKernel(
    GLOBALDATA *pDriverData,
    HANDLE hDevice)
{
#ifndef WINNT
    HANDLE hVxdHandle = INVALID_HANDLE_VALUE;
#endif // !WINNT

    // forced to use the device handle passed to us !
    if (hDevice)
        NVP_DRIVER_HANDLE = hDevice;
    else
    {
#ifndef WINNT
        if (!NVP_DRIVER_HANDLE)
        {
            // Check whether we are primary or secondary display
            DWORD dwSuccess, dwDeviceHandle;
            dwSuccess = NvRmConfigGet(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                                      NV_CFG_DEVICE_HANDLE, &dwDeviceHandle);

            if (dwSuccess != NVOS_CGE_STATUS_SUCCESS)
            {
                // Unable to know if we are primary or secondary
                // We must fail the VPE since loading the wrong VDD would cause a BSOD.
                DPF("ERROR: VPE is unable to know if we are primary or secondary display\n");
                return NVP_STATUS_FAILURE;
            }

            if (dwDeviceHandle == 1)
            {
                // We are primary display
                hVxdHandle = CreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
            }
            else
            {
                // We are secondary display
                // NO VPE support yet
                DPF("ERROR: VPE not supported on second display\n");
                return NVP_STATUS_FAILURE;
            }

            if (hVxdHandle != INVALID_HANDLE_VALUE)
            {
                NVP_DRIVER_HANDLE = hVxdHandle;
            }
            else
            {
                DPF("ERROR: unable to connect to MiniVDD!\n");
                return NVP_STATUS_FAILURE;
            }
       }
#else
        NVP_DRIVER_HANDLE = ppdev->hDriver;
#endif // WINNT
    }

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPInitialize

    Description:    pass initialization and other VPE data to kernel

==============================================================================
*/
NVP_STATUS NVPInitialize
(
    GLOBALDATA *pDriverData,
    DWORD dwVPConnectionFlags,
    LPDDRAWI_DIRECTDRAW_GBL pDDGbl
)
{
    NVP_CMD_OBJECT nvInitObj;

    DPF("nvpkrnl.cpp: NVPInitialize()\n");

    NVPDumpVPConnectInfo(dwVPConnectionFlags);      //Dump connection info

    // First time call into HAL: Reset NV and and create some objects
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        DPF ("NVPInitialize: reset NV\n");
        if (!nvEnable32 (pDDGbl)) {
            return NVP_STATUS_FAILURE;
        }
    }

    //If VPE is already initialized, uninitialize it first before continuing
    //pDriverData->nvpeState.bVPEInitialized = FALSE;
    if(pDriverData->nvpeState.bVPEInitialized){
        NVPUninitialize(pDriverData);
    }

    if (NVPEGetHandleToKernel(pDriverData, NULL) != NVP_STATUS_SUCCESS) {
        return NVP_STATUS_FAILURE;
    }

#ifdef NV3
    NvChannel *pVPChannel;

    // Use Pio channel for NV3
    if (NVP_VPE_CHANNEL_PTR == NULL)
    {
        // allocate timer object
        if (NvRmAllocChannelPio(
                NVP_CLIENT,     //pDriverData->dwRootHandle,
                NV_WIN_DEVICE,
                NVP_VPE_CHANNEL,
                NV03_CHANNEL_PIO,
                0,
                (PVOID)&(NVP_VPE_CHANNEL_PTR),
                ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT) != 0)
        {
            DPF("ERROR: NVPInitialize() failed to allocate VPE PIO channel !\n");
            return NVP_STATUS_FAILURE;
        }
    }
    nvInitObj.dwChipId          = pDriverData->NvDeviceVersion; //NVP_CHIP_VER_03;
#else
    nvInitObj.dwChipId          = pDriverData->NvDeviceVersion; //NVP_CHIP_VER_04;
#endif

    // fill up structure with initialization data
    nvInitObj.dwSize            = sizeof(NVP_CMD_OBJECT);
    nvInitObj.dwSrvId           = NVP_SRV_INITIALIZE;
    nvInitObj.hClient           = NVP_CLIENT;
    nvInitObj.pChannel          = (U032) NVP_VPE_CHANNEL_PTR;   // pDriverData->NvDevFlatVPE
    nvInitObj.pOvrChannel       = (U032) NVP_OVERLAY_CHANNEL_PTR;
    nvInitObj.dwOvrSubChannel   = NVP_OVERLAY_SUBCHANNEL;       // DD_SPARE; // NV_DD_SPARE;
    //nvInitObj.dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
    //nvInitObj.dwScalerObjectID = NV_DD_VIDEO_SCALER;
    //nvInitObj.dwDVDObjectID = NV_DD_DVD_SUBPICTURE;

    nvInitObj.dwOverlayObjectID = NV_VIDEO_OVERLAY; //0xDD003F90;
    nvInitObj.dwScalerObjectID = NV_VIDEO_OVERLAY; //0xDD003FA0;
    nvInitObj.dwDVDObjectID = NV_VIDEO_DVD_SUBPICTURE;
    nvInitObj.dwDVDObjectCtxDma = NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nvInitObj.pNvPioFlipOverlayNotifierFlat = (U032)pDriverData->pPioFlipOverlayNotifierFlat;

    nvInitObj.dwPortId      = 0;    // use 0 for now !
    nvInitObj.dwDeviceId    = NV_WIN_DEVICE;
    nvInitObj.pFrameBuffer  = (U032) NVP_FB_BASE_ADDRESS;
    nvInitObj.dwFBLen       = NVP_FB_LENGTH;
    nvInitObj.dwVPTypeFlags = dwVPConnectionFlags;

    nvInitObj.MultiMon        = 0;
#if IS_WINNT5
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE) {
        nvInitObj.MultiMon = 1;
    }
#elif IS_WIN9X
    if (pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW ||
        pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
        nvInitObj.MultiMon = 1;
    }
#endif
    nvInitObj.regOverlayMode  = pDriverData->vpp.regOverlayMode;
    nvInitObj.regOverlayMode2 = pDriverData->vpp.regOverlayMode2;
    nvInitObj.regOverlayMode3 = pDriverData->vpp.regOverlayMode3;

    NVPCreateEvents(pDriverData, &nvInitObj);

/*
    dwVal = (DWORD)('e' | ('p' << 8) | ('v' << 16) | ('n' << 24));
    pVppDispatch = (PNVP_VPP_DISPATCH) EngAllocMem(FL_ZERO_MEMORY, sizeof(NVP_VPP_DISPATCH), dwVal);
    nvInitObj.pVppDispatch = (ULONG)pVppDispatch;

    nvCreateThread(&hThreadHandle, ThreadProc);
*/
    // call vpe kernel to initialize media port
    if (NVPCallKernel(NVP_DRIVER_HANDLE, &nvInitObj, NULL) == NVP_STATUS_SUCCESS)
        pDriverData->nvpeState.bVPEInitialized = TRUE;

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPUninitialize

    Description:    clean up

==============================================================================
*/
NVP_STATUS NVPUninitialize(GLOBALDATA *pDriverData)
{
    NVP_CMD_OBJECT nvInitObj;

    DPF("nvpkrnl.cpp: NVPUninitialize()\n");

   // already un-initialized !
    if (pDriverData->nvpeState.bVPEInitialized == FALSE)
    {
        DPF("NVPUninitialize: already unintialized !\n");
        return NVP_STATUS_SUCCESS;
    }

#ifdef VPEFSMIRROR
    if (pDriverData->nvpeState.bFsMirrorEnabled) {
        NVPFsMirrorDisable(pDriverData);
    }
#endif

    // fill up structure with data needed for uninitialization
    nvInitObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvInitObj.dwSrvId = NVP_SRV_UNINITIALIZE;
    nvInitObj.hClient = NVP_CLIENT;
    nvInitObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR;    // pDriverData->NvDevFlatVPE
    nvInitObj.dwPortId = 0; // use 0 for now !
    nvInitObj.dwDeviceId = NV_WIN_DEVICE;

    // call vpe kernel to uninitialize media port
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInitObj, NULL);

    // free VPE pio channel
    if (NVP_VPE_CHANNEL_PTR)
    {
        NvRmFree(NVP_CLIENT, NV_WIN_DEVICE, NVP_VPE_CHANNEL);
        NVP_VPE_CHANNEL_PTR = 0;
    }

    NVPDestroyEvents(pDriverData);

#ifndef WINNT
    CloseHandle(NVP_DRIVER_HANDLE);
    NVP_DRIVER_HANDLE = 0;
#endif


    // reset flag
    pDriverData->nvpeState.bVPEInitialized = FALSE;

/*
    if (pVppDispatch)
    {
        EngFreeMem(pVppDispatch);
        pVppDispatch = NULL;
    }

    if (hThreadHandle)
    {
        nvTerminateThread();
        hThreadHandle = NULL;
    }
*/
    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPStartVideo

    Description:    tells the VP to start grabbing

==============================================================================
*/
NVP_STATUS NVPStartVideo(
    LPDDHAL_UPDATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;
    NVP_CMD_OBJECT nvCmdObj;
    DWORD dwNumVideoSurfaces, dwNumVBISurfaces;
    DWORD i;

    DPF("nvpkrnl.cpp: NVPStartVideo()\n");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // fill up structure with data needed for uninitialization
    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.hClient = NVP_CLIENT;
    nvCmdObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR; // pDriverData->NvDevFlatVPE
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwDeviceId = NV_WIN_DEVICE;

    // keep a copy of the VP Info DDraw flags
    nvCmdObj.dwVPInfoFlags = lpInput->lpVideoInfo->dwVPFlags;

    // determine image dimensions
    NVPGetImageDim(&(lpInput->lpVideoPort->ddvpDesc), lpInput->lpVideoInfo, &nvCmdObj, (lpInput->lplpDDVBISurface == NULL));

    nvCmdObj.bSurfVBI = FALSE;
    nvCmdObj.bSurfUpdate = FALSE;

    dwNumVideoSurfaces = lpInput->dwNumAutoflip;
    dwNumVBISurfaces = lpInput->dwNumVBIAutoflip;

    // in case of manual flip, register one surface for now... the others will be passed to us in FlipVideoPort
    if (!(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP))
    {
        dwNumVideoSurfaces = (lpInput->lplpDDSurface) ? 1 : 0;
        dwNumVBISurfaces = (lpInput->lplpDDVBISurface) ? 1 : 0;
    }

    // register Video surfaces
    for (i = 0; i < dwNumVideoSurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDSurface[i], &nvCmdObj, i);
    }

    // any VBI surfaces ?!
    nvCmdObj.bSurfVBI = (dwNumVBISurfaces != 0);
    for (i = 0; i < dwNumVBISurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDVBISurface[i], &nvCmdObj, i);
    }

    // Need better explanation of this. @mjl@

    // channel pointer might have been updated or initialized later than expected
    nvCmdObj.pOvrChannel = (U032) NVP_OVERLAY_CHANNEL_PTR;
    // extra overlay offset (used for prescaling on NV4 and NV5 !)
    for (i = 0; i < pDriverData->vpp.extraNumSurfaces; i++)
    {
        nvCmdObj.aExtra422OverlayOffset[i] = pDriverData->vpp.extraOverlayOffset[i];
    }
    nvCmdObj.dwExtra422NumSurfaces = pDriverData->vpp.extraNumSurfaces;
    nvCmdObj.dwExtra422Index = pDriverData->vpp.extraIndex;
    nvCmdObj.dwExtra422Pitch = pDriverData->vpp.extraPitch;

    // call Miniport to start VP
    nvCmdObj.dwSrvId = NVP_SRV_START_VIDEO;

    // before starting media port, wait for overlay engine to complete operation 35msec x 2 fields ... this situation might occur during a mode switch
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY1, 35);
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY2, 35);

    // call vpe kernel to start media port
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    NvReleaseSemaphore(pDriverData);

    NVPDumpVPSurfInfo(lpInput, &nvCmdObj);

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPUpdateVideo

    Description:    updates VP settings

==============================================================================
*/
NVP_STATUS NVPUpdateVideo(
    LPDDHAL_UPDATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;
    NVP_CMD_OBJECT nvCmdObj;
    DWORD dwNumVideoSurfaces, dwNumVBISurfaces;
    DWORD i;

    DPF("nvpkrnl.cpp: NVPUpdateVideo()\n");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // stop video first !
//    NVPStopVideo(pDriverData);

    // fill up structure with data needed for uninitialization
    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.hClient = NVP_CLIENT;
    nvCmdObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR; // pDriverData->NvDevFlatVPE
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwDeviceId = NV_WIN_DEVICE;

    // keep a copy of the VP Info DDraw flags
    nvCmdObj.dwVPInfoFlags = lpInput->lpVideoInfo->dwVPFlags;

    // determine image dimensions
    NVPGetImageDim(&(lpInput->lpVideoPort->ddvpDesc), lpInput->lpVideoInfo, &nvCmdObj, (lpInput->lplpDDVBISurface == NULL));

    nvCmdObj.bSurfVBI = FALSE;
    nvCmdObj.bSurfUpdate = TRUE;

    dwNumVideoSurfaces = lpInput->dwNumAutoflip;
    dwNumVBISurfaces = lpInput->dwNumVBIAutoflip;

    // in case of manual flip, register one surface for now... the others will be passed to us in FlipVideoPort
    if (!(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP))
    {
        dwNumVideoSurfaces = (lpInput->lplpDDSurface) ? 1 : 0;
        dwNumVBISurfaces = (lpInput->lplpDDVBISurface) ? 1 : 0;
    }

    // register Video surfaces
    for (i = 0; i < dwNumVideoSurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDSurface[i], &nvCmdObj, i);
    }

    // any VBI surfaces ?!
    nvCmdObj.bSurfVBI = (dwNumVBISurfaces != 0);
    for (i = 0; i < dwNumVBISurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDVBISurface[i], &nvCmdObj, i);
    }

    // Need better explanation of this. @mjl@

    // channel pointer might have been updated or initialized later than expected
    nvCmdObj.pOvrChannel = (U032) NVP_OVERLAY_CHANNEL_PTR;
    // extra overlay offset (used for prescaling on NV4 and NV5 !)
    for (i = 0; i < pDriverData->vpp.extraNumSurfaces; i++)
    {
        nvCmdObj.aExtra422OverlayOffset[i] = pDriverData->vpp.extraOverlayOffset[i];
    }
    nvCmdObj.dwExtra422NumSurfaces = pDriverData->vpp.extraNumSurfaces;
    nvCmdObj.dwExtra422Index = pDriverData->vpp.extraIndex;
    nvCmdObj.dwExtra422Pitch = pDriverData->vpp.extraPitch;

    // call Miniport to update VP
    nvCmdObj.dwSrvId = NVP_SRV_UPDATE_VIDEO;

    // call vpe kernel to update video port data/state
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    NvReleaseSemaphore(pDriverData);

    NVPDumpVPSurfInfo(lpInput, &nvCmdObj);

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPStopVideo

    Description:    tells the VP to stop grabbing video

==============================================================================
*/
NVP_STATUS NVPStopVideo (GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    NVP_CMD_OBJECT nvCmdObj;

    DPF("nvpkrnl.cpp: NVPStopVideo()\n");

    if(!pDriverData->nvpeState.bVPEInitialized){
        return  NVP_STATUS_SUCCESS;
    }

    // case where stopping VPE right after a mode switch... Reset NV and and create some objects
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        DPF ("NVPStopVideo: reset NV !\n");
        if (!nvEnable32 (pDDGbl)) {
            return NVP_STATUS_FAILURE;   
        }
        //// this flag must be set here after a mode switch because a new pDriverData got created and the old
        // flag/state is lost ! (this flag might be reset in NVPUninitialize() later)
        pDriverData->nvpeState.bVPEInitialized = TRUE;
    }

    // fill up structure with data needed for uninitialization
    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.dwSrvId = NVP_SRV_STOP_VIDEO;
    nvCmdObj.hClient = NVP_CLIENT;
    nvCmdObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR; // pDriverData->NvDevFlatVPE
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwDeviceId = NV_WIN_DEVICE;

    // call vpe kernel to stop media port
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    // wait for overlay engine to complete operation 35msec x 2 fields
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY1, 35);
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY2, 35);

    DPF("NVPStopVideo: end function !\n");

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPGetImageDim

    Description:    determines the dimension of captured video field (crop,
                    vbi height...)

==============================================================================
*/
NVP_STATUS NVPGetImageDim(
    LPDDVIDEOPORTDESC pVPDesc,
    LPDDVIDEOPORTINFO pVideoInfo,
    PNVP_CMD_OBJECT pnvCmdObj,
    BOOL bIsVideoOnlySurface)
{
    if (bIsVideoOnlySurface)
    {
        // this indicates that there are NO VBI surfaces associated with this video port update.
        // therefore we should send all the line to the Image surface
        pnvCmdObj->dwImageStartLine = 0;    // send all the data after line 0

        if (pVideoInfo->dwVPFlags & DDVP_CROP)
        {
            if(pVideoInfo->rCrop.top > (signed long) pnvCmdObj->dwImageStartLine)
                pnvCmdObj->dwImageStartLine = pVideoInfo->rCrop.top;
        }

    }
    else
    {
#define NVP_VBIVALIDDATALINE    1
        // there are some VBI surfaces associated with this video port,
        // so update VBI height and start line accordingly
        pnvCmdObj->dwVBIStartLine = NVP_VBIVALIDDATALINE;

        pnvCmdObj->dwVBIHeight = pVideoInfo->dwVBIHeight;

        pnvCmdObj->dwImageStartLine = 1 + pnvCmdObj->dwVBIHeight + pnvCmdObj->dwVBIStartLine;

        // Image start line should be one line after the vbi end

        if (pVideoInfo->dwVPFlags & DDVP_CROP)
        {
            if (pVideoInfo->rCrop.top > (signed long) pnvCmdObj->dwImageStartLine)
                pnvCmdObj->dwImageStartLine = pVideoInfo->rCrop.top;
        }
    }

    // check for cropping
    if (pVideoInfo->dwVPFlags & DDVP_CROP)
    {
        pnvCmdObj->dwInHeight = (DWORD) (pVideoInfo->rCrop.bottom - pVideoInfo->rCrop.top);
        pnvCmdObj->dwInWidth  = (DWORD) (pVideoInfo->rCrop.right - pVideoInfo->rCrop.left);
    }
    else
    {
        pnvCmdObj->dwInHeight = pVPDesc->dwFieldHeight;
        pnvCmdObj->dwInWidth  = pVPDesc->dwFieldWidth;
    }

    // in the case where DDVP_IGNOREVBIXCROP flag is set we must substract the VBIHeight from InHeight
    if (pVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP)
	    pnvCmdObj->dwInHeight -= (pVideoInfo->dwVBIHeight+1);	// -1=empirical data shows this is needed
																// to normalize to vid size

    // check prescaling
    if (pVideoInfo->dwVPFlags & DDVP_PRESCALE)
    {
        pnvCmdObj->dwPreHeight = pVideoInfo->dwPrescaleHeight;
        pnvCmdObj->dwPreWidth  = pVideoInfo->dwPrescaleWidth;

    }
    else
    {
        pnvCmdObj->dwPreHeight = pnvCmdObj->dwInHeight;
        pnvCmdObj->dwPreWidth = pnvCmdObj->dwInWidth;
    }

    pnvCmdObj->dwOriginX = pVideoInfo->dwOriginX;
    pnvCmdObj->dwOriginY = pVideoInfo->dwOriginY;

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPRegSurface

    Description:    registers a new surface in miniport

==============================================================================
*/
NVP_STATUS NVPRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_DDRAW_SURFACE pDDSurface,  // lpInput->lplpDDSurface,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId)
{
    DWORD dwVal;

    // surface memory pointer and pitch
    pnvCmdObj->pSurfVidMem = NVP_GET_SURFACE_POINTER(pDDSurface->lpLcl->lpGbl->fpVidMem);
    pnvCmdObj->dwSurfPitch = pDDSurface->lpLcl->lpGbl->lPitch;

    // compute the actual offset
    dwVal = (pnvCmdObj->dwOriginX)*2 + (pnvCmdObj->dwOriginY)*(pnvCmdObj->dwSurfPitch);
    pnvCmdObj->dwSurfOffset = NVP_GET_SURFACE_OFFSET(pDDSurface->lpLcl->lpGbl->fpVidMem) + dwVal;

    pnvCmdObj->dwSrvId = NVP_SRV_REG_SURFACE;
    pnvCmdObj->dwSurfaceId = dwSurfaceId;

    // call vpe kernel to register surface
    NVPCallKernel(NVP_DRIVER_HANDLE, pnvCmdObj, NULL);

    return NVP_STATUS_SUCCESS;
}


/*
==============================================================================

    NVPUpdateOverlay

    Description:    update overlay data in miniport

==============================================================================
*/
DWORD __stdcall NVPUpdateOverlay(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    NVP_CMD_OBJECT nvCmdObj;
    DWORD          i;

    // this is a case where a VPE object wasn't created (ex: STB TV app) but KMVT service OverlayFlip() is called !
    if ((pDriverData->bRing0FlippingFlag) && !(pDriverData->nvpeState.bVPEInitialized))
    {
        if (NVPInitialize(pDriverData, 0, pDDGbl) != NVP_STATUS_SUCCESS)
            return 0;
    }

    if(!(pDriverData->nvpeState.bVPEInitialized)){
        return 0;
    }

    // copy overlay data from DriverInfo
    nvCmdObj.dwOverlayFormat       = pDriverData->vpp.dwOverlayFormat;
    nvCmdObj.dwOverlaySrcX         = pDriverData->vpp.dwOverlaySrcX;
    nvCmdObj.dwOverlaySrcY         = pDriverData->vpp.dwOverlaySrcY;
    nvCmdObj.dwOverlaySrcPitch     = pDriverData->vpp.dwOverlaySrcPitch;
    nvCmdObj.dwOverlaySrcSize      = pDriverData->vpp.dwOverlaySrcSize;
    nvCmdObj.dwOverlaySrcWidth     = pDriverData->vpp.dwOverlaySrcWidth;
    nvCmdObj.dwOverlaySrcHeight    = pDriverData->vpp.dwOverlaySrcHeight;
    nvCmdObj.dwOverlayDstWidth     = pDriverData->vpp.dwOverlayDstWidth;
    nvCmdObj.dwOverlayDstHeight    = pDriverData->vpp.dwOverlayDstHeight;
    nvCmdObj.dwOverlayDstX         = pDriverData->vpp.dwOverlayDstX;
    nvCmdObj.dwOverlayDstY         = pDriverData->vpp.dwOverlayDstY;
    nvCmdObj.dwOverlayDeltaX       = pDriverData->vpp.dwOverlayDeltaX;
    nvCmdObj.dwOverlayDeltaY       = pDriverData->vpp.dwOverlayDeltaY;
    nvCmdObj.dwOverlayColorKey     = pDriverData->vpp.dwOverlayColorKey;
    nvCmdObj.dwOverlayMode         = pDriverData->vpp.dwOverlayMode;
    nvCmdObj.dwOverlayMaxDownScale = pDriverData->vpp.dwOverlayMaxDownScale;

    // Need better explanation of this. @mjl@

    // extra overlay offset (used for prescaling on NV4 and NV5 !)
    for (i = 0; i < pDriverData->vpp.extraNumSurfaces; i++)
    {
        nvCmdObj.aExtra422OverlayOffset[i] = pDriverData->vpp.extraOverlayOffset[i];
    }
    nvCmdObj.dwExtra422NumSurfaces = pDriverData->vpp.extraNumSurfaces;
    nvCmdObj.dwExtra422Index = pDriverData->vpp.extraIndex;
    nvCmdObj.dwExtra422Pitch = pDriverData->vpp.extraPitch;

    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.dwSrvId = NVP_SRV_UPDATE_OVERLAY;
    nvCmdObj.dwPortId = 0;  // use 0 for now !

    // call vpe kernel to register this surface
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    if ((pDriverData->vpp.dwOverlayDstWidth == 0) && (pDriverData->vpp.dwOverlayDstHeight == 0))
    {
        // wait for overlay engine to complete operation (35msec)
        NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY1, 35);
        NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY2, 35);
    }

    return 0;
}

/*
==============================================================================

    NVPWaitForSync

    Description:    waits on vpe events. They are set by video kernel when
                    notification is issued after an even or odd field is
                    displayed or when captured (or engine stopped)

==============================================================================
*/
NVP_STATUS NVPWaitForSync(
    GLOBALDATA *pDriverData,
    DWORD dwIndex, // event list index NVP_EVENT_MEDIAPORT, NVP_EVENT_OVERLAY1, NVP_EVENT_OVERLAY2
    DWORD dwTimeOut) // in msec
{
#ifdef WINNT
    LARGE_INTEGER llTimeOut;

    if (pDriverData->nvpeState.hNVPSyncEvent[dwIndex] == NULL)
        return NVP_STATUS_SUCCESS;

    if (dwTimeOut)
    {
        llTimeOut.LowPart = -((int)dwTimeOut) * 10000;   // measured in units of 100 ns in NT
        llTimeOut.HighPart = -1;                       // negative means relative to current time
    }
    else
    {
        llTimeOut.LowPart = 0;
        llTimeOut.HighPart = 0;
    }

    // note: DDK docs are wrong, it returns an error code of 0x102 if timed-out and 0 on success, not a TRUE/FALSE result
    return (NVP_STATUS)(EngWaitForSingleObject((PEVENT) (pDriverData->nvpeState.hNVPSyncEvent[dwIndex]), &llTimeOut));

#else   //WINNT
    NVP_STATUS dwStatus;

    if (pDriverData->nvpeState.hNVPSyncEvent[dwIndex] == NULL)
        return NVP_STATUS_SUCCESS;

    dwStatus = (NVP_STATUS)(WaitForSingleObject(pDriverData->nvpeState.hNVPSyncEvent[dwIndex], dwTimeOut));
    ResetEvent(pDriverData->nvpeState.hNVPSyncEvent[dwIndex]);

    return dwStatus;
#endif  //WINNT
}

/*
==============================================================================

    NVPCreateEvents

    Description:    creates VPE events. They are set by video kernel when
                    notification is issued after an even or odd field is
                    captured (at end of mediaport vsync !)

==============================================================================
*/
NVP_STATUS NVPCreateEvents(
    GLOBALDATA *pDriverData,
    PNVP_CMD_OBJECT pnvInitObj)
{
    int i;

    // media port and overlay synchronization event
    for (i = 0; i < NVP_EVENT_MAX; i++)
    {
#ifndef WINNT
        if (!(pDriverData->nvpeState.hNVPSyncEvent[i] = CreateEvent(NULL, TRUE, FALSE, NULL)))
#else
        if (!EngCreateEvent((PEVENT *)&(pDriverData->nvpeState.hNVPSyncEvent[i])))
#endif
        {

            DPF("ERROR: NVPCreateEvents() failed to create sync events !\n");
            return NVP_STATUS_FAILURE;
        }

#ifndef WINNT
        // under Win9x, convert win32 event to ring0 handle
        pDriverData->nvpeState.hNVPSyncEvent0[i] = ConvertRing3EventToRing0((HANDLE) (pDriverData->nvpeState.hNVPSyncEvent[i]));
        pnvInitObj->hNVPSyncEvent[i] = (U032)(pDriverData->nvpeState.hNVPSyncEvent0[i]);
#else
        // under Win2k, you must de-reference the event handle in order to be used by miniport KeSetEvent !
        pnvInitObj->hNVPSyncEvent[i] = (U032) (*((LPDWORD)(pDriverData->nvpeState.hNVPSyncEvent[i])));
#endif
    }

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPDestroyEvents

    Description:    destroys VPE events

==============================================================================
*/
NVP_STATUS NVPDestroyEvents(GLOBALDATA *pDriverData)
{
    int i;

    // close media port and overlay synchronization event
    for (i = 0; i < NVP_EVENT_MAX; i++)
    {
#ifndef WINNT
        CloseHandle(pDriverData->nvpeState.hNVPSyncEvent[i]);
        CloseRing0Handle(pDriverData->nvpeState.hNVPSyncEvent0[i]);
        pDriverData->nvpeState.hNVPSyncEvent0[i] = NULL;

#else
        HDRVEVENT pevent;
        if(pevent = (PEVENT)pDriverData->nvpeState.hNVPSyncEvent[i])
        {
            EngDeleteEvent(pevent);
        }

#endif
        pDriverData->nvpeState.hNVPSyncEvent[i] = NULL;
    }

    return NVP_STATUS_SUCCESS;
}


/*
==============================================================================

    NVPFlipVideoPort

    Description:    asks kernel to start capturing now to the specified
                    target surface

==============================================================================
*/
NVP_STATUS NVPFlipVideoPort(
    LPDDHAL_FLIPVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;
    NVP_CMD_OBJECT nvCmdObj;
    DWORD dwVal;

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // determine image dimensions
    NVPGetImageDim(&(lpInput->lpVideoPort->ddvpDesc), &(lpInput->lpVideoPort->ddvpInfo), &nvCmdObj, TRUE);

    // surface memory pointer and pitch
    nvCmdObj.pSurfVidMem = NVP_GET_SURFACE_POINTER(lpInput->lpSurfTarg->lpGbl->fpVidMem);
    nvCmdObj.dwSurfPitch = lpInput->lpSurfTarg->lpGbl->lPitch;

    // compute the actual offset
    dwVal = (nvCmdObj.dwOriginX)*2 + (nvCmdObj.dwOriginY)*(nvCmdObj.dwSurfPitch);
    nvCmdObj.dwSurfOffset = NVP_GET_SURFACE_OFFSET(lpInput->lpSurfTarg->lpGbl->fpVidMem) + dwVal;

    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwSrvId = NVP_SRV_FLIP_VIDEOPORT;
    nvCmdObj.dwSurfaceId = NVP_UNDEF; // this value tells the kernel to lookup the surface Id in its registered surfaces list

    // flip to the target surface
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    NvReleaseSemaphore(pDriverData);

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPCallKernel

    Description:    OS dependent functions used to call miniport (Win2k) or
                    minivdd (Win9x)

==============================================================================
*/
NVP_STATUS NVPCallKernel(
    HANDLE hDevice,
    PNVP_CMD_OBJECT pnvInCmdObj,
    PNVP_CMD_OBJECT pnvOutCmdObj)
{
    DWORD   dwCBRet, dwSizeOut = 0;

    if (pnvOutCmdObj != NULL)
       dwSizeOut = sizeof(NVP_CMD_OBJECT);

#ifndef WINNT

    if (DeviceIoControl(
            hDevice,
            IOCTL_VIDEO_VPE_COMMAND,
            pnvInCmdObj,
            sizeof(NVP_CMD_OBJECT),
            pnvOutCmdObj,
            dwSizeOut,
            &dwCBRet,
            NULL))
        return NVP_STATUS_SUCCESS;  //Win9x returns non-zero for success

#else

    if (!EngDeviceIoControl(
            hDevice,          //pDriverData->ppdev->hDriver
            IOCTL_VIDEO_VPE_COMMAND,
            pnvInCmdObj,
            sizeof(NVP_CMD_OBJECT),
            pnvOutCmdObj,
            dwSizeOut,
            &dwCBRet))
        return NVP_STATUS_SUCCESS;  //Win2k returns zero for success

#endif // !WINNT

    return NVP_STATUS_FAILURE;
}

/*
==============================================================================

    NVPCleanUp

    Description:    basically, calls NVPUninitialize() and clears the ring0
                    flip flag set by kernel services

    Note:           this function is called from DestroySurface32() which
                    is NOT the "normal" path for uninitialization.
                    DestroyVideoPort32/NVPUninitialize is !

==============================================================================
*/
DWORD __stdcall NVPCleanUp(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
#ifdef VPEFSMIRROR
    if (pDriverData->nvpeState.bVPEInitialized && pDriverData->nvpeState.bFsMirrorEnabled) {
        NVPFsMirrorDisable(pDriverData);
    }
#endif

//need to understand why the ifdef's are here to diff OSes.
#ifndef WINNT
    if ((pDriverData->bRing0FlippingFlag) && (pDriverData->nvpeState.bVPEInitialized)){
        //Dst width & height =0 will shutdown overlay
        //changing size values are not recommended but since these values
        //are updated when you call updateoverlay, I guess this is fine.
        //and we are destroying VP anyway...
        pDriverData->vpp.dwOverlayDstWidth = 0;
        pDriverData->vpp.dwOverlayDstHeight = 0;
        NVPUpdateOverlay(pDriverData, pDDGbl);
        NVPStopVideo(pDriverData, pDDGbl);
        NVPUninitialize(pDriverData);
    }

    pDriverData->bRing0FlippingFlag = 0;
#else
    if (pDriverData->nvpeState.bVPEInitialized){
        //Dst width & height =0 will shutdown overlay
        //changing size values are not recommended but since these values
        //are updated when you call updateoverlay, I guess this is fine.
        //and we are destroying VP anyway...
        pDriverData->vpp.dwOverlayDstWidth = 0;
        pDriverData->vpp.dwOverlayDstHeight = 0;
        NVPUpdateOverlay(pDriverData, pDDGbl);

		//bRing0FlippingFlag is only set when r0 lock is called (busmaster cards)
		//don't need to destroy VP otherwise (VP using non-over surf)
		if(pDriverData->bRing0FlippingFlag){
			NVPStopVideo(pDriverData, pDDGbl);
			NVPUninitialize(pDriverData);
		}
    }
#endif

    return 0;
}


NVP_STATUS NVPDumpVPSurfInfo(LPDDHAL_UPDATEVPORTDATA lpInput, NVP_CMD_OBJECT *pnvCmdObj)
{

    int i;

    DPF("nvpkrnl.cpp: # Video surf          =0x%x", lpInput->dwNumAutoflip);
    if(lpInput->dwNumAutoflip > 0){
        for(i=0; i < (int)(lpInput->dwNumAutoflip); ++i){
            DPF("nvpkrnl.cpp:   pVidMem (%d)        =0x%x", i,
                NVP_GET_SURFACE_POINTER(((lpInput->lplpDDSurface)[i])->lpLcl->lpGbl->fpVidMem));
        }
        DPF("nvpkrnl.cpp:   Pitch               =0x%x (%d)",
                        (*(lpInput->lplpDDSurface))->lpLcl->lpGbl->lPitch,
                        (*(lpInput->lplpDDSurface))->lpLcl->lpGbl->lPitch);
        DPF("nvpkrnl.cpp:   Width               =0x%x (%d)", pnvCmdObj->dwInWidth, pnvCmdObj->dwInWidth);
        DPF("nvpkrnl.cpp:   Height              =0x%x (%d)", pnvCmdObj->dwInHeight, pnvCmdObj->dwInHeight);
        DPF("nvpkrnl.cpp:   PrescaleSizeX       =0x%x (%d)", pnvCmdObj->dwPreWidth, pnvCmdObj->dwPreWidth);
        DPF("nvpkrnl.cpp:   PrescaleSizeY       =0x%x (%d)", pnvCmdObj->dwPreHeight, pnvCmdObj->dwPreHeight);
        DPF("nvpkrnl.cpp:   Video Start Line    =0x%x (%d)", pnvCmdObj->dwImageStartLine, pnvCmdObj->dwImageStartLine);

        // print some stuff out about the flags we're lookin at:
        /*if( pMySurfaces->bInvertedFields ) {
            DPF("      field polarity               inverted");
        } else {
            DPF("      field polarity               normal");
        }*/
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP  ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_AUTOFLIP            on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_AUTOFLIP            off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT       ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CONVERT            on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CONVERT            off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP                  ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CROP               on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CROP               off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE            ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_INTERLEAVE         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_INTERLEAVE         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT       ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORLEFTRIGHT    on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORLEFTRIGHT    off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN          ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORUPDOWN       on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORUPDOWN       off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE              ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_PRESCALE           on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_PRESCALE           off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS        ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPEVENFIELDS     on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPEVENFIELDS     off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS         ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPODDFIELDS      on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPODDFIELDS      off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER                ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SYNCMASTER         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SYNCMASTER         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT                ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBICONVERT         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBICONVERT         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE                ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBINOSCALE         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBINOSCALE         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE      ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_OVERRIDEBOBWEAVE   on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_OVERRIDEBOBWEAVE   off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP        ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_IGNOREVBIXCROP     on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_IGNOREVBIXCROP     off");
        }





    }

    DPF("nvpkrnl.cpp: # Vbi surf            =0x%x", lpInput->dwNumVBIAutoflip);
    if(lpInput->dwNumVBIAutoflip){
        for(i=0; i < (int)(lpInput->dwNumVBIAutoflip); ++i){
            DPF("nvpkrnl.cpp:   pVbiMem (%d)        =0x%x", i,
                NVP_GET_SURFACE_POINTER(((lpInput->lplpDDVBISurface)[i])->lpLcl->lpGbl->fpVidMem));
        }
        DPF("nvpkrnl.cpp:   Vbi Start Line      =0x%x (%d)", pnvCmdObj->dwVBIStartLine, pnvCmdObj->dwVBIStartLine);
        DPF("nvpkrnl.cpp:   Vbi Height          =0x%x (%d)", pnvCmdObj->dwVBIHeight, pnvCmdObj->dwVBIHeight);
        DPF("nvpkrnl.cpp:   Vbi Pitch           =0x%x (%d)",
                        (*(lpInput->lplpDDVBISurface))->lpLcl->lpGbl->lPitch,
                        (*(lpInput->lplpDDVBISurface))->lpLcl->lpGbl->lPitch);
    }

    return NVP_STATUS_SUCCESS;

}

NVP_STATUS NVPDumpVPConnectInfo(DWORD dwVPConnectionFlags)
{
    //we currently do not use these
    /*
    // this is the second create
    DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
    DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
    DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
    DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
    DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
    DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
    DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
    DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
    DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
    DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
#ifndef __cplusplus
    DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
#endif
    DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
    */
    DPF("nvpkrnl.cpp:VP Connection Info");
    if(dwVPConnectionFlags & DDVPCONNECT_INTERLACED ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INTERLACED          on");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INTERLACED          off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_INVERTPOLARITY  ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INVERTPOLARITY      on");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INVERTPOLARITY      off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_HALFLINE  ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_HALFLINE            on");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_HALFLINE            off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_VACT ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_VACT                on  -ERROR!!!!");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_VACT                off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_DOUBLECLOCK ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_DOUBLECLOCK         on  -ERROR!!!!");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_DOUBLECLOCK         off");
    }


    return NVP_STATUS_SUCCESS;

}
//

void __stdcall NVPInitialState(
    GLOBALDATA *pDriverData)
{
    int i;

    pDriverData->nvpeState.bVPEInitialized = FALSE;
    pDriverData->nvpeState.bFsMirrorEnabled = FALSE;
    pDriverData->nvpeState.dwVPEState = 0;
    pDriverData->nvpeState.hVPEKernel = 0;
    for (i=0; i<NVPE_EVENT_MAX; i++) {
        pDriverData->nvpeState.hNVPSyncEvent[i] = 0;
        pDriverData->nvpeState.hNVPSyncEvent0[i] = 0;
    }

}


#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\VPE\src\core\nvpecore.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//***************************************************************************
//  Module Name:
//
//      nvpecore.c
//
//  Abstract:
//
//      This module contains the core implementation of VideoPort Extension
//      and Kernel mode video transport on both Win2k and Win9x
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport/miniVDD.
//
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef NVPE

#include "nvpecore.h" // local definitions

//#define _NVP_DTRACE
//#define _NVP_TEST_NEXT_FIELD
#define FORCE_INTERLEAVE_MEM	//NOTE: If this is defined, DoBobFromInterleaved 
								//		is always called.
								//		Surf is always interleaved even if ddraw
								//		requests for non-interleaved surf. Need to
								//		double dwOverlaySrcHeight. Can't rely on ddraw
								//		interleave caps and our NV_VFM_FORMAT_X caps
								//		that is shared with the overlay code.

#ifdef _NVP_DTRACE
#define DEFINE_GLOBALS
#include "dtrace.h"
#endif

////////// globals
BOOL g_bFlip = FALSE;
DWORD g_nIntCounter = 0;
int DebugLevel=0;               //Debug level for printfs
#ifdef _NVP_TEST_NEXT_FIELD
int g_nNextFieldId = 0;
#endif

//Local Functions
VP_STATUS NVPFlushChannel(PNVP_CONTEXT pVPEContext);

#ifdef VPEFSMIRROR
// extern function not found in one of the header files need to integrate later [XW]
extern U032 rmNVPAlloc(U032 hClient, U032 hChannel,U032 hObject,U032 hClass, PVOID pAllocParms);
#endif


/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD FlipVideoPort(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPVIDEOPORTINFO pFlipVideoPortInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGTRACE,"FlipVideoPort()");
#ifdef _NOT_IMPLEMENTED
    //
    // Get offset (from framebuffer) and add offset from surface:
    //
    ULONG offset;

    offset = pFlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + pFlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here
#endif
    return DX_OK;
}

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD FlipOverlay(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    DDSURFACEDATA* pCurSurf = (DDSURFACEDATA*) (pFlipOverlayInfo->lpCurrentSurface);
    DDSURFACEDATA* pTargSurf = (DDSURFACEDATA*) (pFlipOverlayInfo->lpTargetSurface);
    PNVP_CONTEXT pVPEContext;
    U032 dwFlags, dwOverlayOffset;
    PNVP_OVERLAY pOvInfo;

    DBGPRINT(DBGTRACE,"FlipOverlay()");

    // get a pointer to the appropriate VPE context (assume VPE 0)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // if not initialized
    if (pVPEContext->nvDmaFifo == NULL)
    {
        return DXERR_GENERIC;
    }

    // NVPUpdateOverlay must be called first !
    if (!g_bFlip)
        return NO_ERROR;

    pOvInfo = &(pVPEContext->nvpOverlay);

    // VPP flags
    dwFlags = VPP_PRESCALE;

    if (pTargSurf->dwOverlayFlags & DDOVER_INTERLEAVED)
       dwFlags |= VPP_INTERLEAVED;
      else
       dwFlags |= VPP_BOB;   // non-interleaved

    if (pTargSurf->dwOverlayFlags & DDOVER_BOB)
       dwFlags |= VPP_BOB;

    if (pFlipOverlayInfo->dwFlags & DDFLIP_ODD)
        dwFlags |= VPP_ODD;
    else if (pFlipOverlayInfo->dwFlags & DDFLIP_EVEN)
        dwFlags |= VPP_EVEN;

    // initialize overlay buffer index if necessary
    if (pOvInfo->dwOverlayBufferIndex == NVP_UNDEF)
        pOvInfo->dwOverlayBufferIndex = 0;

    dwOverlayOffset = (U032)pTargSurf->fpLockPtr - pVPEContext->pFrameBuffer;

    // flip overlay here !
    if (NVPPrescaleAndFlip(pVPEContext, pOvInfo, dwOverlayOffset, pTargSurf->lPitch, 0, dwFlags))
        return DX_OK;

    return DXERR_GENERIC;
}

DWORD LockSurface(
    PVOID HwDeviceExtension,
    PNVP_DDLOCKININFO pLockInfoIn,
    PNVP_DDLOCKOUTINFO pLockInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;
    U032 *pOvrFlag;

    DBGPRINT(DBGTRACE, "LockSurface()");

    // get a pointer to the appropriate VPE context (assume VPE 0)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // this is a shared flag with DDraw...  set flag to indicate to DDraw that VPE kernel takes care of overlay flips !
    pOvrFlag = (U032 *) (pVPEContext->pOvrRing0FlipFlag);
    if (pOvrFlag)
        *pOvrFlag = 1;

    return DX_OK;
}

/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD BobNextField(
    PVOID HwDeviceExtension,
    PNVP_DDBOBNEXTFIELDINFO pBobNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGTRACE,"BobNextField()");

    return DX_OK;
}

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD SetState(
    PVOID HwDeviceExtension,
    PNVP_DDSETSTATEININFO  pSetStateInInfo,
    PNVP_DDSETSTATEOUTINFO pSetStateOutInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGERROR,"SetState() not implemented");

    return DX_OK;
}


/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD SkipNextField(
    PVOID HwDeviceExtension,
    PNVP_DDSKIPNEXTFIELDINFO pSkipNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGERROR,"SkipNextField() not implemented");

    return DX_OK;
}


/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD GetPolarity(
    PVOID HwDeviceExtension,
    PNVP_DDGETPOLARITYININFO  pGetPolarityInInfo,
    PNVP_DDGETPOLARITYOUTINFO pGetPolarityOutInfo)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;

    DBGPRINT(DBGTRACE,"GetPolarity()");

    // get a handle to current VPE context (BUGBUG: assume index 0 for now !)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // check video first !
    if (pVPEContext->nNumVidSurf)
    {
        // TRUE for Even, FALSE for Odd
        if (pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType == NVP_FIELD_ODD)
            pGetPolarityOutInfo->bPolarity = FALSE;
        else
            pGetPolarityOutInfo->bPolarity = TRUE;
    }
    // vbi polarity
    else if (pVPEContext->nNumVBISurf)
    {
        if (pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType == NVP_FIELD_ODD)
            pGetPolarityOutInfo->bPolarity = FALSE;
        else
            pGetPolarityOutInfo->bPolarity = TRUE;
    }
    else
        return DXERR_GENERIC;

    return DX_OK;
}

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETCURRENTAUTOFLIPININFO  pGetCurrentAutoflipInInfo,
    PNVP_DDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    int nNotifyIdx;

    DBGPRINT(DBGTRACE,"GetCurrentAutoflip()");

    // get a handle to current VPE context (BUGBUG: assume index 0 for now !)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
    // check out video
    if (pVPEContext->nNumVidSurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
        else
            // assume it is the next surface then !
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].nNextSurfaceIdx);
    }

    pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
    // check out vbi
    if (pVPEContext->nNumVBISurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
        else
            // assume it is the next surface then !
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].nNextSurfaceIdx);
    }

    return DX_OK;
}


/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETPREVIOUSAUTOFLIPININFO  pGetAutoflipInInfo,
    PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    int nNotifyIdx;

    DBGPRINT(DBGTRACE,"GetPreviousAutoflip()");

    // get a handle to current VPE context (BUGBUG: assume index 0 for now !)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
    // check out video
    if (pVPEContext->nNumVidSurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            // if in progress, return index of previous surface
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)((pVPEContext->nVidSurfIdx == 0) ? (pVPEContext->nNumVidSurf - 1): (pVPEContext->nVidSurfIdx - 1));
        else
            // assume this is the "previous"ly autoflipped surface then !
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
    }

    pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
    // check out vbi
    if (pVPEContext->nNumVBISurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            // if in progress, return index of previous surface
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)((pVPEContext->nVBISurfIdx == 0) ? (pVPEContext->nNumVBISurf - 1): (pVPEContext->nVBISurfIdx - 1));
        else
            // assume this is the "previous"ly autoflipped surface then !
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
    }

    return DX_OK;
}

#ifdef VPEFSMIRROR

// ***************************************************************************
// [XW:10/02/2000] - start FS Mirror Functions
// ***************************************************************************
//
// CreateVideoPort -> R3: vppEnableFsMirror + R0: NVPFsMirrorEnable + NVPFsRegSurface
//        |
//        V 
//     VideoField0/1Notify -> R0: NVPProcessCommand -> NVPScheduleOverlayandFlip 
//
//                      -> NVPFsFlipSync -> NVPFsMirror -> NVPFsFlip
//        |
//        V
// DestoryVideoPort32 -> R3: vppDisableFsMirror + R0: NVPFsMirrorDisable

// {

/*
==============================================================================
    
    NVPFsRegSurface

    Description:    register a full screen mirror surface... with
                    attributes

    Date:           September 25,2000
    BUGBUG:         To Fix feature.. Update surfaces.. needs to calc dsdy?
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsRegSurface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    
    PNVP_CONTEXT        pVPEContext;
    PNVP_SURFACE_INFO   pSurface;
       
    DWORD               dwSurfId;
        
    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);    
    pSurface = &(pVPEContext->aFSMirrorSurfaceInfo[pCmdObj->dwSurfaceId]);

    dwSurfId = pCmdObj->dwSurfaceId;

    pSurface->pVidMem = pCmdObj->pSurfVidMem;
    pSurface->dwOffset = pCmdObj->dwSurfOffset;    
    pSurface->dwPitch = pCmdObj->dwSurfPitch;
    pSurface->dwHeight = pCmdObj->dwSurfHeight;
    pSurface->dwWidth = pCmdObj->dwSurfWidth;
    
    // point each to previous surface
    if (pCmdObj->dwSurfaceId) {
        pSurface->nPrevSurfaceIdx = dwSurfId - 1;
    }
       
    (pVPEContext->nNumFSSurf)++;

    // update the surface 0's information
    pVPEContext->aFSMirrorSurfaceInfo[0].nPrevSurfaceIdx = pVPEContext->nNumFSSurf - 1; 
        
    return NO_ERROR;
}

/*
==============================================================================
    
    NVPFsMirrorEnable

    Description:    Initialize everything we need for the fsmirror 

    Date:           September 25,2000
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsMirrorEnable(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;  // object creation params
    NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;
    PNVP_CONTEXT pVPEContext;   // the actual vpe context
    Nv4ControlDma *pDmaChannel; // dma channel stuff
    U032 nvDmaCount;           
    //NVOS10_PARAMETERS evParam; // for event callbacks
    NvNotification *adacNotifiers;
    NvNotification *as2mNotifiers;

    NvNotification *asrfNotifiers;
    U032 bRecreateOverlay = FALSE;
    
    //U032 status;             // some local vars that I need

  
    // ******************************
    // Object Creation  
    // ******************************

    // Create LUT_DAC Object.. most important
    
    //#define NVP_VIDEO_LUT_DAC_SUBCHANNEL 3

    //#define NVP_SCALED_IMAGE_SUBCHANNEL  4

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    pVPEContext->regOverlayMode2 = pCmdObj->regOverlayMode2;
    pVPEContext->dwOverlayFSHead = pCmdObj->dwOverlayFSHead;
    pVPEContext->dwDesktopState = pCmdObj->dwDesktopState;
    if (pCmdObj->dwOverlayFSOvlHead != pVPEContext->dwOverlayFSOvlHead) {
        bRecreateOverlay = TRUE;
    }
    pVPEContext->dwOverlayFSOvlHead = pCmdObj->dwOverlayFSOvlHead;    
    
    if (bRecreateOverlay) {
    
        // stop overlay?
        // free old overlay
        rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_OVERLAY_OBJECT);
        
        // make new overlay        
        nv07aAllocParms.logicalHeadId = pVPEContext->dwOverlayFSOvlHead;
        if (rmNVPAlloc(pCmdObj->hClient,
                  NVP_VPE_CHANNEL,
                  NVP_OVERLAY_OBJECT,
                  NV10_VIDEO_OVERLAY,
                  &nv07aAllocParms) != 0)
        {
            DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Overlay Object ", NVP_OVERLAY_OBJECT);
            return ERROR_INVALID_PARAMETER;
        }        

        // initialize new overlay

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;


    NVP_DMAPUSH_CHECK_FREE_COUNT(8);

    // set overlay contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_NOTIFIES, NVP_OVERLAY_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(0), NVP_OVERLAY_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(1), NVP_OVERLAY_BUFFER_CONTEXT);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    }

    // head selection.  pVPEContext should be pointing to head2
    nv07cAllocParms.logicalHeadId = pVPEContext->dwOverlayFSHead;    

    // use lowest one possible for complete compatibility
    if (rmNVPAlloc(pVPEContext->hClient,
                   NVP_VPE_CHANNEL,
                   NVP_VIDEO_LUT_DAC_OBJ_ID,
                   NV15_VIDEO_LUT_CURSOR_DAC,
                   &nv07cAllocParms) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate video_lut_dac object ", NVP_VIDEO_LUT_DAC_OBJ_ID);
        return ERROR_INVALID_PARAMETER;
    }

    if (rmNVPAllocObject(pVPEContext->hClient,
                   NVP_VPE_CHANNEL,
                   NVP_SCALED_IMAGE_OBJ_ID, 
                   NV10_SCALED_IMAGE_FROM_MEMORY) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate scaled image object ", NVP_SCALED_IMAGE_OBJ_ID);
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate Scaled-image-buffer-context context dmas
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_SCALED_IMAGE_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate video_lut_dac_video_buffer0_context context dmas
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }
    
    // Allocate video_lut_dac_video_buffer1_context context dmas
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_VIDEO_LUT_DAC_FIELD1_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // ******************************
    // Notifiers Set, Set Events to VPEContext..
    // ******************************

    //#define NVP_CLASS089_MAX_NOTIFIERS          1
    //#define NVP_CLASS07C_MAX_NOTIFIERS          9

    // Allocate s2m context notifer ID
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->as2mNotifiers,
                        (sizeof(NvNotification)*NVP_CLASS089_MAX_NOTIFIERS - 1) ) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate video_lut_cursor_dac context notifer ID
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->adacNotifiers,
                        (sizeof(NvNotification)*NVP_CLASS07C_MAX_NOTIFIERS - 1) ) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

  
    
    // reset notifiers, scaled image from memory and video_lut_cursor_dac

    adacNotifiers = (NvNotification*)pVPEContext->adacNotifiers;
    as2mNotifiers = (NvNotification*)pVPEContext->as2mNotifiers;
    

    adacNotifiers[NV07C_NOTIFIERS_NOTIFY].status = 0;
    adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(0)].status = 0;
    adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(1)].status = 0;
    as2mNotifiers[NV089_NOTIFIERS_NOTIFY].status = 0;

    
    // Context Surface Creation and Setup

    asrfNotifiers = (NvNotification*)(&pVPEContext->asrfNotifiers[0]);
    asrfNotifiers[NV042_NOTIFIERS_NOTIFY].status = 0;

    if (rmNVPAllocObject(pVPEContext->hClient,
                   NVP_VPE_CHANNEL,
                   NVP_CONTEXT_SURFACE_2D_OBJECT, 
                   NV04_CONTEXT_SURFACES_2D) != 0)
    {
        DBGPRINT (DBGERROR, "cannot allocate context surface 2D object");
        return ERROR_INVALID_PARAMETER;
    }

    // context_surface_2d_notifiers_ID
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)asrfNotifiers,
                        (sizeof(NvNotification)*NVP_CLASS089_MAX_NOTIFIERS - 1) ) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for surf 2 d transfer Object");
        return ERROR_INVALID_PARAMETER;
    } 

    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot Allocate Context for Surface 2D object in memory");
        return ERROR_INVALID_PARAMETER;
    }


    // ******************************
    // Events stuff and Callbacks
    // ******************************
/*  
    // Create 2 callbacks for video_lut_cursor_dac
    evParam.hRoot = pVPEContext->hClient;
    evParam.hObjectParent = NVP_VIDEO_LUT_DAC_OBJ_ID;
    evParam.hObjectNew = NVP_VIDEO_LUT_DAC_EVENT0_ID;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV07C_NOTIFIERS_SET_IMAGE(0);
    NvU64_VALUE(evParam.hEvent) = (ULONG) NVPFsCRTCField0Notify;
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for crtc 0");
        return ERROR_INVALID_PARAMETER;
    }

    evParam.hRoot = pVPEContext->hClient;
    evParam.hObjectParent = NVP_VIDEO_LUT_DAC_OBJ_ID;
    evParam.hObjectNew = NVP_VIDEO_LUT_DAC_EVENT1_ID;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV07C_NOTIFIERS_SET_IMAGE(1);
    NvU64_VALUE(evParam.hEvent) = (ULONG) NVPFsCRTCField1Notify;
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for crtc 1");
        return ERROR_INVALID_PARAMETER;
    }
  */      
    // ******************************
    // DMA Channel - Object Setup
    // ******************************
    
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel); // get dma chan    
    nvDmaCount = pVPEContext->nvDmaCount;
    
    NVP_DMAPUSH_CHECK_FREE_COUNT(30); // Adjusted - check    

    // Setup NV04_VIDEO_LUT_CURSOR_DAC object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_OBJECT, NVP_VIDEO_LUT_DAC_OBJ_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_CONTEXT_DMA_NOTIFIES, NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_CONTEXT_DMA_IMAGE(0), NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_CONTEXT_DMA_IMAGE(1), NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT);

    // Setup NV04_CONTEXT_SURFACES_2D object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OBJECT, NVP_CONTEXT_SURFACE_2D_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_CONTEXT_DMA_NOTIFIES, NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_SOURCE, NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_DESTIN, NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT);
    
    // Setup NV05_SCALED_IMAGE_FROM_MEMORY object 
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_OBJECT, NVP_SCALED_IMAGE_OBJ_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_CONTEXT_DMA_NOTIFIES, NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_CONTEXT_DMA_IMAGE, NVP_SCALED_IMAGE_BUFFER_CONTEXT);        
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_COLOR_FORMAT, NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_CONTEXT_SURFACE, NVP_CONTEXT_SURFACE_2D_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_OPERATION,NV089_SET_OPERATION_SRCCOPY_AND);    
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_COLOR_CONVERSION,NV089_SET_COLOR_CONVERSION_DITHER);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    pVPEContext->nNumFSSurf     = 0;   // will be incremented later
    pVPEContext->nFSFlipSurfIdx = 1;   // should be 1
    pVPEContext->nFSMirrorIdx   = 0;   // should always be one behind
    pVPEContext->nFSFlipIdx     = 0;   // should be 0
    
    // Will only turn on if everything has passed..
    pVPEContext->dwFsMirrorOn = TRUE;  // turn this off at disable time

	// [XW] BUGBUG: 
	// Ideally we should return an Error, so we could deallocate everything Through Ring 3.
	// Right now, we'll just use the dwFsMirrorOn flag to make sure everything is *off* if fs mirror
	// is not turned on.
	
    return NO_ERROR;    
}

/*
==============================================================================
    
    NVPFsMirrorDisable

    Description:    UnInitialize everything we need for the fsmirror 

    Date:           October 2,2000
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsMirrorDisable(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    // free objects, events etc.
    PNVP_CONTEXT pVPEContext;
    
    DBGPRINT(DBGTRACE, "NVPFsMirrorDisable()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    pVPEContext->dwFsMirrorOn = FALSE;  // turn off at disable time
        
    // FCF: wait for notifiers to stop objects still running?
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_SCALED_IMAGE_BUFFER_CONTEXT);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_VIDEO_LUT_DAC_FIELD1_BUFFER_CONTEXT);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT);
    
    rmNVPFree(pVPEContext->hClient, NVP_VPE_CHANNEL, NVP_CONTEXT_SURFACE_2D_OBJECT);
    rmNVPFree(pVPEContext->hClient, NVP_VPE_CHANNEL, NVP_VIDEO_LUT_DAC_OBJ_ID);
    rmNVPFree(pVPEContext->hClient, NVP_VPE_CHANNEL, NVP_SCALED_IMAGE_OBJ_ID);
    
    return NO_ERROR;

}

/*
==============================================================================
    
    NVPFsFlip

    Description:    Flips to next FS Surface

    Date:           October 2,2000
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsFlip(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    int nFlipIdx;
    NVP_SURFACE_INFO* pSurface;
    DWORD dwOffset;
    DWORD dwFormat;
    Nv4ControlDma *pDmaChannel; // dma channel stuff
    U032 nvDmaCount;           
    NvNotification *adacNotifiers;
        
    nFlipIdx = pVPEContext->nFSFlipSurfIdx;
    nFlipIdx = pVPEContext->aFSMirrorSurfaceInfo[nFlipIdx].nPrevSurfaceIdx;       
    pSurface = &(pVPEContext->aFSMirrorSurfaceInfo[nFlipIdx]);
        
    
    dwOffset = pSurface->dwOffset;
    dwFormat = pSurface->dwPitch |(NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 31)| (NV07C_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20);

    // we are ready to start flipping
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel); // get dma chan    
    nvDmaCount = pVPEContext->nvDmaCount;

    // update the notifiers
    adacNotifiers = (NvNotification*)pVPEContext->adacNotifiers;
    if (adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(nFieldId)].status == NV07C_NOTIFICATION_STATUS_IN_PROGRESS) {
        return ERROR_INVALID_PARAMETER;
    }
    adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(nFieldId)].status = NV07C_NOTIFICATION_STATUS_IN_PROGRESS;

    NVP_DMAPUSH_CHECK_FREE_COUNT(6);

    // Setup NV04_VIDEO_LUT_CURSOR_DAC object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_OBJECT, NVP_VIDEO_LUT_DAC_OBJ_ID);
    // context dmas should be set up .. so we just need a offset, and a format to start it going
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_IMAGE_OFFSET(nFieldId), dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_IMAGE_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return NO_ERROR;
}


/*
==============================================================================
    
    NVPFsMirror

    Description:    Full Screen Mirror Copy Function from buffer into next surface

    Date:           October 2,2000
    
    Author:         Xun Wang

==============================================================================
*/

VP_STATUS NVPFsMirror(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset
    DWORD         dwPitch,         // source pitch
    DWORD         dwWidth,         // source width
    DWORD         dwHeight,        // source height
    DWORD         dwIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags)
{
    // free objects, events etc.

    DWORD dwPointIn, dwSizeIn, dwPointOut, dwSizeOut;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwInFormat;
    DWORD dwClipPoint, dwClipSize;
    DWORD dwSurfId;
    DWORD dwPitch2d;
    DWORD dwSurfaceColorFormat;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;

    NVP_SURFACE_INFO* pSurface;
    NvNotification* as2mNotifiers;

	DBGPRINT(DBGTRACE, "NVPFsMirror");
   
    dwSurfId = pVPEContext->nFSFlipSurfIdx;
    pSurface = &(pVPEContext->aFSMirrorSurfaceInfo[dwSurfId]);
    
    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;  // << 3 insteed of << 4 because YUYV is 2 bytes wide
    
    if (IS_FIELD(dwFlags) && (dwFlags & VPP_BOB) && (dwFlags & VPP_INTERLEAVED) ) {
        // The problem is scaled_image does not accept -0.5 as a value
        // for Point In, therefore we must adjust dwPointIn to
        // 0 for EVEN fields 
        // 1 for ODD Fields
        // Therefore we must also adjust the SizeIn as well, and this
        // must be done before Delta Y is calculated
        if (dwFlags & VPP_EVEN) 
        {            
            dwPointIn += 0x00040000;
        } else 
        {
            dwPointIn += 0x00140000;
        }
        dwHeight = dwHeight - 1;    
    }
    
    dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));        
    
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    dwPointOut = asmMergeCoords(0,0); // outpoint on fulscreen mirror should be zero, for top of screen.    
    dwClipPoint = asmMergeCoords(0,0); // clippoint should be zerol;       

    
    // This stuff should be done elsewhere, and saved in the context,
    // In Efficient! [XW]
    // aspect ratio.. should be calculated somewhere... in init,
    // and attached to some kind of info struct
    // calculate the scaling ration in/out.
    

    if (dwFlags & VPP_INTERLEAVED) 
    {            
        if (dwFlags & VPP_EVEN) 
        { dwOffset += dwPitch; }
        dwPitch  <<= 1;
        dwHeight >>= 1;
        dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));        
     
    }

    dwInFormat = (ULONG)((ULONG) dwPitch | (ULONG)NV089_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16| (ULONG) NV089_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24);

    if (pSurface->dwWidth <= 1)
        dwDeltaX = 0x100000;
    else
    {
        dwDeltaX =  (dwWidth - 1) << 16;
        dwDeltaX /= (pSurface->dwWidth - 1);
        dwDeltaX <<=4 ;
    }
        
    if (pSurface->dwHeight <= 1)
        dwDeltaY = 0x100000;
    else
    {
        dwDeltaY =  (dwHeight - 1) << 16;
        dwDeltaY /= (pSurface->dwHeight - 1);
        dwDeltaY <<=4 ;
    }
        
    
    dwSizeOut = asmMergeCoords(pSurface->dwWidth, pSurface->dwHeight); // size of fullscreen grab out of surf info in struct
    dwClipSize = dwSizeOut;   
            
    dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
    dwPitch2d = ( (pSurface->dwPitch << 16) | dwPitch );

    // program overlay to flip
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

    // update the notifiers
    as2mNotifiers = (NvNotification*)pVPEContext->as2mNotifiers;
//    if (as2mNotifiers[NV089_NOTIFIERS_NOTIFY].status == NV089_NOTIFICATION_STATUS_IN_PROGRESS) {
//        return ERROR_INVALID_PARAMETER;
//    } // FCF: Why is the notifier never ready?

    as2mNotifiers[NV089_NOTIFIERS_NOTIFY].status = NV089_NOTIFICATION_STATUS_IN_PROGRESS;

    NVP_DMAPUSH_CHECK_FREE_COUNT(32); // Adjusted - check

    // Setup NV04_CONTEXT_SURFACES_2D object    
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OBJECT, NVP_CONTEXT_SURFACE_2D_OBJECT);    
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_COLOR_FORMAT, dwSurfaceColorFormat);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_PITCH, dwPitch2d);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OFFSET_SOURCE, dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OFFSET_DESTIN, pSurface->dwOffset);
    
    // Setup NV05_SCALED_IMAGE_FROM_MEMORY object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_OBJECT, NVP_SCALED_IMAGE_OBJ_ID);        
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_CLIP_POINT,dwClipPoint);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_CLIP_SIZE,dwClipSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_OUT_POINT,dwPointOut);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_OUT_SIZE,dwSizeOut);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_DS_DX,dwDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_DT_DY,dwDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN_SIZE,dwSizeIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN_FORMAT,dwInFormat);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN_OFFSET,dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN,dwPointIn);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return NO_ERROR;
}

// }
// ***************************************************************************
// [XW:10/02/2000] - end FS Mirror Functions
// ***************************************************************************

// ***************************************************************************
// [XW:10/02/2000] - start FS Mirror callbacks section
// ***************************************************************************
// {

#ifdef _WIN32_WINNT



/*
==============================================================================
    
    NVPFsCRTCField0Notify

    Description:    callback function. for crtc buffer 0 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField0Notify(PVOID pHwDeviceExtension)
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;    
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    NVPFsFlip(pVPEContext,1);
}


/*
==============================================================================
    
    NVPFsCRTCField1Notify

    Description:    callback function. for crtc buffer 1 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField1Notify(PVOID pHwDeviceExtension)
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    NVPFsFlip(pVPEContext,0);
}

#else


/*
==============================================================================
    
    NVPFsCRTCField0Notify

    Description:    callback function. for crtc buffer 0 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField0Notify()
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)&nvpeDevExtension;    
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    NVPFsFlip(pVPEContext,1);
}


/*
==============================================================================
    
    NVPFsCRTCField1Notify

    Description:    callback function. for crtc buffer 1 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField1Notify()
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)&nvpeDevExtension;
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    NVPFsFlip(pVPEContext,0);
}



#endif //_WIN32_WINNT

//#endif // VPE_FSMIRROR

// }
// ***************************************************************************
// [XW:10/02/2000] - end FS Mirror callbacks section
// ***************************************************************************

#endif


/*
==============================================================================
    
    NVP3Initialize

    Description:    Initializes the NV video port. Creates channels and DMA
                    contexts. Create Video and VBI objects.
                    NV3 version uses PIO channel

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVP3Initialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
#ifdef NVP_NV3
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    NVOS10_PARAMETERS evParam;
    int nFreeCount;
    U032 status;
    NVOS09_PARAMETERS ntfParam;
    Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);

//////////// HACK
    //cur_debuglevel = 1;
    g_bFlip = FALSE;
///////////

    DBGPRINT(DBGTRACE,"NVP3Initialize()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    // initialize context
    pVPEContext->pNVPChannel = (ULONG) pNVPChannel; // keep a copy of the pio channel pointer
    pVPEContext->nvDmaFifo = NULL;
    pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
    pVPEContext->hClient = pCmdObj->hClient;
      pVPEContext->pFrameBuffer = pCmdObj->pFrameBuffer;
      pVPEContext->dwFBLen = pCmdObj->dwFBLen;
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
    pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
    pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
    pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
    pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
    pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
    pVPEContext->nNumVidSurf = 0;
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->dwVPState = NVP_STATE_STOPPED;
    pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
    pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
    pVPEContext->nCurTransferIdx = NVP_EOQ;
    pVPEContext->nLastTransferIdx = NVP_EOQ;
    pVPEContext->nRecentTransferIdx = NVP_EOQ;
    pVPEContext->nNumTransfer = 0;
    pVPEContext->bxfContextCreated = FALSE;
    pVPEContext->bxfContextFlushed = FALSE;
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // alloc external decoder object
    if (RmAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_EXTERNAL_DECODER_OBJECT,
                NV03_EXTERNAL_VIDEO_DECODER) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "Cannot allocate External Decoder Object ", NVP_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }

    // allocate transfer object (used for vbi and video capture)
    if (RmAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_M2M_OBJECT,
                NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "Cannot allocate Mem to mem transfer Object ", NVP_M2M_OBJECT);
        return FALSE;
    }

    // allocate the transfer FROM context
    if (RmAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for M2M transfer Object");
        return FALSE;
    }

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for M2M transfer Object");
        return FALSE;
    }
    
    // allocate a notify context for external decoder
    if (RmAllocContextDma(
                    pCmdObj->hClient,
                    NVP_EXTERNAL_DECODER_NOTIFIER,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->avpNotifiers),
                    (sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for external decoder object");
        return FALSE;
    }

    // context DMA for video field0
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for video field0");
        return FALSE;
    }

    // context DMA for video field1 
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for video field1");
        return FALSE;
    }
    
    // context DMA for video field0
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for VBI field0");
        return FALSE;
    }

    // context DMA for video field1
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for VBI field1");
        return FALSE;
    }

    //CHECK_FREE_COUNT(pNVPChannel,10*5);
    nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    while (nFreeCount < 13*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    }           
    pVPEContext->nFreeCount = nFreeCount - (13*4);

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // transfer object setup
    pNVPChannel->subchannel[5].SetObject  = NVP_M2M_OBJECT;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = NVP_M2M_NOTIFIER;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = NVP_M2M_FROM_CONTEXT;
    
    // make sure decoder object is in the channel....
    pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = NVP_EXTERNAL_DECODER_NOTIFIER;

    // plug in our buffer contexts
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] = NVP_VIDEO_FIELD0_BUFFER_CONTEXT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] = NVP_VIDEO_FIELD1_BUFFER_CONTEXT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]   = NVP_VBI_FIELD0_BUFFER_CONTEXT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]   = NVP_VBI_FIELD1_BUFFER_CONTEXT;
    
    // NB: we don't want to launch any captures at this point

    // setup the transfer callback
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_M2M_OBJECT;
    evParam.hObjectNew = NVP_M2M_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) NVPTransferNotify;
    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for m2m transfer 0");
        return FALSE;
    }

    // setup fields callbacks
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VideoField0Notify;

    // video field0
    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for video field 0");
        return FALSE;
    }

    // video field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VideoField1Notify;

    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for video field 1");
        return FALSE;
    }

    // vbi field0
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VBIField0Notify;

    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for VBI field 0");
        return FALSE;
    }
            
    // vbi field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VBIField1Notify;

    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for VBI field 1");
        return FALSE;
    }
#endif // NVP_NV3
    return NO_ERROR;
}


/*
==============================================================================
    
    NVPInitialize

    Description:    Initializes the NV video port. Creates channels and DMA
                    contexts. Create Video and VBI objects.
                    DMA push buffer version (NV ver >= 0x04)

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPInitialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    NvNotification *aovNotifiers;
    U032 dwOvObj;
    NVOS10_PARAMETERS evParam;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    U032 i, status;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pCmdObj->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3Initialize(pHwDevExt, pCmdObj);

//////////// HACK
    //cur_debuglevel = 1;
    g_bFlip = FALSE;
///////////

    DBGPRINT(DBGTRACE, "NVPInitialize()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // already initialized... should rather uninitialize and re-initialize with new data !!!
    //transfer check to ring3 NVPInitialize
#if 0
	if (pVPEContext->nvDmaFifo != NULL)	
    {
          DBGPRINT(DBGERROR, "already initialized !");
          return NO_ERROR;
    }
#endif

    // FS Mirror variable initialization
    pVPEContext->MultiMon = pCmdObj->MultiMon;
    pVPEContext->regOverlayMode = pCmdObj->regOverlayMode;
    pVPEContext->regOverlayMode2 = pCmdObj->regOverlayMode2;
    pVPEContext->regOverlayMode3 = pCmdObj->regOverlayMode3;
    pVPEContext->dwFsMirrorOn = 0;
    pVPEContext->nNumFSSurf = 0;
    pVPEContext->nFSFlipSurfIdx = 0;
    pVPEContext->nFSMirrorIdx = 0;
    pVPEContext->nFSFlipIdx = 0;
    pVPEContext->dwOverlayFSHead = 0;
    pVPEContext->dwOverlayFSOvlHead = 0;

    // initialize context
    //pVPEContext->pNVPChannel = (ULONG) 0;
    pVPEContext->dwChipId = pCmdObj->dwChipId;
    pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
    pVPEContext->hClient = pCmdObj->hClient;
    pVPEContext->pFrameBuffer = pCmdObj->pFrameBuffer;
    pVPEContext->dwFBLen = pCmdObj->dwFBLen;
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
    pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
    pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
    pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
    pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
    pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
    pVPEContext->nNumVidSurf = 0;
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->dwVPState = NVP_STATE_STOPPED;
    pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
    pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
    pVPEContext->nCurTransferIdx = NVP_EOQ;
    pVPEContext->nLastTransferIdx = NVP_EOQ;
    pVPEContext->nRecentTransferIdx = NVP_EOQ;
    pVPEContext->nNumTransfer = 0;
    pVPEContext->bxfContextCreated = FALSE;
    pVPEContext->bxfContextFlushed = FALSE;
    for (i = 0; i < NVP_MAX_SYNC_EVENTS; i++)
    {
        pVPEContext->hNVPSyncEvent[i] = (PVOID)(pCmdObj->hNVPSyncEvent[i]);
    }

    pVPEContext->nvDmaFifo = NULL;
    pVPEContext->DmaPushBufTotalSize = 32*1024*4;   // 32k DWORDs

    if (osNVPAllocDmaBuffer((PVOID)pHwDevExt, pVPEContext->DmaPushBufTotalSize, (PVOID *)&(pVPEContext->nvDmaFifo)))
        return ERROR_INVALID_PARAMETER;

    if (rmNVPAllocContextDma(pCmdObj->hClient,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_ONLY,
                            0, // selector
                            (U032)(pVPEContext->nvDmaFifo),
                            pVPEContext->DmaPushBufTotalSize - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate Context Dma for PushBuffer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the DMA push buffer ERROR notifier
    if (rmNVPAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            0, // selector
                            (U032)(&(pVPEContext->DmaPushBufErrNotifier[0])),
                            sizeof(NvNotification) - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate PushBuffer notifier");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate DMA channel here !
    if (rmNVPAllocChannelDma(  pCmdObj->hClient,
                            pCmdObj->dwDeviceId,
                            NVP_VPE_CHANNEL,
                            NV4_CHANNEL_DMA,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            0,
                            (PVOID)&(pVPEContext->pDmaChannel)) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Dma Channel ", NVP_VPE_CHANNEL);
        return ERROR_INVALID_PARAMETER;
    }

    // alloc external decoder object
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_EXTERNAL_DECODER_OBJECT,
                NV03_EXTERNAL_VIDEO_DECODER) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate External Decoder Object ", NVP_EXTERNAL_DECODER_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }

    // allocate transfer object (used for vbi and video capture)
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_M2M_OBJECT,
                NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Mem to mem transfer Object ", NVP_M2M_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }

    dwOvObj = (pCmdObj->dwChipId < NV_DEVICE_VERSION_10) ? NV04_VIDEO_OVERLAY : NV10_VIDEO_OVERLAY;

    // If not MultiMon, use the old way to make an overlay
    // Otherwise, specify which head to use.
    if (!pVPEContext->MultiMon) {
    // alloc overlay object
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_OVERLAY_OBJECT,
                dwOvObj) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Overlay Object ", NVP_OVERLAY_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }
    } else {
        NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;

        nv07aAllocParms.logicalHeadId = pVPEContext->dwOverlayFSOvlHead;
        if (rmNVPAlloc(pCmdObj->hClient,
                  NVP_VPE_CHANNEL,
                  NVP_OVERLAY_OBJECT,
                  NV10_VIDEO_OVERLAY,
                  &nv07aAllocParms) != 0)
        {
            DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Overlay Object ", NVP_OVERLAY_OBJECT);
            return ERROR_INVALID_PARAMETER;
        }
    }


    // alloc DVD subpicture object
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_DVD_SUBPICTURE_OBJECT,
                NV4_DVD_SUBPICTURE) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate DVD subpicture Object ", NVP_DVD_SUBPICTURE_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }

    // allocate the transfer FROM context
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for M2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a notify context for transfer object
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for M2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }
    
    // allocate a notify context for external decoder
    if (rmNVPAllocContextDma(
                    pCmdObj->hClient,
                    NVP_EXTERNAL_DECODER_NOTIFIER,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->avpNotifiers),
                    (sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for external decoder object");
        return ERROR_INVALID_PARAMETER;
    }

    // context DMA for video field0
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate context DMA for video field0");
        return ERROR_INVALID_PARAMETER;
    }

    // context DMA for video field1 
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for video field1");
        return ERROR_INVALID_PARAMETER;
    }
    
    // context DMA for video field0
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate context DMA for VBI field0");
        return ERROR_INVALID_PARAMETER;
    }

    // context DMA for video field1
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "cannot allocate context DMA for VBI field1");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a context for overlay object
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_OVERLAY_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate dma context for overlay buffer0");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a context for DVD subpicture object
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_DVD_SUBPICTURE_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate dma context for DVD subpicture Object");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a notify context for overlay notifiers
    if (rmNVPAllocContextDma(
                    pCmdObj->hClient,
                    NVP_OVERLAY_NOTIFIER,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->aovNotifiers),
                    (sizeof(NvNotification)*NVP_CLASS07A_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for external decoder object");
        return ERROR_INVALID_PARAMETER;
    }

    // reset media port notifiers
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // reset overlay notifiers
    aovNotifiers = (NvNotification *) (pVPEContext->aovNotifiers);
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(0)].status = 0;
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(1)].status = 0;

    pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = (U032) (pVPEContext->aovNotifiers);

    // init Dma channel pointers
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    pDmaChannel->Put = 0;
    nvDmaCount = 0;

    // set m2m object context
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_NOTIFIES, NVP_M2M_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_IN, NVP_M2M_FROM_CONTEXT);

    // make sure decoder object is in the channel....
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_NOTIFIES, NVP_EXTERNAL_DECODER_NOTIFIER);
    // plug in our buffer contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(0), NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(1), NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(0), NVP_VBI_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(1), NVP_VBI_FIELD1_BUFFER_CONTEXT);

    // set overlay contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_NOTIFIES, NVP_OVERLAY_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(0), NVP_OVERLAY_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(1), NVP_OVERLAY_BUFFER_CONTEXT);

    // same for DVD subpicture context
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT, NVP_DVD_SUBPICTURE_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_IN, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_OUT, NVP_DVD_SUBPICTURE_CONTEXT);

    pVPEContext->nvDmaCount = nvDmaCount;
    pDmaChannel->Put = nvDmaCount << 2;

    // NB: we don't want to launch any captures at this point

    // setup the transfer callback
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_M2M_OBJECT;
    evParam.hObjectNew = NVP_M2M_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
    NvU64_VALUE(evParam.hEvent) = (ULONG) NVPTransferNotify;
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for m2m transfer 0");
        return ERROR_INVALID_PARAMETER;
    }

    // setup fields callbacks
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VideoField0Notify;

    // video field0
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for video field 0");
        return ERROR_INVALID_PARAMETER;
    }

    // video field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VideoField1Notify;

    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for video field 1");
        return ERROR_INVALID_PARAMETER;
    }

    // vbi field0
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VBIField0Notify;

    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for VBI field 0");
        return ERROR_INVALID_PARAMETER;
    }
            
    // vbi field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VBIField1Notify;

    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for VBI field 1");
        return ERROR_INVALID_PARAMETER;
    }

    // media port sync event
    if (pCmdObj->hNVPSyncEvent[0])
    {
        // field 0
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
        evParam.hObjectNew = NVP_VSYNC_EVENT0;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[0];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

        // field 1 (use same event for both fields)
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
        evParam.hObjectNew = NVP_VSYNC_EVENT1;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[0];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

    }

    // media port sync event
    if (pCmdObj->hNVPSyncEvent[1] && pCmdObj->hNVPSyncEvent[2])
    {
        // field 0
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_OVERLAY_OBJECT;
        evParam.hObjectNew = NVP_OV_SYNC_EVENT0;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV07A_NOTIFIERS_SET_OVERLAY(0);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[1];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

        // field 1
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_OVERLAY_OBJECT;
        evParam.hObjectNew = NVP_OV_SYNC_EVENT1;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV07A_NOTIFIERS_SET_OVERLAY(1);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[2];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

    }

	//alloc m2m dst heap for dma xfer -osNVPAllocDmaBuffer naming is ambiguous, should change to allocheap
	if (osNVPAllocDmaBuffer((PVOID)pHwDevExt, BUFSIZE, (PVOID *)&(pVPEContext->pSysBuf)))
        return ERROR_INVALID_PARAMETER;

	if(!(pVPEContext->pSysBuf)){
		DBGPRINT(DBGERROR, "Unable to alloc Sys Buf\n");
		return ERROR_INVALID_PARAMETER;
	}

	//alloc context dma for m2m dst heap
	if (rmNVPAllocContextDma(
                    pVPEContext->hClient,
                    NVP_M2M_CONTEXT,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->pSysBuf),
                    BUFSIZE-1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate mem 2 mem context");
        return DXERR_GENERIC;
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPUninitialize

    Description:    Free channels, DMA contexts and objects created by a
                    previous call to NVPInitialize

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPUninitialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;

    DBGPRINT(DBGTRACE, "NVPUninitialize()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    //NVPFlushChannel(pVPEContext);

    // free allocated resources
    ////////// shouldn't we wait for completion (either grab of transfer ?!)
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_NOTIFIER);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_NOTIFIER);
    // free transfer object resources
    //if (pVPEContext->bxfContextCreated)
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_CONTEXT);

	// free m2m dst heap
	if(pVPEContext->pSysBuf){
		osNVPReleaseDmaBuffer((PVOID)(pHwDevExt), (PVOID)(pVPEContext->pSysBuf));
	}

    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_NOTIFIER);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_FROM_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_EVENT);
    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_M2M_OBJECT);

    if (pVPEContext->hNVPSyncEvent[0])
    {
        rmNVPFree(pCmdObj->hClient, NVP_EXTERNAL_DECODER_OBJECT, NVP_VSYNC_EVENT0);
        rmNVPFree(pCmdObj->hClient, NVP_EXTERNAL_DECODER_OBJECT, NVP_VSYNC_EVENT1);
        pVPEContext->hNVPSyncEvent[0] = NULL;
    }

    if (pVPEContext->hNVPSyncEvent[1] || pVPEContext->hNVPSyncEvent[2])
    {
        rmNVPFree(pCmdObj->hClient, NVP_OVERLAY_OBJECT, NVP_OV_SYNC_EVENT0);
        rmNVPFree(pCmdObj->hClient, NVP_OVERLAY_OBJECT, NVP_OV_SYNC_EVENT1);
        pVPEContext->hNVPSyncEvent[1] = NULL;
        pVPEContext->hNVPSyncEvent[2] = NULL;
    }

    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_EXTERNAL_DECODER_OBJECT);
    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_OVERLAY_OBJECT);
    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_DVD_SUBPICTURE_OBJECT);

    if (pVPEContext->nvDmaFifo != NULL)
    {
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VPE_CHANNEL);
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_FROM_MEMORY_PUSHBUF);
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_PUSHBUF_ERROR_NOTIFIER);
        osNVPReleaseDmaBuffer((PVOID)(pHwDevExt), (PVOID)(pVPEContext->nvDmaFifo));
    }

    pVPEContext->pOverlayChannel = 0;
    pVPEContext->nvDmaFifo = NULL;
    pVPEContext->pDmaChannel = NULL;

    pVPEContext->nvpOverlay.dwOverlayBufferIndex = NVP_UNDEF;

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPUpdate

    Description:    Updates the NV video port data.

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPUpdate(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_OVERLAY pnvOverlay;
    DWORD i, dwFlipStatus;

    DBGPRINT(DBGTRACE, "NVPUpdate()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// get decoder height
	pVPEContext->dwDecoderHeight = pCmdObj->dwInHeight;

    pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
    {
        DBGPRINT(DBGERROR, "NVPUpdate() exceeded number of extra 422 surfaces");
        return ERROR_INVALID_PARAMETER;
    }

    // get a pointer to the overlay object in VPE context
    pnvOverlay = &(pVPEContext->nvpOverlay);

    // update overlay info: extra 422 surfaces used for prescaling
    pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
    pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
    pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < pCmdObj->dwExtra422NumSurfaces; i++)
    {
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i]; // extra memory space used for prescaling
    }

    // just in case flipping was turned on before starting mediaport, turn it off only for the first 2 manual flips
    dwFlipStatus = g_bFlip;
    g_bFlip = FALSE;

    // start video grabbing here if not already done in NVPStart
    if ((pVPEContext->nNumVidSurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO))
    {
        // start VBI at the same time as video if vbi is not already enabled !
        if (pVPEContext->nNumVBISurf > 0)
        {
            // is it already started, then no need to do it again...
            if (!(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
            {
                (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
                pVPEContext->nNextVBISurfId = 1;
            }
            pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO | NVP_STATE_STARTED_VBI);
        }
        else
            pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO);
        
        (pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
        // kick off VP
        pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
#ifdef _NVP_TEST_NEXT_FIELD
            g_nIntCounter = 0;
            g_nNextFieldId = 0;
#endif
        // we OR 0x80 to tell function this is not a notifier calling !
        NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
        NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
    }
    // start VBI grabbing here if not already done in NVPStart
    else if ((pVPEContext->nNumVBISurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
    {
        // if video already started, then only enable VBI state flag
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
        {
            pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
        }
        else
        {
            pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VBI);
            (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
            pVPEContext->nNextVBISurfId = 1;
            // kick off VP
            NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
            NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
        }
    }

    // restore overlay flipping status
    g_bFlip = dwFlipStatus;

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPStart

    Description:    Tells the NV video port to start grabbing video

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPStart(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_OVERLAY pnvOverlay;
    DWORD i, dwFlipStatus;

    DBGPRINT(DBGTRACE, "NVPStart()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // aleady started ?! it must be an UpdateVideo then...
    if (pVPEContext->dwVPState & NVP_STATE_STARTED)
        return NVPUpdate(pHwDevExt, pCmdObj);

	// get decoder height
	pVPEContext->dwDecoderHeight = pCmdObj->dwInHeight;

    // current
    pVPEContext->nVidSurfIdx = 0;
    pVPEContext->nVBISurfIdx = 0;
    // next in the list
    pVPEContext->nNextVideoSurfId = 0;
    pVPEContext->nNextVBISurfId = 0;

    // update overlay channel pointer !
    /////// NVPUpdate() must be the place for this !?
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

    pVPEContext->dwVPState = NVP_STATE_STARTED;
    pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
    {
        DBGPRINT(DBGERROR, "NVPStart() exceeded number of extra 422 surfaces ");
        return ERROR_INVALID_PARAMETER;
    }

    // get a pointer to the overlay object in VPE context
    pnvOverlay = &(pVPEContext->nvpOverlay);

    // update overlay info: extra 422 surfaces used for prescaling
    pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
    pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
    pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < pCmdObj->dwExtra422NumSurfaces; i++)
    {
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i]; // extra memory space used for prescaling
    }

    // just in case flipping was turned on before starting mediaport, turn it off only for the first 2 manual flips
    dwFlipStatus = g_bFlip;
    g_bFlip = FALSE;

    // make a cyclic chain with surfaces
    if (pVPEContext->nNumVidSurf > 0)
    {
        pVPEContext->dwVPState |= NVP_STATE_STARTED_VIDEO;
        (pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
        // kick off VP
        pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
        // before kicking off the media port, check out VBI setting
        if (pVPEContext->nNumVBISurf > 0)
        {
            pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
            (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
            pVPEContext->nNextVBISurfId = 1;
        }
#ifdef _NVP_TEST_NEXT_FIELD
            g_nIntCounter = 0;
            g_nNextFieldId = 0;
#endif

        // we OR 0x80 to tell function this is not a notifier calling !
        NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
        NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
    }
    else if (pVPEContext->nNumVBISurf > 0)
    {
        pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
        (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
        pVPEContext->nNextVBISurfId = 1;
        // kick off VP
        NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
        NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
    }

    // restore overlay flipping status
    g_bFlip = dwFlipStatus;
    
    return NO_ERROR;
}

/*
==============================================================================
    
    NVP3Stop

    Description:    Tells the NV video port to stop grabbing. PIO channel
                    version

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVP3Stop(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    NVOS09_PARAMETERS ntfParam;
    U032 i = 0;

    DBGPRINT(DBGTRACE, "NVP3Stop()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    // aleady stopped ?!
    if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
        return NO_ERROR;
    else
        pVPEContext->dwVPState = NVP_STATE_STOPPED;

    g_bFlip = FALSE;

    pVPEContext->pNVPChannel = (ULONG) pNVPChannel; // get a copy of the pio channel pointer
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // tell VP to stop grabbing !
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage = 0;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;

    ntfParam.hObjectParent = pCmdObj->dwDeviceId;
#define NVP_NOTIFY_TIMEOUT 100000
    // wait for the last few notifies to show up...
    while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
             (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
           (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           (i < NVP_NOTIFY_TIMEOUT)))
    {
        i++;
        //RmInterrupt(&ntfParam);
    }

#ifdef _STOP_OVERLAY
    // reset surfaces counters
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->nNumVidSurf = 0;
#endif

#endif // NVP_NV3
    return NO_ERROR;
}

/*
==============================================================================
    
    NVPShutDownMediaPort

    Description:    shuts down media port engine

    Date:           May 24, 2000
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPShutDownMediaPort(PNVP_CONTEXT pVPEContext)
{
    NvNotification *avpNotifiers;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    U032 i;

    DBGPRINT(DBGTRACE, "NVPShutDownMediaPort()");

    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

    // stop grabbing !
    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VIDEO)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_IMAGE , 0);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VBI)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_VBI , 0);
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

#define NVP_NOTIFY_TIMEOUT 100000
    i = 0;
    // wait for the last few notifies to show up...
    while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
             (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
           (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           (i < NVP_NOTIFY_TIMEOUT)))
    {
        i++;
    }

    // timed-out...
    if (i >= NVP_NOTIFY_TIMEOUT)
        DBGPRINT(DBGERROR, "waiting for MediaPort notifiers timed-out....");

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // clear/reset sync event
    osNVPClearEvent((PVOID) pVPEContext->hNVPSyncEvent[0]);

    pVPEContext->dwVPState = NVP_STATE_STOPPED;

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPShutDownOverlay

    Description:    shuts down overlay engine

    Date:           May 24, 2000
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPShutDownOverlay(PNVP_CONTEXT pVPEContext)
{
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    NvNotification *pPioFlipOverlayNotifier;
    U032 i;

    DBGPRINT(DBGTRACE, "NVPShutDownOverlay()");

    // channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

    // stop overlay engine
    if (pDmaChannel && g_bFlip)
    {
        g_bFlip = FALSE;

        if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
        {
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[1]);
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[2]);
        }

        // reset notifiers
        pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;

        // stop overlay
        NVP_DMAPUSH_CHECK_FREE_COUNT(6);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        pDmaChannel->Put = nvDmaCount << 2;
        pVPEContext->nvDmaCount = nvDmaCount;

        // wait here only if not waiting on events in ring3 !!!
        if ((pVPEContext->hNVPSyncEvent[1] == NULL) || (pVPEContext->hNVPSyncEvent[2] == NULL))
        {
            i = 0;
            while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                i++;

            // timed-out...
            if (i >= NVP_VPP_TIME_OUT)
                DBGPRINT(DBGERROR, "waiting for overlay flip notifiers timed-out....");
        }

        pPioFlipOverlayNotifier[1].status = 0;
        pPioFlipOverlayNotifier[2].status = 0;
    }
    // don't let ring3 wait for nothing !
    else if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
    {
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[1]);
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[2]);
    }

    return NO_ERROR;
}


/*
==============================================================================
    
    NVPStop

    Description:    Tells the NV video port to stop grabbing

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPStop(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    //Nv03ChannelPio *pOvChannel;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    NvNotification *pPioFlipOverlayNotifier;

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // overlay channel
    //pOvChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);   // get a pointer to the overlay channel

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3Stop(pHwDevExt, pCmdObj);

    DBGPRINT(DBGTRACE, "NVPStop()");

    // aleady stopped ?!
    if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
        return NO_ERROR;
    else
        pVPEContext->dwVPState = NVP_STATE_STOPPED;

    // channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

#ifdef _STOP_OVERLAY
    // stop overlay engine
    if (pDmaChannel && g_bFlip)
    {
        g_bFlip = FALSE;

        if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
        {
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[1]);
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[2]);
        }

        // reset notifiers
        pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;

        // stop overlay
        NVP_DMAPUSH_CHECK_FREE_COUNT(6);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        pDmaChannel->Put = nvDmaCount << 2;
        pVPEContext->nvDmaCount = nvDmaCount;

        // wait here only if not waiting on events in ring3 !!!
        if ((pVPEContext->hNVPSyncEvent[1] == NULL) || (pVPEContext->hNVPSyncEvent[2] == NULL))
        {
            i = 0;
            while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                i++;

            // timed-out...
            if (i >= NVP_VPP_TIME_OUT)
                DBGPRINT(DBGERROR, "waiting for overlay flip notifiers timed-out....");
        }

        pPioFlipOverlayNotifier[1].status = 0;
        pPioFlipOverlayNotifier[2].status = 0;
    }
    // don't let ring3 wait for nothing !
    else if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
    {
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[1]);
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[2]);
    }

    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // tell VP to stop grabbing !
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VIDEO)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_IMAGE , 0);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VBI)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_VBI , 0);
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

#define NVP_NOTIFY_TIMEOUT 100000
    i = 0;
    // wait for the last few notifies to show up...
    while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
             (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
           (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           (i < NVP_NOTIFY_TIMEOUT)))
    {
        i++;
        //RmInterrupt(&ntfParam);
    }

    // timed-out...
    if (i >= NVP_NOTIFY_TIMEOUT)
        DBGPRINT(DBGERROR, "waiting for MediaPort notifiers timed-out....");

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

#else
//    NVPShutDownOverlay(pVPEContext);

    // reset notifiers
    pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

    pPioFlipOverlayNotifier[1].status = 0;
    pPioFlipOverlayNotifier[2].status = 0;

    NVPShutDownMediaPort(pVPEContext);
#endif


    // reset surfaces counters
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->nNumVidSurf = 0;

#ifdef _STOP_OVERLAY
    // clear/reset sync event
    osNVPClearEvent((PVOID) pVPEContext->hNVPSyncEvent[0]);
#endif

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPRegSurface

    Description:    register a DDraw surface. Insert in list and update
                    attributes

    Date:           Feb 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPRegSurface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface;
    BOOL bVideoStarted, bVBIStarted;

    DBGPRINT(DBGTRACE, "NVPRegSurface()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    bVideoStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO);
    bVBIStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI);

    //resize VP if capturing
    if(pVPEContext->ulVPECaptureFlag){
        
        pCmdObj->dwPreWidth=(pVPEContext->ulVPECapturePrescaleXFactor *
                                    pCmdObj->dwInWidth)/1000;
        pCmdObj->dwPreHeight=(pVPEContext->ulVPECapturePrescaleYFactor *
                                    pCmdObj->dwInHeight)/1000;
    }               

    // update attributes of already existing surfaces ?!
    if (pCmdObj->bSurfUpdate)
    {
        // vbi surfaces ?!
        if (pCmdObj->bSurfVBI)
        {
            if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVBISurf)
            {
                pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
                // check for mem offset in framebuffer !
                if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
                {
                    pSurface->dwHeight = pCmdObj->dwVBIHeight;
                    pSurface->dwStartLine = pCmdObj->dwVBIStartLine;        // startline for vbi

                }
                else
                {
                    DBGPRINT(DBGERROR, "can't update VBI surface data !");
                    return ERROR_INVALID_PARAMETER;
                }

            }
            else
            {
                // new vbi surfaces
                pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
                (pVPEContext->nNumVBISurf)++;
                pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
                pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
                pSurface->dwPitch = pCmdObj->dwSurfPitch;
                pSurface->dwHeight = pCmdObj->dwVBIHeight;
                pSurface->dwStartLine = pCmdObj->dwVBIStartLine;        // Programs Y-crop for image, and startline for vbi
                pSurface->dwPreScaleSizeX = pCmdObj->dwInWidth;         // prescale size width == pitch for vbi surfaces
                pSurface->dwPreScaleSizeY = pCmdObj->dwInHeight;        // prescale size height == vbi height 
                pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;   // the next surface idx in the chain
                pSurface->bIsFirstFieldCaptured = FALSE;                // reset value

            }
        }
        else    // video surface
        {
            if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVidSurf)
            {
                //////////
                ///// I assume something changing in the following values only !
                pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
                if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
                {
#ifndef _STOP_OVERLAY
                    ///// we need to stop the media port and restart it later because there is a change in the scaling factors
                    if ((pSurface->dwHeight != pCmdObj->dwInHeight) || 
                        (pSurface->dwWidth != pCmdObj->dwInWidth) ||
                        (pSurface->dwPreScaleSizeX != pCmdObj->dwPreWidth) ||
                        (pSurface->dwPreScaleSizeY != pCmdObj->dwPreHeight))
                    {
                        //pVPEContext->bVPScalingFactorChanged = TRUE;
                        // aleady stopped ?!
                        if (!(pVPEContext->dwVPState & NVP_STATE_STOPPED))
                        {
                            NVPShutDownOverlay(pVPEContext);
                            NVPShutDownMediaPort(pVPEContext);
                        }
                    }
#endif
                    pSurface->dwHeight = pCmdObj->dwInHeight;
                    pSurface->dwWidth = pCmdObj->dwInWidth;                 // Ignored for VBI
                    pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // Programs Y-crop for image, and startline for vbi
                    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // prescale size width
                    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // prescale size height
                }
                else
                {
                    DBGPRINT(DBGTRACE, "can't update video surface data !");
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                // new video surfaces
                pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
                (pVPEContext->nNumVidSurf)++;
                pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
                pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
                pSurface->dwPitch = pCmdObj->dwSurfPitch;
                pSurface->dwHeight = pCmdObj->dwInHeight;
                pSurface->dwWidth = pCmdObj->dwInWidth;                 // Ignored for VBI
                pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // Programs Y-crop for image, and startline for vbi
                pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // prescale size width
                pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // prescale size height
                pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;   // the next surface idx in the chain
                pSurface->bIsFirstFieldCaptured = FALSE;                // reset value

            }
        }
    }
    else    // new surfaces !
    {
        if (pVPEContext->dwVPState & NVP_STATE_STARTED)
        {
            DBGPRINT(DBGERROR, "can't register new DD surfaces while Video Port is running !");
            return ERROR_INVALID_PARAMETER;
        }

        // vbi surfaces ?!
        if (pCmdObj->bSurfVBI)
        {
            pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
            (pVPEContext->nNumVBISurf)++;
            pSurface->dwStartLine = pCmdObj->dwVBIStartLine;       // startline for vbi
            pSurface->dwPreScaleSizeX = pCmdObj->dwInWidth;        // shouldn't be any prescaling performed on vbi surfaces
            pSurface->dwPreScaleSizeY = pCmdObj->dwInHeight;
        }
        else    // video surface
        {
            pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
            (pVPEContext->nNumVidSurf)++;
            pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // startline for video
            pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // prescale size width
            pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // prescale size height
        }

        pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
        pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
        pSurface->dwPitch = pCmdObj->dwSurfPitch;
        pSurface->dwHeight = pCmdObj->dwInHeight;
        pSurface->dwWidth = pCmdObj->dwInWidth;
        pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;   // the next surface idx in the chain
        pSurface->bIsFirstFieldCaptured = FALSE;                // reset value
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPUpdateOverlay

    Description:    update the overlay info structure

    Date:           Mar 01, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPUpdateOverlay(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    Nv03ChannelPio *pChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);   // get a pointer to the overlay channel;
    PNVP_OVERLAY pnvOverlay =  &(pVPEContext->nvpOverlay);
    NvNotification *pPioFlipOverlayNotifier;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount, i = 0;
    U032 srcDeltaX, srcDeltaY;
    U032 bRing0FlippingFlag;

    DBGPRINT(DBGTRACE, "NVPUpdateOverlay()");
#define VBI_CAP_OFFSET	0//1	//Hack. When capturing vid +vbi, the last vid line is always corrupted. Use
							//this to offset line and apply for all cases for consistency. ch    

	//Adjust for WDM prescale hack (only when capturing!!)
	//need to zoom back up because of ME prescaling during capture ONLY IF
	//vp is using the overlay engine(bVPNotUseOverSurf)
    if (pVPEContext->ulVPECaptureFlag && !(pVPEContext->ulVPNotUseOverSurf))
    {
        DBGPRINT(DBGTRACE, "NVPUpdateOverlay():Adjusting for VP prescaling...");

        pCmdObj->dwOverlaySrcWidth = (pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeX;    //getting prescale size since it's the same for all surfs.
#ifdef FORCE_INTERLEAVE_MEM
		pCmdObj->dwOverlaySrcHeight = ((pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeY - VBI_CAP_OFFSET)*2;
#else
        if(pVPEContext->dwVPFlags & DDVP_INTERLEAVE){
			pCmdObj->dwOverlaySrcHeight = ((pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeY - VBI_CAP_OFFSET)*2;
		}else{
			pCmdObj->dwOverlaySrcHeight = (pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeY - VBI_CAP_OFFSET;
		}
#endif
    }else{	//not capturing

#ifdef FORCE_INTERLEAVE_MEM
		//since we are forcing interleave and if DDVP_INTERLEAVE is off, 
		//overlay src size is is incorrect. need to double src height
		if (!(pVPEContext->dwVPFlags & DDVP_INTERLEAVE)){
			pCmdObj->dwOverlaySrcHeight = (pCmdObj->dwOverlaySrcHeight - VBI_CAP_OFFSET)*2;
			//pCmdObj->dwOverlaySrcPitch *= 2;
		}
#endif
	}
    // ds/dx
    if (pCmdObj->dwOverlayDstWidth <= 1) {
        srcDeltaX = 0x100000;
    } else {
        srcDeltaX = (pCmdObj->dwOverlaySrcWidth - 1) << 16;
        srcDeltaX /= pCmdObj->dwOverlayDstWidth - 1;
        srcDeltaX <<= 4;
    }

    // dt/dy
    if (pCmdObj->dwOverlayDstHeight <= 1) {
        srcDeltaY = 0x100000;
    } else {
        srcDeltaY = (pCmdObj->dwOverlaySrcHeight - 1) << 16;
        if (pVPEContext->dwChipId <= NV_DEVICE_VERSION_4) {
            srcDeltaY /= pCmdObj->dwOverlayDstHeight + 2;
        } else {
            srcDeltaY /= pCmdObj->dwOverlayDstHeight + 1;
        }
        srcDeltaY <<= 4;
    }

    // sizein
    pCmdObj->dwOverlaySrcSize = (pCmdObj->dwOverlaySrcHeight)<<16;
    pCmdObj->dwOverlaySrcSize |= pCmdObj->dwOverlaySrcWidth;

    pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

    if ((pCmdObj->dwOverlayDstWidth != 0) && (pCmdObj->dwOverlayDstHeight != 0))
    {
        // I must rather have a structure memcpy !
        pnvOverlay->dwOverlayFormat = pCmdObj->dwOverlayFormat;
        pnvOverlay->dwOverlaySrcX = pCmdObj->dwOverlaySrcX;
        pnvOverlay->dwOverlaySrcY = pCmdObj->dwOverlaySrcY;
        pnvOverlay->dwOverlaySrcPitch = pCmdObj->dwOverlaySrcPitch;
        pnvOverlay->dwOverlaySrcSize = pCmdObj->dwOverlaySrcSize;
        pnvOverlay->dwOverlaySrcWidth = pCmdObj->dwOverlaySrcWidth;
        pnvOverlay->dwOverlaySrcHeight = pCmdObj->dwOverlaySrcHeight;
        pnvOverlay->dwOverlayDstWidth = pCmdObj->dwOverlayDstWidth;
        pnvOverlay->dwOverlayDstHeight = pCmdObj->dwOverlayDstHeight;
        pnvOverlay->dwOverlayDstX = pCmdObj->dwOverlayDstX;
        pnvOverlay->dwOverlayDstY = pCmdObj->dwOverlayDstY;
        pnvOverlay->dwOverlayDeltaX = srcDeltaX;//pCmdObj->dwOverlayDeltaX;
        pnvOverlay->dwOverlayDeltaY = srcDeltaY;//pCmdObj->dwOverlayDeltaY;
        pnvOverlay->dwOverlayColorKey = pCmdObj->dwOverlayColorKey;
        pnvOverlay->dwOverlayMode = pCmdObj->dwOverlayMode;
        pnvOverlay->dwOverlayMaxDownScale = pCmdObj->dwOverlayMaxDownScale;

		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcX=", (pCmdObj->dwOverlaySrcX));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcY=", (pCmdObj->dwOverlaySrcY));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcPitch=", (pCmdObj->dwOverlaySrcPitch));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcSize=", (pCmdObj->dwOverlaySrcSize));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcWidth=", (pCmdObj->dwOverlaySrcWidth));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcHeight=", (pCmdObj->dwOverlaySrcHeight));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstWidth=", (pCmdObj->dwOverlayDstWidth));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstHeight=", (pCmdObj->dwOverlayDstHeight));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstX=", (pCmdObj->dwOverlayDstX));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstY=", (pCmdObj->dwOverlayDstY));
		DBGPRINTVALUE(DBGINFO, "srcDeltaX=", (srcDeltaX));
		DBGPRINTVALUE(DBGINFO, "srcDeltaY=", (srcDeltaY));
		DBGPRINTVALUE(DBGINFO, "dwOverlayMode=", (pCmdObj->dwOverlayMode));
		DBGPRINTVALUE(DBGINFO, "dwOverlayMaxDownScale=", (pCmdObj->dwOverlayMaxDownScale));

        // update overlay info: extra 422 surfaces used for prescaling
        pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
        pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
        pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

        for (i = 0; i < pCmdObj->dwExtra422NumSurfaces; i++)
        {
            pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i]; // extra memory space used for prescaling
        }

        DBGPRINT(DBGTRACE, "overlay flipping enabled....");
        g_bFlip = TRUE;

        // if we get a 'show overlay' command while MediaPort engine is stopped, this means that we are in a 
        // 'pause state'... unless we are using KMVT to flip (STB-TV-tuner-like app), program the overlay engine to show the last frame captured by Media Port !
        bRing0FlippingFlag = 0;
        if (pVPEContext->pOvrRing0FlipFlag)
            bRing0FlippingFlag = *((U032 *)(pVPEContext->pOvrRing0FlipFlag));
        if ((pVPEContext->dwVPState & NVP_STATE_STOPPED) && !bRing0FlippingFlag)
        {
            NVPScheduleOverlayFlip(pVPEContext, &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]), 0, 0, 0);
            // reset notifiers
            pPioFlipOverlayNotifier[1].status = 0;
            pPioFlipOverlayNotifier[2].status = 0;

        }
    }
    else
    {
        if (g_bFlip)
        {
            DBGPRINT(DBGTRACE, "overlay flipping disabled....");

            g_bFlip = FALSE;    // no autoflip !

            // channel
            pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
            nvDmaCount = pVPEContext->nvDmaCount;

            // stop overlay engine
            if (pDmaChannel)
            {
                if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
                {
                    osNVPClearEvent(pVPEContext->hNVPSyncEvent[1]);
                    osNVPClearEvent(pVPEContext->hNVPSyncEvent[2]);
                }

                // reset notifiers
//                pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

                pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
                pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;

                // stop overlay
                NVP_DMAPUSH_CHECK_FREE_COUNT(6);
                NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
                NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
                NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
                pDmaChannel->Put = nvDmaCount << 2;
                pVPEContext->nvDmaCount = nvDmaCount;

               // wait here only if not waiting on events in ring3 !!!
               if ((pVPEContext->hNVPSyncEvent[1] == NULL) || (pVPEContext->hNVPSyncEvent[2] == NULL))
               {
                    while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                        i++;
                    // timed-out...
                    if (i >= NVP_VPP_TIME_OUT)
                        DBGPRINT(DBGERROR, "waiting for overlay flip notifiers timed-out....");
                }
    
                pPioFlipOverlayNotifier[1].status = 0;
                pPioFlipOverlayNotifier[2].status = 0;
            }
        }
        // don't let ring3 wait for nothing !
        else if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
        {
            osNVPSetEvent(pVPEContext->hNVPSyncEvent[1]);
            osNVPSetEvent(pVPEContext->hNVPSyncEvent[2]);
        }
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPFlipVideoPort

    Description:    start capturing in specified surface

    Date:           Mar 01, 1999
    
    Author:         H. Azar

==============================================================================
*/
#pragma warning(disable: 4296)

VP_STATUS NVPFlipVideoPort(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface;
    int i;

    DBGPRINT(DBGTRACE, "NVPFlipVideoPort()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // NVP_UNDEF tells us to lookup the surface in list
    if (pCmdObj->dwSurfaceId == NVP_UNDEF)
    {
        for (i = 0; i < pVPEContext->nNumVidSurf; i++)
        {
                //////////
                ///// I assume nothing changing in the surfaces values
                pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
                if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
                {
                    // clear/reset sync event
                    osNVPClearEvent((PVOID)pVPEContext->hNVPSyncEvent[0]);
                    // found target surface, so update index of video surface we're currently capturing into
                    pVPEContext->nVidSurfIdx = i;
                    return NO_ERROR;
                }
        }
    }
    else
    {
        // check for weird values !
        if ((pCmdObj->dwSurfaceId >= 0) &&
            (pCmdObj->dwSurfaceId < (DWORD)pVPEContext->nNumVidSurf) &&
            (pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId].pVidMem == pCmdObj->pSurfVidMem))
        {
                // clear/reset sync event
                osNVPClearEvent((PVOID)pVPEContext->hNVPSyncEvent[0]);
                // update index of video surface we're currently capturing into
                pVPEContext->nVidSurfIdx = (int)(pCmdObj->dwSurfaceId);
                return NO_ERROR;
        }
    }

    ////// if we got here, it means the target surface wasn't found in list...
    // so add it at the end of the list
    i = pVPEContext->nNumVidSurf;
    pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
    (pVPEContext->nNumVidSurf)++;
    pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // startline for video
    pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
    pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
    pSurface->dwPitch = pCmdObj->dwSurfPitch;
    pSurface->dwHeight = pCmdObj->dwInHeight;
    pSurface->dwWidth = pCmdObj->dwInWidth;                 // Ignored for VBI
    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // Ignored for VBI.. prescale size width
    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // Ignored for VBI.. prescale size height
    pSurface->nNextSurfaceIdx = 0;                          // the next surface idx in the chain
    pSurface->bIsFirstFieldCaptured = FALSE;                // reset value
    // clear/reset sync event
    osNVPClearEvent((PVOID)pVPEContext->hNVPSyncEvent[0]);
    // flip to surface !
    pVPEContext->nVidSurfIdx = i;                           

    return NO_ERROR;
}

#pragma warning(default: 4296)

/*
==============================================================================
    
    NVP3ProgVideoField

    Description:    programs the vp to capture the specified video field

    Date:           Feb 19, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVP3ProgVideoField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId,
    U032 dwSurfPitch,
    U032 dwInterleaveOffset,
    BOOL bGrab)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pNVPChannel;
    NvNotification *avpNotifiers;
    int nFreeCount;
    NVOS09_PARAMETERS ntfParam;

    pSurface->dwFieldType = (ULONG)nFieldId;

    // get a pointer to the appropriate VPE context
    pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;    // get a copy of the pio channel pointer

#ifdef _NV_DPC
    //CHECK_FREE_COUNT(pNVPChannel,6*4);
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 7*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    }           
    pVPEContext->nFreeCount = nFreeCount - (7*4);
#endif

    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    // program the VP to grab in the next surface
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeIn  = (pSurface->dwWidth) | (pSurface->dwHeight << 16);
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeOut = (pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16);

    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = pSurface->dwStartLine;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].offset  = pSurface->dwOffset + dwInterleaveOffset;

    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].format =
            (dwSurfPitch & 0xFFFF)  |
            ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
            ((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000);

#endif // NVP_NV3
}

/*
==============================================================================
    
    NVP3ProgVBIField

    Description:    programs the vp to capture the specified VBI field.
                    PIO channel version.

    Date:           Feb 19, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVP3ProgVBIField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pNVPChannel;
    int nFreeCount;
    NVOS09_PARAMETERS ntfParam;
    NvNotification *avpNotifiers;

    pSurface->dwFieldType = (ULONG)nFieldId;

    // get a pointer to the appropriate VPE context
    pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;    // get a copy of the pio channel pointer

#ifdef _NV_DPC
    //CHECK_FREE_COUNT(pNVPChannel,5*4);
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 5*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    }
    pVPEContext->nFreeCount = nFreeCount - (5*4);
#endif
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].size  = (pSurface->dwStartLine) | (pSurface->dwHeight << 16);
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].offset  = pSurface->dwOffset;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].format =
            (pSurface->dwPitch & 0xFFFF)  |
            ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
            ((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);

#endif // NVP_NV3
}

/*
==============================================================================
    
    NVPProgVideoField

    Description:    programs the vp to capture the specified video field

    Date:           Apr 19, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVPProgVideoField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId,
    U032 dwSurfPitch,
    U032 dwInterleaveOffset,
    BOOL bGrab)
{
    Nv4ControlDma *pDmaChannel;
    NvNotification *avpNotifiers;
    U032 dwFormat;
    U032 nvDmaCount;

    DBGPRINT(DBGTRACE, "NVPProgVideoField");

    //NVPFlushChannel(pVPEContext);
    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
    {
        NVP3ProgVideoField(pVPEContext, pSurface, nFieldId, dwSurfPitch, dwInterleaveOffset, bGrab);
        return;
    }

#ifdef _NVP_DTRACE
    DTRACE(0xdead0000);
    DTRACE_CYCLE_DELTA();
    DTRACE(g_nIntCounter);
    DTRACE(nFieldId);
    g_nIntCounter++;
#endif

    // update type of field we're capturing
    pSurface->dwFieldType = (ULONG)nFieldId;

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(12);

    // reset notifier
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

#ifdef _NVP_TEST_NEXT_FIELD
    if (nFieldId != g_nNextFieldId)
        _asm int 3
    g_nNextFieldId = nFieldId ^ 1;
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    dwFormat = avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status;
    dwFormat = avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(g_nNextFieldId)].status;
#endif

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_IN(nFieldId), ((pSurface->dwWidth) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_OUT(nFieldId), ((pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_START_LINE, pSurface->dwStartLine);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_OFFSET(nFieldId), (pSurface->dwOffset + dwInterleaveOffset));
    dwFormat = ((dwSurfPitch & 0xFFFF) |
                ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
                ((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000));

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;


}

/*
==============================================================================
    
    NVPProgVBIField

    Description:    programs the vp to capture the specified VBI field

    Date:           Apr 22, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVPProgVBIField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId)
{
    Nv4ControlDma *pDmaChannel;
    NvNotification *avpNotifiers;
    U032 dwFormat;
    U032 nvDmaCount;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
    {
        NVP3ProgVBIField(pVPEContext, pSurface, nFieldId);
        return;
    }

    // update type of field we're capturing
    pSurface->dwFieldType = (ULONG)nFieldId;

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(8);

    // reset notifier
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_SIZE(nFieldId), ((pSurface->dwStartLine) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_OFFSET(nFieldId), pSurface->dwOffset);
    dwFormat = (pSurface->dwPitch & 0xFFFF)  |
            ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
            ((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;
}


/*
==============================================================================
    
    NVPProcessState

    Description:    programs the video port grab in a surface and determines
                    which surface is next.

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPProcessState(
    PHW_DEVICE_EXTENSION pHwDevExt,
    int nIndex,
    BOOL bVBIField)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface;
    int nFieldId = nIndex & 1;
    BOOL bIRQCallback;

    DBGPRINT(DBGTRACE, "NVPProcessState()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // setting nIndex to greater than 1 (nField | any_value) means that the caller is NVPStart or NVPUpdate
    // so first time initialize the dwOverlayIndex to match up with the nFieldId (notifier)
    if ((pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF) && (nIndex <= 1))
       pVPEContext->nvpOverlay.dwOverlayBufferIndex = nFieldId;

    // calling IRQCallback must be done only at the end of video field or at end of vbi when
    // capturing vbi only
    bIRQCallback = (!bVBIField) || (pVPEContext->nNumVidSurf == 0);
    // any transfer request of already captured vbi/video data ?!
//  if (bIRQCallback)
//      NVPCheckForLaunch(pVPEContext, NULL);


    if (pVPEContext->dwVPState != NVP_STATE_STOPPED)
    {
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
        {
            // program VBI here. This way VBI is synchronized with the video thus we eliminate the need
            // for a seperate VBI notifications routine unless we're streaming VBI only
            if (!bVBIField)
            {
                if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
                {
                    pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
                    // program the VP to grab in the next surface
                    NVPProgVBIField(pVPEContext, pSurface, nFieldId);

                    // next surface in the chain !
                    pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
                    pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
                }

                if (pVPEContext->dwVPConFlags & DDVPCONNECT_INTERLACED)
                {
                    if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
                    {
                        if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
                        {
                            // Bob from interleaved surfaces (skip even/odd included here too)
                            DoBobFromInterleaved(pVPEContext, nFieldId);
                        }
                        else
                        {
                            // Weave
                            DoWeave(pVPEContext, nFieldId);
                        }
                    }
                    else
                    {
#ifdef FORCE_INTERLEAVE_MEM
                        // Bob from interleaved surfaces (skip even/odd included here too)
                        DoBobFromInterleaved(pVPEContext, nFieldId);
#else
                        // Bob from non-interleaved (separate) surfaces (skip even/odd included here too)
                        DoBob(pVPEContext, nFieldId);
#endif
                    }
                }
                else
                {
                    // Progressive
                    DoProgressive(pVPEContext, nFieldId);
                }
            }
        }
        else if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
        {
            pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
            // program the VP to grab in the next surface
            NVPProgVBIField(pVPEContext, pSurface, nFieldId);

            // next surface in the chain !
            pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
            pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
        }
    }

    //
    // calling IRQCallback must be done only at the end of video field or at end of vbi when
    // capturing vbi only
    if (bIRQCallback && (pHwDevExt->dwIRQSources & DDIRQ_VPORT0_VSYNC))
    {
        kmvtNVPCallbackDxApi((PVOID)pHwDevExt, DDIRQ_VPORT0_VSYNC);
#if 0
        // can we pass on the interrupt !
        if ((pHwDevExt->IRQCallback) && (pHwDevExt->dwIRQSources & DDIRQ_VPORT0_VSYNC))
        {
            PDX_IRQDATA pIRQData;
            pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
            pIRQData->dwIrqFlags |= DDIRQ_VPORT0_VSYNC;
            ((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
        }
#endif
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPEProcessCommand

    Description:    dispatches commands sent via IOCTL to the appropriate
                    NVP function

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
#pragma warning(disable: 4296)

VP_STATUS NVPEProcessCommand(
    PVOID pHwDeviceExtension,
    PVIDEO_REQUEST_PACKET pRequestPacket)
{
    U032 status = 0;
    NVP_CMD_OBJECT *pnvCmdObj, *pnvCmdObjOut;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    DBGPRINT(DBGTRACE, "NVPEProcessCommand()");

    pnvCmdObj = (NVP_CMD_OBJECT *)(pRequestPacket->InputBuffer);
    pnvCmdObjOut = (NVP_CMD_OBJECT *)(pRequestPacket->OutputBuffer);
    // some arguments validation
    if ((pnvCmdObj->dwPortId < 0) || (pnvCmdObj->dwPortId >= NVP_MAX_VPORTS))
        return ERROR_INVALID_PARAMETER;

    // dispatch call
    switch (pnvCmdObj->dwSrvId)
    {
        case NVP_SRV_INITIALIZE:
            status = NVPInitialize(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_UNINITIALIZE:
            status = NVPUninitialize(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_START_VIDEO:
            status = NVPStart(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_STOP_VIDEO:
            status = NVPStop(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_UPDATE_VIDEO:
            status = NVPUpdate(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_REG_SURFACE:
            status = NVPRegSurface(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_UPDATE_OVERLAY:
            status = NVPUpdateOverlay(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_FLIP_VIDEOPORT:
            status = NVPFlipVideoPort(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_IS_VPE_ENABLED:
            status = NVPIsVPEEnabled(pHwDevExt, pnvCmdObj, pnvCmdObjOut);
#ifdef _WIN32_WINNT
                  pRequestPacket->StatusBlock->Information = sizeof(NVP_CMD_OBJECT);
#endif
            break;
#ifdef VPEFSMIRROR    
        case NVP_SRV_ENABLE_FSMIRROR:
            status = NVPFsMirrorEnable(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_REG_FSMIRROR_SURFACE:
            status = NVPFsRegSurface(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_DISABLE_FSMIRROR:
            status = NVPFsMirrorDisable(pHwDevExt, pnvCmdObj);
            break;
#endif
        default:
            DBGPRINT(DBGERROR, "invalid VPE command !");
            return ERROR_INVALID_PARAMETER;
    }

    return status;
}

#pragma warning(default: 4296)

#ifdef _WIN32_WINNT // {

/*
==============================================================================
    
    VideoField0Notify

    Description:    callback function. Called after a video buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VideoField0Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 0, FALSE);
}

/*
==============================================================================
    
    VideoField1Notify

    Description:    callback function. Called after a vbi buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VideoField1Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 1, FALSE);
}


/*
==============================================================================
    
    VBIField0Notify

    Description:    callback function. Called after a vbi buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VBIField0Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 0, TRUE);
}

/*
==============================================================================
    
    VBIField1Notify

    Description:    callback function. Called after a vbi buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VBIField1Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 1, TRUE);
}

#endif // _WIN32_WINNT }

/*
==============================================================================
    
    NVPScheduleOverlayFlip

    Description:    program overlay object to flip surface

    Date:           Feb 25, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPScheduleOverlayFlip(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int  nImageId,
    U032 dwSrcPitch,
    U032 dwMoveDownOffset)
{
    U032 dwFlags = 0;

    DBGPRINT(DBGTRACE, "NVPScheduleOverlayFlip");

#ifdef VPEFSMIRROR
    	// [XW:10/15/2000] Added so we don't skip the FSMirror for FourCC blits of VPE Port
	    
    if ( (!g_bFlip) && (!pVPEContext->dwFsMirrorOn) )
        return NO_ERROR;

#endif

    if (!g_bFlip)
        return NO_ERROR;

    DBGPRINT(DBGTRACE, "NVPScheduleOverlayFlip()");

    dwFlags = VPP_PRESCALE;

#ifndef FORCE_INTERLEAVE_MEM
    if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
       dwFlags |= VPP_INTERLEAVED;
    else
       dwFlags |= VPP_BOB;
#else
	dwFlags |= VPP_INTERLEAVED;
	if (!(pVPEContext->dwVPFlags & DDVP_INTERLEAVE)){
		dwFlags |= VPP_BOB;
	}
#endif
    if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
       dwFlags |= VPP_BOB;

    if (nImageId == NVP_FIELD_ODD)
       dwFlags |= VPP_ODD;
    else if (nImageId == NVP_FIELD_EVEN)
       dwFlags |= VPP_EVEN;

    NVPPrescaleAndFlip(
        pVPEContext,
        &(pVPEContext->nvpOverlay),
        pSurface->dwOffset,
        pSurface->dwPitch, // source pitch
        nImageId,
        dwFlags);          // VPP flags

    return NO_ERROR;
}


/*
==============================================================================
    
    DoProgressive

    Description:    displays progressive video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoProgressive(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch;
    int nImage = nFieldId;

    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
        // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        nTargetSurfId = pSurface->nNextSurfaceIdx;

    dwSrcPitch = pSurface->dwPitch;

    // Overlay Image n from CS
    NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage, dwSrcPitch, 0);

    pVPEContext->nVidSurfIdx = nTargetSurfId;

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    DoWeave

    Description:    use weave method to display video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoWeave(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch, dwOffset = 0;
    int nImage = nFieldId;

    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
    // if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        nTargetSurfId = pSurface->nNextSurfaceIdx;
    // double pitch (interleaved data)
    dwSrcPitch = 2*(pSurface->dwPitch);

    if (nFieldId == NVP_FIELD_ODD)
    {
        // Invert Polarity ?!
        if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
        {
            // change vp grab offset one line down
            dwOffset = pSurface->dwPitch;
            // Shift Down Image destination by 1 line !
            /////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
            //dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
        }
    }
    else
    {
        // not Invert Polarity ?!
        if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
        {
            // offset vp grab one line down
            dwOffset = pSurface->dwPitch;

            // Shift Down Image destination by 1 line !
            /////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
            //dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
        }
    }

    // whole frame captured ?!
    if (pSurface->bIsFirstFieldCaptured)
    {
        // Overlay Image n from CS
        NVPScheduleOverlayFlip(pVPEContext, pSurface, NVP_UNDEF, pSurface->dwPitch, 0);
        // NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);

        pSurface->bIsFirstFieldCaptured = FALSE;    // reset flag (for the next time)

        // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
        if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
            pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
    }
    else
        pSurface->bIsFirstFieldCaptured = TRUE; // set flag (for the next time)

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    DoBobFromInterleaved

    Description:    use bob from interleaved input to display video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoBobFromInterleaved(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch, dwOffset = 0;
    int nImage = nFieldId;

    DBGPRINT(DBGTRACE, "DoBobFromInterleaved");

    // Current Surface (CS)
    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
    // NewPitch = OldPitch
    dwSrcPitch = pSurface->dwPitch; // interleaved
    // if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        nTargetSurfId = pSurface->nNextSurfaceIdx;

#if 0
    if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
    {
        if (nFieldId == NVP_FIELD_EVEN)
        {
            // VP minimum programming to issue an interrupt at end of field !
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
            return NO_ERROR;
        }
    }
    else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
    {
        if (nFieldId == NVP_FIELD_ODD)
        {
            // VP minimum programming to issue an interrupt at end of field !
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
            return NO_ERROR;
        }
    }
    else
#endif
    {
        // double pitch (interleaved data)
        dwSrcPitch = 2*dwSrcPitch;
        if (nFieldId == NVP_FIELD_ODD)
        {
            // Invert Polarity ?!
            if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                // change vp grab offset one line down
                dwOffset = pSurface->dwPitch;
            }
        }
        else
        {
            // Invert Polarity ?!
            // for the even field (bottom) shift down overlay destination if invert polarity flag is not set !
            if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
            {
                dwOffset = pSurface->dwPitch;

            }
        }

    }

    if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
        !((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
    {
        // Overlay Image n from CS
        NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset);
        // NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);
    }

    // whole frame captured ?!
    if (pSurface->bIsFirstFieldCaptured)
    {
        pSurface->bIsFirstFieldCaptured = FALSE;    // reset (for the next time)
        // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
        if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
            pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
    }
    else
        pSurface->bIsFirstFieldCaptured = TRUE; // for the next time

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    DoBob

    Description:    use bob from non-interleaved input to display video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoBob(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch;
    int nImage = nFieldId;

    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
    dwSrcPitch = pSurface->dwPitch;
#if 0
    if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
    {
        if (nFieldId == NVP_FIELD_EVEN)
        {
            // VP minimum programming to issue an interrupt at end of field !
            // TS = next2(CS)
            nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
            pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
            return NO_ERROR;
        }
        else
            // TS = next(CS)
            nTargetSurfId = pSurface->nNextSurfaceIdx;
    }
    else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
    {
        if (nFieldId == NVP_FIELD_ODD)
        {
            // VP minimum programming to issue an interrupt at end of field !
            nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
            pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
            return NO_ERROR;
        }
        else
            // TS = next(CS)
            nTargetSurfId = pSurface->nNextSurfaceIdx;
    }
    else
#endif
    {
        // if autoflip, TS = next2(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
        if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
            nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
    }

    if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
        !((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
    {
        // Overlay Image n from CS
        NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage, dwSrcPitch, 0);
    }

    // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPTransfer

    Description:    transfers content of video or vbi field to specified
                    buffer (usually system memory buffer)

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPTransfer(
    PVOID pContext,
    PNVP_DDTRANSFERININFO  pInInfo,
    PNVP_DDTRANSFEROUTINFO pOutInfo)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;

    DBGPRINT(DBGTRACE, "NVPTransfer()");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    if (pInInfo->dwTransferFlags & DDTRANSFER_NONLOCALVIDMEM)
        return DXERR_UNSUPPORTED;
    
    // we DO handle cancels for transfer buffers not "in progress" !
    if (pInInfo->dwTransferFlags & DDTRANSFER_CANCEL){
		pVPEContext->ulCap=FALSE;
        return NVPCancelTransfer(pVPEContext, pInInfo);
	}

    // determine polarity, TRUE for Even, FALSE for Odd !
    NVPGetSurface(pVPEContext, (U032)(((DDSURFACEDATA*) (pInInfo->lpSurfaceData))->fpLockPtr), &pSurface);
      if (pSurface == NULL)
        return DXERR_GENERIC;
    if (pSurface->dwFieldType == NVP_FIELD_ODD)
        pOutInfo->dwBufferPolarity = FALSE;
    else
        pOutInfo->dwBufferPolarity = TRUE;
    
    // queue request
    if (NVPAddTransfer(pVPEContext, pInInfo, !(pOutInfo->dwBufferPolarity)))
        return DXERR_GENERIC;
#if 0
    if (pVPEContext->nCurTransferIdx != -1)
    {
        pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
        // Recreate context dma for MDL
        NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
    }
#endif

      // launch a transfer here
    NVPCheckForLaunch(pVPEContext, pSurface);

    return DX_OK;
}

/*
==============================================================================
    
    NVPGetSurface

    Description:    looks for surface that has the specified pointer. pSurface
                    is set to NULL if no surface is found.


    Date:           Mar 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
BOOL NVPGetSurface(
    PNVP_CONTEXT pVPEContext,
    U032 dwSurfPtr,
    PNVP_SURFACE_INFO *pSurface)
{
    int i;

    DBGPRINT(DBGTRACE, "NVPGetSurface()");

    *pSurface = NULL;

    // why VBI first ! well, this is most probably what we're transfering... kinda optimization !
    for (i = 0; i < pVPEContext->nNumVBISurf; i++)
    {
        if (pVPEContext->aVBISurfaceInfo[i].pVidMem == dwSurfPtr)
        {
            *pSurface = &(pVPEContext->aVBISurfaceInfo[i]);
            return FALSE;   // FALSE means VBI
        }
    }

    for (i = 0; i < pVPEContext->nNumVidSurf; i++)
    {
        if (pVPEContext->aVideoSurfaceInfo[i].pVidMem == dwSurfPtr)
        {
            *pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
            return TRUE;    // TRUE means VIDEO
        }
    }

    return FALSE;   // return something ! (pSurface is NULL anyway)
}

/*
==============================================================================
    
    NVP3RecreateContext

    Description:    if necessary, create context DMA for mem to mem object
                    PIO channel version.

    Date:           Mar 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVP3RecreateContext(
    PNVP_CONTEXT pVPEContext,
    PMDL pDestMDL)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pChan;
    NVOS09_PARAMETERS ntfParam;
    U032 dwStart;
    U032 dwLimit;
    int nFreeCount;

    pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);

    // first check to see if we can reuse the OLD context... since context creation is expensive.
    dwStart = (U032)(pDestMDL->lpMappedSystemVa);
    dwLimit = (pDestMDL->ByteCount) - 1;
    
    if (pVPEContext->bxfContextCreated)
    {
        // do not recreate if same context
        if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
            return DX_OK;
    }

#ifdef _NV_DPC
    // FIFO free count check up
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 4*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pChan, 5);
    }
    pVPEContext->nFreeCount = nFreeCount - (4*4);
#endif

    // free the old context first
    if (pVPEContext->bxfContextCreated)
    {
        pChan->subchannel[5].SetObject = NVP_M2M_OBJECT;
        pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#ifdef _NV_DPC
        // Do a software method flush here
        ntfParam.hObjectParent = pVPEContext->dwDeviceId;
        nFreeCount = pVPEContext->nFreeCount;
        while (nFreeCount < NV06A_FIFO_GUARANTEED_SIZE)
        {
            //RmInterrupt(&ntfParam);
            nFreeCount = NvGetFreeCount(pChan, 5);
        }
        pVPEContext->nFreeCount = nFreeCount - NV06A_FIFO_GUARANTEED_SIZE;
#endif
        RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

        pVPEContext->bxfContextCreated = FALSE;
    }
    
    // setup Notify Context
    if (RmAllocContextDma(
                    pVPEContext->hClient,
                    NVP_M2M_CONTEXT,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    dwStart,
                    dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "cannot allocate mem 2 mem context");
        return DXERR_GENERIC;
    }

    // set context of M2M object
    pChan->subchannel[5].SetObject  = NVP_M2M_OBJECT;
    pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = NVP_M2M_CONTEXT;

    pVPEContext->dwTransferCtxStart = dwStart;
    pVPEContext->dwTransferCtxSize = dwLimit;
    pVPEContext->bxfContextCreated = TRUE;

#endif // NVP_NV3

    return DX_OK;
}

/*
==============================================================================
    
    NVP3CheckForLaunch

    Description:    try to launch another mem transfer if engine not busy
                    (PIO version)

    Date:           Mar 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVP3CheckForLaunch(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pChan;
    PNVP_TRANSFER_BUFFER pTransfer;
    LPDDSURFACEDATA pSurfaceData;
    NVOS09_PARAMETERS ntfParam;
    NvNotification *aM2MNotifiers;
    PMDL pDestMDL;
    U032 dwOffsetStartByte;
    LONG lLength, lPitch, lCount;
    int nFreeCount;
    PNVP_SURFACE_INFO pSurf = NULL;

    DBGPRINT(DBGTRACE, "NVP3CheckForLaunch()");

    aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

    // is transfer in progress ?
    if ((aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS) ||
        // or no transfer request !?
        (pVPEContext->nCurTransferIdx == -1))
        return DXERR_GENERIC;

    // get a pointer to the VP pio channel
    pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);
    // which surface are we transferring from ?
    pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
    pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
    if (pSurface == NULL)
    {
        NVPGetSurface(pVPEContext, pSurfaceData->fpLockPtr, &pSurf);
        if (pSurf == NULL)
        {
            DBGPRINT(DBGERROR, "NVPCheckForLaunch() can't get pointer to surface");
            return DXERR_GENERIC;
        }
    }
    else
        pSurf = pSurface;

    // Recreate context dma for MDL
    NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
    
    // reset notifier status
    aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

#ifdef _NV_DPC
    //CHECKFREECOUNT(pMyNvChan,9*4);
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 9*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pChan, 5);
    }
    pVPEContext->nFreeCount = nFreeCount - (9*4);
#endif

    // start at given line
    dwOffsetStartByte = pSurf->dwOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

    // lLength and lPitch might not be the same (case of interleaved fields !!!)
    lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
    lLength = (pSurface->dwPreScaleSizeX)*(pSurfaceData->dwFormatBitCount >> 3);
    lPitch = pSurfaceData->lPitch;
            
    // SMAC@microsoft.com  :  Yes, you should transfer the end line.
    // Therefore, if we only wanted you to transfer a single line, start line would equal end line. 
    lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);

    if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
    {
        // if we want to invert things, then we should
        // negate the pitch and put the start offset at the end.
        
        dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
        lPitch = -lPitch;
    }

    pDestMDL = (PMDL)(pTransfer->pDestMDL);
    if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
    {
        DBGPRINT(DBGERROR, "NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count");
    //  lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
        lCount = pDestMDL->ByteCount / lLength;
    }

#ifdef _NV_DPC
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 8*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pChan, 5);
    }
    pVPEContext->nFreeCount = nFreeCount - (8*4);
#endif

    // set mem to mem transfer object !
    pChan->subchannel[NVP_M2M_SUBCHANNEL].SetObject = NVP_M2M_OBJECT;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetIn = dwOffsetStartByte;
    //pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = 0;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchIn  = lPitch;   // use the pitch in so that we can do interleaved
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchOut = lLength;  // use line length on pitch out so that it squishes together
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineLengthIn = lLength;
    
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineCount    = lCount;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.Format       =  ( 1 | (1 << 8));
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.BufferNotify = NV039_NOTIFY_WRITE_THEN_AWAKEN_1;

    pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;

#endif // NVP_NV3

    return DX_OK;
}

/*
==============================================================================
    
    NVPRecreateContext

    Description:    if necessary, create context DMA for mem to mem object
                    (DMA version)

    Date:           Apr 22, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPRecreateContext(
    PNVP_CONTEXT pVPEContext,
    PMDL pDestMDL)
{
    U032 dwStart;
    U032 dwLimit;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3RecreateContext(pVPEContext, pDestMDL);

    // first check to see if we can reuse the OLD context... since context creation is expensive.
    dwStart = (U032)(pDestMDL->lpMappedSystemVa);
    dwLimit = (pDestMDL->ByteCount) - 1;
    
    if (pVPEContext->bxfContextCreated)
    {
        // do not recreate if same context
        if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
            return DX_OK;
    }

    // free the old context first
    if (pVPEContext->bxfContextCreated)
    {
        // free m2m dma context
        rmNVPFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

        pVPEContext->bxfContextCreated = FALSE;
    }
    
    // setup Notify Context
    if (rmNVPAllocContextDma(
                    pVPEContext->hClient,
                    NVP_M2M_CONTEXT,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    dwStart,
                    dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate mem 2 mem context");
        return DXERR_GENERIC;
    }

    pVPEContext->dwTransferCtxStart = dwStart;
    pVPEContext->dwTransferCtxSize = dwLimit;
    pVPEContext->bxfContextFlushed = FALSE;
    pVPEContext->bxfContextCreated = TRUE;

    return DX_OK;
}

/*
==============================================================================
    
    NVPCheckForLaunch

    Description:    try to launch another mem transfer if engine not busy
                    (DMA version)

    Date:           Apr 22, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCheckForLaunch(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface)
{
    PNVP_TRANSFER_BUFFER pTransfer;
    LPDDSURFACEDATA pSurfaceData;
    NvNotification *aM2MNotifiers;
    PMDL pDestMDL;
    U032 dwOffsetStartByte;
    LONG lLength, lPitch, lCount;
    PNVP_SURFACE_INFO pSurf = NULL;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount, bVBICapture;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3CheckForLaunch(pVPEContext, pSurface);

    DBGPRINT(DBGTRACE, "NVPCheckForLaunch()");

    aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

    // is transfer in progress ?
    if (aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
        return DXERR_GENERIC;

    // or no transfer request !?
    if (pVPEContext->nCurTransferIdx == -1) //|| !(pVPEContext->bxfContextCreated))
    {
        return DXERR_GENERIC;
    }

	//make sure surf hasn't been DMAed
	if(pTransfer->dwTransferStatus == NVP_TRANSFER_QUEUED){
		//DBGPRINTVALUE(DBGINFO, "Checkforlaunch- xfering=", pTransfer->dwTransferId);
		DBGPRINT(DBGINFO, "Checkforlaunch- xfering=");
	}else{
		//DBGPRINTVALUE(DBGINFO, "Checkforlaunch- surf is already xferred=", pTransfer->dwTransferId);
		DBGPRINT(DBGINFO, "Checkforlaunch- surf is already xferred=");
		return DXERR_GENERIC;
	}

    // which surface are we transferring from ?
    //pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
    pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
    if (pSurface == NULL)
    {
        NVPGetSurface(pVPEContext, pSurfaceData->fpLockPtr, &pSurf);
        if (pSurf == NULL)
        {
            DBGPRINT(DBGERROR, "NVPCheckForLaunch() can't get pointer to surface");
            return DXERR_GENERIC;
        }
    }
    else
        pSurf = pSurface;

    // reset notifier status
    aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

    // is it a raw8 (vbi) capture ?
    bVBICapture = (pSurfaceData->dwFormatFourCC == mmioFOURCC('R','A','W','8'));

    // start at given line
    dwOffsetStartByte = pSurf->dwOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

    // lLength and lPitch might not be the same (case of interleaved fields !!!)
    //////// NOTE: this should really be pSurfaceData->dwWidth instead of pSurf->dwPreScaleSizeX but the client
    ///            doesn't know we are prescaling... because of a bug in DShow OverlayMixer, we are using the 
    ///            MediaEngine prescaler behind the back of DirectShow/DxApi... a correction to the surface
    ///            width is needed here !
    //lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
    lLength = (bVBICapture) ? pSurfaceData->dwWidth : pSurf->dwPreScaleSizeX;
    lLength *= (pSurfaceData->dwFormatBitCount >> 3); // convert to bytes !
    lPitch = pSurfaceData->lPitch;
            
    // SMAC@microsoft.com  :  Yes, you should transfer the end line.
    // Therefore, if we only wanted you to transfer a single line, start line would equal end line. 
    lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);

    /// H.AZAR: 05/02/2000    
    /// NOTE: the following if-statement is a hack since DirectShow is unable of specifying single field capture, 
    ///       so we try to double the pitch to skip the bottom field and always return the top field...
    ///       An alternative to this hack would be for the client app to always capture full frame size (two fields)
    ///       and extract the field it needs...
    ///       PROS of using this hack:
    ///           - transfer only one field so no extra memory/bandwidth required for transfering a full frame
    ///           - no feathering effect or prescaling effect since only transfering the top field
    ///       CONS:
    ///           - it is a hack !
    ///           - if DShow get fixed one day, we will have to put extra logic to deal with old code !
    ///           - always return top field
    ///
/*
    //currently any height < 288 is single field
    //if it's single field, double the pitch (skipping bottom field)
    if (!bVBICapture && (lCount <= 288))
    {
        lPitch *= 2;
    }
*/
    //when capturing, src height is (pVPEContext->nvpOverlay).dwDecoderHeight
	//if capture height <= src height, it is single field capture
	if (!bVBICapture && (lCount <= (LONG)(pVPEContext->dwDecoderHeight)))
    {
        lPitch *= 2;
    }

    ////
    ////


    if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
    {
        // if we want to invert things, then we should
        // negate the pitch and put the start offset at the end.
        
        dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
        lPitch = -lPitch;
    }

    pDestMDL = (PMDL)(pTransfer->pDestMDL);

	//recreating a context dma for every captured frame causes weird behavior with ddraw.
	//changed to xfering to a fix surf in sys mem and do a sys 2 sys xfer in nvpchecktransferstatus
/*
    // if necessary, recreate context for new transfer buffer
    if (NVPRecreateContext(pVPEContext, pDestMDL) != DX_OK)
    {
        DBGPRINT(DBGERROR, "NVPCheckForLaunch() - error, can't create context dma for new transfer buffer !");
        return DXERR_GENERIC;
    }
*/


    if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
    {
        DBGPRINT(DBGERROR, "NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count");
    //  lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
        lCount = pDestMDL->ByteCount / lLength;
    }

    // get a pointer to the VPE dma channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(20);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_OUT, NVP_M2M_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_IN, dwOffsetStartByte);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_OUT, 0);    //(unsigned long)pTransfer->DestMDL->ByteOffset
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_IN, lPitch);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_OUT, lLength);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_LENGTH_IN, lLength);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_COUNT, lCount);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_FORMAT, ( 1 | (1 << 8)));
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_BUFFER_NOTIFY, NV039_NOTIFY_WRITE_THEN_AWAKEN_1);

    pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;
    // go !
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return DX_OK;
}


/*
==============================================================================
    
    NVPGetTransferStatus

    Description:    returns status of buffer transfer (from video mem to
                    system mem)

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPGetTransferStatus(
    PVOID pContext,
    PVOID pNotUsed,
    PNVP_DDGETTRANSFEROUTINFO pOutInfo)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
    PNVP_TRANSFER_BUFFER pTransfer;
    PNVP_CONTEXT pVPEContext;

    DBGPRINT(DBGTRACE, "NVPGetTransferStatus()");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    if (pVPEContext->nRecentTransferIdx == NVP_EOQ)
        return DXERR_GENERIC;

    pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nRecentTransferIdx]);

    if (pTransfer->dwTransferStatus == NVP_TRANSFER_DONE)
    {
        // return MS transfer ID
        pOutInfo->dwTransferID = pTransfer->dwTransferId;
        NVPRemoveTransfer(pVPEContext, pVPEContext->nRecentTransferIdx);

    }
    else
        return DXERR_GENERIC;

    return DX_OK;
}

/*
==============================================================================
    
    NVPAddTransfer

    Description:    adds transfer buffer to queue

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPAddTransfer(
    PNVP_CONTEXT pVPEContext,
    PNVP_DDTRANSFERININFO pInInfo,
    BOOL bIsOddField)
{
    PNVP_TRANSFER_BUFFER pNewTransfer;
    int i = pVPEContext->nCurTransferIdx;

    DBGPRINT(DBGTRACE, "NVPAddTransfer()");

    if (pVPEContext->nNumTransfer >= NVP_MAX_TRANSFER_BUFFERS)
        return DXERR_GENERIC;
    
    while (i != NVP_EOQ)
    {
        if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
            // a transfer request with same ID is already queued !!!
            return DXERR_GENERIC;
        else
            i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
    }

        
    // queue new transfer request !
    i = pVPEContext->nLastTransferIdx;
    pVPEContext->nLastTransferIdx = ++(pVPEContext->nLastTransferIdx) % NVP_MAX_TRANSFER_BUFFERS;
    pNewTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nLastTransferIdx]);
    if (i != NVP_EOQ)
        pVPEContext->aTransferBuffers[i].nNextTransferIdx = pVPEContext->nLastTransferIdx;
    pNewTransfer->nNextTransferIdx = NVP_EOQ;
    pNewTransfer->nPrevTransferIdx = i;
    (pVPEContext->nNumTransfer)++;
	if(pVPEContext->nNumTransfer){
		pVPEContext->ulCap=TRUE;
	}
    if (pVPEContext->nCurTransferIdx == NVP_EOQ)
        pVPEContext->nCurTransferIdx = pVPEContext->nLastTransferIdx;

    // DDTRANSFER_HALFLINES indicates that, due to half line issues, the odd field contains an
    // extra line of useless data at the top that the driver must account for
    if ((pInInfo->dwTransferFlags & DDTRANSFER_HALFLINES) && (bIsOddField))
    {
        pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine) + 1;
        pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine) + 1;
    }
    else
    {
        pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine);
        pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine);
    }

    // copy input data...
    pNewTransfer->pSurfaceData = (ULONG) (pInInfo->lpSurfaceData);
    pNewTransfer->dwTransferId = pInInfo->dwTransferID;
    pNewTransfer->dwTransferFlags = pInInfo->dwTransferFlags;
    pNewTransfer->pDestMDL = (ULONG) (pInInfo->lpDestMDL);
    pNewTransfer->dwTransferStatus = NVP_TRANSFER_QUEUED;

    return DX_OK;
}


/*
==============================================================================
    
    NVPCancelTransfer

    Description:    cancels transfer request before it gets processed

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCancelTransfer(
    PNVP_CONTEXT pVPEContext,
    PNVP_DDTRANSFERININFO pInInfo)
{
    PNVP_TRANSFER_BUFFER pTransfer = NULL;
    int i = pVPEContext->nCurTransferIdx;

    DBGPRINT(DBGTRACE, "NVPCancelTransfer()");

    // look for transfer in queue
    while (i != NVP_EOQ)
    {
        if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
        {
            pTransfer = &(pVPEContext->aTransferBuffers[i]);
            break;
        }
        i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
    }

    if ((pTransfer) && (pTransfer->dwTransferStatus == NVP_TRANSFER_QUEUED))
        return NVPRemoveTransfer(pVPEContext, i);
    else
        return DXERR_GENERIC;
}

/*
==============================================================================
    
    NVPRemoveTransfer

    Description:    removes transfer request from queue

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPRemoveTransfer(
    PNVP_CONTEXT pVPEContext,
    int nTransferIdx)
{
    PNVP_TRANSFER_BUFFER pTransfer = &(pVPEContext->aTransferBuffers[nTransferIdx]);

    DBGPRINT(DBGTRACE, "NVPRemoveTransfer()");

    // check limits
    if (nTransferIdx == pVPEContext->nCurTransferIdx)
        pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;
    else if (nTransferIdx == pVPEContext->nLastTransferIdx)
        pVPEContext->nLastTransferIdx = pTransfer->nPrevTransferIdx;
    // reset values
    pTransfer->dwTransferId = NVP_UNDEF;
    pTransfer->dwTransferStatus = NVP_TRANSFER_FREE;
    // re-map indices
    if (pTransfer->nPrevTransferIdx != NVP_EOQ)
    {
        pVPEContext->aTransferBuffers[pTransfer->nPrevTransferIdx].nNextTransferIdx = pTransfer->nNextTransferIdx;
        pTransfer->nPrevTransferIdx = NVP_EOQ;
    }
    if (pTransfer->nNextTransferIdx != NVP_EOQ)
    {
        pVPEContext->aTransferBuffers[pTransfer->nNextTransferIdx].nPrevTransferIdx = pTransfer->nPrevTransferIdx;
        pTransfer->nNextTransferIdx = NVP_EOQ;
    }

    // one down !
    (pVPEContext->nNumTransfer)--;

    return DX_OK;
}
    

/*
==============================================================================
    
    NVPCheckTransferStatus

    Description:    checks for transfer status. Calls MS callback.

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCheckTransferStatus(
    PHW_DEVICE_EXTENSION pHwDevExt)
{
    NvNotification *aM2MNotifiers;
    PNVP_CONTEXT pVPEContext;
    PNVP_TRANSFER_BUFFER pTransfer;
    U032 status;

    DBGPRINT(DBGTRACE, "nvpecore: NVPCheckTransferStatus()");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

    status = aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status;
    pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
/*
    if (status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
        // still in progress
        return FALSE;
    else if (status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS)
    {
        pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

        // finished ok!
        if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
            pTransfer->dwTransferStatus = NVP_TRANSFER_DONE;

        pVPEContext->nRecentTransferIdx = pVPEContext->nCurTransferIdx;
    }
*/
	if (	status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS ||
		status == NV039_NOTIFICATION_STATUS_IN_PROGRESS){	//notifier may already been reset 
		
		//logging 
		if(status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS){
			//DBGPRINTVALUE(DBGINFO, "ChkXferStatus - m2m status success", pTransfer->dwTransferId);
			DBGPRINT(DBGINFO, "ChkXferStatus - m2m status success");

		}else{
			//DBGPRINTVALUE(DBGINFO, "ChkXferStatus - m2m status in prog", pTransfer->dwTransferId);
			DBGPRINT(DBGINFO, "ChkXferStatus - m2m status in prog");
		}
		//pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		//do Sys 2 Sys copy now
		//intermittent page faults were generated when Dst surf is no longer valid.
		//use ulCap=false when DDTRANSFER_CANCEL is sent to cancel sys 2 sys xfer.
		if(pVPEContext->ulCap)		
		{
			DWORD *pSrc;
			DWORD *pDst;
			//DWORD *pdw;
			DWORD dwLimit=((((PMDL)(pTransfer->pDestMDL))->ByteCount) - 1);///3;
			DWORD i;

			if(dwLimit < BUFSIZE){
				pSrc=(DWORD *)pVPEContext->pSysBuf;
				pDst=(DWORD *)(((PMDL)(pTransfer->pDestMDL))->lpMappedSystemVa);
				for(i=0; i<dwLimit; i+=4){
					*pDst=*pSrc;
					++pDst;
					++pSrc;
				}
			}

		
		}else{
			DBGPRINT(DBGERROR, "NOT xfering\n");
		}
        // finished ok!
        if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
            pTransfer->dwTransferStatus = NVP_TRANSFER_DONE;

        pVPEContext->nRecentTransferIdx = pVPEContext->nCurTransferIdx;

	}else{
        
		DBG_PRINT_STRING_VALUE(DBGERROR, "NVPCheckTransferStatus() - memory transfer failed error ", status);

        //pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

        // finished with an error !
        if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
            pTransfer->dwTransferStatus = NVP_TRANSFER_FAILURE;

    }

    // move to next transfer in queue (*** not sure whether I should do this even when an error had occured ?!?!?!?)
    pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;
/*
    // we pass on the interrupt
#if 0
    if (pHwDevExt->IRQCallback) //&& (pHwDevExt->dwIRQSources & DDIRQ_BUSMASTER))
    {
          PDX_IRQDATA pIRQData;
        pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
        pIRQData->dwIrqFlags |= DDIRQ_BUSMASTER;
        ((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
    }
#else
      kmvtNVPCallbackDxApi((PVOID)pHwDevExt, DDIRQ_BUSMASTER);
#endif
*/
    return DX_OK;
}


/*
==============================================================================
    
    NVPCompleteTransfer

    Description:    checks for transfer status. Calls MS callback.

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCompleteTransfer(PVOID pHwDevExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) pHwDevExtension;
    PNVP_CONTEXT pVPEContext;

    // call MS callback if done with transfer
    if (NVPCheckTransferStatus(pHwDevExt) == DX_OK)
    {
        // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
        pVPEContext = &(pHwDevExt->avpContexts[0]);
        //  transfer next in queue !
        NVPCheckForLaunch(pVPEContext, NULL);

		// we pass on the interrupt
#if 0
		if (pHwDevExt->IRQCallback) //&& (pHwDevExt->dwIRQSources & DDIRQ_BUSMASTER))
		{
			PDX_IRQDATA pIRQData;
			pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
			pIRQData->dwIrqFlags |= DDIRQ_BUSMASTER;
			((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
		}
#else
		kmvtNVPCallbackDxApi((PVOID)pHwDevExt, DDIRQ_BUSMASTER);
#endif

        return DX_OK;
    }

    return DXERR_GENERIC;
}

#ifdef _WIN32_WINNT
/*
==============================================================================
    
    NVPTransferNotify

    Description:    callback routine for vbi/video transfer code.

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVPTransferNotify(
    PVOID pHwDevExtension)
{
    NVPCompleteTransfer(pHwDevExtension);
}
#endif


/*
==============================================================================
    
    NVPPreScale

    Description:    Prescales YUV422 surface.  The new width and height are
                    returned.  If this routine does the field prescaling, it
                    flips off the field flags to indicate that the flip
                    should not bob.

    Date:           Nov 04, 1999
    
    Author:         H. Azar (based on VPP code from Sandy Lum)

==============================================================================
*/
BOOL NVPPreScale(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwSrcOffset,
    DWORD         dwSrcPitch,
    DWORD         dwDstOffset,
    DWORD         dwDstPitch,
    DWORD         *pWidth,
    DWORD         *pHeight,
    DWORD         *pField)
{
    DWORD preScaleDeltaX;
    DWORD preScaleDeltaY;
    DWORD preScaleOverlay;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwOutSizeX, dwOutSizeY, dwOutFormat;
    DWORD dwInPitch, dwInOffset, dwInPoint, dwInSize;
    BOOL isField;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;

    if (pOverlayInfo->dwOverlayDstWidth == 0 ||
        pOverlayInfo->dwOverlayDstHeight == 0)
        return FALSE;

    isField = IS_FIELD(*pField);

    if (pOverlayInfo->dwOverlayDstWidth <= 1)
    {
        dwDeltaX = 0x100000;
    }
    else
    {
        dwDeltaX = (pOverlayInfo->dwOverlaySrcWidth - 1) << 16;
        dwDeltaX /= pOverlayInfo->dwOverlayDstWidth - 1;
        dwDeltaX <<= 4;
    }

    if (pOverlayInfo->dwOverlayDstHeight <= 1)
    {
        dwDeltaY = 0x100000;
    }
    else
    {
        dwDeltaY = (pOverlayInfo->dwOverlaySrcHeight - 1) << 16; //(*pHeight - 1) << 16; //
        // err on the side of caution, need to do this because of the 1/4 pixel offset
        // ????? why is NV4 different from NV5?  NV4 HW must be a little wonky
        if (pVPEContext->dwChipId <= NV_DEVICE_VERSION_4) {
            dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 2;
        } else {
            dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 1;
        }
        dwDeltaY <<= 4;
    }

    preScaleOverlay = 0;

    if (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale))
    {
        // use X prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = (pOverlayInfo->dwOverlayDstWidth + 2) & ~1;
        preScaleDeltaX = dwDeltaX;
        pOverlayInfo->dwOverlayDeltaX = 0x100000;
    } else {
        // use X overlay scaler
        dwOutSizeX = (*pWidth + 2) & ~1;
        preScaleDeltaX = 0x100000;
        pOverlayInfo->dwOverlayDeltaX = dwDeltaX;
    }

///// Until I get 'pOverlayInfo->regOverlayMode' logic implememted, always use Y prescaler... otherwise video will look aweful on NV4/5 in 'bob from non-interleaved' mode !
#ifndef NVP_CHECK_REGKEY
    // use Y prescaler
    preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
    dwOutSizeY = pOverlayInfo->dwOverlayDstHeight;
    preScaleDeltaY = dwDeltaY;
    pOverlayInfo->dwOverlayDeltaY = 0x100000;
#else
    if ((pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale)) ||
        (pOverlayInfo->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE))
    {
        // use Y prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = pOverlayInfo->dwOverlayDstHeight;
        preScaleDeltaY = dwDeltaY;
        pOverlayInfo->dwOverlayDeltaY = 0x100000;
    }
    else
    {
        // use Y overlay scaler
        dwOutSizeY = *pHeight;
        preScaleDeltaY = 0x100000;
        pOverlayInfo->dwOverlayDeltaY = dwDeltaY;
    }
#endif //#ifdef NVP_CHECK_REGKEY

    if ((pVPEContext->dwChipId < NV_DEVICE_VERSION_10) || (preScaleOverlay & NV_PRESCALE_OVERLAY_Y))
    {
        if (isField)
        {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            if (*pField & VPP_INTERLEAVED)
                preScaleDeltaY >>= 1;
        }
    }

    if (preScaleOverlay == 0)
        return FALSE;

    dwInSize = asmMergeCoords(*pWidth, *pHeight);
    dwInPoint = 0;
    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField && (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        if (*pField & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            *pHeight >>= 1;
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (*pField & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInPoint = 0xFFFC0000;
            } else {
                dwInPoint = 0x00040000;
            }
        }
    }

//    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
//    } else {
//        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
//    }

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(38);

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT , NVP_DVD_SUBPICTURE_OBJECT); // pVPEContext->dwDVDSubPicObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_POINT, 0);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_SIZE, (asmMergeCoords(dwOutSizeX, dwOutSizeY)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_FORMAT, ((dwOutFormat << 16) | dwDstPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_OFFSET, dwDstOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_FORMAT, ((dwOutFormat << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_POINT, dwInPoint);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_FORMAT, ((NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_POINT, 0);

    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NOTIFY, NV038_NOTIFY_WRITE_THEN_AWAKEN);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NO_OPERATION, 0);

    // this forces the H/W to serialize
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    // return changes in state
    if (//(pDriverData->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
        (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        // with HQVUp, we no longer use the overlay to bob
        *pField &= ~(VPP_ODD | VPP_EVEN | VPP_BOB | VPP_INTERLEAVED);
    }

    *pHeight = dwOutSizeY;
    *pWidth  = dwOutSizeX;

    return TRUE;
}

/*
==============================================================================
    
    NVPFlip

    Description:    Flip YUV422 surface.

    Date:           Nov 04, 1999
    
    Author:         H. Azar (based on VPP code from Sandy Lum)

==============================================================================
*/
BOOL NVPFlip(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset
    DWORD         dwPitch,         // source pitch
    DWORD         dwWidth,         // source width
    DWORD         dwHeight,        // source height
    DWORD         dwIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;
    DWORD dwPointIn, dwOverlayFormat, dwSizeIn;
    DWORD dwDeltaX, dwDeltaY;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;

    DBGPRINT(DBGTRACE, "NVPFlip");

    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;  // << 3 insteed of << 4 because YUYV is 2 bytes wide
    dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));
    dwSizeIn += dwPointIn;
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    // Remember this in case we get a SetOverlayPosition call
    //pOverlayInfo->dwOverlaySrcOffset = dwOffset;
    //pOverlayInfo->dwOverlaySrcPitch = dwPitch;

    dwDeltaX = pOverlayInfo->dwOverlayDeltaX;
    dwDeltaY = pOverlayInfo->dwOverlayDeltaY;

    if (IS_FIELD(dwFlags)) {
        if (dwFlags & VPP_INTERLEAVED) {
            // if (dwFlags & VPP_ODD) {
            if (dwFlags & VPP_EVEN) {
                dwOffset += dwPitch;
            }
            dwPitch <<= 1;
            dwHeight >>= 1;
            dwDeltaY >>= 1;
        }
        if (dwFlags & VPP_BOB) {
            // if (dwFlags & VPP_ODD) {
            if (dwFlags & VPP_EVEN) {
                dwPointIn += 0xFFFC0000;
            } else {
                dwPointIn += 0x00040000;
            }
        }
    }

    // replace old surface pitch value with current pitch value
    dwOverlayFormat = pOverlayInfo->dwOverlayFormat;
    dwOverlayFormat &= 0xFFFF0000;
    dwOverlayFormat |= dwPitch;
    dwOverlayFormat |= (1 << 31);

/*

    if (pVPEContext->dwVPConnectFlags & NVP_CONNECT_HDTV) // progressive (non-interlaced) and 16bit VIP
        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT709 << 24);
*/
    if (dwIndex & 0x1) {
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;
    } else {
        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
    }

    // program overlay to flip
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(20);

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_IN(dwIndex), dwSizeIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstWidth, pOverlayInfo->dwOverlayDstHeight)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_IN(dwIndex), dwPointIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstX, pOverlayInfo->dwOverlayDstY)));

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_OFFSET(dwIndex), dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_COLORKEY(dwIndex), pOverlayInfo->dwOverlayColorKey);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DU_DX(dwIndex), dwDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DV_DY(dwIndex), dwDeltaY);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_FORMAT(dwIndex), dwOverlayFormat);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddPrescaleAndFlip
//
//      VPE implementation of selected parts of DDRAW's VPP pipe.  Only
//      prescaling and flip are performed.
//

/*
==============================================================================
    
    NVPPrescaleAndFlip

    Description:    VPE implementation of selected parts of DDRAW's VPP pipe.
                    Only prescaling and flip are performed.

    Date:           Nov 04, 1999
    
    Author:         H. Azar (based on VPP code from Sandy Lum)

==============================================================================
*/

#define NEXT_SURFACE { \
            dwSrcOffset = dwDstOffset;  \
            dwSrcPitch = dwDstPitch;    \
            dwDstOffset = dwNextOffset; \
            dwDstPitch = dwNextPitch;   \
            dwNextOffset = dwSrcOffset; \
            dwNextPitch = dwSrcPitch;   \
            dwOpCount++;                \
        }

BOOL NVPPrescaleAndFlip(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset
    DWORD         dwPitch,         // source pitch
    DWORD         dwOvIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
    DWORD dwHeight, dwWidth, i = 0;
    DWORD dwSrcOffset, dwSrcPitch;
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwNextOffset, dwNextPitch;
    DWORD dwOpCount;
    DWORD dwWorkSurfaces;
    BOOL  doXPreScale, doYPreScale, doPreScale;
    BOOL  isDownScale;
    DWORD dwRoundX, dwRoundY;
    DWORD vppExec;
    BOOL  isField;
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;


    

#if 0 //#ifdef DEBUG
    char debugstr[256];

    debugstr[0] = '\0';
    if (dwFlags & VPP_ODD)          strcat(debugstr, "odd  ");
    if (dwFlags & VPP_EVEN)         strcat(debugstr, "even ");
    if (dwFlags & VPP_BOB)          strcat(debugstr, "bob ");
    if (dwFlags & VPP_INTERLEAVED)  strcat(debugstr, "int ");
    if (dwFlags & VPP_VIDEOPORT)    strcat(debugstr, "vp ");
    if (dwFlags & VPP_WAIT)         strcat(debugstr, "wait ");
    if (dwFlags & VPP_OPTIMIZEFLIP) strcat(debugstr, "opt ");
    strcat(debugstr, "REQ: ");
    if (dwFlags & VPP_CONVERT)      strcat(debugstr, "cvt ");
    if (dwFlags & VPP_SUBPICTURE)   strcat(debugstr, "sp ");
    if (dwFlags & VPP_PRESCALE)     strcat(debugstr, "ps ");
    if (dwFlags & VPP_COLOURCONTROL) strcat(debugstr, "cc ");
    if (dwFlags & VPP_TEMPORAL)     strcat(debugstr, "tf ");
    if (dwFlags & VPP_DEINTERLACE)  strcat(debugstr, "df ");
#endif

    //assert(pDriverData);

    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    // find out if overlay hardware is busy, if so return "overlay busy" error code.
    // Perhaps check a "number of overlay buffers programmed" count.  When this count is less
    // than 2, the overlay hardare is not busy and when it's equal to 2, the hardwar is busy.
    // If it's not busy, then program it up here and increment the count.  Then use a kernel
    // callback to decrement this count upon buffer complete.
    //

    DWORD dwIndex = pOverlayInfo->dwOverlayBufferIndex & 1;

    DBGPRINT(DBGTRACE, "NVPPrescaleAndFlip");

#if 0 //def _NVP_DTRACE
    DTRACE(0xdead0001);
    DTRACE_CYCLE_DELTA();
    DTRACE(dwOffset);
    DTRACE(dwIndex);

//    return TRUE;
#endif

/*
        while ((pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS) && (i < VDD_VPP_TIME_OUT))
            i++;
        // timed-out... stop the appropriate buffer and return error
        if (i >= VDD_VPP_TIME_OUT)
*/


    dwWorkSurfaces = pOverlayInfo->dwExtra422NumSurfaces;
    vppExec = 0;
    dwOpCount = 0;
    dwSrcOffset = dwOffset;
    dwSrcPitch = dwPitch;
    dwDstOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index];
    dwDstPitch = pOverlayInfo->dwExtra422Pitch;
    dwNextOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index + 1];
    dwNextPitch = pOverlayInfo->dwExtra422Pitch;

    isField = IS_FIELD(dwFlags);

    doXPreScale = (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale));
    doYPreScale = (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale));

    if (pVPEContext->dwChipId < NV_DEVICE_VERSION_10) {
        // NV4/5 also prescales:
        //  - all BOBed fields
        //  - vertical upscales when HQVUp is enabled
        doYPreScale = TRUE; //doYPreScale || isField; //|| (pOverlayInfo->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)
    }

    doPreScale = (dwFlags & VPP_PRESCALE) &&
                 (doXPreScale || doYPreScale);

    isDownScale = FALSE;
    if (doPreScale)
    {
        DWORD dwSrcArea, dwDstArea;

        dwSrcArea = pOverlayInfo->dwOverlaySrcHeight * pOverlayInfo->dwOverlaySrcWidth;
        if ((dwFlags & (VPP_ODD | VPP_EVEN)) && (dwFlags & VPP_INTERLEAVED))
        {
            // bob mode
            dwSrcArea >>= 1;
        }
        dwDstArea = pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayDstWidth;
        if (dwSrcArea > dwDstArea)
        {
            isDownScale = TRUE;
        }
    }

    if (dwWorkSurfaces < 2) {
        // no work surfaces, can't do anything
        doPreScale = FALSE;
    }

    // adjust for the subrectangle
    dwRoundX = pOverlayInfo->dwOverlaySrcX & 0x1;
    dwRoundY = pOverlayInfo->dwOverlaySrcY & 0x1;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcY & ~0x1) * dwSrcPitch;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcX & ~0x1) << 1;   // always YUV422
    dwWidth = pOverlayInfo->dwOverlaySrcSize & 0xFFFF;
    dwHeight = pOverlayInfo->dwOverlaySrcSize >> 16;
    if (dwWidth & 1)
        dwWidth += 1;
    if (dwRoundY)
        dwHeight += 1;

    // do the prescaling now
    if (doPreScale)
    {
        if (NVPPreScale(pVPEContext, pOverlayInfo,
                        dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, &dwWidth, &dwHeight,
                        &dwFlags)) {
            NEXT_SURFACE;
            vppExec |= VPP_PRESCALE;
        }
    }

    if (dwRoundY)
    {
        dwSrcOffset += dwSrcPitch;
        dwHeight -= 1;
    }

//    if (dwRoundX)
//        dwWidth -= 1;

#ifdef VPEFSMIRROR
	// do FS Mirror
    if (pVPEContext->dwFsMirrorOn)
	{   
        if(NVPFsMirror(pVPEContext, pOverlayInfo, dwSrcOffset, dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFlags)
           == NO_ERROR)
        {
            if (NVPFsFlip(pVPEContext, pVPEContext->nFSFlipIdx) 
                == NO_ERROR)
            {
             pVPEContext->nFSFlipIdx ^= 1;  // success, switch to other buffer            
            }        
        // move to next surface here            
        pVPEContext->nFSFlipSurfIdx = (pVPEContext->nFSFlipSurfIdx + 1) % pVPEContext->nNumFSSurf;
        }
	}
   
#endif

    // drop field if previous one is still being drawn (same overlay buffer) !
    if (pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS){
        DBGPRINT(DBGWARN, "     Overlay still busy. Previous one is still being drawn");
    }
    else {
    // always do the flip, even if we are not flipping
    if (NVPFlip(pVPEContext, pOverlayInfo, dwSrcOffset,
                dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFlags))
    {
        pOverlayInfo->dwOverlayBufferIndex ^= 1;
        if (dwWorkSurfaces == 0)
        {
            pOverlayInfo->dwExtra422Index = 0;
        }
        else if (dwWorkSurfaces <= 3)
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 1) % dwWorkSurfaces;
        }
        else
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 2) % dwWorkSurfaces;
        }
    }
    else
    {
        return FALSE;
    }
    }



    return TRUE;
}

/*
==============================================================================
    
    NVPIsVPEEnabled

    Description:    checks registry key VPEENABLE if set to 0 (disable)
                    return pCmdObj->dwPortId = 1 if enabled (default)
                           pCmdObj->dwPortId = 0 if disabled

    Date:           Feb 04, 2000
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPIsVPEEnabled(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pInCmdObj,
    NVP_CMD_OBJECT *pOutCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    
    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[pInCmdObj->dwPortId]);

    // copy pointer to shared flag
    pVPEContext->pOvrRing0FlipFlag = pInCmdObj->pOvrRing0FlipFlag;

#ifdef _WIN32_WINNT
    // check flag (previously read from registry in function FindAdapter())
    pOutCmdObj->dwPortId = (pHwDevExt->dwVPEEnabled) ? 1 : 0;
#endif

    return NO_ERROR;
}

VP_STATUS NVPFlushChannel(
    PNVP_CONTEXT pVPEContext)
{
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    NvNotification *pavpNotifiers;
    U032    count=10000;
    
    DBGPRINT(DBGTRACE, "NVPFlushChannel");

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;


#define USE_M2M_OBJECT 
#ifdef USE_M2M_OBJECT

    pavpNotifiers = (NvNotification *)pVPEContext->axfNotifiers;
    (pavpNotifiers[NV039_NOTIFIERS_NOTIFY]).status=NV039_NOTIFICATION_STATUS_IN_PROGRESS;
    // send NO-OP thru
    NVP_DMAPUSH_CHECK_FREE_COUNT(10);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT , NVP_M2M_OBJECT);
    pDmaChannel->Put = nvDmaCount << 2;

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NOTIFY, NV039_NOTIFY_WRITE_ONLY); 
    pDmaChannel->Put = nvDmaCount << 2;

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NO_OPERATION, 0x00000000); 
    pDmaChannel->Put = nvDmaCount << 2;
/*
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT , NVP_M2M_OBJECT);
    //NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_NOTIFIES, NVP_M2M_NOTIFIER);
    //NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_IN, NVP_M2M_FROM_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NOTIFY, NV039_NOTIFY_WRITE_ONLY); 
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NO_OPERATION, 0x00000000); 

    pDmaChannel->Put = nvDmaCount << 2;
*/
    pVPEContext->nvDmaCount = nvDmaCount;

    while ( pavpNotifiers[NV039_NOTIFIERS_NOTIFY].status == 
                            NV04D_NOTIFICATION_STATUS_IN_PROGRESS && (--count));

    if(!count){
        DBGPRINT(DBGWARN, "Timeout. Unable to flush channel!!!");
    }

#endif

//#define USE_VID_DEC_OBJECT

#ifdef USE_VID_DEC_OBJECT
    ////////////////////////////////////////////////
    // reset notifiers
    //pavpNotifiers = &(((NvNotification *)(pVPEContext->avpNotifiers))[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)]);

    //pavpNotifiers->status = NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED;//NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    pavpNotifiers = (NvNotification *)pVPEContext->avpNotifiers;
    (pavpNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)]).status=NV04D_NOTIFICATION_STATUS_IN_PROGRESS;//NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED;
    // send NO-OP thru
    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_NOTIFY, NV04D_NOTIFY_WRITE_ONLY); 
    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_NO_OPERATION, 0x00000000); //not implemented
    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_NOTIFIES, 
    //                                  NVP_EXTERNAL_DECODER_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_GET_IMAGE_OFFSET_NOTIFY(0), 
                                        NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY); 
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    while ( ((pavpNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)]).status) == 
                            NV04D_NOTIFICATION_STATUS_IN_PROGRESS  && (--count));

    if(!count){
        DBGPRINT(DBGWARN, "Timeout. Unable to flush channel!!!");
    }

#endif

    return NO_ERROR;
}

#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\ddrvmem.h ===
#ifndef DDRVMEM_H
#define DDRVMEM_H

#define EXTRA_LEAN_AND_MEAN
#include <windows.h>

// =========================================================
// Memory Management Macros
//
//      These macros are used for platform independent
//      memory operations.
//
//      NOTE:  If you have multiple threads
//             that compete for memory or run
//             into memory corruption problems.
//             uncomment the #define DDRV_SERIALIZE below
//
//      NOTE:  This does not support locking/unlocking mutual
//             exclusion.  If you have multiple threads or
//             code that can be interrupted and re-entered
//             then it is possible to get invalid pointers.
//             It shouldn't be too hard to add this support yourself
// =========================================================



extern HANDLE g_hD3DHAL_DriverHeap;

#define MEMALLOC(cbSize)    HeapAlloc (g_hD3DHAL_DriverHeap, HEAP_ZERO_MEMORY, (cbSize))
#define MEMFREE(lpPtr)      HeapFree (g_hD3DHAL_DriverHeap, 0, (lpPtr))

#define MEMCOPY(p1,p2,cbSize)   CopyMemory((void *)(p1), (void *)(p2), (DWORD)(cbSize))
#define MEMCLEAR(p1,cbSize)     ZeroMemory((void *)(p1), (DWORD)(cbSize))
#define MEMSET(p1,cbSize,val)   FillMemory((void *)(p1), (DWORD)(cbSize), (BYTE)val)



// =========================================================
// DDrvItemArray library.
//
//   This is used by the display drivers for dynamic memory
//   management of contexts, textures, and other objects
//   described by fixed-size structures.
//
// =========================================================

// Call this in DLL_PROCESS_ATTACH.
// If this function returns FALSE, you should fail the
// DLL load.
BOOL DDrvItemArrayInit ();

// Call this on DLL_PROCESS_DETACH.
BOOL DDrvItemArrayFini ();


// Handle to an itemarray
typedef DWORD HDDRVITEMARRAY, *LPHDDRVITEMARRAY;

// Handle to an item
typedef DWORD HDDRVITEM, * LPHDDRVITEM;


// Passes back a handle to the itemarray and returns TRUE if
// successful.
//
// nItems   - initial number of item slots in array
// dwSize   - size of each item in array (in Bytes)
// dwDelta  - growth factor (array grows by dwDelta slot
//            each time it is full and needs more space)
// lphArray - handle to newly created array
//
// Returns FALSE if the itemarray could not be created.
BOOL DDrvItemArrayCreate (DWORD nItems, DWORD dwSize,
                          DWORD dwDelta, LPHDDRVITEMARRAY lphArray);

// Destroys an itemarray.
// Returns FALSE if the itemarray handle is not valid.
BOOL DDrvItemArrayDestroy(HDDRVITEMARRAY hArray);

// Flushes an array, i.e. sets all item slots to empty (available)
// Returns FALSE if the itemarray handle is not valid.
BOOL DDrvItemArrayFlush (HDDRVITEMARRAY hArray);

// Allocate an item in array and return a small integer handle to it.
// The integer handle is guaranteed positive (0 is not a valid handle).
// Returns FALSE if it could not allocate enough room.
BOOL DDrvItemArrayAlloc (HDDRVITEMARRAY hArray, LPHDDRVITEM lphItem);

// Attempts to free an item.
BOOL DDrvItemArrayFree (HDDRVITEMARRAY hArray, HDDRVITEM hItem);

// Given an itemarray and an item handle, return a pointer to
// the item.
//
// Don't save these pointers. Allocating more items from the array
// may move the array's location in memory, invalidating any
// pointers into the array that may be lying around.
LPVOID DDrvItemArrayGetPtr (HDDRVITEMARRAY hArray, HDDRVITEM hItem);


// Callback Return type
enum DDRV_RETURN {
    DDRV_SUCCESS_STOP,
    DDRV_SUCCESS_CONTINUE,
    DDRV_ERROR_CONTINUE,
    DDRV_ERROR_STOP
};

// Generic Callback prototype
// should return one of the above values
typedef DWORD (*DDRVAPPLYFUNC)(void * lpData, HDDRVITEM hItem, DWORD dwData);


// Apply's a user defined callback function to
// each and every valid item in itemarray
BOOL DDrvItemArrayApplyValid (HDDRVITEMARRAY hArray, DDRVAPPLYFUNC lpCallback,
                              DWORD dwExtraData);

BOOL DDrvItemArrayApplyAll (HDDRVITEMARRAY hArray, DDRVAPPLYFUNC lpCallback,
                            DWORD dwExtraData);

BOOL DDrvItemArrayFindFirstValid (HDDRVITEMARRAY hArray, LPHDDRVITEM lpNextValid);

BOOL DDrvItemArrayFindNextValid (HDDRVITEMARRAY hArray, HDDRVITEM hStartFrom,
                                 LPHDDRVITEM lpNextValid);


#endif // DDRVMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\duma.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: Duma.h															*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*		Andrei Osnovich    01/17/99  Created								*
*                                                                           *
\***************************************************************************/

#ifndef DUMA_H
#define DUMA_H

#ifndef DUMA_VXD
#include <windows.h>
#endif

/*
 *Duma delegated services.
 */

#define DUMA_HOT_KEY_CREATE 		  1
#define DUMA_HOT_KEY_DESTROY		  2
#define DUMA_HOT_KEY_RESET			  3
#define DUMA_CACHE_CONTROL			  4
#define DUMA_SOFTICE_CONTROL          5
#define DUMA_ENFORCE_FILTER           6
// Errors
#define DUMA_OK 		   0

#define CACHE_INVALIDATE	 0x01
#define CACHE_ENABLE_WT 	 0x02
#define CACHE_ENABLE_WB 	 0x04
#define CACHE_DISABLE		 0x08
#define CACHE_ENABLE_AGP	 0x10
#define CACHE_DISABLE_AGP	 0x20

typedef struct _CacheControlData {
	DWORD dwFlags;
	DWORD dwStartAddr;
	DWORD dwLength;
} CACHECONTROLDATA, *LPCACHECONTROLDATA;

// Hot key options:
#define HK_BUSY_MASK	   0x80000000 // mask for MSB - controls busy of hotkey
#define HK_OCCURED_MASK    0x7FFFFFFF // mask for value (w/o MSB)

#ifndef DUMA_VXD

typedef DWORD* HKHANDLE;  // HotKey Handle

typedef struct _HOTKEY
{
	DWORD	  dwValue;
	HKHANDLE  hkHandle;
} HOTKEY, *LPHOTKEY;

#ifdef __cplusplus

// C++ interface class for Duma VxD services.
class CHotKeyInterface
{
  protected:
	  HANDLE DumaHandle;

  public:
	  HKHANDLE CreateHotKey(DWORD dwKey);
	  BOOL DestroyHotKey(HKHANDLE );
	  BOOL ResetHotKey(HKHANDLE );
      BOOL EnforceFilter(void);
	  inline BOOL isInitialized()
		{ return DumaHandle!=NULL; }

  public:
	  CHotKeyInterface();  // constructor
	  ~CHotKeyInterface(); // destructor
};

typedef CHotKeyInterface CHOTKEYINTERFACE, *LPCHOTKEYINTERFACE;

/*
 * Macros for easy Hot Key Interface access.
 */

#define CREATEHOTKEY(pInterface,HotKey)                                 \
	if ((HotKey).dwValue)                                               \
    {                                                                   \
	  if (pInterface)                                                   \
		(HotKey).hkHandle = pInterface->CreateHotKey((HotKey).dwValue); \
    }

#define DESTROYHOTKEY(pInterface,HotKey)                                \
	if (pInterface && (HotKey).hkHandle)                                \
    {                                                                   \
	   pInterface->DestroyHotKey((HotKey).hkHandle);                    \
	   (HotKey).hkHandle = 0;                                           \
    }

#define ENFORCEFILTER(pInterface)                                       \
    res_ = FALSE;                                                       \
	if (pInterface)                                                     \
    {                                                                   \
	   res_ = pInterface->EnforceFilter();                              \
    }

// Warning!!! The function that uses the POLLHOTKEY macros has to 
// define the following local variable:
//      BOOL res_; 
#define POLLHOTKEY(pInterface,HotKey)                                   \
    res_ = FALSE;                                                       \
	if ((HotKey).hkHandle && (*((HotKey).hkHandle) & HK_OCCURED_MASK))  \
    {                                                                   \
        res_ = TRUE;                                                    \
		if (pInterface) pInterface->ResetHotKey((HotKey).hkHandle);     \
    }                                                                   \
    if (res_ == TRUE)

#ifdef  DEFINE_HOTKEY_INTERFACES

// CHotKeyInterface class members implementation is to be included once 
// somewhere in a ring 3 application that wants to utilize the DUMA hot 
// key support. 

CHotKeyInterface::CHotKeyInterface()
{
    if ((DumaHandle = CreateFile("\\\\.\\DUMA.VXD", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL))==INVALID_HANDLE_VALUE)
        DumaHandle = NULL;
}

CHotKeyInterface::~CHotKeyInterface()
{
    if (DumaHandle)
    {     
        CloseHandle(DumaHandle);
        DumaHandle = NULL;
    }
}

HKHANDLE CHotKeyInterface::CreateHotKey(DWORD dwKey)
{
    HKHANDLE hkHandle = NULL;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_HOT_KEY_CREATE, (LPVOID)&dwKey, sizeof(DWORD), &hkHandle, sizeof(HKHANDLE), &RetVal, NULL);
        if (RetVal != sizeof(HKHANDLE)) return NULL;
        return hkHandle;
    }
    return NULL;
}

BOOL CHotKeyInterface::DestroyHotKey(HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_HOT_KEY_DESTROY, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL CHotKeyInterface::ResetHotKey(HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_HOT_KEY_RESET, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL CHotKeyInterface::EnforceFilter(void)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_ENFORCE_FILTER, NULL, 0, &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

#endif  //DEFINE_HOTKEY_INTERFACES

#else   //__cplusplus==0

// "C" interface structure for Duma VxD services.
typedef struct _HotKeyInterface
{
	  HANDLE DumaHandle;
	  HKHANDLE (*CreateHotKey)(struct _HotKeyInterface *, DWORD dwKey);
	  BOOL (*DestroyHotKey)(struct _HotKeyInterface *, HKHANDLE );
	  BOOL (*ResetHotKey)(struct _HotKeyInterface *, HKHANDLE );
      BOOL (*EnforceFilter)(struct _HotKeyInterface *);
} CHOTKEYINTERFACE, *LPCHOTKEYINTERFACE;

/*
 * Macros for easy Hot Key Interface access.
 */

#define CREATEHOTKEY(pInterface,HotKey)                                             \
	if ((HotKey).dwValue)                                                           \
    {                                                                               \
	  if (pInterface)                                                               \
		(HotKey).hkHandle = pInterface->CreateHotKey(pInterface,(HotKey).dwValue);  \
    }

#define DESTROYHOTKEY(pInterface,HotKey)                                            \
	if (pInterface && (HotKey).hkHandle)                                            \
    {                                                                               \
	   pInterface->DestroyHotKey(pInterface,(HotKey).hkHandle);                     \
	   (HotKey).hkHandle = 0;                                                       \
    }

#define ENFORCEFILTER(pInterface)                                                   \
    res_ = FALSE;                                                                   \
	if (pInterface)                                                                 \
    {                                                                               \
	   res_ = pInterface->EnforceFilter(pInterface);                                \
    }

// Warning!!! The function that uses the POLLHOTKEY macros has to 
// define the following local variable:
//      BOOL res_; 
#define POLLHOTKEY(pInterface,HotKey)                                               \
    res_ = FALSE;                                                                   \
	if ((HotKey).hkHandle && (*((HotKey).hkHandle) & HK_OCCURED_MASK))              \
    {                                                                               \
        res_ = TRUE;                                                                \
		if (pInterface) pInterface->ResetHotKey(pInterface,(HotKey).hkHandle);      \
    }                                                                               \
    if (res_ == TRUE)

#ifdef  DEFINE_HOTKEY_INTERFACES

// HotKeyInterface "C" interface's implementation is to be included once 
// somewhere in a ring 3 application that wants to utilize the DUMA hot 
// key support. 

HKHANDLE CreateHotKey(LPCHOTKEYINTERFACE pInterface, DWORD dwKey)
{
    HKHANDLE hkHandle = NULL;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_HOT_KEY_CREATE, (LPVOID)&dwKey, sizeof(DWORD), &hkHandle, sizeof(HKHANDLE), &RetVal, NULL);
        if (RetVal != sizeof(HKHANDLE)) return NULL;
        return hkHandle;
    }
    return NULL;
}

BOOL DestroyHotKey(LPCHOTKEYINTERFACE pInterface, HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_HOT_KEY_DESTROY, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return RetVal;
    }
    return ServiceOutput;  
}

BOOL ResetHotKey(LPCHOTKEYINTERFACE pInterface, HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_HOT_KEY_RESET, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL EnforceFilter(LPCHOTKEYINTERFACE pInterface)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_ENFORCE_FILTER, NULL, 0, &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL CreateHotKeyInterface(LPCHOTKEYINTERFACE pInterface)
{
    if (!pInterface)
        return FALSE;
    if ((pInterface->DumaHandle = CreateFile("\\\\.\\DUMA.VXD", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL))==INVALID_HANDLE_VALUE)
        return FALSE;
    pInterface->CreateHotKey  = CreateHotKey;
    pInterface->DestroyHotKey = DestroyHotKey;
    pInterface->ResetHotKey   = ResetHotKey;
}

void DestroyHotKeyInterface(LPCHOTKEYINTERFACE pInterface)
{
    if (pInterface->DumaHandle)
    {     
        CloseHandle(pInterface->DumaHandle);
        pInterface->DumaHandle = NULL;
    }
}

#else   //DEFINE_HOTKEY_INTERFACES==0
extern  BOOL CreateHotKeyInterface(LPCHOTKEYINTERFACE pInterface);
extern  void DestroyHotKeyInterface(LPCHOTKEYINTERFACE pInterface);
#endif  //DEFINE_HOTKEY_INTERFACES

#endif  //__cplusplus==0

#endif //DUMA_VXD

#endif // #define DUMA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\dxshare.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       dxshare.h
 *
 *  Content:    This file has a data structure that is shared between
 *              the display driver and the DirectX driver.
 *
 *      NOTES:  Due to the need to h2inc this file and also compiler
 *              structure packing parameters, please only use
 *              unsigned longs as members of this structure and
 *              do NOT have any substructures. The real data
 *              DirectX needs will go in its own private data
 *              structure that it allocates itself when the DirectX
 *              driver is laoded. This shared data structure is ONLY
 *              needed for the display driver to send over a few
 *              instance specific things to the DirectX driver
 *              and the DirectX driver to send back a few instance
 *              specific things to the display driver.
 *
 ***************************************************************************/

#ifndef _DXSHARE_H_
#define _DXSHARE_H_

// I don't think we will have more than this for a while
#define MAX_HEADS       4

typedef struct  tagDISPDRVDIRECTXCOMMON
{
    // The display driver fills these in for the DirectX driver to use
    unsigned long   pFlatDibeng;        // Flat ptr to Driver PDEVICE
    unsigned long   dwNVDeviceID;       // 1 based board instance
    unsigned long   dwDeviceVersion;    // NVidia chip/software version
    unsigned long   dwRootHandle;       // Root allocated from RM by driver
    unsigned long   dwScreenLinearBase; // Linear base address of framebuffer
    unsigned long   dwDeviceLinearBase; // Linear base address of chip
    unsigned long   dwDeviceHandle;     // VDD handle for this device
    unsigned long   dwHeadNumber;       // 0 or 1
                                        // For single head boards and
                                        // multi-head boards in clone mode
                                        // this will be 0.

    // There are some wierd DirectX apps that assume the mode table
    // is created in 16bit land before even calling the 32bit
    // DirectX driver. Hence, DirectX needs amode table around and
    // hanging out so that it can just grab. It doesn't have the
    // opportunity to build one before it needs it. This is a ptr to
    // MODEENTRYANDPITCH structures defined in modeext.h
    unsigned long   lpMasterModeList;

    // This is a 32:32 (FAR32) ptr to a callback function that DirectX
    // can invoke only when it is within a pfnInterfaceFunc routine
    // shown below. Pass in the pDispDriverHWLogDevCX as the context
    // data for this function call.
    unsigned long   dwDrvCallbackOffset;
    unsigned long   dwDrvCallbackSelector;
    unsigned long   pDispDriverHWLogDevCX;

    ////////////////////////////////////////////////////////////////////
    // The DirectX driver fills these in for the display driver to use.
    unsigned long   dwFlatDataSel;
    unsigned long   dwFlatCodeSel;

    // 32 Bit flat ptr to the DDHALInfo structure
    unsigned long   pHalInfo;

    // size of DDthe HALINFO structure in bytes
    unsigned long   dwHALInfoSize;

    // The hInstance of the DirectX driver passed to its DllMain proc
    unsigned long   hDirectXInstance;

    // cached values of the previous display mode (used to detect true mode changes)
    // do not use these to get the current mode information
    unsigned long   deWidth;
    unsigned long   deHeight;
    unsigned long   deBitsPixel;

    // 32bit flat ptr to a procedure which accepts the following:
    // eax - ptr to this structure DISPDRVDIRECTXCOMMON
    // ebx - one of the GDIDX_XXX equates below
    // Basically this procedure can be called by the display driver
    // whenever the driver wants to inform DirectX about something.
    // The interface is agreed upon solely by the display driver
    // and the DirectX driver. This procedure will be called directly
    // (with no thunking) from the display driver. Hence, it cannot
    // call any system routines, since although we are running in
    // 32bit flat land at the time we are executing it, we will really
    // be running as a sub-routine of the display driver! To return,
    // this procedure MUST execute a FAR32 return -- you must do this
    // in assembly -- the 32bit C compiler cannot do this for you!
    unsigned long   pfnInterfaceFunc;

    // DirectX context data ptr. The display driver has no idea
    // what this points to -- it is solely for DirectDraw's use.
    unsigned long   pDirectXData;
    unsigned long   pNvPrimarySurf;
    unsigned long   dwModeNumber;
    unsigned long   primaryBufferIndex;

    unsigned long   dwPhysicalHeadNumber;

}   DISPDRVDIRECTXCOMMON;

// These flags indicate what type of Interface call this is
// When calling pfnInterfaceFunc from the display driver, if ebx =
// GDIDX_PRE_SETINFOINIT, then you should fill in the 16bit portion of
// the DDHALINFO structure. Basically the "16 bit portion" is the
// vmiData, FourCC, ModeList, and Callback List fields.
#define GDIDX_PRE_SETINFOINIT           0x01
#define GDIDX_ENTER_FULL_SCREEN_DOS     0x02
#define GDIDX_EXIT_FULL_SCREEN_DOS      0x03
#define GDIDX_PRE_MODESET_NOTIFY        0x04
#define GDIDX_POST_MODESET_NOTIFY       0x05
#define GDIDX_DIRECTX_OS_VERSION        0x06
#define GDIDX_DRIVER_UNLOADING          0x07
#define GDIDX_EARLY_DX_CONNECT          0x08

// This is a DCI escape call that I made up. It is not part of the
// standard DCI escape set. but it should be! It tells the display
// driver that the DirectX driver is going down.
#define DDNVCREATEDRIVEROBJECT      98
#define DDNVDESTROYDRIVEROBJECT     99

// DirectX needs to understand the standard part of the PDEVICE
// which is the DIBENGING structure. Unfortunately, including
// dibeng.inc won't build so I just have the structure here.
typedef struct  _tagDIBENGINEHDR1
{
    unsigned short      deType;
    unsigned short      deWidth;
    unsigned short      deHeight;
    unsigned short      deWidthBytes;
    unsigned char       dePlanes;
    unsigned char       deBitsPixel;
    unsigned long       deReserved1;
    unsigned long       deDeltaScan;
    unsigned long       delpPDevice;
    unsigned long       deBitsOffset;
    unsigned short      deBitsSelector;
    unsigned short      deFlags;
    unsigned short      deVersion;
    unsigned long       deBitmapInfo;
    unsigned long       deBeginAccess;
    unsigned long       deEndAccess;
    unsigned long       deDriverReserved;
}   DIBENGINEHDR1;

// When certain events happen in 16bit, there is a special call
// made into the DX driver via the pfnInterfaceFunc ptr in the
// DISPDRVDIRECTXCOMMON structure. This is not a thunked call
// so while executing the code in these calls, the DX driver is
// running as a sub-routine of the display driver and it cannot
// make system calls. To make calls into the OS to alloc memory,
// etc, DX must call back to the display driver and have it make
// the system calls on its behalf. To do this the DX driver
// calls the function pointed at by the dwDrvCallbackOffset and
// dwDrvCallbackSelector fields in the DISPDRVDIRECTXCOMMON
// structure. This DrvCallback routine has the following interface.
// int FAR32 PASCAL DrvCallbackFunc(DWORD pDispDriverHWLogDevCX,
// DWORD dwFunction, void *pIn, void *pOut) and can perform a
// variety of services based upon the dwFunction argument.
// These are listed below.

// For the alloc memory service, set dwFunction to this equate
// pIn should point to the following structure.
// The objectID should be a uniqueID for the object that the
// RM will associate with the memory block. This objectID will
// need to get passed back in to free the memory block.
// dwAllocFlags are things like NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS
// specified in nvos.h
// pOut should point to a dword which will get filled in with
// a ptr to a memory block of the size requested or NULL if the
// allocation was unsuccessful.
#define NV_DRVSERVICE_ALLOC_MEMORY          0x01
typedef struct  _DRVSERVICE_ALLOC_MEMORY
{
    unsigned long   dwObjectID;
    unsigned long   dwAllocFlags;
    unsigned long   dwNumBytes;
}   DRVSERVICE_ALLOC_MEMORY;

// For the free memory service, set dwFunction to this equate
// Then pIn should point to the following struct. The service
// always returns TRUE. The pOut argument is not used.
#define NV_DRVSERVICE_FREE_MEMORY           0x02
typedef struct  _DRVSERVICE_FREE_MEMORY
{
    unsigned long   dwObjectID;
}   DRVSERVICE_FREE_MEMORY;

// These two services should be called with the lpIn argument equal
// to the lpDibeng. lpDibeng should be a field in the HALINFO table.
// It is a 16:16 ptr to the DIBENGINE structure.
// These two services may actually be called even if the DX driver
// is not running as a subroutine of the display driver because
// these services make no system calls, so it does not matter what
// "space" the owner is running in.
#define NV_DRVSERVICE_BEGINACCESS           0x03
#define NV_DRVSERVICE_ENDACCESS             0x04

#endif  // _DXSHARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\Files.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       files.h
 *  Content:    Contains defines for the various binary filenames
 *
 ***************************************************************************/

/*NV3 binaries*/
#define NV3_DDRAW_BINARY		"NV3DD32.DLL"
#define NV3_DISPLAY_BINARY		"NV3DISP.DRV"
#define NV3_OPENGL_BINARY		"NV3OGL.DLL"
#define NV3_MINIVDD_BINARY		"NV3.VXD"
#define NV3_MINIVDD2_BINARY		"NV3MINI2.VXD"
#define NV3_RM_32_BINARY		"NV3API.DLL"
#define NV3_RM_16_BINARY		"NV3SYS.DLL"
#define NV3_RM_KERNEL_BINARY		"NV3RM.VXD"
#define NV3_QUICK_TWEAK_BINARY		"NV3QTWK.DLL"
#define NV3_TWEAK_BINARY		"NV3TWEAK.DLL"
#define NV3_TWEAK_HELP_BINARY		"NV3TWEAK.HLP"

/*NV4 binaries*/
#define NV4_DDRAW_BINARY		"NVDD32.DLL"
#define NV4_DISPLAY_BINARY		"NVDISP.DRV"
#define NV4_MODESET_BINARY		"NVMODE.DLL"
#define NV4_OPENGL_BINARY		"NVOPENGL.DLL"
#define NV4_MINIVDD_BINARY		"NVMINI.VXD"
#define NV4_MINIVDD2_BINARY		"NVMINI2.VXD"
#define NV4_RM_32_BINARY		"NVARCH32.DLL"
#define NV4_RM_16_BINARY		"NVARCH16.DLL"
#define NV4_RM_KERNEL_BINARY		"NVCORE.VXD"
#define NV4_QUICK_TWEAK_BINARY		"NVQTWK.DLL"
#define NV4_TWEAK_BINARY		    "NVCPL.DLL"
#define NV4_TWEAK_SVC_BINARY		"NVCPLSVC.DLL"
#define NV4_DESK_MGR_BINARY         "NVDESK32.DLL"
#define NV4_DESK_MGR_UI_BINARY      "NVDMCPL.DLL"
#define NV4_FSVM_BINARY		        "NVFSVM.EXE"
#define NV4_TWEAK_HELP_BINARY		"NVCPL.HLP"
#define NV4_INSTALL_LIB_BINARY      "NVINST32.DLL"
#define NV4_ARABIC_RESOURCE_BINARY	"NVRSAR.DLL"
#define NV4_ARABIC_HELP_BINARY		"NVCPAR.HLP"
#define NV4_CZECH_RESOURCE_BINARY	"NVRSCS.DLL"
#define NV4_CZECH_HELP_BINARY		"NVCPCS.HLP"
#define NV4_DANISH_RESOURCE_BINARY	"NVRSDA.DLL"
#define NV4_DANISH_HELP_BINARY		"NVCPDA.HLP"
#define NV4_GERMAN_RESOURCE_BINARY	"NVRSDE.DLL"
#define NV4_GERMAN_HELP_BINARY		"NVCPDE.HLP"
#define NV4_UKENGLISH_RESOURCE_BINARY	"NVRSENG.DLL"
#define NV4_UKENGLISH_HELP_BINARY	"NVCPENG.HLP"
#define NV4_SPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_SPANISH_HELP_BINARY		"NVCPES.HLP"
#define NV4_LASPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_LASPANISH_HELP_BINARY	"NVCPES.HLP"
#define NV4_FINNISH_RESOURCE_BINARY	"NVRSFI.DLL"
#define NV4_FINNISH_HELP_BINARY		"NVCPFI.HLP"
#define NV4_FRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_FRENCH_HELP_BINARY		"NVCPFR.HLP"
#define NV4_CAFRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_CAFRENCH_HELP_BINARY	"NVCPFR.HLP"
#define NV4_GREEK_RESOURCE_BINARY	"NVRSEL.DLL"
#define NV4_GREEK_HELP_BINARY	"NVCPEL.HLP"
#define NV4_HEBREW_RESOURCE_BINARY	"NVRSHE.DLL"
#define NV4_HEBREW_HELP_BINARY	"NVCPHE.HLP"
#define NV4_HUNGARIAN_RESOURCE_BINARY	"NVRSHU.DLL"
#define NV4_HUNGARIAN_HELP_BINARY	"NVCPHU.HLP"
#define NV4_ITALIAN_RESOURCE_BINARY	"NVRSIT.DLL"
#define NV4_ITALIAN_HELP_BINARY		"NVCPIT.HLP"
#define NV4_JAPANESE_RESOURCE_BINARY	"NVRSJA.DLL"
#define NV4_JAPANESE_HELP_BINARY	"NVCPJA.HLP"
#define NV4_KOREAN_RESOURCE_BINARY	"NVRSKO.DLL"
#define NV4_KOREAN_HELP_BINARY		"NVCPKO.HLP"
#define NV4_DUTCH_RESOURCE_BINARY	"NVRSNL.DLL"
#define NV4_DUTCH_HELP_BINARY		"NVCPNL.HLP"
#define NV4_NORWEGIAN_RESOURCE_BINARY	"NVRSNO.DLL"
#define NV4_NORWEGIAN_HELP_BINARY	"NVCPNO.HLP"
#define NV4_POLISH_RESOURCE_BINARY	"NVRSPL.DLL"
#define NV4_POLISH_HELP_BINARY	"NVCPPL.HLP"
#define NV4_PORTUGUESE_RESOURCE_BINARY	"NVRSPT.DLL"
#define NV4_PORTUGUESE_HELP_BINARY	"NVCPPT.HLP"
#define NV4_BPORTUGUESE_RESOURCE_BINARY	"NVRSPTB.DLL"
#define NV4_BPORTUGUESE_HELP_BINARY	"NVCPPTB.HLP"
#define NV4_RUSSIAN_RESOURCE_BINARY	"NVRSRU.DLL"
#define NV4_RUSSIAN_HELP_BINARY		"NVCPRU.HLP"
#define NV4_SLOVAK_RESOURCE_BINARY	"NVRSSK.DLL"
#define NV4_SLOVAK_HELP_BINARY		"NVCPSK.HLP"
#define NV4_SLOVENIAN_RESOURCE_BINARY	"NVRSSL.DLL"
#define NV4_SLOVENIAN_HELP_BINARY		"NVCPSL.HLP"
#define NV4_SWEDISH_RESOURCE_BINARY	"NVRSSV.DLL"
#define NV4_SWEDISH_HELP_BINARY		"NVCPSV.HLP"
#define NV4_THAI_RESOURCE_BINARY	"NVRSTH.DLL"
#define NV4_THAI_HELP_BINARY		"NVCPTH.HLP"
#define NV4_TURKISH_RESOURCE_BINARY	"NVRSTR.DLL"
#define NV4_TURKISH_HELP_BINARY		"NVCPTR.HLP"
#define NV4_SIMCHINESE_RESOURCE_BINARY	"NVRSZHC.DLL"
#define NV4_SIMCHINESE_HELP_BINARY	"NVCPZHC.HLP"
#define NV4_TRDCHINESE_RESOURCE_BINARY	"NVRSZHT.DLL"
#define NV4_TRDCHINESE_HELP_BINARY	"NVCPZHT.HLP"

/*NV4 NT4 binaries*/
#define NV4_DISPLAY_BINARY_NT4		"NV4_DISP.DLL"
#define NV4_OPENGL_BINARY_NT4		"NVOGLNT.DLL"
#define NV4_MINIVDD_BINARY_NT4		"NV4_MINI.SYS"
#define NV4_QUICK_TWEAK_BINARY_NT4   NV4_QUICK_TWEAK_BINARY
#define NV4_TWEAK_BINARY_NT4         NV4_TWEAK_BINARY
#define NV4_TWEAK_HELP_BINARY_NT4    NV4_TWEAK_HELP_BINARY
#define NV4_DESK_MGR_BINARY_NT4      NV4_DESK_MGR_BINARY

/* Workstation Application binaries */
#define NV4_POWERDRAFT_BINARY		"NVDS15.DLL"
#define NV4_MAXTREME_BINARY			"MAXtreme.drv"
#define NV4_QUADROVIEW_BINARY		"QUADROVIEW.EXE"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\DDMINI.H ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddmini.h
 *  Content:    header for Windows95 Direct Draw driver
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef NVARCH
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

#if !defined(_WIN32) && !defined(WINNT)
#define NOUSER
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#include <windows.h>
#define NOPTRC
#define PTTYPE POINT
#include <nvgdi.inc>
#define NVFAR FAR
#include <nvdib.inc>
typedef struct tagPALETTEENTRY FAR* LPPALETTEENTRY;
typedef struct tagRGNDATA      FAR* LPRGNDATA;
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    };
} ULARGE_INTEGER;
#include <ddrawi.h>
#endif

#include "nvFourCC.h"
#include "nvVPP.h"
#include "nvcm.h"
#include "nvdd.h"

#include "nvUniversal.h"

/***************************************************************************
 *
 * DriverData
 *
 * this structure contains all the globals of the driver, it is shared
 * between the 16 and 32bit side of the driver.
 *
 ***************************************************************************/

#ifndef HDRVEVENT
#include "nvProcMan.h"
#endif

#ifndef NVTWINVIEWDATA
#include "nvMultiMon.h"
#endif

#define DDMINI_VERSION  0x0400

#if (NVARCH < 0x4)
#define NV_MAX_OVERLAY_SURFACES  10
#define NV_MAX_EXTRA_SURFACES    6
#define NV_MAX_EXTRA_FS_SURFACES 4
#endif

//---------------------------------------------------------------------------

typedef struct tagNVMCSURFACEFLAGS {
  DWORD dwMCSurfaceBase;
  DWORD dwMCSurface422Offset;
  DWORD dwMCMotionCompReferenceCount;
  DWORD dwMCFormatCnvReferenceCount;
  DWORD dwMCCompositeReferenceCount;
  DWORD dwMCTemporalFilterReferenceCount;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCFrameIsFiltered;
  BYTE  bMCFrameIsComposited;
  BYTE  bMCFrameAlreadyFormatConverted;
} NVMCSURFACEFLAGS, *LPNVMCSURFACEFLAGS;

//---------------------------------------------------------------------------
#ifdef ENABLE_VPP_DISPATCH_CODE

typedef struct {
    DWORD               dwState;    // dispatcher state
    DWORD               dwCommand;  // dispatcher command
    DWORD               dwThreadPriority;
    DWORD               dwProcessPriority;
    DWORD               dwOriginalThreadPriority;
    DWORD               dwOriginalProcessPriority;
    PROCESS_INFORMATION procInfo;
    HDRVEVENT           hSignalGo0;     // ring0 event to dispatch
    HDRVEVENT           hSignalGo3;     // ring3 event to dispatch
    HDRVEVENT           hSignalDone0;   // ring0 event signaling completion
    HDRVEVENT           hSignalDone3;   // ring3 event signaling completion

    // parameters for vppVPPandFlip
    DWORD               dwOffset;
    DWORD               dwPitch;
    DWORD               dwWidth;
    DWORD               dwHeight;
    DWORD               dwFourCC;
    DWORD               dwFlags;
    DWORD               dwReturnCode;
    DWORD               dwReserved1;
} VPPDISPATCH;
#else
// NB: The following # of DWORDS must exactly match the size of the dispatch code
// above.  Someday this can all go away...
typedef DWORD VPPDISPATCH[22];
#endif

//---------------------------------------------------------------------------
#if (NVARCH < 0x4)
typedef struct {
    DWORD               dwLastFlags;
    DWORD               dwLastExec;
    DWORD               dwMarker1;
    DWORD               dwReserved1;

    LONGLONG            qwCount;

    LONGLONG            qwInterFrameTime;
    LONGLONG            qwInterFrameAcc;
    LONGLONG            qwInterFramePeak;
    LONGLONG            qwInterFrameDelta;
    LONGLONG            qwInterFrameJitterAcc;
    LONGLONG            qwInterFrameJitterPeak;

    LONGLONG            qwIntraFrameAcc;
    LONGLONG            qwIntraFramePeak;
    LONGLONG            qwIntraFrameDelta;
    LONGLONG            qwIntraFrameJitterAcc;
    LONGLONG            qwIntraFrameJitterPeak;

    LONGLONG            qwMarker2;
    LONGLONG            qwReserved2;
} VPPSNOOP;

//---------------------------------------------------------------------------

typedef struct {
    DWORD               dwOpCount;
    HDRVEVENT           hLastStage;
    BOOL                doLateFlipSync;
    DWORD               dwIndex;
    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwWidth;
    DWORD               dwHeight;
    DWORD               dwFourCC;
    DWORD               dwFlags;
    DWORD               dwWorkSurfaces;
    DWORD               vppExec;
    LONGLONG            qwTime1;
    LONGLONG            qwTime2;
    LONGLONG            qwDelta;
    LONGLONG            qwJitter;
} VPPSTATE;
#endif
#define NVPE_EVENT_MAX 3

//---------------------------------------------------------------------------
/// NVPESTATE

typedef struct {
    BOOL                bVPEInitialized;
    BOOL                bFsMirrorEnabled;
    DWORD               dwVPEState;
    HANDLE              hVPEKernel;
    HANDLE              hNVPSyncEvent[NVPE_EVENT_MAX];
    HANDLE              hNVPSyncEvent0[NVPE_EVENT_MAX];
} NVPESTATE;

//---------------------------------------------------------------------------
// blit data, including cached values and other control parameters

typedef struct {
    DWORD               dwStatusReferenceCount;
    DWORD               dwSystemSurfaceContextDMAIndex;
    DWORD               dwMTMFIndex;     // alternating odd or even, does not need to be initialized
    DWORD               dwLastRop;
    DWORD               dwLastColourKey;
    DWORD               dwLastColourFormat;
    DWORD               dwLastCombinedPitch;
    DWORD               dwLastSrcOffset;
    DWORD               dwLastDstOffset;
    DWORD               dwSystemBltFallback;
    DWORD               dwLetItThrash;
    DWORD               dwQueuedPrimaryBlitCount;
} BLTDATA;

//---------------------------------------------------------------------------
// blt work surface info

typedef struct {
    DWORD               dwLocale;
    DWORD               dwContextDma;
    DWORD               dwWSSize;
    FLATPTR             fpVidMem;
    DWORD               dwOffset;
    DWORD               dwReserved;
} BLTWSINFO;

//---------------------------------------------------------------------------
// sync record

typedef struct {
    DWORD               bSyncFlag;
    DWORD               dwReserved1;
} SYNCRECORD;

//---------------------------------------------------------------------------
// flip record
//---------------------------------------------------------------------------
typedef struct {
    DWORD               fpFlipFrom;
    DWORD               dwFlipDuration;
    DWORD               bFlipFlag;
    DWORD               bIsD3DSurface;
    DWORD               fpFlipTo;
    DWORD               fpPreviousFlipFrom;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LONGLONG            llFlipTime;
    LONGLONG            llPreviousFlipTime;
    NV_CFGEX_CRTC_TIMING_PARAMS nvTimingInfo[2];
    LONGLONG            llFlipDurationNs[2];
} FLIPRECORD;

typedef DWORD  (FAR PASCAL *LPDDHALSURFCB_GETSURFACEINFO)(LPDDRAWI_DDRAWSURFACE_LCL);

#ifdef WINNT
typedef struct _PDEV PDEV;      // Defined in NT display driver's DRIVER.H file
#endif

//---------------------------------------------------------------------------

/*
 * nvdd32 driver context
 *
 * this is only used when nvdd32.dll source files include this file
 */
#if (NVARCH < 0x4)
#ifdef __cplusplus
class CDriverContext;
#define NVDD32_CONTEXT      DWORD  dwNVDD32Context;
#else
#define NVDD32_CONTEXT      DWORD  ContextSpaceFiller;
#endif
#endif
/*
 * forward definitions
 */
#ifdef __cplusplus
class CNvObject;
class CInterProcessHeap;
struct _NV_OBJECT_LIST;
#endif

#ifdef __cplusplus
class CReferenceCount;
#define REFCOUNT_t CReferenceCount
#else
struct CReferenceCount;
#define REFCOUNT_t struct CReferenceCount
#endif

// ---------------------------------------------------------
// GLOBALDATA struct
// ---------------------------------------------------------

#define FSDOSSTATUS_RECOVERYNEEDED_DDRAW  0x00000001
#define FSDOSSTATUS_RECOVERYNEEDED_D3D    0x00000002
#define FSDOSSTATUS_TWINVIEW_STATE_CHANGE 0x40000000
#define FSDOSSTATUS_COMPLETE              0x80000000

typedef struct _GLOBALDATA {
    // ---------------------------------------------------------
    // Stuff whose offset in this structure is critical.
    // ---------------------------------------------------------

#if (NVARCH >= 0x04)

    DWORD                       dwVersion;
    DWORD                       dwGlobalStructSize;          // current size of this structure
    DWORD                       DDrawVideoSurfaceCount;
    DWORD                       dwFullScreenDOSStatus;

#else  // NV3

    // on nv3, we still have dependencies with the display driver, so offsets are critical
#ifdef _WIN32
    DWORD                       lpPDevice;                   // *MUST* be first (DIBLINK.ASM) uses it.
#else
    DIBENGINE FAR *             lpPDevice;
#endif
    DWORD                       dwVersion;
    DWORD                       dwGlobalStructSize;          // current size of this structure
    DWORD                       DDrawVideoSurfaceCount;      // *MUST* start at 0x0C (cursor code and realizeObject checks it)
    WORD                        fDmaPusherActive;            // *MUST* start at 0x10 (both display driver and direct draw check it)
    BYTE                        fFullScreenDosOccurred;      // *MUST* start at 0x12 (both display driver and D3D check it)
    BYTE                        fDDrawFullScreenDosOccurred; // *MUST* start at 0x13 (both display driver and DDraw check it)
    DWORD                       dwModeSwitchCount;           // *MUST* start at 0x16 offset (display driver uses it)

#endif  // NV3

    // ---------------------------------------------------------
    // General Info -
    // stuff not specific to NV internals, D3D, DirectDraw,
    // or MultiMon alone. If specific, please file below.
    // (sooner or later, i _will_ organize the world.
    // ---------------------------------------------------------
#if (NVARCH >= 0x4)
    CPushBuffer                 nvPusher;
#endif
    DWORD                       dwDDDmaPusherChannelIndex;
    DWORD                       dwDDDmaPusherChannelMask;
    DWORD                       NvAGPDmaPusherBufferBase;
    DWORD                       dwSharedClipChangeCount;
    DWORD                       dwDDMostRecentClipChangeCount;
#ifdef  _WIN32
    volatile long               *NvDmaPusherBufferEnd;
#else   // _WIN32
#endif  // _WIN32
    long                        NvDmaPusherBufferSize;
    DWORD                       dwVidMemCtxDmaSize;
    #if (NVARCH < 0x4)
    DWORD                       dwDmaPusherCtxDmaSize;
    #endif
    DWORD                       dwMacrovisionNavigatorID;
    SYNCRECORD                  syncPioFifoRecord;
    SYNCRECORD                  syncDmaRecord;
    DWORD                       blitCalled;
    WORD                        fVidMemLocked;
    WORD                        fActiveExternalUser; // NVLIB, NVDDX, etc
    WORD                        fNvActiveFloatingContexts;
#ifdef WINNT
    // stored in pDXShare under win9x
    WORD                        primaryBufferIndex;
#else
    WORD                        unused_01;  // Keep everything dword aligned
#endif

    // info about the current mode
    DWORD                       TotalVRAM;          // total VRAM on card
#if (NVARCH < 0x4)
    DWORD                       ModeNumber;
    DWORD                       ScreenSel;          // selector to screen
    DWORD                       maxOffScreenY;      // maximum screen pitch width Y at current resolution
#endif
    DWORD                       BaseAddress;        // base addess of accessable video memory.
    long                        VideoHeapBase;      // start of video heap
    long                        VideoHeapEnd;       // end of video heap
    long                        VideoHeapTotal;     // total available heap
    long                        VideoHeapOverhead;  // GDI and RM overhead, not related to DX surfaces
    long                        VideoHeapFree;      // free heap
#ifdef WINNT
    DWORD_PTR                   GARTLinearBase;     // linear base address of AGP GART memory
    DWORD_PTR                   GARTPhysicalBase;   // physical base address of AGP GART memory
    DWORD_PTR                   GARTLinearHeapOffset; // WINNT - offset from GARTLinearBase to beginning of AGP heap
#else
    DWORD                       GARTLinearBase;     // linear base address of AGP GART memory
    DWORD                       GARTPhysicalBase;   // physical base address of AGP GART memory
    VOID                        *notUsedGARTLinearHeapOffset; // not used - placeholder for Win9x VxD builds
#endif // !WINNT

    DWORD                       regPersistAGPSize;  // # of bytes reserved for persistent AGP allocs
#if (NVARCH < 0x4)
    // bitmapinfo for current mode
    BITMAPINFOHEADER            bi;
    DWORD                       color_table[256];

    DWORD                       dwDXRuntimeVersion; // version of DirectX runtime installed (inferred from GUIDs)
    #endif
    DWORD                       dwDDGlobal;         // LPDDRAWI_DIRECTDRAW_GBL for this context
    DWORD                       __pad_xxx;

    DWORD                       dwGenInfoPad0;      // unused
    DWORD                       dwGenInfoPad1;      // unused

    // ---------------------------------------------------------
    // NV stuff
    // ---------------------------------------------------------
    DWORD                       lpNvDmaBuffer; // obsolete
    DWORD                       NvCommonDmaBufferFlat;
    DWORD                       NvScanlineBufferFlat;
#if (NVARCH < 0x04)
    DWORD                       NvDevFlatPio;
#endif
    DWORD                       NvDevVideoFlatPio;  // Video channel
    DWORD                       NvDevFlatVPE;       // Vpe channel
#if (NVARCH >= 0x04)
    NvNotification *            pDmaBufferNotifierFlat;
    NvNotification *            pDmaFlipPrimaryNotifierFlat;
    NvNotification *            pDmaDmaToMemNotifierFlat;
    NvNotification *            pDmaSyncNotifierFlat;
    NvNotification *            pGenericScaledImageNotifier;
    NvNotification *            pPioColourControlEventNotifierFlat;
    NvNotification *            pPioCombinerEventNotifierFlat;
#else
    DWORD                       NvPioFlipPrimaryNotifierFlat;
    DWORD                       NvPioSyncNotifierFlat;
    DWORD                       NvPioDmaFromMemNotifierFlat;
#endif
    DWORD                       NvPioDmaToMemNotifierFlat;
    DWORD                       NvPioBufferNotifierFlat;
    NvNotification *            pDmaPusherSyncNotifierFlat;
    NvNotification *            pPioFlipOverlayNotifierFlat;
    DWORD                       NvDmaFromMemBaseAddress;
    DWORD                       NvDmaFromMemSurfaceMem;
    DWORD                       NvFloating0UYVYSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloating1UYVYSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloating0YUYVSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloating1YUYVSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloatingMem2MemFormatMemoryHandle;        // only used for WINNT now, delete when done
    DWORD                       NvFloatingMem2MemFormatSurfaceAddress[4];   // only used for NV3 now, delete when done
    DWORD                       NvYUY2Surface0Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvYUY2Surface1Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvYUY2Surface2Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvYUY2Surface3Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvWinDmaPusherNotifierFlat;
    DWORD                       dwVideoPortsAvailable;
    DWORD                       NvFloatingTexture;
    DWORD                       CurrentVisibleSurfaceAddress;
    DWORD                       dDrawSpareSubchannelObject; // subchannel 7
    BOOL                        bDirtyRenderTarget;                         // nv4 only - RT/ZB has/have changed, need HW update
    DWORD                       NvBaseFlat;
    NvU32                       dwDesktopState;

    // --------------------------------------------------------
    // Overlay related stuff
    // --------------------------------------------------------
    Vpp_t                       vpp;

    NvU32                       regSuper7Compat;
#if (NVARCH < 0x4)
    DWORD                       dwOverlaySurfaces;
    DWORD                       dwOverlayOwner;
    DWORD                       dwOverlaySurfaceLCL[NV_MAX_OVERLAY_SURFACES];
    DWORD                       dwOverlaySrcWidth;
    DWORD                       dwOverlaySrcHeight;
    DWORD                       dwOverlayDstWidth;
    DWORD                       dwOverlayDstHeight;
    DWORD                       dwOverlayDeltaX;
    DWORD                       dwOverlayDeltaY;
    DWORD                       dwOverlayLastVisibleSurfaceLCL;
    DWORD                       dwOverlayLastVisibleFpVidMem;
    DWORD                       dwOverlayLastVisiblePitch;
    DWORD                       dwOverlayLastVisiblePixelFormat;
    DWORD                       dwOverlayFlipCount;
    WORD                        OverlaySrcX;        // overlay starting points
    WORD                        OverlaySrcY;
    WORD                        OverlayDstX;
    WORD                        OverlayDstY;
    WORD                        OverlayBufferIndex;
    WORD                        OverlayRelaxOwnerCheck;
    DWORD                       OverlaySrcOffset;
    DWORD                       OverlayFormat;      // current overlay format - used so VDD knows what's up!
    DWORD                       OverlaySrcPitch;    // current overlay pitch   - used so VDD knows what's up!
    DWORD                       OverlaySrcSize;
    DWORD                       OverlayColorKey;
    DDCOLORCONTROL              OverlayColourControl;
    DWORD                       OverlayCachedFlags;
    DWORD                       extra422OverlayOffset[NV_MAX_EXTRA_SURFACES];   // can be up to n "chunks" longer original surface
    DWORD                       extra422Pitch;
    DWORD                       extra422NumSurfaces;
    DWORD                       extra422Index;
    DWORD                       dwOverlayFSOffset[NV_MAX_EXTRA_FS_SURFACES];
    DWORD                       dwOverlayFSWidth;
    DWORD                       dwOverlayFSHeight;
    DWORD                       dwOverlayFSPitch;
    DWORD                       dwOverlayFSFormat;
    DWORD                       dwOverlayFSNumSurfaces;
    DWORD                       dwOverlayFSIndex;
    DWORD                       dwOverlayFSDeltaX;
    DWORD                       dwOverlayFSDeltaY;
    DWORD                       dwOverlayFSHead;
    DWORD                       dwOverlayFSOvlHead;
    DWORD                       dwOverlayFSSrcWidth;
    DWORD                       dwOverlayFSSrcHeight;
    DWORD                       dwOverlayFSSrcMinX;
    DWORD                       dwOverlayFSSrcMinY;
    NVTWINVIEWDATA              dwOverlayFSTwinData;
    DWORD                       dwOverlayFSOvlHeadSaved;
    DWORD                       dwOverlayFSOvlLost;
    DWORD                       fpOverlayShadow;
    DWORD                       dwOverlayByteAlignmentPad;
    DWORD                       dwOverlayMaxDownScale;
    DWORD                       dwOverlayMaxDownScaleX;
    DWORD                       dwOverlayMaxDownScaleY;
    DWORD                       regOverlayColourControlEnable;
    DWORD                       regRing0ColourCtlInterlockFlags;    // bit0 = 1 -> ring0 should run; bit2 = 1 ring0 in progress
    DWORD                       regOverlayMode;
    DWORD                       regOverlayMode2;
    DWORD                       regOverlayMode3;
    DWORD                       OverlayMode;            // used to tell if we're doing interleaved or what...
    DWORD                       regVPPInvMask;
    DWORD                       regVPPMaxSurfaces;
    VPPDISPATCH                 vppDispatch;
    VPPSNOOP                    vppSnoop;
    VPPSTATE                    vppState;
    DWORD                       dwVPPSubPictureOffset;
    DWORD                       dwVPPSubPicturePitch;
    DWORD                       dwVPPSubPictureFormat;
    DWORD                       dwVPPSubPictureX;
    DWORD                       dwVPPSubPictureY;
    DWORD                       dwVPPSubPictureWidth;
    DWORD                       dwVPPSubPictureHeight;
    #endif
    NvU32                       regPBLocale;
    LPPROCESSINFO               lpProcessInfoHead;
    PROCESSINFO                 procInfo;           // statically created for NT
    DWORD                       dwUseRefreshRate;
    WORD                        ddClipUpdate;
    WORD                        fDeviceHasDitheringControl;
    DWORD                       physicalColorMask;
    BYTE                        fDmaPushBufferHasBeenFlushed;
    BYTE                        fIsBltStyleFlip;
    WORD                        NvDeviceVersion;
    WORD                        bEnableVPE;     // used to allow registry disabling of VPE port
    WORD                        ddPad0point5;   // the other word which is unused
    DWORD                       CloseNvDevVideoFlatPio;
    DWORD                       CloseNvDevFlatVPE;
    DWORD                       northBridgeID;
    BLTDATA                     bltData;
    BLTWSINFO                   bltSysMemInfo;
    BLTWSINFO                   bltAGPMemInfo;
    BLTWSINFO                   bltVidMemInfo;
    DWORD                       dwTVTunerFlipCount;
    DWORD                       dwTVTunerTimer;
    NvU32                       regMaxAGPLimit;
    NvU32                       regTVTunerHack;         // unused under WINNT
    NvU32                       regEnumDDRefresh;

    // --------------------------------------------------------
    // VPE related stuff
    // --------------------------------------------------------

    NVPESTATE                   nvpeState;

    // --------------------------------------------------------
    // Motion Comp related stuff
    // --------------------------------------------------------
    DWORD                       dwMCTex0Control0;
    DWORD                       dwMCTex1Control0;
    BYTE                        bMCNewFrame;
    BYTE                        bMCPictureStructure;
    BYTE                        bMCPictureCodingType;
    BYTE                        bMCTopFieldFirst;
    BYTE                        bMCSecondField;
    BYTE                        bMCFrameType;
    BYTE                        bMCForwardPictureStructure;
    BYTE                        bMCBackwardPictureStructure;
    DWORD                       dwMCDestinationSurface;
    DWORD                       dwMCForwardSurface;
    DWORD                       dwMCBackwardSurface;
    DWORD                       dwMCDualPrimeSurface;
    DWORD                       dwMCIDCTSurface;
    DWORD                       dwMCMostRecentlyDecodedSurfaceBase;
    DWORD                       dwMCNVDSSurfaceBase;
    DWORD                       dwMCFirstAlignedIDCTIndex;
    DWORD                       dwMCIDCTAGPSurfaceBase[4];
    DWORD                       dwMCIDCTAGPCtxDmaSize[4];
    DWORD                       dwMCCurrentCelsiusIDCTCtxDma;
    DWORD                       dwMCDestinationSurfaceOffset;
    DWORD                       dwMCForwardSurfaceOffset;
    DWORD                       dwMCBackwardSurfaceOffset;
    DWORD                       dwMCNVMCSurface;
    DWORD                       dwMCNV12Surface[8];
    DWORD                       dwMCNVIDSurface[4];
    DWORD                       dwMCNVSPSurface;
    NVMCSURFACEFLAGS            nvMCSurfaceFlags[9];
    BYTE                        bMCTemporalFilterDisabled;
    BYTE                        bMCPercentCurrentField;
    BYTE                        bMCMostRecentlyDecodedPictureStructure;
    BYTE                        bMCOverlaySrcIsSingleField1080i;
    BYTE                        bMCCurrentExecuteFunction;
    BYTE                        bMCHorizontallyDownscale1080i;
    BYTE                        bMCPad0; // unused
    BYTE                        bMCPad1; // unused
    DWORD                       dwMCNVIDSurfaceReferenceCount[4];
    // --------------------------------------------------------
    DWORD                       dwMostRecentHWUser;   // most recent user of shared HW objects (celsius, kelvin, etc.)
    DWORD                       NvVideoNotifierBuffer;
    DWORD                       lockCount;
    DWORD                       thisDeviceID;
    DWORD                       dwRingZeroMutex; // when true prevents ring 0 from stepping on ring3 spare channel state
    WORD                        flatSelector;
    WORD                        NvFreeCount;
    DWORD                       dwBusType;
    DWORD                       pCurrentChannelID;
    DWORD                       NvVideoFreeCount;
    #if (NVARCH < 0x4)
    BYTE                        NvFirstCall;
    BYTE                        NvPrevDepth;
    #else
    WORD                        wNv4Pad;
    #endif
    BYTE                        TwoDRenderingOccurred;
    BYTE                        ThreeDRenderingOccurred;
    DWORD                       fourCC[32];

    // Used by VPP, MoComp & D3D
    FLIPRECORD               flipPrimaryRecord;
    FLIPRECORD               flipOverlayRecord;
    REFCOUNT_t              *pRefCount;

    // ---------------------------------------------------------
    // D3D stuff
    // ---------------------------------------------------------

    // for nv4 and beyond, most stuff has been moved into CDriverContext
#if (NVARCH >= 0x04)
    NV_SystemInfo_t             nvD3DPerfData;
    DWORD                       dwCurrentContextHandle;     // probably don't need
#else  // NV3
    DWORD                       dwCurrentContextHandle;
    DWORD                       dwD3DContextCount;
    DWORD                       dwZBufferContextAddr;
    DWORD                       dwTextureContextValid;
    DWORD                       dwD3DTextureCount;
    DWORD                       dwDMAPushContext;
    DWORD                       dwDmaPushBufferSize;
    DWORD                       hContexts_gbl;
    DWORD                       hTextures_gbl;
    DWORD                       hAGPList_gbl;
    DWORD                       hTextureHeap;
    DWORD                       dwContextListHead;
    DWORD                       dwDmaMaxPushCount;
    DWORD                       dwDmaFifoAddr;
    DWORD                       dwDmaFifoOffset;
    DWORD                       dwDmaFifoCurrentBuffer;
    DWORD                       dwDmaCount;
    DWORD                       dwDmaFifoPhysOffset;
    DWORD                       dwDmaFifoCurrent;
    DWORD                       dwDmaFifoOffsetCurrent;
    DWORD                       dwTextureListHead;
#ifdef __cplusplus
    CNvObject                  *pNvObjectHead;
#else
    void                       *dwD3DPad3;
#endif
    DWORD                       dwRMChID;
    DWORD                       dwRMPtBase;
    DWORD                       dwRMAddressSpace;
    DWORD                       dwProcessorSpeed;
    DWORD                       dwProcessorFlags;
    // Texture heap data.
    DWORD                       pRealHeapBase;
    DWORD                       pTextureHeapBase;
    DWORD                       pTextureHeapAllocHead;
    DWORD                       pTextureHeapAllocTail;
    DWORD                       pTextureHeapFreeHead;
    DWORD                       pTextureHeapFreeTail;
    DWORD                       dwTextureHeapSize;
    DWORD                       dwTextureHeapSizeMax;
    DWORD                       dwTextureHeapLimit;
    DWORD                       dwTextureHeapLimitMax;
    DWORD                       dwAllocSize;
    DWORD                       dwFreeSize;
    // D3D registry settings.
    DWORD                       regD3DEnableBits1;
    DWORD                       regDmaPushBufferSizeMax;
    DWORD                       regMipMapLevels;
    DWORD                       regZOHMode;
    DWORD                       regTexHeap;
    DWORD                       regMinVideoTextureSize;
    DWORD                       regFilterControl;
    DWORD                       regD3DContextMax;
    DWORD                       regD3DTextureMax;
    DWORD                       regNonSquareExpand;
    DWORD                       regFOHMode;
    DWORD                       regLODMethod;
    DWORD                       regAAReadCompatibilityFile;
    DWORD                       regAAMethod;
    DWORD                       regTurboMode;
    DWORD                       regD3DAlphaBlendMethod;
    DWORD                       regDmaMinPushCount;
    DWORD                       regNVPEventBits;   // locutus enable bits
    DWORD                       regNVPTimeBits;    // locutus enable bits
    DWORD                       regNVPCountBits;   // locutus enable bits
    DWORD                       regGapFill;
    DWORD                       regTexAddrAdjust;
    // Extra D3D data space
    DWORD                       dwD3DPad0;         // unused
    DWORD                       dwD3DPad1;         // unused
    DWORD                       fReset;
    DWORD                       fVidMemVarsReset;
#endif  // NV3

    // ---------------------------------------------------------
    // DirectDraw stuff
    // ---------------------------------------------------------

    DWORD                       dwFourCCSelector;
    DWORD                       dwPvmListSelector;
    DWORD                       dwDDCallbacksSelector;
    DWORD                       dwDDSurfaceCallbacksSelector;
    DWORD                       dwDDPaletteCallbacksSelector;
    DWORD                       dwDDExecuteBufferCallbackSelector;
    DWORD                       dwModeListSelector;
#ifndef WINNT
#define                         MAX_MODES   MAX_MODEENTRYS
#ifdef  _WIN32  // This is because we use this file with both 16 and 32 bit compilers
    DDHALMODEINFO NEAR          *ModeList;
#else
    DWORD                       ModeList;
#endif  // _WIN32
    DDHALDDRAWFNS               HALCallbacks;
#endif // !WINNT

#ifdef WINNT
    DDHALINFO                   HALInfo;                // allocated dynamically under Win9x
#endif // WINNT
    DDHAL_DDCALLBACKS           DDCallbacks;
    DDHAL_DDSURFACECALLBACKS    DDSurfaceCallbacks;
    DDHAL_DDPALETTECALLBACKS    DDPaletteCallbacks;

#ifndef WINNT   // WINNT BUG we will need to remove when DX7 port is complete
    DDHAL_DDEXEBUFCALLBACKS     DDExecuteBufferCallbacks;
#else
    DDHAL_D3DBUFCALLBACKS       DDExecuteBufferCallbacks;
#endif // WINNT0

#ifndef WINNT
    VIDMEM                      vidMem[2];
#endif // #ifdef WINNT

    DWORD                       dwMySurfacesPtr;        // unused
    DWORD                       bRing0FlippingFlag;        // TRUE when KMVT based overlay flipping is happening
    DWORD                       dwDDrawPad3;        // unused

    DWORD                       dwSurfaceAlignPad;
    DWORD                       dwSurfaceAlign;     // hw required surface alignment
    DWORD                       dwSurfaceBitAlign; // hw required surface alignment in term of bits

    // ---------------------------------------------------------
    // Multi-Monitor stuff - only use this data in a MM driver
    // ---------------------------------------------------------
    DWORD                       dwDrvRefCount;      // driver reference count, can get greater than 1 in multihead
    DWORD                       dwRootHandle;       // NV connection Root Handle
    DWORD                       dwDeviceHandle;     // ID associated with a particular driver for a display by VDD
    DWORD                       dwDeviceIDNum;      // ID for a display assigned by the RM
    DWORD                       dwDeviceClass;
    DWORD                       dwHeads;            // number of heads (DACs) on this device
#ifdef WINNT
    //*****************************************************************************
    // Semaphore related fields.
    //*****************************************************************************
    BOOL    NvSemRefCnt;        // Does this GLOBALDATA own the semaphore?
#else
    DWORD   NvSemPlaceHolder;   // Dummy placeholder for Win9x
#endif // !WINNT

    DWORD                       pStereoData;        // pointer to a structure containing stereo stuff.

    // ---------------------------------------------------------
    // DirectX-VA Stuff
    // ---------------------------------------------------------
    BYTE                        bDXVAIndexToNVIndex[8];
    DWORD                       dwDXVAConvertBuffer;
    WORD                        wDXVAReserved1;
    WORD                        wDXVAReserved2;
    DWORD                       dwDXVAFlags;
    DWORD                       dwDXVAIndexToVidMem[8];
    DWORD                       dwDXVAReserved3;

    DWORD                       dwNVOverlayFlags;

} GLOBALDATA;

/***************************************************************************
 ***************************************************************************/

#ifdef _WIN32

#ifdef __cplusplus
    class CDriverContext;
    extern CDriverContext *pDriverData;   // in ddDrv.cpp
#else
    extern GLOBALDATA     *pDriverData;   // in ddDrv.cpp
#endif

/* Ternary raster operation indexes */

#define BLACKNESSINDEX      0x00000000L
#define NOTSRCERASEINDEX    0x00000011L
#define NOTSRCCOPYINDEX     0x00000033L
#define SRCERASEINDEX       0x00000044L
#define PATINVERTINDEX      0x0000005AL
#define SRCINVERTINDEX      0x00000066L
#define SRCANDINDEX         0x00000088L
#define MERGEPAINTINDEX     0x000000BBL
#define SRCCOPYINDEX        0x000000CCL
#define SRCPAINTINDEX       0x000000EEL
#define PATCOPYINDEX        0x000000F0L
#define WHITENESSINDEX      0x000000FFL

/* Supported ROP table bits */

/* 0x00 */
#define BLACKNESSBIT        0x00000001L
/* 0x10 */
#define NOTSRCERASEBIT      0x00020000L

/* 0x20 */
/* 0x30 */
#define NOTSRCCOPYBIT       0x00080000L

/* 0x40 */
#define SRCERASEBIT         0x00000010L
/* 0x50 */
#define PATINVERTBIT        0x04000000L

/* 0x60 */
#define SRCINVERTBIT        0x00000040L
/* 0x70 */

/* 0x80 */
#define SRCANDBIT           0x00000100L
/* 0x90 */

/* 0xA0 */
/* 0xB0 */
#define MERGEPAINTBIT       0x08000000L

/* 0xC0 */
#define MERGECOPYBIT        0x00000001L
#define SRCCOPYBIT          0x00001000L
/* 0xD0 */

/* 0xE0 */
#define SRCPAINTBIT         0x00004000L
/* 0xF0 */
#define PATCOPYBIT          0x00010000L
#define WHITENESSBIT        0x80000000L


#else  // _WIN32

/* Ternary raster operations */
#define BLACKNESS           0x00000042L
#define SRCCOPY             0x00CC0020L
#define PATCOPY             0x00F00021L
#define WHITENESS           0x00FF0062L

/***************************************************************************
 *
 * global driver data
 *
 ***************************************************************************/

#if !defined(_WIN32) && !defined(WINNT)
extern GLOBALDATA           DriverData;     // in ddmini16.c
#endif /* !defined(_WIN32) && !defined(WINNT) */

/***************************************************************************
 *
 * functions in ddmini.c
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags);
void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags);

/***************************************************************************
 *
 * functions in setmode.c
 *
 ***************************************************************************/

BOOL HWSetMode();
BOOL HWTestMode(int ModeNumber);
void HWEndAccess(void);
BOOL HWSetPalette(int start, int count, DWORD FAR *colors);


/***************************************************************************
 *
 * functions in DIBENG
 *
 ***************************************************************************/

extern DWORD FAR PASCAL CreateDIBPDevice    (LPBITMAPINFOHEADER lpbi, DIBENGINE FAR *lpDevice, LPVOID lpBits, WORD dwFlags);
extern UINT  FAR PASCAL DIB_Enable          (LPVOID, UINT, LPSTR, LPSTR, LPVOID);
extern UINT  FAR PASCAL DIB_Disable         (DIBENGINE FAR *);
extern LONG  FAR PASCAL DIB_Control         (DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern UINT  FAR PASCAL DIB_BeginAccess     (DIBENGINE FAR *, int left, int top, int right, int bottom, WORD flags);
extern UINT  FAR PASCAL DIB_EndAccess       (DIBENGINE FAR *, WORD flags);
extern UINT  FAR PASCAL DIB_SetPaletteExt   (UINT start, UINT count, DWORD FAR *lpPalette, DIBENGINE FAR * pde);
extern UINT  FAR PASCAL DIB_BitBlt          (DIBENGINE FAR *, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *);
extern UINT  FAR PASCAL DIB_StretchBlt      (DIBENGINE FAR *, int, int, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_StretchDIBits   (DIBENGINE FAR *, int, int, int, int, int, int, int, int, LPVOID, BITMAPINFO FAR *, LPVOID, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_DibToDevice     (DIBENGINE FAR *, int, int, int, int, RECT FAR *, DRAWMODE FAR *, LPVOID, BITMAPINFO FAR *, LPVOID);
extern UINT  FAR PASCAL DIB_Output          (DIBENGINE FAR *, int, int, POINT FAR *, DIB_Pen FAR *, DIB_Brush8 FAR *, DRAWMODE FAR *, RECT FAR *);
extern UINT  FAR PASCAL DIB_ExtTextOutExt   (DIBENGINE FAR *pde, int x, int y, RECT FAR *Clip, LPSTR sz, UINT cb, LPVOID lpFont, DRAWMODE FAR *pdm, LPVOID xform, int FAR *pdx, RECT FAR *lpORect, UINT f, LPVOID DrawBitmap, LPVOID DrawRect);
// extern UINT  FAR PASCAL DIB_SetCursorExt    (CURSORSHAPE FAR *lpCursor, DIBENGINE FAR *pde);
extern UINT  FAR PASCAL DIB_MoveCursorExt   (int x, int y, DIBENGINE FAR * pde);

#endif // _WIN32

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010
#define NV_DEVICE_VERSION_20    0x0020

/* AGP stuff */
#define NV_MAX_AGP_MEMORY_LIMIT 0x1FFFFFF

/* Dma flags */
#define NV_WIN_DMA_PUSHER_IS_ACTIVE  1
#define NV_DD_DMA_PUSHER_IS_ACTIVE   2

/* Floating system memory context in use flags */
#define NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        1
#define NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        2
#define NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        4
#define NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        8
#define NV_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY       16

/* Other NV specific defines */
#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L

/* Surface Alignment */
#if (NVARCH >= 0x010)
#define NV_BYTE_ALIGNMENT_PAD           63L
#define NV_BYTE_ALIGNMENT               64L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#elif (NVARCH >= 0x04)
#define NV_BYTE_ALIGNMENT_PAD           31L
#define NV_BYTE_ALIGNMENT               32L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#else /* NVARCH < 0x04 */
#define NV_BYTE_ALIGNMENT_PAD           15L
#define NV_BYTE_ALIGNMENT               16L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      128
#define NV_BIT_ALIGNMENT                128
#endif  /* !(NV10 || NV4) */

/* Define driver defined surface bits for the driver reserved field in the local surface structure */
#define NV_D3D_HAS_FLIPPED              0x00000001

/* Detect the Via VP3 and MVP3 Northbridge IDs for workarounds */
#define VIA_VP3_NB_ID   0x5971106
#define VIA_MVP3_NB_ID  0x5981106
#define IS_VIA_MVP3_NB_ID(nb)   (((nb) == VIA_VP3_NB_ID) || ((nb) == VIA_MVP3_NB_ID))

// dwDXVAFlags in pDriverData
#define DXVA_MO_COMP_IN_PROGRESS     0x00000001
#define DXVA_PICTURE_IN_PROGRESS     0x00000002
#define DXVA_ENABLED_IN_REGISTRY     0x00000004
#define DXVA_INTRA_IDCT_UNSIGNED     0x00000008
#define DXVA_OVERLAY_WAS_BOBBED      0x00000010
#define DXVA_BACK_END_ALPHA_SELECTED 0x00000020
#define DXVA_BACK_END_ALPHA_ENABLED  0x00000040

// dwNVOverlayFlags in pDriverData
#define OVERLAY_FLAG_ON_PANEL        0x00000001


/***************************************************************************
 *
 * DEBUG stuff
 *
 ***************************************************************************/
#ifdef IS_32
    extern void __cdecl PF (LPSTR szFormat, ...);
    #ifdef DEBUG
        extern void __cdecl DPF(LPSTR szFormat, ...);
        #define BREAK()     DebugBreak();
    #else
        #define DPF         1 ? (void)0 : (void)
        #define BREAK()
    #endif
#else  // !IS_32
    #define PF          1 ? (void)0 : (void)
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif  // !IS_32

#ifdef WINNT
//
// WINNT Only:
// Need to declare these with "C" linkage so we can call them from the display
// driver.
//
// Function prototypes. One time DX6 Init/Destroy code. This is the 32 bit ddraw init code.
// Found in $(BUILDDIR)\main\drivers\ddraw\common\src\ddDrv.cpp
//
BOOL  __stdcall buildDDHALInfo32(GLOBALDATA *pDriverData);
DWORD __stdcall DriverInit(DWORD dwDriverData);
HRESULT __stdcall DestroyDriver32(GLOBALDATA *pGlobalData);
void  __stdcall init_globals(void);
void  __stdcall NvWin2KInitIPM();
void  __stdcall NvWin2KInitDXGlobals();
void  __stdcall NvWin2KInitDXState(PDEV *ppdev);
BOOL  __stdcall NvWin2KD3DHALCreateDriver(DD_HALINFO *pHalInfo, PDEV *ppdev);
BOOL  __stdcall NvWin2KAllocDriverData(PDEV* ppdev);
void  __stdcall NvWin2KpvmConfig(PDEV *ppdev, VIDEOMEMORY *pvmList);
DWORD __stdcall NvWin2KMapAgpHeap(PDEV *ppdev);
DWORD __stdcall NvWin2KGetAgpLimit(PDEV *ppdev, DWORD dwRootHandle, DWORD dwDevID);
DWORD __stdcall NvWin2KUnmapAgpHeap(PDEV *ppdev);

extern GLOBALDATA  DefaultGlobalData;
extern ENGSAFESEMAPHORE NvSem;
#define NvAcquireSemaphore(pGblData)                \
{                                                   \
    if ((pGblData) && !((pGblData)->NvSemRefCnt))   \
    {                                               \
        EngAcquireSemaphore(NvSem.hsem);            \
    }                                               \
    (pGblData)->NvSemRefCnt++;                      \
}
#define NvReleaseSemaphore(pGblData)            \
{                                               \
    if ((pGblData) && (pGblData)->NvSemRefCnt)  \
    {                                           \
        (pGblData)->NvSemRefCnt--;              \
        if (!((pGblData)->NvSemRefCnt))         \
        {                                       \
            EngReleaseSemaphore(NvSem.hsem);    \
        }                                       \
    }                                           \
}
#else   // Win9x
#define NvAcquireSemaphore(pGblData)
#define NvReleaseSemaphore(pGblData)
#endif

/*
 * This is the error return value from the DX heap manager allocation functions.
 * It is defined differently under Win2K since the DX heap manager returns an
 * offset rather than an address, which makes 0 a valid offset rather than an
 * error code.
 */
#ifndef WINNT
#define ERR_DXALLOC_FAILED 0
#else
#define ERR_DXALLOC_FAILED 0xffffffff
#endif

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\ESCAPE.H ===
/*****************************************************************************
 *                                                                           *
 *                                 ESCAPE.H                                  *
 *                                                                           *
 *    A file to gather all the miscellaneous Escape() codes implemented in   *
 *    the GDI driver.                                                        *
 *                                                                           *
 *                 Copyright (C) 1999, Nvidia Coporation                     *
 *                                                                           *
 *                                                                           *
 * Any escape that begins NV_ESC_XXX or GN_ESC_XXX can be changed since      *
 * these are private escapes between different driver components. Any other  *
 * escapes are system defined values and shouldn't be changed.               *
 *****************************************************************************/

#ifndef _ESCAPE_H_
#define _ESCAPE_H_

//*****************************************************************************
// Pulled from hwspec/code/hwcntrl.asm

#define NV_ESC_DVD_MACROVISION_CMD              0x6979

#define     MACROVISION_OFF                     0
#define     MACROVISION_AGC_ONLY                1
#define     MACROVISION_TWO_STRIPES_PLUS_AGC    2
#define     MACROVISION_FOUR_STRIPES_PLUS_AGC   3

//*****************************************************************************
// Hide these for WINNT miniport builds to avoid conflict with nv4_ref.h

#ifndef WINNT
#define     NV_PRAMDAC_TEST_CONTROL             0x680608
#define     NV_PRAMDAC_CHECKSUM                 0x68060C
#endif

    typedef struct _tagMACROVISION_INFO {
        unsigned long   dwMacrovisionNavigatorID;
        unsigned long   dwMacrovisionData;
    }   MACROVISION_INFO;


//*****************************************************************************
// Pulled from hwspec/code/hwcntrl.asm
#define NV_ESC_INTEL_DIAG                       0x6E77      // 'nv' + 1

#define     IDIAG_OPEN_INTERFACE                0
#define     IDIAG_CLOSE_INTERFACE               1
#define     IDIAG_GET_ERROR_CODE                2
#define     IDIAG_GET_CRC                       3
#define     IDIAG_GET_DRIVER_INFO               4
#define     IDIAG_GET_MEMORY_INFO               5
#define     IDIAG_GET_CLOCK_RATES               6
#define     IDIAG_GET_PCI_CONFIG                7
#define     IDIAG_GET_BUS_CONFIG                8

#define     IDIAG_ERROR_NONE                    0
#define     IDIAG_ERROR_GENERIC                 1
#define     IDIAG_ERROR_INVALID_PARAM           2
#define     IDIAG_ERROR_NOT_SUPPORTED           3


//*****************************************************************************
// Pulled from tools/sdk/win32/include/winerror.h
#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS                    0L
#endif
#define ERROR_INVALID_FUNCTION           1L
#define ERROR_INVALID_DATA               13L
#define ERROR_BAD_COMMAND                22L
#define ERROR_INVALID_PARAMETER          87L


//*****************************************************************************
// Added to enable alpha blended color cursors
#define NV_ESC_GET_CURSOR_ALPHA             0x6E78      // 'nv' + 2
#define NV_ESC_SET_CURSOR_ALPHA             0x6E79      // 'nv' + 3

//*****************************************************************************
// Added to test mode switching by OpenGL or anything else that uses the counter
#define NV_ESC_INC_MODE_SWITCH              0x6E7A      // 'nv' + 4

//*****************************************************************************
// Pulled from common/win9x/inc/GNPDEV.H
// The generic non-Windows defined escapes we support are:
// For GETPDEVICE, the first DWORD pointed to by lpOut will get a linear
// address of the PDEVICE and the second DWORD gets a 16:16 ptr to the
// PDEVICE.
#define GN_ESC_GET_PDEVICE                  0x6E7B
#define GETPDEVICE                          GN_ESC_GET_PDEVICE

// The lpIn argument should point to 2 DWORDS.  The first DWORD is the
// linear base address the newly allcated seelctor should get. The
// second DWORD specifies the limit of the selector. The return value
// is a 16bit WORD that is placed where lpOut points to. The 16bit value
// is the newly allocated slector. It is 0 if the routine failed.
#define GN_ESC_ALLOC_SELECTOR_AND_MAP       0x6E7C

// The first 16 bit WORD pointed to by lpIn has the selector to free.
#define GN_ESC_UNMAP_AND_FREE_SELECTOR      0x6E7D

// If lpIn is NULL, then this is a query type call and lpOut points to
// a dword that returns the number of modes in the registry list. If lpIn
// is not NULL, then it points to one of the following three values
// (defined in modeext.h) MODETYPE_MODEENTRYNORR, MODETYPE_MODEENTRY,
// or MODETYPE_MODEENTRYANDPITCH. lpOut points to an array of
// MAX_MODEENTRYS structures of the format specified by the lpIn
// parameter (i.e. either MODEENTRYNORR, MODEENTRY, or MODEENTRYANDPITCH.)
// The list of modes will be placed into this lpOut buffer. If the
// routine fails, the return code is 0; if it succeeeds, it returns 1.
#define NV_ESC_GET_REGISTRY_MODE_LIST       0x6E7E

// This escape gets the local base path in the registry to be used
// by driver components wishing to write board specific info into the
// registry. How to use the string returned by this escape is discussed
// in ....drivers\common\nv4\inc\nvreg.h. The lpOut parameter points
// to a buffer that is at least 128 characters in length.
// The first DWORD in lpOut is one one of the predefined registry keys
// like HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER, etc. Starting right
// after the first dword is a string which is the registry path.
// NOTE: You have to issue the escape to the correct display driver in
// a multi-mon scenario. How do you know which one? There is code in
// the DirectX driver which shows how to get the correct display HDC.
#define NV_ESC_GET_LOCAL_REGISTRY_PATH      0x6E7F

// This escape indicates that we are running on an NVidia board/driver
// combination. It returns this escape value as a dword pointed to by
// lpOut argument of the escape call. The second dword pointed to by
// the lpOut argument is the NVidia device number that the display
// driver is talking to -- this is a 1 based number. The third dword
// pointed to by lpOut is a physical CRTC index. Don't use this right
// now -- it is just for testing purposes.
#define NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER   0x6E80

// This escape will fill in the following structure into the memory
// area pointed to by the lpOut argument to the escape call.
#define NV_ESC_GET_HARDWARE_POINTERS        0x6E81

typedef struct  tagHARDWAREPOINTERS
{
    unsigned long   lp16FrameBuffer;        // 16:16 ptr to frame buffer
    unsigned long   lp32FrameBuffer;        // flat  ptr to frame buffer
    unsigned long   lp16Chip;               // 16:16 ptr to chip space
    unsigned long   lp32Chip;               // flat  ptr to chip space
} HARDWAREPOINTERS;

// This escape will get a flat ptr to the shared DirectX data. It
// is returned as the first dword of the lpOut parameter.
#define NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA 0x6E82

// This escape will validate a mode on a given display device.
// The lpIn ptr will point to the following structure.  The
// Escape will always return TRUE. lpOut points to a dword. If
// the requested mode can be set on the specified device then
// the dword pointed to by lpOut will be set to 1. If the mode
// cannot be set on the device, the dword will be 0. The
// dwDeviceType field in the structure can be one of the
// MONITOR_TYPE_XXXX constants in nvcm.h.
#define NV_ESC_VALIDATE_DEVICE_MODE         0x6E83

typedef struct  tagVALMODEEXT
{
    unsigned long   dwHRes;
    unsigned long   dwVRes;
    unsigned long   dwBpp;
    unsigned long   dwDeviceType;
} VALMODEXT;

// This escape is used to inform the display driver what the
// desired output device should be on the next modeset. The
// lpIn parameter should point to the following structure.
// The dwSuccessFlag is ignored for this escape (can be 0.) The
// lpOut parameter should point to a dword which will be set
// to a 1 if the display driver successfully handles the escape
// and 0 if the display driver could not handle the call.
// The escape call itself will always return non-0 if the
// display driver recieved the escape.
// The dwDeviceType holds one of the MONITOR_TYPE_XXXX constants
// defined in nvcm.h. If dwDeviceType is either the NTSC or PAL
// type, then dwTvFormat will be one of the specific NTSC or PAL
// formats specified in nvcm.h like NTSC_M, NTSC_J, PAL_A etc.
#define NV_ESC_SET_DISPLAY_DEVICE_TYPE      0x6E84

// This escape is used to get from the display driver what the
// current output device actually is. The lpOut parameter should
// point to the following structure. Upon returning, the dwSuccessFlag
// will be non-0 if the display driver successfully filled in the
// dwDeviceType and dwTvFormat fields with the current device type
// and tv format respectively. Otherwise, it will hold FALSE.
// The escape call itself will always return non-0 if the
// display driver recieved the escape.
// The dwDeviceType will hold one of the MONITOR_TYPE_XXXX constants
// defined in nvcm.h. If dwDeviceType is either the NTSC or PAL
// type, then dwTvFormat will be one of the specific NTSC or PAL
// formats specified in nvcm.h like NTSC_M, NTSC_J, PAL_A etc.
#define NV_ESC_GET_DISPLAY_DEVICE_TYPE      0x6E85

typedef struct  tagSETGETDEVTYPE
{
    unsigned long   dwSuccessFlag;
    unsigned long   dwDeviceType;
    unsigned long   dwTvFormat;
} SETGETDEVTYPE;


// Escape used to get the current refresh rate from the display driver

#define NV_ESC_GET_REFRESH_INFO             0x6E86

// lpIn = NULL
// lpOut points to DWORD to receive the current refresh rate as follows:
// (-1) = Optimal
//  0   = Adapter Default
// Any other value represents the actual refresh rate in use


// This escape will allow 32 bit code to call SetCursor() directly,
// bypassing GDI and the goofyness inherent in it.  16 bit code can
// find the SetCursor entry point (ordinal 102 in the display driver).
//
// lpIn = pointer to a genuine cursor structure
//
// Note: this allows 32x32, 64x64 (and 32x64 & 64x32) cursors if the
// hardware permits it.  Also, in debug builds, pixel depths of 33 and
// 34 will expose the ARGB and premultiplied ARGB (where available).

#define GN_ESC_SET_CURSOR                   0x6E87

#ifdef WINNT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88

// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif // WINNT

// lpIn pointer to a 32bit value that has the amount of memory
//      to allocate
// lpOut pointer to a 32bit value that is the flat ptr to the
//      block of memory that is at least as large as requested.
// The escape itself always returns TRUE. If the allocation is
// successful, lpOut will return pointing to a non-NULL value.
// NULL value indicates that the alloc failed. The alloc escape
// always allocates CACHED memory above 2Gig (SHARED memory).

// This escape allocates memory through the RM.
// lpIn should point to the following structure.
// The objectID should be a uniqueID for the object that the
// RM will associate with the memory block. This objectID will
// need to get passed back in to free the memory block.
// dwAllocFlags are things like NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS
// specified in nvos.h
// lpOut should point to a dword which will get filled in with
// a ptr to a memory block of the size requested or NULL if the
// allocation was unsuccessful.
// The Escape itself will always return TRUE.
#define NV_ESC_ALLOC_MEMORY                 0x6E8A
typedef struct  _ESC_ALLOC_MEMORY
{
    unsigned long   dwObjectID;
    unsigned long   dwAllocFlags;
    unsigned long   dwNumBytes;
}   ESC_ALLOC_MEMORY;


// This escape always returns TRUE.
// This escape frees memory allocated by a previous call to
// NV_ESC_ALLOC_MEMORY.
// lpIn should point to the following structure.
// lpOut is not used.
#define NV_ESC_FREE_MEMORY                  0x6E8B
typedef struct  _ESC_FREE_MEMORY
{
    unsigned long   dwObjectID;
}   ESC_FREE_MEMORY;


// This is identical to the NV_ESC_GET_REGISTRY_MODE_LIST escape,
// EXCEPT that the list only contains desktop modes. No DDRAW only
// modes are included.
#define NV_ESC_GET_REGISTRY_DESKTOP_MODE_LIST   0x6E8C


// This escape allocates shared memory.
// lpIn should point to an ESC_ALLOC_SHARED_MEMORY_IN structure.
// dwNumBytes should be the size in bytes of the desired
// memory block. dwID can be used to request a ptr to the
// memory block at a later date.
// lpOut should point to an ESC_ALLOC_MEMORY_OUT structure.
// pMemBlock will be a flat pointer to the memory block.
// The Escape itself will always return TRUE.
#define NV_ESC_ALLOC_SHARED_MEMORY  0x6E8D
typedef struct  _ESC_ALLOC_SHARED_MEMORY_IN
{
    unsigned long   dwNumBytes;
    unsigned long   dwID;
}   ESC_ALLOC_SHARED_MEMORY_IN;

typedef struct  _ESC_ALLOC_SHARED_MEMORY_OUT
{
    unsigned long   pMemBlock;
}   ESC_ALLOC_SHARED_MEMORY_OUT;

// This escape frees memory allocated by a previous call to
// NV_ESC_ALLOC_SHARED_MEMORY.
// lpIn should point to an _ESC_FREE_SHARED_MEMORY_IN structure.
// dwID should be an ID that was passed in to some prior ALLOC.
// lpOut should point to an _ESC_FREE_SHARED_MEMORY_OUT structure.
// If TRUE, the dwSuccess field indicates the the memory block
// assoictaed with the dwID passied in was freed.
// This escape always returns TRUE.
#define NV_ESC_FREE_SHARED_MEMORY   0x6E8E
typedef struct  _ESC_FREE_SHARED_MEMORY_IN
{
    unsigned long   dwID;
}   ESC_FREE_SHARED_MEMORY_IN;

typedef struct  _ESC_FREE_SHARED_MEMORY_OUT
{
    unsigned long   dwSuccess;
}   ESC_FREE_SHARED_MEMORY_OUT;

// This escape gets a ptr to a previsouly allocated shared
// memory block.
// lpIn should point to an _ESC_GET_SHARED_MEMORY_IN structure.
// dwID should be an ID that was passed in to some prior ALLOC.
// lpIn should point to an _ESC_GET_SHARED_MEMORY_OUT structure.
// This escape always returns TRUE.
#define NV_ESC_GET_SHARED_MEMORY    0x6E8F
typedef struct  _ESC_GET_SHARED_MEMORY_IN
{
    unsigned long   dwID;
}   ESC_GET_SHARED_MEMORY_IN;

typedef struct  _ESC_GET_SHARED_MEMORY_OUT
{
    unsigned long   pMemBlock;
}   ESC_GET_SHARED_MEMORY_OUT;


//*****************************************************************************
// Pulled from hwspec/code/hwcntrl.asm
#define NV_ESC_DMAPUSHMODESWITCHCOUNT       0x6E90

// Also found in OpenGL/nv/nvInit.c
#define NV_ESC_GETAGPBASE                   0x6E91
#define NV_ESC_GETACTIVECHANNELPTR          0x6E92


//*****************************************************************************
// Added for PGC (aka SLI) communications between multimonitor instances of the
// GDI driver. Can be also used to pull information about PGC drivers. The
// actual action is specified by the command field in the lpIn parameter.
#define NV_ESC_PGC_COMMAND                  0x6E93

//*****************************************************************************
//
// NV11 TwiNView escape for controlling dual CRTC functionality
//

#define NV_ESC_SETGET_TWINVIEW_DATA         0x6E94
#include "nvMultiMon.h" // Contains all definitions and structures used in the NV_ESC_SETGET_TWINVIEW_DATA escape call.

#define NV_ESC_ENABLE_DISABLE_SOFTWARE_CURSOR 0x6E95

// For both of these escapes the lpOut ptr points to a DWORD.
// For SET, the driver will get this dword and save it.
// For GET, the driver will place the cpl dword where lpOut points.
// The lpIn argument is not used.
#define NV_ESC_SET_CPL_DWORD                0x6E96
#define NV_ESC_GET_CPL_DWORD                0x6E97

#ifndef NV_SIGNATURE
// This value also is defined in driver.h of display driver
#define NV_SIGNATURE 0x11223344
#endif

#ifndef NV_ESC_PRIMARY_INFO
#define NV_ESC_PRIMARY_INFO 0x7104
typedef struct _NV_PRIMARY_INFO
{
    unsigned long ulNVSignature;   // IN
    unsigned long ulNumDevices;    // IN
    unsigned long ulHeadNum;       // IN
    unsigned long ulReturnCode;    // OUT from display driver
    unsigned long ulWidth;         // OUT from display driver
    unsigned long ulHeight;        // OUT from display driver
    unsigned long ulDepth;         // OUT from display driver
    unsigned long ulPitch;         // OUT from display driver
    unsigned long ulPrimaryOffset; // OUT from display driver
    unsigned long ulNumDACs;       // OUT from display driver (NT only)
    unsigned long ulNumActiveDACs; // OUT from display driver
    unsigned long ulActiveDACs;    // OUT from display driver (NT only)
    unsigned long ulPanningPtr;    // OUT from display driver (9x only)
    unsigned long ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO;
#endif

#ifndef ESC_NV_QUERY_HEAD_REFRESH_RATE
#define ESC_NV_QUERY_HEAD_REFRESH_RATE 0x7106
#endif

//*****************************************************************************
//
// PGC subcommands and corresponding structures
//
#ifndef WINNT
typedef struct _MYPGCCMD
{
    unsigned long dwCommand;
    unsigned long dwParam1;
    unsigned long dwParam2;
} MYPGCCMD;

#define PGC_CONNECT_GDI 1

#endif  // WINNT

//*****************************************************************************
//
// Formerly common/win9x/inc/OPENGL.H
//
#ifndef WINNT       // These are redefined in the NT tree
// From common/win9x/inc/opengl.h
// These escape values are fixed by Windows
#define OPENGL_CMD                          4352
#define OPENGL_GETINFO                      4353

#define     OPENGL_GETINFO_DRVNAME              0

#define     OPENGL_ICD_VER                      2
#define     OPENGL_DRIVER_VER                   0x10000     // Version 1.0000

#define     OPENGL_KEY_NAME                     "RIVATNT"

    typedef struct {
        unsigned long   ulVersion;
        unsigned long   ulDriverVersion;
        unsigned char   awch[ 129 ];
    } OPENGL_INFO;

#endif  // WINNT

#endif  // _ESCAPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\nv332.h ===
/***** Notification Status Values *****/
/*
 * NV sets NvNotification.status to NV_STATUS_DONE_OK if the operation
 * succeeded.
 */
#define NV_STATUS_DONE_OK          0



/* class NV_CONTEXT_ERROR_TO_MEMORY */
#define  NV_CONTEXT_ERROR_TO_MEMORY                      (0xFF5)
/* NvNotification[] elements */
#define NVFF5_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFF5_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF5_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF5_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} Nvff5Typedef, NvContextErrorToMemory;
#define NVFF5_TYPEDEF                                    NvContextErrorToMemory
/* dma method offsets, fields, and values */
#define NVFF5_SET_OBJECT                                 (0x00000000)
#define NVFF5_NO_OPERATION                               (0x00000100)
#define NVFF5_NOTIFY                                     (0x00000104)
#define NVFF5_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF5_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF5_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF5_SET_DMA_SPECIFIER                          (0x00000300)


/* class NV_VIDEO_COLOR_KEY */
#define  NV_VIDEO_COLOR_KEY                              (0xFF6)
/* NvNotification[] elements */
#define NVFF6_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFF6_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF6_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput[3];        /* NV1_PATCHCORD_VIDEO               0204-020b*/
 V032 Reserved02[0x03c];
 V032 SetColorFormat;          /* NVFF6_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColorKey;             /* color to compare with             0304-0307*/
 V032 SetPoint;                /* y_x, S16_S16 in pixels, top-left  0308-030b*/
 V032 SetSize;                 /* height_width U16_U16 in pixels    030c-030f*/
 V032 Reserved03[0x73c];
} Nvff6Typedef, NvVideoColorKey;
#define NVFF6_TYPEDEF                                    NvVideoColorKey
/* dma method offsets, fields, and values */
#define NVFF6_SET_OBJECT                                 (0x00000000)
#define NVFF6_NO_OPERATION                               (0x00000100)
#define NVFF6_NOTIFY                                     (0x00000104)
#define NVFF6_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF6_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF6_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF6_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF6_SET_VIDEO_INPUT                            (0x00000204)
#define NVFF6_SET_COLOR_FORMAT                           (0x00000300)
#define NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8                (0x00000001)
#define NVFF6_SET_COLOR_FORMAT_LE_X24Y8                  (0x00000002)
#define NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5            (0x00000003)
#define NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5              (0x00000004)
#define NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5              (0x00000005)
#define NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8               (0x00000006)
#define NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8               (0x00000007)
#define NVFF6_SET_COLOR_FORMAT_LE_A16Y16                 (0x00000008)
#define NVFF6_SET_COLOR_FORMAT_LE_X16Y16                 (0x00000009)
#define NVFF6_SET_COLOR_KEY                              (0x00000304)
#define NVFF6_SET_POINT                                  (0x00000308)
#define NVFF6_SET_POINT_X                                15:0
#define NVFF6_SET_POINT_Y                                31:16
#define NVFF6_SET_SIZE                                   (0x0000030C)
#define NVFF6_SET_SIZE_WIDTH                             15:0
#define NVFF6_SET_SIZE_HEIGHT                            31:16


/* class NV_VIDEO_SCALER */
#define  NV_VIDEO_SCALER                                 (0xFF7)
/* NvNotification[] elements */
#define NVFF7_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFF7_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF7_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x03e];
 V032 SetDeltaDuDx;            /* S12d20 ratio du/dx                0300-0303*/
 V032 SetDeltaDvDy;            /* S12d20 ratio dv/dy                0304-0307*/
 V032 SetPoint;                /* y_x S16_S16 in pixels, top-left   0308-030b*/
 V032 Reserved03[0x73d];
} Nvff7Typedef, NvVideoScaler;
#define NVFF7_TYPEDEF                                    NvVideoScaler
/* dma method offsets, fields, and values */
#define NVFF7_SET_OBJECT                                 (0x00000000)
#define NVFF7_NO_OPERATION                               (0x00000100)
#define NVFF7_NOTIFY                                     (0x00000104)
#define NVFF7_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF7_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF7_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF7_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF7_SET_VIDEO_INPUT                            (0x00000204)
#define NVFF7_SET_DELTA_DU_DX                            (0x00000300)
#define NVFF7_SET_DELTA_DV_DY                            (0x00000304)
#define NVFF7_SET_POINT                                  (0x00000308)
#define NVFF7_SET_POINT_X                                15:0
#define NVFF7_SET_POINT_Y                                31:16


/* class NV_VIDEO_FROM_MEMORY */
#define  NV_VIDEO_FROM_MEMORY                            (0xFF8)
/* NvNotification[] elements */
#define NVFF8_NOTIFIERS_NOTIFY                           (0)
#define NVFF8_NOTIFIERS_IMAGE_SCAN(b)                    (1+(b))
#define NVFF8_NOTIFIERS_GET_OFFSET_NOTIFY(b)             (3+(b))
/* NvNotification[] fields and values */
#define NVFF8_NOTIFICATION_INFO16_BUFFER_NOT_STARTED     (0x0001)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_OFFSET_VALID    (0x0002)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_DONE            (0x0003)
#define NVFF8_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_PATCH        (0x0400)
#define NVFF8_NOTIFICATION_STATUS_WARNING_INVALID_DATA   (0x0001)
#define NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF8_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NVFF8_STOP_TRANSFER_VALUE         0108-010b*/
 V032 SetPatch;                /* NVFF8_SET_PATCH_*                 010c-010f*/
 V032 Reserved00[0x01c];
 V032 SetImageNotifyCtxDma;    /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetImageCtxDma[2];       /* NV1_CONTEXT_DMA_FROM_MEMORY       0184-018b*/
 V032 Reserved01[0x01d];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 Reserved02[0x03f];
 struct {                      /* start of methods in array         0300-    */
  U032 offset;                 /* byte offset of top-left pixel       00-  03*/
  U032 pitch;                  /* bytes, vertical pixel delta         04-  07*/
  V032 size;                   /* height_width U16_U16 in pixels      08-  0b*/
  V032 format;                 /* field_color V16_V16                 0c-  0f*/
  V032 notify;                 /* NVFF8_IMAGE_SCAN_NOTIFY_*           10-  13*/
 } ImageScan[2];               /* end of methods in array               -0327*/
 V032 GetOffsetNotify[2];      /* NVFF8_GET_OFFSET_NOTIFY_*         0328-032f*/
 V032 Reserved03[0x734];
} Nvff8Typedef, NvVideoFromMemory;
#define NVFF8_TYPEDEF                                    NvVideoFromMemory
/* dma method offsets, fields, and values */
#define NVFF8_SET_OBJECT                                 (0x00000000)
#define NVFF8_NO_OPERATION                               (0x00000100)
#define NVFF8_NOTIFY                                     (0x00000104)
#define NVFF8_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF8_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF8_STOP_TRANSFER                              (0x00000108)
#define NVFF8_STOP_TRANSFER_VALUE                        (0x00000000)
#define NVFF8_SET_PATCH                                  (0x0000010C)
#define NVFF8_SET_PATCH_INVALIDATE                       (0x00000000)
#define NVFF8_SET_PATCH_VALIDATE                         (0x00000001)
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF8_SET_CONTEXT_DMA_IMAGE                      (0x00000184)
#define NVFF8_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF8_IMAGE_SCAN                                 (0x00000300)
#define NVFF8_IMAGE_SCAN_OFFSET                          (0x00000300)
#define NVFF8_IMAGE_SCAN_PITCH                           (0x00000304)
#define NVFF8_IMAGE_SCAN_SIZE                            (0x00000308)
#define NVFF8_IMAGE_SCAN_SIZE_WIDTH                      15:0
#define NVFF8_IMAGE_SCAN_SIZE_HEIGHT                     31:16
#define NVFF8_IMAGE_SCAN_FORMAT                          (0x0000030C)
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR                    15:0
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8              (0x00000001)
#define NV_VFM_FORMAT_COLOR_LE_Y8_P4                      0x00000001
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8      (0x00000002)
#define NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8                   0x00000002
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8      (0x00000003)
#define NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8                   0x00000003
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5       (0x00000004)
#define NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2                0x00000004
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5          (0x00000005)
#define NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2                  0x00000005
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8     (0x00000006)
#define NV_VFM_FORMAT_COLOR_LE_X8R8G8B8                   0x00000006
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD                    31:16
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_PROGRESSIVE        (0x00000001)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_EVEN_FIELD         (0x00000002)
#define NV_VFM_FORMAT_NEXT_FIELD_EVEN                     0x00000002
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_ODD_FIELD          (0x00000003)
#define NV_VFM_FORMAT_NEXT_FIELD_ODD                      0x00000003
#define NVFF8_IMAGE_SCAN_SET_NOTIFY                      (0x00000310)
#define NVFF8_IMAGE_SCAN_NOTIFY                          31:0
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
#define NVFF8_GET_OFFSET_NOTIFY                          (0x00000328)
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
#define NVFF8_SET_VIDEO_OUTPUT_PARAM(s)                  (0x00040200+8192*(s))
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES_PARAM(s)          (0x00040180+8192*(s))
#define NVFF8_IMAGE_SCAN_PARAM(s,b)                      (0x00140300+8192*(s)+\
                                                                     20*(b))


/* class NV_VIDEO_COLORMAP */
#define  NV_VIDEO_COLORMAP                               (0xFF9)
/* NvNotification[] elements */
#define NVFF9_NOTIFIERS_NOTIFY                           (0)
#define NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY            (1)
/* NvNotification[] fields and values */
#define NVFF9_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF9_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 SetColormapCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY        0184-0187*/
 V032 Reserved01[0x01e];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x040];
 U032 SetColormapStart;        /* offset in bytes                   0308-030b*/
 U032 SetColormapLength;       /* in bytes                          030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update         0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, starts transfer         0314-0317*/
 V032 Reserved03[0x73a];
} Nvff9Typedef, NvVideoColormap;
#define NVFF9_TYPEDEF                                    NvVideoColormap
/* dma method offsets, fields, and values */
#define NVFF9_SET_OBJECT                                 (0x00000000)
#define NVFF9_NO_OPERATION                               (0x00000100)
#define NVFF9_NOTIFY                                     (0x00000104)
#define NVFF9_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF9_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF9_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF9_SET_CONTEXT_DMA_COLORMAP                   (0x00000184)
#define NVFF9_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF9_SET_VIDEO_INPUT                            (0x00000204)
#define NVFF9_SET_COLORMAP_START                         (0x00000308)
#define NVFF9_SET_COLORMAP_LENGTH                        (0x0000030C)
#define NVFF9_COLORMAP_DIRTY_START                       (0x00000310)
#define NVFF9_COLORMAP_DIRTY_LENGTH                      (0x00000314)
#define NVFF9_SET_VIDEO_OUTPUT_PARAM(s)                 (0x00040200+8192*(s))
#define NVFF9_SET_CONTEXT_DMA_NOTIFIES_PARAM(s)         (0x00040180+8192*(s))
#define NVFF9_SET_COLORMAP_START_PARAM(s)               (0x00040308+8192*(s))


/* class NV_VIDEO_SINK */
#define  NV_VIDEO_SINK                                   (0xFFA)
/* NvNotification[] elements */
#define NVFFA_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFA_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFA_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFA_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoInput[64];       /* NV1_PATCHCORD_VIDEO               0200-02ff*/
 V032 Reserved02[0x740];
} NvffaTypedef, NvVideoSink;
#define NVFFA_TYPEDEF                                    NvVideoSink
/* dma method offsets, fields, and values */
#define NVFFA_SET_OBJECT                                 (0x00000000)
#define NVFFA_NO_OPERATION                               (0x00000100)
#define NVFFA_NOTIFY                                     (0x00000104)
#define NVFFA_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFA_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFA_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFA_SET_VIDEO_INPUT                            (0x00000200)


/* class NV_PATCHCORD_VIDEO */
#define  NV_PATCHCORD_VIDEO                              (0xFFB)
/* NvNotification[] entries, values, errors, warnings */
#define NVFFB_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} NvffbTypedef, NvPatchcordVideo;
#define NVFFB_TYPEDEF                                    NvPatchcordVideo


/* class NV_CONTEXT_DMA_IN_MEMORY */
#define  NV_CONTEXT_DMA_IN_MEMORY                        (0xFFC)
/* NvNotification[] elements */
#define NVFFC_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFC_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFC_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFC_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* On X86 address[1] is the selector    0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffcTypedef, NvContextDmaInMemory;
#define NVFFC_TYPEDEF                                    NvContextDmaInMemory
/* dma method offsets, fields, and values */
#define NVFFC_SET_OBJECT                                 (0x00000000)
#define NVFFC_NO_OPERATION                               (0x00000100)
#define NVFFC_NOTIFY                                     (0x00000104)
#define NVFFC_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFC_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFC_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFC_SET_DMA_SPECIFIER                          (0x00000300)


/* class NV_CONTEXT_DMA_TO_MEMORY */
#define  NV_CONTEXT_DMA_TO_MEMORY                        (0xFFD)
/* NvNotification[] elements */
#define NVFFD_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFD_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFD_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFD_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffdTypedef, NvContextDmaToMemory;
#define NVFFD_TYPEDEF                                    NvContextDmaToMemory
/* dma method offsets, fields, and values */
#define NVFFD_SET_OBJECT                                 (0x00000000)
#define NVFFD_NO_OPERATION                               (0x00000100)
#define NVFFD_NOTIFY                                     (0x00000104)
#define NVFFD_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFD_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFD_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFD_SET_DMA_SPECIFIER                          (0x00000300)


/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define  NV_CONTEXT_DMA_FROM_MEMORY                      (0xFFE)
/* NvNotification[] elements */
#define NVFFE_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFE_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFE_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFE_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffeTypedef, NvContextDmaFromMemory;
#define NVFFE_TYPEDEF                                    NvContextDmaFromMemory
/* dma method offsets, fields, and values */
#define NVFFE_SET_OBJECT                                 (0x00000000)
#define NVFFE_NO_OPERATION                               (0x00000100)
#define NVFFE_NOTIFY                                     (0x00000104)
#define NVFFE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFE_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFE_SET_DMA_SPECIFIER                          (0x00000300)
#define NVFFE_SET_DMA_SPECIFIER_LIMIT                    (0x00000308)


/* class NV_CLASS */
#define  NV_CLASS                                        (0xFFF)
/* NvNotification[] elements */
#define NVFFF_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFF_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFF_NOTIFICATION_STATUS_WARNING_UNAVAILABLE    (0x0002)
#define NVFFF_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFF_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 V032 Create;                  /* 32-bit handle of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit handle of object           0304-0307*/
 V032 Reserved02[0x73e];
} NvfffTypedef, NvClass;
#define NVFFF_TYPEDEF                                    NvClass
/* dma method offsets, fields, and values */
#define NVFFF_SET_OBJECT                                 (0x00000000)
#define NVFFF_NO_OPERATION                               (0x00000100)
#define NVFFF_NOTIFY                                     (0x00000104)
#define NVFFF_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFF_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFF_CREATE_OFFSET                              (0x00000300)
#define NVFFF_DESTROY_OFFSET                             (0x00000304)
#define NVFFF_CREATE(s)                                  (0x00000300+8192*(s))
#define NVFFF_CREATE_PARAM(s)                            (0x00040300+8192*(s))
#define NVFFF_DESTROY(s)                                 (0x00000304+8192*(s))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\h2inc.h ===
/******************************************************************************
 *                                                                            *
 *  H2INC.H  - A file used to help H2INC deal with complex header files.      *
 *                                                                            *
 ******************************************************************************/

#ifndef _H2INC_H        // Try not to include this file twice
#define _H2INC_H

#ifdef  H2INC           // Only include this file if it is in H2INC (-DH2INC on command line)

typedef unsigned long   DWORD;
typedef unsigned short  WORD;
typedef unsigned char   BYTE;

#endif //  H2INC
#endif // _H2INC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\NVDD.H ===
#ifndef _NVDD_
#define _NVDD_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       nvdd.h
 *  Content:    header for NVidia Windows 95 Direct Draw driver
 *
 ***************************************************************************/

#ifndef NVARCH
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

#if(NVARCH < 0x4)
#define CDriverContext GLOBALDATA
#pragma warning(disable:4005) //macro redefinition warning/error
#endif

// force write combine and put
#ifdef NVSPEAK
// obsolete - use nvPusherStart
#else //!NVSPEAK
#define NVDD_FLUSH_AND_PUT(putAddress) \
    { pDriverData->NvDmaPusherBufferEnd[0] += putAddress[0]; \
      _outp (0x3d0,0); \
      npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2; }
#endif //!NV_SPEAK

#define NVFAR FAR

#define FAST register

#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)


typedef struct {
    unsigned long offset;
    unsigned short selector;
} NVFP;

#define NVLP2FP(NVFAR_POINTER, USHORT_POINTER) \
    {   \
        NVFP *fptemp = (NVFP *)&(NVFAR_POINTER); \
         fptemp->selector = (USHORT_POINTER)[1]; \
        fptemp->offset = (USHORT_POINTER)[0]; \
    }


#define CLOSE_HANDLE(h) CloseHandle(h)
//#define CLOSE_HANDLE(h) (1)

#ifdef NVD3D

typedef struct {
    short   x;
    short   y;
} NVXY;

typedef struct {
    unsigned short w;
    unsigned short h;
} NVWH;


typedef union {
    long xy;
    unsigned long wh;
    NVXY xy16;
    NVWH wh16;
} NVCOORD;

#endif

#ifdef WINNT
    extern PDEV *ppdev;
    #define nvSetDriverDataPtrFromDDGbl(pDDGbl) {                                                                   \
        NvAcquireSemaphore((CDriverContext *)(((PDEV *)(((PDD_DIRECTDRAW_GLOBAL)(pDDGbl))->dhpdev))->pDriverData))  \
        ppdev       = ((PDEV *)(((PDD_DIRECTDRAW_GLOBAL)(pDDGbl))->dhpdev));                                        \
        pDriverData = (CDriverContext *)(ppdev->pDriverData);                                                       \
        pDriverData->dwDDGlobal = (DWORD)(pDDGbl);                                                                  \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
    #define nvSetDriverDataPtrFromContext(pContext) {                                                               \
        NvAcquireSemaphore((pContext)->pDriverData)                                                                 \
        ppdev       = (pContext)->ppdev;                                                                            \
        pDriverData = (pContext)->pDriverData;                                                                      \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
#else // !WINNT
    #include "dxshare.h"
    extern DISPDRVDIRECTXCOMMON *pDXShare;
    #define nvSetDriverDataPtrFromDDGbl(pDDGbl) {                                                                   \
        pDXShare         = (DISPDRVDIRECTXCOMMON *)((pDDGbl)->dwReserved3);                                         \
        pDriverData      = (CDriverContext *)pDXShare->pDirectXData;                                                \
        pDriverData->dwDDGlobal = (DWORD)(pDDGbl);                                                                  \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
    #define nvSetDriverDataPtrFromContext(pContext) {                                                               \
        pDXShare         = (DISPDRVDIRECTXCOMMON *)((pContext)->pDXShare);                                          \
        pDriverData      = (pContext)->pDriverData;                                                                 \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
#endif // !WINNT

//
// DDHAL_EXIT(retcode) should always be invoked when returning from a HAL function
// or any function which loads the global variable pDriverData. This macro will
// return the parameter retVal to its caller.
//
#ifndef WINNT
    #define DDHAL_EXIT(retVal) return(retVal)
#else
    #define DDHAL_EXIT(retVal)              \
        NvReleaseSemaphore(pDriverData);    \
        return(retVal)
#endif

#if !defined(WINNT) || (DIRECT3D_VERSION >= 0x0800)
    #define NvTexSurfHandle(ptcd) ((LPDIRECTDRAWSURFACE) ((ptcd)->lpDDS))
#else   // WINNT
    #define NvTexSurfHandle(ptcd) ((LPDIRECTDRAWSURFACE) ((ptcd)->hDDS))
#endif  // WINNT

#if !defined(WINNT) || (DIRECT3D_VERSION >= 0x0800)
    #define NvLockTextureSurface(ptr)   ((LPDDRAWI_DDRAWSURFACE_INT)NvTexSurfHandle(ptr))->lpLcl
    #define NvUnlockTextureSurface(ptr)
#else   // WINNT
    #define NvLockTextureSurface(ptr)   EngLockDirectDrawSurface(NvTexSurfHandle(ptr))
    #define NvUnlockTextureSurface(ptr) EngUnlockDirectDrawSurface((ptr))
#endif  // WINNT

#if !defined(WINNT) || (DIRECT3D_VERSION >= 0x0800)
#define NvSaveTexSurfHandle(dst, src)   (dst)->lpDDS = (src)->lpDDS
#else   // WINNT
#define NvSaveTexSurfHandle(dst, src)   (dst)->hDDS = (src)->lpDDS
#endif  // WINNT

/*
 * Macros used to obtain video memory offset/addresses from fpVidMem field
 * in surface struct. Our Win9x driver requires an address in the fpVidMem
 * field while NT requires an offset. These macros are used to hide these
 * differences.
 */

#if defined(WINNT) && (DIRECT3D_VERSION < 0x0800)
    #define SETLIGHT_DATATYPE(lpDp2SetLight)          ((lpDp2SetLight)->lightData)
    #define SETPRIORITY_DSTSURF(lpDp2SetPriority)     ((lpDp2SetPriority)->dwDDDestSurface)
    #define SETRENDERTARG_DDSLCL(lpDp2SetRenderTarg)  ((lpDp2SetRenderTarg)->lpDDS)
    #define SETRENDERTARG_DDSLCLZ(lpDp2SetRenderTarg) ((lpDp2SetRenderTarg)->lpDDSZ)
#else // !WINNT
    #define SETLIGHT_DATATYPE(lpDp2SetLight)          ((lpDp2SetLight)->dwDataType)
    #define SETPRIORITY_DSTSURF(lpDp2SetPriority)     ((lpDp2SetPriority)->dwDDSurface)
    #define SETRENDERTARG_DDSLCL(lpDp2SetRenderTarg)  ((lpDp2SetRenderTarg)->lpDDSLcl)
    #define SETRENDERTARG_DDSLCLZ(lpDp2SetRenderTarg) ((lpDp2SetRenderTarg)->lpDDSLclZ)
#endif // !WINNT

#ifdef WINNT
#ifndef VIDMEM_ADDR
    #define VIDMEM_ADDR(fpVidMem)    ((fpVidMem) + (ULONG) ppdev->pjFrameBufbase)
#endif
    #define VIDMEM_OFFSET(fpVidMem)  (fpVidMem)
#ifndef AGPMEM_ADDR
    #define AGPMEM_ADDR(fpVidMem)    ((ULONG) fpVidMem + (ULONG) pDriverData->GARTLinearBase)
#endif
    #define VIDMEM_OFFSET(fpVidMem)  (fpVidMem)
    #define AGPMEM_OFFSET(fpVidMem)  ((ULONG) fpVidMem - (ULONG) pDriverData->GARTLinearBase)
    #define GET_PRIMARY_ADDR()       (ppdev->ulPrimarySurfaceOffset)
    #define GET_MODE_WIDTH()         (ppdev->cxScreen)
    #define GET_MODE_HEIGHT()        (ppdev->cyScreen)
    #define GET_MODE_PITCH()         (ppdev->lDelta)
    #define GET_MODE_PHYSICAL_HEIGHT(dwHead) (pDriverData->flipPrimaryRecord.nvTimingInfo[dwHead].VDisplayEnd)
    #define GET_MODE_BPP()           (ppdev->cBitsPerPel)
    #define GET_HALINFO()            (&(pDriverData->HALInfo))
    #define GET_CURRENT_HEAD()       (ppdev->ulDeviceDisplay[0])
    #define GET_SPAN_OFFSET(dwHead)  (ppdev->ulHeadDisplayOffset[dwHead])
    #define PRIMARY_BUFFER_INDEX     (ppdev->ulPrimaryBufferIndex)
#else // !WINNT
    #define VIDMEM_ADDR(fpVidMem)    (fpVidMem)
    #define VIDMEM_OFFSET(fpVidMem)  ((fpVidMem) - pDriverData->BaseAddress)
    #define AGPMEM_ADDR(fpVidMem)    (fpVidMem)
    #define AGPMEM_OFFSET(fpVidMem)  ((fpVidMem) - pDriverData->GARTLinearBase)
    #define GET_PRIMARY_ADDR()       (pDXShare->dwScreenLinearBase + (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deBitsOffset))
    #define GET_MODE_WIDTH()         (((DIBENGI