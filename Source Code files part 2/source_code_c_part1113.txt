             lpBufferIn,
                     FILE_BUFFER_SIZE - 1,
                     &cbIn,
                     NULL
                     )
            )
        // Note:  we asume, in our use of lpCharIn, that the file is always less than
        // FILE_BUFFER_SIZE
        {
            LPBYTE lpCharIn = lpBufferIn;
            LPBYTE lpCharOut = lpBufferOut;

            while ((*lpCharIn) && (FILE_BUFFER_SIZE - 2 > cbOut))
            {
              *lpCharOut++ = *lpCharIn;
              cbOut++;
              if (('\r' == *lpCharIn) && ('\n' != *(lpCharIn + 1)))
              {
                fChanged = TRUE;

                *lpCharOut++ = '\n';
                cbOut++;
              }
              lpCharIn++;
            }

            if (fChanged)
            {
                LARGE_INTEGER lnOffset = {0,0};
                if (SetFilePointerEx(hfile, lnOffset, NULL, FILE_BEGIN))
                {
                    DWORD   cbWritten = 0;
                    if (! WriteFile(hfile,
                                    lpBufferOut,
                                    cbOut,
                                    &cbWritten,
                                    NULL
                                    )
                        )
                    {
                        hr = GetLastError();
                    }
                }
                else
                {
                    hr = GetLastError();
                }
            }
        }
        else
        {
            hr = GetLastError();
        }
        CloseHandle(hfile);
    }
    else
    {
        hr = GetLastError();
    }

    GlobalFree((HGLOBAL)lpBufferIn);
    return ERROR_SUCCESS;
}

DWORD CINSHandler::RunExecutable(void)
{
    DWORD               dwRet;
    SHELLEXECUTEINFO    sei;

    // Hide the active window first
    HWND  hWndHide = GetActiveWindow();
    ::ShowWindow(hWndHide, SW_HIDE);

    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = cszOpen;
    sei.lpFile = m_szRunExecutable;
    sei.lpParameters = m_szRunArgument;
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;
    sei.hInstApp = NULL;
    // Optional members
    sei.hProcess = NULL;

    if (ShellExecuteEx(&sei))
    {
        DWORD iWaitResult = 0;
        // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
        while((iWaitResult=MsgWaitForMultipleObjects(1, &sei.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
           MSG msg ;
           // read all of the messages in this next loop
           // removing each message as we read it
           while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
           {
               if (msg.message == WM_QUIT)
               {
                   CloseHandle(sei.hProcess);
                   return NO_ERROR;
               }
               else
                   DispatchMessage(&msg);
            }
        }

        CloseHandle(sei.hProcess);
        dwRet = ERROR_SUCCESS;
    }
    else
    {
        dwRet = GetLastError();
    }

    ::ShowWindow(hWndHide, SW_SHOW);

    return dwRet;
}

void CINSHandler::SaveAutoDial(void)
{
    // if the original autodial settings have not been saved
    if (!m_fAutodialSaved)
    {
        // save the current autodial settings
        InetGetAutodial(
                &m_fAutodialEnabled,
                m_szAutodialConnection,
                sizeof(m_szAutodialConnection));

        m_fAutodialSaved = TRUE;
    }
}



void CINSHandler::RestoreAutoDial(void)
{
    if (m_fAutodialSaved)
    {
        // restore original autodial settings
        AUTODIAL_TYPE eType = 
            m_fAutodialEnabled ? AutodialTypeAlways : AutodialTypeNever;
        SetDefaultConnectoid(eType, m_szAutodialConnection);
        m_fAutodialSaved = FALSE;
    }
}

BOOL CINSHandler::KeepConnection(LPCWSTR lpszFile)
{
    WCHAR szTemp[10];

    GetPrivateProfileString(cszCustomSection,
                            cszKeepConnection,
                            cszNo,
                            szTemp,
                            MAX_CHARS_IN_BUFFER(szTemp),
                            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD CINSHandler::ImportCustomInfo
(
    LPCWSTR lpszImportFile,
    LPWSTR lpszExecutable,
    DWORD cchExecutable,
    LPWSTR lpszArgument,
    DWORD cchArgument
)
{
    GetPrivateProfileString(cszCustomSection,
                              cszRun,
                              cszNull,
                              lpszExecutable,
                              (int)cchExecutable,
                              lpszImportFile);

    GetPrivateProfileString(cszCustomSection,
                              cszArgument,
                              cszNull,
                              lpszArgument,
                              (int)cchArgument,
                              lpszImportFile);

    return ERROR_SUCCESS;
}

DWORD CINSHandler::ImportFile
(
    LPCWSTR lpszImportFile,
    LPCWSTR lpszSection,
    LPCWSTR lpszOutputFile
)
{
    HANDLE  hScriptFile = INVALID_HANDLE_VALUE;
    LPWSTR   pszLine, pszFile;
    int     i, iMaxLine;
    UINT    cch;
    DWORD   cbRet;
    DWORD   dwRet = ERROR_SUCCESS;

    // Allocate a buffer for the file
    if ((pszFile = (LPWSTR)LocalAlloc(LMEM_FIXED, CCH_ReadBuf * sizeof(WCHAR))) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    // Look for script
    if (GetPrivateProfileString(lpszSection,
                                NULL,
                                szNull,
                                pszFile,
                                CCH_ReadBuf,
                                lpszImportFile) != 0)
    {
        // Get the maximum line number
        pszLine = pszFile;
        iMaxLine = -1;
        while (*pszLine)
        {
            i = _wtoi(pszLine);
            iMaxLine = max(iMaxLine, i);
            pszLine += lstrlen(pszLine)+1;
        };

        // If we have at least one line, we will import the script file
        if (iMaxLine >= 0)
        {
            // Create the script file
            hScriptFile = CreateFile(lpszOutputFile,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,          // security attributes
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL
                                     );

            if (INVALID_HANDLE_VALUE != hScriptFile)
            {
                WCHAR   szLineNum[MAXLONGLEN+1];

                // From The first line to the last line
                for (i = 0; i <= iMaxLine; i++)
                {
                    // Read the script line
                    wsprintf(szLineNum, L"%d", i);
                    if ((cch = GetPrivateProfileString(lpszSection,
                                                          szLineNum,
                                                          szNull,
                                                          pszLine,
                                                          CCH_ReadBuf,
                                                          lpszImportFile)) != 0)
                    {
                        // Write to the script file
                        lstrcat(pszLine, L"\x0d\x0a");
                        if (! WriteFile(hScriptFile,
                                        pszLine,
                                        BYTES_REQUIRED_BY_CCH(cch + 2),
                                        &cbRet,
                                        NULL
                                        )
                                )
                            {
                                dwRet = GetLastError();
                                break;
                            }
                    }
                }
                CloseHandle(hScriptFile);
            }
            else
            {
                dwRet = GetLastError();
            }
        }
        else
        {
            dwRet = ERROR_NOT_FOUND;
        }
    }
    else
    {
        dwRet = ERROR_NOT_FOUND;
    }
    LocalFree(pszFile);

    return dwRet;
}



DWORD CINSHandler::ImportCustomFile
(
    LPCWSTR lpszImportFile
)
{
    WCHAR   szFile[_MAX_PATH];
    WCHAR   szTemp[_MAX_PATH];

    // If a custom file name does not exist, do nothing
    if (GetPrivateProfileString(cszCustomSection,
                                cszFileName,
                                cszNull,
                                szTemp,
                                MAX_CHARS_IN_BUFFER(szTemp),
                                lpszImportFile) == 0)
    {
        return ERROR_SUCCESS;
    };

    GetWindowsDirectory(szFile, MAX_CHARS_IN_BUFFER(szFile));
    if (*CharPrev(szFile, szFile + lstrlen(szFile)) != L'\\')
    {
        lstrcat(szFile, L"\\");
    }
    lstrcat(szFile, szTemp);

    return (ImportFile(lpszImportFile, cszCustomFileSection, szFile));
}

BOOL CINSHandler::LoadExternalFunctions(void)
{
    BOOL    bRet = FALSE;

    do
    {
        // Load the Brading library functions
        m_hBranding = LoadLibrary(L"IEDKCS32.DLL");
        if (m_hBranding != NULL)
        {
            if (NULL == (m_lpfnBrandICW2 = (PFNBRANDICW2)GetProcAddress(m_hBranding, "BrandICW2")))
                break;
        }
        else
        {
            break;
        }

        if( IsNT() )
        {
            // Load the RAS functions
            m_hRAS = LoadLibrary(L"RASAPI32.DLL");
            if (m_hRAS != NULL)
            {
                if (NULL == (m_lpfnRasSetAutodialEnable = (PFNRASSETAUTODIALENABLE)GetProcAddress(m_hRAS, "RasSetAutodialEnableA")))
                    break;
                if (NULL == (m_lpfnRasSetAutodialAddress = (PFNRASSETAUTODIALADDRESS)GetProcAddress(m_hRAS, "RasSetAutodialAddressA")))
                    break;
            }
            else
            {
                break;
            }
        }

        // Success if we get to here
        bRet = TRUE;
        break;
    } while(1);

    return bRet;
}

//-----------------------------------------------------------------------------
//  OpenIcwRmindKey
//-----------------------------------------------------------------------------
BOOL CINSHandler::OpenIcwRmindKey(HKEY* phkey)
{
    // This method will open the IcwRmind key in the registry.  If the key
    // does not exist it will be created here.

    LONG lResult = ERROR_SUCCESS;
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszKeyIcwRmind, 0, KEY_READ | KEY_WRITE, phkey))
    {
        lResult = RegCreateKey(HKEY_LOCAL_MACHINE, cszKeyIcwRmind, phkey);
    }

    return ( ERROR_SUCCESS == lResult );
}

BOOL CINSHandler::ConfigureTrialReminder
(
    LPCWSTR  lpszFile
)
{

    WCHAR    szISPName[MAX_ISP_NAME];
    WCHAR    szISPMsg[MAX_ISP_MSG];
    WCHAR    szISPPhoneNumber[MAX_ISP_PHONENUMBER];
    int     iTrialDays;
    WCHAR    szConvertURL[INTERNET_MAX_URL_LENGTH];

    WCHAR    szExpiredISPFileURL[INTERNET_MAX_URL_LENGTH];
    WCHAR    szExpiredISPFileName[MAX_PATH]; // The fully qualified path to the final INS file
    WCHAR    szISPFile[MAX_PATH];            // The name we get in the INS

    WCHAR    szConnectoidName[MAXNAME];

    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPName,
                                cszNull,
                                szISPName,
                                MAX_CHARS_IN_BUFFER(szISPName),
                                lpszFile) == 0)
    {
        return FALSE;
    }

    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPPhone,
                                cszNull,
                                szISPPhoneNumber,
                                MAX_CHARS_IN_BUFFER(szISPPhoneNumber),
                                lpszFile) == 0)
    {
        return FALSE;
    }

    if ((iTrialDays = GetPrivateProfileInt(cszTrialRemindSection,
                                           cszEntryTrialDays,
                                           0,
                                           lpszFile)) == 0)
    {
        return FALSE;
    }


    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntrySignupURL,
                                cszNull,
                                szConvertURL,
                                MAX_CHARS_IN_BUFFER(szConvertURL),
                                lpszFile) == 0)
    {
        return FALSE;
    }

    //optional
    GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPMsg,
                                cszNull,
                                szISPMsg,
                                MAX_CHARS_IN_BUFFER(szISPMsg),
                                lpszFile);

    // Get the connectoid name from the [Entry] Section
    if (GetPrivateProfileString(cszEntrySection,
                                cszEntry_Name,
                                cszNull,
                                szConnectoidName,
                                MAX_CHARS_IN_BUFFER(szConnectoidName),
                                lpszFile) == 0)
    {
        return FALSE;
    }

    // If we get to here, we have everything to setup a trial, so let's do it.

    HKEY hkey;
    if (OpenIcwRmindKey(&hkey))
    {
        // Set the values we have

        RegSetValueEx(hkey, cszEntryISPName, 0, REG_SZ, LPBYTE(szISPName), BYTES_REQUIRED_BY_SZ((LPWSTR)szISPName) );

        RegSetValueEx(hkey, cszEntryISPMsg, 0, REG_SZ, LPBYTE(szISPMsg), BYTES_REQUIRED_BY_SZ((LPWSTR)szISPMsg) );

        RegSetValueEx(hkey, cszEntryISPPhone, 0, REG_SZ, LPBYTE(szISPPhoneNumber), BYTES_REQUIRED_BY_SZ((LPWSTR)szISPPhoneNumber) );

        RegSetValueEx(hkey, cszEntryTrialDays, 0, REG_DWORD, (LPBYTE)&iTrialDays, sizeof(DWORD) + 1);

        RegSetValueEx(hkey, cszEntrySignupURL, 0, REG_SZ, LPBYTE(szConvertURL), BYTES_REQUIRED_BY_SZ((LPWSTR)szConvertURL) );

        RegSetValueEx(hkey, cszEntryConnectoidName, 0, REG_SZ, LPBYTE(szConnectoidName), BYTES_REQUIRED_BY_SZ((LPWSTR)szConnectoidName) );

        // See if we have to create an ISP file
        if (GetPrivateProfileString(cszTrialRemindSection,
                                    cszEntryExpiredISPFileName,
                                    cszNull,
                                    szISPFile,
                                    MAX_CHARS_IN_BUFFER(szISPFile),
                                    lpszFile) != 0)
        {

            // Set the fully qualified path for the ISP file name
            WCHAR szAppDir[MAX_PATH];
            LPWSTR   p;
            if (GetModuleFileName(GetModuleHandle(L"msobcomm.ldl"), szAppDir, MAX_PATH))
            {
                p = &szAppDir[lstrlen(szAppDir)-1];
                while (*p != L'\\' && p >= szAppDir)
                    p--;
                if (*p == L'\\') *(p++) = L'\0';
            }

            wsprintf(szExpiredISPFileName, L"%s\\%s",szAppDir,szISPFile);

            if (GetPrivateProfileString(cszTrialRemindSection,
                                        cszSignupExpiredISPURL,
                                        cszNull,
                                        szExpiredISPFileURL,
                                        MAX_CHARS_IN_BUFFER(szExpiredISPFileURL),
                                        lpszFile) != 0)
            {

                // Download the ISP file, and then copy its contents
                CWebGate    WebGate;
                BSTR        bstrURL;
                BSTR        bstrFname;
                BOOL        bRetVal;

                // Setup the webGate object, and download the ISP file
                bstrURL = SysAllocString(szExpiredISPFileURL);
                WebGate.put_Path(bstrURL);
                SysFreeString(bstrURL);
                WebGate.FetchPage(1, &bRetVal);
                if (bRetVal)
                {
                    WebGate.get_DownloadFname(&bstrFname);

                    // Copy the file from the temp location, making sure one does not
                    // yet exist
                    DeleteFile(szExpiredISPFileName);
                    MoveFile(bstrFname, szExpiredISPFileName);
                    SysFreeString(bstrFname);

                    // Write the new file to the registry
                    RegSetValueEx(hkey, cszEntrySignupURLTrialOver, 0, REG_SZ, LPBYTE(szExpiredISPFileName), BYTES_REQUIRED_BY_SZ((LPWSTR)szExpiredISPFileName) );

                }

            }
        }
        // The key was opened inside OpenIcwRmindKey, close it here.
        RegCloseKey(hkey);
    }

    return TRUE;

}

DWORD CINSHandler::ImportBrandingInfo
(
    LPCWSTR lpszFile,
    LPCWSTR lpszConnectoidName
)
{
    USES_CONVERSION;
    WCHAR szPath[_MAX_PATH + 1];
    MYASSERT(m_lpfnBrandICW2 != NULL);

    GetWindowsDirectory(szPath, MAX_CHARS_IN_BUFFER(szPath));
    m_lpfnBrandICW2(W2A(lpszFile), W2A(szPath), m_dwBrandFlags, W2A(lpszConnectoidName));

    return ERROR_SUCCESS;
}


DWORD CINSHandler::ReadClientInfo
(
    LPCWSTR lpszFile,
    LPINETCLIENTINFO lpClientInfo,
    LPCLIENT_TABLE lpClientTable
)
{
    LPCLIENT_TABLE lpTable;

    for (lpTable = lpClientTable; NULL != lpTable->lpszSection; ++lpTable)
    {
        GetPrivateProfileString(lpTable->lpszSection,
                lpTable->lpszValue,
                cszNull,
                (LPWSTR)((LPBYTE)lpClientInfo + lpTable->uOffset),
                lpTable->uSize,
                lpszFile);
    }

    lpClientInfo->dwFlags = 0;
    if (*lpClientInfo->szPOPLogonName)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }
    if ((*lpClientInfo->szNNTPLogonName) || (*lpClientInfo->szNNTPServer))
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    return ERROR_SUCCESS;
}

BOOL CINSHandler::WantsExchangeInstalled(LPCWSTR lpszFile)
{
    WCHAR szTemp[10];

    GetPrivateProfileString(cszEMailSection,
            cszUseExchange,
            cszNo,
            szTemp,
            MAX_CHARS_IN_BUFFER(szTemp),
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

BOOL CINSHandler::DisplayPassword(LPCWSTR lpszFile)
{
    WCHAR szTemp[10];

    GetPrivateProfileString(cszUserSection,
            cszDisplayPassword,
            cszNo,
            szTemp,
            MAX_CHARS_IN_BUFFER(szTemp),
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD CINSHandler::ImportClientInfo
(
    LPCWSTR lpszFile,
    LPINETCLIENTINFO lpClientInfo
)
{
    DWORD dwRet;

    lpClientInfo->dwSize = sizeof(INETCLIENTINFO);

    dwRet = ReadClientInfo(lpszFile, lpClientInfo, iniTable);

    return dwRet;
}

DWORD CINSHandler::ConfigureClient
(
    HWND hwnd,
    LPCWSTR lpszFile,
    LPBOOL lpfNeedsRestart,
    LPBOOL lpfConnectoidCreated,
    BOOL fHookAutodial,
    LPWSTR szConnectoidName,
    DWORD dwConnectoidNameSize
)
{
    LPICONNECTION       pConn  = NULL;
    LPINETCLIENTINFO    pClientInfo = NULL;
    DWORD               dwRet = ERROR_SUCCESS;
    UINT                cb = sizeof(ICONNECTION) + sizeof(INETCLIENTINFO);
    DWORD               dwfOptions = INETCFG_INSTALLTCP | INETCFG_WARNIFSHARINGBOUND;
    LPRASINFO           pRasInfo = NULL;
    LPRASENTRY          pRasEntry = NULL;
    RNAAPI              Rnaapi;
    LPBYTE              lpDeviceInfo = NULL;
    DWORD               dwDeviceInfoSize = 0;
    BOOL                lpfNeedsRestartLan = FALSE;

    //
    // ChrisK Olympus 4756 5/25/97
    // Do not display busy animation on Win95
    //
    if (!m_bSilentMode && IsNT())
    {
        dwfOptions |=  INETCFG_SHOWBUSYANIMATION;
    }

    // Allocate a buffer for connection and clientinfo objects
    if ((pConn = (LPICONNECTION)LocalAlloc(LPTR, cb)) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }


    if (WantsExchangeInstalled(lpszFile))
    {
        dwfOptions |= INETCFG_INSTALLMAIL;
    }

    // Create either a CM profile, or a connectoid
    if (CallCMConfig(lpszFile))
    {
        *lpfConnectoidCreated = TRUE;       // A dialup connection was created
    }
    else
    {
        switch ( InetSGetConnectionType ( lpszFile ) ) {
            case InetS_RASModem :
            case InetS_RASIsdn : 
            {
                break;
            }
            case InetS_RASAtm   : 
            {
                lpDeviceInfo = (LPBYTE) malloc ( sizeof (ATMPBCONFIG) );
                if ( !lpDeviceInfo )
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                dwDeviceInfoSize = sizeof( ATMPBCONFIG );
                break;
            }

            case InetS_LANCable :
            {
                DWORD           nRetVal  = 0;
                LANINFO         LanInfo;

                memset ( &LanInfo, 0, sizeof (LANINFO) );
                LanInfo.dwSize = sizeof (LanInfo);
                
                if ((nRetVal = InetSImportLanConnection (LanInfo, lpszFile)) != ERROR_SUCCESS )
                {
                    return nRetVal;
                }
                if ((nRetVal = InetSSetLanConnection (LanInfo)) != ERROR_SUCCESS )
                {
                    return nRetVal;
                }
                lpfNeedsRestartLan = TRUE;
                goto next_step; // skip the RAS processing code.
                break; // not reached, of course
            }
            case InetS_LAN1483 :
            {
                DWORD           nRetVal = 0;
                RFC1483INFO     Rfc1483Info;

                memset ( &Rfc1483Info, 0, sizeof (RFC1483INFO) );
                Rfc1483Info.dwSize = sizeof ( Rfc1483Info );
                // first, we determine the size of the buffer required
                // to hold the 1483 settings.
                if ((nRetVal = InetSImportRfc1483Connection (Rfc1483Info, lpszFile)) != ERROR_SUCCESS ) {
                    return nRetVal;
                }
                // verify that the size has been returned.
                if ( !Rfc1483Info.Rfc1483Module.dwRegSettingsBufSize )
                {
                    return E_FAIL;
                }
                // we create the buffer.
                if ( !(Rfc1483Info.Rfc1483Module.lpbRegSettingsBuf = (LPBYTE) malloc ( Rfc1483Info.Rfc1483Module.dwRegSettingsBufSize ) ))
                {
                    return ERROR_OUTOFMEMORY;
                }
                // we call the function again with the correct settings.
                if ((nRetVal = InetSImportRfc1483Connection (Rfc1483Info, lpszFile)) != ERROR_SUCCESS ) {
                    free(Rfc1483Info.Rfc1483Module.lpbRegSettingsBuf);
                    return nRetVal;
                }
                // we place the imported settings in the registry.
                if ((nRetVal = InetSSetRfc1483Connection (Rfc1483Info) ) != ERROR_SUCCESS ) {
                    free(Rfc1483Info.Rfc1483Module.lpbRegSettingsBuf);
                    return nRetVal;
                }
                // we clean up.
                free(Rfc1483Info.Rfc1483Module.lpbRegSettingsBuf);
                lpfNeedsRestartLan = TRUE;
                goto next_step; // skip RAS processing code.
                break; // not reached
            }
            case InetS_LANPppoe : 
            {
                DWORD           nRetVal = 0;
                PPPOEINFO       PppoeInfo;

                memset ( &PppoeInfo, 0, sizeof (RFC1483INFO) );
                PppoeInfo.dwSize = sizeof ( PppoeInfo );
                // first, we determine the size of the buffer required
                // to hold the 1483 settings.
                if ((nRetVal = InetSImportPppoeConnection (PppoeInfo, lpszFile)) != ERROR_SUCCESS ) {
                    return nRetVal;
                }
                // verify that the size has been returned.
                if ( !PppoeInfo.PppoeModule.dwRegSettingsBufSize )
                {
                    return E_FAIL;
                }
                // we create the buffer.
                if ( !(PppoeInfo.PppoeModule.lpbRegSettingsBuf = (LPBYTE) malloc ( PppoeInfo.PppoeModule.dwRegSettingsBufSize ) ))
                {
                    return ERROR_OUTOFMEMORY;
                }
                // we call the function again with the correct settings.
                if ((nRetVal = InetSImportPppoeConnection (PppoeInfo, lpszFile)) != ERROR_SUCCESS ) {
                    free(PppoeInfo.PppoeModule.lpbRegSettingsBuf);
                    return nRetVal;
                }
                // we place the imported settings in the registry.
                if ((nRetVal = InetSSetPppoeConnection (PppoeInfo) ) != ERROR_SUCCESS ) {
                    free(PppoeInfo.PppoeModule.lpbRegSettingsBuf);
                    return nRetVal;
                }
                // we clean up.
                free(PppoeInfo.PppoeModule.lpbRegSettingsBuf);
                lpfNeedsRestartLan = TRUE;
                goto next_step; // skip RAS processing code.
                break; // not reached
            }
            default:
                break;
        }
        dwRet = ImportConnection(lpszFile, pConn, lpDeviceInfo, &dwDeviceInfoSize);
        if (ERROR_SUCCESS == dwRet)
        {
            pRasEntry = &pConn->RasEntry;
            dwfOptions |= INETCFG_SETASAUTODIAL |
                        INETCFG_INSTALLRNA |
                        INETCFG_INSTALLMODEM;
        }
        else if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != dwRet)
        {
			free (lpDeviceInfo);
            return dwRet;
        }

        if (!m_bSilentMode && DisplayPassword(lpszFile))
        {
            if (*pConn->szPassword || *pConn->szUserName)
            {
                //WCHAR szFmt[128];
                //WCHAR szMsg[384];

                //LoadString(_Module.GetModuleInstance(), IDS_PASSWORD, szFmt, MAX_CHARS_IN_BUFFER(szFmt));
                //wsprintf(szMsg, szFmt, pConn->szUserName, pConn->szPassword);

                //::MessageBox(hwnd, szMsg, GetSz(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
            }
        }

        if (fHookAutodial &&
            ((0 == *pConn->RasEntry.szAutodialDll) ||
             (0 == *pConn->RasEntry.szAutodialFunc)))
        {
            lstrcpy(pConn->RasEntry.szAutodialDll, L"isign32.dll");
            lstrcpy(pConn->RasEntry.szAutodialFunc, L"AutoDialLogon");
        }

        pRasEntry->dwfOptions |= RASEO_ShowDialingProgress;

        // humongous hack for ISBU


        dwRet = Rnaapi.InetConfigClientEx(hwnd,
                                     NULL,
                                     pConn->szEntryName,
                                     pRasEntry,
                                     pConn->szUserName,
                                     pConn->szPassword,
                                     NULL,
                                     NULL,
                                     dwfOptions & ~INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart,
                                     szConnectoidName,
                                     dwConnectoidNameSize,
                                     lpDeviceInfo,
                                     &dwDeviceInfoSize);

        if ( lpDeviceInfo ) 
            free (lpDeviceInfo);

        LclSetEntryScriptPatch(pRasEntry->szScript, pConn->szEntryName);
        BOOL fEnabled = TRUE;
        DWORD dwResult = 0xba;
        dwResult = InetGetAutodial(&fEnabled, pConn->szEntryName, RAS_MaxEntryName+1);
        if ((ERROR_SUCCESS == dwRet) && lstrlen(szConnectoidName))
        {
            *lpfConnectoidCreated = (NULL != pRasEntry);
            PopulateNTAutodialAddress( lpszFile, pConn->szEntryName );
        }
    }

next_step:
    // If we were successfull in creating the connectiod, then see if the user wants a
    // mail client installed
    if (ERROR_SUCCESS == dwRet)
    {
        // Get the mail client info
        if (m_dwDeviceType == InetS_LANCable)
        {
            if (!(pClientInfo = (LPINETCLIENTINFO) malloc (sizeof (INETCLIENTINFO))))
            {
                return ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            if (!pConn)
                return ERROR_INVALID_PARAMETER;
            pClientInfo = (LPINETCLIENTINFO)(((LPBYTE)pConn) + sizeof(ICONNECTION));
        }
        ImportClientInfo(lpszFile, pClientInfo);

        // use inet config to install the mail client
        dwRet = Rnaapi.InetConfigClientEx(hwnd,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     pClientInfo,
                                     dwfOptions & INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart,
                                     szConnectoidName,
                                     dwConnectoidNameSize);

    }

    // cleanup
    if (m_dwDeviceType == InetS_LANCable)
        free (pClientInfo);
    if (pConn)
        LocalFree(pConn);
    *lpfNeedsRestart |= lpfNeedsRestartLan;
    return dwRet;
 }


//+----------------------------------------------------------------------------
//
//    Function:    PopulateNTAutodialAddress
//
//    Synopsis:    Take Internet addresses from INS file and load them into the
//                autodial database
//
//    Arguments:    pszFileName - pointer to INS file name
//
//    Returns:    Error code (ERROR_SUCCESS == success)
//
//    History:    8/29/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#define AUTODIAL_ADDRESS_BUFFER_SIZE 2048
#define AUTODIAL_ADDRESS_SECTION_NAME L"Autodial_Addresses_for_NT"
HRESULT CINSHandler::PopulateNTAutodialAddress(LPCWSTR pszFileName, LPCWSTR pszEntryName)
{
    HRESULT hr = ERROR_SUCCESS;
    LONG lRC = 0;
    LPLINETRANSLATECAPS lpcap = NULL;
    LPLINETRANSLATECAPS lpTemp = NULL;
    LPLINELOCATIONENTRY lpLE = NULL;
    RASAUTODIALENTRY* rADE;
    INT idx = 0;
    LPWSTR lpszBuffer = NULL;
    LPWSTR lpszNextAddress = NULL;
    rADE = NULL;


    //RNAAPI *pRnaapi = NULL;

    // jmazner  10/8/96  this function is NT specific
    if( !IsNT() )
    {
        // TraceMsg(TF_INSHANDLER, L"ISIGNUP: Bypassing PopulateNTAutodialAddress for win95.\r\n");
        return( ERROR_SUCCESS );
    }

    MYASSERT(m_lpfnRasSetAutodialEnable);
    MYASSERT(m_lpfnRasSetAutodialAddress);

    //MYASSERT(pszFileName && pszEntryName);
    //dprintf(L"ISIGNUP: PopulateNTAutodialAddress "%s %s.\r\n", pszFileName, pszEntryName);
    // TraceMsg(TF_INSHANDLER, pszFileName);
    // TraceMsg(TF_INSHANDLER, L", ");
    // TraceMsg(TF_INSHANDLER, pszEntryName);
    // TraceMsg(TF_INSHANDLER, L".\r\n");

    //
    // Get list of TAPI locations
    //
    lpcap = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR, sizeof(LINETRANSLATECAPS));
    if (!lpcap)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }
    lpcap->dwTotalSize = sizeof(LINETRANSLATECAPS);
    lRC = lineGetTranslateCaps(0, 0x10004, lpcap);
    if (SUCCESS == lRC)
    {
        lpTemp = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR, lpcap->dwNeededSize);
        if (!lpTemp)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto PopulateNTAutodialAddressExit;
        }
        lpTemp->dwTotalSize = lpcap->dwNeededSize;
        GlobalFree(lpcap);
        lpcap = (LPLINETRANSLATECAPS)lpTemp;
        lpTemp = NULL;
        lRC = lineGetTranslateCaps(0, 0x10004, lpcap);
    }

    if (SUCCESS != lRC)
    {
        hr = (HRESULT)lRC; // REVIEW: not real sure about this.
        goto PopulateNTAutodialAddressExit;
    }

    //
    // Create an array of RASAUTODIALENTRY structs
    //
    rADE = (RASAUTODIALENTRY*)GlobalAlloc(GPTR,
        sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations);
    if (!rADE)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }


    //
    // Enable autodialing for all locations
    //
    idx = lpcap->dwNumLocations;
    lpLE = (LPLINELOCATIONENTRY)((DWORD_PTR)lpcap + lpcap->dwLocationListOffset);
    while (idx)
    {
        idx--;
        m_lpfnRasSetAutodialEnable(lpLE[idx].dwPermanentLocationID, TRUE);

        //
        // fill in array values
        //
        rADE[idx].dwSize = sizeof(RASAUTODIALENTRY);
        rADE[idx].dwDialingLocation = lpLE[idx].dwPermanentLocationID;
        lstrcpyn(rADE[idx].szEntry, pszEntryName, RAS_MaxEntryName);
    }

    //
    // Get list of addresses
    //
    lpszBuffer = (LPWSTR)GlobalAlloc(GPTR, AUTODIAL_ADDRESS_BUFFER_SIZE * sizeof(WCHAR));
    if (!lpszBuffer)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }

    if((AUTODIAL_ADDRESS_BUFFER_SIZE-2) == GetPrivateProfileSection(AUTODIAL_ADDRESS_SECTION_NAME,
        lpszBuffer, AUTODIAL_ADDRESS_BUFFER_SIZE, pszFileName))
    {
        //AssertSz(0, L"Autodial address section bigger than buffer.\r\n");
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }

    //
    // Walk list of addresses and set autodialing for each one
    //
    lpszNextAddress = lpszBuffer;
    do
    {
        lpszNextAddress = MoveToNextAddress(lpszNextAddress);
        if (!(*lpszNextAddress))
            break;    // do-while
        m_lpfnRasSetAutodialAddress(lpszNextAddress, 0, rADE,
            sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations, lpcap->dwNumLocations);
        lpszNextAddress = lpszNextAddress + lstrlen(lpszNextAddress);
    } while(1);

PopulateNTAutodialAddressExit:
    if (lpcap)
        GlobalFree(lpcap);
    lpcap = NULL;
    if (rADE)
        GlobalFree(rADE);
    rADE = NULL;
    if (lpszBuffer)
        GlobalFree(lpszBuffer);
    lpszBuffer = NULL;
    //if( pRnaapi )
    //    delete pRnaapi;
    //pRnaapi = NULL;
    return hr;
}



//+----------------------------------------------------------------------------
//
//    Function:    MoveToNextAddress
//
//    Synopsis:    Given a pointer into the data bufffer, this function will move
//                through the buffer until it points to the begining of the next
//                address or it reaches the end of the buffer.
//
//    Arguements:    lpsz - pointer into buffer
//
//    Returns:    Pointer to the next address, return value will point to NULL
//                if there are no more addresses
//
//    History:    8/29/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
LPWSTR CINSHandler::MoveToNextAddress(LPWSTR lpsz)
{
    BOOL fLastCharWasNULL = FALSE;

    //assertSz(lpsz, L"MoveToNextAddress: NULL input\r\n");

    //
    // Look for an = sign
    //
    do
    {
        if (fLastCharWasNULL && L'\0' == *lpsz)
            break; // are we at the end of the data?

        if (L'\0' == *lpsz)
            fLastCharWasNULL = TRUE;
        else
            fLastCharWasNULL = FALSE;

        if (L'=' == *lpsz)
            break;

        if (*lpsz)
            lpsz = CharNext(lpsz);
        else
            lpsz += BYTES_REQUIRED_BY_CCH(1);
    } while (1);

    //
    // Move to the first character beyond the = sign.
    //
    if (*lpsz)
        lpsz = CharNext(lpsz);

    return lpsz;
}


//+----------------------------------------------------------------------------
//
//    Function:    ImportCustomDialer
//
//    Synopsis:    Import custom dialer information from the specified file
//                and save the information in the RASENTRY
//
//    Arguments:    lpRasEntry - pointer to a valid RASENTRY structure
//                szFileName - text file (in .ini file format) containing the
//                Custom Dialer information
//
//    Returns:    ERROR_SUCCESS - success otherwise a Win32 error
//
//    History:    ChrisK    Created        7/11/96
//            8/12/96    ChrisK    Ported from \\trango
//
//-----------------------------------------------------------------------------
DWORD CINSHandler::ImportCustomDialer(LPRASENTRY lpRasEntry, LPCWSTR szFileName)
{

    // If there is an error reading the information from the file, or the entry
    // missing or blank, the default value (cszNull) will be used.
    GetPrivateProfileString(cszCustomDialerSection,
                            cszAutoDialDLL,
                            cszNull,
                            lpRasEntry->szAutodialDll,
                            MAX_CHARS_IN_BUFFER(lpRasEntry->szAutodialDll),
                            szFileName);

    GetPrivateProfileString(cszCustomDialerSection,
                            cszAutoDialFunc,
                            cszNull,
                            lpRasEntry->szAutodialFunc,
                            MAX_CHARS_IN_BUFFER(lpRasEntry->szAutodialFunc),
                            szFileName);

    return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL StrToip (LPWSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//****************************************************************************
LPCWSTR CINSHandler::StrToSubip (LPCWSTR szIPAddress, LPBYTE pVal)
{
    LPCWSTR  pszIP = szIPAddress;
    BYTE    val = 0;

    // skip separators (non digits)
    while (*pszIP && !myisdigit(*pszIP))
    {
          ++pszIP;
    }

    while (myisdigit(*pszIP))
    {
        val = (val * 10) + (BYTE)(*pszIP - L'0');
        ++pszIP;
    }

    *pVal = val;

    return pszIP;
}


DWORD CINSHandler::StrToip (LPCWSTR szIPAddress, RASIPADDR *ipAddr)
{
    LPCWSTR pszIP = szIPAddress;

    pszIP = StrToSubip(pszIP, &ipAddr->a);
    pszIP = StrToSubip(pszIP, &ipAddr->b);
    pszIP = StrToSubip(pszIP, &ipAddr->c);
    pszIP = StrToSubip(pszIP, &ipAddr->d);

    return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCWSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName)
{
    WCHAR   szYesNo[MAXNAME];

    if (GetPrivateProfileString(cszPhoneSection,
                               cszPhone,
                               cszNull,
                               lpRasEntry->szLocalPhoneNumber,
                               MAX_CHARS_IN_BUFFER(lpRasEntry->szLocalPhoneNumber),
                               szFileName) == 0)
    {
        return ERROR_BAD_PHONE_NUMBER;
    }

    lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

    GetPrivateProfileString(cszPhoneSection,
                            cszDialAsIs,
                            cszNo,
                            szYesNo,
                            MAX_CHARS_IN_BUFFER(szYesNo),
                            szFileName);

    // Do we have to get country code and area code?
    if (!lstrcmpi(szYesNo, cszNo))
    {

        // If we cannot get the country ID or it is zero, default to dial as is
        //
        if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
        {
            lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

            GetPrivateProfileString(cszPhoneSection,
                                      cszAreaCode,
                                      cszNull,
                                      lpRasEntry->szAreaCode,
                                      MAX_CHARS_IN_BUFFER(lpRasEntry->szAreaCode),
                                      szFileName);

            lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

        }
  }
  else
  {
      // bug in RasSetEntryProperties still checks area codes
      // even when RASEO_UseCountryAndAreaCodes is not set
      lstrcpy(lpRasEntry->szAreaCode, L"805");
      lpRasEntry->dwCountryID = 1;
      lpRasEntry->dwCountryCode = 1;
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPWSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportServerInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName)
{
    WCHAR   szYesNo[MAXNAME];
    WCHAR   szType[MAXNAME];
    DWORD  i;

    // Get the server type name
    GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          cszNull,
                          szType,
                          MAX_CHARS_IN_BUFFER(szType),
                          szFileName);

    // need to convert the string into
    // one of the following values
    //   RASFP_Ppp
    //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
    //   RASFP_Ras

    for (i = 0; i < NUM_SERVER_TYPES; ++i)
    {
        if (!lstrcmpi(aServerTypes[i].szType, szType))
        {
            lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
            lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
            break;
        }
    }

    // Get the server type settings
    if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              cszYes,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_SwCompression;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              cszNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              cszNo,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              cszNo,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
        }
    }

    // Get the protocol settings
    if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              cszNo,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              cszNo,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              cszYes,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ip;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
                              cszNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
        }
    }

    return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPWSTR szEntryName, LPWSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportIPInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName)
{
    WCHAR   szIPAddr[MAXIPADDRLEN];
    WCHAR   szYesNo[MAXNAME];

    // Import IP address information
    if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              cszNo,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            // The import file has IP address specified, get the IP address
            lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
            if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddr);
            }
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
        }
    }

    // Import Server address information
    if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              cszNo,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            // The import file has server address specified, get the server address
            lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
            if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
            }
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
        }
    }

    // Header compression and the gateway settings
    if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              cszYes,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        }
    }

    if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              cszYes,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
          lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
        }
        else
        {
          lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }
    }
    return ERROR_SUCCESS;
}

DWORD CINSHandler::ImportScriptFile(
    LPCWSTR lpszImportFile,
    LPWSTR szScriptFile,
    UINT cbScriptFile)
{
    WCHAR szTemp[_MAX_PATH];
    DWORD dwRet = ERROR_SUCCESS;

    // Get the script filename
    //
    if (GetPrivateProfileString(cszScriptingSection,
                                cszScriptName,
                                cszNull,
                                szTemp,
                                MAX_CHARS_IN_BUFFER(szTemp),
                                lpszImportFile) != 0)
    {

//!!! commonize this code
//!!! make it DBCS compatible
//!!! check for overruns
//!!! check for absolute path name
        GetWindowsDirectory(szScriptFile, cbScriptFile);
        if (*CharPrev(szScriptFile, szScriptFile + lstrlen(szScriptFile)) != L'\\')
        {
            lstrcat(szScriptFile, L"\\");
        }
        lstrcat(szScriptFile, szTemp);

        dwRet =ImportFile(lpszImportFile, cszScriptSection, szScriptFile);
    }

    return dwRet;
}

//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPWSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::RnaValidateImportEntry (LPCWSTR szFileName)
{
    WCHAR  szTmp[4];

    // Get the alias entry name
    //
    // 12/4/96    jmazner    Normandy #12373
    // If no such key, don't return ERROR_INVALID_PHONEBOOK_ENTRY,
    // since ConfigureClient always ignores that error code.

    return (GetPrivateProfileString(cszEntrySection,
                                  cszEntry_Name,
                                  cszNull,
                                  szTmp,
                                  MAX_CHARS_IN_BUFFER(szTmp),
                                  szFileName) > 0 ?
            ERROR_SUCCESS : ERROR_UNKNOWN);
}


DWORD CINSHandler::ImportRasEntry (LPCWSTR szFileName, LPRASENTRY lpRasEntry, LPBYTE & lpDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    DWORD         dwRet;

    dwRet = ImportPhoneInfo(lpRasEntry, szFileName);
    if (ERROR_SUCCESS == dwRet)
    {
        // Get device type
        //
        GetPrivateProfileString(cszDeviceSection,
                              cszDeviceType,
                              cszNull,
                              lpRasEntry->szDeviceType,
                              MAX_CHARS_IN_BUFFER(lpRasEntry->szDeviceType),
                              szFileName);

        // Get Server Type settings
        //
        dwRet = ImportServerInfo(lpRasEntry, szFileName);
        if (ERROR_SUCCESS == dwRet)
        {
            // Get IP address
            //
            dwRet = ImportIPInfo(lpRasEntry, szFileName);
        }
        if ( (ERROR_SUCCESS == dwRet) && (m_dwDeviceType == InetS_RASAtm) )
        {
            // Get ATM-Specific Information
            //
            dwRet = ImportAtmInfo(lpRasEntry, szFileName, lpDeviceInfo, lpdwDeviceInfoSize);
        }
    }

    return dwRet;
}

//****************************************************************************
// DWORD ImportATMInfo (LPRASENTRY, LPCWSTR, LPBYTE, LPDWORD)
//
// This function is called to import ATM Information into a buffer.
// Note: Memory is allocated in this function to accomodate ATM data.
//       This memory can be deallocated using delete.
//
// History:
//  Mon 1-Nov-1999 11:27:02  -by-  Thomas Jeyaseelan [thomasje]
// Created.
//****************************************************************************
DWORD CINSHandler::ImportAtmInfo (LPRASENTRY lpRasEntry, LPCWSTR cszFileName,
                                  LPBYTE  & lpDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    // Error handling. Make sure that lpDeviceInfo = 0 and lpdwDeviceInfo != 0
    // and lpdwDeviceInfo points to a DWORD that is assigned a value of 0.

    DWORD   dwRet = ERROR_SUCCESS; // <== investigate correct return value for failure
    
    if ( lpDeviceInfo && lpdwDeviceInfoSize && (*lpdwDeviceInfoSize == sizeof (ATMPBCONFIG) ) )
    {
        // Creating the ATM Buffer. Note that memory is allocated on the heap.
        // This memory must be carefully deallocated in one of the caller routines.
        LPATMPBCONFIG            lpAtmConfig = (LPATMPBCONFIG) lpDeviceInfo;
        DWORD dwCircuitSpeed    = 0;
        DWORD dwCircuitQOS      = 0;
        DWORD dwCircuitType     = 0;
        WCHAR szYesNo [MAXNAME]; // for Speed_Adjust, QOS_Adjust, Vendor_Config, Show_Status and Enable_Log.

        DWORD dwEncapsulation   = 0;
        DWORD dwVpi             = 0;
        DWORD dwVci             = 0;

        dwCircuitSpeed = GetPrivateProfileInt (cszATMSection, cszCircuitSpeed, dwCircuitSpeed, cszFileName);
        switch (dwCircuitSpeed) {
            case 0:
                lpAtmConfig->dwCircuitSpeed = ATM_CIRCUIT_SPEED_LINE_RATE;
                break;
            case 1:
                lpAtmConfig->dwCircuitSpeed = ATM_CIRCUIT_SPEED_USER_SPEC;
                break;
            case 512:
                lpAtmConfig->dwCircuitSpeed = ATM_CIRCUIT_SPEED_512KB;
                break;
            case 1536:
                lpAtmConfig->dwCircuitSpeed = ATM_CIRCUIT_SPEED_1536KB;
                break;
            case 25000:
                lpAtmConfig->dwCircuitSpeed = ATM_CIRCUIT_SPEED_25MB;
                break;
            case 155000:
                lpAtmConfig->dwCircuitSpeed = ATM_CIRCUIT_SPEED_155MB;
                break;
            default:
                lpAtmConfig->dwCircuitSpeed = ATM_CIRCUIT_SPEED_DEFAULT;
                break;
        }
        lpAtmConfig->dwCircuitOpt |= lpAtmConfig->dwCircuitSpeed;

        dwCircuitQOS   = GetPrivateProfileInt (cszATMSection, cszCircuitQOS, dwCircuitQOS, cszFileName);
        switch (dwCircuitQOS) {
            case 0:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_QOS_UBR;
                break;
            case 1:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_QOS_VBR;
                break;
            case 2:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_QOS_CBR;
                break;
            case 3:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_QOS_ABR;
                break;
            default:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_QOS_DEFAULT;
                break;
        }
        dwCircuitType  = GetPrivateProfileInt (cszATMSection, cszCircuitType, dwCircuitType, cszFileName);
        switch (dwCircuitType) {
            case 0:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_OPT_SVC;
                break;
            case 1:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_OPT_PVC;
                break;
            default:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_OPT_SVC;
                break;
        }
        dwEncapsulation = GetPrivateProfileInt (cszATMSection, cszEncapsulation, dwEncapsulation, cszFileName);
        switch (dwEncapsulation) {
            case 0:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_ENCAP_NULL;
                break;
            case 1:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_ENCAP_LLC;
                break;
            default:
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_ENCAP_DEFAULT;
                break;
        }
        dwVpi           = GetPrivateProfileInt (cszATMSection, cszVPI, dwVpi, cszFileName);
        lpAtmConfig->wPvcVpi = (WORD) dwVpi;
        dwVci           = GetPrivateProfileInt (cszATMSection, cszVCI, dwVci, cszFileName);
        lpAtmConfig->wPvcVci = (WORD) dwVci;

        // Speed_Adjust
        if (GetPrivateProfileString(cszATMSection,
                                    cszSpeedAdjust,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszFileName))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_OPT_SPEED_ADJUST;
            } else      {
                lpAtmConfig->dwCircuitOpt &= ~ATM_CIRCUIT_OPT_SPEED_ADJUST;
            }
        } else {
            // if this field is not correctly specified, we use the default settings
            // as specified in the ATMCFG header file.
            lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_OPT_SPEED_ADJUST;
        }

        // QOS_Adjust
        if (GetPrivateProfileString(cszATMSection,
                                    cszQOSAdjust,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszFileName))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_OPT_QOS_ADJUST;
            } else {
                lpAtmConfig->dwCircuitOpt &= ~ATM_CIRCUIT_OPT_QOS_ADJUST;
            }
        } else {
            lpAtmConfig->dwCircuitOpt |= ATM_CIRCUIT_OPT_QOS_ADJUST;
        }

        // Vendor_Config
        if (GetPrivateProfileString(cszATMSection,
                                    cszVendorConfig,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszFileName))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                lpAtmConfig->dwGeneralOpt |= ATM_GENERAL_OPT_VENDOR_CONFIG;
            } else {
                lpAtmConfig->dwGeneralOpt &= ~ATM_GENERAL_OPT_VENDOR_CONFIG;
            }
        } else {
            lpAtmConfig->dwGeneralOpt &= ~ATM_GENERAL_OPT_VENDOR_CONFIG;
        }

        // Show_Status
        if (GetPrivateProfileString(cszATMSection,
                                    cszShowStatus,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszFileName))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                lpAtmConfig->dwGeneralOpt |= ATM_GENERAL_OPT_SHOW_STATUS;
            } else {
                lpAtmConfig->dwGeneralOpt &= ~ATM_GENERAL_OPT_SHOW_STATUS;
            }
        } else {
            lpAtmConfig->dwGeneralOpt &= ~ATM_GENERAL_OPT_SHOW_STATUS;
        }

        // Enable_Log
        if (GetPrivateProfileString(cszATMSection,
                                    cszEnableLog,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszFileName))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                lpAtmConfig->dwGeneralOpt |= ATM_GENERAL_OPT_ENABLE_LOG;
            } else {
                lpAtmConfig->dwGeneralOpt &= ~ATM_GENERAL_OPT_ENABLE_LOG;
            }
        } else {
            lpAtmConfig->dwGeneralOpt &= ~ATM_GENERAL_OPT_ENABLE_LOG;
        }


    } else dwRet = ERROR_CANCELLED;

    return dwRet; // note that lpDeviceInfo now points to a buffer. also, *lpdwDeviceInfoSize > 0.
}



//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPWSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportConnection (LPCWSTR szFileName, LPICONNECTION lpConn,
                                     LPBYTE & lpDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    DWORD   dwRet;

    lpConn->RasEntry.dwSize = sizeof(RASENTRY);

    dwRet = RnaValidateImportEntry(szFileName);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    GetPrivateProfileString(cszEntrySection,
                          cszEntry_Name,
                          cszNull,
                          lpConn->szEntryName,
                          MAX_CHARS_IN_BUFFER(lpConn->szEntryName),
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          cszNull,
                          lpConn->szUserName,
                          MAX_CHARS_IN_BUFFER(lpConn->szUserName),
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          cszNull,
                          lpConn->szPassword,
                          MAX_CHARS_IN_BUFFER(lpConn->szPassword),
                          szFileName);

    // thomasje - We are no longer dealing with only RAS.
    //            There are two types of connections. One is RAS
    //            and the other is Ethernet. By exmining the device type
    //            we will call the correct engine to handle the matter.

        dwRet = ImportRasEntry(szFileName, &lpConn->RasEntry, lpDeviceInfo, lpdwDeviceInfoSize);
        if (ERROR_SUCCESS == dwRet)
        {
            dwRet = ImportCustomDialer(&lpConn->RasEntry, szFileName);
        }

        if (ERROR_SUCCESS == dwRet)
        {
            // Import the script file
            //
            dwRet = ImportScriptFile(szFileName,
                                     lpConn->RasEntry.szScript,
                                     MAX_CHARS_IN_BUFFER(lpConn->RasEntry.szScript));
        }

        // Use an ISPImport object to Config The ras device
        CISPImport  ISPImport;

        ISPImport.set_hWndMain(GetActiveWindow());
        dwRet = ISPImport.ConfigRasEntryDevice(&lpConn->RasEntry);
        switch( dwRet )
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_CANCELLED:
                /*
             if(!m_bSilentMode)
                InfoMsg1(NULL, IDS_SIGNUPCANCELLED, NULL);
                */
            // Fall through
            default:
                goto ImportConnectionExit;
        }
    ImportConnectionExit:
    return dwRet;
}

// Prototype for acct manager entry point we want
typedef HRESULT (WINAPI *PFNCREATEACCOUNTSFROMFILEEX)(LPSTR szFile, CONNECTINFO *pCI, DWORD dwFlags);

// Regkeys for Acct manager
#define ACCTMGR_PATHKEY L"SOFTWARE\\Microsoft\\Internet Account Manager"
#define ACCTMGR_DLLPATH L"DllPath"


// ############################################################################
//
//    Name:    ImportMailAndNewsInfo
//
//    Description:    Import information from INS file and set the associated
//                        registry keys for Internet Mail and News (Athena)
//
//    Input:    lpszFile - Fully qualified filename of INS file
//
//    Return:    Error value
//
//    History:        6/27/96            Created
//
// ############################################################################
DWORD CINSHandler::ImportMailAndNewsInfo(LPCWSTR lpszFile, BOOL fConnectPhone)
{
    USES_CONVERSION;
    DWORD dwRet = ERROR_SUCCESS;

    WCHAR szAcctMgrPath[MAX_PATH + 1] = L"";
    WCHAR szExpandedPath[MAX_PATH + 1] = L"";
    DWORD dwAcctMgrPathSize = 0;
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    HINSTANCE hInst = NULL;
    CONNECTINFO connectInfo;
    WCHAR szConnectoidName[RAS_MaxEntryName] = L"nogood\0";
    PFNCREATEACCOUNTSFROMFILEEX fp = NULL;


    // get path to the AcctMgr dll
    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACCTMGR_PATHKEY, 0, KEY_READ, &hKey);
    if ( (dwRet != ERROR_SUCCESS) || (NULL == hKey) )
    {
        // TraceMsg(TF_INSHANDLER, L"ImportMailAndNewsInfo couldn't open reg key %s\n", ACCTMGR_PATHKEY);
        return( dwRet );
    }

    dwAcctMgrPathSize = sizeof (szAcctMgrPath);
    dwRet = RegQueryValueEx(hKey, ACCTMGR_DLLPATH, NULL, NULL, (LPBYTE) szAcctMgrPath, &dwAcctMgrPathSize);


    RegCloseKey( hKey );

    if ( dwRet != ERROR_SUCCESS )
    {
        // TraceMsg(TF_INSHANDLER, L"ImportMailAndNewsInfo: RegQuery failed with error %d\n", dwRet);
        return( dwRet );
    }

    // 6/18/97 jmazner Olympus #6819
    // TraceMsg(TF_INSHANDLER, L"ImportMailAndNewsInfo: read in DllPath of %s\n", szAcctMgrPath);
    ExpandEnvironmentStrings( szAcctMgrPath, szExpandedPath, MAX_CHARS_IN_BUFFER(szExpandedPath) );

    //
    // 6/4/97 jmazner
    // if we created a connectoid, then get its name and use that as the
    // connection type.  Otherwise, assume we're supposed to connect via LAN
    //
    connectInfo.cbSize = sizeof(CONNECTINFO);
    connectInfo.type = CONNECT_LAN;

    if( fConnectPhone )
    {
        BOOL fEnabled = FALSE;

        dwRet = InetGetAutodial(&fEnabled, szConnectoidName, RAS_MaxEntryName);

        if( ERROR_SUCCESS==dwRet && szConnectoidName[0] )
        {
            connectInfo.type = CONNECT_RAS;
            lstrcpyn( connectInfo.szConnectoid, szConnectoidName, MAX_CHARS_IN_BUFFER(connectInfo.szConnectoid) );
            // TraceMsg(TF_INSHANDLER, L"ImportMailAndNewsInfo: setting connection type to RAS with %s\n", szConnectoidName);
        }
    }

    if( CONNECT_LAN == connectInfo.type )
    {
        // TraceMsg(TF_INSHANDLER, L"ImportMailAndNewsInfo: setting connection type to LAN\n");
        lstrcpy( connectInfo.szConnectoid, L"I said CONNECT_LAN!" );
    }



    hInst = LoadLibrary(szExpandedPath);
    if (hInst)
    {
        fp = (PFNCREATEACCOUNTSFROMFILEEX) GetProcAddress(hInst, "CreateAccountsFromFileEx");
        if (fp)
            hr = fp( W2A(lpszFile), &connectInfo, NULL );
    }
    else
    {
        // TraceMsg(TF_INSHANDLER, L"ImportMailAndNewsInfo unable to LoadLibrary on %s\n", szAcctMgrPath);
    }

    //
    // Clean up and release resourecs
    //
    if( hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    if( fp )
    {
        fp = NULL;
    }

    return dwRet;
}

// ############################################################################
//
//    Name:    WriteMailAndNewsKey
//
//    Description:    Read a string value from the given INS file and write it
//                    to the registry
//
//    Input:    hKey - Registry key where the data will be written
//            lpszSection - Section name inside of INS file where data is read
//                from
//            lpszValue -    Name of value to read from INS file
//            lpszBuff - buffer where data will be read into
//            dwBuffLen - size of lpszBuff
//            lpszSubKey - Value name where information will be written to
//            dwType - data type (Should always be REG_SZ)
//            lpszFileName - Fully qualified filename to INS file
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
HRESULT CINSHandler::WriteMailAndNewsKey(HKEY hKey, LPCWSTR lpszSection, LPCWSTR lpszValue,
                            LPWSTR lpszBuff, DWORD dwBuffLen, LPCWSTR lpszSubKey,
                            DWORD dwType, LPCWSTR lpszFile)
{
    ZeroMemory(lpszBuff, dwBuffLen);
    GetPrivateProfileString(lpszSection, lpszValue, L"", lpszBuff, dwBuffLen, lpszFile);
    if (lstrlen(lpszBuff))
    {
        return RegSetValueEx(hKey, lpszSubKey, 0, dwType, (CONST BYTE*)lpszBuff,
            BYTES_REQUIRED_BY_SZ(lpszBuff));
    }
    else
    {
        // TraceMsg(TF_INSHANDLER, L"ISIGNUP: WriteMailAndNewsKey, missing value in INS file\n");
        return ERROR_NO_MORE_ITEMS;
    }
}


// ############################################################################
//
//    Name:    PreparePassword
//
//    Description:    Encode given password and return value in place.  The
//                    encoding is done right to left in order to avoid having
//                    to allocate a copy of the data.  The encoding uses base64
//                    standard as specified in RFC 1341 5.2
//
//    Input:    szBuff - Null terminated data to be encoded
//            dwBuffLen - Full length of buffer, this should exceed the length of
//                the input data by at least 1/3
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
HRESULT CINSHandler::PreparePassword(LPWSTR szBuff, DWORD dwBuffLen)
{
    DWORD   dwX;
    LPWSTR   szOut = NULL;
    LPWSTR   szNext = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BYTE    bTemp = 0;
    DWORD   dwLen = 0;

    dwLen = lstrlen(szBuff);
    if (!dwLen)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    // Calculate the size of the buffer that will be needed to hold
    // encoded data
    //

    szNext = &szBuff[dwLen-1];
    dwLen = (((dwLen % 3 ? (3-(dwLen%3)):0) + dwLen) * 4 / 3);

    if (dwBuffLen < dwLen+1)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    szOut = &szBuff[dwLen];
    *szOut-- = L'\0';

    // Add padding = characters
    //

    switch (lstrlen(szBuff) % 3)
    {
    case 0:
        // no padding
        break;
    case 1:
        *szOut-- = 64;
        *szOut-- = 64;
        *szOut-- = (*szNext & 0x3) << 4;
        *szOut-- = (*szNext-- & 0xFC) >> 2;
        break;
    case 2:
        *szOut-- = 64;
        *szOut-- = (*szNext & 0xF) << 2;
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Encrypt data into indicies
    //

    while (szOut > szNext && szNext >= szBuff)
    {
        *szOut-- = *szNext & 0x3F;
        *szOut = ((*szNext-- & 0xC0) >> 6);
        *szOut-- |= ((*szNext & 0xF) << 2);
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Translate indicies into printable characters
    //

    szNext = szBuff;

    // BUG OSR#10435--if there is a 0 in the generated string of base-64
    // encoded digits (this can happen if the password is "Willypassword"
    // for example), then instead of encoding the 0 to 'A', we just quit
    // at this point, produces an invalid base-64 string.

    for(dwX=0; dwX < dwLen; dwX++)
        *szNext = arBase64[*szNext++];

PreparePasswordExit:
    return hr;
}

// ############################################################################
//
//    Name: FIsAthenaPresent
//
//    Description:    Determine if Microsoft Internet Mail And News client (Athena)
//                    is installed
//
//    Input:    none
//
//    Return:    TRUE - Athena is installed
//            FALSE - Athena is NOT installed
//
//    History:        7/1/96            Created
//
// ############################################################################
BOOL CINSHandler::FIsAthenaPresent()
{
    WCHAR        szBuff[MAX_PATH + 1];
    HRESULT     hr = ERROR_SUCCESS;
    HINSTANCE   hInst = NULL;
    DWORD       dwLen = 0;
    DWORD       dwType = REG_SZ;
    // Get path to Athena client
    //

    dwLen = MAX_PATH;
    hr = RegQueryValueEx(HKEY_CLASSES_ROOT,
                         MAIL_NEWS_INPROC_SERVER32,
                         NULL,
                         &dwType,
                         (LPBYTE) szBuff,
                         &dwLen);
    if (hr == ERROR_SUCCESS)
    {
        // Attempt to load client
        //

        hInst = LoadLibrary(szBuff);
        if (!hInst)
        {
            // TraceMsg(TF_INSHANDLER, L"ISIGNUP: Internet Mail and News server didn't load.\n");
            hr = ERROR_FILE_NOT_FOUND;
        }
        else
        {
            FreeLibrary(hInst);
        }
        hInst = NULL;
    }

    return (hr == ERROR_SUCCESS);
}

// ############################################################################
//
//    Name:    FTurnOffBrowserDefaultChecking
//
//    Description:    Turn Off IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
BOOL CINSHandler::FTurnOffBrowserDefaultChecking()
{
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    BOOL bRC = TRUE;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER, cszDEFAULT_BROWSER_KEY, &hKey))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Read current settings for check associations
    //
    dwType = 0;
    dwSize = sizeof(m_szCheckAssociations);
    ZeroMemory(m_szCheckAssociations, dwSize);
    RegQueryValueEx(hKey,
                    cszDEFAULT_BROWSER_VALUE,
                    0,
                    &dwType,
                    (LPBYTE)m_szCheckAssociations,
                    &dwSize);
    // ignore return value, even if the calls fails we are going to try
    // to change the setting to "NO"

    //
    // Set value to "no" to turn off checking
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)cszNo,
                      BYTES_REQUIRED_BY_SZ(cszNo)))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Clean up and return
    //
FTurnOffBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    if (bRC)
        m_fResforeDefCheck = TRUE;
    hKey = NULL;
    return bRC;
}

// ############################################################################
//
//    Name:    FRestoreBrowserDefaultChecking
//
//    Description:    Restore IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
BOOL CINSHandler::FRestoreBrowserDefaultChecking()
{
    HKEY hKey = NULL;
    BOOL bRC = TRUE;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER, cszDEFAULT_BROWSER_KEY, &hKey))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

    //
    // Set value to original value
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)m_szCheckAssociations,
                      BYTES_REQUIRED_BY_SZ(m_szCheckAssociations)))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

FRestoreBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    hKey = NULL;
    return bRC;
}



// This is the main entry point for processing an INS file.
// DJM: BUGBUG: TODO: Need to pass in branding flags
HRESULT CINSHandler::ProcessINS(
    LPCWSTR lpszFile, 
    LPWSTR lpszConnectoidName, 
    BOOL * pbRetVal
    )
{

    BOOL        fConnectoidCreated = FALSE;
    BOOL        fClientSetup       = FALSE;
    BOOL        bKeepConnection    = FALSE;
    BOOL        fErrMsgShown       = FALSE;
    HRESULT     hr                 = E_FAIL;
    LPRASENTRY  lpRasEntry         = NULL;
    WCHAR        szTemp[3]          = L"\0";
    WCHAR        szConnectoidName[RAS_MaxEntryName] = L"";

    if (NULL == lpszFile || NULL == lpszConnectoidName || NULL == pbRetVal )
    {
        MYASSERT(FALSE);
        return E_INVALIDARG;
    }

    *pbRetVal = FALSE;

    // The Connection has not been killed yet
    m_fConnectionKilled = FALSE;
    m_fNeedsRestart = FALSE;

    MYASSERT(NULL != lpszFile);

    if (0xFFFFFFFF == GetFileAttributes(lpszFile))
    {
        return E_FAIL;
    }

    do
    {
        // Make sure we can load the necessary extern support functions
        if (!LoadExternalFunctions())
            break;

        // Convert EOL chars in the passed file.
        if (FAILED(MassageFile(lpszFile)))
        {
            break;
        }
        if(GetPrivateProfileString(cszURLSection,
                                    cszStartURL,
                                    szNull,
                                    m_szStartURL,
                                    MAX_CHARS_IN_BUFFER(m_szStartURL),
                                    lpszFile) == 0)
        {
            m_szStartURL[0] = L'\0';
        }

        if (GetPrivateProfileString(cszEntrySection,
                                    cszCancel,
                                    szNull,
                                    szTemp,
                                    MAX_CHARS_IN_BUFFER(szTemp),
                                    lpszFile) != 0)
        {
            // We do not want to process a CANCEL.INS file
            // here.
            break;
        }

        // See if this INS has a client setup section
        if (GetPrivateProfileSection(cszClientSetupSection,
                                     szTemp,
                                     MAX_CHARS_IN_BUFFER(szTemp),
                                     lpszFile) != 0)
            fClientSetup = TRUE;

        // Process the trial reminder section, if it exists.  this needs to be
        // done BEFORE we allow the connection to be closed
        //
        // VYUNG 2/25/99 ReminderApp not supported by OOBE.
        // Ask WJPARK for more questions
        /*
        if (ConfigureTrialReminder(lpszFile))
        {
            // We configured a trial, so we need to launch the remind app now
            SHELLEXECUTEINFO    sei;

            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_NOCLOSEPROCESS;
            sei.hwnd = NULL;
            sei.lpVerb = cszOpen;
            sei.lpFile = cszReminderApp;
            sei.lpParameters = cszReminderParams;
            sei.lpDirectory = NULL;
            sei.nShow = SW_SHOWNORMAL;
            sei.hInstApp = NULL;
            // Optional members
            sei.hProcess = NULL;

            ShellExecuteEx(&sei);
        }*/

        // Check to see if we should keep the connection open.  The custom section
        // might want this for processing stuff
        if (!fClientSetup && !KeepConnection(lpszFile))
        {
            // Kill the connection
            gpCommMgr->m_pRefDial->DoHangup();
            m_fConnectionKilled = TRUE;
        }

        // Import the Custom Info
        ImportCustomInfo(lpszFile,
                         m_szRunExecutable,
                         MAX_CHARS_IN_BUFFER(m_szRunExecutable),
                         m_szRunArgument,
                         MAX_CHARS_IN_BUFFER(m_szRunArgument));

        ImportCustomFile(lpszFile);

        // configure the client.
        hr = ConfigureClient(GetActiveWindow(),
                             lpszFile,
                             &m_fNeedsRestart,
                             &fConnectoidCreated,
                             FALSE,
                             szConnectoidName,
                             RAS_MaxEntryName);
        if( ERROR_SUCCESS != hr )
        {
            /*if(!m_bSilentMode)
                ErrorMsg1(GetActiveWindow(), IDS_INSTALLFAILED, NULL);*/
            fErrMsgShown = TRUE;
        }

        lstrcpy(lpszConnectoidName, szConnectoidName);

        ImportBrandingInfo(lpszFile, szConnectoidName);

        // If we created a connectoid, tell the world that ICW
        // has left the building...
        if(ERROR_SUCCESS == hr)
            SetICWCompleted( (DWORD)1 );

        // 2/19/97 jmazner    Olympus 1106
        // For SBS/SAM integration.
        DWORD dwSBSRet = CallSBSConfig(GetActiveWindow(), lpszFile);
        switch( dwSBSRet )
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_MOD_NOT_FOUND:
            case ERROR_DLL_NOT_FOUND:
                // TraceMsg(TF_INSHANDLER, L"ISIGN32: SBSCFG DLL not found, I guess SAM ain't installed.\n");
                break;
        }

        //
        // If the INS file contains the ClientSetup section, build the commandline
        // arguments for ICWCONN2.exe.
        //
        if (fClientSetup)
        {
            // Check to see if a REBOOT is needed and tell the next application to
            // handle it.
            if (m_fNeedsRestart)
            {
                wsprintf(m_szRunArgument, L" /INS:\"%s\" /REBOOT", lpszFile);
                m_fNeedsRestart = FALSE;
            }
            else
            {       
                wsprintf(m_szRunArgument, L" /INS:\"%s\"", lpszFile);
            }
        }

        // humongous hack for ISBU
        if (ERROR_SUCCESS != hr && fConnectoidCreated)
        {
            //if(!m_bSilentMode)
            //    InfoMsg1(GetActiveWindow(), IDS_MAILFAILED, NULL);
            hr = ERROR_SUCCESS;
        }

        //
        // Import settings for mail and new read from INS file (ChrisK, 7/1/96)
        //
        if (ERROR_SUCCESS == hr)
        {
            ImportMailAndNewsInfo(lpszFile, fConnectoidCreated);

            // If we did not create a connectiod, then restore
            // the autodial one
            if (!fConnectoidCreated)
            {
                RestoreAutoDial();
            }
            else
            {
                SetDefaultConnectoid(AutodialTypeAlways, szConnectoidName);
            }
            //InetSetAutodial(TRUE, m_szAutodialConnection);

            // Delete the INS file now
            /**** VYUNG DO NOT REMOVE ISP FILE IN OOBE ****
            if (m_szRunExecutable[0] == L'\0')
            {
                DeleteFile(lpszFile);
            }*/
        }
        else
        {
            RestoreAutoDial();
        }


        if (m_szRunExecutable[0] != L'\0')
        {
            // Fire an event to the container telling it that we are
            // about to run a custom executable
            //Fire_RunningCustomExecutable();

            if FAILED(RunExecutable())
            {
                //if(!m_bSilentMode)
                //    ErrorMsg1(NULL, IDS_EXECFAILED, m_szRunExecutable);
            }

            // If the Connection has not been killed yet
            // then tell the browser to do it now
            if (!m_fConnectionKilled)
            {
                gpCommMgr->m_pRefDial->DoHangup();
                m_fConnectionKilled = TRUE;
            }
        }


        // If we get to here, we are successful.
        if(fConnectoidCreated && SUCCEEDED(hr))
            *pbRetVal = TRUE;
        break;

    }   while(1);

    return S_OK;
}

// If this is true, then the user will need to reboot, so
// the finish page should indicate this.
STDMETHODIMP CINSHandler::get_NeedRestart(BOOL *pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_fNeedsRestart;
    return S_OK;
}

STDMETHODIMP CINSHandler::put_BrandingFlags(long lFlags)
{
    m_dwBrandFlags = lFlags;
    return S_OK;
}

STDMETHODIMP CINSHandler::put_SilentMode(BOOL bSilent)
{
    m_bSilentMode = bSilent;
    return S_OK;
}

// If this is true, get the URL from the INS file
STDMETHODIMP CINSHandler::get_DefaultURL(BSTR *pszURL)
{
    if (pszURL == NULL)
        return E_POINTER;

    *pszURL = SysAllocString(m_szStartURL);
    return S_OK;
}

// This is the main entry point for merge an INS file.
HRESULT CINSHandler::MergeINSFiles(LPCWSTR lpszMainFile, LPCWSTR lpszOtherFile, LPWSTR lpszOutputFile, DWORD dwFNameSize)
{   
    PWSTR pszSection;
    WCHAR *pszKeys = NULL;
    PWSTR pszKey = NULL;
    WCHAR szValue[MAX_PATH];
    WCHAR szTempFileFullName[MAX_PATH];
    ULONG ulRetVal     = 0;
    HRESULT hr = E_FAIL;
    ULONG ulBufferSize = MAX_SECTIONS_BUFFER;
    WCHAR *pszSections = NULL;

    if (dwFNameSize < MAX_PATH)
        goto MergeINSFilesExit;

    // Check if branding file doesn't exists, just use the original
    if (0xFFFFFFFF == GetFileAttributes(lpszOtherFile))
    {
        lstrcpy(lpszOutputFile, lpszMainFile);
        return S_OK;
    }

    // Make sure it is an htm extension, otherwise, IE will promp for download
    GetTempPath(MAX_CHARS_IN_BUFFER(szTempFileFullName), szTempFileFullName);
    lstrcat(szTempFileFullName, L"OBEINS.htm");

    if(!CopyFile(lpszMainFile, szTempFileFullName, FALSE))
        goto MergeINSFilesExit;
    lstrcpy(lpszOutputFile, szTempFileFullName);

    //
    // Unfortunately the .ini file functions don't offer a direct way of updating
    // some entry value. So enumerate each of the sections of the .ini file, enumerate
    // each of the keys within each section, get the value for each of the keys,
    // write them to the value specified and if they compare equal.
    //

    // Loop to find the appropriate buffer size to retieve the ins to memory
    do
    {
        if (NULL != pszSections)
        {
            GlobalFree( pszSections);
            ulBufferSize += ulBufferSize;
        }
        pszSections = (LPWSTR)GlobalAlloc(GPTR, ulBufferSize*sizeof(WCHAR));
        if (NULL == pszSections)
        {
            goto MergeINSFilesExit;
        }

        ulRetVal = ::GetPrivateProfileString(NULL, NULL, L"", pszSections, ulBufferSize, lpszOtherFile);
        if (0 == ulRetVal)
        {
            goto MergeINSFilesExit;
        }
    } while (ulRetVal == (ulBufferSize - 2));

    pszSection = pszSections;
    ulRetVal= 0;

    while (*pszSection)
    {
        ulBufferSize = MAX_KEYS_BUFFER;
        ulRetVal = 0;

        // Loop to find the appropriate buffer size to retieve the ins to memory
        do
        {
            if (NULL != pszKeys)
            {
                GlobalFree( pszKeys );
                ulBufferSize += ulBufferSize;
            }
            pszKeys = (LPWSTR)GlobalAlloc(GPTR, ulBufferSize*sizeof(WCHAR));
            if (NULL == pszKeys)
            {
                goto MergeINSFilesExit;
            }

            ulRetVal = ::GetPrivateProfileString(pszSection, NULL, L"", pszKeys, ulBufferSize, lpszOtherFile);
            if (0 == ulRetVal)
            {
                goto MergeINSFilesExit;
            }
        } while (ulRetVal == (ulBufferSize - 2));

        // Enumerate each key value pair in the section
        pszKey = pszKeys;
        while (*pszKey)
        {
            ulRetVal = ::GetPrivateProfileString(pszSection, pszKey, L"", szValue, MAX_CHARS_IN_BUFFER(szValue), lpszOtherFile);
            if ((ulRetVal != 0) && (ulRetVal < (MAX_CHARS_IN_BUFFER(szValue) - 1)))
            {
                WritePrivateProfileString(pszSection, pszKey, szValue, szTempFileFullName);
            }
            pszKey += lstrlen(pszKey) + 1;
        }

        pszSection += lstrlen(pszSection) + 1;
    }

    hr = S_OK;


MergeINSFilesExit:

    if (pszSections)
        GlobalFree( pszSections );

    if (pszKeys)
        GlobalFree( pszKeys );

    return hr;
}


/*******************************************************************

  NAME:         ProcessOEMBrandINS

  SYNOPSIS:     Read OfflineOffers flag from the oeminfo.ini file

  ENTRY:        None

  RETURN:       True if OEM offline is read

********************************************************************/
BOOL CINSHandler::ProcessOEMBrandINS(
    BSTR bstrFileName,
    LPWSTR lpszConnectoidName
    )
{

    // OEM code
    //
    WCHAR szOeminfoPath         [MAX_PATH + 1];
    WCHAR szMergedINSFName      [MAX_PATH + 1];
    WCHAR szOrigINSFile         [MAX_PATH + 1];

    WCHAR *lpszTerminator       = NULL;
    WCHAR *lpszLastChar         = NULL;
    BOOL bRet = FALSE;

    // If we already checked, don't do it again
    //if( 0 != GetSystemDirectory( szOeminfoPath, MAX_PATH + 1 ) )
    {
        /*
        lpszTerminator = &(szOeminfoPath[ lstrlen(szOeminfoPath) ]);
        lpszLastChar = CharPrev( szOeminfoPath, lpszTerminator );

        if( L'\\' != *lpszLastChar )
        {
            lpszLastChar = CharNext( lpszLastChar );
            *lpszLastChar = L'\\';
            lpszLastChar = CharNext( lpszLastChar );
            *lpszLastChar = L'\0';
        }

        if (bstrFileName)
        {
            // Download INS case
            lstrcat( szOeminfoPath, cszOEMBRND );
            lstrcpy( szOrigINSFile, bstrFileName);
        }
        else
        {
            // Proconfig case
            lstrcpy( szPreCfgINSPath, szOeminfoPath);
            lstrcat( szPreCfgINSPath, cszISPCNFG );
            lstrcat( szOeminfoPath, cszOEMBRND );
            lstrcpy( szOrigINSFile, szPreCfgINSPath);
        }
        */

        // find the oemcnfg.ins file
        if (0 == SearchPath(NULL, cszOEMCNFG, NULL, MAX_PATH, szOeminfoPath, NULL))
        {
            *szOeminfoPath = L'\0';
        }

        if (bstrFileName) // if Filename is there, read the ins file
        {
            lstrcpy( szOrigINSFile, bstrFileName);
        }
        else
        {
            // find the ISPCNFG.ins file
            // If it is not there, it is ok.  It is not an error condition. Just bail out.
            WCHAR szINSPath[MAX_PATH];

            if (!GetOOBEPath((LPWSTR)szINSPath))
                return 0;

            lstrcat(szINSPath, L"\\HTML\\ISPSGNUP");

            if (0 == SearchPath(szINSPath, cszISPCNFG, NULL, MAX_PATH, szOrigINSFile, NULL))
            {
                *szOrigINSFile = L'\0';
                return 0;
            }
        }

        if (S_OK == MergeINSFiles(szOrigINSFile , szOeminfoPath, szMergedINSFName, MAX_PATH))
        {
            ProcessINS(szMergedINSFName, lpszConnectoidName, &bRet);
        }

        if (!bRet)
        {
            HKEY  hKey           = NULL;
            DWORD dwDisposition  = 0;
            DWORD dwFailed       = 1;
            WCHAR szIspName    [MAX_PATH+1] = L"\0";
            WCHAR szSupportNum [MAX_PATH+1] = L"\0";

            //ProcessINS will nuke the file so if we want this info we should get it now
            GetPrivateProfileString(OEM_CONFIG_INS_SECTION,
                                    OEM_CONFIG_INS_ISPNAME,
                                    L"",
                                    szIspName,
                                    MAX_CHARS_IN_BUFFER(szIspName),
                                    szMergedINSFName);

            GetPrivateProfileString(OEM_CONFIG_INS_SECTION,
                                    OEM_CONFIG_INS_SUPPORTNUM,
                                    L"",
                                    szSupportNum,
                                    MAX_CHARS_IN_BUFFER(szSupportNum),
                                    szMergedINSFName);

            RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           OEM_CONFIG_REGKEY,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKey,
                           &dwDisposition);

            if(hKey)
            {
                RegSetValueEx(hKey,
                              OEM_CONFIG_REGVAL_FAILED,
                              0,
                              REG_DWORD,
                              (LPBYTE)&dwFailed,
                              sizeof(dwFailed));
            
                RegSetValueEx(hKey,
                              OEM_CONFIG_REGVAL_ISPNAME,
                              0,
                              REG_SZ,
                              (LPBYTE)szIspName,
                              BYTES_REQUIRED_BY_SZ(szIspName) 
                              );

                RegSetValueEx(hKey,
                              OEM_CONFIG_REGVAL_SUPPORTNUM,
                              0,
                              REG_SZ,
                              (LPBYTE)szSupportNum,
                              BYTES_REQUIRED_BY_SZ(szSupportNum)
                              );

                RegCloseKey(hKey);

            }
        }

    }

    return bRet;
}

// This function will restore connetoid password
HRESULT CINSHandler::RestoreConnectoidInfo()
{
    WCHAR               szPassword[PWLEN+1];
    WCHAR               szConnectoid[MAX_RASENTRYNAME+1];
    LPRASDIALPARAMS     lpRasDialParams = NULL;
    HRESULT             hr = ERROR_SUCCESS;
    BOOL                bPW;
    DWORD               dwSize;
    RNAAPI              *pcRNA = new RNAAPI;

    if (!pcRNA)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto RestoreConnectoidInfoExit;
    }

    dwSize = sizeof(szConnectoid);
    ReadSignUpReg((LPBYTE)szConnectoid, &dwSize, REG_SZ, CONNECTOIDNAME);

    // Get connectoid information
    //
    lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR, sizeof(RASDIALPARAMS));
    if (!lpRasDialParams)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto RestoreConnectoidInfoExit;
    }
    lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
    lstrcpyn(lpRasDialParams->szEntryName, szConnectoid, MAX_CHARS_IN_BUFFER(lpRasDialParams->szEntryName));
    bPW = FALSE;
    hr = pcRNA->RasGetEntryDialParams(NULL, lpRasDialParams, &bPW);
    if (hr != ERROR_SUCCESS)
    {
        goto RestoreConnectoidInfoExit;
    }

    // If the original connectoid had password, do not reset it
    if (lstrlen(lpRasDialParams->szPassword) == 0)
    {
        szPassword[0] = 0;
        dwSize = sizeof(szPassword);
        ReadSignUpReg((LPBYTE)szPassword, &dwSize, REG_SZ, ACCESSINFO);
        if(szPassword[0])
            lstrcpy(lpRasDialParams->szPassword, szPassword);
        hr = pcRNA->RasSetEntryDialParams(NULL, lpRasDialParams, FALSE);
    }



RestoreConnectoidInfoExit:
    DeleteSignUpReg(CONNECTOIDNAME);
    DeleteSignUpReg(ACCESSINFO);
    if (lpRasDialParams)
        GlobalFree(lpRasDialParams);
    lpRasDialParams = NULL;

    if (pcRNA)
        delete pcRNA;

    return hr;
}


DWORD CINSHandler::InetSImportLanConnection(LANINFO& LANINFO,                                               LPCWSTR cszINSFile)
{
    if (
        cszINSFile &&
        ( GetPrivateProfileString( cszDeviceSection, cszPnpId, L"", LANINFO.szPnPId, MAX_CHARS_IN_BUFFER (LANINFO.szPnPId), cszINSFile ) != 0 ) &&
        ( InetSImportTcpIpModule ( LANINFO.TcpIpInfo, cszINSFile ) == ERROR_SUCCESS )
       )
       return ERROR_SUCCESS;
    else return E_FAIL;
}


// Caution: Memory might have been allocated.
// this function is currently not used, due to lack of legacy support.
DWORD CINSHandler::InetSImportRasConnection(RASINFO &RasEntry, LPCWSTR cszINSFile)
{
    if (!cszINSFile) return ERROR_INVALID_PARAMETER;

    // how do you get the RAS Entry and RAS Phonebook Entry information ?

    ImportPhoneInfo ( &RasEntry.RasEntry, cszINSFile );

    ImportServerInfo( &RasEntry.RasEntry, cszINSFile );

    ImportIPInfo    ( &RasEntry.RasEntry, cszINSFile );

    // Now, we consider the device-specific data.
    switch ( m_dwDeviceType ) {
    case InetS_RASAtm: {
        ATMPBCONFIG         AtmMod;
        memset ( &AtmMod, 0, sizeof (ATMPBCONFIG) );
        if (InetSImportAtmModule ( AtmMod, cszINSFile ) != ERROR_SUCCESS) {
            // function aborted as ATM Module fails
            return E_ABORT;
        }

        // copy this into the RASINFO Buffer.
        // the lpDeviceInfo and dwDeviceInfoSize cannot have been previously used!
        if ( RasEntry.lpDeviceInfo || RasEntry.dwDeviceInfoSize ) {
            return ERROR_INVALID_PARAMETER;
        }
        if (! (RasEntry.lpDeviceInfo = (LPBYTE) malloc (sizeof(ATMPBCONFIG))) ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy ( RasEntry.lpDeviceInfo, &AtmMod, sizeof (ATMPBCONFIG) );
        RasEntry.dwDeviceInfoSize = sizeof (ATMPBCONFIG);
        }
        break;
    default:
        break;
    }

    return ERROR_SUCCESS;
}

DWORD CINSHandler::InetSImportTcpIpModule(TCPIP_INFO_EXT &TcpIpInfoMod, LPCWSTR cszINSFile)
{
    DWORD       nReturnValue = ERROR_SUCCESS;
    WCHAR    szYesNo [GEN_MAX_STRING_LENGTH]; // temporary buffer for storing Yes/No results

    if (!cszINSFile) {
        return ERROR_INVALID_PARAMETER;
    }
    // IP

    GetPrivateProfileString( cszIPSection, cszIPSpec, cszNo, szYesNo, MAX_CHARS_IN_BUFFER (szYesNo ), cszINSFile );

    if (!(TcpIpInfoMod.EnableIP = !lstrcmpi(szYesNo, cszYes))) {
        // we do not need to look for IPAddress or IPMask values if EnableIP is false.
        goto GATEWAY;
    }

    GetPrivateProfileString( cszIPSection, cszIPAddress, cszNullIP, TcpIpInfoMod.szIPAddress, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szIPAddress), cszINSFile );

    GetPrivateProfileString( cszIPSection, cszIPMask, cszNullIP, TcpIpInfoMod.szIPMask, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szIPMask), cszINSFile );


GATEWAY:
    GetPrivateProfileString( cszIPSection, cszGatewayList, cszNullIP, TcpIpInfoMod.szDefaultGatewayList, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szDefaultGatewayList), cszINSFile );

// DNS:  we do not need to mention "DNS:" but will do so within comments, for clarity.
    
    // DNS
    GetPrivateProfileString( cszIPSection, cszDNSSpec, cszNo, szYesNo, MAX_CHARS_IN_BUFFER (szYesNo ), cszINSFile );

    if (!(TcpIpInfoMod.EnableDNS = !lstrcmpi(szYesNo, cszYes))) {
        // we do not need to look for other DNS entries if EnableDNS is false.
        goto WINS;
    }
    
    GetPrivateProfileString( cszIPSection, cszHostName, cszNull, TcpIpInfoMod.szHostName, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szHostName), cszINSFile );

    GetPrivateProfileString( cszIPSection, cszDomainName, cszNull, TcpIpInfoMod.szDomainName, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szDomainName), cszINSFile );

    GetPrivateProfileString( cszIPSection, cszDNSList, cszNullIP, TcpIpInfoMod.szDNSList, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szDNSList), cszINSFile );

    GetPrivateProfileString( cszIPSection, cszDomainSuffixSearchList, cszNull, TcpIpInfoMod.szSuffixSearchList, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szSuffixSearchList), cszINSFile );


    // WINS
WINS:
    GetPrivateProfileString( cszIPSection, cszWINSSpec, cszNo, szYesNo, MAX_CHARS_IN_BUFFER (szYesNo ), cszINSFile );

    if (!(TcpIpInfoMod.EnableWINS = !lstrcmpi(szYesNo, cszYes))) {
        // we do not need to look for other DNS entries if EnableDNS is false.
        goto DHCP;
    }
    
    GetPrivateProfileString( cszIPSection, cszWINSList, cszNullIP, TcpIpInfoMod.szWINSList, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szWINSList), cszINSFile );

    TcpIpInfoMod.uiScopeID = GetPrivateProfileInt   ( cszIPSection, cszScopeID, ~0x0, cszINSFile );

    // DHCP
DHCP:
    GetPrivateProfileString( cszIPSection, cszDHCPSpec, cszNo, szYesNo, MAX_CHARS_IN_BUFFER (szYesNo ), cszINSFile );

    if (!(TcpIpInfoMod.EnableDHCP = !lstrcmpi(szYesNo, cszYes))) {
        // we do not need to look for other DNS entries if EnableDNS is false.
        goto end;
    }
    
    GetPrivateProfileString( cszIPSection, cszDHCPServer, cszNullIP, TcpIpInfoMod.szDHCPServer, MAX_CHARS_IN_BUFFER (TcpIpInfoMod.szDHCPServer), cszINSFile );

end:
    return nReturnValue;
}

DWORD CINSHandler::InetSImportRfc1483Connection ( RFC1483INFO &Rfc1483Info, LPCWSTR cszINSFile )
{
    BOOL    bBufGiven       = FALSE;
    if ( !cszINSFile ) return ERROR_INVALID_PARAMETER;



    if (  ( Rfc1483Info.Rfc1483Module.dwRegSettingsBufSize!=0 && Rfc1483Info.Rfc1483Module.lpbRegSettingsBuf==NULL) ||
          ( Rfc1483Info.Rfc1483Module.dwRegSettingsBufSize==0 && Rfc1483Info.Rfc1483Module.lpbRegSettingsBuf!=NULL)
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    bBufGiven = (BOOL) (Rfc1483Info.Rfc1483Module.dwRegSettingsBufSize != 0);

    if ( InetSImportRfc1483Module ( Rfc1483Info.Rfc1483Module, cszINSFile ) != ERROR_SUCCESS ) {
        return E_FAIL;
    }

    if ( !bBufGiven ) return ERROR_SUCCESS;

    if ( InetSImportLanConnection ( Rfc1483Info.TcpIpInfo, cszINSFile ) != ERROR_SUCCESS ) {
        return E_FAIL;
    }

    return ERROR_SUCCESS;
}

DWORD CINSHandler::InetSImportPppoeConnection ( PPPOEINFO &PppoeInfo, LPCWSTR cszINSFile )
{
    BOOL    bBufGiven       = FALSE;
    if ( !cszINSFile ) return ERROR_INVALID_PARAMETER;



    if (!( (PppoeInfo.PppoeModule.dwRegSettingsBufSize==0) ^ 
           (PppoeInfo.PppoeModule.lpbRegSettingsBuf==NULL)) ) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    bBufGiven = (BOOL) !PppoeInfo.PppoeModule.dwRegSettingsBufSize;

    if ( InetSImportPppoeModule ( PppoeInfo.PppoeModule, cszINSFile ) != ERROR_SUCCESS ) {
        return E_FAIL;
    }

    if ( !bBufGiven ) return ERROR_SUCCESS;

    if ( InetSImportLanConnection ( PppoeInfo.TcpIpInfo, cszINSFile ) != ERROR_SUCCESS ) {
        return E_FAIL;
    }

    return ERROR_SUCCESS;
}

DWORD CINSHandler::InetSImportRfc1483Module (RFC1483_INFO_EXT &Rfc1483InfoMod, LPCWSTR cszINSFile)
{
    static const INT CCH_BUF_MIN        = 200;
    static const INT CCH_BUF_PAD        = 10;
    LPBYTE           lpbTempBuf          = NULL;
    DWORD            cchTempBuf       = 0;
    DWORD            cchFinalBuf      = 0; // not required but used for clarity.
    BOOL             bBufferGiven        = FALSE;

    if (!cszINSFile) return ERROR_INVALID_PARAMETER;
    
    // check if a buffer has been given, or a buffer size is required.
    if ( !(Rfc1483InfoMod.dwRegSettingsBufSize) ) 
    {
        // we will create a temporary buffer to find out how large a buffer we need
        // to accomodate the entire 1483 section. this buffer will be freed at the
        // end of the function (or if error conditions arise).
        bBufferGiven = FALSE;
        if ( !(lpbTempBuf = (LPBYTE) malloc (BYTES_REQUIRED_BY_CCH(CCH_BUF_MIN))) ) 
        {
            return ERROR_OUTOFMEMORY;
        }
        cchTempBuf = CCH_BUF_MIN;

    } 
    else 
    {
        bBufferGiven  = TRUE;
        lpbTempBuf    = Rfc1483InfoMod.lpbRegSettingsBuf;
        cchTempBuf = Rfc1483InfoMod.dwRegSettingsBufSize;

    }
    while  ( (cchFinalBuf = GetPrivateProfileSection(
                                                cszRfc1483Section, 
                                                (WCHAR*)lpbTempBuf, 
                                                cchTempBuf, 
                                                cszINSFile
                                                )
              ) == (cchTempBuf - 2) 
                                                
            ) 
    {
        if (!bBufferGiven)
        {
            if ( !(lpbTempBuf = (LPBYTE) realloc (lpbTempBuf, BYTES_REQUIRED_BY_CCH(cchTempBuf = cchTempBuf * 2) ))) 
            {
                free (lpbTempBuf);
                return ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            // if the caller has provided a buffer, we do not reallocate it
            // to try to fit the section in. the caller has to reallocate it.
            return ERROR_INSUFFICIENT_BUFFER;
        }

    }
    if ( bBufferGiven ) 
    {
        return ERROR_SUCCESS;
    }
    else
    {
        free (lpbTempBuf); // clear the temporary buffer.
        Rfc1483InfoMod.dwRegSettingsBufSize = BYTES_REQUIRED_BY_CCH(cchFinalBuf + 1 + CCH_BUF_PAD); // needed for '\0'. BUGBUG: WHY ARE WE PADDING THE BUFFER?
        return ERROR_SUCCESS;

    }
}

DWORD CINSHandler::InetSImportPppoeModule (PPPOE_INFO_EXT &PppoeInfoMod, LPCWSTR cszINSFile)
{
    static const INT MIN_BUF_SIZE        = 200;
    static const INT CCH_BUF_PAD         = 10;
    LPBYTE           lpbTempBuf          = NULL;
    DWORD            cchTempBuf          = 0;
    DWORD            cchFinalBuf         = 0; // not required but used for clarity.
    BOOL             bBufferGiven        = FALSE;

    if (!cszINSFile) return ERROR_INVALID_PARAMETER;
    
    // check if a buffer has been given, or a buffer size is required.
    if ( !(PppoeInfoMod.dwRegSettingsBufSize) ) 
    {
        // we will create a temporary buffer to find out how large a buffer we need
        // to accomodate the entire pppoe section. this buffer will be freed at the
        // end of the function (or if error conditions arise).
        bBufferGiven = FALSE;
        if ( !(lpbTempBuf = (LPBYTE) malloc (MIN_BUF_SIZE*sizeof(WCHAR))) ) 
        {
            return ERROR_OUTOFMEMORY;
        }
        cchTempBuf = MIN_BUF_SIZE;

    } 
    else 
    {
        bBufferGiven  = TRUE;
        lpbTempBuf    = PppoeInfoMod.lpbRegSettingsBuf;
        cchTempBuf = PppoeInfoMod.dwRegSettingsBufSize / sizeof(WCHAR);

    }
    while  ( (cchFinalBuf = GetPrivateProfileSection (cszPppoeSection, (WCHAR*)lpbTempBuf, cchTempBuf, cszINSFile)) == (cchTempBuf - 2) ) 
    {
        if (!bBufferGiven)
        {
            cchTempBuf *= 2;
            if ( !(lpbTempBuf = (LPBYTE) realloc (lpbTempBuf, cchTempBuf*sizeof(WCHAR) ))) 
            {
                free (lpbTempBuf);
                return ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            // if the caller has provided a buffer, we do not reallocate it
            // to try to fit the section in. the caller has to reallocate it.
            return ERROR_INSUFFICIENT_BUFFER;
        }

    }
    if ( bBufferGiven ) 
    {
        return ERROR_SUCCESS;
    }
    else
    {
        free (lpbTempBuf); // clear the temporary buffer.
        PppoeInfoMod.dwRegSettingsBufSize = BYTES_REQUIRED_BY_CCH(cchFinalBuf+CCH_BUF_PAD);
        return ERROR_SUCCESS;

    }
}


// It is acceptable for many of the values to be default. if a 
// parameter is not given in the file, the default will be chosen.
DWORD CINSHandler::InetSImportAtmModule(ATMPBCONFIG &AtmInfoMod, LPCWSTR cszINSFile)
{
    if (!cszINSFile) return ERROR_INVALID_PARAMETER;

    DWORD dwCircuitSpeed    = 0;
    DWORD dwCircuitQOS      = 0;
    DWORD dwCircuitType     = 0;

    DWORD dwEncapsulation   = 0;
    DWORD dwVpi             = 0;
    DWORD dwVci             = 0;

    WCHAR szYesNo [MAXNAME]; // for Speed_Adjust, QOS_Adjust, Vendor_Config, Show_Status and Enable_Log.


    dwCircuitSpeed = GetPrivateProfileInt (cszATMSection, cszCircuitSpeed, dwCircuitSpeed, cszINSFile);
    AtmInfoMod.dwCircuitSpeed &= ~ATM_CIRCUIT_SPEED_MASK;
        switch (dwCircuitSpeed) {
            case 0:
                AtmInfoMod.dwCircuitSpeed = ATM_CIRCUIT_SPEED_LINE_RATE;
                break;
            case 1:
                AtmInfoMod.dwCircuitSpeed = ATM_CIRCUIT_SPEED_USER_SPEC;
                break;
            case 512:
                AtmInfoMod.dwCircuitSpeed = ATM_CIRCUIT_SPEED_512KB;
                break;
            case 1536:
                AtmInfoMod.dwCircuitSpeed = ATM_CIRCUIT_SPEED_1536KB;
                break;
            case 25000:
                AtmInfoMod.dwCircuitSpeed = ATM_CIRCUIT_SPEED_25MB;
                break;
            case 155000:
                AtmInfoMod.dwCircuitSpeed = ATM_CIRCUIT_SPEED_155MB;
                break;
            default:
                AtmInfoMod.dwCircuitSpeed = ATM_CIRCUIT_SPEED_DEFAULT;
                break;
        }
        AtmInfoMod.dwCircuitOpt &= ~ATM_CIRCUIT_SPEED_MASK;
        AtmInfoMod.dwCircuitOpt |= AtmInfoMod.dwCircuitSpeed;

        dwCircuitQOS   = GetPrivateProfileInt (cszATMSection, cszCircuitQOS, dwCircuitQOS, cszINSFile);
        AtmInfoMod.dwCircuitOpt &= ~ATM_CIRCUIT_QOS_MASK;
        switch (dwCircuitQOS) {
            case 0:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_QOS_UBR;
                break;
            case 1:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_QOS_VBR;
                break;
            case 2:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_QOS_CBR;
                break;
            case 3:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_QOS_ABR;
                break;
            default:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_QOS_DEFAULT;
                break;
        }
        dwCircuitType  = GetPrivateProfileInt (cszATMSection, cszCircuitType, dwCircuitType, cszINSFile);
        AtmInfoMod.dwCircuitOpt &= ~ATM_CIRCUIT_OPT_MASK;
        switch (dwCircuitType) {
            case 0:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_OPT_SVC;
                break;
            case 1:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_OPT_PVC;
                break;
            default:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_OPT_SVC;
                break;
        }
        dwEncapsulation = GetPrivateProfileInt (cszATMSection, cszEncapsulation, dwEncapsulation, cszINSFile);
        AtmInfoMod.dwCircuitOpt &= ~ATM_CIRCUIT_ENCAP_MASK;
        switch (dwEncapsulation) {
            case 0:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_ENCAP_NULL;
                break;
            case 1:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_ENCAP_LLC;
                break;
            default:
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_ENCAP_DEFAULT;
                break;
        }
        dwVpi           = GetPrivateProfileInt (cszATMSection, cszVPI, dwVpi, cszINSFile);
        AtmInfoMod.wPvcVpi = (WORD) dwVpi;
        dwVci           = GetPrivateProfileInt (cszATMSection, cszVCI, dwVci, cszINSFile);
        AtmInfoMod.wPvcVci = (WORD) dwVci;

        // Speed_Adjust
        if (GetPrivateProfileString(cszATMSection,
                                    cszSpeedAdjust,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszINSFile))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_OPT_SPEED_ADJUST;
            } else      {
                AtmInfoMod.dwCircuitOpt &= ~ATM_CIRCUIT_OPT_SPEED_ADJUST;
            }
        } else {
            // if this field is not correctly specified, we use the default settings
            // as specified in the ATMCFG header file.
            AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_OPT_SPEED_ADJUST;
        }

        // QOS_Adjust
        if (GetPrivateProfileString(cszATMSection,
                                    cszQOSAdjust,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszINSFile))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_OPT_QOS_ADJUST;
            } else {
                AtmInfoMod.dwCircuitOpt &= ~ATM_CIRCUIT_OPT_QOS_ADJUST;
            }
        } else {
            AtmInfoMod.dwCircuitOpt |= ATM_CIRCUIT_OPT_QOS_ADJUST;
        }

        // Vendor_Config
        AtmInfoMod.dwGeneralOpt &= ~ATM_GENERAL_OPT_MASK;
        if (GetPrivateProfileString(cszATMSection,
                                    cszVendorConfig,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszINSFile))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                AtmInfoMod.dwGeneralOpt |= ATM_GENERAL_OPT_VENDOR_CONFIG;
            } else {
                AtmInfoMod.dwGeneralOpt &= ~ATM_GENERAL_OPT_VENDOR_CONFIG;
            }
        } else {
            AtmInfoMod.dwGeneralOpt &= ~ATM_GENERAL_OPT_VENDOR_CONFIG;
        }

        // Show_Status
        if (GetPrivateProfileString(cszATMSection,
                                    cszShowStatus,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszINSFile))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                AtmInfoMod.dwGeneralOpt |= ATM_GENERAL_OPT_SHOW_STATUS;
            } else {
                AtmInfoMod.dwGeneralOpt &= ~ATM_GENERAL_OPT_SHOW_STATUS;
            }
        } else {
            AtmInfoMod.dwGeneralOpt &= ~ATM_GENERAL_OPT_SHOW_STATUS;
        }

        // Enable_Log
        if (GetPrivateProfileString(cszATMSection,
                                    cszEnableLog,
                                    cszYes,
                                    szYesNo,
                                    MAX_CHARS_IN_BUFFER(szYesNo),
                                    cszINSFile))
        {
            if (!lstrcmpi(szYesNo, cszYes)) {
                AtmInfoMod.dwGeneralOpt |= ATM_GENERAL_OPT_ENABLE_LOG;
            } else {
                AtmInfoMod.dwGeneralOpt &= ~ATM_GENERAL_OPT_ENABLE_LOG;
            }
        } else {
            AtmInfoMod.dwGeneralOpt &= ~ATM_GENERAL_OPT_ENABLE_LOG;
        }

        return ERROR_SUCCESS;
}


DWORD CINSHandler::InetSGetConnectionType ( LPCWSTR cszINSFile ) {
    WCHAR   szDeviceTypeBuf [MAX_PATH];
    DWORD   dwBufSize = MAX_CHARS_IN_BUFFER (szDeviceTypeBuf);

    if (!GetPrivateProfileString ( cszDeviceSection, cszDeviceType, szNull, szDeviceTypeBuf, dwBufSize, cszINSFile ) ) {
        return (m_dwDeviceType = 0);
    }

    if (!lstrcmpi (szDeviceTypeBuf, RASDT_Modem)) {
        return (m_dwDeviceType = InetS_RASModem);
    }
    if (!lstrcmpi (szDeviceTypeBuf, RASDT_Isdn))  {
        return (m_dwDeviceType = InetS_RASIsdn);
    }
    if (!lstrcmpi (szDeviceTypeBuf, RASDT_Atm))   {
        return (m_dwDeviceType = InetS_RASAtm);
    }
    if (!lstrcmpi (szDeviceTypeBuf, LANDT_Cable)) {
        return (m_dwDeviceType = InetS_LANCable);
    }
    if (!lstrcmpi (szDeviceTypeBuf, LANDT_Ethernet)) {
        return (m_dwDeviceType = InetS_LANEthernet);
    }
    if (!lstrcmpi (szDeviceTypeBuf, LANDT_Pppoe)) {
        return (m_dwDeviceType = InetS_LANPppoe);
    }
    if (!lstrcmpi (szDeviceTypeBuf, LANDT_1483)) {
        return (m_dwDeviceType = InetS_LAN1483);
    }
    return (m_dwDeviceType = InetS_RASModem); // we default to modem!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\ispcsv.h ===
//**********************************************************************
// File name: ISPCSV.H
//
//      Definition of CISPCSV
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _ISPCSV_H_ )
#define _ISPCSV_H_

#include "ccsv.h"

#define MAX_GUID            50
#define TEMP_BUFFER_LENGTH  1024

#define NUM_ISPCSV_FIELDS   14

class CISPCSV
{
    private:
        int     iISPLogoIndex;
        
        // The following members represent the content of a single line from the CSV file.

        int     iSpecialVal;                        // if bIsSpecial is TRUE, then 0 = NO Offers and -1 = OLS offer
        BOOL    bCNS;
        BOOL    bIsSpecial;                         // If true, then CNS value was "special"
        BOOL    bSecureConnection;
        WORD    wOfferID;
        DWORD   dwCfgFlag;
        DWORD   dwRequiredUserInputFlags;
        WCHAR   szISPLogoPath         [MAX_PATH];
        WCHAR   szISPTierLogoPath     [MAX_PATH];
        WCHAR   szISPTeaserPath       [MAX_PATH];
        WCHAR   szISPMarketingHTMPath [MAX_PATH];
        WCHAR   szISPFilePath         [MAX_PATH];
        WCHAR   szISPName             [MAX_ISP_NAME];
        WCHAR   szCNSIconPath         [MAX_PATH];
        WCHAR   szBillingFormPath     [MAX_PATH];
        WCHAR   szPayCSVPath          [MAX_PATH];
        WCHAR   szOfferGUID           [MAX_GUID];
        WCHAR   szMir                 [MAX_ISP_NAME];
        WORD    wLCID;
        HICON   hbmTierIcon;
                                                        
    public:

        CISPCSV(void) 
        {
            memset(this, 0, sizeof(CISPCSV));            
        }
        
        ~CISPCSV(void);
         
        HRESULT ReadOneLine             (CCSVFile far *pcCSVFile);      
        HRESULT ReadFirstLine           (CCSVFile far *pcCSVFile);
        void    StripQuotes             (LPWSTR   lpszDst, LPWSTR   lpszSrc);
        BOOL    ReadDW                  (DWORD far *pdw, CCSVFile far *pcCSVFile);
        BOOL    ReadW                   (WORD far *pw, CCSVFile far *pcCSVFile);
        BOOL    ReadWEx                 (WORD far *pw, CCSVFile far *pcCSVFile); //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
        BOOL    ReadB                   (BYTE far *pb, CCSVFile far *pcCSVFile);
        BOOL    ReadBOOL                (BOOL far *pbool, CCSVFile far *pcCSVFile);
        BOOL    ReadSPECIAL             (BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt, CCSVFile far *pcCSVFile);
        BOOL    ReadSZ                  (LPWSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
        BOOL    ReadToEOL               (CCSVFile far *pcCSVFile);
        BOOL    ValidateFile            (WCHAR* pszFile);
        void    MakeCompleteURL         (LPWSTR lpszURL, LPWSTR  lpszSRC);     
        
        LPWSTR   get_szISPLogoPath(void)
        {
            return szISPLogoPath;
        }   

        LPWSTR   get_szISPTierLogoPath(void)
        {
            return szISPTierLogoPath;
        } 
        
        void set_ISPTierLogoIcon(HICON hIcon)
        {
            hbmTierIcon = hIcon;
        }   

        HICON get_ISPTierLogoIcon(void)
        {
            return hbmTierIcon;
        }   
      
        LPWSTR   get_szISPTeaserPath(void)
        {
            return szISPTeaserPath;
        } 

        LPWSTR   get_szISPMarketingHTMPath(void)
        {
            return szISPMarketingHTMPath;
        }   

        DWORD get_dwCFGFlag() 
        {
            return dwCfgFlag;
        }

        void set_dwCFGFlag(DWORD dwNewCfgFlag) 
        {
            dwCfgFlag = dwNewCfgFlag;
        }

        DWORD get_dwRequiredUserInputFlags() 
        {
            return dwRequiredUserInputFlags;
        }

        void set_dwRequiredUserInputFlags(DWORD dwFlags) 
        {
            dwRequiredUserInputFlags = dwFlags;
        }

        void set_szBillingFormPath(WCHAR* pszFile)
        {
            lstrcpy(szBillingFormPath, pszFile);
        }   
        
        LPWSTR   get_szBillingFormPath(void)
        {
            return szBillingFormPath;
        }   

        void set_ISPLogoImageIndex(int iImage)  
        {
            iISPLogoIndex = iImage;
        }

        void set_szISPName(WCHAR* pszName)
        {
            lstrcpy(szISPName, pszName);
        }
        
        LPWSTR   get_szISPName()
        {
            return szISPName;
        }
        
        int get_ISPLogoIndex()
        {
            return iISPLogoIndex;
        }
        
        void set_bCNS(BOOL bVal)
        {
            bCNS = bVal;
        }
        
        BOOL get_bCNS()
        {
            return bCNS;
        }

        void set_bIsSpecial(BOOL bVal) 
        {
            bIsSpecial = bVal;
        }
       
        
        BOOL get_bIsSpecial() 
        {
            return bIsSpecial;
        }
        
        int get_iSpecial()
        {
            return iSpecialVal;
        }
        
        void set_szPayCSVPath(WCHAR* pszFile)
        {
            lstrcpy(szPayCSVPath, pszFile);
        }            
        

        LPWSTR get_szPayCSVPath()
        {
            return szPayCSVPath;
        }            
        
         
        void set_szISPFilePath(WCHAR* pszFile)
        {
            lstrcpy(szISPFilePath, pszFile);
        }

        LPWSTR get_szISPFilePath()
        {
            return szISPFilePath;
        }
        
        LPWSTR get_szOfferGUID()
        {
            return szOfferGUID;
        }
        
        WORD    get_wOfferID()
        {
            return wOfferID;
        }

        LPWSTR  get_szMir()
        {
            return szMir;
        }

        WORD    get_wLCID()
        {
            return wLCID;
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\ispdata.cpp ===
#include "windowsx.h"
#include "ispdata.h"
#include "validate.h"
#include "tchar.h"
#include "util.h"
#include "resource.h"

// NOTE: This order of this table is dependant on the order ot the ENUM in WEBVIEW.H for ISPDATA element.
// DO NOT CHANGE 1 without CHANGING the other!!!!!
ISPDATAELEMENT aryISPDataElements[] = 
{
    { csz_USER_FIRSTNAME,       NULL,   0,                  IDS_USERINFO_FIRSTNAME,     REQUIRE_FIRSTNAME          },
    { csz_USER_LASTNAME,        NULL,   0,                  IDS_USERINFO_LASTNAME,      REQUIRE_LASTNAME           },
    { csz_USER_ADDRESS,         NULL,   0,                  IDS_USERINFO_ADDRESS1,      REQUIRE_ADDRESS            },
    { csz_USER_MOREADDRESS,     NULL,   0,                  IDS_USERINFO_ADDRESS2,      REQUIRE_MOREADDRESS        },
    { csz_USER_CITY,            NULL,   0,                  IDS_USERINFO_CITY,          REQUIRE_CITY               },
    { csz_USER_STATE,           NULL,   0,                  IDS_USERINFO_STATE,         REQUIRE_STATE              },
    { csz_USER_ZIP,             NULL,   0,                  IDS_USERINFO_ZIP,           REQUIRE_ZIP                },
    { csz_USER_PHONE,           NULL,   0,                  IDS_USERINFO_PHONE,         REQUIRE_PHONE              },
    { csz_AREACODE,             NULL,   0,                  0,                          0                          },
    { csz_COUNTRYCODE,          NULL,   0,                  0,                          0                          },
    { csz_USER_FE_NAME,         NULL,   0,                  IDS_USERINFO_FE_NAME,       REQUIRE_FE_NAME            },
    { csz_PAYMENT_TYPE,         NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_BILLNAME,     NULL,   0,                  IDS_PAYMENT_PBNAME,         REQUIRE_PHONEIV_BILLNAME   },
    { csz_PAYMENT_BILLADDRESS,  NULL,   0,                  IDS_PAYMENT_CCADDRESS,      REQUIRE_CCADDRESS          },
    { csz_PAYMENT_BILLEXADDRESS, NULL,   0,                  IDS_USERINFO_ADDRESS2,      REQUIRE_IVADDRESS2         },
    { csz_PAYMENT_BILLCITY,     NULL,   0,                  IDS_USERINFO_CITY,          REQUIRE_IVCITY             },
    { csz_PAYMENT_BILLSTATE,    NULL,   0,                  IDS_USERINFO_STATE,         REQUIRE_IVSTATE            },
    { csz_PAYMENT_BILLZIP,      NULL,   0,                  IDS_USERINFO_ZIP,           REQUIRE_IVZIP              },
    { csz_PAYMENT_BILLPHONE,    NULL,   0,                  IDS_PAYMENT_PBNUMBER,       REQUIRE_PHONEIV_ACCNUM     },
    { csz_PAYMENT_DISPLAYNAME,  NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_CARDNUMBER,   NULL,   ValidateCCNumber,   IDS_PAYMENT_CCNUMBER,       REQUIRE_CCNUMBER           },
    { csz_PAYMENT_EXMONTH,      NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_EXYEAR,       NULL,   ValidateCCExpire,   0,                          0                          },
    { csz_PAYMENT_CARDHOLDER,   NULL,   0,                  IDS_PAYMENT_CCNAME,         REQUIRE_CCNAME             },
    { csz_SIGNED_PID,           NULL,   0,                  0,                          0                          },
    { csz_GUID,                 NULL,   0,                  0,                          0                          },
    { csz_OFFERID,              NULL,   0,                  0,                          0                          },
    { NULL,                     NULL,   0,                  0,                          0                          },
    { NULL,                     NULL,   0,                  0,                          0                          },
    { csz_USER_COMPANYNAME,     NULL,   0,                  IDS_USERINFO_COMPANYNAME,   REQUIRE_COMPANYNAME        },
    { csz_ICW_VERSION,          NULL,   0,                  0,                          0                          }
}; 


    
#define ISPDATAELEMENTS_LEN sizeof(aryISPDataElements) / sizeof(ISPDATAELEMENT)

extern const WCHAR cszEquals[];
extern const WCHAR cszAmpersand[];
extern const WCHAR cszPlus[];
extern const WCHAR cszQuestion[];

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData:CICWISPData
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWISPData::CICWISPData() 
{
    m_lRefCount = 0;
    
    // Initialize the data elements array
    m_ISPDataElements = aryISPDataElements;
    
}

CICWISPData::~CICWISPData()
{
    // Walk through and free any allocated values in m_ISPDataElements
    for (int i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        if (m_ISPDataElements[i].lpQueryElementValue)
        {
            free(m_ISPDataElements[i].lpQueryElementValue);
            m_ISPDataElements[i].lpQueryElementValue = NULL;
        }
    }
}

// BUGBUG need a destructor to walk the array and free the lpQueryElementValue members

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//
//-----------------------------------------------------------------------------
HRESULT CICWISPData::QueryInterface( REFIID riid, void** ppv )
{

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWISPData::AddRef( void )
{
    return 1 ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWISPData::Release( void )
{
    return( m_lRefCount );
}


BOOL CICWISPData::PutDataElement
(
    WORD wElement, 
    LPCWSTR lpValue, 
    WORD wValidateLevel
)
{
    //ASSERT(wElement < ISPDATAELEMENTS_LEN);
    
    BOOL                bValid = TRUE;
    LPISPDATAELEMENT    lpElement = &m_ISPDataElements[wElement];
    
    //ASSERT(lpElement);
        
    if (wValidateLevel > ISPDATA_Validate_None)
    {
        // See if we even need to validate.  A validateflag of 0 means we always validate
        if ((0 == lpElement->dwValidateFlag) || m_dwValidationFlags & lpElement->dwValidateFlag)
        {
            // process based on validation level
            switch (wValidateLevel)
            {
                case ISPDATA_Validate_DataPresent:
                {
                    bValid = IsValid(lpValue, m_hWndParent, lpElement->wValidateNameID);
                    break;
                }
                
                case ISPDATA_Validate_Content:
                {
                    bValid = bValidateContent(lpElement->idContentValidator, lpValue);
                    break;
                }
            }
        }            
    }   
     
    // If the element is valid, then store it.
    if (bValid)
    {
        // If this elemement has been previously set the free it
        if (lpElement->lpQueryElementValue)
        {
            free(lpElement->lpQueryElementValue);
            lpElement->lpQueryElementValue = NULL;
        }
        
        // lpValue can be NULL
        if (lpValue)    
            lpElement->lpQueryElementValue = _wcsdup(lpValue);
        else
            lpElement->lpQueryElementValue = NULL;
                    
    }        
    return (bValid);
}

// This funtion will form the query string to be sent to the ISP signup server
// 
HRESULT CICWISPData::GetQueryString
(
    BSTR    bstrBaseURL,
    BSTR    *lpReturnURL    
)
{
    LPWSTR              lpWorkingURL;
    WORD                cchBuffer = 0;
    LPISPDATAELEMENT    lpElement;
    LPWSTR              lpszBaseURL = bstrBaseURL;
    int                 i;
       
    //ASSERT(lpReturnURL);
    if (!lpReturnURL)
        return E_FAIL;
                
    // Calculate how big of a buffer we will need
    cchBuffer += (WORD)lstrlen(lpszBaseURL);
    cchBuffer += 1;                      // For the & or the ?
    for (i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_ISPDataElements[i];
        //ASSERT(lpElement);
        if (lpElement->lpQueryElementName)
        {
            cchBuffer += (WORD)lstrlen(lpElement->lpQueryElementName);
            cchBuffer += (WORD)lstrlen(lpElement->lpQueryElementValue) * 3;       // *3 for encoding
            cchBuffer += 3;              // For the = and & and the terminator (because we copy
                                        // lpQueryElementValue into a new buffer for encoding
        }
        else
        {
            cchBuffer += (WORD)lstrlen(lpElement->lpQueryElementValue);
            cchBuffer += 1;              // for the trailing &
        }        
    }
    cchBuffer += 1;                     // Terminator
    
    // Allocate a buffer large enough
    if (NULL == (lpWorkingURL = (LPWSTR)GlobalAllocPtr(GPTR, BYTES_REQUIRED_BY_CCH(cchBuffer))))
        return E_FAIL;
        
    lstrcpy(lpWorkingURL, lpszBaseURL);
    
    // See if this ISP provided URL is already a Query String.
    if (NULL != wcschr(lpWorkingURL, L'?'))
        lstrcat(lpWorkingURL, cszAmpersand);      // Append our params
    else
        lstrcat(lpWorkingURL, cszQuestion);       // Start with our params

    for (i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_ISPDataElements[i];
        //ASSERT(lpElement);
            
        if (lpElement->lpQueryElementName)
        {
            // If there is a query value, then encode it
            if (lpElement->lpQueryElementValue)
            {
                // Allocate a buffer to encode into
                size_t size = 3 * BYTES_REQUIRED_BY_SZ(lpElement->lpQueryElementValue);
                LPWSTR lpszVal = (LPWSTR) malloc(size+BYTES_REQUIRED_BY_CCH(1));
                
                lstrcpy(lpszVal, lpElement->lpQueryElementValue);
                URLEncode(lpszVal, size);
            
                URLAppendQueryPair(lpWorkingURL, 
                                   (LPWSTR)lpElement->lpQueryElementName,
                                   lpszVal);
                free(lpszVal);
            }   
            else
            {
                URLAppendQueryPair(lpWorkingURL, 
                                   (LPWSTR)lpElement->lpQueryElementName,
                                   NULL);
            }             
        }                                   
        else
        {
            if (lpElement->lpQueryElementValue)
            {
                lstrcat(lpWorkingURL, lpElement->lpQueryElementValue);
                lstrcat(lpWorkingURL, cszAmpersand);                                        
            }                
        }    
    }    
    
    // Terminate the working URL properly, by removing the trailing ampersand
    lpWorkingURL[lstrlen(lpWorkingURL)-1] = L'\0';
    
    
    // Set the return VALUE.  We must allocate here, since the caller will free
    // this returned string, and A2W only puts the string in the stack
    *lpReturnURL = SysAllocString(lpWorkingURL);
    
    // Free the buffer
    GlobalFreePtr(lpWorkingURL);
    
    return (S_OK);
}


// Dispatch functioin to handle content specific validation
BOOL    CICWISPData::bValidateContent
(
    WORD        wFunctionID,
    LPCWSTR     lpData
)
{
    BOOL    bValid = TRUE;
    
    switch (wFunctionID)
    {
        case ValidateCCNumber:
            break;

        case ValidateCCExpire:
            break;
    }
    
    return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\ispcsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
#include "appdefs.h"
#include "obcomglb.h"
#include "wininet.h"
#include "perhist.h"
#include "shlobj.h"
#include "ispcsv.h"
#include "util.h"

const VARIANT c_vaEmpty = {0};
const LARGE_INTEGER c_li0 = { 0, 0 };


WCHAR szTempBuffer[TEMP_BUFFER_LENGTH];

#define MAX_MESSAGE_LEN     256 * 4

#define ReadVerifyDW(x)     if (!ReadDW(&(x), pcCSVFile))                        \
                            {                                                   \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyW(x)      if (!ReadW(&(x), pcCSVFile))                         \
                            {                                                   \
                                goto ReadOneLineError;                          \
                            }
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
#define ReadVerifyWEx(x)    if (!ReadWEx(&(x), pcCSVFile))                       \
                            {                                                   \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyB(x)      if (!ReadB(&(x), pcCSVFile))                         \
                            {                                                   \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyBOOL(x)   if (!ReadBOOL(&(x), pcCSVFile))                      \
                            {                                                   \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifySPECIAL(x, y, z) if (!ReadSPECIAL(&(x), &(y), &(z), pcCSVFile))   \
                            {                                                   \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifySZ(x, y)   if (!ReadSZ(&x[0],y+sizeof(L'\0'),pcCSVFile))        \
                            {                                                   \
                                goto ReadOneLineError;                          \
                            }


CISPCSV::~CISPCSV(void)
{
    if (hbmTierIcon)
        DeleteObject(hbmTierIcon);
    
}

// Do an strip of Single Quotes from a source string.  The source is formatted as:
// 'some text', and the dest string ends up being
// some text
void CISPCSV::StripQuotes
(
    LPWSTR   lpszDst,
    LPWSTR   lpszSrc
)
{
    lstrcpyn(lpszDst, lpszSrc + 1, lstrlen(lpszSrc) - 1);
}


BOOL CISPCSV::ValidateFile(WCHAR* pszFile)
{
    WCHAR szDownloadDir[MAX_PATH];
  
    if (!lstrlen(pszFile))
        return FALSE;

    if (!GetOOBEPath((LPWSTR)szDownloadDir))
        return FALSE;

    lstrcat(szDownloadDir, L"\\");
    lstrcat(szDownloadDir, pszFile);

    if (GetFileAttributes(szDownloadDir) == 0xFFFFFFFF)
        return FALSE;

    return TRUE;
}

// ############################################################################
BOOL CISPCSV::ReadDW(DWORD far *pdw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer, TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2Dw(szTempBuffer, pdw));
}

// ############################################################################
BOOL CISPCSV::ReadW(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer, TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer, pw));
}

// ############################################################################
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL CISPCSV::ReadWEx(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer, TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2WEx(szTempBuffer, pw));
}

// ############################################################################
BOOL CISPCSV::ReadB(BYTE far *pb, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer, TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2B(szTempBuffer, pb));
}

// ############################################################################
BOOL CISPCSV::ReadBOOL(BOOL far *pbool, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer, TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2BOOL(szTempBuffer, pbool));
}

// ############################################################################
// A special int can be either a BOOL (TRUE, FALSE) or a int, 0 or -1
// if the value is 0 or -1, then the pbIsSpecial bool is set to TRUE
BOOL CISPCSV::ReadSPECIAL(BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer, TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2SPECIAL(szTempBuffer, pbool, pbIsSpecial, pInt));
}

// ############################################################################
BOOL CISPCSV::ReadSZ(LPWSTR psz, DWORD cch, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz, cch))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CISPCSV::ReadToEOL(CCSVFile far *pcCSVFile)
{
    return pcCSVFile->SkipTillEOL();
}

HRESULT CISPCSV::ReadOneLine
(
    CCSVFile    far *pcCSVFile
)
{
    HRESULT     hr = ERROR_SUCCESS;
    WCHAR       szTemp[MAX_ISP_NAME];

    if (!ReadSZ(szTemp, MAX_CHARS_IN_BUFFER(szTemp), pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        goto ReadOneLineExit;
    }
    // Strip the single quotes from the isp Name
    StripQuotes(szISPName, szTemp);
    
    ReadVerifyW(wOfferID);   
    ReadVerifySZ(szISPLogoPath, MAX_CHARS_IN_BUFFER(szISPLogoPath));
    ReadVerifySZ(szISPMarketingHTMPath, MAX_CHARS_IN_BUFFER(szISPMarketingHTMPath));
    ReadVerifySZ(szISPTierLogoPath, MAX_CHARS_IN_BUFFER(szISPTierLogoPath));
    ReadVerifySZ(szISPTeaserPath, MAX_CHARS_IN_BUFFER(szISPTeaserPath));
    ReadVerifySZ(szISPFilePath, MAX_CHARS_IN_BUFFER(szISPFilePath)); 
    ReadVerifyDW(dwCfgFlag);
    ReadVerifyDW(dwRequiredUserInputFlags);
    ReadVerifySZ(szBillingFormPath, MAX_CHARS_IN_BUFFER(szBillingFormPath));
    ReadVerifySZ(szPayCSVPath, MAX_CHARS_IN_BUFFER(szPayCSVPath));
    ReadVerifySZ(szOfferGUID, MAX_CHARS_IN_BUFFER(szOfferGUID));
    ReadVerifySZ(szMir, MAX_CHARS_IN_BUFFER(szMir));   
    ReadVerifyWEx(wLCID);   //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
    ReadToEOL(pcCSVFile);


    bCNS = (ICW_CFGFLAG_CNS & dwCfgFlag) ? TRUE : FALSE;
    bSecureConnection = (ICW_CFGFLAG_SECURE & dwCfgFlag) ? TRUE : FALSE;

    //If this is nooffer we won't try to validate
    if (!(dwCfgFlag & ICW_CFGFLAG_OFFERS))
    {
        if (!ValidateFile(szISPMarketingHTMPath))
            hr = ERROR_FILE_NOT_FOUND;
        return hr;
    }

    if (!(dwCfgFlag & ICW_CFGFLAG_AUTOCONFIG))
    {
        if (!ValidateFile(szISPMarketingHTMPath))
            return ERROR_FILE_NOT_FOUND;
    }

    if (dwCfgFlag & ICW_CFGFLAG_OEM_SPECIAL)
    {
        if (!ValidateFile(szISPTierLogoPath) || !ValidateFile(szISPTeaserPath))
            dwCfgFlag &= ~ICW_CFGFLAG_OEM_SPECIAL ;
    }

    //Try and validate the integrity of various offers
    //based on type.

    //OLS, CNS, NO-CNS   
    if (!ValidateFile(szISPLogoPath))
        return ERROR_FILE_NOT_FOUND;
    if (!ValidateFile(szISPFilePath))
        return ERROR_FILE_NOT_FOUND;

    // Validate the billing path only when billing option is set
    if (dwCfgFlag & ICW_CFGFLAG_BILL)
    {
        if(!ValidateFile(szBillingFormPath))
            return ERROR_FILE_NOT_FOUND;
    }

    // Validate the payment path only when payment option is set
    if (dwCfgFlag & ICW_CFGFLAG_PAYMENT)
    {
        if(!ValidateFile(szPayCSVPath))
            return ERROR_FILE_NOT_FOUND;
    }        
ReadOneLineExit:
    return hr;
    
ReadOneLineError:
    hr = ERROR_INVALID_DATA;
    goto ReadOneLineExit;
}

HRESULT CISPCSV::ReadFirstLine
(
    CCSVFile    far *pcCSVFile
)
{
    WCHAR   szTemp[TEMP_BUFFER_LENGTH];

    for (int i = 0; i < NUM_ISPCSV_FIELDS; i++)
    {
        if (!ReadSZ(szTemp, MAX_CHARS_IN_BUFFER(szTemp), pcCSVFile))
        {
            return(ERROR_INVALID_DATA);
        }            
    }          
    ReadToEOL(pcCSVFile);
    return (ERROR_SUCCESS);
}

void CISPCSV::MakeCompleteURL(LPWSTR   lpszURL, LPWSTR  lpszSRC)    
{
    WCHAR   szCurrentDir[MAX_PATH];

    // Form the URL
    if(GetOOBEPath((LPWSTR)szCurrentDir))
    {
        wsprintf (lpszURL, L"FILE://%s\\%s", szCurrentDir, lpszSRC);        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\inshdlr.h ===
/*-----------------------------------------------------------------------------
	INSHandler.h

	Declaration of CINSHandler - INS file processing

	Copyright (C) 1999 Microsoft Corporation
	All rights reserved.

	Authors:
		vyung		

	History:
        2/7/99      Vyung created - code borrowed from ICW, icwhelp.dll

-----------------------------------------------------------------------------*/

#ifndef __INSHANDLER_H_
#define __INSHANDLER_H_
#include "obcomglb.h"
#include "inets.h"
#include <ras.h>

// Default branding flags the we will support
#define BRAND_FAVORITES 1
#define BRAND_STARTSEARCH 2
#define BRAND_TITLE 4
#define BRAND_BITMAPS 8
#define BRAND_MAIL 16
#define BRAND_NEWS 32

#define BRAND_DEFAULT (BRAND_FAVORITES | BRAND_STARTSEARCH)
typedef enum
{
    CONNECT_LAN = 0,
    CONNECT_MANUAL,
    CONNECT_RAS
};

typedef struct tagCONNECTINFO
{
    DWORD   cbSize;
    DWORD   type;
    WCHAR    szConnectoid[MAX_PATH];
} CONNECTINFO;

// This struct is used to configure the client
typedef struct
{
    LPCWSTR  lpszSection;
    LPCWSTR  lpszValue;
    UINT    uOffset;
    UINT    uSize;
} CLIENT_TABLE, FAR *LPCLIENT_TABLE;

typedef struct
{
    WCHAR          szEntryName[RAS_MaxEntryName+1];
    WCHAR          szUserName[UNLEN+1];
    WCHAR          szPassword[PWLEN+1];
    WCHAR          szScriptFile[MAX_PATH+1];
    RASENTRY      RasEntry;
} ICONNECTION, FAR * LPICONNECTION;


#define LANDT_1483			L"ethernet_1483"
#define LANDT_Cable			L"cable"
#define LANDT_Ethernet		L"ethernet"
#define LANDT_Pppoe         L"pppoe"

#define LAN_MaxDeviceType  	(max(max(max(sizeof(LANDT_1483), sizeof(LANDT_Cable)), sizeof(LANDT_Normal))), LANDT_Pppoe)
#define CONN_MaxDeviceType	(max(LAN_MaxDeviceType, RAS_MaxDeviceType))
// definitions for the m_dwDeviceType member
static const DWORD InetS_RASModem 		= 0x1;
static const DWORD InetS_RASIsdn		= 0x2;
static const DWORD InetS_RASVpn 		= 0x4;
static const DWORD InetS_RASAtm			= 0x8;
static const DWORD InetS_RAS			= InetS_RASModem | InetS_RASIsdn | InetS_RASVpn | InetS_RASAtm;

static const DWORD InetS_LANEthernet	= 0x8000;
static const DWORD InetS_LANCable		= 0x10000;
static const DWORD InetS_LAN1483        = 0x20000;
static const DWORD InetS_LANPppoe       = 0x40000;
static const DWORD InetS_LAN = InetS_LANEthernet | InetS_LANCable | InetS_LAN1483 | InetS_LANPppoe;


typedef DWORD (WINAPI *PFNINETCONFIGCLIENT)(HWND hwndParent, LPCSTR lpszPhoneBook, LPCSTR lpszEntryName, LPRASENTRY lpRasEntry, LPCSTR lpszUserName, LPCSTR lpszPassword, LPCSTR lpszProfile, LPINETCLIENTINFO lpClientInfo, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef DWORD (WINAPI *PFNINETCONFIGCLIENTEX)(HWND hwndParent, LPCSTR lpszPhoneBook, LPCSTR lpszEntryName, LPRASENTRY lpRasEntry, LPCSTR lpszUserName, LPCSTR lpszPassword, LPCSTR lpszProfile, LPINETCLIENTINFO lpClientInfo, DWORD dwfOptions, LPBOOL lpfNeedsRestart, LPSTR szConnectoidName, DWORD dwSizeOfCreatedEntryName);

typedef BOOL (WINAPI *PFNBRANDICW)(LPCSTR pszIns, LPCSTR pszPath, DWORD dwFlags);
typedef BOOL (WINAPI *PFNBRANDICW2)(LPCSTR pszIns, LPCSTR pszPath, DWORD dwFlags, LPCSTR pszConnectoid);
typedef DWORD (WINAPI *PFNRASSETAUTODIALADDRESS)(LPWSTR lpszAddress, DWORD dwReserved, RASAUTODIALENTRY* lpAutoDialEntries, DWORD dwcbAutoDialEntries, DWORD dwcAutoDialEntries);
typedef DWORD (WINAPI *PFNRASSETAUTODIALENABLE)(DWORD dwDialingLocation, BOOL fEnabled);

/////////////////////////////////////////////////////////////////////////////
// CINSHandler
class CINSHandler 
{
public:
    CINSHandler()
    {
        m_szRunExecutable      [0]  = L'\0';
        m_szRunArgument        [0]  = L'\0';
        m_szCheckAssociations  [0]  = L'\0';
        m_szAutodialConnection [0]  = L'\0';
        m_szStartURL           [0]  = L'\0';
        m_fResforeDefCheck          = FALSE;
        m_fAutodialSaved            = TRUE;
        m_fAutodialEnabled          = FALSE;
        m_fProxyEnabled             = FALSE;
        m_bSilentMode               = TRUE;

        m_lpfnBrandICW              = NULL;
        m_lpfnBrandICW2             = NULL;
        m_lpfnRasSetAutodialEnable  = NULL;
        m_lpfnRasSetAutodialAddress = NULL;
        m_hInetCfg                  = NULL;
        m_hBranding                 = NULL;
        m_hRAS                      = NULL;
        m_dwBrandFlags              = BRAND_DEFAULT; 

        m_dwDeviceType				= 0;
    }
    ~CINSHandler()
    {
        if (m_hRAS)
            FreeLibrary(m_hRAS);
    }

// IINSHandler
public:
    STDMETHOD (put_BrandingFlags) (/*[in]*/ long lFlags);
    STDMETHOD (put_SilentMode)    (/*[in]*/ BOOL bSilent);
    STDMETHOD (get_NeedRestart)   (/*[out, retval]*/ BOOL *pVal);
    STDMETHOD (get_DefaultURL)    (/*[out, retval]*/ BSTR *pszURL);

    BOOL        ProcessOEMBrandINS(BSTR bstrFileName, LPWSTR lpszConnectoidName);
    HRESULT     MergeINSFiles(LPCWSTR lpszMainFile, LPCWSTR lpszOtherFile, LPWSTR lpszOutputFile, DWORD dwFNameSize);
    HRESULT     RestoreConnectoidInfo();
    
private:
    HRESULT     ProcessINS(LPCWSTR lpszFile, LPWSTR lpszConnectoidName,BOOL *pbRetVal);
    BSTR        m_bstrINSFileName; //CComBSTR    m_bstrINSFileName;
    HRESULT     MassageFile(LPCWSTR lpszFile);
    DWORD       RunExecutable(void);
    BOOL        KeepConnection(LPCWSTR lpszFile);
    DWORD       ImportCustomInfo(LPCWSTR lpszImportFile, LPWSTR lpszExecutable, DWORD cbExecutable, LPWSTR lpszArgument, DWORD cbArgument);
    DWORD       ImportFile(LPCWSTR lpszImportFile, LPCWSTR lpszSection, LPCWSTR lpszOutputFile);
    DWORD       ImportCustomFile(LPCWSTR lpszImportFile);
    DWORD       ImportBrandingInfo(LPCWSTR lpszFile, LPCWSTR lpszConnectoidName);
    // Client Config functions
    DWORD       ImportCustomDialer(LPRASENTRY lpRasEntry, LPCWSTR szFileName);
    LPCWSTR     StrToSubip (LPCWSTR szIPAddress, LPBYTE pVal);
    DWORD       StrToip (LPCWSTR szIPAddress, RASIPADDR *ipAddr);
    DWORD       ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName);
    DWORD       ImportServerInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName);
    DWORD       ImportIPInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName);
    DWORD       ImportScriptFile(LPCWSTR lpszImportFile, LPWSTR szScriptFile, UINT cbScriptFile);
    DWORD       RnaValidateImportEntry (LPCWSTR szFileName);
    DWORD       ImportRasEntry (LPCWSTR szFileName, LPRASENTRY lpRasEntry, LPBYTE & lpDeviceInfo, LPDWORD lpdwDeviceInfoSize);
    DWORD       ImportAtmInfo(LPRASENTRY lpRasEntry, LPCWSTR cszFileName, LPBYTE & lpDeviceInfo, LPDWORD lpdwDeviceInfoSize);
    DWORD       ImportConnection (LPCWSTR szFileName, LPICONNECTION lpConn, LPBYTE & lpDeviceInfo, LPDWORD lpdwDeviceInfoSiz);


    DWORD InetSGetConnectionType ( LPCWSTR cszINSFile );

	DWORD InetSImportRasConnection ( RASINFO& RasEntry, LPCWSTR cszINSFile );
    DWORD InetSImportLanConnection ( LANINFO& LanInfo,  LPCWSTR cszINSFile );
    DWORD InetSImportRfc1483Connection ( RFC1483INFO &Rfc1483Info, LPCWSTR cszINSFile );
    DWORD InetSImportPppoeConnection ( PPPOEINFO &PppoeInfo, LPCWSTR cszINSFile);

    DWORD InetSImportAtmModule ( ATMPBCONFIG &AtmInfoMod, LPCWSTR cszINSFile );
    DWORD InetSImportTcpIpModule ( TCPIP_INFO_EXT &TcpIpInfoMod, LPCWSTR cszINSFile );
    DWORD InetSImportRfc1483Module ( RFC1483_INFO_EXT &Rfc1483InfoMod, LPCWSTR cszINSFile );
    DWORD InetSImportPppoeModule (PPPOE_INFO_EXT &PppoeInfoMod, LPCWSTR cszINSFile );
 

    DWORD       ImportMailAndNewsInfo(LPCWSTR lpszFile, BOOL fConnectPhone);
    HRESULT     WriteMailAndNewsKey(HKEY hKey, LPCWSTR lpszSection, LPCWSTR lpszValue, LPWSTR lpszBuff, DWORD dwBuffLen, LPCWSTR lpszSubKey, DWORD dwType, LPCWSTR lpszFile);
    BOOL        LoadExternalFunctions(void);
    DWORD       ReadClientInfo(LPCWSTR lpszFile, LPINETCLIENTINFO lpClientInfo, LPCLIENT_TABLE lpClientTable);
    BOOL        WantsExchangeInstalled(LPCWSTR lpszFile);
    BOOL        DisplayPassword(LPCWSTR lpszFile);
    DWORD       ImportClientInfo(LPCWSTR lpszFile, LPINETCLIENTINFO lpClientInfo);
    DWORD       ConfigureClient(HWND hwnd, LPCWSTR lpszFile, LPBOOL lpfNeedsRestart, LPBOOL lpfConnectoidCreated, BOOL fHookAutodial, LPWSTR szConnectoidName, DWORD dwConnectoidNameSize);
    HRESULT     PopulateNTAutodialAddress(LPCWSTR pszFileName, LPCWSTR pszEntryName);
    LPWSTR      MoveToNextAddress(LPWSTR lpsz);
    HRESULT     PreparePassword(LPWSTR szBuff, DWORD dwBuffLen);
    BOOL        FIsAthenaPresent();
    BOOL        FTurnOffBrowserDefaultChecking();
    BOOL        FRestoreBrowserDefaultChecking();
    void        SaveAutoDial(void);
    void        RestoreAutoDial(void);


    BOOL        OpenIcwRmindKey(HKEY *phkey);
    BOOL        ConfigureTrialReminder(LPCWSTR  lpszFile);

    BOOL        SetICWCompleted( DWORD dwCompleted );
    DWORD       CallSBSConfig(HWND hwnd, LPCWSTR lpszINSFile);
    BOOL        CallCMConfig(LPCWSTR lpszINSFile);
    
    
    DWORD       dw_ProcessFlags;        // Flags used to control INS processing
    WCHAR       m_szRunExecutable[MAX_PATH + 1];
    WCHAR       m_szRunArgument[MAX_PATH + 1];
    WCHAR       m_szCheckAssociations[20];
    WCHAR       m_szAutodialConnection[RAS_MaxEntryName + 1];
    WCHAR       m_szStartURL[MAX_PATH + 1];

    BOOL        m_fConnectionKilled;
    BOOL        m_fNeedsRestart;
    BOOL        m_fResforeDefCheck;
    BOOL        m_fAutodialSaved;
    BOOL        m_fAutodialEnabled;
    BOOL        m_fProxyEnabled;
    BOOL        m_bSilentMode;
 

    PFNBRANDICW                 m_lpfnBrandICW;
    PFNBRANDICW2                m_lpfnBrandICW2;
    PFNRASSETAUTODIALENABLE     m_lpfnRasSetAutodialEnable;
    PFNRASSETAUTODIALADDRESS    m_lpfnRasSetAutodialAddress;


    HINSTANCE           m_hInetCfg;
    HINSTANCE           m_hBranding;
    HINSTANCE           m_hRAS;
    DWORD               m_dwBrandFlags;

    DWORD				m_dwDeviceType;
};

#endif //__INSHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\ispdata.h ===
#ifndef   _ISPDATA_H
#define  _ISPDATA_H

#include "obcomglb.h"
#include "appdefs.h"



class CICWISPData
{
    public:

        // IICWISPData
        virtual BOOL    STDMETHODCALLTYPE   PutDataElement(WORD wElement, LPCWSTR lpValue, WORD wValidateLevel);
        virtual HRESULT STDMETHODCALLTYPE   GetQueryString(BSTR bstrBaseURL, BSTR *lpReturnURL);
        virtual LPCWSTR STDMETHODCALLTYPE   GetDataElement(WORD wElement)
        {
            //ASSERT(wElement < ISPDATAELEMENTS_LEN);
            return (m_ISPDataElements[wElement].lpQueryElementValue);
        };
        
        virtual void STDMETHODCALLTYPE      PutValidationFlags(DWORD dwFlags)
        {
            m_dwValidationFlags = dwFlags;
        };
        
        virtual void STDMETHODCALLTYPE      Init(HWND   hWndParent)
        {
            m_hWndParent = hWndParent;
        };
        
        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWISPData();
        ~CICWISPData();

private:
        BOOL    bValidateContent(WORD   wFunctionID, LPCWSTR  lpData);
        
        LPISPDATAELEMENT    m_ISPDataElements;

        HWND                m_hWndParent;       // parent for messages
        DWORD               m_dwValidationFlags;
        // For class object management
        LONG                m_lRefCount;
};
#endif //_ISPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\mapicall.h ===
//*********************************************************************
//*                                    Microsoft Windows                                                             **
//*                        Copyright(c) Microsoft Corp., 1994-1999                             **
//*********************************************************************

//
//    MAPICALL.H - Header file for MAPI callout module
//            
//

//    HISTORY:
//    
//    1/27/95        jeremys    Created.
//    96/03/26    markdu    Put #ifdef __cplusplus around extern "C"
//

#ifndef _MAPICALL_H_
#define _MAPICALL_H_

#undef  MAPI_DIM
#define MAPI_DIM    10

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <mapidefs.h>
#include <mapicode.h>
#include <mspst.h>
#include <mspab.h>
#define MAPI_NOWIDECHAR // MAPI guys...don't map lstr*W to MNLS_lstr*W
#include <mapiwin.h>
#include <mapitags.h>
#include <mapiutil.h>
#include <mapispi.h>
#include "inetprop.h"

#ifdef DEBUG
    #undef Assert    // more MAPI guys!
    #include <mapidbg.h>
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

// prototype for function pointer for MAPI util function
typedef HRESULT (CALLBACK * LPHRQUERYALLROWS) (LPMAPITABLE, LPSPropTagArray,
    LPSRestriction, LPSSortOrderSet,LONG,LPSRowSet FAR *);
extern HINSTANCE hInstMAPIDll;        // handle to MAPI dll we load explicitly

// structure used in determining if a service is present in a MAPI profile,
// and to install the service
typedef struct tagMSGSERVICE {
    BOOL fPresent;                // TRUE if service is present
    UINT uIDServiceName;        // ID of str resource with service name (non-UI)
    UINT uIDServiceDescription;    // ID of str resource with service desc (for UI)

    BOOL fNeedConfig;            // TRUE if create-time config proc should be called
    UINT uIDStoreFilename;        // name to try for message store for
    UINT uIDStoreFilename1;        // name to use to generate other message store names
    UINT uPropID;                // prop val ID for message store property for this service
} MSGSERVICE;

#define NUM_SERVICES        3    // number of services in table of MSGSERVICEs

// class to aid in releasing interfaces.    When you obtain an OLE interface,
// you can contruct a RELEASE_ME_LATER object with the pointer to the interface.
// When the object is destructed, it will release the interface.
class RELEASE_ME_LATER
{
private:
    LPUNKNOWN _lpInterface;
public:
    RELEASE_ME_LATER(LPUNKNOWN lpInterface) { _lpInterface = lpInterface; }
    ~RELEASE_ME_LATER() { if (_lpInterface) _lpInterface->Release(); }
};

// defines needed by route 66 config DLL.    Note: don't change these!
#define CONNECT_TYPE_LAN                    1
#define CONNECT_TYPE_REMOTE                 2    
#define DOWNLOAD_OPTION_HEADERS             1
#define DOWNLOAD_OPTION_MAIL_DELETE         3

class ENUM_MAPI_PROFILE
{
private:
    LPSRowSet       _pProfileRowSet;
    UINT            _iRow;
    UINT            _nEntries;
public:
    ENUM_MAPI_PROFILE();
    ~ENUM_MAPI_PROFILE();
    BOOL Next(LPWSTR * ppProfileName, BOOL * pfDefault);
    UINT GetEntryCount()    { return _nEntries; }
    
};

class ENUM_MAPI_SERVICE
{
private:
    LPSRowSet       _pServiceRowSet;
    UINT            _iRow;
    UINT            _nEntries;
public:
    ENUM_MAPI_SERVICE(LPWSTR pszProfileName);
    ~ENUM_MAPI_SERVICE();
    BOOL Next(LPWSTR * ppServiceName);
    UINT GetEntryCount()    { return _nEntries; }
    
};

#endif // _MAPICALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\mapicall.cpp ===
//*********************************************************************
//*                                    Microsoft Windows                                                             **
//*                        Copyright(c) Microsoft Corp., 1994-1995                             **
//*********************************************************************

//
//    MAPICALL.C - Functions to call MAPI for internet mail profile configuration
//            
//

//    HISTORY:
//    
//    1/25/95        jeremys        Created.
//    96/03/09    markdu        Added a wait cursor during loading of MAPI
//

#include "mapicall.h"
#include "obcomglb.h"
#include "resource.h"

/**********************************************************************

    Terminology:

    profile - a collection of settings for Exchange that determine
        the services that are used and the address book and message store
    service - a MAPI plug-in that talks to a mail back end
        (or address book or message store)

    There can be a number of profiles installed on a particular machine.
    Each profile contains a set of services.

    Stategy:

    To configure Microsoft Exchange, we need to do the following:

    1) Establish a profile to modify
        - If any profiles currently exist, find the default profile.
        Otherwise create a profile, which will be initially empty.

    2) Populate the profile with the required services.
        - The profile needs to contain the Internet Mail service, an
        address book and a message store.    If any of these items are
        not present, we add them to the profile.

    3) Configure the internet mail service for this profile.
        - stick in the user's email address, email server, etc.

**********************************************************************/

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
#define SMALL_BUF_LEN             48    // convenient size for small text buffers

HINSTANCE hInstMAPIDll=NULL;    // handle to MAPI dll we load explicitly
DWORD dwMAPIRefCount = 0;
static const WCHAR cszNull[] = L"";
static const WCHAR sz0[]    =             L"0";
static const WCHAR sz1[]    =                L"1";
static const WCHAR szNull[] =             L"";
static const WCHAR szSlash[] =             L"\\";
LPMAPIINITIALIZE        lpMAPIInitialize         = NULL;
LPMAPIADMINPROFILES     lpMAPIAdminProfiles     = NULL;
LPMAPIUNINITIALIZE      lpMAPIUninitialize         = NULL;
LPMAPIALLOCATEBUFFER    lpMAPIAllocateBuffer    = NULL;
LPMAPIFREEBUFFER        lpMAPIFreeBuffer         = NULL;
LPHRQUERYALLROWS        lpHrQueryAllRows        = NULL;
// global function pointers for MAPI apis

//////////////////////////////////////////////////////
// MAPI api function names
//////////////////////////////////////////////////////
static const CHAR szMAPIInitialize[] =             "MAPIInitialize";
static const CHAR szMAPIUninitialize[] =         "MAPIUninitialize";
static const CHAR szMAPIAdminProfiles[] =         "MAPIAdminProfiles";
static const CHAR szMAPIAllocateBuffer[] =         "MAPIAllocateBuffer";
static const CHAR szMAPIFreeBuffer[] =             "MAPIFreeBuffer";
static const CHAR szHrQueryAllRows[] =             "HrQueryAllRows@24";


#define NUM_MAPI_PROCS     6
// API table for function addresses to fetch
APIFCN MAPIApiList[NUM_MAPI_PROCS] = {
    { (PVOID *) &lpMAPIInitialize, szMAPIInitialize},
    { (PVOID *) &lpMAPIUninitialize, szMAPIUninitialize},
    { (PVOID *) &lpMAPIAdminProfiles, szMAPIAdminProfiles},
    { (PVOID *) &lpMAPIAllocateBuffer, szMAPIAllocateBuffer},
    { (PVOID *) &lpMAPIFreeBuffer, szMAPIFreeBuffer},
    { (PVOID *) &lpHrQueryAllRows, szHrQueryAllRows}};

#pragma data_seg(DATASEG_DEFAULT)

// function prototypes
HRESULT GetProfileList(LPPROFADMIN lpProfAdmin, LPSRowSet * ppRowSet);
HRESULT GetServicesList(LPSERVICEADMIN lpServiceAdmin, LPSRowSet *ppRowSet);
HRESULT CreateProfileIfNecessary(LPPROFADMIN lpProfAdmin, WCHAR * pszSelProfileName);
HRESULT InstallRequiredServices(LPSERVICEADMIN pServiceAdmin,
    LPSRowSet pServiceRowSet);
VOID FreeSRowSet(LPSRowSet prws);
BOOL ValidateProperty(LPSPropValue pval, ULONG cVal, ULONG ulPropTag);
BOOL DoesFileExist(WCHAR * pszPath, WCHAR * pszFileName);
HRESULT ConfigInternetService(MAILCONFIGINFO * pMailConfigInfo,
    LPSERVICEADMIN lpServiceAdmin);
HRESULT     GetServiceUID(WCHAR * pszName, LPSERVICEADMIN lpServiceAdmin,
    LPMAPIUID *ppMapiUID);
BOOL MakeUniqueFilename(UINT uIDFilename, UINT uIDAltFilename,
    WCHAR * pszFilename, DWORD cbFilename);
extern BOOL GetApiProcAddresses(HMODULE hModDLL, APIFCN * pApiProcList,
    UINT nApiProcs);
HRESULT ConfigNewService(LPSERVICEADMIN lpServiceAdmin, LPMAPIUID lpMapiUID,
    UINT uIDFilename, UINT uIDFilename1,UINT uPropValID);

// enums
enum { ivalDisplayName, ivalServiceName, ivalResourceFlags, ivalServiceDllName,
    ivalServiceEntryName, ivalServiceUID, ivalServiceSupportFiles,
    cvalMsgSrvMax };

BOOL gfMAPIActive = FALSE;


/*******************************************************************

    NAME:        GetApiProcAddresses

    SYNOPSIS:    Gets proc addresses for a table of functions

    EXIT:        returns TRUE if successful, FALSE if unable to retrieve
                any proc address in table

    HISTORY: 
    96/02/28    markdu    If the api is not found in the module passed in,
                        try the backup (RNAPH.DLL)

********************************************************************/
BOOL GetApiProcAddresses(HMODULE hModDLL, APIFCN * pApiProcList,UINT nApiProcs)
{

    UINT nIndex;
    // cycle through the API table and get proc addresses for all the APIs we
    // need
    for (nIndex = 0;nIndex < nApiProcs;nIndex++)
    {
        if (!(*pApiProcList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hModDLL,
            pApiProcList[nIndex].pszName)))
        {
                return FALSE;
	}
    }

    return TRUE;
}
/*******************************************************************

    NAME:        InitMAPI

    SYNOPSIS:    Loads the MAPI dll, gets proc addresses and initializes
                MAPI

    EXIT:        TRUE if successful, or FALSE if fails.    Displays its
                own error message upon failure.

    NOTES:        We load MAPI explicitly because the DLL may not be installed
                when we begin the wizard... we may have to install it and
                then load it.
                

********************************************************************/
BOOL InitMAPI(HWND hWnd)
{
    HRESULT hr;

    // load MAPI only if not already loaded... otherwise just increment
    // reference count

    if (!hInstMAPIDll) {

        // get the filename (MAPI32.DLL) out of resource
        // load the MAPI dll
        hInstMAPIDll = LoadLibrary(L"MAPI32.DLL");
        if (!hInstMAPIDll) {
            UINT uErr = GetLastError();
            //DisplayErrorMessage(hWnd, IDS_ERRLoadMAPIDll1,uErr,ERRCLS_STANDARD,
            //    MB_ICONSTOP, szMAPIDll);
            return FALSE;
        }

        // cycle through the API table and get proc addresses for all the APIs we
        // need
        BOOL fSuccess = GetApiProcAddresses(hInstMAPIDll, MAPIApiList,NUM_MAPI_PROCS);

        if (!fSuccess) {
            DeInitMAPI();
            return FALSE;
        }

        // initialize MAPI
        assert(lpMAPIInitialize);
        hr = lpMAPIInitialize(NULL);
        if (HR_FAILED(hr)) {
            DeInitMAPI();
            return FALSE;
        }

        gfMAPIActive = TRUE;
    }

    dwMAPIRefCount ++;

     return TRUE;
}

/*******************************************************************

    NAME:        DeInitMAPI

    SYNOPSIS:    Uninitializes MAPI and unloads MAPI dlls

********************************************************************/
VOID DeInitMAPI(VOID)
{
    // decrease reference count
    if (dwMAPIRefCount) {
        dwMAPIRefCount--;
    }

    // shut down and unload MAPI if reference count hits zero
    if (!dwMAPIRefCount) {
        // uninitialize MAPI
        if (gfMAPIActive && lpMAPIUninitialize) {
            lpMAPIUninitialize();
            gfMAPIActive = FALSE;
        }

        // free the MAPI dll
        if (hInstMAPIDll) {
            FreeLibrary(hInstMAPIDll);
            hInstMAPIDll = NULL;
        }
    
        // set function pointers to NULL
        for (UINT nIndex = 0;nIndex<NUM_MAPI_PROCS;nIndex++) 
            *MAPIApiList[nIndex].ppFcnPtr = NULL;
    }
}

/*******************************************************************

    NAME:        SetMailProfileInformation

    SYNOPSIS:    Sets up MAPI profile for internet mail and sets
                user information in profile.

    ENTRY:        pMailConfigInfo - pointer to struct with configuration info

    EXIT:        returns an HRESULT
    
    NOTES:        See strategy statement above
    
********************************************************************/
HRESULT SetMailProfileInformation(MAILCONFIGINFO * pMailConfigInfo)
{
    HRESULT hr;
    LPPROFADMIN     pProfAdmin=NULL;    // interface to administer profiles
    LPSERVICEADMIN    pServiceAdmin=NULL; // interface to administer services
    LPSRowSet        pServiceRowSet=NULL;
    WCHAR            szSelProfileName[cchProfileNameMax+1]=L"";

    assert(pMailConfigInfo);

    // get a pointer to the interface to administer profiles
    assert(lpMAPIAdminProfiles);
    hr = lpMAPIAdminProfiles(0, &pProfAdmin);
    if (HR_FAILED(hr)) {
        //DEBUGMSG(L"MAPIAdminProfiles returned 0x%lx", hr);
        return (hr);
    }
    assert(pProfAdmin);
    // release this interface when we leave the function
    RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

    // get profile name from passed-in struct, if specified
    if (pMailConfigInfo->pszProfileName && lstrlen(pMailConfigInfo->pszProfileName)) {
        lstrcpy(szSelProfileName, pMailConfigInfo->pszProfileName);
    } else {
        // no profile specified, use default name
        LoadString( GetModuleHandle(L"msobcomm.dll"), IDS_DEFAULT_PROFILE_NAME, szSelProfileName,MAX_CHARS_IN_BUFFER(szSelProfileName));
    }

    // create profile if we need to
    hr = CreateProfileIfNecessary(pProfAdmin, szSelProfileName);
    if (HR_FAILED(hr))
        return hr;

    // set this profile as default if appropriate
    if (pMailConfigInfo->fSetProfileAsDefault) {
        hr = pProfAdmin->SetDefaultProfile(szSelProfileName, 0);
        if (HR_FAILED(hr))
            return hr;
    }

    assert(lstrlen(szSelProfileName));    // should have profile name at this point
    //DEBUGMSG(L"Modifying MAPI profile: %s", szSelProfileName);

    // get a pointer to the interface to administer services for this profile
    hr = pProfAdmin->AdminServices(szSelProfileName, NULL,NULL,0,
        &pServiceAdmin);

    if (HR_FAILED(hr))
        return hr;
    assert(pServiceAdmin);
    // release pServiceAdmin interface when done
    RELEASE_ME_LATER rlServiceAdmin(pServiceAdmin);    

    // get a list of services for this profile
    hr = GetServicesList(pServiceAdmin, &pServiceRowSet);
    if (HR_FAILED(hr))
        return hr;
    assert(pServiceRowSet);

    // install any services we need which aren't already present in the profile
    hr = InstallRequiredServices(pServiceAdmin, pServiceRowSet);
        // done with profile row set, free the table
    FreeSRowSet(pServiceRowSet);
    pServiceRowSet = NULL;
    if (HR_FAILED(hr))
        return hr;

    // configure the internet mail service with the passed in email name,
    // server, etc.
    hr = ConfigInternetService(pMailConfigInfo, pServiceAdmin);
    if (HR_FAILED(hr)) {
        //DEBUGMSG(L"ConfigInternetService returned 0x%x" , hr);
        return hr;
    }

    return hr;
}

/*******************************************************************

    NAME:        GetProfileList

    SYNOPSIS:    retrieves a list of MAPI profiles 

    ENTRY:        lpProfAdmin - pointer to profile admin interface
                ppRowSet - pointer to an SRowSet pointer that is filled in

    EXIT:        returns an HRESULT.    If successful, *ppRowSet contains
                pointer to SRowSet with profile list.

    NOTES:        Cloned from MAPI profile control panel code.
                Caller MUST call MAPIFreeBuffer to free *ppRowSet when done.
                    
********************************************************************/
HRESULT GetProfileList(LPPROFADMIN lpProfAdmin, LPSRowSet * ppRowSet)
{
    HRESULT hr;
    LPMAPITABLE     pMapiTable=NULL;
    SPropTagArray     TagArray= {3,
                        {PR_DISPLAY_NAME,
                        PR_COMMENT,
                        PR_DEFAULT_PROFILE}};

    assert(lpProfAdmin);
    assert(ppRowSet);

    // call the lpProfAdmin interface to get the MAPI profile table
    hr = lpProfAdmin->GetProfileTable(0, &pMapiTable);
    if (HR_FAILED(hr))
        return hr;
    assert(pMapiTable);
    // release this interface when we leave the function
    RELEASE_ME_LATER ReleaseMapiTableLater(pMapiTable);

    // set properties of table columns
    hr = pMapiTable->SetColumns(&TagArray, 0);
    if (!HR_FAILED(hr)) {
        // get row set information from table
        hr = pMapiTable->QueryRows(4000, 0,ppRowSet);
    }

    return hr;
}

/*******************************************************************

    NAME:        GetServicesList

    SYNOPSIS:    retrieves a list of MAPI services in a profile

    ENTRY:        lpProfAdmin - pointer to service admin interface
                ppRowSet - pointer to an SRowSet pointer that is filled in

    EXIT:        returns an HRESULT.    If successful, *ppRowSet contains
                pointer to SRowSet with service list.

    NOTES:        Cloned from MAPI profile control panel code.
                Caller MUST call MAPIFreeBuffer to free *ppRowSet when done.
                    
********************************************************************/
HRESULT GetServicesList(LPSERVICEADMIN lpServiceAdmin, LPSRowSet *ppRowSet)
{
    HRESULT            hr;
    ULONG            iRow;
    LPMAPITABLE        pMapiTable     = NULL;
    SCODE            sc        = S_OK;
    static SPropTagArray taga    = {7, 
    { PR_DISPLAY_NAME,
                                        PR_SERVICE_NAME,
                                        PR_RESOURCE_FLAGS,
                                        PR_SERVICE_DLL_NAME,
                                        PR_SERVICE_ENTRY_NAME,
                                        PR_SERVICE_UID,
                                        PR_SERVICE_SUPPORT_FILES }};

    *ppRowSet = NULL;

    hr = lpServiceAdmin->GetMsgServiceTable(0, &pMapiTable);
    if (HR_FAILED(hr))
        return hr;
    // free this interface when function exits
    RELEASE_ME_LATER rlTable(pMapiTable);


    hr = pMapiTable->SetColumns(&taga, 0);
    if (!HR_FAILED(hr)) {
        // BUGBUG get rid of 'magic number' (appears in MAPI
        // ctrl panel code, need to find out what it is)    jeremys 1/30/95
        hr = pMapiTable->QueryRows(4000, 0,ppRowSet);
    }
    if (HR_FAILED(hr))
        return hr;

    for(iRow = 0; iRow < (*ppRowSet)->cRows; iRow++)
    {
        // make sure properties are valid, if not then slam something in
        ValidateProperty((*ppRowSet)->aRow[iRow].lpProps, 0, PR_DISPLAY_NAME);
        ValidateProperty((*ppRowSet)->aRow[iRow].lpProps, 1, PR_SERVICE_NAME);
    }

    return hr;
}

/*******************************************************************

    NAME:        CreateProfileIfNecessary

    SYNOPSIS:    Creates profile if it doesn't already exist

    ENTRY:        lpProfAdmin - pointer to profile admin interface
                pszSelProfileName - name of profile to create

    EXIT:        returns an HRESULT. 

********************************************************************/
HRESULT CreateProfileIfNecessary(LPPROFADMIN pProfAdmin, WCHAR * pszSelProfileName)
{
    HRESULT hr = hrSuccess;
    LPWSTR lpProfileName=NULL;
    BOOL    fDefault;

    assert(pProfAdmin);
    assert(pszSelProfileName);

    ENUM_MAPI_PROFILE EnumMAPIProfile;

    // walk through the profile names, see if we have a match
    while (EnumMAPIProfile.Next(&lpProfileName, &fDefault)) {
        assert(lpProfileName);

        if (!lstrcmpi(lpProfileName, pszSelProfileName)) {
            return hrSuccess;    // found a match, nothing to do
        }
    }

    // no match, need to create profile
    //DEBUGMSG(L"Creating MAPI profile: %s", pszSelProfileName);
    // call MAPI to create the profile
    hr = pProfAdmin->CreateProfile(pszSelProfileName,
        NULL, (ULONG) 0, (ULONG) 0);

    return hr;
}


/*******************************************************************

    NAME:        InstallRequiredServices

    SYNOPSIS:    Installs the 3 services we need (message store,
                address book, internet mail) in the profile
                if they're not already present.    Calls functions to configure
                message store and address book (they both need a filename
                to use) if we're adding them.

    ENTRY:        lpServiceAdmin - pointer to service admin interface
                pServiceRowSet - MAPI table with list of installed services
                
    EXIT:        returns an HRESULT. 

    NOTES:        We deliberately don't configure internet mail service here--
                we do that in the main routine.    The reason is that we
                need to configure internet mail whether it's already installed
                or not, address book and message store we only need to configure
                if they're brand new.

********************************************************************/
HRESULT InstallRequiredServices(LPSERVICEADMIN pServiceAdmin,
    LPSRowSet pServiceRowSet)
{
    ULONG             iRow, iService;
    WCHAR             szServiceName[SMALL_BUF_LEN+1];
    LPMAPIUID         pMapiUID=NULL;
    HRESULT            hr=hrSuccess;

    // table for MAPI services we need to make sure are installed in profile
    MSGSERVICE MAPIServiceList[NUM_SERVICES] = {
        { FALSE, IDS_INTERNETMAIL_SERVICENAME, IDS_INTERNETMAIL_DESCRIPTION, FALSE, 0,0,0},
        { FALSE, IDS_MESSAGESTORE_SERVICENAME, IDS_MESSAGESTORE_DESCRIPTION, TRUE,
            IDS_MESSAGESTORE_FILENAME, IDS_MESSAGESTORE_FILENAME1,PR_PST_PATH},
        { FALSE, IDS_ADDRESSBOOK_SERVICENAME, IDS_ADDRESSBOOK_DESCRIPTION, TRUE,
            IDS_ADDRESSBOOK_FILENAME, IDS_ADDRESSBOOK_FILENAME1,PR_PAB_PATH}};

    // walk through the list of services
    for (iRow = 0;iRow < pServiceRowSet->cRows;iRow ++) {
        //DEBUGMSG(L"Profile contains service: %s (%s)",
        //    pServiceRowSet->aRow[iRow].lpProps[ivalDisplayName].Value.LPSZ,
        //    pServiceRowSet->aRow[iRow].lpProps[ivalServiceName].Value.LPSZ);

        // for each service, walk through our array of required services,
        // and see if there's a match
        for (iService = 0;iService < NUM_SERVICES;iService ++) {
            // load the name for this service out of resource
            LoadString( GetModuleHandle(L"msobcomm.dll"), MAPIServiceList[iService].uIDServiceName,
                szServiceName, MAX_CHARS_IN_BUFFER(szServiceName));

            // compare it to the service name in the table of
            // installed services for this profile
            if (!lstrcmpi(szServiceName,
                pServiceRowSet->aRow[iRow].lpProps[ivalServiceName].Value.LPSZ)) {
                 // this is a match!
                MAPIServiceList[iService].fPresent = TRUE;
                break;    // break the inner 'for' loop
            }
        }
    }


    // install any services we need which are not already present
    for (iService = 0;iService < NUM_SERVICES;iService ++) {

        if (!MAPIServiceList[iService].fPresent) {
            WCHAR szServiceDesc[MAX_RES_LEN+1];
            MSGSERVICE * pMsgService = &MAPIServiceList[iService];                

            // load the service name and description
            LoadString( GetModuleHandle(L"msobcomm.dll"), pMsgService->uIDServiceName,
                szServiceName, MAX_CHARS_IN_BUFFER(szServiceName));
            LoadString( GetModuleHandle(L"msobcomm.dll"), pMsgService->uIDServiceDescription,
                szServiceDesc, MAX_CHARS_IN_BUFFER(szServiceDesc));
            //DEBUGMSG(L"Adding service: %s (%s)",
            //    szServiceDesc, szServiceName);

            // create the service
            hr = pServiceAdmin->CreateMsgService(szServiceName,
                szServiceDesc, 0,0);
            if (HR_FAILED(hr))
                return hr;

            // call a creation-time config procedure if specified
            if (pMsgService->fNeedConfig) {

                // get the UID (identifier) for this service
                // based on service name, APIs downstream need this
                hr = GetServiceUID(szServiceName, pServiceAdmin,
                    &pMapiUID);
                if (HR_FAILED(hr))
                    return hr;
                assert(pMapiUID);

                // call the proc to configure newly-created service
                hr = ConfigNewService(pServiceAdmin, pMapiUID,
                    pMsgService->uIDStoreFilename, pMsgService->uIDStoreFilename1,
                    pMsgService->uPropID);

                // free the buffer with the UID
                assert(lpMAPIFreeBuffer);
                lpMAPIFreeBuffer(pMapiUID);
                pMapiUID = NULL;
            }
        }
    }

    return hr;
}

#define NUM_MAIL_PROPS     11
/*******************************************************************

    NAME:        ConfigInternetService

    SYNOPSIS:    Configures the Internet Mail service (route 66) with
                user's email name, email server, etc.

    ENTRY:        pMailConfigInfo - pointer to struct with configuration info
                pServiceAdmin - pointer to service admin interface

    EXIT:        returns an HRESULT

    NOTES:        will stomp any existing settings for properties that it
                sets.

********************************************************************/
HRESULT ConfigInternetService(MAILCONFIGINFO * pMailConfigInfo,
    LPSERVICEADMIN pServiceAdmin)
{
    HRESULT         hr;
    SPropValue         PropValue[NUM_MAIL_PROPS];
    WCHAR             szServiceName[SMALL_BUF_LEN+1];
    LPMAPIUID         pMapiUID=NULL;
    UINT            nProps = NUM_MAIL_PROPS;

    assert(pMailConfigInfo);
    assert(pServiceAdmin);

    // get service UID for internet mail service
    LoadString( GetModuleHandle(L"msobcomm.dll"), IDS_INTERNETMAIL_SERVICENAME, szServiceName,MAX_CHARS_IN_BUFFER(szServiceName));
    hr = GetServiceUID(szServiceName, pServiceAdmin,&pMapiUID);
    if (HR_FAILED(hr)) {
        return hr;
    }
    assert(pMapiUID);


    // set the property value for each property.    Note that the order
    // of items in the array doesn't mattter. The ulPropTag member indicates
    // what property the PropValue item is for, and the lpszW, b or l member
    // contains the data for that property.

    // need to "encrypt" mail account password with xor bit mask.    Mail client
    // expects it to be thusly "encrypted" when it reads it out.    It's stored
    // in the registry in this securely "encrypted" format.    Somebody pretty
    // smart must have thought of this.

    // configure mail service properties
    PropValue[0].ulPropTag = PR_CFG_EMAIL_ADDRESS;
    PropValue[0].Value.lpszW = pMailConfigInfo->pszEmailAddress;
    PropValue[1].ulPropTag = PR_CFG_EMAIL_DISPLAY_NAME;
    PropValue[1].Value.lpszW = pMailConfigInfo->pszEmailDisplayName;
    PropValue[2].ulPropTag = PR_CFG_SERVER_PATH;
    PropValue[2].Value.lpszW = pMailConfigInfo->pszEmailServer;
    PropValue[3].ulPropTag = PR_CFG_EMAIL_ACCOUNT;
    PropValue[3].Value.lpszW = pMailConfigInfo->pszEmailAccountName;
    PropValue[4].ulPropTag = PR_CFG_PASSWORD;
    PropValue[4].Value.lpszW = (LPWSTR) szNull;
    PropValue[5].ulPropTag = PR_CFG_REMEMBER;
    PropValue[5].Value.b = (USHORT) TRUE;
    // configure for RNA or LAN as appropriate
    PropValue[6].ulPropTag = PR_CFG_RNA_PROFILE;
    PropValue[7].ulPropTag = PR_CFG_CONN_TYPE;
    PropValue[8].ulPropTag = PR_CFG_DELIVERY_OPTIONS;
    if (pMailConfigInfo->pszConnectoidName &&
        lstrlen(pMailConfigInfo->pszConnectoidName)) {
        PropValue[6].Value.lpszW = pMailConfigInfo->pszConnectoidName;
        PropValue[7].Value.l = (long) CONNECT_TYPE_REMOTE;
        // set transfer mode for "selective"..
        PropValue[8].Value.l = DOWNLOAD_OPTION_HEADERS;
    } else {
        PropValue[6].Value.lpszW = (LPWSTR) szNull;
        PropValue[7].Value.l = (long) CONNECT_TYPE_LAN;
        // set automatic transfer mode... mail guys made up the weird
        // define name, not me!
        PropValue[8].Value.l = DOWNLOAD_OPTION_MAIL_DELETE;
    }
    PropValue[9].ulPropTag = PR_CFG_REMOTE_USERNAME;
    PropValue[9].Value.lpszW = pMailConfigInfo->pszEmailAccountName;
    PropValue[10].ulPropTag = PR_CFG_REMOTE_PASSWORD;
    PropValue[10].Value.lpszW = pMailConfigInfo->pszEmailAccountPwd;

    // call the service admin interface to configure the service with these
    // properties
    hr = pServiceAdmin->ConfigureMsgService(pMapiUID, NULL,0,
        nProps, PropValue);
    if (HR_FAILED(hr)) {
        //DEBUGMSG(L"ConfigureMsgService returned 0x%x", hr);
    }

    // free the buffer with the UID
    assert(lpMAPIFreeBuffer);
    lpMAPIFreeBuffer(pMapiUID);
    pMapiUID = NULL;

    return hr;
}

/*******************************************************************

    NAME:        ConfigMessageStore

    SYNOPSIS:    Generates a unique filename and sets it as the
                message store

    ENTRY:        lpServiceAdmin - pointer to service admin interface
                lpMapiUID - UID for this service (message store)

    EXIT:        returns an HRESULT

    NOTES:        This code expects to be called only when the service is
                newly created.    Calling it on an existing service will
                cause it to stomp existing settings.
    
********************************************************************/
HRESULT ConfigNewService(LPSERVICEADMIN lpServiceAdmin, LPMAPIUID lpMapiUID,
    UINT uIDFilename, UINT uIDFilename1,UINT uPropValID)
{
    WCHAR szMsgStorePath[MAX_PATH+1];
    HRESULT hr=hrSuccess;

    assert(lpServiceAdmin);
    assert(lpMapiUID);

    // build a path for the message store
    if (!MakeUniqueFilename(uIDFilename, uIDFilename1,
        szMsgStorePath, MAX_CHARS_IN_BUFFER(szMsgStorePath) ))
    {
        //DEBUGTRAP(L"Unable to create unique filename");
        return MAPI_E_COLLISION;
    }
    //(L"Creating MAPI store %s", szMsgStorePath);

    // set this filename for the message store
    SPropValue PropVal;
    PropVal.ulPropTag = uPropValID;
    PropVal.Value.lpszW = szMsgStorePath;
    hr = lpServiceAdmin->ConfigureMsgService(lpMapiUID, NULL,0,1,&PropVal);
    if (HR_FAILED(hr)) {
        //DEBUGMSG(L"ConfigureMsgService returned 0x%x", hr);
    }

    return hr;
}

/*******************************************************************

    NAME:        FindInternetMailService

    SYNOPSIS:    Detects if internet mail is installed, returns
                email address and email server if it is.
    
********************************************************************/
BOOL FindInternetMailService(WCHAR * pszEmailAddress, DWORD cbEmailAddress,
    WCHAR * pszEmailServer, DWORD cbEmailServer)
{
    assert(pszEmailAddress);
    assert(pszEmailServer);

    if (!hInstMAPIDll && !InitMAPI(NULL))
        return FALSE;

    // look through all profiles.    For each profile, look through all
    // services.    If we find an instance of the internet mail service,
    // then return email address and password to caller.    If there is
    // more than one profile with the internet mail service, we
    // will return the first one we find.

    ENUM_MAPI_PROFILE EnumMAPIProfile;
    LPWSTR lpProfileName, lpServiceName;
    BOOL fDefault;
    // walk through the list of profiles...
    while (EnumMAPIProfile.Next(&lpProfileName, &fDefault)) {
        assert(lpProfileName);

        //DEBUGMSG(L"Found profile: %s", lpProfileName);
        
        // for each profile, walk through the list of services...
        ENUM_MAPI_SERVICE EnumMAPIService(lpProfileName);
        while (EnumMAPIService.Next(&lpServiceName)) {
            WCHAR szSmallBuf[SMALL_BUF_LEN+1];

            //DEBUGMSG(L"Found service: %s", lpServiceName);
            LoadString( GetModuleHandle(L"msobcomm.dll"), IDS_INTERNETMAIL_SERVICENAME,
                szSmallBuf, MAX_CHARS_IN_BUFFER(szSmallBuf));

            if (!lstrcmpi(lpServiceName, szSmallBuf)) {

//BUGBUG 21-May-1995 jeremys Get e-mail server & address from MAPI profile

                return TRUE;
            }
        }
    }

    return FALSE;
}                             

ENUM_MAPI_PROFILE::ENUM_MAPI_PROFILE(VOID)
{
    LPPROFADMIN     pProfAdmin=NULL;    // interface to administer profiles
    HRESULT hr;

    //assert(gfMAPIActive, L"MAPI not initialized!");

    _pProfileRowSet = NULL;
    _nEntries = 0;
    _iRow = 0;

    // get a pointer to the interface to administer profiles
    assert(lpMAPIAdminProfiles);
    hr = lpMAPIAdminProfiles(0, &pProfAdmin);
    if (HR_FAILED(hr)) {
        //DEBUGMSG(L"MAPIAdminProfiles returned 0x%lx", hr);
        return;
    }
    assert(pProfAdmin);
    // release this interface when we leave the function
    RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

    // get the rows in the profile table
    hr = GetProfileList(pProfAdmin, &_pProfileRowSet);
    if (HR_FAILED(hr))
        return;
    assert(_pProfileRowSet);

    _nEntries = _pProfileRowSet->cRows;

}

ENUM_MAPI_PROFILE::~ENUM_MAPI_PROFILE(VOID)
{
    if (_pProfileRowSet) {
        // done with profile row set, free the table
        FreeSRowSet(_pProfileRowSet);
        _pProfileRowSet = NULL;
    }
}

BOOL ENUM_MAPI_PROFILE::Next(LPWSTR * ppProfileName, BOOL * pfDefault)
{
    assert(pfDefault);

    if (!_pProfileRowSet)
        return FALSE;

    if (_iRow < _pProfileRowSet->cRows) {
        LPSPropValue pPropVal = _pProfileRowSet->aRow[_iRow].lpProps;
        assert(pPropVal);

        // get pointer to profile name
        *ppProfileName = pPropVal[0].Value.LPSZ;
        assert(*ppProfileName);
        // set 'this profile is default' flag
        *pfDefault = pPropVal[2].Value.b;

        _iRow++;
        return TRUE;
    }
    
    return FALSE;
}

ENUM_MAPI_SERVICE::ENUM_MAPI_SERVICE(LPWSTR pszProfileName)
{
    LPPROFADMIN     pProfAdmin=NULL;    // interface to administer profiles
    LPSERVICEADMIN    pServiceAdmin=NULL;    // interface to administer services
    HRESULT hr;

    assert(pszProfileName);
    //assertSZ(gfMAPIActive, L"MAPI not initialized!");

    _pServiceRowSet = NULL;
    _nEntries = 0;
    _iRow = 0;

    // get a pointer to the interface to administer profiles
    assert(lpMAPIAdminProfiles);
    hr = lpMAPIAdminProfiles(0, &pProfAdmin);
    if (HR_FAILED(hr)) {
        //DEBUGMSG(L"MAPIAdminProfiles returned 0x%lx", hr);
        return;
    }
    assert(pProfAdmin);
    // release this interface when we leave the function
    RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

    // get a pointer to the interface to administer services for this profile
    hr = pProfAdmin->AdminServices(pszProfileName, NULL,NULL,0,
        &pServiceAdmin);
    if (HR_FAILED(hr)) {
        //DEBUGMSG(L"AdminServices returned 0x%lx", hr);
        return;
    }
    // release this interface when we leave the function
    RELEASE_ME_LATER ReleaseServiceAdminLater(pServiceAdmin);

    // get the rows in the profile table
    hr = GetServicesList(pServiceAdmin, &_pServiceRowSet);
    if (HR_FAILED(hr))
        return;
    assert(_pServiceRowSet);

    _nEntries = _pServiceRowSet->cRows;

}

ENUM_MAPI_SERVICE::~ENUM_MAPI_SERVICE(VOID)
{
    if (_pServiceRowSet) {
        // done with profile row set, free the table
        FreeSRowSet(_pServiceRowSet);
        _pServiceRowSet = NULL;
    }
}

BOOL ENUM_MAPI_SERVICE::Next(LPWSTR * ppServiceName)
{
    if (!_pServiceRowSet)
        return FALSE;

    if (_iRow < _pServiceRowSet->cRows) {
        LPSPropValue pPropVal = _pServiceRowSet->aRow[_iRow].lpProps;
        assert(pPropVal);

        // get pointer to profile name
        *ppServiceName = pPropVal[ivalServiceName].Value.LPSZ;
        assert(*ppServiceName);

        _iRow++;
        return TRUE;
    }
    
    return FALSE;
}

/*******************************************************************

    NAME:        MakeUniqueFilename

    SYNOPSIS:    Generates a filename in the Windows directory that
                does not already exist

    ENTRY:        uIDFilename - ID of string resource for desired name
                    for the file
                uIDAltFilename - ID of string resource with template
                    for filename to use if file with uIDFilename's name
                    already exists.    Template should contain %u into
                    which numbers will be inserted to make filename unique.
                pszFilename - buffer to return path and filename into
                cbFilename - size of pszFilename buffer

    EXIT:        returns TRUE if successful, FALSE if couldn't make
                unique filename within MAX_FILENAME_TRIES tries
    
********************************************************************/
// number of times we'll try to create a unique filename before giving up
#define MAX_MAKEFILENAME_TRIES    20
BOOL MakeUniqueFilename(UINT uIDFilename, UINT uIDAltFilename,
    WCHAR * pszFilename, DWORD cchFilename)
{
    WCHAR szFileName[SMALL_BUF_LEN+1];
    BOOL fSuccess = FALSE;

    assert(pszFilename);

    // build a path for the filename
    UINT uRet=GetWindowsDirectory(pszFilename, cchFilename);
    //assertSZ(uRet, L"GetWindowsDirectory failed");

    // choose a file name that doesn't already exist

    // first, try using the string resource specified by uIDFilename
    LoadString( GetModuleHandle(L"msobcomm.dll"), uIDFilename, szFileName,MAX_CHARS_IN_BUFFER(szFileName));
    if (DoesFileExist(pszFilename, szFileName)) {

        // if that file exists, then use the string resource uIDAltFilename
        // which has a replacable parameter.    We'll try adding numbers to
        // the filename to make it unique.
        
        WCHAR szFileFmt[SMALL_BUF_LEN+1];
        LoadString( GetModuleHandle(L"msobcomm.dll"), uIDAltFilename, szFileFmt,MAX_CHARS_IN_BUFFER(szFileFmt));

        for (UINT nIndex = 0; nIndex < MAX_MAKEFILENAME_TRIES; nIndex ++) {
            // make a name e.g. "mailbox4.pst"
            wsprintf(szFileName, szFileFmt,nIndex);
            if (!DoesFileExist(pszFilename, szFileName)) {
                // OK, found a filename that doesn't exist
                fSuccess = TRUE;
                break;
            }
        }
    } else {
        // first try succeeded    
        fSuccess = TRUE;
    }

    if (fSuccess) {
        // now we have unique filename, build the full path

        lstrcat(pszFilename, szSlash);
        lstrcat(pszFilename, szFileName);
    }

    return fSuccess;
}

/*******************************************************************

    NAME:        DoesFileExist

    SYNOPSIS:    Checks to see whether the specified file exists

    ENTRY:        pszPath - path to directory
                pszFilename - name of file

    EXIT:        returns TRUE if file exists, FALSE if it doesn't
    
********************************************************************/
BOOL DoesFileExist(WCHAR * pszPath, WCHAR * pszFileName)
{
    WCHAR         szPath[MAX_PATH+1];
    OFSTRUCT    of;

    assert(pszPath);
    assert(pszFileName);

    // concatenate the path and file name
    lstrcpy(szPath, pszPath);
    lstrcat(szPath, szSlash);
    lstrcat(szPath, pszFileName);

    // find out if this file exists
    WIN32_FIND_DATA fd;
    HANDLE          hfd = FindFirstFile(szPath, &fd);
    if (INVALID_HANDLE_VALUE == hfd)
    {
        return FALSE;
    }

    CloseHandle(hfd);
    return TRUE;

}

/*******************************************************************

    NAME:        GetServiceUID

    SYNOPSIS:    Given a MAPI service name, gets the MAPIUID associated
                with it.

    ENTRY:        pszServiceName - name of MAPI service (e.g. "IMAIL", "MSPST AB")
                lpServiceAdmin - pointer to service admin interface
                ppMapiUID - pointer to pointer for MAPIUID struct
    
    EXIT:        returns an HRESULT

    NOTES:        Cloned from MAPI profile wizard code, if you think this
                function is big and ugly now you should have seen it before
                I cleaned it up.

                This function allocates a MAPIUID, the caller is responsible
                for freeing this (use MAPIFreeBuffer) when done.
    
********************************************************************/
HRESULT     GetServiceUID(WCHAR * pszServiceName, LPSERVICEADMIN lpServiceAdmin,
    LPMAPIUID *ppMapiUID)
{
    HRESULT            hr =hrSuccess;
    LPSPropValue    pTblProp =NULL;
    DWORD                 iRow, iColumn;
    LPMAPITABLE         pTable =NULL;
    LPSRowSet        pRowSet =NULL;
    LPSRow            pRow =NULL;
    int                nFound =0;
    LPMAPIUID        pMapiUID =NULL;
    BOOL            fContinue = TRUE;
    SizedSPropTagArray(2, Tbltaga) = { 2, { PR_SERVICE_NAME,
                                            PR_SERVICE_UID }};

    assert(pszServiceName);
    assert(lpServiceAdmin);
    assert(ppMapiUID);

    // get table of message services
    hr = lpServiceAdmin->GetMsgServiceTable(0, &pTable);
    if (HR_FAILED(hr))
    {
        //DEBUGMSG(L"GetMsgServiceTable returned 0x%x", hr);
        return hr;
    }
    assert(pTable);
    // release this table when we exit this function
    RELEASE_ME_LATER rlTable(pTable);

    assert(lpHrQueryAllRows);
    hr = lpHrQueryAllRows(pTable, (LPSPropTagArray) &Tbltaga, NULL, NULL, 0, &pRowSet);
    if (HR_FAILED(hr))
    {
        //DEBUGMSG(L"HrQueryAllRows returned 0x%x", hr);
        return hr;
    }
    assert(pRowSet);

    iRow =0;
    while (fContinue && iRow< pRowSet->cRows)
    {
        pRow = &pRowSet->aRow[iRow];
        pTblProp = pRow->lpProps;
        nFound = 0;
        for (iColumn=0; iColumn<pRow->cValues; iColumn++)
        {     //Check each property
            if (pTblProp->ulPropTag ==PR_SERVICE_UID)
            {
                nFound++;
                assert(lpMAPIAllocateBuffer);
                lpMAPIAllocateBuffer(pTblProp->Value.bin.cb, (LPVOID FAR *) &pMapiUID);
                if (!pMapiUID)
                {
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    fContinue = FALSE;
                    break;
                }
                memcpy(pMapiUID, pTblProp->Value.bin.lpb, (size_t) pTblProp->Value.bin.cb);
                *ppMapiUID = pMapiUID;
            }
            else if ((pTblProp->ulPropTag ==PR_SERVICE_NAME) &&
                     !lstrcmpi(pTblProp->Value.lpszW, pszServiceName))
            {
                nFound++;
            }
            pTblProp++;

            if (nFound == 2) {
                // found it!
                fContinue = FALSE;
                break;
            }
        }
        iRow++;

        if (nFound < 2) {        
        // if one but not both items matched above, then deallocate buffer
            if (pMapiUID) {
                assert(lpMAPIFreeBuffer);
                lpMAPIFreeBuffer(pMapiUID);
                pMapiUID =NULL;
            }
            if (*ppMapiUID)
                *ppMapiUID = NULL;
        }
    }

    if (HR_FAILED(hr) || nFound < 2) {
        // free buffer if we didn't find the UID
        if (pMapiUID) {
            assert(lpMAPIFreeBuffer);
            lpMAPIFreeBuffer(pMapiUID);
        }
        if (*ppMapiUID)
            *ppMapiUID = NULL;
    }

    if (pRowSet)
        FreeSRowSet(pRowSet);

    return hr;
}

/*******************************************************************

    NAME:        FreeSRowSet

    SYNOPSIS:    Frees an SRowSet structure and the rows therein

    ENTRY:        prws - the row set to free

    NOTES:        Cloned from MAPI profile ctrl panel code

********************************************************************/
VOID FreeSRowSet(LPSRowSet prws)
{
    ULONG irw;

    if (!prws)
        return;

    assert(lpMAPIFreeBuffer);

    // Free each row
    for (irw = 0; irw < prws->cRows; irw++)
        lpMAPIFreeBuffer(prws->aRow[irw].lpProps);

    // Free the top level structure
    lpMAPIFreeBuffer(prws);
}

/*
 *    ValidateProperty
 *
 *    Purpose:
 *        Given a string prop, make sure it contains a valid string.
 *
 *    Arguments:
 *        pval
 *        cVal
 *        ulPropTag
 *
 *    Returns:
 *        BOOL
 */
WCHAR szUnk[] = L"???";
BOOL ValidateProperty(LPSPropValue pval, ULONG cVal, ULONG ulPropTag)
{
    if(pval[cVal].ulPropTag != ulPropTag)
    {
        // make sure we're not stomping on good properties.
        assert(PROP_TYPE(pval[cVal].ulPropTag) == PT_ERROR);

        pval[cVal].ulPropTag = ulPropTag;
        pval[cVal].Value.LPSZ = szUnk;

        return TRUE;
    }

    return FALSE;
}

#pragma data_seg(DATASEG_READONLY)
// note: this array depends on errors in rc file being in this order
// starting with S_OK.    Don't rearrange one without rearranging the other.
static SCODE mpIdsScode[] =
{
        S_OK,
        MAPI_E_NO_ACCESS,
        E_NOINTERFACE,
        E_INVALIDARG,
        MAPI_E_CALL_FAILED,
        MAPI_E_NOT_FOUND,
        MAPI_E_NO_SUPPORT,
        MAPI_W_ERRORS_RETURNED,
        MAPI_W_PARTIAL_COMPLETION,
        MAPI_E_BAD_CHARWIDTH,
        MAPI_E_BAD_VALUE,
        MAPI_E_BUSY,
        MAPI_E_COLLISION,
        MAPI_E_COMPUTED,
        MAPI_E_CORRUPT_DATA,
        MAPI_E_CORRUPT_STORE,
        MAPI_E_DISK_ERROR,
        MAPI_E_HAS_FOLDERS,
        MAPI_E_HAS_MESSAGES,
        MAPI_E_INVALID_ENTRYID,
        MAPI_E_INVALID_OBJECT,
        MAPI_E_LOGON_FAILED,
        MAPI_E_NETWORK_ERROR,
        MAPI_E_NON_STANDARD,
        MAPI_E_NOT_ENOUGH_DISK,
        MAPI_E_NOT_ENOUGH_MEMORY,
        MAPI_E_NOT_ENOUGH_RESOURCES,
        MAPI_E_NOT_IN_QUEUE,
        MAPI_E_OBJECT_CHANGED,
        MAPI_E_OBJECT_DELETED,
        MAPI_E_STRING_TOO_LONG,
        MAPI_E_SUBMITTED,
        MAPI_E_TOO_BIG,
        MAPI_E_UNABLE_TO_ABORT,
        MAPI_E_UNCONFIGURED,
        MAPI_E_UNEXPECTED_TYPE,
        MAPI_E_UNKNOWN_FLAGS,
        MAPI_E_USER_CANCEL,
        MAPI_E_VERSION
};
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\misc.cpp ===
/*-----------------------------------------------------------------------------
    misc.cpp

    service functions

  History:
        1/7/98      DONALDM Moved to new ICW project and string
                    and nuked 16 bit stuff
-----------------------------------------------------------------------------*/

//#include <stdio.h>
#include "obcomglb.h"
#include <shlobj.h>
#include <winsock2.h>
#include <assert.h>
#include <ras.h>
#include <util.h>
#include <inetreg.h>
#include <userenv.h>
#include <userenvp.h>
#include <shlwapi.h>
#include <sddl.h>
extern "C"
{
#include <sputils.h>
}

#define DIR_SIGNUP L"signup"
#define DIR_WINDOWS L"windows"
#define DIR_SYSTEM L"system"
#define DIR_TEMP L"temp"
#define INF_DEFAULT L"SPAM SPAM SPAM SPAM SPAM SPAM EGGS AND SPAM"
const WCHAR cszFALSE[] = L"FALSE";
const WCHAR cszTRUE[]  = L"TRUE";

BOOL g_bGotProxy=FALSE;

//+----------------------------------------------------------------------------
// NAME: GetSz
//
//    Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
//+----------------------------------------------------------------------------

LPWSTR GetSz(DWORD dwszID)
{
    /*
    LPWSTR psz = szStrTable[iSzTable];

    iSzTable++;
    if (iSzTable >= MAX_STRINGS)
        iSzTable = 0;

    if (!LoadString(_Module.GetModuleInstance(), dwszID, psz, 512))
    {
        *psz = 0;
    }

    return (psz);
    */
    return (NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessDBCS
//
//  Synopsis:   Converts control to use DBCS compatible font
//              Use this at the beginning of the dialog procedure
//  
//              Note that this is required due to a bug in Win95-J that prevents
//              it from properly mapping MS Shell Dlg.  This hack is not needed
//              under winNT.
//
//  Arguments:  hwnd - Window handle of the dialog
//              cltID - ID of the control you want changed.
//
//  Returns:    ERROR_SUCCESS
//
//  History:    4/31/97 a-frankh    Created
//              5/13/97 jmazner     Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
    HFONT hFont = NULL;

    /*if( IsNT() )
    {
        return;
    }*/

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    if (hFont != NULL)
        SendMessage(GetDlgItem(hDlg, ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
}

// ############################################################################
//  StoreInSignUpReg
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCWSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey;

    hr = RegCreateKey(HKEY_LOCAL_MACHINE, SIGNUPKEY, &hKey);
    if (hr != ERROR_SUCCESS) goto StoreInSignUpRegExit;
    hr = RegSetValueEx(hKey, pszKey, 0,dwType,lpbData,dwSize);


    RegCloseKey(hKey);

StoreInSignUpRegExit:
    return hr;
}

HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCWSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, SIGNUPKEY, &hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegQueryValueEx(hKey, pszKey, 0,&dwType,lpbData,pdwSize);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}


HRESULT DeleteSignUpReg(LPCWSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SIGNUPKEY, 0, KEY_ALL_ACCESS, &hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegDeleteValue(hKey, pszKey);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}

// ############################################################################
//  GetDataFromISPFile
//
//  This function will read a specific piece of information from an ISP file.
//
//  Created 3/16/96,        Chris Kauffman
// ############################################################################
HRESULT GetDataFromISPFile
(
    LPWSTR pszISPCode,
    LPWSTR pszSection,
    LPWSTR pszDataName,
    LPWSTR pszOutput,
    DWORD cchOutput)
{
    LPWSTR   pszTemp;
    HRESULT hr = ERROR_SUCCESS;
    WCHAR    szTempPath[MAX_PATH];
    //WCHAR    szBuff256[256];

    *pszOutput = L'\0'; // since lstrlen(pszOutput) is used later when
                        // pszOutput may be otherwise still uninitialized

    // Locate ISP file
    if (!SearchPath(NULL, pszISPCode, INF_SUFFIX,MAX_PATH,szTempPath,&pszTemp))
    {
        //wsprintf(szBuff256, L"Can not find:%s%s (%d) (connect.exe)", pszISPCode,INF_SUFFIX,GetLastError());
        ////AssertMsg(0, szBuff256);
        //lstrcpyn(szTempPath, pszISPCode, MAX_PATH);
        //lstrcpyn(&szTempPath[lstrlen(szTempPath)], INF_SUFFIX, MAX_PATH-lstrlen(szTempPath));
        //wsprintf(szBuff256, GetSz(IDS_CANTLOADINETCFG), szTempPath);
        ////MessageBox(NULL, szBuff256, GetSz(IDS_TITLE),MB_MYERROR);
        hr = ERROR_FILE_NOT_FOUND;
    } else if (!GetPrivateProfileString(pszSection, pszDataName, INF_DEFAULT,
        pszOutput, (int)cchOutput, szTempPath))
    {
        //TraceMsg(TF_GENERAL, L"ICWHELP: %s not specified in ISP file.\n", pszDataName);
        hr = ERROR_FILE_NOT_FOUND;
    }

    // 10/23/96 jmazner Normandy #9921
    // CompareString does _not_ have same return values as lsrtcmp!
    // Return value of 2 indicates strings are equal.
    //if (!CompareString(LOCALE_SYSTEM_DEFAULT, 0, INF_DEFAULT,lstrlen(INF_DEFAULT),pszOutput,lstrlen(pszOutput)))
    if (2 == CompareString(LOCALE_SYSTEM_DEFAULT, 0, INF_DEFAULT,lstrlen(INF_DEFAULT),pszOutput,lstrlen(pszOutput)))
    {
        hr = ERROR_FILE_NOT_FOUND;
    }

    if (hr != ERROR_SUCCESS && cchOutput)
        *pszOutput = L'\0'; // I suppose if CompareString fails, this is not
                            // redundant with the first *pszOutput = L'\0';.
    return hr;
}

// ############################################################################
//  GetINTFromISPFile
//
//  This function will read a specific integer from an ISP file.
//
//
// ############################################################################
HRESULT GetINTFromISPFile
(
    LPWSTR   pszISPCode,
    LPWSTR   pszSection,
    LPWSTR   pszDataName,
    int far *lpData,
    int     iDefaultValue
)
{
    LPWSTR   pszTemp;
    HRESULT hr = ERROR_SUCCESS;
    WCHAR    szTempPath[MAX_PATH];
    //WCHAR    szBuff256[256];

    // Locate ISP file
    if (!SearchPath(NULL, pszISPCode, INF_SUFFIX,MAX_PATH,szTempPath,&pszTemp))
    {
        //wsprintf(szBuff256, L"Can not find:%s%s (%d) (connect.exe)", pszISPCode,INF_SUFFIX,GetLastError());
        ////AssertMsg(0, szBuff256);
        //lstrcpyn(szTempPath, pszISPCode, MAX_PATH);
        //lstrcpyn(&szTempPath[lstrlen(szTempPath)], INF_SUFFIX, MAX_PATH-lstrlen(szTempPath));
        //wsprintf(szBuff256, GetSz(IDS_CANTLOADINETCFG), szTempPath);
        //MessageBox(NULL, szBuff256, GetSz(IDS_TITLE),MB_MYERROR);
        hr = ERROR_FILE_NOT_FOUND;
    }

    *lpData = GetPrivateProfileInt(pszSection,
                                   pszDataName,
                                   iDefaultValue,
                                   szTempPath);
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   IsNT
//
//  Synopsis:   findout If we are running on NT
//
//  Arguements: none
//
//  Return:     TRUE -  Yes
//              FALSE - No
//
//--------------------------------------------------------------------
BOOL IsNT ()
{
    OSVERSIONINFO  OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);

}  //end of IsNT function call

//+-------------------------------------------------------------------
//
//  Function:   IsNT4SP3Lower
//
//  Synopsis:   findout If we are running on NTSP3 or lower
//
//  Arguements: none
//
//  Return:     TRUE -  Yes
//              FALSE - No
//
//--------------------------------------------------------------------

BOOL IsNT4SP3Lower()
{
    return FALSE;
}



// ############################################################################
HRESULT ClearProxySettings()
{
    /*
    HINSTANCE hinst = NULL;
    FARPROC fp;
    HRESULT hr = ERROR_SUCCESS;

    hinst = LoadLibrary(L"INETCFG.DLL");
    if (hinst)
    {
        fp = GetProcAddress(hinst, "InetGetProxy");
        if (!fp)
        {
            hr = GetLastError();
            goto ClearProxySettingsExit;
        }
        //hr = ((PFNINETGETPROXY)fp)(&g_bProxy, NULL, 0,NULL,0);
        if (hr == ERROR_SUCCESS)
            g_bGotProxy = TRUE;
        else
            goto ClearProxySettingsExit;

        if (g_bProxy)
        {
            fp = GetProcAddress(hinst, "InetSetProxy");
            if (!fp)
            {
                hr = GetLastError();
                goto ClearProxySettingsExit;
            }
            ((PFNINETSETPROXY)fp)(FALSE, (LPCSTR)NULL, (LPCSTR)NULL);
        }
    } else {
        hr = GetLastError();
    }

ClearProxySettingsExit:
    if (hinst)
        FreeLibrary(hinst);
    return hr;
    */
    return ERROR_SUCCESS;
}

// ############################################################################
HRESULT RestoreProxySettings()
{
    /*
    HINSTANCE hinst = NULL;
    FARPROC fp;
    HRESULT hr = ERROR_SUCCESS;

    hinst = LoadLibrary(L"INETCFG.DLL");
    if (hinst && g_bGotProxy)
    {
        fp = GetProcAddress(hinst, "InetSetProxy");
        if (!fp)
        {
            hr = GetLastError();
            goto RestoreProxySettingsExit;
        }
        ((PFNINETSETPROXY)fp)(g_bProxy, (LPCSTR)NULL, (LPCSTR)NULL);
    } else {
        hr = GetLastError();
    }

RestoreProxySettingsExit:
    if (hinst)
        FreeLibrary(hinst);
    return hr;
    */
    return ERROR_SUCCESS;
}

// ############################################################################
BOOL FSz2Dw(LPCWSTR pSz, LPDWORD dw)
{
    DWORD val = 0;
    while (*pSz && *pSz != L'.')
    {
        if (*pSz >= L'0' && *pSz <= L'9')
        {
            val *= 10;
            val += *pSz++ - L'0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
LPWSTR GetNextNumericChunk(LPWSTR psz, LPWSTR pszLim, LPWSTR* ppszNext)
{
    LPWSTR pszEnd;

    // init for error case
    *ppszNext = NULL;
    // skip non numerics if any to start of next numeric chunk
    while(*psz<L'0' || *psz>L'9')
    {
        if(psz >= pszLim) return NULL;
        psz++;
    }
    // skip all numerics to end of country code
    for(pszEnd=psz; *pszEnd>=L'0' && *pszEnd<=L'9' && pszEnd<pszLim; pszEnd++)
        ;
    // zap whatever delimiter there was to terminate this chunk
    *pszEnd++ = L'\0';
    // return ptr to next chunk (pszEnd now points to it)
    if(pszEnd<pszLim)
        *ppszNext = pszEnd;
        
    return psz; // return ptr to start of chunk
}

// ############################################################################
// BOOL FSz2DwEx(PCSTR pSz, DWORD *dw)
// Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2DwEx(LPCWSTR pSz, DWORD far *dw)
{
    DWORD val = 0;
    BOOL    bNeg = FALSE;
    while (*pSz)
    {
        if( *pSz == L'-' )
        {
            bNeg = TRUE;
            pSz++;
        }
        else if ((*pSz >= L'0' && *pSz <= L'9'))
        {
            val *= 10;
            val += *pSz++ - L'0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    if(bNeg)
        val = 0 - val;

    *dw = val;
    return (TRUE);
}

// ############################################################################
// BOOL FSz2WEx(PCSTR pSz, WORD *w)
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2WEx(LPCWSTR pSz, WORD far *w)
{
    DWORD dw;
    if (FSz2DwEx(pSz, &dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
// BOOL FSz2W(PCSTR pSz, WORD *w)
BOOL FSz2W(LPCWSTR pSz, WORD far *w)
{
    DWORD dw;
    if (FSz2Dw(pSz, &dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
WORD Sz2W (LPCWSTR szBuf)
{
    DWORD dw;
    if (FSz2Dw(szBuf, &dw))
    {
        return (WORD)dw;
    }
    return 0;
}

// ############################################################################
// BOOL FSz2B(PCSTR pSz, BYTE *pb)
BOOL FSz2BOOL(LPCWSTR pSz, BOOL far *pbool)
{
    if (lstrcmpi(cszFALSE, pSz) == 0)
    {
        *pbool = (BOOL)FALSE;
    }
    else
    {
        *pbool = (BOOL)TRUE;
    }
    return TRUE;
}

// ############################################################################
// BOOL FSz2B(PCSTR pSz, BYTE *pb)
BOOL FSz2B(LPCWSTR pSz, BYTE far *pb)
{
    DWORD dw;
    if (FSz2Dw(pSz, &dw))
    {
        *pb = (BYTE)dw;
        return TRUE;
    }
    return FALSE;
}

BOOL FSz2SPECIAL(LPCWSTR pSz, BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt)
{
    // See if the value is a BOOL (TRUE or FALSE)
    if (lstrcmpi(cszFALSE, pSz) == 0)
    {
        *pbool = FALSE;
        *pbIsSpecial = FALSE;
    }
    else if (lstrcmpi(cszTRUE, pSz) == 0)
    {
        *pbool = (BOOL)TRUE;
        *pbIsSpecial = FALSE;
    }
    else
    {
        // Not a BOOL, so it must be special
        *pbool = (BOOL)FALSE;
        *pbIsSpecial = TRUE;
        *pInt = _wtoi(pSz);
    }
    return TRUE;
}

// ############################################################################
int FIsDigit( int c )
{
    WCHAR szIn[2];
    WORD rwOut[2];
    szIn[0] = (WCHAR)c;
    szIn[1] = L'\0';
    GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, szIn,-1,rwOut);
    return rwOut[0] & C1_DIGIT;

}

// ############################################################################
LPBYTE MyMemSet(LPBYTE dest, int c, size_t count)
{
    LPVOID pv = dest;
    LPVOID pvEnd = (LPVOID)(dest + (WORD)count);
    while (pv < pvEnd)
    {
        *(LPINT)pv = c;
        //((WORD)pv)++;
        pv=((LPINT)pv)+1;
    }
    return dest;
}

// ############################################################################
LPBYTE MyMemCpy(LPBYTE dest, const LPBYTE src, size_t count)
{
    LPBYTE pbDest = (LPBYTE)dest;
    LPBYTE pbSrc = (LPBYTE)src;
    LPBYTE pbEnd = (LPBYTE)((DWORD_PTR)src + (DWORD_PTR)count);
    while (pbSrc < pbEnd)
    {
        *pbDest = *pbSrc;
        pbSrc++;
        pbDest++;
    }
    return dest;
}

// ############################################################################
BOOL ShowControl(HWND hDlg, int idControl, BOOL fShow)
{
    HWND hWnd;

    if (NULL == hDlg)
    {
        ////AssertMsg(0, L"Null Param");
        return FALSE;
    }


    hWnd = GetDlgItem(hDlg, idControl);
    if (hWnd)
    {
        ShowWindow(hWnd, fShow ? SW_SHOW : SW_HIDE);
    }

    return TRUE;
}

BOOL isAlnum(WCHAR c)
{
    if ((c >= L'0' && c <= L'9')  ||
        (c >= L'a' && c <= L'z')  ||
        (c >= L'A' && c <= L'Z') )
        return TRUE;
    return FALSE;
}


// ############################################################################
BOOL FShouldRetry2(HRESULT hrErr)
{
    BOOL bRC;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}



//+----------------------------------------------------------------------------
//
//  Function:   FCampusNetOverride
//
//  Synopsis:   Detect if the dial should be skipped for the campus network
//
//  Arguments:  None
//
//  Returns:    TRUE - overide enabled
//
//  History:    8/15/96 ChrisK  Created
//
//-----------------------------------------------------------------------------
#if defined(PRERELEASE)
BOOL FCampusNetOverride()
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\ISignup\\Debug", &hkey))
        goto FCampusNetOverrideExit;

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey, L"CampusNet", 0,&dwType,
        (LPBYTE)&dwData, &dwSize))
        goto FCampusNetOverrideExit;

    ////AssertMsg(REG_DWORD == dwType, L"Wrong value type for CampusNet.  Must be DWORD.\r\n");
    bRC = (0 != dwData);

    if (bRC)
    {
        if (IDOK != MessageBox(NULL, L"DEBUG ONLY: CampusNet will be used.", L"Testing Override",MB_OKCANCEL))
            bRC = FALSE;
    }
FCampusNetOverrideExit:
    if (hkey)
        RegCloseKey(hkey);

    return bRC;
}
#endif //PRERELEASE



//+----------------------------------------------------------------------------
//  Function    CopyUntil
//
//  Synopsis    Copy from source until destination until running out of source
//              or until the next character of the source is the chend character
//
//  Arguments   dest - buffer to recieve characters
//              src - source buffer
//              lpdwLen - length of dest buffer
//              chend - the terminating character
//
//  Returns     FALSE - ran out of room in dest buffer
//
//  Histroy     10/25/96    ChrisK  Created
//-----------------------------------------------------------------------------
static BOOL CopyUntil(LPWSTR *dest, LPWSTR *src, LPDWORD lpdwLen, WCHAR chend)
{
    while ((L'\0' != **src) && (chend != **src) && (0 != *lpdwLen))
    {
        **dest = **src;
        (*lpdwLen)--;
        (*dest)++;
        (*src)++;
    }
    return (0 != *lpdwLen);
}



//+---------------------------------------------------------------------------
//
//  Function:   GenericMsg
//
//----------------------------------------------------------------------------
void GenericMsg
(
    HWND    hwnd,
    UINT    uId,
    LPCWSTR  lpszArg,
    UINT    uType
)
{
    WCHAR szTemp[MAX_STRING + 1];
    WCHAR szMsg[MAX_STRING + MAX_PATH + 1];
    LPWSTR psz;

    //Assert( lstrlen( GetSz(uId) ) <= MAX_STRING );

    psz = GetSz( (DWORD)uId );
    if (psz) {
        lstrcpy( szTemp, psz );
    }
    else {
        szTemp[0] = '\0';
    }

    if (lpszArg)
    {
        //Assert( lstrlen( lpszArg ) <= MAX_PATH );
        wsprintf(szMsg, szTemp, lpszArg);
    }
    else
    {
        lstrcpy(szMsg, szTemp);
    }
    //MessageBox(hwnd,
    //          szMsg,
    //           GetSz(IDS_TITLE),
    //           uType);
}

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPWSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz = NULL;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(BYTES_REQUIRED_BY_CCH(i));
        break;
      //default:
        ////AssertMsg(0, L"Bogus String Type.");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    //int i;

    CHAR szTmp[512] = "0";

    // load the string from the resources.
    //
    //i = LoadString(_Module.GetModuleInstance(), wId, szTmp, 512);
    //if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp = NULL;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc(BYTES_REQUIRED_BY_CCH(i+1));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (BYTES_REQUIRED_BY_CCH(i+1)));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

HRESULT
GetCommonAppDataDirectory(
    LPWSTR              szDirectory,
    DWORD               cchDirectory
    )
{
    assert(MAX_PATH <= cchDirectory);
    if (MAX_PATH > cchDirectory)
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return SHGetFolderPath(NULL,  // hwndOwner
                           CSIDL_COMMON_APPDATA,
                           NULL,  // hAccessToken
                           SHGFP_TYPE_CURRENT,
                           szDirectory
                           );
}

const LPWSTR            cszPhoneBookPath =
                            L"Microsoft\\Network\\Connections\\Pbk";
const LPWSTR            cszDefPhoneBook = L"rasphone.pbk";
HRESULT
GetDefaultPhoneBook(
    LPWSTR              szPhoneBook,
    DWORD               cchPhoneBook
    )
{
    WCHAR               rgchDirectory[MAX_PATH];
    int                 cch;
    HRESULT             hr = GetCommonAppDataDirectory(rgchDirectory, MAX_PATH);

    if (FAILED(hr))
    {
        return hr;
    }

    if (cchPhoneBook < (DWORD)(lstrlen(rgchDirectory) + lstrlen(cszPhoneBookPath) + lstrlen(cszDefPhoneBook) + 3)
        )
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    cch = wsprintf(szPhoneBook, L"%s\\%s\\%s",
                   rgchDirectory, cszPhoneBookPath, cszDefPhoneBook
                   );
    assert(cch ==  lstrlen(rgchDirectory) + lstrlen(cszPhoneBookPath) +
                   lstrlen(cszDefPhoneBook) + 2
           );

    return hr;
}

BOOL
INetNToW(
    struct in_addr      inaddr,
    LPWSTR              szAddr
    )
{
    USES_CONVERSION;

    LPSTR               sz = inet_ntoa(inaddr);

    if (NULL != sz)
    {
        lstrcpy(szAddr, A2W(sz));
    }

    return (NULL != sz);

}   //  INetNToW


#ifndef REGSTR_VAL_NONETAUTODIAL
#define REGSTR_VAL_NONETAUTODIAL                        L"NoNetAutodial"
#endif

LONG
SetAutodial(
    IN HKEY hUserRoot,              // HKEY_CURRENT_USER or other user hive root
    IN AUTODIAL_TYPE eType,         // Type of autodial for the connectoid
    IN LPCWSTR szConnectoidName,    // NULL terminated string of connectoid name
    IN BOOL bSetICWCompleted        // set ICW completed flag or not
    )
    
/*++

Routine Description:
    
    Set a particular per-user registry settings to default an autodial
    connectoid to the name specified and always dial the autodial connection, and/or
    set the ICW completed flag

Return Value:

    WIN32 Error code, i.e. ERROR_SUCCESS on success, -1 or other non-zero value
    on failure.

Note:

    Despite the name, this function sets ICW Completed flag if bSetICWCompleted
    is true and do not set autodial if szConnectoidName is NULL.

--*/

{
    LONG  ret = -1;
    HKEY  hKey = NULL;
    DWORD dwRet = -1;

    if (bSetICWCompleted)
    {
        if (ERROR_SUCCESS == RegCreateKey( hUserRoot,
                                           ICWSETTINGSPATH,
                                           &hKey) )
        {
            DWORD dwCompleted = 1;
            
            ret = RegSetValueEx( hKey,
                                 ICWCOMPLETEDKEY,
                                 0,
                                 REG_DWORD,
                                 (CONST BYTE*)&dwCompleted,
                                 sizeof(dwCompleted) );
            TRACE1(L"Setting ICW Completed key 0x%08lx", ret);
            
            RegCloseKey(hKey);
        }
    }
    // Set the name if given, else do not change the entry.
    if (szConnectoidName)
    {
        // Set the name of the connectoid for autodial.
        // HKCU\RemoteAccess\InternetProfile
        if (ERROR_SUCCESS == RegCreateKey( hUserRoot,
                                           REGSTR_PATH_REMOTEACCESS,
                                           &hKey) )
        {
            ret = RegSetValueEx( hKey,
                                 REGSTR_VAL_INTERNETPROFILE,
                                 0,
                                 REG_SZ,
                                 (BYTE*)szConnectoidName,
                                 BYTES_REQUIRED_BY_SZ(szConnectoidName) );
            TRACE2(L"Setting IE autodial connectoid to %s 0x%08lx", szConnectoidName, ret);
            
            RegCloseKey(hKey);
        }

        hKey = NULL;
        if (ERROR_SUCCESS == ret)
        {
            // Set setting in the registry that indicates whether autodialing is enabled.
            // HKCU\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
            if (ERROR_SUCCESS == RegCreateKey( hUserRoot,
                                               REGSTR_PATH_INTERNET_SETTINGS,
                                               &hKey) )
            {
                DWORD dwValue;

                dwValue = (eType == AutodialTypeAlways || eType == AutodialTypeNoNet) ? 1 : 0;
                ret = RegSetValueEx( hKey,
                                     REGSTR_VAL_ENABLEAUTODIAL,
                                     0, 
                                     REG_DWORD,
                                     (BYTE*)&dwValue,
                                     sizeof(DWORD) );
                TRACE1(L"Enable/Disable IE Autodial 0x%08lx", ret);

                
                dwValue = (eType == AutodialTypeNoNet) ? 1 : 0;
                ret = RegSetValueEx( hKey,
                                     REGSTR_VAL_NONETAUTODIAL,
                                     0,
                                     REG_DWORD,
                                     (BYTE*)&dwValue,
                                     sizeof(DWORD) );
                TRACE1(L"Setting Autodial mode 0x%08lx", ret);
                
                RegCloseKey(hKey);
            }
        }

    }

    return ret;
}

LONG
SetUserAutodial(
    IN LPWSTR szProfileDir,     // Directory containing a user's ntuser.dat file
    IN AUTODIAL_TYPE eType,     // type of autodial for the connectoid
    IN LPCWSTR szConnectoidName,// NULL terminated string of connectoid name
    IN BOOL bSetICWCompleted    // set the ICW completed key or not
    )

/*++

Routine Description:

    Modified a user profile, specified by the profile directory, to enable
    autodial. SE_BACKUP_NAME and SE_RESTORE_NAME privileges are required to
    load and unload a user hive.

Return Value:

    WIN32 Error code, i.e. ERROR_SUCCESS on success, -1 or other non-zero value
    on failure.

--*/

{
    const WCHAR OOBE_USER_HIVE[] = L"OOBEUSERHIVE";

    HKEY  hUserHive = NULL;
    WCHAR szProfilePath[MAX_PATH+1] = L"";
    LONG  ret = -1;

    lstrcpyn(szProfilePath, szProfileDir, MAX_CHARS_IN_BUFFER(szProfilePath));
    pSetupConcatenatePaths(szProfilePath,
                           L"\\NTUSER.DAT",
                           MAX_CHARS_IN_BUFFER(szProfilePath),
                           NULL);
    ret = RegLoadKey(HKEY_USERS, OOBE_USER_HIVE, szProfilePath);
    if (ret == ERROR_SUCCESS)
    {
        ret = RegOpenKeyEx( HKEY_USERS,
                            OOBE_USER_HIVE,
                            0,
                            KEY_WRITE,                                
                            &hUserHive );
        if (ERROR_SUCCESS == ret)
        {
            ret = SetAutodial(hUserHive, eType, szConnectoidName, bSetICWCompleted);
            RegCloseKey(hUserHive);
            TRACE1(L"Autodial set %s", szProfilePath);
        }
        else
        {
            TRACE2(L"RegOpenKey %s failed %d", szProfilePath, ret);
        }
        RegUnLoadKey(HKEY_USERS, OOBE_USER_HIVE);
    }
    else
    {
        TRACE2(L"RegLoadKey %s failed %d", szProfilePath, ret);
    }
    
    return ret;
}

BOOL
MyGetUserProfileDirectory(
    IN     LPWSTR szUser,           // a user account name
    OUT    LPWSTR szUserProfileDir, // buffer to receive null terminate string
    IN OUT LPDWORD pcchSize         // input the buffer size in TCHAR, including terminating NULL
    )

/*++

Routine Description:

    This function does what the SDK function GetUserProfileDirectory does,
    except that it accepts a user account name instead of handle to a user
    token.

Return Value:

    TRUE  - Success

    FALSE - Failure

--*/

{
    PSID          pSid = NULL;
    DWORD         cbSid = 0;
    LPWSTR        szDomainName = NULL;
    DWORD         cbDomainName = 0;
    SID_NAME_USE  eUse = SidTypeUser;
    BOOL          bRet;
    
    bRet = LookupAccountName(NULL,
                             szUser,
                             NULL,
                             &cbSid,
                             NULL,
                             &cbDomainName,
                             &eUse);

    if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pSid = (PSID) LocalAlloc(LPTR, cbSid);
        szDomainName = (LPWSTR) LocalAlloc(LPTR, cbDomainName * sizeof(TCHAR));
        
        if (pSid && szDomainName)
        {
            bRet = LookupAccountName(NULL,
                                     szUser,
                                     pSid,
                                     &cbSid,
                                     szDomainName,
                                     &cbDomainName,
                                     &eUse);
        }

    }
    
    if (bRet && SidTypeUser == eUse)
    {
        bRet = GetUserProfileDirFromSid(pSid, szUserProfileDir, pcchSize);
        if (!bRet)
        {
            TRACE1(L"GetUserProfileDirFromSid (%d)", GetLastError());
        }
    }
    else
    {
        if (SidTypeUser == eUse)
        {
            TRACE2(L"LookupAccountName %s (%d)", szUser, GetLastError());
        }
    }
    
    if (pSid)
    {
        LocalFree(pSid);
        pSid = NULL;
    }

    if (szDomainName)
    {
        LocalFree(szDomainName);
        szDomainName = NULL;
    }

    return bRet;
}

BOOL EnumBuildInAdministrators(
    OUT LPWSTR* pszAlias // list of name delimited by null, double null-terminated
    )
    
/*++

Routine Description:

    List all the build-in administrator accounts created by Windows Setup.

Return Value:

    TRUE  - Success

    FALSE - Failure

--*/

{
    WCHAR     szReservedAdmins[MAX_PATH * 2]  = L"";
    PWCHAR    p = NULL;
    DWORD     len;
    BOOL      ret = FALSE;
    HINSTANCE hInstance = NULL;

    if (pszAlias != NULL)
    {
        *pszAlias = NULL;

        hInstance = LoadLibraryEx(OOBE_MAIN_DLL, NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (hInstance != NULL)
        {
            
            len = LoadString(hInstance,
                             566, // IDS_ACCTLIST_RESERVEDADMINS in OOBE_MAIN_DLL
                             szReservedAdmins,
                             MAX_CHARS_IN_BUFFER(szReservedAdmins));
            if (len)
            {
                DWORD cbSize;
                
                p = StrChr(szReservedAdmins, L'|');
                while ( p )
                {
                    PWCHAR t = CharNext(p);
                    *p = L'\0';
                    p = StrChr(t, L'|');
                }

                cbSize = sizeof(WCHAR) * (len + 1);
                // Make sure we have enough space for 
                // double NULL terminate the return value
                *pszAlias = (LPWSTR) GlobalAlloc(GPTR, cbSize + sizeof(WCHAR));
                if (*pszAlias)
                {
                    CopyMemory(*pszAlias, szReservedAdmins, cbSize);
                    // double NULL terminate the string
                    (*pszAlias)[cbSize / sizeof(WCHAR)] = L'\0';
                    ret = TRUE;
                }
            }

            FreeLibrary(hInstance);
        }
    }

    return ret;

}


BOOL
SetMultiUserAutodial(
    IN AUTODIAL_TYPE eType,     // type of autodial for the connectoid
    IN LPCWSTR szConnectoidName,// NULL terminated string of connectoid name
    IN BOOL bSetICWCompleted    // set the ICW completed key or not
    )
{
    BOOL             bSucceed = TRUE;
    LONG             lRet = ERROR_SUCCESS;
    WCHAR            szProfileDir[MAX_PATH+1] = L"";
    DWORD            dwSize;
    LPWSTR           szAdmins = NULL;

    // SYSTEM
    lRet = SetAutodial(HKEY_CURRENT_USER, eType, szConnectoidName, bSetICWCompleted);
    if (lRet != ERROR_SUCCESS)
    {
        bSucceed = FALSE;
    }

    pSetupEnablePrivilege(SE_BACKUP_NAME, TRUE);
    pSetupEnablePrivilege(SE_RESTORE_NAME, TRUE);

    // Default User, which will apply to any new user profiles created
    // afterward.
    dwSize = MAX_CHARS_IN_BUFFER(szProfileDir);
    if (GetDefaultUserProfileDirectory(szProfileDir, &dwSize))
    {
        lRet = SetUserAutodial(szProfileDir, eType, szConnectoidName, bSetICWCompleted);
        if (lRet != ERROR_SUCCESS)
        {
            bSucceed = FALSE;
        }
    }

    // Built-in Administrators, e.g. Administrator.
    if (EnumBuildInAdministrators(&szAdmins))
    {
        LPWSTR szAdmin = szAdmins;
        while (*szAdmin)
        {
            // MAX_CHARS_IN_BUFFER excludes the terminating NULL
            dwSize = MAX_CHARS_IN_BUFFER(szProfileDir) + 1;
            if (MyGetUserProfileDirectory(szAdmin, szProfileDir, &dwSize))
            {
                lRet = SetUserAutodial(szProfileDir, eType, szConnectoidName, bSetICWCompleted);
                if (lRet != ERROR_SUCCESS)
                {
                    bSucceed = FALSE;
                }
            }
            szAdmin += (lstrlen(szAdmin) + 1);
        }
        GlobalFree(szAdmins);
    }
    
    return bSucceed;

}



BOOL
SetDefaultConnectoid(
    IN AUTODIAL_TYPE eType,            // type of autodial for the connectoid
    IN LPCWSTR       szConnectoidName  // null terminated autodial connectoid name
    )

/*++

Routine Description:

    Set the default autodial connectoid for SYSTEM, Default User and 
    build-in administrators. Assume that this function is run in System
    context, i.e. it is SYSTEM who runs OOBE.

Return Value:

    TRUE  - Success to set all user accounts

    FALSE - Failure to set any one of the user accounts
    
--*/

{
    BOOL             bSucceed = TRUE;
    LONG             lRet = ERROR_SUCCESS;
    RASAUTODIALENTRY adEntry;


    //
    // IE on WinXP use Ras autodial address, instead of its own registry
    // key for autodial connection name, but it keeps using its own registry
    // key for autodial mode.
    //
    ZeroMemory(&adEntry, sizeof(RASAUTODIALENTRY));
    adEntry.dwSize = sizeof(RASAUTODIALENTRY);
    lstrcpyn(adEntry.szEntry, szConnectoidName, 
             sizeof(adEntry.szEntry)/sizeof(WCHAR)
             );
    lRet = RasSetAutodialAddress(NULL,
                                 NULL,
                                 &adEntry,
                                 sizeof(RASAUTODIALENTRY),
                                 1
                                 );
    TRACE2(L"Setting default autodial connectoid to %s %d\n",
           szConnectoidName, lRet);

    if (lRet != ERROR_SUCCESS)
    {
        bSucceed = FALSE;
        return bSucceed;
    }

    bSucceed = SetMultiUserAutodial(eType, szConnectoidName, FALSE);
    
    return bSucceed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\msobcomm.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOBCOMM.CPP - Implementation of CObCommunicationManager
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
//  Class which will manage all communication functions

#include "msobcomm.h"
#include "dispids.h"
#include "CntPoint.h"       // ConnectionPoint Component
#include <ocidl.h>          //For IConnectionPoint and IEnumConnectionPoints
#include <olectl.h>
#include <shlwapi.h>
#include <util.h>
#include "enumodem.h"
#include "commerr.h"
#include "homenet.h"

extern DWORD
IsMouseOrKeyboardPresent(HWND  HWnd,
                         PBOOL pbKeyboardPresent,
                         PBOOL pbMousePresent);

CObCommunicationManager* gpCommMgr    = NULL;

///////////////////////////////////////////////////////////
//
// Creation function used by CFactory.
//
HRESULT CObCommunicationManager::CreateInstance(IUnknown*  pOuterUnknown,
                                                CUnknown** ppNewComponent)
{
   if (pOuterUnknown != NULL)
   {
      // Don't allow aggregation. Just for the heck of it.
      return CLASS_E_NOAGGREGATION;
   }

   *ppNewComponent = new CObCommunicationManager(pOuterUnknown);
   return S_OK;
}

///////////////////////////////////////////////////////////
//
//  NondelegatingQueryInterface
//
HRESULT __stdcall
CObCommunicationManager::NondelegatingQueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IObCommunicationManager2 || iid == IID_IObCommunicationManager)
    {
        return FinishQI(static_cast<IObCommunicationManager*>(this), ppv);
    }
    else
    {
        return CUnknown::NondelegatingQueryInterface(iid, ppv);
    }
}

///////////////////////////////////////////////////////////
//
//  Constructor
//
CObCommunicationManager::CObCommunicationManager(IUnknown* pOuterUnknown)
: CUnknown(pOuterUnknown)
{
    m_pConnectionPoint  = NULL;
    m_pWebGate          = NULL;
    m_hwndCallBack      = NULL;
    m_pRefDial          = NULL;
    m_InsHandler        = NULL;
    m_pDisp             = NULL;
    m_IcsMgr            = NULL;
    m_bIsIcsUsed        = FALSE;
    ZeroMemory(m_szExternalConnectoid, sizeof(m_szExternalConnectoid));
    m_bFirewall         = FALSE;
    m_bAutodialCleanup  = FALSE;

}

///////////////////////////////////////////////////////////
//
//  Destructor
//
CObCommunicationManager::~CObCommunicationManager()
{
    if (m_pDisp)
        m_pDisp->Release();

    if (m_InsHandler)
        delete m_InsHandler;

    if (m_pRefDial)
        delete m_pRefDial;

    if (m_pWebGate)
        delete m_pWebGate;

    if (m_pConnectionPoint)
        delete m_pConnectionPoint;

    if (m_IcsMgr)
        delete m_IcsMgr;

    OobeAutodialHangup();
}

///////////////////////////////////////////////////////////
//
//  FinalRelease -- Clean up the aggreated objects.
//
void CObCommunicationManager::FinalRelease()
{
    CUnknown::FinalRelease();
}


///////////////////////////////////////////////////////////
//  IObCommunicationManager Implementation
///////////////////////////////////////////////////////////
INT CObCommunicationManager::m_nNumListener = 0;

///////////////////////////////////////////////////////////
// ListenToCommunicationEvents
HRESULT CObCommunicationManager::ListenToCommunicationEvents(IUnknown* pUnk)
{
    DObCommunicationEvents* pCommEvent = NULL;
    m_pDisp = NULL;

    CObCommunicationManager::m_nNumListener ++;

    //first things first
    if (!pUnk)
        return E_FAIL;

    //So somebody want to register to listen to our ObWebBrowser events
    //Ok, let's get sneaky and reverse QI them to see if they even say they
    //support the right interfaces
    //if (FAILED(pUnk->QueryInterface(DIID_DObCommunicationEvents, (LPVOID*)&pCommEvent)) || !pCommEvent)
    //    return E_UNEXPECTED;

    // ListenToCommunicationEvents treats CConnectionPoint as a C++ object and not like a COM object.
    // Everyone else deals with CConnectionPoint through COM interfaces.
    if (!m_pConnectionPoint)
        m_pConnectionPoint = new CConnectionPoint(this, &IID_IDispatch) ;

    if (FAILED(pUnk->QueryInterface(IID_IDispatch, (LPVOID*)&m_pDisp)) || !m_pDisp)
        return E_UNEXPECTED;

    gpCommMgr = this;
    m_pRefDial = new CRefDial();
    m_pWebGate = new CWebGate();

    //Ok, everything looks OK, try to setup a connection point.
    // Setup to get WebBrowserEvents
    return ConnectToConnectionPoint(pUnk,
                                    DIID_DObCommunicationEvents,
                                    TRUE,
                                    (IObCommunicationManager*)this,
                                    &m_dwcpCookie,
                                    NULL);
}

HRESULT CObCommunicationManager::ConnectToConnectionPoint(  IUnknown*          punkThis,
                                                            REFIID             riidEvent,
                                                            BOOL               fConnect,
                                                            IUnknown*          punkTarget,
                                                            DWORD*             pdwCookie,
                                                            IConnectionPoint** ppcpOut)
{
    HRESULT hr = E_FAIL;
    IConnectionPointContainer* pcpContainer = NULL;

    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;


    IConnectionPoint *pcp;
    if(SUCCEEDED(hr = FindConnectionPoint(riidEvent, &pcp)))
    {
        if(fConnect)
        {
            // Add us to the list of people interested...
            hr = pcp->Advise(punkThis, pdwCookie);
            if (FAILED(hr))
                *pdwCookie = 0;
        }
        else
        {
            // Remove us from the list of people interested...
            hr = pcp->Unadvise(*pdwCookie);
            *pdwCookie = 0;
        }

        if (ppcpOut && SUCCEEDED(hr))
            *ppcpOut = pcp;
        else
            pcp->Release();
            pcp = NULL;
    }

    return hr;
}


///////////////////////////////////////////////////////////
//
//                      IConnectionPointContainer
//
///////////////////////////////////////////////////////////
//
// EnumConnectionPoints
//
HRESULT CObCommunicationManager::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    // Construct the enumerator object.
    //IEnumConnectionPoints* pEnum = new CEnumConnectionPoints(m_pConnectionPoint) ;

    // The contructor AddRefs for us.
    //*ppEnum = pEnum ;
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// FindConnectionPoint
//
HRESULT CObCommunicationManager::FindConnectionPoint(REFIID riid, IConnectionPoint **ppCP)
{
    // Model only supports a single connection point.
    if (riid != DIID_DObCommunicationEvents)
    {
        *ppCP = NULL ;
        return  CONNECT_E_NOCONNECTION ;
    }

    if (m_pConnectionPoint == NULL)
    {
        return E_FAIL ;
    }

    // Get the interface point to the connection point object.
    IConnectionPoint* pIConnectionPoint = m_pConnectionPoint ;

    // AddRef the interface.
    pIConnectionPoint->AddRef() ;

    // Return the interface to the client.
    *ppCP = pIConnectionPoint ;

    return S_OK ;
}


///////////////////////////////////////////////////////////
//  DWebBrowserEvents2 / IDispatch implementation
///////////////////////////////////////////////////////////

STDMETHODIMP CObCommunicationManager::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CObCommunicationManager::GetTypeInfo(UINT, LCID, ITypeInfo** )
{
    return E_NOTIMPL;
}

// COleSite::GetIDsOfNames
STDMETHODIMP CObCommunicationManager::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{
    return ResultFromScode(DISP_E_UNKNOWNNAME);
}

/////////////////////////////////////////////////////////////
// COleSite::Invoke
HRESULT CObCommunicationManager::Invoke
(
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr
)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
   /*
    switch(dispidMember)
    {
        default:
           break;
    }
    */
    return hr;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//////  Methods
//////
//////
//////

///////////////////////////////////////////////////////////
//
//                      IMsobComm Interface
//
///////////////////////////////////////////////////////////
//
//  CheckDialReady
//
HRESULT CObCommunicationManager::CheckDialReady(DWORD *pdwRetVal)
{
    HINSTANCE hinst = NULL;
    FARPROC fp;
    HRESULT hr = E_FAIL;

    if (NULL == pdwRetVal)
        return ERR_COMM_UNKNOWN;

    *pdwRetVal = ERR_COMM_OOBE_COMP_MISSING;

    if (IsNT())
    {
        hinst = LoadLibrary(L"ICFGNT5.DLL");
    }
    else
    {
        hinst = LoadLibrary(L"ICFG95.DLL");
    }


    if (hinst)
    {
        fp = GetProcAddress(hinst, "IcfgNeedInetComponents");
        if (fp)
        {

            DWORD dwfInstallOptions = ICFG_INSTALLTCP;
            dwfInstallOptions |= ICFG_INSTALLRAS;
            dwfInstallOptions |= ICFG_INSTALLDIALUP;
            //dwfInstallOptions |= ICFG_INSTALLMAIL;
            BOOL  fNeedSysComponents = FALSE;

            DWORD dwRet = ((ICFGNEEDSYSCOMPONENTS)fp)(dwfInstallOptions, &fNeedSysComponents);

            if (ERROR_SUCCESS == dwRet)
            {
                // We don't have RAS or TCPIP
                if (fNeedSysComponents)
                {
                    *pdwRetVal = ERR_COMM_RAS_TCP_NOTINSTALL;
                    TRACE(L"RAS or TCPIP not install");
                }
                else
                {
                    // check modem
                    // The does does not exist, we failed.
                    m_EnumModem.ReInit();
                    if (NULL != m_EnumModem.GetDeviceNameFromType(RASDT_Modem))
                    {
                        if (NULL == m_EnumModem.GetDeviceNameFromType(RASDT_Isdn))
                        {
                            *pdwRetVal = ERR_COMM_NO_ERROR;
                        }
                        else
                        {
                            *pdwRetVal = ERR_COMM_PHONE_AND_ISDN;
                        }
                    }
                    else if (NULL != m_EnumModem.GetDeviceNameFromType(RASDT_Isdn))
                    {
                        *pdwRetVal = ERR_COMM_ISDN;
                    }
                    else
                    {
                        *pdwRetVal = ERR_COMM_NOMODEM;
                    }
                }

            }
            hr = S_OK;
        }
        FreeLibrary(hinst);
    }

    return hr ;
}


//////////////////////////////////////////////////////////////////////////////
//
//  GetConnectionCapabilities
//
//  Retrieves LAN connection capabilities.
//
//  For Whistler we rely on the modem path through EnumModem and RAS to
//  determine whether a modem is installed.
//
//
//  parameters:
//      _parm_          _description_
//
//  returns:
//      _description_
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::GetConnectionCapabilities(
    DWORD*              pdwConnectionCapabilities
    )
{
    TRACE(L"CObCommunicationManager::GetConnectionCapabilities\n");
    return m_ConnectionManager.GetCapabilities(pdwConnectionCapabilities);

}   //  CObCommunicationManager::GetConnectionCapabilities


//////////////////////////////////////////////////////////////////////////////
//
//  GetPreferredConnection
//
//  _abstract_
//
//  parameters:
//      _parm_          _description_
//
//  returns:
//      _description_
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::GetPreferredConnection(
    DWORD*              pdwPreferredConnection
    )
{
    return m_ConnectionManager.GetPreferredConnection(pdwPreferredConnection);

}   //  CObCommunicationManager::GetPreferredConnection


//////////////////////////////////////////////////////////////////////////////
//
//  SetPreferredConnection
//
//  _abstract_
//
//  parameters:
//      _parm_          _description_
//
//  returns:
//      _description_
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::SetPreferredConnection(
    const DWORD         dwPreferredConnection,
    BOOL*               pfSupportedType
    )
{
    return  m_ConnectionManager.SetPreferredConnection(dwPreferredConnection,
                                                       pfSupportedType
                                                       );

}   //  CObCommunicationManager::SetPreferredConnection

//////////////////////////////////////////////////////////////////////////////
//
//  ConnectedToInternet
//
//  _abstract_
//
//  parameters:
//      _parm_          _description_
//
//  returns:
//      _description_
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::ConnectedToInternet(
    BOOL*               pfConnected
    )
{
    return  m_ConnectionManager.ConnectedToInternet(pfConnected); 

}   //  CObCommunicationManager::ConnectedToInternet

//////////////////////////////////////////////////////////////////////////////
//
//  ConnectedToInternetEx
//
//  _abstract_
//
//  parameters:
//      _parm_          _description_
//
//  returns:
//      _description_
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::ConnectedToInternetEx(
    BOOL*               pfConnected
    )
{
    return  m_ConnectionManager.ConnectedToInternetEx(pfConnected); 

}   //  CObCommunicationManager::ConnectedToInternetEx

//////////////////////////////////////////////////////////////////////////////
//
//  AsyncConnectedToInternetEx
//
//  _abstract_
//
//  parameters:
//      _parm_          _description_
//
//  returns:
//      _description_
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::AsyncConnectedToInternetEx(
    const HWND          hwnd
    )
{
    return  m_ConnectionManager.AsyncConnectedToInternetEx(hwnd); 

}   //  CObCommunicationManager::AsyncConnectedToInternetEx

///////////////////////////////////////////////////////////
//
// SetPreferredConnectionTcpipProperties
//
STDMETHODIMP CObCommunicationManager::SetPreferredConnectionTcpipProperties(
    BOOL fAutoIPAddress,
    DWORD StaticIp_A,
    DWORD StaticIp_B,
    DWORD StaticIp_C,
    DWORD StaticIp_D,
    DWORD SubnetMask_A,
    DWORD SubnetMask_B,
    DWORD SubnetMask_C,
    DWORD SubnetMask_D,
    DWORD DefGateway_A,
    DWORD DefGateway_B,
    DWORD DefGateway_C,
    DWORD DefGateway_D,
    BOOL fAutoDNS,
    DWORD DnsPref_A,
    DWORD DnsPref_B,
    DWORD DnsPref_C,
    DWORD DnsPref_D,
    DWORD DnsAlt_A,
    DWORD DnsAlt_B,
    DWORD DnsAlt_C,
    DWORD DnsAlt_D,
    BOOL fFirewallRequired
    )
{
    HRESULT             hr;
    hr = m_ConnectionManager.SetPreferredConnectionTcpipProperties(
                                                            fAutoIPAddress, 
                                                            StaticIp_A, 
                                                            StaticIp_B, 
                                                            StaticIp_C, 
                                                            StaticIp_D, 
                                                            SubnetMask_A,
                                                            SubnetMask_B,
                                                            SubnetMask_C,
                                                            SubnetMask_D,
                                                            DefGateway_A,
                                                            DefGateway_B,
                                                            DefGateway_C,
                                                            DefGateway_D,
                                                            fAutoDNS, 
                                                            DnsPref_A, 
                                                            DnsPref_B, 
                                                            DnsPref_C, 
                                                            DnsPref_D, 
                                                            DnsAlt_A, 
                                                            DnsAlt_B, 
                                                            DnsAlt_C, 
                                                            DnsAlt_D
                                                            );    
    if (SUCCEEDED(hr) && fFirewallRequired)
    {
       // Save the connectoid name so it can be firewalled by the HomeNet
       // Wizard.
       m_ConnectionManager.GetPreferredConnectionName(
                                m_szExternalConnectoid,
                                sizeof(m_szExternalConnectoid)/sizeof(WCHAR)
                                ); 
    }

    return hr;
                                                            
}   //  CObCommunicationManager::SetPreferredConnectionTcpipProperties

///////////////////////////////////////////////////////////
//
// FirewallPreferredConnection
//
HRESULT CObCommunicationManager::FirewallPreferredConnection(BOOL bFirewall)
{
    m_bFirewall = bFirewall;
    if (bFirewall)
    {
        // Save the connectoid name so it can be firewalled by the HomeNet
        // Wizard.
        return m_ConnectionManager.GetPreferredConnectionName(
                                m_szExternalConnectoid,
                                sizeof(m_szExternalConnectoid)/sizeof(WCHAR)
                                );
    }
    else
    {
        m_szExternalConnectoid[0] = TEXT('\0');
        return S_OK;
    }
    
}   //  CObCommunicationManager::FirewallPreferredConnection

///////////////////////////////////////////////////////////
//
//  SetupForDialing
//
HRESULT CObCommunicationManager::SetupForDialing(UINT nType, BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, DWORD dwAppMode, DWORD dwMigISPIdx)
{
    HRESULT hr = E_FAIL;
    
    if (m_pRefDial)
    {
        BSTR bstrDeviceName = GetPreferredModem();

        if (bstrDeviceName)
        {
            hr = m_pRefDial->SetupForDialing(
                nType,
                bstrISPFile,
                dwCountry,
                bstrAreaCode,
                dwFlag,
                dwAppMode,
                dwMigISPIdx,
                bstrDeviceName);
            
            SysFreeString(bstrDeviceName);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////
//
//  DoConnect
//
HRESULT CObCommunicationManager::DoConnect(BOOL *pbRetVal)
{

    if (m_pRefDial)
    {
        return m_pRefDial->DoConnect(pbRetVal);
    }

    return E_FAIL ;
}


///////////////////////////////////////////////////////////
//
//  SetRASCallbackHwnd
//
HRESULT CObCommunicationManager::SetRASCallbackHwnd(HWND hwndCallback)
{
    m_hwndCallBack = hwndCallback;

    return S_OK;
}

///////////////////////////////////////////////////////////
//
// DoHangup
//
HRESULT CObCommunicationManager::DoHangup()
{
    if (m_pRefDial)
    {
        m_pRefDial->m_bUserInitiateHangup = TRUE;
        m_pRefDial->DoHangup();
    }

    return S_OK ;
}


///////////////////////////////////////////////////////////
//
// GetDialPhoneNumber
//
HRESULT CObCommunicationManager::GetDialPhoneNumber(BSTR *pVal)
{
    if (m_pRefDial)
    {
        m_pRefDial->GetDialPhoneNumber(pVal);
    }

    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetPhoneBookNumber
//
HRESULT CObCommunicationManager::GetPhoneBookNumber(BSTR *pVal)
{
    if (m_pRefDial)
    {
        m_pRefDial->GetPhoneBookNumber(pVal);
    }

    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// PutDialPhoneNumber
//
HRESULT CObCommunicationManager::PutDialPhoneNumber(BSTR newVal)
{
    if (m_pRefDial)
    {
        m_pRefDial->PutDialPhoneNumber(newVal);
    }

    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// SetDialAlternative
//
HRESULT CObCommunicationManager::SetDialAlternative(BOOL bVal)
{
    if (m_pRefDial)
    {
        m_pRefDial->SetDialAlternative(bVal);
    }

    return S_OK;
}
///////////////////////////////////////////////////////////
//
// GetDialErrorMsg
//
HRESULT CObCommunicationManager::GetDialErrorMsg(BSTR *pVal)
{
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetSupportNumber
//
HRESULT CObCommunicationManager::GetSupportNumber(BSTR *pVal)
{
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// RemoveConnectoid
//
HRESULT CObCommunicationManager::RemoveConnectoid(BOOL *pbRetVal)
{
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetSignupURL
//
HRESULT CObCommunicationManager::GetSignupURL(BSTR *pVal)
{
    if (m_pRefDial)
    {
        m_pRefDial->get_SignupURL(pVal);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetReconnectURL
//
HRESULT CObCommunicationManager::GetReconnectURL(BSTR *pVal)
{
    if (m_pRefDial)
    {
        m_pRefDial->get_ReconnectURL(pVal);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetConnectionType
//
HRESULT CObCommunicationManager::GetConnectionType(DWORD *pdwVal)
{
    if (m_pRefDial)
    {
        m_pRefDial->GetConnectionType(pdwVal);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// FetchPage
//
HRESULT CObCommunicationManager::FetchPage(BSTR bstrURL, BSTR* pbstrLocalFile)
{
    BOOL bRetVal = 0;
    if (m_pWebGate && pbstrLocalFile)
    {
        BSTR bstrFileName = NULL;
        m_pWebGate->put_Path(bstrURL);
        m_pWebGate->FetchPage(1, &bRetVal);
        m_pWebGate->get_DownloadFname(&bstrFileName);
        *pbstrLocalFile = SysAllocString(bstrFileName);
        TRACE2(L"CObCommunicationManager::FetchPage(%s, %s)\n",
               bstrURL ? bstrURL : NULL, 
               bstrFileName ? bstrFileName : NULL
               );
    }
    if (bRetVal)
        return S_OK ;
    return E_FAIL;
}

///////////////////////////////////////////////////////////
//
// GetFile
//
HRESULT CObCommunicationManager::GetFile(BSTR bstrURL, BSTR bstrFileFullName)
{
    if (m_pWebGate && bstrURL)
    {
        // Check for HTTP prefix
        if (PathIsURL(bstrURL))
        {

            BOOL bRetVal = FALSE;
            m_pWebGate->put_Path(bstrURL);
            m_pWebGate->FetchPage(1, &bRetVal);
            if (bRetVal && bstrFileFullName)
            {
                BSTR bstrTempFile = NULL;
                m_pWebGate->get_DownloadFname(&bstrTempFile);
                // Make sure we have a valid file name
                if (bstrTempFile)
                {
                    if (CopyFile(bstrTempFile, bstrFileFullName, FALSE))
                    {
                        // Delete the temp file
                        DeleteFile(bstrTempFile);
                        return S_OK;
                    }
                }
            }
        }

    }
    return E_FAIL ;
}

///////////////////////////////////////////////////////////
//
//  CheckPhoneBook
//
HRESULT CObCommunicationManager::CheckPhoneBook(BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, BOOL *pbRetVal)
{
    if (m_pRefDial)
    {
        return m_pRefDial->CheckPhoneBook(bstrISPFile, dwCountry, bstrAreaCode, dwFlag, pbRetVal);
    }
    return E_FAIL ;
}

///////////////////////////////////////////////////////////
//
//  RestoreConnectoidInfo
//
HRESULT CObCommunicationManager::RestoreConnectoidInfo()
{
    if (!m_InsHandler)
        m_InsHandler = new CINSHandler;

    if (m_InsHandler)
    {
        return m_InsHandler->RestoreConnectoidInfo();
    }
    return E_FAIL ;
}

///////////////////////////////////////////////////////////
//
//  SetPreloginMode
//
HRESULT CObCommunicationManager::SetPreloginMode(BOOL bVal)
{
    m_pbPreLogin = bVal;
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// DownloadFileBuffer
//
HRESULT CObCommunicationManager::DownloadFileBuffer(BSTR *pVal)
{
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// ProcessINS
//
HRESULT CObCommunicationManager::ProcessINS(BSTR bstrINSFilePath, BOOL *pbRetVal)
{

    HRESULT hr = E_FAIL;
    if (!m_InsHandler)
    {
        m_InsHandler = new CINSHandler;
        if (m_InsHandler == NULL)
        {
            return hr;
        }
    }

    if (NULL == bstrINSFilePath)
    {
        *pbRetVal = m_InsHandler->ProcessOEMBrandINS(NULL,
                                                     m_szExternalConnectoid
                                                     );
        hr = S_OK;

    }
    else
    {
        // Download the ins file, then merge it with oembrnd.ins
        // Check for HTTP prefix
        if (PathIsURL(bstrINSFilePath))
        {
            if (m_pWebGate)
            {
                BOOL bRetVal;
                m_pWebGate->put_Path(bstrINSFilePath);
                m_pWebGate->FetchPage(1, &bRetVal);
                if (bRetVal)
                {
                    BSTR bstrINSTempFile = NULL;
                    if (S_OK == m_pWebGate->get_DownloadFname(&bstrINSTempFile))
                    {
                        if (bstrINSTempFile)
                        {
                            *pbRetVal = m_InsHandler->ProcessOEMBrandINS(
                                                    bstrINSTempFile,
                                                    m_szExternalConnectoid
                                                    );
                            hr = S_OK;
                        }
                        DeleteFile(bstrINSTempFile);
                    }
                }
            }
        }
        else
        {
            *pbRetVal = m_InsHandler->ProcessOEMBrandINS(
                                                    bstrINSFilePath,
                                                    m_szExternalConnectoid
                                                    );
            hr = S_OK;
        }
    }
    HKEY  hKey;
    if ((S_OK == hr) && *pbRetVal)
    {
        if((ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          REG_KEY_OOBE_TEMP,
                                          0,
                                          KEY_WRITE,
                                          &hKey)) && hKey)
        {

            hr = RegSetValueEx(hKey,
                          REG_VAL_ISPSIGNUP,
                          0,
                          REG_DWORD,
                          (BYTE*)pbRetVal,
                          sizeof(*pbRetVal));
            RegCloseKey(hKey);
        }
        else
        {
            DWORD dwDisposition  = 0;
            if ( ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                                   REG_KEY_OOBE_TEMP,
                                                   0,
                                                   NULL,
                                                   REG_OPTION_NON_VOLATILE,
                                                   KEY_ALL_ACCESS,
                                                   NULL,
                                                   &hKey,
                                                   &dwDisposition))
            {
                hr = RegSetValueEx(hKey,
                              REG_VAL_ISPSIGNUP,
                              0,
                              REG_DWORD,
                              (BYTE*)pbRetVal,
                              sizeof(*pbRetVal));
                RegCloseKey(hKey);
            }
        }
    }
    return hr ;
}

///////////////////////////////////////////////////////////
//
// CheckKbdMouse
//
HRESULT CObCommunicationManager::CheckKbdMouse(DWORD *pdwRetVal)
{
    BOOL bkeyboard, bmouse;

    *pdwRetVal = 0;

    // summary: *pdwRetVal returns
    // 0 = Success (keyboard and mouse present
    // 1 = Keyboard is missing
    // 2 = Mouse is missing
    // 3 = Keyboard and mouse are missing

    IsMouseOrKeyboardPresent(m_hwndCallBack,
                         &bkeyboard,
                         &bmouse);
    // If there is a keyboard, set the first bit to 1
    if (bkeyboard)
        *pdwRetVal |= 0x01;

    // If there is a mouse, set the first bit to 1
    if (bmouse)
        *pdwRetVal |= 0x02;

    return S_OK;
}

///////////////////////////////////////////////////////////
//
// Fire_Dialing
//
HRESULT CObCommunicationManager::Fire_Dialing(DWORD dwDialStatus)
{
    VARIANTARG varg;
    VariantInit(&varg);
    varg.vt  = VT_I4;
    varg.lVal= dwDialStatus;
    DISPPARAMS disp = { &varg, NULL, 1, 0 };
    m_pDisp->Invoke(DISPID_DIALING, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Fire_Connecting
//
HRESULT CObCommunicationManager::Fire_Connecting()
{
    VARIANTARG varg;
    VariantInit(&varg);
    varg.vt  = VT_I4;
    varg.lVal= 0;
    DISPPARAMS disp = { &varg, NULL, 1, 0 };
    m_pDisp->Invoke(DISPID_CONNECTING, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Fire_DialError
//
HRESULT CObCommunicationManager::Fire_DialError(DWORD dwErrorCode)
{
    VARIANTARG varg;
    VariantInit(&varg);
    varg.vt  = VT_I4;
    varg.lVal= dwErrorCode;
    DISPPARAMS disp = { &varg, NULL, 1, 0 };
    m_pDisp->Invoke(DISPID_DIALINGERROR, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Fire_ConnectionComplete
//
HRESULT CObCommunicationManager::Fire_ConnectionComplete()
{
    VARIANTARG varg;
    VariantInit(&varg);
    varg.vt  = VT_I4;
    varg.lVal= 0;
    DISPPARAMS disp = { &varg, NULL, 1, 0 };
    m_pDisp->Invoke(DISPIP_CONNECTIONCOMPLETE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Fire_DownloadComplete
//
HRESULT CObCommunicationManager::Fire_DownloadComplete(BSTR pVal)
{
    VARIANTARG varg;
    VariantInit(&varg);
    varg.vt = VT_BSTR;
    varg.bstrVal= pVal;
    DISPPARAMS disp = { &varg, NULL, 1, 0 };
    m_pDisp->Invoke(DISPIP_DOWNLOADCOMPLETE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// OnDownloadEvent
//
HRESULT CObCommunicationManager::OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL* bHandled)
{
    return m_pRefDial->OnDownloadEvent(uMsg, wParam, lParam, bHandled);
}

///////////////////////////////////////////////////////////
//
// GetISPList
//
HRESULT CObCommunicationManager::GetISPList(BSTR* pVal)
{
    return m_pRefDial->GetISPList(pVal);
}

///////////////////////////////////////////////////////////
//
// GetISPList
//
HRESULT CObCommunicationManager::Set_SelectISP(UINT nVal)
{
    return m_pRefDial->Set_SelectISP(nVal);
}

///////////////////////////////////////////////////////////
//
// Set_ConnectionMode
//
HRESULT CObCommunicationManager::Set_ConnectionMode(UINT nVal)
{
    return m_pRefDial->Set_ConnectionMode(nVal);
}

///////////////////////////////////////////////////////////
//
// Get_ConnectionMode
//
HRESULT CObCommunicationManager::Get_ConnectionMode(UINT* pnVal)
{
    return m_pRefDial->Get_ConnectionMode(pnVal);
}


///////////////////////////////////////////////////////////
//
// DownloadReferralOffer
//
HRESULT CObCommunicationManager::DownloadReferralOffer(BOOL *pbVal)
{
    if (pbVal)
    {
        // Start the download now!!!
        m_pRefDial->DoOfferDownload(pbVal);
        if (!*pbVal)
            m_pRefDial->DoHangup();
        return S_OK;
    }
    return E_FAIL;

}

///////////////////////////////////////////////////////////
//
// DownloadISPOffer
//
HRESULT CObCommunicationManager::DownloadISPOffer(BOOL *pbVal, BSTR *pVal)
{
    if (pbVal && pVal)
    {
        // Start the download now!!!
        m_pRefDial->DownloadISPOffer(pbVal, pVal);
        if (!*pbVal)
            m_pRefDial->DoHangup();
        return S_OK;
    }
    return E_FAIL;
}

///////////////////////////////////////////////////////////
//
// Get_ISPName
//
HRESULT CObCommunicationManager::Get_ISPName(BSTR *pVal)
{
    if (pVal)
    {
        // Start the download now!!!
        return m_pRefDial->get_ISPName(pVal);
    }
    return E_FAIL;
}


///////////////////////////////////////////////////////////
//
// RemoveDownloadDir
//
HRESULT CObCommunicationManager::RemoveDownloadDir()
{
    return m_pRefDial->RemoveDownloadDir();
}

///////////////////////////////////////////////////////////
//
// PostRegData
//
HRESULT CObCommunicationManager::PostRegData(DWORD dwSrvType, BSTR bstrRegUrl)
{
    return m_pRefDial->PostRegData(dwSrvType, bstrRegUrl);
}

///////////////////////////////////////////////////////////
//
// AllowSingleCall
//
HRESULT CObCommunicationManager::CheckStayConnected(BSTR bstrISPFile, BOOL *pbVal)
{
    return m_pRefDial->CheckStayConnected(bstrISPFile, pbVal);
}

///////////////////////////////////////////////////////////
//
//  Connect
//
HRESULT CObCommunicationManager::Connect(UINT nType, BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, DWORD dwAppMode)
{
    if (m_pRefDial)
    {
        return m_pRefDial->Connect(nType, bstrISPFile, dwCountry, bstrAreaCode, dwFlag, dwAppMode);
    }
    return E_FAIL ;
}


///////////////////////////////////////////////////////////
//
// CheckStayConnected
//
HRESULT CObCommunicationManager::CheckOnlineStatus(BOOL *pbVal)
{
    if (pbVal)
    {
        BOOL    bIcs = FALSE;
        BOOL    bModem = FALSE;
        IsIcsAvailable (&bIcs); // we don't care about the return value here
        m_pRefDial->CheckOnlineStatus(&bModem);
        *pbVal = (bIcs || bModem); // we are online if we have ICS  or if the modem is connected.
        return S_OK;
    }
    return E_FAIL;

}
HRESULT CObCommunicationManager::CreateIcsBot(DWORD *pdwRetVal)
{
    if (!m_IcsMgr) {
        if (!(m_IcsMgr  = new CIcsMgr())) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (!pdwRetVal) {
        return ERROR_INVALID_PARAMETER;
    }
    *pdwRetVal = m_IcsMgr->CreateIcsDialMgr();
    return ERROR_SUCCESS;
}
HRESULT CObCommunicationManager::IsIcsAvailable(BOOL *bRetVal)
{
    if (!bRetVal) {
        return ERROR_INVALID_PARAMETER;
    }
    if (!m_IcsMgr) {
        *bRetVal = FALSE;

    } else {
        *bRetVal = m_IcsMgr->IsIcsAvailable();
    }
    return S_OK;
}

HRESULT CObCommunicationManager::IsCallbackUsed(BOOL *bRetVal)
{
    if (!bRetVal) {
        return E_FAIL;
    }
    if (!m_IcsMgr) {
        *bRetVal = FALSE;

    } else {
        *bRetVal = m_IcsMgr->IsCallbackUsed();
    }
    return S_OK;
}

HRESULT CObCommunicationManager::NotifyIcsMgr(UINT msg, WPARAM wParam, LPARAM lParam)
{
    if ( !m_IcsMgr )
        return E_FAIL;
    else
        m_IcsMgr->NotifyIcsMgr(msg, wParam, lParam);
    return S_OK;
}

HRESULT CObCommunicationManager::NotifyIcsUsage(BOOL bParam)
{
    m_bIsIcsUsed = bParam;
    return S_OK;
}

HRESULT CObCommunicationManager::TriggerIcsCallback(BOOL bParam)
{
    if (!m_IcsMgr)
    {
        return E_FAIL;
    }
    else
    {
        // The Dial Manager is initialized only once, even if
        // TriggerIcsCallback is called several times.
        // m_IcsMgr->CreateIcsDialMgr();
        m_IcsMgr->TriggerIcsCallback(bParam);
        return S_OK;
    }
}

HRESULT CObCommunicationManager::IsIcsHostReachable(BOOL *bRetVal)
{
    if (!bRetVal) {
        return E_FAIL;
    }
    if (!m_IcsMgr) {
        *bRetVal = FALSE;

    } else {
        *bRetVal = m_IcsMgr->IsIcsHostReachable();
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
//
// CreateModemConnectoid
//
STDMETHODIMP CObCommunicationManager::CreateModemConnectoid(
    BSTR bstrPhoneBook,
    BSTR bstrConnectionName,
    DWORD dwCountryID,
    DWORD dwCountryCode,
    BSTR bstrAreaCode,
    BSTR bstrPhoneNumber,
    BOOL fAutoIPAddress,
    DWORD ipaddr_A,
    DWORD ipaddr_B,
    DWORD ipaddr_C,
    DWORD ipaddr_D,
    BOOL fAutoDNS,
    DWORD ipaddrDns_A,
    DWORD ipaddrDns_B,
    DWORD ipaddrDns_C,
    DWORD ipaddrDns_D,
    DWORD ipaddrDnsAlt_A,
    DWORD ipaddrDnsAlt_B,
    DWORD ipaddrDnsAlt_C,
    DWORD ipaddrDnsAlt_D,
    BSTR bstrUserName,
    BSTR bstrPassword)
{
    DWORD dwRet = ERROR_SUCCESS;

    dwRet = m_EnumModem.ReInit();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    LPWSTR szDeviceName = m_EnumModem.GetDeviceNameFromType(RASDT_Modem);
    if (NULL == szDeviceName)
    {
        return ERROR_DEVICE_DOES_NOT_EXIST;
    }

    BSTR bstrDeviceName = SysAllocString(szDeviceName);
    BSTR bstrDeviceType = SysAllocString(RASDT_Modem);
    if (NULL == bstrDeviceName || NULL == bstrDeviceType)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
    else 
    {

        DWORD dwEntryOptions = RASEO_UseCountryAndAreaCodes
                             | RASEO_IpHeaderCompression
                             | RASEO_RemoteDefaultGateway
                             | RASEO_SwCompression
                             | RASEO_ShowDialingProgress
                             | RASEO_ModemLights;

        dwRet = CreateConnectoid(bstrPhoneBook,
                                bstrConnectionName,
                                dwCountryID,
                                dwCountryCode,
                                bstrAreaCode,
                                bstrPhoneNumber,
                                fAutoIPAddress,
                                ipaddr_A,
                                ipaddr_B,
                                ipaddr_C,
                                ipaddr_D,
                                fAutoDNS,
                                ipaddrDns_A,
                                ipaddrDns_B,
                                ipaddrDns_C,
                                ipaddrDns_D,
                                ipaddrDnsAlt_A,
                                ipaddrDnsAlt_B,
                                ipaddrDnsAlt_C,
                                ipaddrDnsAlt_D,
                                bstrUserName,
                                bstrPassword,
                                bstrDeviceName,
                                bstrDeviceType,
                                dwEntryOptions,
                                RASET_Phone
                                );
    }
    
    if (bstrDeviceName) SysFreeString(bstrDeviceName);
    if (bstrDeviceType) SysFreeString(bstrDeviceType);

    // BUGBUG: Mixing HRESULT and WIN32 error code
    return dwRet;

}

///////////////////////////////////////////////////////////
//
// CreatePppoeConnectoid
//
STDMETHODIMP CObCommunicationManager::CreatePppoeConnectoid(
    BSTR bstrPhoneBook,
    BSTR bstrConnectionName,
    BSTR bstrBroadbandService,
    BOOL fAutoIPAddress,
    DWORD ipaddr_A,
    DWORD ipaddr_B,
    DWORD ipaddr_C,
    DWORD ipaddr_D,
    BOOL fAutoDNS,
    DWORD ipaddrDns_A,
    DWORD ipaddrDns_B,
    DWORD ipaddrDns_C,
    DWORD ipaddrDns_D,
    DWORD ipaddrDnsAlt_A,
    DWORD ipaddrDnsAlt_B,
    DWORD ipaddrDnsAlt_C,
    DWORD ipaddrDnsAlt_D,
    BSTR bstrUserName,
    BSTR bstrPassword)
{
    
    DWORD dwRet = ERROR_SUCCESS;

    dwRet = m_EnumModem.ReInit();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    LPWSTR szDeviceName = m_EnumModem.GetDeviceNameFromType(RASDT_PPPoE);
    if (NULL == szDeviceName)
    {
        return ERROR_DEVICE_DOES_NOT_EXIST;
    }

    BSTR bstrDeviceName = SysAllocString(szDeviceName);
    BSTR bstrDeviceType = SysAllocString(RASDT_PPPoE);
    if (NULL == bstrDeviceName || NULL == bstrDeviceType)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        DWORD dwEntryOptions = RASEO_IpHeaderCompression
                             | RASEO_RemoteDefaultGateway
                             | RASEO_SwCompression
                             | RASEO_ShowDialingProgress
                             | RASEO_ModemLights;
        
        // Note that bstrBroadbandService is passed as the bstrPhoneNumber param to
        // CreateConnectoid.  This is correct per PMay.  bstrBroadbandService may
        // contain the name of a broadband service or may be an empty string.
        //
        dwRet = CreateConnectoid(bstrPhoneBook,
                                bstrConnectionName,
                                0,                      // dwCountryID unused
                                0,                      // dwCountryCode unused
                                NULL,                   // area code
                                bstrBroadbandService,
                                fAutoIPAddress,
                                ipaddr_A,
                                ipaddr_B,
                                ipaddr_C,
                                ipaddr_D,
                                fAutoDNS,
                                ipaddrDns_A,
                                ipaddrDns_B,
                                ipaddrDns_C,
                                ipaddrDns_D,
                                ipaddrDnsAlt_A,
                                ipaddrDnsAlt_B,
                                ipaddrDnsAlt_C,
                                ipaddrDnsAlt_D,
                                bstrUserName,
                                bstrPassword,
                                bstrDeviceName,
                                bstrDeviceType,
                                dwEntryOptions,
                                RASET_Broadband
                                );
    }

    if (bstrDeviceName) SysFreeString(bstrDeviceName);
    if (bstrDeviceType) SysFreeString(bstrDeviceType);

    // BUGBUG: Mixing HRESULT and WIN32 error code
    return dwRet;

}

///////////////////////////////////////////////////////////
//
// CreateConnectoid
//
STDMETHODIMP CObCommunicationManager::CreateConnectoid(
    BSTR bstrPhoneBook,
    BSTR bstrConnectionName,
    DWORD dwCountryID,
    DWORD dwCountryCode,
    BSTR bstrAreaCode,
    BSTR bstrPhoneNumber,
    BOOL fAutoIPAddress,
    DWORD ipaddr_A,
    DWORD ipaddr_B,
    DWORD ipaddr_C,
    DWORD ipaddr_D,
    BOOL fAutoDNS,
    DWORD ipaddrDns_A,
    DWORD ipaddrDns_B,
    DWORD ipaddrDns_C,
    DWORD ipaddrDns_D,
    DWORD ipaddrDnsAlt_A,
    DWORD ipaddrDnsAlt_B,
    DWORD ipaddrDnsAlt_C,
    DWORD ipaddrDnsAlt_D,
    BSTR bstrUserName,
    BSTR bstrPassword,
    BSTR bstrDeviceName,
    BSTR bstrDeviceType,
    DWORD dwEntryOptions,
    DWORD dwEntryType)
{
    RNAAPI rnaapi;
    HRESULT hr;
    RASENTRY rasentry;
    WCHAR wsz[MAX_ISP_NAME + 1];

    // Set up the RASENTRY
    memset(&rasentry, 0, sizeof(RASENTRY));
    rasentry.dwSize = sizeof(RASENTRY);
    rasentry.dwfOptions = dwEntryOptions;

    //
    // Location/phone number.
    //
    rasentry.dwCountryID = dwCountryID;
    rasentry.dwCountryCode = dwCountryCode;
    
    TRACE2(L"Connectoid %d %d", dwCountryID, dwCountryCode);
    
    // bstrAreaCode will be NULL when creating a PPPOE connectoid
    //
    if (NULL != bstrAreaCode)
    {
        lstrcpyn(rasentry.szAreaCode, bstrAreaCode, RAS_MaxAreaCode + 1);

        TRACE1(L"Connectoid AreaCode %s", rasentry.szAreaCode);
    }
    // bstrPhoneNumber should contain either a phone number or a broadband
    // service name.
    //
    MYASSERT(NULL != bstrPhoneNumber);
    if (NULL != bstrPhoneNumber)
    {
        lstrcpyn(rasentry.szLocalPhoneNumber, 
                 bstrPhoneNumber, 
                 RAS_MaxPhoneNumber + 1
                 );

        TRACE1(L"Connectoid LocalPhoneNumber %s", rasentry.szLocalPhoneNumber);
    }
    // dwAlternateOffset; No alternate numbers
    //
    // PPP/Ip
    //
    if (!fAutoIPAddress)
    {
        rasentry.dwfOptions |= RASEO_SpecificIpAddr;
        rasentry.ipaddr.a = (BYTE)ipaddr_A;
        rasentry.ipaddr.b = (BYTE)ipaddr_B;
        rasentry.ipaddr.c = (BYTE)ipaddr_C;
        rasentry.ipaddr.d = (BYTE)ipaddr_D;

        TRACE4(L"Connectoid ipaddr %d.%d.%d.%d",
            ipaddr_A, ipaddr_B, ipaddr_C, ipaddr_D);
    }
    if (!fAutoDNS)
    {
        rasentry.dwfOptions |= RASEO_SpecificNameServers;
        rasentry.ipaddrDns.a = (BYTE)ipaddrDns_A;
        rasentry.ipaddrDns.b = (BYTE)ipaddrDns_B;
        rasentry.ipaddrDns.c = (BYTE)ipaddrDns_C;
        rasentry.ipaddrDns.d = (BYTE)ipaddrDns_D;

        TRACE4(L"Connectoid ipaddrDns %d.%d.%d.%d",
            ipaddrDns_A, ipaddrDns_B, ipaddrDns_C, ipaddrDns_D);
        
        rasentry.ipaddrDnsAlt.a = (BYTE)ipaddrDnsAlt_A;
        rasentry.ipaddrDnsAlt.b = (BYTE)ipaddrDnsAlt_B;
        rasentry.ipaddrDnsAlt.c = (BYTE)ipaddrDnsAlt_C;
        rasentry.ipaddrDnsAlt.d = (BYTE)ipaddrDnsAlt_D;

        TRACE4(L"Connectoid ipaddrDnsAlt %d.%d.%d.%d",
            ipaddrDnsAlt_A, ipaddrDnsAlt_B, ipaddrDnsAlt_C, ipaddrDnsAlt_D);
        
    // RASIPADDR  ipaddrWins;
    // RASIPADDR  ipaddrWinsAlt;
    }
    //
    // Framing
    //
    // dwFrameSize; Ignored unless framing is RASFP_Slip
    rasentry.dwfNetProtocols = RASNP_Ip;
    rasentry.dwFramingProtocol = RASFP_Ppp;
    //
    // Scripting
    //
    // szScript[ MAX_PATH ];
    //
    // AutoDial - Use the default dialer
    //
    // szAutodialDll[ MAX_PATH ];
    // szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    if (NULL != bstrDeviceType)
    {
        lstrcpyn(rasentry.szDeviceType, bstrDeviceType, RAS_MaxDeviceType + 1);

        TRACE1(L"Connectoid DeviceType %s", rasentry.szDeviceType);
    }

    if (NULL != bstrDeviceName)
    {
        lstrcpyn(rasentry.szDeviceName, bstrDeviceName, RAS_MaxDeviceName + 1);

        TRACE1(L"Connectoid DeviceName %s", rasentry.szDeviceName);
    }

    //
    // X.25 - not using an X.25 device
    //
    // szX25PadType[ RAS_MaxPadType + 1 ];
    // szX25Address[ RAS_MaxX25Address + 1 ];
    // szX25Facilities[ RAS_MaxFacilities + 1 ];
    // szX25UserData[ RAS_MaxUserData + 1 ];
    // dwChannels;
    //
    // Reserved
    //
    // dwReserved1;
    // dwReserved2;
    //
    // Multilink and BAP
    //
    // dwSubEntries;
    // dwDialMode;
    // dwDialExtraPercent;
    // dwDialExtraSampleSeconds;
    // dwHangUpExtraPercent;
    // dwHangUpExtraSampleSeconds;
    //
    // Idle time out
    //
    // dwIdleDisconnectSeconds;
    //
    rasentry.dwType = dwEntryType;
    // dwEncryptionType;     // type of encryption to use
    // dwCustomAuthKey;      // authentication key for EAP
    // guidId;               // guid that represents
                             // the phone-book entry
    // szCustomDialDll[MAX_PATH];    // DLL for custom dialing
    // dwVpnStrategy;         // specifies type of VPN protocol

    TRACE5(L"Connectoid %d %d %d %d %d",
        rasentry.dwSize, rasentry.dwfOptions, rasentry.dwfNetProtocols,
        rasentry.dwFramingProtocol, rasentry.dwType);
    
    // Now pass all parameters to RAS
    hr = RasSetEntryProperties(bstrPhoneBook,
                               bstrConnectionName,
                               &rasentry,
                               sizeof(RASENTRY),
                               NULL,
                               0
                               );

    
    if (ERROR_SUCCESS == hr)
    {
        HRESULT        hr2;
        RASCREDENTIALS rascred;
        
        ZeroMemory(&rascred, sizeof(rascred));
        
        rascred.dwSize = sizeof(rascred);
        rascred.dwMask = RASCM_UserName 
                       | RASCM_Password 
                       | RASCM_Domain
                       | RASCM_DefaultCreds;
        
        if (bstrUserName != NULL)
        {
            lstrcpyn(rascred.szUserName, bstrUserName,UNLEN);
        }
        else
        {
            lstrcpyn(rascred.szUserName, L"", UNLEN);
        }
        
        if (bstrPassword != NULL)
        {
            lstrcpyn(rascred.szPassword, bstrPassword,PWLEN);
        }
        else
        {
            lstrcpyn(rascred.szPassword, L"", PWLEN);
        }
        
        lstrcpyn(rascred.szDomain, L"",DNLEN);

        hr2 = RasSetCredentials(bstrPhoneBook,
                                bstrConnectionName,
                                &rascred,
                                FALSE);

        TRACE1(L"Connectoid SetCredentials 0x%08lx", hr2);

        SetDefaultConnectoid(AutodialTypeNoNet, bstrConnectionName);
                    
        // Save the connectoid name so it can be firewalled by the HomeNet
        // Wizard.
        //
        lstrcpy(m_szExternalConnectoid, bstrConnectionName);
    }
    
    TRACE1(L"CreateConnectoid %d\n", hr);
    
    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//
//  DoFinalTasks
//
//  This method is called during OOBE's Finish code.  Complete any final tasks
//  (ie, run the HomeNet Wizard) here.
//
//  parameters:
//      pfRebootRequired    pointer to a buffer that receives a boolean
//                          indicating whether a reboot is required before
//                          something done here will take affect.
//
//  returns:
//      HRESULT returned by CHomeNet::ConfigureSilently
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CObCommunicationManager::DoFinalTasks(
    BOOL*               pfRebootRequired
    )
{
    HRESULT             hr = S_OK;
    BOOL                fRebootRequired = FALSE;
    LPCWSTR             szConnectoidName = (0 < lstrlen(m_szExternalConnectoid) 
                                            ? m_szExternalConnectoid 
                                            : NULL);

    if (szConnectoidName)
    {
        // Run the HomeNet Wizard sans UI.  m_szExternalConnectoid is the name of
        // the connectoid that will be firewalled.
        //
        CHomeNet            HomeNet;
        HomeNet.Create();

        // Run the HomeNet Wizard sans UI.  m_szExternalConnectoid is the name of
        // the connectoid that will be firewalled.
        //
        hr = HomeNet.ConfigureSilently(szConnectoidName,
                                       &fRebootRequired);
        if (FAILED(hr))
        {
            TRACE2(L"Failed: IHomeNetWizard::ConfigureSilently(%s): (0x%08X)",
                   m_szExternalConnectoid, hr
                   );
            fRebootRequired = FALSE;
        }
        else
        {
            TRACE1(L"Connection %s Firewalled", szConnectoidName);
        }
    }
    else if (m_bFirewall)
    {
        PSTRINGLIST List = NULL;
        
        m_ConnectionManager.EnumPublicConnections(&List);

        if (List)
        {
            CHomeNet HomeNet;
            if (SUCCEEDED(HomeNet.Create()))
            {                
                for (PSTRINGLIST p = List; p; p = p->Next)
                {
                    BOOL bRet = FALSE;

                    hr = HomeNet.ConfigureSilently(p->String, &bRet);
                    if (SUCCEEDED(hr))
                    {
                        TRACE1(L"Connection %s Firewalled", p->String);
                        if (bRet)
                        {
                            fRebootRequired = TRUE;
                        }
                    }
                    else
                    {
                        TRACE2(
                            L"Failed: IHomeNetWizard::ConfigureSilently(%s): (0x%08X)",
                            p->String,
                            hr
                            );
                    }
                }
            }
            else
            {
                TRACE1(L"Failed: IHomeNetWizard CoCreateInstance: (0x%08lx)", hr);
            }
            
            DestroyList(List);
            
        }
    }
    
    if (NULL != pfRebootRequired)
    {
        *pfRebootRequired = fRebootRequired;
    }

    return hr;

}   //  CObCommunicationManager::DoFinalTasks

//////////////////////////////////////////////////////////////////////////////
//
//  OobeAutodial
//
//  This method invokes IE's autodial as a modal dialog.
//
//  If a connection is established, it will be disconnected when 
//  OobeAutodialHangup is called or in this class's destructor.
// 
//  Precondition:
//      no internet connectivity is available.
//
//  returns:
//      S_OK - connection established
//      S_FALSE - no error. Autodial cancelled and no connection established
//      HRESULT error code - error occured.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CObCommunicationManager::OobeAutodial()
{
    HRESULT hr = S_OK;
    BOOL bRet = FALSE;
    
    if (!InternetAutodial(INTERNET_AUTODIAL_FORCE_ONLINE, m_hwndCallBack))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    hr = ConnectedToInternetEx(&bRet);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    if (bRet)
    {
        hr = S_OK;
        m_bAutodialCleanup = true;
    }
    else
    {
        hr = S_FALSE;
    }

cleanup:

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OobeAutodialHangup
//
//  This method disconnects the autodial connection, if there is one, created
//  by OobeAutodial
//
//  returns:
//      S_OK - no connection is created by OobeAutodial or hangup succeeded
//      HRESULT error code - error occured.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CObCommunicationManager::OobeAutodialHangup()
{
    HRESULT hr = S_OK;
    
    if (m_bAutodialCleanup)
    {
        if (!InternetAutodialHangup(0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        m_bAutodialCleanup = FALSE;
    }

    return hr;
}

HRESULT CObCommunicationManager::UseWinntProxySettings()
{
    m_ConnectionManager.UseWinntProxySettings();
    return S_OK;
}

HRESULT CObCommunicationManager::DisableWinntProxySettings()
{
    m_ConnectionManager.DisableWinntProxySettings();
    return S_OK;
}

HRESULT CObCommunicationManager::GetProxySettings(
    BOOL* pbUseAuto,
    BOOL* pbUseScript,
    BSTR* pszScriptUrl,
    BOOL* pbUseProxy,
    BSTR* pszProxy
    )
{
    return m_ConnectionManager.GetProxySettings(
        pbUseAuto,
        pbUseScript,
        pszScriptUrl,
        pbUseProxy,
        pszProxy
        );
}

HRESULT CObCommunicationManager::SetProxySettings(
    BOOL bUseAuto,
    BOOL bUseScript,
    BSTR szScriptUrl,
    BOOL bUseProxy,
    BSTR szProxy
    )
{
    return m_ConnectionManager.SetProxySettings(
        bUseAuto,
        bUseScript,
        szScriptUrl,
        bUseProxy,
        szProxy
        );
}

BSTR CObCommunicationManager::GetPreferredModem()
{
    BSTR bstrVal = NULL;
    
    // Assume CObCommunicationManager::CheckDialReady has been called
    //
    LPWSTR szDeviceName = m_EnumModem.GetDeviceNameFromType(RASDT_Isdn);
    if (szDeviceName == NULL)
    {
        szDeviceName = m_EnumModem.GetDeviceNameFromType(RASDT_Modem);
    }

    if (szDeviceName != NULL)
    {
        bstrVal = SysAllocString(szDeviceName);
    }

    return bstrVal;
}

HRESULT CObCommunicationManager::SetICWCompleted(
    BOOL bMultiUser
    )
{
    BOOL bRet;
    
    if (bMultiUser)
    {
        bRet = SetMultiUserAutodial(AutodialTypeNever, NULL, TRUE);
    }
    else
    {
        bRet = SetAutodial(HKEY_CURRENT_USER, AutodialTypeNever, NULL, TRUE);
    }

    return (bRet) ? S_OK : E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
//
//  GetPublicLanCount
//
//  Forward the work to CConnectionManager::GetPublicLanCount
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::GetPublicLanCount(
    int*                pcPublicLan
    )
{
    return  m_ConnectionManager.GetPublicLanCount(pcPublicLan);
}   //  CObCommunicationManager::GetPublicLanCount

//////////////////////////////////////////////////////////////////////////////
//
//  SetExclude1394
//
//  Forward the work to CConnectionManager::SetExclude1394
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::SetExclude1394(
    BOOL bExclude
    )
{
    m_ConnectionManager.SetExclude1394(bExclude);
    return S_OK;
}   // CObCommunicationManager::SetExclude1394 

//////////////////////////////////////////////////////////////////////////////
//
//  GnsAutodial
//
//  Forward the work to CRefDial::SetupForAutoDial
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObCommunicationManager::GnsAutodial(
    BOOL bEnabled,
    BSTR bstrUserSection
    )
{
    HRESULT hr = S_OK;
    
    if (m_pRefDial)
    {
        hr = m_pRefDial->SetupForAutoDial(bEnabled, bstrUserSection);
    }

    return hr;

}   // CObCommunicationManager::GnsAutodial
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\msobcomm.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOBWEB.H - Header for the implementation of CObWebBrowser
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Class which will call up an IOleSite and the WebOC
//  and provide external interfaces.

#ifndef _MSOBCOMM_H_
#define _MSOBCOMM_H_

#include <ocidl.h> //For IConnectionPoint
#include "cunknown.h"
#include "cfactory.h"
#include "obcomm.h" 
#include "Cntpoint.h"
#include "refdial.h"
#include "webgate.h"
#include "icsmgr.h"
#include "homenet.h"
#include "connmgr.h"


class CObCommunicationManager : public CUnknown,
                                public IObCommunicationManager2,
                                public DObCommunicationEvents,
                                public IConnectionPointContainer
{
    // Declare the delegating IUnknown.
    DECLARE_IUNKNOWN

public: 
    static  HRESULT           CreateInstance              (IUnknown* pOuterUnknown, CUnknown** ppNewComponent);

    // IObCommunicationManager Members
    virtual HRESULT __stdcall ListenToCommunicationEvents (IUnknown* pUnk);
    
    // RAS Dialing methods
    virtual HRESULT __stdcall CheckDialReady(DWORD *pdwRetVal) ;
    virtual HRESULT __stdcall SetupForDialing(UINT nType, BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, DWORD dwAppMode, DWORD dwMigISPIdx);
    virtual HRESULT __stdcall DoConnect(BOOL *pbRetVal) ;
    virtual HRESULT __stdcall DoHangup() ;
    virtual HRESULT __stdcall GetDialPhoneNumber(BSTR *pVal);
    virtual HRESULT __stdcall PutDialPhoneNumber(BSTR newVal);
    virtual HRESULT __stdcall GetDialErrorMsg(BSTR *pVal);
    virtual HRESULT __stdcall GetSupportNumber(BSTR *pVal);
    virtual HRESULT __stdcall RemoveConnectoid(BOOL *pbRetVal);
    virtual HRESULT __stdcall SetRASCallbackHwnd(HWND hwndCallback); 
    virtual HRESULT __stdcall GetSignupURL(BSTR *pVal);
    virtual HRESULT __stdcall GetReconnectURL(BSTR *pVal);
    virtual HRESULT __stdcall CheckPhoneBook(BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, BOOL *pbRetVal);
    virtual HRESULT __stdcall RestoreConnectoidInfo() ;
    virtual HRESULT __stdcall SetPreloginMode(BOOL bVal);
    virtual HRESULT __stdcall GetConnectionType(DWORD * pdwVal);
    virtual HRESULT __stdcall CheckKbdMouse(DWORD *pdwRetVal) ;
    virtual HRESULT __stdcall OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL* bHandled);
    virtual HRESULT __stdcall GetISPList(BSTR* pVal);
    virtual HRESULT __stdcall Set_SelectISP(UINT nVal);
    virtual HRESULT __stdcall Set_ConnectionMode(UINT nVal);
    virtual HRESULT __stdcall Get_ConnectionMode(UINT* pnVal);
    virtual HRESULT __stdcall DownloadReferralOffer(BOOL *pbVal);
    virtual HRESULT __stdcall DownloadISPOffer(BOOL *pbVal, BSTR *pVal);
    virtual HRESULT __stdcall Get_ISPName(BSTR *pVal);
    virtual HRESULT __stdcall RemoveDownloadDir() ;
    virtual HRESULT __stdcall PostRegData(DWORD dwSrvType, BSTR bstrRegUrl);
    virtual HRESULT __stdcall Connect(UINT nType, BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, DWORD dwAppMode);
    virtual HRESULT __stdcall CheckStayConnected(BSTR bstrISPFile, BOOL *pbVal);
    virtual HRESULT __stdcall CheckOnlineStatus(BOOL *pbVal);
    virtual HRESULT __stdcall GetPhoneBookNumber(BSTR *pVal);
    virtual HRESULT __stdcall SetDialAlternative(BOOL bVal);

    // WebGate html download methods
    virtual HRESULT __stdcall FetchPage(BSTR szURL, BSTR* szLocalFile);
    virtual HRESULT __stdcall DownloadFileBuffer(BSTR *pVal);
    virtual HRESULT __stdcall GetFile(BSTR szURL, BSTR szFileFullName);

    // INS processing methods
    virtual HRESULT __stdcall ProcessINS(BSTR bstrINSFilePath, BOOL *pbRetVal);

    // IConnectionPointContainer Methods
    virtual HRESULT __stdcall EnumConnectionPoints(IEnumConnectionPoints **ppEnum) ;
    virtual HRESULT __stdcall FindConnectionPoint(REFIID riid, IConnectionPoint **ppCP) ;
    
    //IObCommunicationEvents
    STDMETHOD (GetTypeInfoCount) (UINT*   pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT,   LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID  dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    //IObCommunicationEvents Members
    virtual HRESULT Fire_Dialing                (DWORD dwDialStatus);
    virtual HRESULT Fire_Connecting             ();
    virtual HRESULT Fire_DialError              (DWORD dwErrorCode);
    virtual HRESULT Fire_ConnectionComplete     ();
    virtual HRESULT Fire_DownloadComplete       (BSTR pVal);


	//ICS Routines
	virtual HRESULT __stdcall CreateIcsBot(DWORD *pdwRetVal);
	virtual HRESULT __stdcall IsIcsAvailable(BOOL *bRetVal);
    virtual HRESULT __stdcall IsCallbackUsed(BOOL *bRetVal);
    virtual HRESULT __stdcall NotifyIcsMgr(UINT msg, WPARAM wParam, LPARAM lParam);
	virtual HRESULT __stdcall NotifyIcsUsage(BOOL bParam);
    virtual HRESULT __stdcall TriggerIcsCallback(BOOL bParam);
    virtual HRESULT __stdcall IsIcsHostReachable(BOOL *bParam);


    //IObCommunicationManager2 Methods
    STDMETHOD(CreateModemConnectoid)            (BSTR bstrPhoneBook,
                                                 BSTR bstrConnectionName,
                                                 DWORD dwCountryID,
                                                 DWORD dwCountryCode,
                                                 BSTR bstrAreaCode,
                                                 BSTR bstrPhoneNumber,
                                                 BOOL fAutoIPAddress,
                                                 DWORD ipaddr_A,
                                                 DWORD ipaddr_B,
                                                 DWORD ipaddr_C,
                                                 DWORD ipaddr_D,
                                                 BOOL fAutoDNS,
                                                 DWORD ipaddrDns_A,
                                                 DWORD ipaddrDns_B,
                                                 DWORD ipaddrDns_C,
                                                 DWORD ipaddrDns_D,
                                                 DWORD ipaddrDnsAlt_A,
                                                 DWORD ipaddrDnsAlt_B,
                                                 DWORD ipaddrDnsAlt_C,
                                                 DWORD ipaddrDnsAlt_D,
                                                 BSTR bstrUserName,
                                                 BSTR bstrPassword);
    STDMETHOD(CreatePppoeConnectoid)            (BSTR bstrPhoneBook,
                                                 BSTR bstrConnectionName,
                                                 BSTR bstrBroadbandService,
                                                 BOOL fAutoIPAddress,
                                                 DWORD ipaddr_A,
                                                 DWORD ipaddr_B,
                                                 DWORD ipaddr_C,
                                                 DWORD ipaddr_D,
                                                 BOOL fAutoDNS,
                                                 DWORD ipaddrDns_A,
                                                 DWORD ipaddrDns_B,
                                                 DWORD ipaddrDns_C,
                                                 DWORD ipaddrDns_D,
                                                 DWORD ipaddrDnsAlt_A,
                                                 DWORD ipaddrDnsAlt_B,
                                                 DWORD ipaddrDnsAlt_C,
                                                 DWORD ipaddrDnsAlt_D,
                                                 BSTR bstrUserName,
                                                 BSTR bstrPassword
                                                 );
    STDMETHOD(CreateConnectoid)                 (BSTR bstrPhoneBook,
                                                 BSTR bstrConnectionName,
                                                 DWORD dwCountryID,
                                                 DWORD dwCountryCode,
                                                 BSTR bstrAreaCode,
                                                 BSTR bstrPhoneNumber,
                                                 BOOL fAutoIPAddress,
                                                 DWORD ipaddr_A,
                                                 DWORD ipaddr_B,
                                                 DWORD ipaddr_C,
                                                 DWORD ipaddr_D,
                                                 BOOL fAutoDNS,
                                                 DWORD ipaddrDns_A,
                                                 DWORD ipaddrDns_B,
                                                 DWORD ipaddrDns_C,
                                                 DWORD ipaddrDns_D,
                                                 DWORD ipaddrDnsAlt_A,
                                                 DWORD ipaddrDnsAlt_B,
                                                 DWORD ipaddrDnsAlt_C,
                                                 DWORD ipaddrDnsAlt_D,
                                                 BSTR bstrUserName,
                                                 BSTR bstrPassword,
                                                 BSTR bstrDeviceName,
                                                 BSTR bstrDeviceType,
                                                 DWORD dwEntryOptions,
                                                 DWORD dwEntryType);
    STDMETHOD(SetPreferredConnectionTcpipProperties)
                                                (BOOL fAutoIPAddress,
                                                 DWORD StaticIp_A,
                                                 DWORD StaticIp_B,
                                                 DWORD StaticIp_C,
                                                 DWORD StaticIp_D,
                                                 DWORD SubnetMask_A,
                                                 DWORD SubnetMask_B,
                                                 DWORD SubnetMask_C,
                                                 DWORD SubnetMask_D,
                                                 DWORD DefGateway_A,
                                                 DWORD DefGateway_B,
                                                 DWORD DefGateway_C,
                                                 DWORD DefGateway_D,
                                                 BOOL fAutoDns,
                                                 DWORD DnsPref_A,
                                                 DWORD DnsPref_B,
                                                 DWORD DnsPref_C,
                                                 DWORD DnsPref_D,
                                                 DWORD DnsAlt_A,
                                                 DWORD DnsAlt_B,
                                                 DWORD DnsAlt_C,
                                                 DWORD DnsAlt_D,
                                                 BOOL fFirewallRequired
                                                 );
    STDMETHOD(DoFinalTasks)                     (BOOL* pfRebootRequired);
    STDMETHOD(GetConnectionCapabilities)        (DWORD* pdwConnectionCapabilities);
    STDMETHOD(GetPreferredConnection)           (DWORD* pdwPreferredConnection);
    STDMETHOD(SetPreferredConnection)           (const DWORD dwPreferredConnection,
                                                 BOOL* pfSupportedType);
    STDMETHOD(ConnectedToInternet)              (BOOL* pfConnected);
    STDMETHOD(ConnectedToInternetEx)            (BOOL* pfConnected);
    STDMETHOD(AsyncConnectedToInternetEx)       (const HWND hwnd);
    STDMETHOD(OobeAutodial)                     ();
    STDMETHOD(OobeAutodialHangup)               ();
    STDMETHOD(FirewallPreferredConnection)      (BOOL fFirewall);
    STDMETHOD(UseWinntProxySettings)            ();
    STDMETHOD(DisableWinntProxySettings)        ();
    STDMETHOD(GetProxySettings)                 (BOOL* pbUseAuto,
                                                 BOOL* pbUseScript,
                                                 BSTR* pszScriptUrl,
                                                 BOOL* pbUseProxy,
                                                 BSTR* pszProxy
                                                );
    STDMETHOD(SetProxySettings)                 (BOOL bUseAuto,
                                                 BOOL bUseScript,
                                                 BSTR szScriptUrl,
                                                 BOOL bUseProxy,
                                                 BSTR szProxy
                                                );

    BSTR GetPreferredModem                      ();
    STDMETHOD(SetICWCompleted)                  (BOOL bMultiUser);
    STDMETHOD(GetPublicLanCount)                (int* pcPublicLan);
    STDMETHOD(SetExclude1394)                   (BOOL bExclude);
    STDMETHOD(GnsAutodial)                      (BOOL bEnabled,
                                                 BSTR bstrUserSection
                                                );

    HWND                m_hwndCallBack;
    CRefDial*           m_pRefDial;
    BOOL                m_pbPreLogin;
 
private:
    DWORD               m_dwcpCookie;

    HRESULT ConnectToConnectionPoint (IUnknown*          punkThis, 
                                      REFIID             riidEvent, 
                                      BOOL               fConnect, 
                                      IUnknown*          punkTarget, 
                                      DWORD*             pdwCookie, 
                                      IConnectionPoint** ppcpOut);
   
    // IUnknown
    virtual HRESULT __stdcall NondelegatingQueryInterface( const IID& iid, void** ppv);
    

    CObCommunicationManager  (IUnknown* pOuterUnknown);
    virtual        ~CObCommunicationManager  ();
    virtual void    FinalRelease             (); // Notify derived classes that we are releasing

    // Connection Point support
    CConnectionPoint*  m_pConnectionPoint;
    CWebGate*          m_pWebGate;
    CINSHandler*       m_InsHandler;
	CIcsMgr*		   m_IcsMgr;
    IDispatch*         m_pDisp;
	BOOL			   m_bIsIcsUsed;
    static INT         m_nNumListener;
    WCHAR              m_szExternalConnectoid[RAS_MaxEntryName];
    CConnectionManager m_ConnectionManager;
    CEnumModem         m_EnumModem;
    BOOL               m_bFirewall;
    BOOL               m_bAutodialCleanup;

};

LRESULT
RegQueryOobeValue(
    LPCWSTR             szValue,
    LPBYTE              pBuffer,
    DWORD*              pcbBuffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\refdial.cpp ===
// RefDial.cpp : Implementation of CRefDial
//#include "stdafx.h"
//#include "icwhelp.h"
#include <urlmon.h>
#include "commerr.h"
#include "RefDial.h"
#include "msobcomm.h"
#include "appdefs.h"
#include "commerr.h"
#include "util.h"
#include "msobdl.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//#include <mshtmhst.h>
const WCHAR c_szCreditsMagicNum[] = L"1 425 555 1212";

const WCHAR c_szRegStrValDigitalPID[] = L"DigitalProductId";
const WCHAR c_szSignedPIDFName[] = L"signed.pid";

const WCHAR c_szRASProfiles[] = L"RemoteAccess\\Profile";
const WCHAR c_szProxyEnable[] = L"ProxyEnable";
const WCHAR c_szURLReferral[] = L"URLReferral";
const WCHAR c_szRegPostURL[]  = L"RegPostURL";
const WCHAR c_szStayConnected[] = L"Stayconnected";
static const WCHAR szOptionTag[] = L"<OPTION>%s";

WCHAR g_BINTOHEXLookup[16] =
{
   L'0',L'1',L'2',L'3',L'4',L'5',L'6',L'7',
   L'8',L'9',L'A',L'B',L'C',L'D',L'E',L'F'
};



extern CObCommunicationManager* gpCommMgr;
extern WCHAR cszUserName[];
extern WCHAR cszPassword[];

extern BOOL isAlnum(WCHAR c);

// ############################################################################
HRESULT Sz2URLValue(WCHAR *s, WCHAR *buf, UINT uiLen)
{
    HRESULT hr;
    WCHAR *t;
    hr = ERROR_SUCCESS;

    for (t=buf;*s; s++)
    {
        if (*s == L' ') *t++ = L'+';
        else if (isAlnum(*s)) *t++ = *s;
        else {
            wsprintf(t, L"%%%02X", (WCHAR) *s);
            t += 3;
        }
    }
    *t = L'\0';
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LineCallback()
//
//  Synopsis:   Call back for TAPI line
//
//+---------------------------------------------------------------------------
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD_PTR dwInstance,
                           DWORD_PTR dwParam1,
                           DWORD_PTR dwParam2,
                           DWORD_PTR dwParam3)
{
    return;
}

void WINAPI MyProgressCallBack
(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
)
{
    CRefDial    *pRefDial = (CRefDial *)dwContext;
    int         prc;

    if (!dwContext)
        return;

    switch(dwInternetStatus)
    {
        case CALLBACK_TYPE_PROGRESS:
            prc = *(int*)lpvStatusInformation;
            // Set the status string ID
            pRefDial->m_DownloadStatusID = 0;//IDS_RECEIVING_RESPONSE;

            // Post a message to fire an event
            PostMessage(gpCommMgr->m_hwndCallBack,
                        WM_OBCOMM_DOWNLOAD_PROGRESS,
                        gpCommMgr->m_pRefDial->m_dwCnType,
                        prc);
            break;

        case CALLBACK_TYPE_URL:
            if (lpvStatusInformation)
                lstrcpy(pRefDial->m_szRefServerURL, (LPWSTR)lpvStatusInformation);
            break;

        default:
            //TraceMsg(TF_GENERAL, L"CONNECT:Unknown Internet Status (%d.\n"), dwInternetStatus);
            pRefDial->m_DownloadStatusID = 0;
            break;
    }
}

DWORD WINAPI  DownloadThreadInit(LPVOID lpv)
{
    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    CRefDial    *pRefDial = (CRefDial*)lpv;
    HINSTANCE   hDLDLL = NULL; // Download .DLL
    FARPROC     fp;

    //MinimizeRNAWindowEx();

    hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);
    if (!hDLDLL)
    {
        hr = ERROR_DOWNLOAD_NOT_FOUND;
        //AssertMsg(0, L"icwdl missing");
        goto ThreadInitExit;
    }

    // Set up for download
    //
    fp = GetProcAddress(hDLDLL, DOWNLOADINIT);
    if (fp == NULL)
    {
        hr = ERROR_DOWNLOAD_NOT_FOUND;
        //AssertMsg(0, L"DownLoadInit API missing");
        goto ThreadInitExit;
    }

    hr = ((PFNDOWNLOADINIT)fp)(pRefDial->m_szUrl, (DWORD FAR *)pRefDial, &pRefDial->m_dwDownLoad, gpCommMgr->m_hwndCallBack);
    if (hr != ERROR_SUCCESS)
        goto ThreadInitExit;

    // Set up call back for progress dialog
    //
    fp = GetProcAddress(hDLDLL, DOWNLOADSETSTATUS);
    //Assert(fp);
    hr = ((PFNDOWNLOADSETSTATUS)fp)(pRefDial->m_dwDownLoad, (INTERNET_STATUS_CALLBACK)MyProgressCallBack);

    // Download stuff MIME multipart
    //
    fp = GetProcAddress(hDLDLL, DOWNLOADEXECUTE);
    //Assert(fp);
    hr = ((PFNDOWNLOADEXECUTE)fp)(pRefDial->m_dwDownLoad);
    if (hr)
    {
        goto ThreadInitExit;
    }

    fp = GetProcAddress(hDLDLL, DOWNLOADPROCESS);
    //Assert(fp);
    hr = ((PFNDOWNLOADPROCESS)fp)(pRefDial->m_dwDownLoad);
    if (hr)
    {
        goto ThreadInitExit;
    }

    hr = ERROR_SUCCESS;

ThreadInitExit:

    // Clean up
    //
    if (pRefDial->m_dwDownLoad)
    {
        fp = GetProcAddress(hDLDLL, DOWNLOADCLOSE);
        //Assert(fp);
        ((PFNDOWNLOADCLOSE)fp)(pRefDial->m_dwDownLoad);
        pRefDial->m_dwDownLoad = 0;
    }

    // Call the OnDownLoadCompelete method
    if (ERROR_SUCCESS == hr)
    {
        PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_DOWNLOAD_DONE, gpCommMgr->m_pRefDial->m_dwCnType, 0);
    }

    // Free the libs used to do the download
    if (hDLDLL)
        FreeLibrary(hDLDLL);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   RasErrorToIDS()
//
//  Synopsis:   Interpret and wrap RAS errors
//
//+---------------------------------------------------------------------------
DWORD RasErrorToIDS(DWORD dwErr)
{
    switch(dwErr)
    {
    case SUCCESS:
        return 0;

    case ERROR_LINE_BUSY:
        return ERR_COMM_RAS_PHONEBUSY;

    case ERROR_NO_ANSWER:       // No pick up
    case ERROR_NO_CARRIER:      // No negotiation
    case ERROR_PPP_TIMEOUT:     // get this on CHAP timeout
        return ERR_COMM_RAS_SERVERBUSY;

    case ERROR_NO_DIALTONE:
        return ERR_COMM_RAS_NODIALTONE;

    case ERROR_HARDWARE_FAILURE:    // modem turned off
    case ERROR_PORT_ALREADY_OPEN:   // procomm/hypertrm/RAS has COM port
    case ERROR_PORT_OR_DEVICE:      // got this when hypertrm had the device open -- jmazner
        return ERR_COMM_RAS_NOMODEM;

    }
    return ERR_COMM_RAS_UNKNOWN;
}

DWORD DoConnMonitor(LPVOID lpv)
{
    if (gpCommMgr)
        gpCommMgr->m_pRefDial->ConnectionMonitorThread(NULL);

    return 1;
}

void CreateConnMonitorThread(LPVOID lpv)
{
    DWORD dwThreadID;
    if (gpCommMgr->m_pRefDial->m_hConnMonThread)
        gpCommMgr->m_pRefDial->TerminateConnMonitorThread();

    gpCommMgr->m_pRefDial->m_hConnMonThread = CreateThread(NULL,
                             0,
                             (LPTHREAD_START_ROUTINE)DoConnMonitor,
                             (LPVOID)0,
                             0,
                             &dwThreadID);

}

HRESULT CRefDial::OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL* bHandled)
{
    if (uMsg == WM_OBCOMM_DOWNLOAD_DONE)
    {
        DWORD   dwThreadResults = STILL_ACTIVE;
        int     iRetries = 0;

        // We keep the RAS connection open here, it must be explicitly
        // close by the container (a call DoHangup)
        // This code will wait until the download thread exists, and
        // collect the download status.
        if (m_hThread)
        {
            do {
                if (!GetExitCodeThread(m_hThread, &dwThreadResults))
                {
                    //ASSERT(0, L"CONNECT:GetExitCodeThread failed.\n");
                }

                iRetries++;
                if (dwThreadResults  == STILL_ACTIVE)
                    Sleep(500);
            } while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);
            m_hThread = NULL;
        }

        // BUGBUG: Is bstrURL used for anything??
        // See if there is an URL to pass to the container
        BSTR    bstrURL;
        if (m_szRefServerURL[0] != L'\0')
            bstrURL = SysAllocString(m_szRefServerURL);
        else
            bstrURL = NULL;

        // The download is complete now, so we reset this to TRUE, so the RAS
        // event handler does not get confused
        m_bDownloadHasBeenCanceled = TRUE;

        // Read and parse the download folder.
        *bHandled = ParseISPInfo(NULL, ICW_ISPINFOPath, TRUE);

        // Free any memory allocated above during the conversion
        SysFreeString(bstrURL);

    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   TerminateConnMonitorThread()
//
//  Synopsis:   Termintate connection monitor thread
//
//+---------------------------------------------------------------------------
void CRefDial::TerminateConnMonitorThread()
{
    DWORD   dwThreadResults = STILL_ACTIVE;
    int     iRetries = 0;

    if (m_hConnMonThread)
    {
        SetEvent(m_hConnectionTerminate);

        // We keep the RAS connection open here, it must be explicitly
        // close by the container (a call DoHangup)
        // This code will wait until the monitor thread exists, and
        // collect the status.
        do
        {
            if (!GetExitCodeThread(m_hConnMonThread, &dwThreadResults))
            {
                break;
            }

            iRetries++;
            if (dwThreadResults  == STILL_ACTIVE)
                Sleep(500);
        } while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);


        CloseHandle(m_hConnMonThread);
        m_hConnMonThread = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ConnectionMonitorThread()
//
//  Synopsis:   Monitor connection status
//
//+---------------------------------------------------------------------------
DWORD CRefDial::ConnectionMonitorThread(LPVOID pdata)
{
    HRESULT  hr   = E_FAIL;

    MSG     msg;
    DWORD   dwRetCode;
    HANDLE  hEventList[1];
    BOOL    bConnected;

    m_hConnectionTerminate = CreateEvent(NULL, TRUE, FALSE, NULL);

    hEventList[0] = m_hConnectionTerminate;


    while(TRUE)
    {
        // We will wait on window messages and also the named event.
        dwRetCode = MsgWaitForMultipleObjects(1,
                                              &hEventList[0],
                                              FALSE,
                                              1000,            // 1 second
                                              QS_ALLINPUT);
        if(dwRetCode == WAIT_TIMEOUT)
        {
            RasGetConnectStatus(&bConnected);
            // If we've got disconnected, then we notify UI
            if (!bConnected)
            {
                PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONDIALERROR, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)ERROR_REMOTE_DISCONNECTION);
                break;
            }
        }
        else if(dwRetCode == WAIT_OBJECT_0)
        {
            break;
        }
        else if(dwRetCode == WAIT_OBJECT_0 + 1)
        {
            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (WM_QUIT == msg.message)
                {
                    //*pbRetVal = FALSE;
                    break;
                }
                else
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

    }
    CloseHandle(m_hConnectionTerminate);
    m_hConnectionTerminate = NULL;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasDialFunc()
//
//  Synopsis:   Call back for RAS
//
//+---------------------------------------------------------------------------
void CALLBACK CRefDial::RasDialFunc(HRASCONN        hRas,
                                    UINT            unMsg,
                                    RASCONNSTATE    rasconnstate,
                                    DWORD           dwError,
                                    DWORD           dwErrorEx)
{
    if (gpCommMgr)
    {
        if (dwError)
        {
            if (ERROR_USER_DISCONNECTION != dwError)
            {
                gpCommMgr->m_pRefDial->DoHangup();
                //gpCommMgr->Fire_DialError((DWORD)rasconnstate);

                TRACE1(L"DialError %d", dwError);

                gpCommMgr->m_pRefDial->m_dwRASErr = dwError;  // Store dialing error
                PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONDIALERROR, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)gpCommMgr->m_pRefDial->m_dwRASErr);
            }
        }
        else
        {
            switch(rasconnstate)
            {
                case RASCS_OpenPort:
                    //gpCommMgr->Fire_Dialing((DWORD)rasconnstate);
                    PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONDIALING, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)0);
                    break;

                case RASCS_StartAuthentication: // WIN 32 only
                    //gpCommMgr->Fire_Connecting();
                    PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONCONNECTING, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)0);
                    break;
                case RASCS_Authenticate: // WIN 32 only
                    //gpCommMgr->Fire_Connecting();
                    if (IsNT())
                        PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONCONNECTING, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)0);
                    break;
                case RASCS_PortOpened:
                    break;
                case RASCS_ConnectDevice:
                    break;
                case RASCS_DeviceConnected:
                case RASCS_AllDevicesConnected:
                    PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONCONNECTING, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)0);
                    break;
                case RASCS_Connected:
                {
                    CreateConnMonitorThread(NULL);
                    PostMessage(gpCommMgr->m_hwndCallBack,
                                WM_OBCOMM_ONCONNECTED,
                                (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType,
                                (LPARAM)0);
                    break;
                }
                case RASCS_Disconnected:
                {

                    if (CONNECTED_REFFERAL == gpCommMgr->m_pRefDial->m_dwCnType &&
                        !gpCommMgr->m_pRefDial->m_bDownloadHasBeenCanceled)
                    {
                        HINSTANCE hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);
                        if (hDLDLL)
                        {
                            FARPROC fp = GetProcAddress(hDLDLL, DOWNLOADCANCEL);
                            if(fp)
                                ((PFNDOWNLOADCANCEL)fp)(gpCommMgr->m_pRefDial->m_dwDownLoad);
                            FreeLibrary(hDLDLL);
                            hDLDLL = NULL;
                            gpCommMgr->m_pRefDial->m_bDownloadHasBeenCanceled = TRUE;
                        }
                    }


                    // If we get a disconnected status from the RAS server, then
                    // hangup the modem here
                    gpCommMgr->m_pRefDial->DoHangup();
                    //gpCommMgr->Fire_DialError((DWORD)rasconnstate);
                    PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONDISCONNECT, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)0);
                    break;
                }

                default:
                    break;
            }
        }
    }
    return;
}

/////////////////////////////////////////////////////////////////////////////
// CRefDial
CRefDial::CRefDial()
{

    HKEY        hkey                    = NULL;
    DWORD       dwResult                = 0;

    *m_szCurrentDUNFile                 = 0;
    *m_szLastDUNFile                    = 0;
    *m_szEntryName                      = 0;
    *m_szConnectoid                     = 0;
    *m_szPID                            = 0;
    *m_szRefServerURL                   = 0;
    *m_szRegServerName                  = 0;
    m_nRegServerPort                    = INTERNET_INVALID_PORT_NUMBER;
    m_fSecureRegServer                  = FALSE;
    *m_szRegFormAction                  = 0;
    *m_szISPSupportNumber               = 0;
    *m_szISPFile                        = 0;
    m_hrDisplayableNumber               = ERROR_SUCCESS;
    m_dwCountryCode                     = 0;
    m_RasStatusID                       = 0;
    m_dwTapiDev                         = 0xFFFFFFFF; // NOTE: 0 is a valid value
    m_dwWizardVersion                   = 0;
    m_lCurrentModem                     = -1;
    m_lAllOffers                        = 0;
    m_PhoneNumberEnumidx                = 0;
    m_dwRASErr                          = 0;
    m_bDownloadHasBeenCanceled          = TRUE;      // This will get set to FALSE when a DOWNLOAD starts
    m_bQuitWizard                       = FALSE;
    m_bTryAgain                         = FALSE;
    m_bDisconnect                       = FALSE;
    m_bDialCustom                       = FALSE;
    m_bModemOverride                    = FALSE;     //allows campus net to be used.
    m_hrasconn                          = NULL;
    m_pszDisplayable                    = NULL;
    m_pcRNA                             = NULL;
    m_hRasDll                           = NULL;
    m_fpRasDial                         = NULL;
    m_fpRasGetEntryDialParams           = NULL;
    m_lpGatherInfo                      = new GATHERINFO;
    m_reflpRasEntryBuff                 = NULL;
    m_reflpRasDevInfoBuff               = NULL;
    m_hThread                           = NULL;
    m_hDialThread                       = NULL;
    m_hConnMonThread                    = NULL;
    m_bUserInitiateHangup               = FALSE;
    m_pszOriginalDisplayable            = NULL;
    m_bDialAlternative                  = TRUE;

    memset(&m_SuggestInfo, 0, sizeof(m_SuggestInfo));
    memset(&m_szConnectoid, 0, RAS_MaxEntryName+1);

    m_dwAppMode                         = 0;
    m_bDial                             = FALSE;
    m_dwCnType                    = CONNECTED_ISP_SIGNUP;
    m_pszISPList                        = FALSE;
    m_dwNumOfAutoConfigOffers           = 0;
    m_pCSVList                          = NULL;
    m_unSelectedISP                     = 0;

    m_bstrPromoCode                     = SysAllocString(L"\0");
    m_bstrProductCode                   = SysAllocString(L"\0");
    m_bstrSignedPID                     = SysAllocString(L"\0");
    m_bstrSupportNumber                 = SysAllocString(L"\0");
    m_bstrLoggingStartUrl               = SysAllocString(L"\0");
    m_bstrLoggingEndUrl                 = SysAllocString(L"\0");

    // This Critical Section is used by DoHangup and GetDisplayableNumber
    InitializeCriticalSection (&m_csMyCriticalSection);

    // Initialize m_dwConnectionType.
    m_dwConnectionType                  = 0;
    if ( RegOpenKey(HKEY_LOCAL_MACHINE, ICSSETTINGSPATH,&hkey) == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        if (RegQueryValueEx(hkey, ICSCLIENT,NULL,&dwType,(LPBYTE)&dwResult, &dwSize) != ERROR_SUCCESS)
            dwResult = 0;

        RegCloseKey(hkey);
    }
    if ( 0 != dwResult )
        m_dwConnectionType = CONNECTION_ICS_TYPE;

    m_bAutodialModeSaved = FALSE;
    m_bCleanupAutodial = FALSE;

}

CRefDial::~CRefDial()
{

    if (m_hrasconn)
        DoHangup();

    if (m_hConnMonThread)
    {
        SetEvent(m_hConnectionTerminate);
    }

    CleanupAutodial();

    if (NULL != m_hThread)
    {
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    if (NULL != m_hDialThread)
    {
        CloseHandle(m_hDialThread);
        m_hDialThread = NULL;
    }

    if (NULL != m_hConnMonThread)
    {
        CloseHandle(m_hConnMonThread);
        m_hConnMonThread = NULL;
    }

    if (m_lpGatherInfo)
        delete(m_lpGatherInfo);

    if( (m_pcRNA!=NULL) && (*m_szConnectoid != 0) )
    {
        m_pcRNA->RasDeleteEntry(NULL, m_szConnectoid);
    }

    if ( m_pcRNA )
        delete m_pcRNA;

    if(m_reflpRasEntryBuff)
    {
        GlobalFree(m_reflpRasEntryBuff);
        m_reflpRasEntryBuff = NULL;
    }
    if(m_reflpRasDevInfoBuff)
    {
        GlobalFree(m_reflpRasDevInfoBuff);
        m_reflpRasDevInfoBuff = NULL;
    }
    if (m_pszISPList)
        delete [] m_pszISPList;
    DeleteCriticalSection(&m_csMyCriticalSection);

    if (m_pszOriginalDisplayable)
    {
        GlobalFree(m_pszOriginalDisplayable);
        m_pszOriginalDisplayable = NULL;
    }

    CleanISPList();
}

void CRefDial::CleanISPList(void)
{
    if (m_pCSVList)
    {
        ISPLIST*        pCurr;
        while (m_pCSVList->pNext != NULL)
        {
            pCurr = m_pCSVList;
            if (NULL != m_pCSVList->pElement)
            {
                delete pCurr->pElement;
            }
            m_pCSVList = pCurr->pNext;
            delete pCurr;
        }
        if (NULL != m_pCSVList->pElement)
            delete m_pCSVList->pElement;
        delete m_pCSVList;
        m_pCSVList = NULL;
        m_pSelectedISPInfo = NULL;
    }
}

/******************************************************************************
// These functions come from the existing ICW code and are use to setup a
// connectiod to the referral server, dial it, and perform the download.
******************************************************************************/

//+----------------------------------------------------------------------------
//    Function:    ReadConnectionInformation
//
//    Synopsis:    Read the contents from the ISP file
//
//    Arguments:    none
//
//    Returns:    error value - ERROR_SUCCESS = succes
//
//    History:    1/9/98      DONALDM     Adapted from ICW 1.x
//-----------------------------------------------------------------------------
//INT _convert;
DWORD CRefDial::ReadConnectionInformation(void)
{

    DWORD       hr;
    WCHAR       szUserName[UNLEN+1];
    WCHAR       szPassword[PWLEN+1];
    LPWSTR       pszTemp;
    BOOL        bReboot;
    LPWSTR       lpRunOnceCmd;

    bReboot = FALSE;
    lpRunOnceCmd = NULL;


    //
    // Get the name of DUN file from ISP file, if there is one.
    //
    WCHAR pszDunFile[MAX_PATH];
    *m_szCurrentDUNFile = 0;
    hr = GetDataFromISPFile(m_szISPFile, INF_SECTION_ISPINFO, INF_DUN_FILE, pszDunFile,MAX_PATH);
    if (ERROR_SUCCESS == hr)
    {
        //
        // Get the full path to the DUN File
        //
        WCHAR    szTempPath[MAX_PATH];
        lstrcpy(szTempPath, pszDunFile);
        if (!(hr = SearchPath(NULL, szTempPath,NULL,MAX_PATH,pszDunFile,&pszTemp)))
        {
            //ErrorMsg1(m_hWnd, IDS_CANTREADTHISFILE, CharUpper(pszDunFile));
            goto ReadConnectionInformationExit;
        }

        //
        // save current DUN file name in global (for ourself)
        //
        lstrcpy(m_szCurrentDUNFile, pszDunFile);
    }

    //
    // Read the DUN/ISP file File
    //

    hr = m_ISPImport.ImportConnection(*m_szCurrentDUNFile != 0 ? m_szCurrentDUNFile : m_szISPFile,
                                      m_szISPSupportNumber,
                                      m_szEntryName,
                                      szUserName,
                                      szPassword,
                                      &bReboot);

    lstrcpyn( m_szConnectoid, m_szEntryName, lstrlen(m_szEntryName) + 1);

    if (/*(VER_PLATFORM_WIN32_NT == g_dwPlatform) &&*/ (ERROR_INVALID_PARAMETER == hr))
    {
        // If there are only dial-out entries configured on NT, we get
        // ERROR_INVALID_PARAMETER returned from RasSetEntryProperties,
        // which InetConfigClient returns to ImportConnection which
        // returns it to us.  If we get this error, we want to display
        // a different error instructing the user to configure a modem
        // for dial-out.
        ////MessageBox(GetSz(IDS_NODIALOUT),
        //           GetSz(IDS_TITLE),
        //           MB_ICONERROR | MB_OK | MB_APPLMODAL);
        goto ReadConnectionInformationExit;
    }
    else
    if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == hr)
    {
        //
        // The disk is full, or something is wrong with the
        // phone book file
        ////MessageBox(GetSz(IDS_NOPHONEENTRY),
        //           GetSz(IDS_TITLE),
        //           MB_ICONERROR | MB_OK | MB_APPLMODAL);
        goto ReadConnectionInformationExit;
    }
    else if (hr == ERROR_CANCELLED)
    {
        ////TraceMsg(TF_GENERAL, L"ICWHELP: User cancelled, quitting.\n");
        goto ReadConnectionInformationExit;
    }
    else if (hr == ERROR_RETRY)
    {
        //TraceMsg(TF_GENERAL, L"ICWHELP: User retrying.\n");
        goto ReadConnectionInformationExit;
    }
    else if (hr != ERROR_SUCCESS)
    {
        ////ErrorMsg1(m_hWnd, IDS_CANTREADTHISFILE, CharUpper(pszDunFile));
        goto ReadConnectionInformationExit;
    }
    else
    {

        //
        // place the name of the connectoid in the registry
        //
        if (ERROR_SUCCESS != (hr = StoreInSignUpReg((LPBYTE)m_szEntryName, BYTES_REQUIRED_BY_SZ(m_szEntryName), REG_SZ, RASENTRYVALUENAME)))
        {
            ////MsgBox(IDS_CANTSAVEKEY, MB_MYERROR);
            goto ReadConnectionInformationExit;
        }
    }

ReadConnectionInformationExit:
    return hr;
}

HRESULT CRefDial::ReadPhoneBook(LPGATHERINFO lpGatherInfo, PSUGGESTINFO pSuggestInfo)
{
    HRESULT hr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;;
    if (pSuggestInfo && m_lpGatherInfo)
    {
        //
        // If phonenumber is not filled in by the ISP file,
        // get phone number from oobe phone book
        //

        pSuggestInfo->wNumber = 1;
        lpGatherInfo->m_bUsePhbk = TRUE;


        WCHAR   szEntrySection[3];
        WCHAR   szEntryName[MAX_PATH];
        WCHAR   szEntryValue[MAX_PATH];
        INT     nPick = 1;
        INT     nTotal= 3;

        WCHAR    szFileName[MAX_PATH];
        LPWSTR   pszTemp;

        // Get Country ID from TAPI
        m_SuggestInfo.AccessEntry.dwCountryCode = m_lpGatherInfo->m_dwCountryCode;


        // Get the name of phone book
        GetPrivateProfileString(INF_SECTION_ISPINFO,
                              INF_PHONE_BOOK,
                              cszOobePhBkFile,
                              szEntryValue,
                              MAX_CHARS_IN_BUFFER(szEntryValue),
                              m_szISPFile);


        SearchPath(NULL, szEntryValue,NULL,MAX_PATH,&szFileName[0],&pszTemp);
        wsprintf(szEntrySection, L"%ld", m_lpGatherInfo->m_dwCountryID);

        // Read the total number of phone numbers
        nTotal = GetPrivateProfileInt(szEntrySection,
                              cszOobePhBkCount,
                              1,
                              szFileName);

        GetPrivateProfileString(szEntrySection,
                              cszOobePhBkRandom,
                              L"No",
                              szEntryValue,
                              MAX_CHARS_IN_BUFFER(szEntryValue),
                              szFileName);

        if (0 == lstrcmp(szEntryValue, L"Yes"))
        {
            // Pick a random number to dial
            nPick = (rand() % nTotal) + 1;
        }
        else
        {
            nPick = (pSuggestInfo->dwPick % nTotal) + 1;
        }


        // Read the name of the city
        wsprintf(szEntryName, cszOobePhBkCity, nPick);
        GetPrivateProfileString(szEntrySection,
                              szEntryName,
                              L"",
                              szEntryValue,
                              MAX_CHARS_IN_BUFFER(szEntryValue),
                              szFileName);
        lstrcpy(pSuggestInfo->AccessEntry.szCity, szEntryValue);
        if (0 == lstrlen(szEntryValue))
        {
            goto ReadPhoneBookExit;
        }

        // Read the dunfile entry from the phonebook
        // lstrcpy(pSuggestInfo->AccessEntry.szDataCenter, L"icwip.dun");
        wsprintf(szEntryName, cszOobePhBkDunFile, nPick);
        GetPrivateProfileString(szEntrySection,
                              szEntryName,
                              L"",
                              szEntryValue,
                              MAX_CHARS_IN_BUFFER(szEntryValue),
                              szFileName);
        lstrcpy(pSuggestInfo->AccessEntry.szDataCenter, szEntryValue);
        if (0 == lstrlen(szEntryValue))
        {
            goto ReadPhoneBookExit;
        }

        // Pick up country code from the Phonebook
        wsprintf(szEntryName, cszOobePhBkAreaCode, nPick);
        GetPrivateProfileString(szEntrySection,
                              szEntryName,
                              L"",
                              szEntryValue,
                              MAX_CHARS_IN_BUFFER(szEntryValue),
                              szFileName);
        lstrcpy(pSuggestInfo->AccessEntry.szAreaCode, szEntryValue);
        // No area code is possible

        // Read the phone number (without areacode) from the Phonebook
        wsprintf(szEntryName, cszOobePhBkNumber, nPick);
        GetPrivateProfileString(szEntrySection,
                              szEntryName,
                              L"",
                              szEntryValue,
                              MAX_CHARS_IN_BUFFER(szEntryValue),
                              szFileName);
        lstrcpy(pSuggestInfo->AccessEntry.szAccessNumber, szEntryValue);
        if (0 == lstrlen(szEntryValue))
        {
            goto ReadPhoneBookExit;
        }

        hr = ERROR_SUCCESS;
    }
ReadPhoneBookExit:
    return hr;
}

HRESULT CRefDial::GetDisplayableNumber()
{
    HRESULT                 hr = ERROR_SUCCESS;
    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    LPLINETRANSLATEOUTPUT   lpOutput1 = NULL;

    DWORD dwNumDev;
    LPLINETRANSLATEOUTPUT lpOutput2;
    LPLINEEXTENSIONID lpExtensionID = NULL;

    // Turns out that DialThreadInit can call this at the same time
    // that script will call this. So, we need to prevent them from
    // stepping on shared variables - m_XXX.
    EnterCriticalSection (&m_csMyCriticalSection);

    //
    // Get phone number from connectoid
    //
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);


    if (hr != ERROR_SUCCESS || NULL == lpRasEntry)
    {
        goto GetDisplayableNumberExit;
    }

    //
    // If this is a dial as is number, just get it from the structure
    //
    m_bDialAsIs = !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes);
    if (m_bDialAsIs)
    {
        if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
        m_pszDisplayable = (LPWSTR)GlobalAlloc(GPTR, BYTES_REQUIRED_BY_SZ(lpRasEntry->szLocalPhoneNumber));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lstrcpy(m_szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
        lstrcpy(m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
        WCHAR szAreaCode[MAX_AREACODE+1];
        WCHAR szCountryCode[8];
        if (SUCCEEDED(tapiGetLocationInfo(szCountryCode, szAreaCode)))
        {
            if (szCountryCode[0] != L'\0')
                m_dwCountryCode = _wtoi(szCountryCode);
            else
                m_dwCountryCode = 1;
        }
        else
        {
            m_dwCountryCode = 1;

        }

    }
    else
    {
        //
        // If there is no area code, don't use parentheses
        //
        if (lpRasEntry->szAreaCode[0])
            wsprintf(m_szPhoneNumber, L"+%lu (%s) %s\0",lpRasEntry->dwCountryCode,
                        lpRasEntry->szAreaCode, lpRasEntry->szLocalPhoneNumber);
        else
            wsprintf(m_szPhoneNumber, L"+%lu %s\0",lpRasEntry->dwCountryCode,
                        lpRasEntry->szLocalPhoneNumber);


        //
        //  Initialize TAPIness
        //
        dwNumDev = 0;

        DWORD dwVer = 0x00020000;

        hr = lineInitializeEx(&m_hLineApp,
                              NULL,
                              LineCallback,
                              NULL,
                              &dwNumDev,
                              &dwVer,
                              NULL);

        if (hr != ERROR_SUCCESS)
            goto GetDisplayableNumberExit;

        lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR, sizeof(LINEEXTENSIONID));
        if (!lpExtensionID)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }

        if (m_dwTapiDev == 0xFFFFFFFF)
        {
                m_dwTapiDev = 0;
        }

        //
        // ChrisK Olympus 5558 6/11/97
        // PPTP device will choke the version negotiating
        //

        do {  //E_FAIL here?
            hr = lineNegotiateAPIVersion(m_hLineApp,
                                         m_dwTapiDev,
                                         0x00010004,
                                         0x00020000,
                                         &m_dwAPIVersion,
                                         lpExtensionID);

        } while (hr != ERROR_SUCCESS && m_dwTapiDev++ < dwNumDev - 1);

        if (m_dwTapiDev >= dwNumDev)
        {
            m_dwTapiDev = 0;
        }

        // ditch it since we don't use it
        //
        if (lpExtensionID) GlobalFree(lpExtensionID);
        lpExtensionID = NULL;
        if (hr != ERROR_SUCCESS)
            goto GetDisplayableNumberExit;

        // Format the phone number
        //

        lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, sizeof(LINETRANSLATEOUTPUT));
        if (!lpOutput1)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

        // Turn the canonical form into the "displayable" form
        //

        hr = lineTranslateAddress(m_hLineApp, m_dwTapiDev,m_dwAPIVersion,
                                    m_szPhoneNumber, 0,
                                    LINETRANSLATEOPTION_CANCELCALLWAITING,
                                    lpOutput1);

        // We've seen hr == ERROR_SUCCESS but the size is too small,
        // Also, the docs hint that some error cases are due to struct too small.
        if (lpOutput1->dwNeededSize > lpOutput1->dwTotalSize)
        {
            lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, (size_t)lpOutput1->dwNeededSize);
            if (!lpOutput2)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetDisplayableNumberExit;
            }
            lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
            GlobalFree(lpOutput1);
            lpOutput1 = lpOutput2;
            lpOutput2 = NULL;
            hr = lineTranslateAddress(m_hLineApp, m_dwTapiDev,
                                        m_dwAPIVersion, m_szPhoneNumber,0,
                                        LINETRANSLATEOPTION_CANCELCALLWAITING,
                                        lpOutput1);
        }

        if (hr != ERROR_SUCCESS)
        {
            goto GetDisplayableNumberExit;
        }

        if (m_pszDisplayable)
        {
            GlobalFree(m_pszDisplayable);
        }
        m_pszDisplayable = (LPWSTR)GlobalAlloc(GPTR, ((size_t)lpOutput1->dwDisplayableStringSize+1));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }

        lstrcpyn(m_pszDisplayable,
                    (LPWSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],
                    (int)(lpOutput1->dwDisplayableStringSize/sizeof(WCHAR)));

        WCHAR szAreaCode[MAX_AREACODE+1];
        WCHAR szCountryCode[8];
        if (SUCCEEDED(tapiGetLocationInfo(szCountryCode, szAreaCode)))
        {
            if (szCountryCode[0] != L'\0')
                m_dwCountryCode = _wtoi(szCountryCode);
            else
                m_dwCountryCode = 1;
        }
        else
        {
            m_dwCountryCode = 1;

        }

    }

GetDisplayableNumberExit:

    if (lpOutput1) GlobalFree(lpOutput1);
    if (m_hLineApp) lineShutdown(m_hLineApp);

    // Release ownership of the critical section
    LeaveCriticalSection (&m_csMyCriticalSection);

    return hr;
}

BOOL CRefDial::FShouldRetry(HRESULT hrErr)
{
    BOOL bRC;

    m_uiRetry++;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    bRC = bRC && m_uiRetry < MAX_RETIES;

    return bRC;
}
DWORD CRefDial:: DialThreadInit(LPVOID pdata)
{


    WCHAR               szPassword[PWLEN+1];
    WCHAR               szUserName[UNLEN + 1];
    WCHAR               szDomain[DNLEN+1];
    LPRASDIALPARAMS     lpRasDialParams = NULL;
    LPRASDIALEXTENSIONS lpRasDialExtentions = NULL;
    HRESULT             hr = ERROR_SUCCESS;
    BOOL                bPW;
    DWORD               dwResult;
    // Initialize the dial error member
    m_dwRASErr = 0;
    if (!m_pcRNA)
    {
        hr = E_FAIL;
        goto DialExit;
    }

    // Get connectoid information
    //
    lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR, sizeof(RASDIALPARAMS));
    if (!lpRasDialParams)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialExit;
    }
    lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
    lstrcpyn(lpRasDialParams->szEntryName, m_szConnectoid,MAX_CHARS_IN_BUFFER(lpRasDialParams->szEntryName));
    bPW = FALSE;
    hr = m_pcRNA->RasGetEntryDialParams(NULL, lpRasDialParams,&bPW);
    if (hr != ERROR_SUCCESS)
    {
        goto DialExit;
    }

    lpRasDialExtentions = (LPRASDIALEXTENSIONS)GlobalAlloc(GPTR, sizeof(RASDIALEXTENSIONS));
    if (lpRasDialExtentions)
    {
        lpRasDialExtentions->dwSize = sizeof(RASDIALEXTENSIONS);
        lpRasDialExtentions->dwfOptions = RDEOPT_UsePrefixSuffix;
    }


    //
    // Add the user's password
    //
    szPassword[0] = 0;
    szUserName[0] = 0;

    WCHAR   szOOBEInfoINIFile[MAX_PATH];
    SearchPath(NULL, cszOOBEINFOINI, NULL, MAX_CHARS_IN_BUFFER(szOOBEInfoINIFile), szOOBEInfoINIFile, NULL);


    GetPrivateProfileString(INFFILE_USER_SECTION,
                            INFFILE_PASSWORD,
                            NULLSZ,
                            szPassword,
                            PWLEN + 1,
                            *m_szCurrentDUNFile != 0 ? m_szCurrentDUNFile : m_szISPFile);

    if (m_lpGatherInfo->m_bUsePhbk)
    {
        if (GetPrivateProfileString(DUN_SECTION,
                                USERNAME,
                                NULLSZ,
                                szUserName,
                                UNLEN + 1,
                                szOOBEInfoINIFile))
        {
            if(szUserName[0])
                lstrcpy(lpRasDialParams->szUserName, szUserName);
        }

    }

    if(szPassword[0])
        lstrcpy(lpRasDialParams->szPassword, szPassword);

    GetPrivateProfileString(INFFILE_USER_SECTION,
                            INFFILE_DOMAIN,
                            NULLSZ,
                            szDomain,
                            DNLEN + 1,
                            *m_szCurrentDUNFile != 0 ? m_szCurrentDUNFile : m_szISPFile);
    szDomain[0]   = 0;
    if (szDomain[0])
        lstrcpy(lpRasDialParams->szDomain, szDomain);

    dwResult = m_pcRNA->RasDial(  lpRasDialExtentions,
                        NULL,
                        lpRasDialParams,
                        1,
                        CRefDial::RasDialFunc,
                        &m_hrasconn);

    if (( dwResult != ERROR_SUCCESS))
    {
        // We failed to connect for some reason, so hangup
        if (m_hrasconn)
        {
            if (m_pcRNA)
            {
                m_pcRNA->RasHangUp(m_hrasconn);
                m_hrasconn = NULL;
            }
        }
        goto DialExit;
    }

    if (m_bFromPhoneBook && (GetDisplayableNumber() == ERROR_SUCCESS))
    {
        if (m_pszOriginalDisplayable)
            GlobalFree(m_pszOriginalDisplayable);
        m_pszOriginalDisplayable = (LPWSTR)GlobalAlloc(GPTR, BYTES_REQUIRED_BY_SZ(m_pszDisplayable));
        lstrcpy(m_pszOriginalDisplayable, m_pszDisplayable);

        TRACE1(L"DialThreadInit: Dialing phone number %s", 
            m_pszOriginalDisplayable);

        m_bFromPhoneBook = FALSE;
    }

DialExit:
    if (lpRasDialParams)
        GlobalFree(lpRasDialParams);
    lpRasDialParams = NULL;

    if (lpRasDialExtentions)
        GlobalFree(lpRasDialExtentions);
    lpRasDialExtentions = NULL;

    PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_DIAL_DONE, 0, 0);
    //m_dwRASErr = RasErrorToIDS(hr);
    m_dwRASErr = hr;
    return S_OK;
}

DWORD WINAPI DoDial(LPVOID lpv)
{
    if (gpCommMgr)
        gpCommMgr->m_pRefDial->DialThreadInit(NULL);

    return 1;
}

// This function will perform the actual dialing
HRESULT CRefDial::DoConnect(BOOL * pbRetVal)
{

    //Fix for redialing, on win9x we need to make sure we "hangup"
    //and free the rna resources in case we are redialing.
    //NT - is smart enough not to need it but it won't hurt.
    if (m_hrasconn)
    {
        if (m_pcRNA)
            m_pcRNA->RasHangUp(m_hrasconn);
        m_hrasconn = NULL;
    }

    if (CONNECTED_REFFERAL == m_dwCnType)
        FormReferralServerURL(pbRetVal);

#if defined(PRERELEASE)
    if (FCampusNetOverride())
    {
        m_bModemOverride = TRUE;
        if (gpCommMgr)
        {
            // Pretend we have the connection
            PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONCONNECTED, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType , (LPARAM)0);

            // Pretend we have connection and downloaded
            //PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_DOWNLOAD_DONE, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType, (LPARAM)0);
        }
    }
#endif

    if (!m_bModemOverride)
    {
        DWORD dwThreadID;
        if (m_hThread)
            CloseHandle(m_hThread);

        m_hDialThread = CreateThread(NULL,
                                 0,
                                 (LPTHREAD_START_ROUTINE)DoDial,
                                 (LPVOID)0,
                                 0,
                                 &dwThreadID);
    }

    m_bModemOverride = FALSE;

    *pbRetVal = (NULL != m_hThread);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   MyRasGetEntryProperties()
//
//  Synopsis:   Performs some buffer size checks and then calls RasGetEntryProperties()
//                See the RasGetEntryProperties() docs to understand why this is needed.
//
//  Arguments:  Same as RasGetEntryProperties with the following exceptions:
//                lplpRasEntryBuff -- pointer to a pointer to a RASENTRY struct.  On successfull
//                                    return, *lplpRasEntryBuff will point to the RASENTRY struct
//                                    and buffer returned by RasGetEntryProperties.
//                                    NOTE: should not have memory allocated to it at call time!
//                                          To emphasize this point, *lplpRasEntryBuff must be NULL
//                lplpRasDevInfoBuff -- pointer to a pointer to a RASDEVINFO struct.  On successfull
//                                    return, *lplpRasDevInfoBuff will point to the RASDEVINFO struct
//                                    and buffer returned by RasGetEntryProperties.
//                                    NOTE: should not have memory allocated to it at call time!
//                                          To emphasize this point, *lplpRasDevInfoBuff must be NULL
//                                    NOTE: Even on a successfull call to RasGetEntryProperties,
//                                          *lplpRasDevInfoBuff may return with a value of NULL
//                                          (occurs when there is no extra device info)
//
//    Returns:    ERROR_NOT_ENOUGH_MEMORY if unable to allocate either RASENTRY or RASDEVINFO buffer
//                Otherwise, it retuns the error code from the call to RasGetEntryProperties.
//                NOTE: if return is anything other than ERROR_SUCCESS, *lplpRasDevInfoBuff and
//                      *lplpRasEntryBuff will be NULL,
//                      and *lpdwRasEntryBuffSize and *lpdwRasDevInfoBuffSize will be 0
//
//  Example:
//
//      LPRASENTRY    lpRasEntry = NULL;
//      LPRASDEVINFO  lpRasDevInfo = NULL;
//      DWORD            dwRasEntrySize, dwRasDevInfoSize;
//
//      hr = MyRasGetEntryProperties( NULL,
//                                      g_pcDialErr->m_szConnectoid,
//                                    &lpRasEntry,
//                                    &dwRasEntrySize,
//                                    &lpRasDevInfo,
//                                    &dwRasDevInfoSize);
//
//
//      if (hr != ERROR_SUCCESS)
//      {
//            //handle errors here
//      } else
//      {
//            //continue processing
//      }
//
//
//  History:    9/10/96     JMazner        Created for icwconn2
//                9/17/96        JMazner        Adapted for icwconn1
//              1/8/98      DONALDM     Moved to the new ICW/GetConn project
//----------------------------------------------------------------------------
HRESULT CRefDial::MyRasGetEntryProperties(LPWSTR lpszPhonebookFile,
                                LPWSTR lpszPhonebookEntry,
                                LPRASENTRY *lplpRasEntryBuff,
                                LPDWORD lpdwRasEntryBuffSize,
                                LPRASDEVINFO *lplpRasDevInfoBuff,
                                LPDWORD lpdwRasDevInfoBuffSize)
{

    HRESULT hr;
    DWORD dwOldDevInfoBuffSize;

    //Assert( NULL != lplpRasEntryBuff );
    //Assert( NULL != lpdwRasEntryBuffSize );
    //Assert( NULL != lplpRasDevInfoBuff );
    //Assert( NULL != lpdwRasDevInfoBuffSize );

    *lpdwRasEntryBuffSize = 0;
    *lpdwRasDevInfoBuffSize = 0;

    if (!m_pcRNA)
    {
        m_pcRNA = new RNAAPI;
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MyRasGetEntryPropertiesErrExit;
    }

    // use RasGetEntryProperties with a NULL lpRasEntry pointer to find out size buffer we need
    // As per the docs' recommendation, do the same with a NULL lpRasDevInfo pointer.

    hr = m_pcRNA->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
                                (LPBYTE) NULL,
                                lpdwRasEntryBuffSize,
                                (LPBYTE) NULL,
                                lpdwRasDevInfoBuffSize);

    // we expect the above call to fail because the buffer size is 0
    // If it doesn't fail, that means our RasEntry is messed, so we're in trouble
    if( ERROR_BUFFER_TOO_SMALL != hr )
    {
        goto MyRasGetEntryPropertiesErrExit;
    }

    // dwRasEntryBuffSize and dwRasDevInfoBuffSize now contain the size needed for their
    // respective buffers, so allocate the memory for them

    // dwRasEntryBuffSize should never be less than the size of the RASENTRY struct.
    // If it is, we'll run into problems sticking values into the struct's fields

    //Assert( *lpdwRasEntryBuffSize >= sizeof(RASENTRY) );

    if (m_reflpRasEntryBuff)
    {
        if (*lpdwRasEntryBuffSize > m_reflpRasEntryBuff->dwSize)
        {
            m_reflpRasEntryBuff = (LPRASENTRY)GlobalReAlloc(m_reflpRasEntryBuff, *lpdwRasEntryBuffSize, GPTR);
        }
    }
    else
    {
        m_reflpRasEntryBuff = (LPRASENTRY)GlobalAlloc(GPTR, *lpdwRasEntryBuffSize);
    }


    if (!m_reflpRasEntryBuff)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MyRasGetEntryPropertiesErrExit;
    }

    // This is a bit convoluted:  lpRasEntrySize->dwSize needs to contain the size of _only_ the
    // RASENTRY structure, and _not_ the actual size of the buffer that lpRasEntrySize points to.
    // This is because the dwSize field is used by RAS for compatability purposes to determine which
    // version of the RASENTRY struct we're using.
    // Same holds for lpRasDevInfo->dwSize

    m_reflpRasEntryBuff->dwSize = sizeof(RASENTRY);

    //
    // Allocate the DeviceInfo size that RasGetEntryProperties told us we needed.
    // If size is 0, don't alloc anything
    //
    if( *lpdwRasDevInfoBuffSize > 0 )
    {
        //Assert( *lpdwRasDevInfoBuffSize >= sizeof(RASDEVINFO) );
        if (m_reflpRasDevInfoBuff)
        {
            // check if existing size is not sufficient
            if ( *lpdwRasDevInfoBuffSize > m_reflpRasDevInfoBuff->dwSize )
            {
                m_reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalReAlloc(m_reflpRasDevInfoBuff, *lpdwRasDevInfoBuffSize, GPTR);
            }
        }
        else
        {
            m_reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalAlloc(GPTR, *lpdwRasDevInfoBuffSize);
        }

        if (!m_reflpRasDevInfoBuff)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto MyRasGetEntryPropertiesErrExit;
        }
    }
    else
    {
        m_reflpRasDevInfoBuff = NULL;
    }

    if( m_reflpRasDevInfoBuff )
    {
        m_reflpRasDevInfoBuff->dwSize = sizeof(RASDEVINFO);
    }


    // now we're ready to make the actual call...

    // jmazner   see below for why this is needed
    dwOldDevInfoBuffSize = *lpdwRasDevInfoBuffSize;

    hr = m_pcRNA->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
                                (LPBYTE) m_reflpRasEntryBuff,
                                lpdwRasEntryBuffSize,
                                (LPBYTE) m_reflpRasDevInfoBuff,
                                lpdwRasDevInfoBuffSize);

    // jmazner 10/7/96  Normandy #8763
    // For unknown reasons, in some cases on win95, devInfoBuffSize increases after the above call,
    // but the return code indicates success, not BUFFER_TOO_SMALL.  If this happens, set the
    // size back to what it was before the call, so the DevInfoBuffSize and the actuall space allocated
    // for the DevInfoBuff match on exit.
    if( (ERROR_SUCCESS == hr) && (dwOldDevInfoBuffSize != *lpdwRasDevInfoBuffSize) )
    {
        *lpdwRasDevInfoBuffSize = dwOldDevInfoBuffSize;
    }

    *lplpRasEntryBuff = m_reflpRasEntryBuff;
    *lplpRasDevInfoBuff = m_reflpRasDevInfoBuff;

    return( hr );

MyRasGetEntryPropertiesErrExit:

    if(m_reflpRasEntryBuff)
    {
        GlobalFree(m_reflpRasEntryBuff);
        m_reflpRasEntryBuff = NULL;
        *lplpRasEntryBuff = NULL;
    }
    if(m_reflpRasDevInfoBuff)
    {
        GlobalFree(m_reflpRasDevInfoBuff);
        m_reflpRasDevInfoBuff = NULL;
        *lplpRasDevInfoBuff = NULL;
    }
    *lpdwRasEntryBuffSize = 0;
    *lpdwRasDevInfoBuffSize = 0;

    return( hr );
}



HRESULT MyGetFileVersion(LPCWSTR pszFileName, LPGATHERINFO lpGatherInfo)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD   dwSize = 0;
    DWORD   dwTemp = 0;
    LPVOID  pv = NULL, pvVerInfo = NULL;
    UINT    uiSize;
    DWORD   dwVerPiece;
    //int idx;


    // verify parameters
    //
    //Assert(pszFileName && lpGatherInfo);

    // Get version
    //
    dwSize = GetFileVersionInfoSize((LPWSTR)pszFileName, &dwTemp);
    if (!dwSize)
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }
    pv = (LPVOID)GlobalAlloc(GPTR, (size_t)dwSize);
    if (!pv) goto MyGetFileVersionExit;
    if (!GetFileVersionInfo((LPWSTR)pszFileName, dwTemp,dwSize,pv))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }

    if (!VerQueryValue(pv, L"\\\0",&pvVerInfo,&uiSize))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }
    pvVerInfo = (LPVOID)((DWORD_PTR)pvVerInfo + sizeof(DWORD)*4);
    lpGatherInfo->m_szSUVersion[0] = L'\0';
    dwVerPiece = (*((LPDWORD)pvVerInfo)) >> 16;
    wsprintf(lpGatherInfo->m_szSUVersion, L"%d.",dwVerPiece);

    dwVerPiece = (*((LPDWORD)pvVerInfo)) & 0x0000ffff;
    wsprintf(lpGatherInfo->m_szSUVersion, L"%s%d.",lpGatherInfo->m_szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)pvVerInfo)[1]) >> 16;
    wsprintf(lpGatherInfo->m_szSUVersion, L"%s%d.",lpGatherInfo->m_szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)pvVerInfo)[1]) & 0x0000ffff;
    wsprintf(lpGatherInfo->m_szSUVersion, L"%s%d",lpGatherInfo->m_szSUVersion,dwVerPiece);

    if (!VerQueryValue(pv, L"\\VarFileInfo\\Translation",&pvVerInfo,&uiSize))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }

    // separate version information from character set
    lpGatherInfo->m_lcidApps = (LCID)(LOWORD(*(DWORD*)pvVerInfo));

    hr = ERROR_SUCCESS;

MyGetFileVersionExit:
    if (pv) GlobalFree(pv);

    return hr;
}

DWORD CRefDial::FillGatherInfoStruct(LPGATHERINFO lpGatherInfo)
{
    HKEY        hkey = NULL;
    SYSTEM_INFO si;
    WCHAR        szTempPath[MAX_PATH];
    DWORD       dwRet = ERROR_SUCCESS;

    lpGatherInfo->m_lcidUser  = GetUserDefaultLCID();
    lpGatherInfo->m_lcidSys   = GetSystemDefaultLCID();

    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

     if (!GetVersionEx(&osvi))
    {
        // Nevermind, we'll just assume the version is 0.0 if we can't read it
        //
        ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    }

    lpGatherInfo->m_dwOS = osvi.dwPlatformId;
    lpGatherInfo->m_dwMajorVersion = osvi.dwMajorVersion;
    lpGatherInfo->m_dwMinorVersion = osvi.dwMinorVersion;

    ZeroMemory(&si, sizeof(SYSTEM_INFO));
    GetSystemInfo(&si);

    lpGatherInfo->m_wArchitecture = si.wProcessorArchitecture;

    // Sign-up version
    //
    lpGatherInfo->m_szSUVersion[0] = L'\0';
    if( GetModuleFileName(0/*_Module.GetModuleInstance()*/, szTempPath, MAX_PATH))
    {
        if ((MyGetFileVersion(szTempPath, lpGatherInfo)) != ERROR_SUCCESS)
        {
            return (GetLastError());
        }
    }
    else
        return( GetLastError() );


    // 2/20/97    jmazner    Olympus #259
    if ( RegOpenKey(HKEY_LOCAL_MACHINE, ICWSETTINGSPATH,&hkey) == ERROR_SUCCESS)
    {
        DWORD dwSize;
        DWORD dwType;
        dwType = REG_SZ;
        dwSize = BYTES_REQUIRED_BY_CCH(MAX_RELPROD + 1);
        if (RegQueryValueEx(hkey, RELEASEPRODUCTKEY,NULL,&dwType,(LPBYTE)&lpGatherInfo->m_szRelProd[0],&dwSize) != ERROR_SUCCESS)
            lpGatherInfo->m_szRelProd[0] = L'\0';

        dwSize = BYTES_REQUIRED_BY_CCH(MAX_RELVER + 1);
        if (RegQueryValueEx(hkey, RELEASEVERSIONKEY,NULL,&dwType,(LPBYTE)&lpGatherInfo->m_szRelVer[0],&dwSize) != ERROR_SUCCESS)
            lpGatherInfo->m_szRelVer[0] = L'\0';


        RegCloseKey(hkey);
    }

    // PromoCode
    lpGatherInfo->m_szPromo[0] = L'\0';

    WCHAR    szPIDPath[MAX_PATH];        // Reg path to the PID

    // Form the Path, it is HKLM\\Software\\Microsoft\Windows[ NT]\\CurrentVersion
    lstrcpy(szPIDPath, L"");


    // Form the Path, it is HKLM\\Software\\Microsoft\Windows[ NT]\\CurrentVersion
    lstrcpy(szPIDPath, L"Software\\Microsoft\\Windows");
    lstrcat(szPIDPath, L"\\CurrentVersion");

    BYTE    byDigitalPID[MAX_DIGITAL_PID];

    // Get the Product ID for this machine
    if ( RegOpenKey(HKEY_LOCAL_MACHINE, szPIDPath,&hkey) == ERROR_SUCCESS)
    {
        DWORD dwSize;
        DWORD dwType;
        dwType = REG_BINARY;
        dwSize = sizeof(byDigitalPID);
        if (RegQueryValueEx(hkey,
                            c_szRegStrValDigitalPID,
                            NULL,
                            &dwType,
                            (LPBYTE)byDigitalPID,
                            &dwSize) == ERROR_SUCCESS)
        {
            // BINHEX the digital PID data so we can send it to the ref_server
            int     i = 0;
            BYTE    by;
            for (DWORD dwX = 0; dwX < dwSize; dwX++)
            {
                by = byDigitalPID[dwX];
                m_szPID[i++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                m_szPID[i++] = g_BINTOHEXLookup[(by & 0x0F)];
            }
            m_szPID[i] = L'\0';
        }
        else
        {
            m_szPID[0] = L'\0';
        }
        RegCloseKey(hkey);
    }
    return( dwRet );
}

// ############################################################################
HRESULT CRefDial::CreateEntryFromDUNFile(LPWSTR pszDunFile)
{
    WCHAR    szFileName[MAX_PATH];
    WCHAR    szUserName[UNLEN+1];
    WCHAR    szPassword[PWLEN+1];
    LPWSTR   pszTemp;
    HRESULT hr;
    BOOL    fNeedsRestart=FALSE;


    hr = ERROR_SUCCESS;

    // Get fully qualified path name
    //

    if (!SearchPath(NULL, pszDunFile,NULL,MAX_PATH,&szFileName[0],&pszTemp))
    {
        hr = ERROR_FILE_NOT_FOUND;
        goto CreateEntryFromDUNFileExit;
    }

    // save current DUN file name in global
    lstrcpy(m_szCurrentDUNFile, &szFileName[0]);

    hr = m_ISPImport.ImportConnection (&szFileName[0], m_szISPSupportNumber, m_szEntryName, szUserName, szPassword, &fNeedsRestart);

    // place the name of the connectoid in the registry
    //
    if (ERROR_SUCCESS != (StoreInSignUpReg((LPBYTE)m_szEntryName,
                BYTES_REQUIRED_BY_SZ(m_szEntryName),
                REG_SZ, RASENTRYVALUENAME)))
    {
        goto CreateEntryFromDUNFileExit;
    }
    lstrcpy(m_szLastDUNFile, pszDunFile);

CreateEntryFromDUNFileExit:
    return hr;
}



HRESULT CRefDial::SetupForRASDialing
(
    LPGATHERINFO lpGatherInfo,
    HINSTANCE hPHBKDll,
    LPDWORD lpdwPhoneBook,
    PSUGGESTINFO pSuggestInfo,
    WCHAR *pszConnectoid,
    BOOL FAR *bConnectiodCreated
)
{

    WCHAR           szEntry[MAX_RASENTRYNAME];
    DWORD           dwSize              = BYTES_REQUIRED_BY_CCH(MAX_RASENTRYNAME);
    RASENTRY        *prasentry          = NULL;
    RASDEVINFO      *prasdevinfo        = NULL;
    DWORD           dwRasentrySize      = 0;
    DWORD           dwRasdevinfoSize    = 0;
    HINSTANCE       hRasDll             = NULL;
    LPRASCONN       lprasconn           = NULL;
    HRESULT         hr                  = ERROR_NOT_ENOUGH_MEMORY;
    m_bUserInitiateHangup = FALSE;

    // Load the connectoid
    //
    if (!m_pcRNA)
        m_pcRNA = new RNAAPI;
    if (!m_pcRNA)
        goto SetupForRASDialingExit;

    prasentry = (RASENTRY*)GlobalAlloc(GPTR, sizeof(RASENTRY)+2);
    //Assert(prasentry);
    if (!prasentry)
    {
        hr = GetLastError();
        goto SetupForRASDialingExit;
    }
    prasentry->dwSize = sizeof(RASENTRY);
    dwRasentrySize = sizeof(RASENTRY);


    prasdevinfo = (RASDEVINFO*)GlobalAlloc(GPTR, sizeof(RASDEVINFO));

    if (!prasdevinfo)
    {
        hr = GetLastError();
        goto SetupForRASDialingExit;
    }
    prasdevinfo->dwSize = sizeof(RASDEVINFO);
    dwRasdevinfoSize = sizeof(RASDEVINFO);


    hr = ReadSignUpReg((LPBYTE)&szEntry[0], &dwSize, REG_SZ,
                        RASENTRYVALUENAME);
    if (hr != ERROR_SUCCESS)
        goto SetupForRASDialingExit;

    hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry,
                                            (LPBYTE)prasentry,
                                            &dwRasentrySize,
                                            (LPBYTE)prasdevinfo,
                                            &dwRasdevinfoSize);
    if (hr == ERROR_BUFFER_TOO_SMALL)
    {
        GlobalFree(prasentry);
        prasentry = (RASENTRY*)GlobalAlloc(GPTR, ((size_t)dwRasentrySize));
        prasentry->dwSize = dwRasentrySize;

        GlobalFree(prasdevinfo);
        prasdevinfo = (RASDEVINFO*)GlobalAlloc(GPTR, ((size_t)dwRasdevinfoSize));
        prasdevinfo->dwSize = dwRasdevinfoSize;
        hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry,
                                                (LPBYTE)prasentry,
                                                &dwRasentrySize,
                                                (LPBYTE)prasdevinfo,
                                                &dwRasdevinfoSize);
    }
    if (hr != ERROR_SUCCESS)
        goto SetupForRASDialingExit;

    //
    // Check to see if the phone number was filled in
    //
    if (lstrcmp(&prasentry->szLocalPhoneNumber[0], DUN_NOPHONENUMBER) == 0)
    {
        //
        // If phonenumber is not filled in by the ISP file,
        // get phone number from oobe phone book
        //
        m_bFromPhoneBook = TRUE;
        hr = ReadPhoneBook(lpGatherInfo, pSuggestInfo);
    }
    else
    {
        ZeroMemory(pszConnectoid, dwSize);
        hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ,
                           RASENTRYVALUENAME);
        if (hr != ERROR_SUCCESS)
            goto SetupForRASDialingExit;

        // Use the RASENTRY that we have to create the connectiod
        hr = m_pcRNA->RasSetEntryProperties(NULL,
                                            pszConnectoid,
                                            (LPBYTE)prasentry,
                                            dwRasentrySize,
                                            (LPBYTE)prasdevinfo,
                                            dwRasdevinfoSize);
        *bConnectiodCreated = TRUE;
    }

SetupForRASDialingExit:
    if (prasentry)
        GlobalFree(prasentry);
    if (prasdevinfo)
        GlobalFree(prasdevinfo);

    return hr;
}



// 10/22/96    jmazner    Normandy #9923
// Since in SetupConnectoidExit we're treating results other than ERROR_SUCCESS as
// indicating successfull completion, we need bSuccess to provide a simple way for the
// caller to tell whether the function completed.
HRESULT CRefDial::SetupConnectoid
(
    PSUGGESTINFO    pSuggestInfo,
    int             irc,
    WCHAR            *pszConnectoid,
    DWORD           dwSize,
    BOOL            *pbSuccess
)
{

    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    RASENTRY    *prasentry = NULL;
    RASDEVINFO  *prasdevinfo = NULL;
    DWORD       dwRasentrySize = 0;
    DWORD       dwRasdevinfoSize = 0;
    HINSTANCE   hPHBKDll = NULL;
    HINSTANCE   hRasDll =NULL;

    LPWSTR       lpszSetupFile;
    LPRASCONN   lprasconn = NULL;

    //Assert(pbSuccess);

    if (!pSuggestInfo)
    {
        hr = ERROR_PHBK_NOT_FOUND;
        goto SetupConnectoidExit;
    }

    lpszSetupFile = *m_szCurrentDUNFile != 0 ? m_szCurrentDUNFile : m_szISPFile;

    WCHAR    szFileName[MAX_PATH];
    LPWSTR   pszTemp;

    SearchPath(NULL, pSuggestInfo->AccessEntry.szDataCenter,NULL,MAX_PATH,&szFileName[0],&pszTemp);

    if(0 != lstrcmpi(m_szCurrentDUNFile, szFileName))
    {
        hr = CreateEntryFromDUNFile(pSuggestInfo->AccessEntry.szDataCenter);
        if (hr == ERROR_SUCCESS)
        {
            ZeroMemory(pszConnectoid, dwSize);
            hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ,
                               RASENTRYVALUENAME);
            if (hr != ERROR_SUCCESS)
                goto SetupConnectoidExit;

            if( prasentry )
            {
                GlobalFree( prasentry );
                prasentry = NULL;
                dwRasentrySize = NULL;
            }

            if( prasdevinfo )
            {
                GlobalFree( prasdevinfo );
                prasdevinfo = NULL;
                dwRasdevinfoSize = NULL;
            }
        }
        else
        {
            // 10/22/96    jmazner    Normandy #9923
            goto SetupConnectoidExit;
        }
    }

    hr = MyRasGetEntryProperties(NULL,
                                pszConnectoid,
                                &prasentry,
                                &dwRasentrySize,
                                &prasdevinfo,
                                &dwRasdevinfoSize);
    if (hr != ERROR_SUCCESS || NULL == prasentry)
        goto SetupConnectoidExit;
    /*
    else
    {
        goto SetupConnectoidExit;
    }*/

    prasentry->dwCountryID = pSuggestInfo->AccessEntry.dwCountryID;

    lstrcpyn(prasentry->szAreaCode,
                pSuggestInfo->AccessEntry.szAreaCode,
                MAX_CHARS_IN_BUFFER(prasentry->szAreaCode));
    lstrcpyn(prasentry->szLocalPhoneNumber,
                pSuggestInfo->AccessEntry.szAccessNumber,
                MAX_CHARS_IN_BUFFER(prasentry->szLocalPhoneNumber));

    prasentry->dwCountryCode = 0;
    prasentry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

    // 10/19/96 jmazner Multiple modems problems
    // If no device name and type has been specified, grab the one we've stored
    // in ConfigRasEntryDevice

    if( 0 == lstrlen(prasentry->szDeviceName) )
    {
        // doesn't make sense to have an empty device name but a valid device type
        //Assert( 0 == lstrlen(prasentry->szDeviceType) );

        // double check that we've already stored the user's choice.
        //Assert( lstrlen(m_ISPImport.m_szDeviceName) );
        //Assert( lstrlen(m_ISPImport.m_szDeviceType) );

        lstrcpyn( prasentry->szDeviceName, m_ISPImport.m_szDeviceName, lstrlen(m_ISPImport.m_szDeviceName) );
        lstrcpyn( prasentry->szDeviceType, m_ISPImport.m_szDeviceType, lstrlen(m_ISPImport.m_szDeviceType) );
    }

    // Write out new connectoid
    if (m_pcRNA)
        hr = m_pcRNA->RasSetEntryProperties(NULL, pszConnectoid,
                                                (LPBYTE)prasentry,
                                                dwRasentrySize,
                                                (LPBYTE)prasdevinfo,
                                                dwRasdevinfoSize);


    // Set this connetiod to have not proxy enabled
    /*
    WCHAR        szConnectionProfile[REGSTR_MAX_VALUE_LENGTH];

    lstrcpy(szConnectionProfile, c_szRASProfiles);
    lstrcat(szConnectionProfile, L"\\");
    lstrcat(szConnectionProfile,  pszConnectoid);

    reg.CreateKey(HKEY_CURRENT_USER, szConnectionProfile);
    reg.SetValue(c_szProxyEnable, (DWORD)0);*/


SetupConnectoidExit:

    *pbSuccess = FALSE;

    if (hr == ERROR_SUCCESS)
        *pbSuccess = TRUE;
    return hr;
}

void CRefDial::GetISPFileSettings(LPWSTR lpszFile)
{

    WCHAR szTemp[INTERNET_MAX_URL_LENGTH];

    /*GetINTFromISPFile(lpszFile,
                      (LPWSTR)cszBrandingSection,
                      (LPWSTR)cszBrandingFlags,
                      (int FAR *)&m_lBrandingFlags,
                      BRAND_DEFAULT);*/

    // Read the Support Number
    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPWSTR)cszSupportSection,
                                     (LPWSTR)cszSupportNumber,
                                     szTemp,
                                     MAX_CHARS_IN_BUFFER(szTemp)))
    {
        m_bstrSupportNumber= SysAllocString(szTemp);
    }
    else
        m_bstrSupportNumber = NULL;


    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPWSTR)cszLoggingSection,
                                     (LPWSTR)cszStartURL,
                                     szTemp,
                                     MAX_CHARS_IN_BUFFER(szTemp)))
    {
        m_bstrLoggingStartUrl = SysAllocString(szTemp);
    }
    else
        m_bstrLoggingStartUrl = NULL;


    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPWSTR)cszLoggingSection,
                                     (LPWSTR)cszEndURL,
                                     szTemp,
                                     MAX_CHARS_IN_BUFFER(szTemp)))
    {
        m_bstrLoggingEndUrl = SysAllocString(szTemp);
    }
    else
        m_bstrLoggingEndUrl = NULL;


}


// This function will accept user selected values that are necessary to
// setup a connectiod for dialing
// Returns:
//      TRUE        OK to dial
//      FALSE       Some kind of problem
//                  QuitWizard - TRUE, then terminate
//                  UserPickNumber - TRUE, then display Pick a Number DLG
//                  QuitWizard and UserPickNumber both FALSE, then just
//                  display the page prior to Dialing UI.
HRESULT CRefDial::SetupForDialing
(
    UINT nType,
    BSTR bstrISPFile,
    DWORD dwCountry,
    BSTR bstrAreaCode,
    DWORD dwFlag,
    DWORD dwAppMode,
    DWORD dwMigISPIdx,
    LPCWSTR szRasDeviceName
)
{
    HRESULT             hr = S_OK;
    long                lRC = 0;
    HINSTANCE           hPHBKDll = NULL;
    DWORD               dwPhoneBook = 0;
    BOOL                bSuccess = FALSE;
    BOOL                bConnectiodCreated = FALSE;
    LPWSTR   pszTemp;
    WCHAR    szISPPath[MAX_PATH];
    WCHAR    szShortISPPath[MAX_PATH];

    CleanupAutodial();

    m_dwCnType = nType;
    if (!bstrAreaCode)
        goto SetupForDialingExit;

    if (CONNECTED_ISP_MIGRATE == m_dwCnType)  // ACCOUNT MIGRATION
    {
        if (!m_pCSVList)
            ParseISPInfo(NULL, ICW_ISPINFOPath, TRUE);
        if (m_pCSVList && (dwMigISPIdx < m_dwNumOfAutoConfigOffers))
        {
            ISPLIST*        pCurr = m_pCSVList;
            for( UINT i = 0; i < dwMigISPIdx && pCurr->pNext != NULL; i++)
                pCurr = pCurr->pNext;

            if (NULL != (m_pSelectedISPInfo = (CISPCSV *) pCurr->pElement))
            {
                lstrcpy(szShortISPPath, m_pSelectedISPInfo->get_szISPFilePath());
            }
        }
    }
    else // ISP FILE SIGNUP
    {
        if (!bstrISPFile)
            goto SetupForDialingExit;
        lstrcpyn(szShortISPPath, bstrISPFile, MAX_PATH);

    }

    // Locate ISP file
    if (!SearchPath(NULL, szShortISPPath,INF_SUFFIX,MAX_PATH,szISPPath,&pszTemp))
    {
        hr = ERROR_FILE_NOT_FOUND;
        goto SetupForDialingExit;
    }


    if(0 == lstrcmpi(m_szISPFile, szISPPath) &&
       0 == lstrcmpi(m_lpGatherInfo->m_szAreaCode, bstrAreaCode) &&
       m_lpGatherInfo->m_dwCountryID == dwCountry)
    {
        if (m_bDialCustom)
        {
            m_bDialCustom = FALSE;
            return S_OK;
        }
        // If ISP file is the same, no need to recreate connectoid
        // Modify the connectiod here

        // If we used the phonebook for this connectoid, we need to
        // continue and import the dun files. Otherwise, we are done
        if (!m_lpGatherInfo->m_bUsePhbk)
        {
            return S_OK;
        }
        if (m_bDialAlternative)
        {
            m_SuggestInfo.dwPick++;
        }
    }
    else
    {
        BOOL bRet;
        RemoveConnectoid(&bRet);
        m_SuggestInfo.dwPick = 0;
        m_bDialCustom = FALSE;
    }

    if (CONNECTED_REFFERAL == m_dwCnType)
    {
        // Check whether the isp file is ICW capable by reading the referral URL
        GetPrivateProfileString(INF_SECTION_ISPINFO,
                            c_szURLReferral,
                            L"",
                            m_szRefServerURL,
                            INTERNET_MAX_URL_LENGTH,
                            szISPPath);
    }


    lstrcpy(m_szISPFile, szISPPath);

    m_dwAppMode = dwAppMode;

    // Initialize failure codes
    m_bQuitWizard = FALSE;
    m_bUserPickNumber = FALSE;
    m_lpGatherInfo->m_bUsePhbk = FALSE;


    // Stuff the Area Code, and Country Code into the GatherInfo struct

    m_lpGatherInfo->m_dwCountryID = dwCountry;
    m_lpGatherInfo->m_dwCountryCode = dwFlag;

    lstrcpyn(
        m_lpGatherInfo->m_szAreaCode,
        bstrAreaCode,
        MAX_CHARS_IN_BUFFER(m_lpGatherInfo->m_szAreaCode)
        );


    m_SuggestInfo.AccessEntry.dwCountryID = dwCountry;
    m_SuggestInfo.AccessEntry.dwCountryCode = dwFlag;
    lstrcpy(m_SuggestInfo.AccessEntry.szAreaCode, bstrAreaCode);

    GetISPFileSettings(szISPPath);

    lstrcpyn(
        m_ISPImport.m_szDeviceName,
        szRasDeviceName,
        MAX_CHARS_IN_BUFFER(m_ISPImport.m_szDeviceName)
        );
    
    // Read the Connection File information which will create
    // a connectiod from the passed in ISP file
    hr = ReadConnectionInformation();

    //  If we failed for some reason above, we need to return
    //  the error to the caller, and Quit The Wizard.
    if (S_OK != hr)
        goto SetupForDialingExit;
    FillGatherInfoStruct(m_lpGatherInfo);

    // Setup, and possible create a connectiod
    hr = SetupForRASDialing(m_lpGatherInfo,
                         hPHBKDll,
                         &dwPhoneBook,
                         &m_SuggestInfo,
                         &m_szConnectoid[0],
                         &bConnectiodCreated);
    if (ERROR_SUCCESS != hr)
    {
        m_bQuitWizard = TRUE;
        goto SetupForDialingExit;
    }

    // If we have a RASENTRY struct from SetupForRASDialing, then just use it
    // otherwise use the suggest info
    if (!bConnectiodCreated)
    {

        // If there is only 1 suggested number, then we setup the
        // connectiod, and we are ready to dial
        if (1 == m_SuggestInfo.wNumber)
        {
            hr = SetupConnectoid(&m_SuggestInfo, 0, &m_szConnectoid[0],
                                sizeof(m_szConnectoid), &bSuccess);
            if( !bSuccess )
            {
                goto SetupForDialingExit;
            }
        }
        else
        {
            // More than 1 entry in the Phonebook, so we need to
            // ask the user which one they want to use
            hr = ERROR_FILE_NOT_FOUND;
            goto SetupForDialingExit;
        }
    }

    // Success if we get to here


SetupForDialingExit:

    if (ERROR_SUCCESS != hr)
        *m_szISPFile = 0;
    return hr;
}

HRESULT CRefDial::CheckPhoneBook
(
    BSTR bstrISPFile,
    DWORD dwCountry,
    BSTR bstrAreaCode,
    DWORD dwFlag,
    BOOL *pbRetVal
)
{
    HRESULT             hr = S_OK;
    long                lRC = 0;
    HINSTANCE           hPHBKDll = NULL;
    DWORD               dwPhoneBook = 0;
    BOOL                bSuccess = FALSE;
    BOOL                bConnectiodCreated = FALSE;
    LPWSTR              pszTemp;
    WCHAR               szISPPath[MAX_PATH];

    *pbRetVal = FALSE;
    if (!bstrISPFile || !bstrAreaCode)
    {
        hr = ERROR_FILE_NOT_FOUND;
        goto CheckPhoneBookExit;
    }

    // Locate ISP file
    if (!SearchPath(NULL, bstrISPFile,INF_SUFFIX,MAX_PATH,szISPPath,&pszTemp))
    {
        hr = ERROR_FILE_NOT_FOUND;
        goto CheckPhoneBookExit;
    }

    //lstrcpy(m_szISPFile, szISPPath);

    // Stuff the Area Code, and Country Code into the GatherInfo struct

    m_lpGatherInfo->m_dwCountryID = dwCountry;
    m_lpGatherInfo->m_dwCountryCode = dwFlag;

    lstrcpy(m_lpGatherInfo->m_szAreaCode, bstrAreaCode);


    m_SuggestInfo.AccessEntry.dwCountryID = dwCountry;
    m_SuggestInfo.AccessEntry.dwCountryCode = dwFlag;
    lstrcpy(m_SuggestInfo.AccessEntry.szAreaCode, bstrAreaCode);

    //
    // If phonenumber is not filled in by the ISP file,
    // get phone number from oobe phone book
    //
    hr = ReadPhoneBook(m_lpGatherInfo, &m_SuggestInfo);

    if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != hr)
        *pbRetVal = TRUE;


CheckPhoneBookExit:
    return hr;
}


// This function will determine if we can connect to the next server in
// the same phone call
// Returns:
//      S_OK        OK to stay connected
//      E_FAIL      Need to redial
HRESULT CRefDial::CheckStayConnected(BSTR bstrISPFile, BOOL *pbVal)
{
    BOOL                bSuccess    = FALSE;
    LPWSTR   pszTemp;
    WCHAR    szISPPath[MAX_PATH];

    *pbVal = FALSE;
    // Locate ISP file
    if (SearchPath(NULL, bstrISPFile,INF_SUFFIX,MAX_PATH,szISPPath,&pszTemp))
    {
        if (GetPrivateProfileInt(INF_SECTION_CONNECTION,
                                            c_szStayConnected,
                                            0,
                                            szISPPath))
        {
            *pbVal = TRUE;
        }
    }
    return S_OK;
}
HRESULT CRefDial::RemoveConnectoid(BOOL * pVal)
{
    if (m_hrasconn)
        DoHangup();

    if( (m_pcRNA!=NULL) && (m_szConnectoid[0]!=L'\0') )
    {
       m_pcRNA->RasDeleteEntry(NULL, m_szConnectoid);
    }
    return S_OK;
}

HRESULT CRefDial::GetDialPhoneNumber(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // Generate a Displayable number
    if (GetDisplayableNumber() == ERROR_SUCCESS)
        *pVal = SysAllocString(m_pszDisplayable);
    else
        *pVal = SysAllocString(m_szPhoneNumber);

    return S_OK;
}

HRESULT CRefDial::GetPhoneBookNumber(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // Generate a Displayable number
    if (m_pszOriginalDisplayable)
        *pVal = SysAllocString(m_pszOriginalDisplayable);
    else if (GetDisplayableNumber() == ERROR_SUCCESS)
        *pVal = SysAllocString(m_pszDisplayable);
    else
        *pVal = SysAllocString(m_szPhoneNumber);

    return S_OK;
}

HRESULT CRefDial::PutDialPhoneNumber(BSTR bstrNewVal)
{


    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    HRESULT                 hr;

    // Get the current RAS entry properties
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);

    if (NULL ==lpRasDevInfo)
    {
        dwRasDevInfoSize = 0;
    }

    if (hr == ERROR_SUCCESS && NULL != lpRasEntry)
    {
        // Replace the phone number with the new one
        //
        lstrcpy(lpRasEntry->szLocalPhoneNumber, bstrNewVal);

        // non-zero dummy values are required due to bugs in win95
        lpRasEntry->dwCountryID = 1;
        lpRasEntry->dwCountryCode = 1;
        lpRasEntry->szAreaCode[1] = L'\0';
        lpRasEntry->szAreaCode[0] = L'8';

        // Set to dial as is
        //
        lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            TRACE6(L"CRefDial::put_DialPhoneNumber - MyRasGetEntryProperties()"
                  L"lpRasEntry->dwfOptions: %ld"
                  L"lpRasEntry->dwCountryID: %ld"
                  L"lpRasEntry->dwCountryCode: %ld"
                  L"lpRasEntry->szAreaCode: %s"
                  L"lpRasEntry->szLocalPhoneNumber: %s"
                  L"lpRasEntry->dwAlternateOffset: %ld",
                  lpRasEntry->dwfOptions,
                  lpRasEntry->dwCountryID,
                  lpRasEntry->dwCountryCode,
                  lpRasEntry->szAreaCode,
                  lpRasEntry->szLocalPhoneNumber,
                  lpRasEntry->dwAlternateOffset
                );

            pcRNA->RasSetEntryProperties(NULL,
                                         m_szConnectoid,
                                         (LPBYTE)lpRasEntry,
                                         dwRasEntrySize,
                                         (LPBYTE)lpRasDevInfo,
                                         dwRasDevInfoSize);

            delete pcRNA;
            m_bDialCustom = TRUE;
        }
    }

    // Regenerate the displayable number
    //GetDisplayableNumber();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDialAlternative
//
//  Synopsis:   Set whether or not to look for another number in phonebook
//              when dialing next time
//
//+---------------------------------------------------------------------------
HRESULT CRefDial::SetDialAlternative(BOOL bVal)
{
    m_bDialAlternative = bVal;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoHangup
//
//  Synopsis:   Hangup the modem for the currently active RAS session
//
//+---------------------------------------------------------------------------
HRESULT CRefDial::DoHangup()
{
    // Set the disconnect flag as the system may be too busy with dialing.
    // Once we get a chance to terminate dialing, we know we have to hangu
    EnterCriticalSection (&m_csMyCriticalSection);

    // Your code to access the shared resource goes here.
    TerminateConnMonitorThread();

    if (NULL != m_hrasconn)
    {
        RNAAPI* pRNA = new RNAAPI();
        if (pRNA)
        {
            pRNA->RasHangUp(m_hrasconn);
            m_hrasconn = NULL;
            delete pRNA;
        }
    }
    // Release ownership of the critical section
    LeaveCriticalSection (&m_csMyCriticalSection);

    return (m_hrasconn == NULL) ? S_OK : E_POINTER;
}


BOOL CRefDial::get_QueryString(WCHAR* szTemp, DWORD cchMax)
{
    WCHAR   szOOBEInfoINIFile[MAX_PATH];
    WCHAR   szISPSignup[MAX_PATH];
    WCHAR   szOEMName[MAX_PATH];
    WCHAR   szQueryString[MAX_SECTIONS_BUFFER*2];
    WCHAR   szBroadbandDeviceName[MAX_STRING];
    WCHAR   szBroadbandDevicePnpid[MAX_STRING];

    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&osvi))
        ZeroMemory(&osvi, sizeof(OSVERSIONINFO));

    if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId)
        m_lpGatherInfo->m_dwOS = 1;
    else if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
        m_lpGatherInfo->m_dwOS = 2;
    else
        m_lpGatherInfo->m_dwOS = 0;

    SearchPath(NULL, cszOOBEINFOINI, NULL, MAX_CHARS_IN_BUFFER(szOOBEInfoINIFile), szOOBEInfoINIFile, NULL);

    DWORD dwOfferCode = 0;
    if(m_dwAppMode == APMD_MSN)
    {
        lstrcpy(szISPSignup, L"MSN");
    }
    else
    {
        GetPrivateProfileString(cszSignup,
                                cszISPSignup,
                                L"",
                                szISPSignup,
                                MAX_CHARS_IN_BUFFER(szISPSignup),
                                szOOBEInfoINIFile);
         dwOfferCode = GetPrivateProfileInt(cszSignup,
                                            cszOfferCode,
                                            0,
                                            szOOBEInfoINIFile);
    }
    GetPrivateProfileString(cszBranding,
                            cszOEMName,
                            L"",
                            szOEMName,
                            MAX_CHARS_IN_BUFFER(szOEMName),
                            szOOBEInfoINIFile);

    GetPrivateProfileString(cszOptions,
                            cszBroadbandDeviceName,
                            L"",
                            szBroadbandDeviceName,
                            MAX_CHARS_IN_BUFFER(szBroadbandDeviceName),
                            szOOBEInfoINIFile);
    GetPrivateProfileString(cszOptions,
                            cszBroadbandDevicePnpid,
                            L"",
                            szBroadbandDevicePnpid,
                            MAX_CHARS_IN_BUFFER(szBroadbandDevicePnpid),
                            szOOBEInfoINIFile);

    //DT tells the ISP if the query is coming from fullscreen OOBE or the desktop (windowed) version of OOBE. DT=1 means desktop version, DT=0 means fullscreen.
    INT nDT = (m_dwAppMode == APMD_OOBE) ? 0 : 1;

    wsprintf(szQueryString, L"LCID=%lu&TCID=%lu&ISPSignup=%s&OfferCode=%lu&OS=%lu%&BUILD=%ld&DT=%lu&OEMName=%s&BroadbandDeviceName=%s&BroadbandDevicePnpid=%s",
            GetUserDefaultUILanguage(),
            m_lpGatherInfo->m_dwCountryID,
            szISPSignup,
            dwOfferCode,
            m_lpGatherInfo->m_dwOS,
            LOWORD(osvi.dwBuildNumber),
            nDT,
            szOEMName,
            szBroadbandDeviceName,
            szBroadbandDevicePnpid);

    // Parse the ISP section in the INI file to find query pair to append
    WCHAR *pszKeys = NULL;
    PWSTR pszKey = NULL;
    WCHAR szValue[MAX_PATH];
    ULONG ulRetVal     = 0;
    BOOL  bEnumerate = TRUE;
    ULONG ulBufferSize = MAX_SECTIONS_BUFFER;
    WCHAR szOobeinfoPath[MAX_PATH + 1];

    //BUGBUG :: this search path is foir the same file as the previous one and is redundant.
    SearchPath(NULL, cszOOBEINFOINI, NULL, MAX_PATH, szOobeinfoPath, NULL);

    // Loop to find the appropriate buffer size to retieve the ins to memory
    ulBufferSize = MAX_KEYS_BUFFER;
    ulRetVal = 0;

    if (!(pszKeys = (LPWSTR)GlobalAlloc(GPTR, ulBufferSize*sizeof(WCHAR)))) {
        return FALSE;
    }
    while (ulRetVal < (ulBufferSize - 2))
    {

        ulRetVal = ::GetPrivateProfileString(cszISPQuery, NULL, L"", pszKeys, ulBufferSize, szOobeinfoPath);
        if (0 == ulRetVal)
           bEnumerate = FALSE;

        if (ulRetVal < (ulBufferSize - 2))
        {
            break;
        }
        GlobalFree( pszKeys );
        ulBufferSize += ulBufferSize;
        pszKeys = (LPWSTR)GlobalAlloc(GPTR, ulBufferSize*sizeof(WCHAR));
        if (!pszKeys)
        {
            bEnumerate = FALSE;
        }

    }


    if (bEnumerate)
    {
        // Enumerate each key value pair in the section
        pszKey = pszKeys;
        while (*pszKey)
        {
            ulRetVal = ::GetPrivateProfileString(cszISPQuery, pszKey, L"", szValue, MAX_CHARS_IN_BUFFER(szValue), szOobeinfoPath);
            if ((ulRetVal != 0) && (ulRetVal < MAX_CHARS_IN_BUFFER(szValue) - 1))
            {
                // Append query pair
                wsprintf(szQueryString, L"%s&%s=%s", szQueryString, pszKey, szValue);
            }
            pszKey += lstrlen(pszKey) + 1;
        }
    }

    if(GetPrivateProfileInt(INF_SECTION_URL,
                            ISP_MSNSIGNUP,
                            0,
                            m_szISPFile))
    {
        lstrcat(szQueryString, QUERY_STRING_MSNSIGNUP);
    }

    if (pszKeys)
        GlobalFree( pszKeys );


    if (cchMax < (DWORD)lstrlen(szQueryString) + 1)
        return FALSE;

    lstrcpy(szTemp, szQueryString);
    return TRUE;

}

HRESULT CRefDial::get_SignupURL(BSTR * pVal)
{
    WCHAR szTemp[INTERNET_MAX_URL_LENGTH] = L"";

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(m_szISPFile, INF_SECTION_URL, INF_SIGNUP_URL,&szTemp[0],INTERNET_MAX_URL_LENGTH)))
    {
        if(*szTemp)
        {
            WCHAR   szUrl[INTERNET_MAX_URL_LENGTH];

            WCHAR szQuery[MAX_PATH * 4] = L"\0";
            get_QueryString(szQuery, MAX_CHARS_IN_BUFFER(szQuery));

            wsprintf(szUrl, L"%s%s",
                    szTemp,
                    szQuery);

            *pVal = SysAllocString(szUrl);
        }
        else
            *pVal = NULL;

    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

//BUGBUG:: this should be combined with get_SignupURL
HRESULT CRefDial::get_ReconnectURL(BSTR * pVal)
{
    WCHAR szTemp[INTERNET_MAX_URL_LENGTH] = L"\0";

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(m_szISPFile, INF_SECTION_URL, INF_RECONNECT_URL,&szTemp[0],INTERNET_MAX_URL_LENGTH)))
    {
        WCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
        WCHAR   szQuery[MAX_PATH * 4] = L"\0";
        DWORD   dwErr = 0;

        if(*szTemp)
        {
            get_QueryString(szQuery, MAX_CHARS_IN_BUFFER(szQuery));

            if (m_dwRASErr)
                dwErr = 1;

                wsprintf(szUrl, L"%s%s&Error=%ld",
                        szTemp,
                        szQuery,
                        dwErr);

            *pVal = SysAllocString(szUrl);
        }
        else
            *pVal = NULL;
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

HRESULT CRefDial::GetConnectionType(DWORD * pdwVal)
{
    *pdwVal = m_dwConnectionType;
    return S_OK;
}



HRESULT CRefDial::GetDialErrorMsg(BSTR * pVal)
{

    if (pVal == NULL)
        return E_POINTER;

    return S_OK;
}


HRESULT CRefDial::GetSupportNumber(BSTR * pVal)
{

    /*
    WCHAR    szSupportNumber[MAX_PATH];

    if (pVal == NULL)
        return E_POINTER;

    if (m_SupportInfo.GetSupportInfo(szSupportNumber, m_dwCountryCode))
        *pVal = SysAllocString(szSupportNumber);
    else
        *pVal = NULL;
*/
    return S_OK;
}


BOOL CRefDial::IsDBCSString( CHAR *sz )
{
    if (!sz)
        return FALSE;

    while( NULL != *sz )
    {
         if (IsDBCSLeadByte(*sz)) return FALSE;
         sz++;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasGetConnectStatus
//
//  Synopsis:   Checks for existing Ras connection; return TRUE for connected
//              Return FALSE for disconnect.
//
//+---------------------------------------------------------------------------

HRESULT CRefDial::RasGetConnectStatus(BOOL *pVal)
{
    HRESULT     hr = E_FAIL;

    *pVal = FALSE;

    if (NULL != m_hrasconn)
    {
        RASCONNSTATUS rasConnectState;
        rasConnectState.dwSize = sizeof(RASCONNSTATUS);
        if (m_pcRNA)
        {
            if (0 == m_pcRNA->RasGetConnectStatus(m_hrasconn, &rasConnectState))
            {
                if (RASCS_Disconnected != rasConnectState.rasconnstate)
                    *pVal = TRUE;
            }

            hr = S_OK;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   DoOfferDownload
//
//  Synopsis:   Download the ISP offer from the ISP server
//
//+---------------------------------------------------------------------------
HRESULT CRefDial::DoOfferDownload(BOOL *pbRetVal)
{
    HRESULT hr;
       RNAAPI  *pcRNA;


    //
    // Hide RNA window on Win95 retail
    //
//        MinimizeRNAWindow(m_pszConnectoid, g_hInst);
        // 4/2/97    ChrisK    Olympus 296
//        g_hRNAZapperThread = LaunchRNAReestablishZapper(g_hInst);
    //
    // The connection is open and ready.  Start the download.
    //
    m_dwThreadID = 0;
    m_hThread = CreateThread(NULL,
                             0,
                             (LPTHREAD_START_ROUTINE)DownloadThreadInit,
                             (LPVOID)this,
                             0,
                             &m_dwThreadID);

    // 5-1-97    ChrisK Olympus 2934
//    m_objBusyMessages.Start(m_hWnd, IDC_LBLSTATUS,m_hrasconn);

    // If we dont get the donwload thread, then kill the open
    // connection
    if (!m_hThread)
    {
        hr = GetLastError();
        if (m_hrasconn)
        {
            pcRNA = new RNAAPI;
            if (pcRNA)
            {
                pcRNA->RasHangUp(m_hrasconn);
                m_hrasconn = NULL;
                delete pcRNA;
                pcRNA = NULL;
            }
        }

        *pbRetVal = FALSE;
    }
    else
    {
        // Download has started.
        m_bDownloadHasBeenCanceled = FALSE;
        *pbRetVal = TRUE;
    }
    return S_OK;
}

// Form the Dialing URL.  Must be called after setting up for dialing.
HRESULT CRefDial::FormReferralServerURL(BOOL * pbRetVal)
{

    WCHAR    szTemp[MAX_PATH] = L"\0";
    WCHAR    szPromo[MAX_PATH]= L"\0";
    WCHAR    szProd[MAX_PATH] = L"\0";
    WCHAR    szArea[MAX_PATH] = L"\0";
    WCHAR    szOEM[MAX_PATH]  = L"\0";
    DWORD    dwCONNWIZVersion = 500;        // Version of CONNWIZ.HTM

    //
    // ChrisK Olympus 3997 5/25/97
    //
    WCHAR szRelProd[MAX_PATH] = L"\0";
    WCHAR szRelProdVer[MAX_PATH] = L"\0";
    HRESULT hr = ERROR_SUCCESS;
    OSVERSIONINFO osvi;


    //
    // Build URL complete with name value pairs
    //
    hr = GetDataFromISPFile(m_szISPFile, INF_SECTION_ISPINFO, INF_REFERAL_URL,&szTemp[0],256);
    if (L'\0' == szTemp[0])
    {
        //MsgBox(IDS_MSNSU_WRONG, MB_MYERROR);
        return hr;
    }

    //Assert(szTemp[0]);

    Sz2URLValue(m_szOEM, szOEM,0);
    Sz2URLValue(m_lpGatherInfo->m_szAreaCode, szArea,0);
    if (m_bstrProductCode)
        Sz2URLValue(m_bstrProductCode, szProd,0);
    else
        Sz2URLValue(DEFAULT_PRODUCTCODE, szProd,0);

    if (m_bstrPromoCode)
        Sz2URLValue(((BSTR)m_bstrPromoCode), szPromo,0);
    else
        Sz2URLValue(DEFAULT_PROMOCODE, szPromo,0);


    //
    // ChrisK Olympus 3997 5/25/97
    //
    Sz2URLValue(m_lpGatherInfo->m_szRelProd, szRelProd, 0);
    Sz2URLValue(m_lpGatherInfo->m_szRelVer, szRelProdVer, 0);
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi))
    {
        ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    }

    // Autoconfig will set alloffers always.
    if ( m_lAllOffers || (m_lpGatherInfo->m_dwFlag & ICW_CFGFLAG_AUTOCONFIG) )
    {
        m_lpGatherInfo->m_dwFlag |= ICW_CFGFLAG_ALLOFFERS;
    }
    wsprintf(m_szUrl, L"%slcid=%lu&sysdeflcid=%lu&appslcid=%lu&icwos=%lu&osver=%lu.%2.2d%s&arch=%u&promo=%s&oem=%s&area=%s&country=%lu&icwver=%s&prod=%s&osbld=%d&icwrp=%s&icwrpv=%s&wizver=%lu&PID=%s&cfgflag=%lu",
                 szTemp,
                 m_lpGatherInfo->m_lcidUser,
                 m_lpGatherInfo->m_lcidSys,
                 m_lpGatherInfo->m_lcidApps,
                 m_lpGatherInfo->m_dwOS,
                 m_lpGatherInfo->m_dwMajorVersion,
                 m_lpGatherInfo->m_dwMinorVersion,
                 ICW_OS_VER,
                 m_lpGatherInfo->m_wArchitecture,
                 szPromo,
                 szOEM,
                 szArea,
                 m_lpGatherInfo->m_dwCountryCode,
                 &m_lpGatherInfo->m_szSUVersion[0],
                 szProd,
                 LOWORD(osvi.dwBuildNumber),
                 szRelProd,
                 szRelProdVer,
                 dwCONNWIZVersion,
                 m_szPID,
                 m_lpGatherInfo->m_dwFlag);


    StoreInSignUpReg(
        (LPBYTE)m_lpGatherInfo,
        sizeof(GATHERINFO),
        REG_BINARY,
        GATHERINFOVALUENAME);
    return hr;
}


/*******************************************************************

  NAME:    ParseISPInfo

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CRefDial::ParseISPInfo
(
    HWND hDlg,
    WCHAR *pszCSVFileName,
    BOOL bCheckDupe
)
{
    // On the first init, we will read the ISPINFO.CSV file, and populate the ISP LISTVIEW

    CCSVFile    far *pcCSVFile;
    CISPCSV     far *pcISPCSV;
    BOOL        bRet = TRUE;
    BOOL        bHaveCNSOffer = FALSE;
    BOOL        bISDNMode = FALSE;
    HRESULT     hr;

    CleanISPList();
    ISPLIST* pCurr = NULL;


    DWORD dwCurrISPListSize = 1;
    m_dwNumOfAutoConfigOffers = 0;
    m_unSelectedISP = 0;

    // Open and process the CSV file
    pcCSVFile = new CCSVFile;
    if (!pcCSVFile)
    {
        // BUGBUG: Show Error Message
        return (FALSE);
    }

    if (!pcCSVFile->Open(pszCSVFileName))
    {
        // BUGBUG: Show Error Message
        delete pcCSVFile;
        pcCSVFile = NULL;

        return (FALSE);
    }

    // Read the first line, since it contains field headers
    pcISPCSV = new CISPCSV;
    if (!pcISPCSV)
    {
        // BUGBUG Show error message
        delete pcCSVFile;
        return (FALSE);
    }

    if (ERROR_SUCCESS != (hr = pcISPCSV->ReadFirstLine(pcCSVFile)))
    {
        // Handle the error case
        delete pcCSVFile;
        pcCSVFile = NULL;

        return (FALSE);
    }
    delete pcISPCSV;        // Don't need this one any more

    // Create the SELECT tag for the html so it can get all the country names in one shot.
    if (m_pszISPList)
        delete [] m_pszISPList;
    m_pszISPList = new WCHAR[1024];
    if (!m_pszISPList)
        return FALSE;

    memset(m_pszISPList, 0, sizeof(m_pszISPList));

    do {
        // Allocate a new ISP record
        pcISPCSV = new CISPCSV;
        if (!pcISPCSV)
        {
            // BUGBUG Show error message
            bRet = FALSE;
            break;

        }

        // Read a line from the ISPINFO file
        hr = pcISPCSV->ReadOneLine(pcCSVFile);
        if (hr == ERROR_SUCCESS)
        {
            // If this line contains a nooffer flag, then leave now
            if (!(pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_OFFERS))
            {
                m_dwNumOfAutoConfigOffers = 0;
                break;
            }
            if ((pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_AUTOCONFIG) &&
                (bISDNMode ? (pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_ISDN_OFFER) : TRUE) )
            {
                // Form the ISP list option tag for HTML

                WCHAR szBuffer[MAX_PATH];
                wsprintf(szBuffer, szOptionTag, pcISPCSV->get_szISPName());
                DWORD dwSizeReq = (DWORD)lstrlen(m_pszISPList) + lstrlen(szBuffer) + 1;
                if (dwCurrISPListSize < dwSizeReq)
                {
                    WCHAR *szTemp = new WCHAR[dwSizeReq];
                    if (szTemp)
                        lstrcpy(szTemp, m_pszISPList);
                    dwCurrISPListSize =  dwSizeReq;
                    delete [] m_pszISPList;
                    m_pszISPList = szTemp;
                }

                // Add the isp to the list.
                if (m_pszISPList)
                    lstrcat(m_pszISPList, szBuffer);

                if (m_pCSVList == NULL) // First one
                {
                    // Add the CSV file object to the first node of linked list
                    ISPLIST* pNew = new ISPLIST;
                    pNew->pElement = pcISPCSV;
                    pNew->uElem = m_dwNumOfAutoConfigOffers;
                    pNew->pNext = NULL;
                    pCurr = pNew;
                    m_pCSVList = pCurr;
                }
                else
                {
                    // Append CSV object to the end of list
                    ISPLIST* pNew = new ISPLIST;
                    pNew->pElement = pcISPCSV;
                    pNew->uElem = m_dwNumOfAutoConfigOffers;
                    pNew->pNext = NULL;
                    pCurr->pNext = pNew;
                    pCurr = pCurr->pNext;
                }
                ++m_dwNumOfAutoConfigOffers;

            }
            else
            {
                delete pcISPCSV;
            }
        }
        else if (hr == ERROR_NO_MORE_ITEMS)
        {
            delete pcISPCSV;        // We don't need this one
            break;
        }
        else if (hr == ERROR_FILE_NOT_FOUND)
        {
            // do not show this ISP when its data is invalid
            // we don't want to halt everything. Just let it contine
            delete pcISPCSV;
        }
        else
        {
            // Show error message Later
            delete pcISPCSV;
            //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
            bRet = FALSE;
            break;
        }

    } while (TRUE);

    delete pcCSVFile;

    return bRet;
}

HRESULT CRefDial::GetISPList(BSTR* pbstrISPList)
{

    if (pbstrISPList)
        *pbstrISPList = NULL;
    else
        return E_FAIL;

    if (!m_pszISPList)
    {
        ParseISPInfo(NULL, ICW_ISPINFOPath, TRUE);
    }
    if (m_pszISPList && *m_pszISPList)
    {
        *pbstrISPList = SysAllocString(m_pszISPList);
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CRefDial::Set_SelectISP(UINT nVal)
{
    if (nVal < m_dwNumOfAutoConfigOffers)
    {
        m_unSelectedISP = nVal;
    }
    return S_OK;
}

HRESULT CRefDial::Set_ConnectionMode(UINT nVal)
{
    if (nVal < m_dwNumOfAutoConfigOffers)
    {
        m_unSelectedISP = nVal;
    }
    return S_OK;
}

HRESULT CRefDial::Get_ConnectionMode(UINT *pnVal)
{
    if (pnVal)
    {
        *pnVal = m_dwCnType;
        return S_OK;
    }
    return E_FAIL;
}


HRESULT CRefDial::ProcessSignedPID(BOOL * pbRetVal)
{
    HANDLE  hfile;
    DWORD   dwFileSize;
    DWORD   dwBytesRead;
    LPBYTE  lpbSignedPID;
    LPWSTR  lpszSignedPID;

    *pbRetVal = FALSE;

    // Open the PID file for Binary Reading.  It will be in the CWD
    if (INVALID_HANDLE_VALUE != (hfile = CreateFile(c_szSignedPIDFName,
                                                  GENERIC_READ,
                                                  0,
                                                  NULL,
                                                  OPEN_EXISTING,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  NULL)))
    {
        dwFileSize = GetFileSize(hfile, NULL);

        // Allocate a buffer to read the file, and one to store the BINHEX version
        lpbSignedPID = new BYTE[dwFileSize];
        lpszSignedPID = new WCHAR[(dwFileSize * 2) + 1];

        if (lpbSignedPID && lpszSignedPID)
        {
            if (ReadFile(hfile, (LPVOID) lpbSignedPID, dwFileSize, &dwBytesRead, NULL) &&
                    (dwFileSize == dwBytesRead))
            {
                // BINHEX the signed PID data so we can send it to the signup server
                DWORD   dwX = 0;
                BYTE    by;
                for (DWORD dwY = 0; dwY < dwFileSize; dwY++)
                {
                    by = lpbSignedPID[dwY];
                    lpszSignedPID[dwX++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                    lpszSignedPID[dwX++] = g_BINTOHEXLookup[(by & 0x0F)];
                }
                lpszSignedPID[dwX] = L'\0';

                // Convert the signed pid to a BSTR
                m_bstrSignedPID = SysAllocString(lpszSignedPID);

                // Set the return value
                *pbRetVal = TRUE;
            }
        }

        // Free the buffers we allocated
        if (lpbSignedPID)
        {
            delete[] lpbSignedPID;
        }
        if (lpszSignedPID)
        {
            delete[] lpszSignedPID;
        }

        // Close the File
        CloseHandle(hfile);

#ifndef DEBUG
        // Delete the File
        // defer removal of this file until the container app exits.
        // see BUG 373.
        //DeleteFile(c_szSignedPIDFName);
#endif
    }

    return S_OK;
}

HRESULT CRefDial::get_SignedPID(BSTR * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = SysAllocString(m_bstrSignedPID);
    return S_OK;
}

HRESULT CRefDial::get_ISDNAutoConfigURL(BSTR * pVal)
{
    WCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(m_szISPFile, INF_SECTION_URL, INF_ISDN_AUTOCONFIG_URL,&szTemp[0],256)))
    {
        *pVal = SysAllocString(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

HRESULT CRefDial::get_ISPName(BSTR * pVal)
{
    if (m_pSelectedISPInfo)
    {
        *pVal = SysAllocString(m_pSelectedISPInfo->get_szISPName());
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

HRESULT CRefDial::get_AutoConfigURL(BSTR * pVal)
{
    WCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(m_szISPFile, INF_SECTION_URL, INF_AUTOCONFIG_URL,&szTemp[0],256)))
    {
        *pVal = SysAllocString(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}


HRESULT CRefDial::DownloadISPOffer(BOOL *pbVal, BSTR *pVal)
{
    HRESULT hr = S_OK;
    // Download the ISP file, and then copy its contents
    // If Ras is complete
    if (pbVal && pVal)
    {

        // Download the first page from Webgate
        BSTR    bstrURL = NULL;
        BSTR    bstrQueryURL = NULL;
        BOOL    bRet;

        *pVal = NULL;
        *pbVal = FALSE;

        m_pISPData = new CICWISPData;

        WCHAR   szTemp[10];      // Big enough to format a WORD

        // Add the PID, GIUD, and Offer ID to the ISP data object
        ProcessSignedPID(&bRet);
        if (bRet)
        {
            m_pISPData->PutDataElement(ISPDATA_SIGNED_PID, m_bstrSignedPID, FALSE);
        }
        else
        {
            m_pISPData->PutDataElement(ISPDATA_SIGNED_PID, NULL, FALSE);
        }

        // GUID comes from the ISPCSV file
        m_pISPData->PutDataElement(ISPDATA_GUID,
                                                m_pSelectedISPInfo->get_szOfferGUID(),
                                                FALSE);

        // Offer ID comes from the ISPCSV file as a WORD
        // NOTE: This is the last one, so besure AppendQueryPair does not add an Ampersand
        if (m_pSelectedISPInfo)
        {
            wsprintf (szTemp, L"%d", m_pSelectedISPInfo->get_wOfferID());
            m_pISPData->PutDataElement(ISPDATA_OFFERID, szTemp, FALSE);
        }


        // BUGBUG: If ISDN get the ISDN Autoconfig URL
        if (m_ISPImport.m_bIsISDNDevice)
        {
            get_ISDNAutoConfigURL(&bstrURL);
        }
        else
        {
            get_AutoConfigURL(&bstrURL);
        }

        if (*bstrURL)
        {
            // Get the full signup url with Query string params added to it
            m_pISPData->GetQueryString(bstrURL, &bstrQueryURL);

            // Setup WebGate
            if (S_OK != gpCommMgr->FetchPage(bstrQueryURL, pVal))
            {
                // Download problem:
                // User has disconnected
                if (TRUE == m_bUserInitiateHangup)
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                *pbVal = TRUE;
            }
        }


        // Now that webgate is done with it, free the queryURL
        SysFreeString(bstrQueryURL);

        // Memory cleanup
        SysFreeString(bstrURL);

        delete m_pISPData;
        m_pISPData = NULL;

    }
    return hr;
}

HRESULT CRefDial::RemoveDownloadDir()
{
    DWORD dwAttribs;
    WCHAR szDownloadDir[MAX_PATH];
    WCHAR szSignedPID[MAX_PATH];

    // form the ICW98 dir.  It is basically the CWD
    if(!GetOOBEPath(szDownloadDir))
        return S_OK;

    // remove the signed.pid file from the ICW directory (see BUG 373)
    wsprintf(szSignedPID, L"%s%s", szDownloadDir, L"\\signed.pid");
    if (GetFileAttributes(szSignedPID) != 0xFFFFFFFF)
    {
      SetFileAttributes(szSignedPID, FILE_ATTRIBUTE_NORMAL);
      DeleteFile(szSignedPID);
    }

    lstrcat(szDownloadDir, L"\\download");

    // See if the directory exists
    dwAttribs = GetFileAttributes(szDownloadDir);
    if (dwAttribs != 0xFFFFFFFF && dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
      DeleteDirectory(szDownloadDir);
    return S_OK;
}

void CRefDial::DeleteDirectory (LPCWSTR szDirName)
{
   WIN32_FIND_DATA fdata;
   WCHAR szPath[MAX_PATH];
   HANDLE hFile;
   BOOL fDone;

   wsprintf(szPath, L"%s\\*.*", szDirName);
   hFile = FindFirstFile (szPath, &fdata);
   if (INVALID_HANDLE_VALUE != hFile)
      fDone = FALSE;
   else
      fDone = TRUE;

   while (!fDone)
   {
      wsprintf(szPath, L"%s\\%s", szDirName, fdata.cFileName);
      if (fdata.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
      {
         if (lstrcmpi(fdata.cFileName, L".")  != 0 &&
             lstrcmpi(fdata.cFileName, L"..") != 0)
         {
            // recursively delete this dir too
            DeleteDirectory(szPath);
         }
      }
      else
      {
         SetFileAttributes(szPath, FILE_ATTRIBUTE_NORMAL);
         DeleteFile(szPath);
      }
      if (FindNextFile(hFile, &fdata) == 0)
      {
         FindClose(hFile);
         fDone = TRUE;
      }
   }
   SetFileAttributes(szDirName, FILE_ATTRIBUTE_NORMAL);
   RemoveDirectory(szDirName);
}

HRESULT CRefDial::PostRegData(DWORD dwSrvType, LPWSTR szPath)
{
    static WCHAR hdrs[]     = L"Content-Type: application/x-www-form-urlencoded";
    static WCHAR accept[]   = L"Accept: */*";
    static LPCWSTR rgsz[]   = {accept, NULL};
    WCHAR  szRegPostURL[INTERNET_MAX_URL_LENGTH] = L"\0";
    HRESULT hRet = E_FAIL;


    if (POST_TO_MS & dwSrvType)
    {
        // Get the RegPostURL from Reg.isp file for MS registration
        GetPrivateProfileString(INF_SECTION_URL,
                                c_szRegPostURL,
                                L"",
                                szRegPostURL,
                                INTERNET_MAX_URL_LENGTH,
                                m_szISPFile);
    }
    else if (POST_TO_OEM & dwSrvType)
    {
        WCHAR   szOOBEInfoINIFile[MAX_PATH];
        SearchPath(NULL, cszOOBEINFOINI, NULL, MAX_CHARS_IN_BUFFER(szOOBEInfoINIFile), szOOBEInfoINIFile, NULL);
        GetPrivateProfileString(INF_OEMREGPAGE,
                                c_szRegPostURL,
                                L"",
                                szRegPostURL,
                                INTERNET_MAX_URL_LENGTH,
                                szOOBEInfoINIFile);
    }


    // Connecting to http://mscomdev.dns.microsoft.com/register.asp.
    if (CrackUrl(
        szRegPostURL,
        m_szRegServerName,
        m_szRegFormAction,
        &m_nRegServerPort,
        &m_fSecureRegServer))
    {

        HINTERNET hSession = InternetOpen(
            L"OOBE",
            INTERNET_OPEN_TYPE_PRECONFIG,
            NULL,
            NULL,
            0
            );

        if (hSession)
        {
            HINTERNET hConnect = InternetConnect(
                hSession,
                m_szRegServerName,
                m_nRegServerPort,
                NULL,
                NULL,
                INTERNET_SERVICE_HTTP,
                0,
                1
                );

            if (hConnect)
            {
                // INTERNET_FLAG_SECURE is needed KB Q168151
                
                HINTERNET hRequest = HttpOpenRequest(
                    hConnect,
                    L"POST",
                    m_szRegFormAction,
                    NULL,
                    NULL,
                    rgsz,
                    (m_fSecureRegServer) ? INTERNET_FLAG_SECURE : 0,
                    1
                    );

                if (hRequest)
                {
                    // The data for the HttpSendRequest has to be in ANSI. The server side does
                    // not understand a UNICODE string. If the server side gets changed to understand
                    // UNICODE data, the conversion below needs to be removed.
                    LPSTR szAnsiData = NULL;
                    INT   iLength;
                    // compute the length
                    //
                    iLength =  WideCharToMultiByte(CP_ACP, 0, szPath, -1, NULL, 0, NULL, NULL);
                    if (iLength > 0)
                    {
                        szAnsiData  = new char[iLength];
                        if (szAnsiData)
                        {
                            WideCharToMultiByte(CP_ACP, 0, szPath, -1, szAnsiData, iLength, NULL, NULL);
                            szAnsiData[iLength - 1] = 0;
                        }
                    }
                    if (szAnsiData)
                    {
                        // 2nd/3rd params are a string/char length pair,
                        // but 4th/5th params are a buffer/byte length pair.
                        if (HttpSendRequest(hRequest, hdrs, lstrlen(hdrs), szAnsiData, lstrlenA(szAnsiData)))
                        {
                            // Get size of file in bytes.
                            WCHAR bufQuery[32] ;
                            DWORD dwFileSize ;
                            DWORD cchMaxBufQuery = MAX_CHARS_IN_BUFFER(bufQuery);
                            BOOL bQuery = HttpQueryInfo(hRequest,
                                HTTP_QUERY_CONTENT_LENGTH,
                                bufQuery,
                                &cchMaxBufQuery,
                                NULL) ;
                            if (bQuery)
                            {
                                // The Query was successful, so allocate the memory.
                                dwFileSize = (DWORD)_wtol(bufQuery) ;
                            }
                            else
                            {
                                // The Query failed. Allocate some memory. Should allocate memory in blocks.
                                dwFileSize = 5*1024 ;
                            }

                            // BUGBUG: What is the purpose of this code??  It
                            // appears to read a file, null-terminate the buffer,
                            // then delete the buffer.  Why??

                            BYTE* rgbFile = new BYTE[dwFileSize+1] ;
                            if (rgbFile)
                            {
                                DWORD dwBytesRead ;
                                BOOL bRead = InternetReadFile(hRequest,
                                    rgbFile,
                                    dwFileSize+1,
                                    &dwBytesRead);
                                if (bRead)
                                {
                                    rgbFile[dwBytesRead] = 0 ;
                                    hRet = S_OK;
                                } // InternetReadFile
                                delete [] rgbFile;
                            }

                        }
                        else
                        {
                            DWORD dwErr = GetLastError();
                        }
                        delete [] szAnsiData;
                    }
                    InternetCloseHandle(hRequest);
                    hRet = S_OK;
                }
                InternetCloseHandle(hConnect);
            }
            InternetCloseHandle(hSession);
        }
    }

    if (hRet != S_OK)
    {
        DWORD dwErr = GetLastError();
        hRet = HRESULT_FROM_WIN32(dwErr);
    }

    TRACE2(TEXT("Post registration data to %s 0x%08lx"), szRegPostURL, hRet);

    return hRet;


}




// This function will accept user selected values that are necessary to
// setup a connectiod for dialing
// Returns:
//      TRUE        OK to dial
//      FALSE       Some kind of problem
//                  QuitWizard - TRUE, then terminate
//                  UserPickNumber - TRUE, then display Pick a Number DLG
//                  QuitWizard and UserPickNumber both FALSE, then just
//                  display the page prior to Dialing UI.
HRESULT CRefDial::Connect
(
    UINT nType,
    BSTR bstrISPFile,
    DWORD dwCountry,
    BSTR bstrAreaCode,
    DWORD dwFlag,
    DWORD dwAppMode
)
{
    HRESULT             hr = S_OK;
    BOOL                bSuccess = FALSE;
    BOOL                bRetVal = FALSE;

    LPWSTR   pszTemp;
    WCHAR    szISPPath[MAX_PATH];

    m_dwCnType = nType;

    if (!bstrISPFile || !bstrAreaCode)
    {
        return E_FAIL;
    }


    // Locate ISP file
    if (!SearchPath(NULL, bstrISPFile,INF_SUFFIX,MAX_PATH,szISPPath,&pszTemp))
    {
        hr = ERROR_FILE_NOT_FOUND;
        return hr;
    }


    // Check whether the isp file is ICW capable by reading the referral URL
    GetPrivateProfileString(INF_SECTION_ISPINFO,
                            c_szURLReferral,
                            L"",
                            m_szRefServerURL,
                            INTERNET_MAX_URL_LENGTH,
                            szISPPath);

    lstrcpy(m_szISPFile, szISPPath);

    m_dwAppMode = dwAppMode;


    // Initialize failure codes
    m_bQuitWizard = FALSE;
    m_bUserPickNumber = FALSE;
    m_lpGatherInfo->m_bUsePhbk = FALSE;


    // Stuff the Area Code, and Country Code into the GatherInfo struct

    m_lpGatherInfo->m_dwCountryID = dwCountry;
    m_lpGatherInfo->m_dwCountryCode = dwFlag;

    lstrcpy(m_lpGatherInfo->m_szAreaCode, bstrAreaCode);


    m_SuggestInfo.AccessEntry.dwCountryID = dwCountry;
    m_SuggestInfo.AccessEntry.dwCountryCode = dwFlag;
    lstrcpy(m_SuggestInfo.AccessEntry.szAreaCode, bstrAreaCode);

    GetISPFileSettings(szISPPath);

    FillGatherInfoStruct(m_lpGatherInfo);

    if (CONNECTED_REFFERAL == m_dwCnType)
        FormReferralServerURL(&bRetVal);

    // LAN connection support in desktop mode
    if (gpCommMgr)
    {
        // Pretend we have the connection
        PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONCONNECTED, (WPARAM)gpCommMgr->m_pRefDial->m_dwCnType , (LPARAM)0);

    }

    return hr;
}


HRESULT CRefDial::CheckOnlineStatus(BOOL *pbVal)
{
    // #if defined(DEBUG)
    //     *pbVal = TRUE;
    //     return S_OK;
    // #endif

    *pbVal = (BOOL)(m_hrasconn != NULL);
    return S_OK;
}


BOOL CRefDial::CrackUrl(
    const WCHAR* lpszUrlIn,
    WCHAR* lpszHostOut,
    WCHAR* lpszActionOut,
    INTERNET_PORT* lpnHostPort,
    BOOL*  lpfSecure)
{
    URL_COMPONENTS urlcmpTheUrl;

    LPURL_COMPONENTS lpUrlComp = &urlcmpTheUrl;

    urlcmpTheUrl.dwStructSize = sizeof(urlcmpTheUrl);

    urlcmpTheUrl.lpszScheme = NULL;
    urlcmpTheUrl.lpszHostName = NULL;
    urlcmpTheUrl.lpszUserName = NULL;
    urlcmpTheUrl.lpszPassword = NULL;
    urlcmpTheUrl.lpszUrlPath = NULL;
    urlcmpTheUrl.lpszExtraInfo = NULL;

    urlcmpTheUrl.dwSchemeLength = 1;
    urlcmpTheUrl.dwHostNameLength = 1;
    urlcmpTheUrl.dwUserNameLength = 1;
    urlcmpTheUrl.dwPasswordLength = 1;
    urlcmpTheUrl.dwUrlPathLength = 1;
    urlcmpTheUrl.dwExtraInfoLength = 1;

    if (!InternetCrackUrl(lpszUrlIn, lstrlen(lpszUrlIn),0, lpUrlComp) || !lpszHostOut || !lpszActionOut || !lpnHostPort || !lpfSecure)
    {
        return FALSE;
    }
    else
    {

        if (urlcmpTheUrl.dwHostNameLength != 0)
        {
            lstrcpyn(lpszHostOut, urlcmpTheUrl.lpszHostName, urlcmpTheUrl.dwHostNameLength+1);
        }

        if (urlcmpTheUrl.dwUrlPathLength != 0)
        {
            lstrcpyn(lpszActionOut, urlcmpTheUrl.lpszUrlPath, urlcmpTheUrl.dwUrlPathLength+1);
        }

        *lpfSecure = (urlcmpTheUrl.nScheme == INTERNET_SCHEME_HTTPS) ? TRUE : FALSE;
        *lpnHostPort = urlcmpTheUrl.nPort;

        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetupForAutoDial
//
//  Synopsis:   Enable/disable autodial to the current connectoid, and with
//              optional new credential. If autodial is enabled, initiate
//              unattended autodial using IE's dialog box
//
//  Return:     S_OK - successful
//              S_FALSE - no current connectoid or autodial was cancelled
//              HRESULT error code
//
//+---------------------------------------------------------------------------
HRESULT CRefDial::SetupForAutoDial(
    IN BOOL bEnabled,
    IN BSTR bstrUserSection OPTIONAL
    )
{
#define AUTOCONNECT_KEY_FORMAT      L"RemoteAccess\\Profile\\%s"
#define AUTOCONNECT_VALUE           L"AutoConnect"

    HRESULT hr = S_OK;
    DWORD dwValue;

    if ((m_szConnectoid[0] == L'\0') ||
        (m_szCurrentDUNFile[0] == L'\0' && m_szISPFile[0] == L'\0'))
    {
        hr = S_FALSE;
        goto cleanup;
    }

    if (bstrUserSection != NULL)
    {
        RASCREDENTIALS rascred;
        LPWSTR szCurrentFile = *m_szCurrentDUNFile != 0 ? m_szCurrentDUNFile : m_szISPFile;
        
        ZeroMemory(&rascred, sizeof(rascred));
        rascred.dwSize = sizeof(rascred);
        rascred.dwMask = RASCM_UserName | RASCM_Password | RASCM_DefaultCreds;

        if (!GetPrivateProfileString(
                bstrUserSection,
                cszUserName,
                L"",
                rascred.szUserName,
                ARRAYSIZE(rascred.szUserName),
                szCurrentFile) || 
            !GetPrivateProfileString(
                bstrUserSection,
                cszPassword,
                L"",
                rascred.szPassword,
                ARRAYSIZE(rascred.szPassword),
                szCurrentFile))
        {
            TRACE2(
                L"Credentials not available in %s [%s]",
                szCurrentFile,
                bstrUserSection
                );
            
            hr = E_INVALIDARG;
            goto cleanup;
        }

        TRACE2(
            L"Update Credentials UserName=%s, Password=%s",
            rascred.szUserName,
            rascred.szPassword
            );

        hr = HRESULT_FROM_WIN32(RasSetCredentials(
                NULL,
                m_szConnectoid,
                &rascred,
                FALSE));
        if (FAILED(hr))
        {
            TRACE1(L"Update Credentials failed 0x%08lx", hr);
            goto cleanup;
        }
    }

    //
    // Even though we call InternetDial directly, we enable autodial
    // so that if the connection is disconnected while browsering
    // in IE, IE will prompt users for reconnect.
    //

    if (!m_bAutodialModeSaved)
    {
        DWORD dwSize = sizeof(DWORD);
        
        m_bAutodialModeSaved = InternetQueryOption(
            NULL,
            INTERNET_OPTION_AUTODIAL_MODE,
            &m_dwOrigAutodialMode,
            &dwSize);

        if (m_bAutodialModeSaved)
        {
            TRACE1(L"Save original autodial mode %d", m_dwOrigAutodialMode);
        }
        else
        {
            TRACE1(L"Save original autodial mode failed: %d", GetLastError());
        }
    }

    dwValue = (bEnabled) ? AUTODIAL_MODE_NO_NETWORK_PRESENT : AUTODIAL_MODE_NEVER;

    TRACE1(L"Set autodial mode to %d", dwValue);
    
    if (!InternetSetOption(
        NULL,
        INTERNET_OPTION_AUTODIAL_MODE,
        &dwValue,
        sizeof(DWORD)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        TRACE1(L"Set autodial mode failed: 0x%08lx", hr);
        
        goto cleanup;
    }
    else
    {
        //
        // need to cleanup if autodial has been enabled or is enabled.
        //
        
        m_bCleanupAutodial = m_bCleanupAutodial || bEnabled;
    }

    //
    // Make the connectoid autoconnect to avoid the username confusing user
    //
    
    if (bEnabled)
    {
        //
        // ISSUE 2002/06/12 chunhoc - hack to make the Autodial dialog remain 
        // opened in case of dialing error, while autoconnect is used.
        //
        
        WCHAR szKey[ARRAYSIZE(AUTOCONNECT_KEY_FORMAT) + ARRAYSIZE(m_szConnectoid)];
        
        StringCchPrintf(
            szKey,
            ARRAYSIZE(szKey),
            AUTOCONNECT_KEY_FORMAT,
            m_szConnectoid
            );

        dwValue = 1;
        SHSetValue(
            HKEY_CURRENT_USER,
            szKey,
            AUTOCONNECT_VALUE,
            REG_DWORD,
            &dwValue,
            sizeof(DWORD)
            );
        
        TRACE(L"Start InternetDial ...");
        
        dwValue = 0;
        hr = InternetDial(
                gpCommMgr->m_hwndCallBack,
                m_szConnectoid,
                INTERNET_AUTODIAL_FORCE_ONLINE | INTERNET_AUTODIAL_FORCE_UNATTENDED,
                &dwValue,
                0
                );

        TRACE2(L"InternetDial returns %d, dwConnection=0x%08lx", hr, dwValue);

        if (SUCCEEDED(hr) && !dwValue)
        {
            //
            // User may have cancelled the dialing.
            //
            
            hr = S_FALSE;
        }
    }

cleanup:

    return hr;
}

void CRefDial::CleanupAutodial()
{   
    if (m_bAutodialModeSaved)
    {
        TRACE1(L"Restore autodial mode %d", m_dwOrigAutodialMode);
        if (!InternetSetOption(
            NULL,
            INTERNET_OPTION_AUTODIAL_MODE,
            &m_dwOrigAutodialMode,
            sizeof(DWORD)))
        {
            TRACE1(L"Restore autodial mode failed %d", GetLastError());
        }
        
        m_bAutodialModeSaved = FALSE;
    }

    if (m_bCleanupAutodial)
    {
        HGLOBAL pBufferToFree = NULL;
        RASCONN rasconn;
        LPRASCONN prc = &rasconn;
        prc->dwSize = sizeof(RASCONN);
        DWORD cbSize = sizeof(RASCONN);
        DWORD cConnection;
        DWORD dwError;
        
        dwError = RasEnumConnections(prc, &cbSize, &cConnection);
        if (dwError == ERROR_BUFFER_TOO_SMALL)
        {
            pBufferToFree = GlobalAlloc(GPTR, cbSize);

            prc = (RASCONN*) pBufferToFree;
            if (prc)
            {
                prc->dwSize = sizeof(RASCONN);

                dwError = RasEnumConnections(prc, &cbSize, &cConnection);
            }
        }

        if (dwError == ERROR_SUCCESS)
        {
            for (DWORD i = 0; i < cConnection; i++)
            {
                if (!lstrcmp(prc[i].szEntryName, m_szConnectoid))
                {
                    dwError = RasHangUp(prc[i].hrasconn);
                    
                    TRACE2(L"Hangup connection [%s]: %d",
                        prc[i].szEntryName,
                        dwError
                        );
                }
            }
        }

        if (pBufferToFree)
        {
            GlobalFree(pBufferToFree);
        }

        m_bCleanupAutodial = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\refdial.h ===
// RefDial.h : Declaration of the CRefDial

#ifndef __REFDIAL_H_
#define __REFDIAL_H_

#include "rnaapi.h"
#include "import.h"
#include "inshdlr.h"
#include "obcomglb.h"
#include "ispcsv.h"
#include "ispdata.h"

// Defines used for Dialing
#define MAX_EXIT_RETRIES 10
#define MAX_RETIES 3
#define MAX_RASENTRYNAME 126

#define MAX_STRING      256  //used by ErrorMsg1 in mt.cpp

#define MAX_VERSION_LEN 40
#define szLoginKey L"Software\\Microsoft\\MOS\\Connection"
#define szCurrentComDev L"CurrentCommDev"
#define szTollFree L"OlRegPhone"
#define CCD_BUFFER_SIZE 255
#define szSignupConnectoidName L"MSN Signup Connection"
#define szSignupDeviceKey L"SignupCommDevice"
#define KEYVALUE_SIGNUPID L"iSignUp"
#define RASENTRYVALUENAME L"RasEntryName"
#define GATHERINFOVALUENAME L"UserInfo"
#define INFFILE_USER_SECTION L"User"
#define INFFILE_PASSWORD L"Password"
#define NULLSZ L""

typedef DWORD (WINAPI *PFNRASGETCONNECTSTATUS)(HRASCONN, LPRASCONNSTATUS);

static const WCHAR cszBrandingSection[]  = L"Branding";
static const WCHAR cszBrandingFlags[] = L"Flags";

static const WCHAR cszSupportSection[]  = L"Support";
static const WCHAR cszSupportNumber[] = L"SupportPhoneNumber";

static const WCHAR cszLoggingSection[]  = L"Logging";
static const WCHAR cszStartURL[] = L"StartURL";
static const WCHAR cszEndURL[] = L"EndURL";

typedef struct ISPLIST
{
    void*    pElement;
    int      uElem;
    ISPLIST* pNext;
} ISPLIST;

class RNAAPI;
class CISPImport;
class CObCommunicationManager;
/////////////////////////////////////////////////////////////////////////////
// CRefDial
class CRefDial 
{
public:

    CRefDial();
    CRefDial::~CRefDial();
    friend DWORD WINAPI DownloadThreadInit(LPVOID lpv);

public:

    virtual HRESULT SetupForDialing(UINT nType, BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, DWORD dwAppMode, DWORD dwMigISPIdx, LPCWSTR szRasDeviceName);
    virtual HRESULT DoConnect(BOOL *pbRetVal) ;
    virtual HRESULT DoHangup() ;
    virtual HRESULT GetDialPhoneNumber(BSTR *pVal);
    virtual HRESULT PutDialPhoneNumber(BSTR newVal);
    virtual HRESULT SetDialAlternative(BOOL bVal);
    virtual HRESULT GetDialErrorMsg(BSTR *pVal);
    virtual HRESULT GetSupportNumber(BSTR *pVal);
    virtual HRESULT RemoveConnectoid(BOOL *pbRetVal);
    virtual HRESULT ReadPhoneBook(LPGATHERINFO lpGatherInfo, PSUGGESTINFO pSuggestInfo);    
    virtual HRESULT get_SignupURL(BSTR * pVal);
    virtual HRESULT get_ReconnectURL(BSTR * pVal);
    virtual HRESULT CheckPhoneBook(BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, BOOL *pbRetVal);
    virtual HRESULT GetConnectionType(DWORD * pdwVal);
    virtual HRESULT DoOfferDownload(BOOL *pbRetVal);
    virtual HRESULT FormReferralServerURL(BOOL * pbRetVal);
    virtual HRESULT OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL* bHandled);
    virtual HRESULT GetISPList(BSTR* pbstrISPList);
    virtual HRESULT Set_SelectISP(UINT nVal);
    virtual HRESULT Set_ConnectionMode(UINT nVal);
    virtual HRESULT Get_ConnectionMode(UINT *pnVal);
    virtual HRESULT DownloadISPOffer(BOOL *pbVal, BSTR *pVal);
    virtual HRESULT ProcessSignedPID(BOOL * pbRetVal);
    virtual HRESULT get_SignedPID(BSTR * pVal);
    virtual HRESULT get_ISDNAutoConfigURL(BSTR *pVal);
    virtual HRESULT get_AutoConfigURL(BSTR *pVal);
    virtual HRESULT get_ISPName(BSTR *pVal);
    virtual HRESULT RemoveDownloadDir() ;
    virtual HRESULT PostRegData(DWORD dwSrvType, LPWSTR szPath);
    virtual HRESULT CheckStayConnected(BSTR bstrISPFile, BOOL *pbVal);
    virtual HRESULT Connect(UINT nType, BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag, DWORD dwAppMode);
    virtual HRESULT CheckOnlineStatus(BOOL *pbVal);
    virtual HRESULT GetPhoneBookNumber(BSTR *pVal);
   
    BOOL CrackUrl(const WCHAR* lpszUrlIn, WCHAR* lpszHostOut, WCHAR* lpszActionOut, INTERNET_PORT* lpnHostPort, BOOL* lpfSecure);
    
    BOOL ParseISPInfo(HWND hDlg, WCHAR *pszCSVFileName, BOOL bCheckDupe);

    // Dialing service functions
    HRESULT GetDisplayableNumber();
    HRESULT Dial();
    BOOL    FShouldRetry(HRESULT hrErr);

    DWORD   ReadConnectionInformation(void);
    DWORD   FillGatherInfoStruct(LPGATHERINFO lpGatherInfo);
    HRESULT CreateEntryFromDUNFile(LPWSTR pszDunFile);
    
    HRESULT SetupForRASDialing(LPGATHERINFO lpGatherInfo, 
                               HINSTANCE hPHBKDll,
                               LPDWORD lpdwPhoneBook,
                               PSUGGESTINFO pSuggestInfo,
                               WCHAR *pszConnectoid, 
                               BOOL FAR *bConnectiodCreated);
    HRESULT SetupConnectoid(PSUGGESTINFO pSuggestInfo, int irc, 
                            WCHAR *pszConnectoid, DWORD dwSize, BOOL * pbSuccess);
    
    HRESULT MyRasGetEntryProperties(LPWSTR lpszPhonebookFile,
                                        LPWSTR lpszPhonebookEntry, 
                                        LPRASENTRY *lplpRasEntryBuff,
                                        LPDWORD lpdwRasEntryBuffSize,
                                        LPRASDEVINFO *lplpRasDevInfoBuff,
                                        LPDWORD lpdwRasDevInfoBuffSize);
    static void CALLBACK RasDialFunc( HRASCONN hRas, UINT unMsg,
                           RASCONNSTATE rasconnstate,
                           DWORD dwError,
                           DWORD dwErrorEx);
    BOOL get_QueryString(WCHAR* szTemp, DWORD dwSize);

    DWORD DialThreadInit(LPVOID pdata);
    DWORD ConnectionMonitorThread(LPVOID pdata);
    void  TerminateConnMonitorThread();
    HRESULT RasGetConnectStatus(BOOL *pVal);
    void CleanISPList();
    void DeleteDirectory(LPCWSTR szDirName);
    HRESULT SetupForAutoDial(BOOL bEnabled, BSTR bstrUserSection);

    // Dialing service members
    UINT            m_unRasDialMsg;
    DWORD           m_dwTapiDev;
    HRASCONN        m_hrasconn;
    WCHAR           m_szConnectoid[RAS_MaxEntryName+1];
    DWORD           m_dwThreadID;
    HINSTANCE       m_hRasDll;
    FARPROC         m_fpRasDial;
    FARPROC         m_fpRasGetEntryDialParams;
    LPGATHERINFO    m_pGI;
    WCHAR           m_szUrl[INTERNET_MAX_URL_LENGTH];               // Download thread
    HANDLE          m_hThread;
    HANDLE          m_hDialThread;
    HANDLE          m_hConnMonThread;
    HANDLE          m_hConnectionTerminate;
    HANDLE          m_hEventError;

    DWORD_PTR       m_dwDownLoad;           // Download thread
    HLINEAPP        m_hLineApp;
    DWORD           m_dwAPIVersion;
    LPWSTR          m_pszDisplayable;
    LPWSTR          m_pszOriginalDisplayable;
    RNAAPI          *m_pcRNA;
    WCHAR           m_szPhoneNumber[256];
    BOOL            m_bDialAsIs;
    BOOL            m_bDialCustom;
    UINT            m_uiRetry;
    WCHAR           m_szISPFile[MAX_PATH];
    WCHAR           m_szCurrentDUNFile[MAX_PATH];
    WCHAR           m_szLastDUNFile[MAX_PATH];
    WCHAR           m_szEntryName[RAS_MaxEntryName+1];
    WCHAR           m_szISPSupportNumber[RAS_MaxAreaCode + RAS_MaxPhoneNumber +1];

    BOOL            m_bDownloadHasBeenCanceled;
    BOOL            m_bDisconnect;
    BOOL            m_bFromPhoneBook;
    BOOL            m_bDialAlternative;

    LPGATHERINFO    m_lpGatherInfo;
    //
    // Used for Phone book look-up
    //
    SUGGESTINFO     m_SuggestInfo;

    CISPImport      m_ISPImport;      // Import an ISP file

    CINSHandler     m_InsHandler;

    int             m_RasStatusID;
    int             m_DownloadStatusID;

    WCHAR           m_szRefServerURL[INTERNET_MAX_URL_LENGTH];
    WCHAR           m_szRegServerName[INTERNET_MAX_URL_LENGTH];
    INTERNET_PORT   m_nRegServerPort;
    BOOL            m_fSecureRegServer;
    WCHAR           m_szRegFormAction[INTERNET_MAX_URL_LENGTH];
    LPRASENTRY      m_reflpRasEntryBuff;
    LPRASDEVINFO    m_reflpRasDevInfoBuff;
    DWORD           m_dwRASErr;
    DWORD           m_dwCnType;
    WCHAR*          m_pszISPList;
    DWORD           m_dwNumOfAutoConfigOffers;
    ISPLIST*        m_pCSVList;
    BOOL            m_bUserInitiateHangup;
    UINT            m_unSelectedISP;

protected:
    CRITICAL_SECTION m_csMyCriticalSection;
    BOOL            m_bTryAgain;
    BOOL            m_bQuitWizard;
    BOOL            m_bUserPickNumber;
    BOOL            m_bRedial;
    HRESULT         m_hrDisplayableNumber;

    BSTR            m_bstrPromoCode;
    BSTR            m_bstrProductCode;
    WCHAR           m_szOEM[MAX_OEMNAME];
    BSTR            m_bstrSignedPID;
    BSTR            m_bstrSupportNumber;
    BSTR            m_bstrLoggingStartUrl;
    BSTR            m_bstrLoggingEndUrl;

    long            m_lAllOffers;
    DWORD           m_dwCountryCode;

    long            m_lBrandingFlags;
    long            m_lCurrentModem;
    // Version of the wizard HTML.  Sent to RefServer
    DWORD           m_dwWizardVersion;
    WCHAR           m_szPID[(MAX_DIGITAL_PID * 2) + 1];  
    long            m_PhoneNumberEnumidx;

private:
    BOOL IsDBCSString( CHAR *sz );
    void GetISPFileSettings(LPWSTR lpszFile);
    void CleanupAutodial();
    
    BOOL m_bModemOverride;
    DWORD m_dwConnectionType;
    DWORD m_dwAppMode;
    DWORD m_bDial;
    CISPCSV* m_pSelectedISPInfo;
    CICWISPData* m_pISPData;
    BOOL m_bAutodialModeSaved;
    BOOL m_bCleanupAutodial;
    DWORD m_dwOrigAutodialMode;

};

#endif //__REFDIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\rnaapi.h ===
// ############################################################################
#ifndef __RNAANPI_H_
#define __RNAANPI_H_
#include "enumodem.h"
#include "obcomglb.h"

#define RASAPI_LIBRARY L"RASAPI32.DLL"
#define RNAPH_LIBRARY L"RNAPH.DLL"


#define RASAPI_RASSETENTRY "RasSetEntryPropertiesA"
#define RASAPI_RASGETENTRY "RasGetEntryPropertiesA"
#define RASAPI_RASDELETEENTRY "RasDeleteEntryA"
#define LEN_APPEND_INT              3           // number of digits for MAX_APPEND_INT  
#define MAX_APPEND_INT              999         // maximum number to append to connectoid name                                  // when cycling through names to create unique name

// ############################################################################
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASDELETEENTRY)(LPWSTR lpszPhonebook, LPWSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASHANGUP)(HRASCONN);

typedef DWORD (WINAPI* PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* PFNRASDIAL)(LPRASDIALEXTENSIONS, LPWSTR,LPRASDIALPARAMS,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI* PFNRASGETENTRYDIALPARAMS)(LPCWSTR, LPRASDIALPARAMS,LPBOOL);
typedef DWORD (WINAPI* PFNRASGETCONNECTSTATUS)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (WINAPI* PFNRASGETCOUNTRYINFO)(LPRASCTRYINFO, LPDWORD);
typedef DWORD (WINAPI* PFNRASSETENTRYDIALPARAMS)(LPCWSTR, LPRASDIALPARAMS,BOOL);
//BOOL LclSetEntryScriptPatch(LPWSTR lpszScript, LPCWSTR lpszEntry);
static const WCHAR szDefaultAreaCode[] = L"555";
static const WCHAR cszDeviceSwitch[] = L"DEVICE=switch";
static const WCHAR cszRasPBKFilename[] = L"\\ras\\rasphone.pbk";
#define SCRIPT_PATCH_BUFFER_SIZE 2048
#define SIZEOF_NULL 1
static const WCHAR cszType[] = L"Type=";


/*
typedef struct tagINETCLIENTINFO
{
    DWORD   dwSize;
    DWORD   dwFlags;
    WCHAR    szEMailName[MAX_EMAIL_NAME + 1];
    WCHAR    szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    WCHAR    szPOPLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szPOPServer[MAX_SERVER_NAME + 1];
    WCHAR    szSMTPServer[MAX_SERVER_NAME + 1];
    WCHAR    szNNTPLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szNNTPServer[MAX_SERVER_NAME + 1];
    // end of version 1.0 structure;
    // extended 1.1 structure includes the following fields:
    WCHAR    szNNTPName[MAX_EMAIL_NAME + 1];
    WCHAR    szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
    int     iIncomingProtocol;
    WCHAR    szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szIncomingMailServer[MAX_SERVER_NAME + 1];
    BOOL    fMailLogonSPA;
    BOOL    fNewsLogonSPA;
    WCHAR    szLDAPLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szLDAPServer[MAX_SERVER_NAME + 1];
    BOOL    fLDAPLogonSPA;
    BOOL    fLDAPResolve;

} INETCLIENTINFO, *PINETCLIENTINFO, FAR *LPINETCLIENTINFO;

*/





// ############################################################################
class RNAAPI
{
public:
    RNAAPI();
    ~RNAAPI();

    DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
    DWORD RasValidateEntryName(LPCWSTR, LPCWSTR);
    DWORD RasSetEntryProperties(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry,
                                LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
                                LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
    DWORD RasGetEntryProperties(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry,
                                LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
                                LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
    DWORD RasDeleteEntry(LPWSTR lpszPhonebook, LPWSTR lpszEntry);
    DWORD RasHangUp(HRASCONN hrasconn);
    DWORD RasGetEntryDialParams(LPCWSTR lpszPhonebook, LPRASDIALPARAMS lprasdialparams,
                                LPBOOL lpfPassword);
    DWORD RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions, LPWSTR lpszPhonebook,
                  LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,LPVOID lpvNotifier,
                  LPHRASCONN lphRasConn);
    DWORD RasEnumConnections(LPRASCONN lprasconn, LPDWORD lpcb,LPDWORD lpcConnections);
    DWORD RasGetConnectStatus(HRASCONN, LPRASCONNSTATUS);
    DWORD RasGetCountryInfo(LPRASCTRYINFO, LPDWORD);
    DWORD RasSetEntryDialParams(LPCWSTR, LPRASDIALPARAMS,BOOL);
    HRESULT InetConfigClientEx(
      HWND              hwndParent,
      LPCWSTR            lpszPhonebook,
      LPCWSTR            lpszEntryName,
      LPRASENTRY        lpRasEntry,
      LPCWSTR            lpszUsername,
      LPCWSTR            lpszPassword,
      LPCWSTR            lpszProfileName,
      INETCLIENTINFO*  lpINetClientInfo,
      DWORD             dwfOptions,
      LPBOOL            lpfNeedsRestart,
      LPWSTR             szConnectoidName,
      DWORD             dwSizeOfCreatedEntryName,
      LPBYTE			lpDeviceInfo = 0,
      LPDWORD			lpdwDeviceInfoSize = 0);
private:
    BOOL LoadApi(LPCSTR, FARPROC*);
    DWORD CreateConnectoid(LPCWSTR pszPhonebook, LPCWSTR pszConnectionName,
         LPRASENTRY lpRasEntry, LPCWSTR pszUserName, LPCWSTR pszPassword,
         LPBYTE lpDeviceInfo = 0, LPDWORD lpdwDeviceInfoSize = 0);

    DWORD SetConnectoidUsername(LPCWSTR pszPhonebook, LPCWSTR pszConnectoidName,
            LPCWSTR pszUserName, LPCWSTR pszPassword);
    //BOOL LclSetEntryScriptPatch(LPCWSTR lpszScript, LPCWSTR lpszEntry);
    DWORD MakeConnectoid(
      HWND        hwndParent,
      DWORD       dwfOptions,
      LPCWSTR      lpszPhonebook,
      LPCWSTR      lpszEntryName,
      LPRASENTRY  lpRasEntry,
      LPCWSTR      lpszUsername,
      LPCWSTR      lpszPassword,
      LPBOOL      lpfNeedsRestart,
      LPBYTE		lpDeviceInfo = 0,
      LPDWORD		lpdwDeviceInfoSize = 0);

    HINSTANCE m_hInst;
    HINSTANCE m_hInst2;

    PFNRASENUMDEVICES m_fnRasEnumDeviecs;
    PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
    PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
    PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
    PFNRASDELETEENTRY m_fnRasDeleteEntry;
    PFNRASHANGUP m_fnRasHangUp;
    PFNRASENUMCONNECTIONS m_fnRasEnumConnections;
    PFNRASDIAL m_fnRasDial;
    PFNRASGETENTRYDIALPARAMS m_fnRasGetEntryDialParams;
    PFNRASGETCONNECTSTATUS m_fnRasGetConnectStatus;
    PFNRASGETCOUNTRYINFO m_fnRasGetCountryInfo;
    PFNRASSETENTRYDIALPARAMS m_fnRasSetEntryDialParams;
    CEnumModem *m_pEnumModem;
    BOOL m_bUseAutoProxyforConnectoid;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\obcomglb.h ===
#ifndef __OBCOMGLB_H_
#define __OBCOMGLB_H_

#include <windows.h>
#include <tchar.h>
#include <ras.h>
#include <raserror.h>
#include <tapi.h>
#include "wininet.h"
#include <mapidefs.h>
#include <assert.h>
#include "appdefs.h"

//--------------------------------------------------------------------------------
//  obcomglb.h
//  The information contained in this file is the sole property of Microsoft Corporation.
//  Copywrite Microsoft 1999
//
//  Created 2/7/99,     vyung
//--------------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// DEFINES
#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED
#undef DATASEG_READONLY
#define DATASEG_READONLY  ".rdata"

#define ERROR_USERCANCEL 32767 // quit message value
#define ERROR_USERBACK 32766 // back message value
#define ERROR_USERNEXT 32765 // back message value
#define ERROR_DOWNLOADIDNT 32764 // Download failure

#define ERROR_READING_DUN       32768
#define ERROR_READING_ISP       32769
#define ERROR_PHBK_NOT_FOUND    32770
#define ERROR_DOWNLOAD_NOT_FOUND 32771

#define cMarvelBpsMin 2400 // minimum modem speed
#define INVALID_PORTID UINT_MAX
#define pcszDataModem L"comm/datamodem"
#define MAX_SECTIONS_BUFFER        1024
#define MAX_KEYS_BUFFER            1024

// install TCP (if needed)
#define ICFG_INSTALLTCP            0x00000001

// install RAS (if needed)
#define ICFG_INSTALLRAS            0x00000002

// install exchange and internet mail
#define ICFG_INSTALLMAIL           0x00000004

//
// ChrisK 5/8/97
// Note: the next three switches are only valid for IcfgNeedInetComponet
// check to see if a LAN adapter with TCP bound is installed
//
#define ICFG_INSTALLLAN            0x00000008

//
// Check to see if a DIALUP adapter with TCP bound is installed
//
#define ICFG_INSTALLDIALUP         0x00000010

//
// Check to see if TCP is installed
//
#define ICFG_INSTALLTCPONLY        0x00000020

#define szLoginKey              L"Software\\Microsoft\\MOS\\Connection"
#define szCurrentComDev         L"CurrentCommDev"
#define szTollFree              L"OlRegPhone"
#define CCD_BUFFER_SIZE         255
#define szSignupConnectoidName  L"MSN Signup Connection"
#define szSignupDeviceKey       L"SignupCommDevice"
#define KEYVALUE_SIGNUPID       L"iSignUp"
#define RASENTRYVALUENAME       L"RasEntryName"
#define GATHERINFOVALUENAME     L"UserInfo"
#define INFFILE_USER_SECTION    L"User"
#define INFFILE_PASSWORD        L"Password"
#define INFFILE_DOMAIN          L"Domain"
#define DUN_SECTION             L"DUN"
#define USERNAME                L"Username"
#define INF_OEMREGPAGE          L"OEMRegistrationPage"

#define NULLSZ L""

#define cchMoreSpace 22000  // bytes needed to hold results of lineGetCountry(0, ...).
                            // Currently this function returns about 16K, docs say 20K,
                            // this should be enough.
#define DwFromSz(sz)        Sz2Dw(sz)           //make it inline, so this is faster.
#define DwFromSzFast(sz)    Sz2DwFast(sz)
#define CONNECT_SIGNUPFIRST 1 // phonenumber constant for determining the firstcall phonenumber TO DO

#define CONNECTFLAGS_MASK_TOLLFREE     0x01
#define CONNECTFLAGS_MASK_TCP          0x02
#define CONNECTFLAGS_MASK_ISDN         0x04
#define CONNECTFLAGS_MASK_DIRECT    0x08
#define CONNECTFLAGS_MASK_OTHERDIALUP  0x10
#define CONNECTFLAGS_MASK_PROXY        0x20

#define CONNECTFLAGS_MASK_FIRST     CONNECTFLAGS_MASK_TCP
#define CONNECTFLAGS_MASK_LAST      CONNECTFLAGS_MASK_ISDN

#define CONNECTMSNDIALUP(dw) ((dw & (CONNECTFLAGS_MASK_TOLLFREE|CONNECTFLAGS_M
#define LANORSHUTTLE(dw) ((dw)==10 || (dw)==34)
#define IS_SHUTTLE(dw)   ((dw)==34)
#define IS_ISP(dw)       ((dw)==18)

#define CONNECTPROTOCOL_MSNDIALUPX25      0
#define CONNECTPROTOCOL_MSNDIALUPTCP      2
#define CONNECTPROTOCOL_MSNDIALUPTCPISDN  6
#define CONNECTPROTOCOL_LANDIRECT         10
#define CONNECTPROTOCOL_ISPDIALUPTCP      18
#define CONNECTPROTOCOL_LANSHUTTLE        34

#define clineMaxATT         16          //for 950 MNEMONIC
#define NXXMin 200
#define NXXMax 999
#define cbgrbitNXX ((NXXMax + 1 - NXXMin) / 8)
#define crgnpab (NPAMax + 1 - NPAMin)

#define MAX_PROMO 64
#define MAX_OEMNAME 64
#define MAX_AREACODE RAS_MaxAreaCode
#define MAX_RELPROD 8
#define MAX_RELVER  30

#define MAX_STRING      256  //used by ErrorMsg1 in mt.cpp

#define NUM_PHBK_SUGGESTIONS    50

#define TYPE_SIGNUP_ANY         0x82
#define MASK_SIGNUP_ANY         0xB2


//#define RASENUMAPI "RasEnumConnectionsA"
//#define RASHANGUP "RasHangUpA"

#define INF_SUFFIX              L".ISP"
#define INF_PHONE_BOOK          L"PhoneBookFile"
#define INF_DUN_FILE            L"DUNFile"
#define INF_REFERAL_URL         L"URLReferral"
#define INF_SIGNUPEXE           L"Sign_Up_EXE"
#define INF_SIGNUPPARAMS        L"Sign_Up_Params"
#define INF_WELCOME_LABEL       L"Welcome_Label"
#define INF_ISP_MSNSU           L"MSICW"
#define INF_SIGNUP_URL          L"Signup"
#define INF_AUTOCONFIG_URL      L"AutoConfig"
#define INF_ISDN_URL            L"ISDNSignup"
#define INF_ISDN_AUTOCONFIG_URL L"ISDNAutoConfig"
#define INF_SECTION_URL         L"URL"
#define INF_SECTION_ISPINFO     L"ISP INFO"
#define INF_RECONNECT_URL       L"Reconnect"
#define INF_SECTION_CONNECTION  L"Connection"
#define ISP_MSNSIGNUP           L"MsnSignup"

#define QUERY_STRING_MSNSIGNUP  L"&MSNSIGNUP=1"

#define DUN_NOPHONENUMBER L"000000000000"

#define MAX_VERSION_LEN 40

#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

// 8/9/96 jmazner
// Added new macro to fix MOS Normandy Bug #4170
#define MB_MYINFORMATION (MB_APPLMODAL | MB_ICONINFORMATION | MB_SETFOREGROUND)

// 8/27/96 jmazner
#define MB_MYEXCLAMATION (MB_APPLMODAL | MB_ICONEXCLAMATION | MB_SETFOREGROUND)

#define WM_STATECHANGE          WM_USER
#define WM_DIENOW               WM_USER + 1
#define WM_DUMMY                WM_USER + 2
#define WM_DOWNLOAD_DONE        WM_USER + 3
#define WM_DOWNLOAD_PROGRESS    WM_USER + 4

#define WM_MYINITDIALOG     (WM_USER + 4)

#define MAX_REDIALS 2

#define REG_USER_INFO L"Software\\Microsoft\\User information"
#define REG_USER_NAME1 L"Default First Name"
#define REG_USER_NAME2 L"Default Last Name"
#define REG_USER_COMPANY L"Default Company"
#define REG_USER_ADDRESS1 L"Mailing Address"
#define REG_USER_ADDRESS2 L"Additional Address"
#define REG_USER_CITY L"City"
#define REG_USER_STATE L"State"
#define REG_USER_ZIP L"ZIP Code"
#define REG_USER_PHONE L"Daytime Phone"
#define REG_USER_COUNTRY L"Country"

#define SIGNUPKEY L"SOFTWARE\\MICROSOFT\\GETCONN"
#define DEVICENAMEKEY L"DeviceName"  // used to store user's choice among multiple modems
#define DEVICETYPEKEY L"DeviceType"

#define ICWSETTINGSPATH L"Software\\Microsoft\\Internet Connection Wizard"
#define ICWBUSYMESSAGES L"Software\\Microsoft\\Internet Connection Wizard\\Busy Messages"
#define ICWCOMPLETEDKEY L"Completed"
#define OOBERUNONCE     L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
#define ICSSETTINGSPATH L"Software\\Microsoft\\Windows\\CurrentVersion\\ICS"
#define ICSCLIENT       L"ICS Client"
#define RELEASEPRODUCTKEY   L"Release Product"
#define RELEASEVERSIONKEY   L"Release Product Version"
#define MAX_DIGITAL_PID     256
#define CONNECTOIDNAME      L"Connectoid"
#define ACCESSINFO          L"AccessInfo"

#define SETUPPATH_NONE L"current"
#define SETUPPATH_MANUAL L"manual"
#define SETUPPATH_AUTO L"automatic"
#define MAX_SETUPPATH_TOKEN 200
// Defines
#define MAX_ISP_NAME        (RAS_MaxEntryName-1)  // internet service provider name
#define MAX_ISP_USERNAME    UNLEN  // max length of login username
#define MAX_ISP_PASSWORD    PWLEN  // max length of login password
#define MAX_PORT_LEN        5      // max length of proxy port number (max # = 65535)


// constants for INETCLIENTINFO.dwFlags

#define INETC_LOGONMAIL     0x00000001
#define INETC_LOGONNEWS     0x00000002
#define INETC_LOGONDIRSERV  0x00000004

// Connection Type
#define CONNECTION_ICS_TYPE 0x00000001

#define ERROR_INETCFG_UNKNOWN 0x20000000L

#define MAX_EMAIL_NAME          64
#define MAX_EMAIL_ADDRESS       128
#define MAX_LOGON_NAME          UNLEN
#define MAX_LOGON_PASSWORD      PWLEN
#define MAX_SERVER_NAME         64  // max length of DNS name per RFC 1035 +1

// IE Auto proxy value in registry
#define AUTO_ONCE_EVER              0           // Auto proxy discovery
#define AUTO_DISABLED               1
#define AUTO_ONCE_PER_SESSION       2
#define AUTO_ALWAYS                 3

// Flags for dwfOptions

// install Internet mail
#define INETCFG_INSTALLMAIL           0x00000001
// Invoke InstallModem wizard if NO MODEM IS INSTALLED
#define INETCFG_INSTALLMODEM          0x00000002
// install RNA (if needed)
#define INETCFG_INSTALLRNA            0x00000004
// install TCP (if needed)
#define INETCFG_INSTALLTCP            0x00000008
// connecting with LAN (vs modem)
#define INETCFG_CONNECTOVERLAN        0x00000010
// Set the phone book entry for autodial
#define INETCFG_SETASAUTODIAL         0x00000020
// Overwrite the phone book entry if it exists
// Note: if this flag is not set, and the entry exists, a unique name will
// be created for the entry.
#define INETCFG_OVERWRITEENTRY        0x00000040
// Do not show the dialog that tells the user that files are about to be installed,
// with OK/Cancel buttons.
#define INETCFG_SUPPRESSINSTALLUI     0x00000080
// Check if TCP/IP file sharing is turned on, and warn user to turn it off.
// Reboot is required if the user turns it off.
#define INETCFG_WARNIFSHARINGBOUND    0x00000100
// Check if TCP/IP file sharing is turned on, and force user to turn it off.
// If user does not want to turn it off, return will be ERROR_CANCELLED
// Reboot is required if the user turns it off.
#define INETCFG_REMOVEIFSHARINGBOUND  0x00000200
// Indicates that this is a temporary phone book entry
// In Win3.1 an icon will not be created
#define INETCFG_TEMPPHONEBOOKENTRY    0x00000400
// Show the busy dialog while checking system configuration
#define INETCFG_SHOWBUSYANIMATION     0x00000800

//
// Chrisk 5/8/97
// Note: the next three switches are only valid for InetNeedSystemComponents
// Check if LAN adapter is installed and bound to TCP
//
#define INETCFG_INSTALLLAN            0x00001000

//
// Check if DIALUP adapter is installed and bound to TCP
//
#define INETCFG_INSTALLDIALUP         0x00002000

//
// Check to see if TCP is installed requardless of binding
//
#define INETCFG_INSTALLTCPONLY        0x00004000
/*
#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
*/
// constants for INETCLIENTINFO.dwFlags

#define INETC_LOGONMAIL     0x00000001
#define INETC_LOGONNEWS     0x00000002
#define INETC_LOGONDIRSERV  0x00000004

#define NUM_SERVER_TYPES    4

#define STR_BSTR   0
#define STR_OLESTR 1

#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPWSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPWSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)
// Note that bryanst and marcl have confirmed that this key will be supported in IE 4
#define IE_PATHKEY L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"


// IE 4 has major.minor version 4.71
// IE 3 golden has major.minor.release.build version # > 4.70.0.1155
// IE 2 has major.minor of 4.40

#define IE4_MAJOR_VERSION (UINT) 4
#define IE4_MINOR_VERSION (UINT) 71
#define IE4_VERSIONMS (DWORD) ((IE4_MAJOR_VERSION << 16) | IE4_MINOR_VERSION)
// 4-30-97 ChrisK Olympus 2934
// While the ICW is trying to connect to the referral server, indicate something is
// working
#define MAX_BUSY_MESSAGE    255
#define MAX_VALUE_NAME      10
#define DEFAULT_IDEVENT     31
#define DEFAULT_UELAPSE     3000

#define cbAreaCode  6           // maximum number of characters in an area code, not including \0
#define cbCity 19               // maximum number of chars in city name, not including \0
#define cbAccessNumber 15       // maximum number of chars in phone number, not including \0
#define cbStateName 31          // maximum number of chars in state name, not including \0
#define cbBaudRate 6            // maximum number of chars in a baud rate, not including \0
#define cbDataCenter (MAX_PATH+1)           // max length of data center string
#define MAX_EXIT_RETRIES    10

static const WCHAR szFmtAppendIntToString[] =  L"%s %d";
static const WCHAR cszOobePhBkFile[]         =  L"Phone.obe";
static const WCHAR cszOobePhBkCountry[]      =  L"COUNTRY_CODE";
static const WCHAR cszOobePhBkCount[]        =  L"NUMBERS";
static const WCHAR cszOobePhBkNumber[]       =  L"NUMBER%d";
static const WCHAR cszOobePhBkDunFile[]      =  L"NUMBER%d_DUN";
static const WCHAR cszOobePhBkCity[]         =  L"NUMBER%d_CITY";
static const WCHAR cszOobePhBkAreaCode[]     =  L"NUMBER%d_ACODE";
static const WCHAR cszOobePhBkRandom[]       =  L"RANDOM";

static const WCHAR cszHTTPS[] = L"https:";
// code relies on these two being the same length
static const WCHAR cszHTTP[]                = L"http:";
static const WCHAR cszFILE[]                = L"file:";
static const WCHAR cszOEMBRND[]             = L"oembrnd.ins";
static const WCHAR cszOEMCNFG[]             = L"oemcnfg.ins";
static const WCHAR cszISPCNFG[]             = L"ispcnfg.ins";
static const WCHAR cszOOBEINFOINI[]         = L"oobeinfo.INI";
static const WCHAR cszSignup[]              = L"Signup";
static const WCHAR cszOfferCode[]           = L"OfferCode";
static const WCHAR cszISPSignup[]           = L"ISPSignup";
static const WCHAR cszISPQuery[]            = L"Query String";
static const WCHAR cszBranding[]            = L"Branding";
static const WCHAR cszOEMName[]             = L"OEMName";
static const WCHAR cszOptions[]             = L"Options";
static const WCHAR cszBroadbandDeviceName[] = L"BroadbandDeviceName";
static const WCHAR cszBroadbandDevicePnpid[] = L"BroadbandDevicePnpid";


//--------------------------------------------------------------------------------
// Type declarations

// NOTE: due to code in connmain, the order of these IS IMPORTANT.  They should be
// in the same order that they appear.

typedef HRESULT (WINAPI * ICFGNEEDSYSCOMPONENTS)  (DWORD dwfOptions, LPBOOL lpfNeedComponents);

typedef struct tagGatherInfo
{
    LCID    m_lcidUser;
    LCID    m_lcidSys;
    LCID    m_lcidApps;
    DWORD   m_dwOS;
    DWORD   m_dwMajorVersion;
    DWORD   m_dwMinorVersion;
    WORD    m_wArchitecture;
    WCHAR   m_szPromo[MAX_PROMO];

    DWORD   m_dwCountryID;
    DWORD   m_dwCountryCode;
    WCHAR   m_szAreaCode[MAX_AREACODE+1];
    HWND    m_hwnd;
    LPLINECOUNTRYLIST m_pLineCountryList;
    BOOL    m_bUsePhbk;
    //LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;

    WCHAR   m_szSUVersion[MAX_VERSION_LEN];
    WORD    m_wState;
    BYTE    m_fType;
    BYTE    m_bMask;
    WCHAR   m_szISPFile[MAX_PATH+1];
    WCHAR   m_szAppDir[MAX_PATH+1];

    WCHAR   m_szRelProd[MAX_RELPROD + 1];
    WCHAR   m_szRelVer[MAX_RELVER + 1];
    DWORD   m_dwFlag;

} GATHERINFO, *LPGATHERINFO;


typedef struct tagRASDEVICE
{
    LPRASDEVINFO lpRasDevInfo;
    DWORD dwTapiDev;
} RASDEVICE, *PRASDEVICE;

HRESULT GetINTFromISPFile
(
    LPWSTR   pszISPCode,
    LPWSTR   pszSection,
    LPWSTR   pszDataName,
    int far *lpData,
    int     iDefaultValue
);


typedef struct tagINETCLIENTINFO
{
    DWORD   dwSize;
    DWORD   dwFlags;
    WCHAR    szEMailName[MAX_EMAIL_NAME + 1];
    WCHAR    szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    WCHAR    szPOPLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szPOPServer[MAX_SERVER_NAME + 1];
    WCHAR    szSMTPServer[MAX_SERVER_NAME + 1];
    WCHAR    szNNTPLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szNNTPServer[MAX_SERVER_NAME + 1];
    // end of version 1.0 structure;
    // extended 1.1 structure includes the following fields:
    WCHAR    szNNTPName[MAX_EMAIL_NAME + 1];
    WCHAR    szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
    int     iIncomingProtocol;
    WCHAR    szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szIncomingMailServer[MAX_SERVER_NAME + 1];
    BOOL    fMailLogonSPA;
    BOOL    fNewsLogonSPA;
    WCHAR    szLDAPLogonName[MAX_LOGON_NAME + 1];
    WCHAR    szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR    szLDAPServer[MAX_SERVER_NAME + 1];
    BOOL    fLDAPLogonSPA;
    BOOL    fLDAPResolve;

} INETCLIENTINFO, *PINETCLIENTINFO, FAR *LPINETCLIENTINFO;



typedef struct SERVER_TYPES_tag
{
    WCHAR szType[6];
    DWORD dwType;
    DWORD dwfOptions;
} SERVER_TYPES;

typedef struct
{
    DWORD   dwIndex;                                // index number
    BYTE    bFlipFactor;                            // for auto-pick
    DWORD   fType;                                  // phone number type
    WORD    wStateID;                               // state ID
    DWORD   dwCountryID;                            // TAPI country ID
    DWORD   dwCountryCode;                          // TAPI country code
    DWORD   dwAreaCode;                             // area code or NO_AREA_CODE if none
    DWORD   dwConnectSpeedMin;                      // minimum baud rate
    DWORD   dwConnectSpeedMax;                      // maximum baud rate
    WCHAR   szCity[MAX_PATH];          // city name
    WCHAR   szAccessNumber[MAX_PATH];  // access number
    WCHAR   szDataCenter[MAX_PATH];              // data center access string
    WCHAR   szAreaCode[MAX_PATH];                  //Keep the actual area code string around.
} ACCESSENTRY, far *PACCESSENTRY;   // ae


typedef struct tagSUGGESTIONINFO
{
    DWORD   dwCountryID;
    DWORD   dwCountryCode;
    DWORD   dwAreaCode;
    DWORD   dwPick;
    WORD    wNumber;
    //DWORD fType;  // 9/6/96 jmazner  Normandy
    //DWORD bMask;  // make this struct look like the one in %msnroot%\core\client\phbk\phbk.h
    ACCESSENTRY AccessEntry;
} SUGGESTINFO, far *PSUGGESTINFO;

// structure used to pass information to mail profile config APIs.
// Most likely the pointers point into a USERINFO struct,
typedef struct MAILCONFIGINFO {
    WCHAR * pszEmailAddress;          // user's email address
    WCHAR * pszEmailServer;          // user's email server path
    WCHAR * pszEmailDisplayName;        // user's name
    WCHAR * pszEmailAccountName;        // account name
    WCHAR * pszEmailAccountPwd;        // account password
    WCHAR * pszProfileName;          // name of profile to use
                      // (create or use default if NULL)
    BOOL fSetProfileAsDefault;        // set profile as default profile

    WCHAR * pszConnectoidName;        // name of connectoid to dial
    BOOL fRememberPassword;          // password cached if TRUE
} MAILCONFIGINFO;

// structure to pass data back from IDD_CHOOSEPROFILENAME handler
typedef struct tagCHOOSEPROFILEDLGINFO
{
  WCHAR szProfileName[cchProfileNameMax+1];
  BOOL fSetProfileAsDefault;
} CHOOSEPROFILEDLGINFO, * PCHOOSEPROFILEDLGINFO;

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;

// The following are the names for the name/value pairs that will be passed as a query string to the
// ISP signup server
const WCHAR csz_USER_FIRSTNAME[]        = L"USER_FIRSTNAME";
const WCHAR csz_USER_LASTNAME[]         = L"USER_LASTNAME";
const WCHAR csz_USER_ADDRESS[]          = L"USER_ADDRESS";
const WCHAR csz_USER_MOREADDRESS[]      = L"USER_MOREADDRESS";
const WCHAR csz_USER_CITY[]             = L"USER_CITY";
const WCHAR csz_USER_STATE[]            = L"USER_STATE";
const WCHAR csz_USER_ZIP[]              = L"USER_ZIP";
const WCHAR csz_USER_PHONE[]            = L"USER_PHONE";
const WCHAR csz_AREACODE[]              = L"AREACODE";
const WCHAR csz_COUNTRYCODE[]           = L"COUNTRYCODE";
const WCHAR csz_USER_FE_NAME[]          = L"USER_FE_NAME";
const WCHAR csz_PAYMENT_TYPE[]          = L"PAYMENT_TYPE";
const WCHAR csz_PAYMENT_BILLNAME[]      = L"PAYMENT_BILLNAME";
const WCHAR csz_PAYMENT_BILLADDRESS[]   = L"PAYMENT_BILLADDRESS";
const WCHAR csz_PAYMENT_BILLEXADDRESS[] = L"PAYMENT_BILLEXADDRESS";
const WCHAR csz_PAYMENT_BILLCITY[]      = L"PAYMENT_BILLCITY";
const WCHAR csz_PAYMENT_BILLSTATE[]     = L"PAYMENT_BILLSTATE";
const WCHAR csz_PAYMENT_BILLZIP[]       = L"PAYMENT_BILLZIP";
const WCHAR csz_PAYMENT_BILLPHONE[]     = L"PAYMENT_BILLPHONE";
const WCHAR csz_PAYMENT_DISPLAYNAME[]   = L"PAYMENT_DISPLAYNAME";
const WCHAR csz_PAYMENT_CARDNUMBER[]    = L"PAYMENT_CARDNUMBER";
const WCHAR csz_PAYMENT_EXMONTH[]       = L"PAYMENT_EXMONTH";
const WCHAR csz_PAYMENT_EXYEAR[]        = L"PAYMENT_EXYEAR";
const WCHAR csz_PAYMENT_CARDHOLDER[]    = L"PAYMENT_CARDHOLDER";
const WCHAR csz_SIGNED_PID[]            = L"SIGNED_PID";
const WCHAR csz_GUID[]                  = L"GUID";
const WCHAR csz_OFFERID[]               = L"OFFERID";
const WCHAR csz_USER_COMPANYNAME[]      = L"USER_COMPANYNAME";
const WCHAR csz_ICW_VERSION[]           = L"ICW_Version";

//Info required flags
// 1 -- required
// 0 -- optional

//User Info
#define REQUIRE_FE_NAME                        0x00000001
#define REQUIRE_FIRSTNAME                      0x00000002
#define REQUIRE_LASTNAME                       0x00000004
#define REQUIRE_ADDRESS                        0x00000008
#define REQUIRE_MOREADDRESS                    0x00000010
#define REQUIRE_CITY                           0x00000020
#define REQUIRE_STATE                          0x00000040
#define REQUIRE_ZIP                            0x00000080
#define REQUIRE_PHONE                          0x00000100
#define REQUIRE_COMPANYNAME                    0x00000200
//Credit Card
#define REQUIRE_CCNAME                         0x00000400
#define REQUIRE_CCADDRESS                      0x00000800
#define REQUIRE_CCNUMBER                       0x00001000
#define REQUIRE_CCZIP                          REQUIRE_ZIP
//Invoice
#define REQUIRE_IVADDRESS1                     REQUIRE_ADDRESS
#define REQUIRE_IVADDRESS2                     REQUIRE_MOREADDRESS
#define REQUIRE_IVCITY                         REQUIRE_CITY
#define REQUIRE_IVSTATE                        REQUIRE_STATE
#define REQUIRE_IVZIP                          REQUIRE_ZIP
//Phone
#define REQUIRE_PHONEIV_BILLNAME               0x00002000
#define REQUIRE_PHONEIV_ACCNUM                 REQUIRE_PHONE

//Htm pagetype flags
#define PAGETYPE_UNDEFINED                     E_FAIL
#define PAGETYPE_NOOFFERS                      0x00000001
#define PAGETYPE_MARKETING                     0x00000002
#define PAGETYPE_BRANDED                       0x00000004
#define PAGETYPE_BILLING                       0x00000008
#define PAGETYPE_CUSTOMPAY                     0x00000010
#define PAGETYPE_ISP_NORMAL                    0x00000020
#define PAGETYPE_ISP_TOS                       0x00000040
#define PAGETYPE_ISP_FINISH                    0x00000080
#define PAGETYPE_ISP_CUSTOMFINISH              0x00000100
#define PAGETYPE_OLS_FINISH                    0x00000200

typedef BOOL (* VALIDATECONTENT)    (LPCWSTR lpData);

enum IPSDataContentValidators
{
    ValidateCCNumber = 0,
    ValidateCCExpire
};

typedef struct tag_ISPDATAELEMENT
{
    LPCWSTR         lpQueryElementName;             // Static name to put in query string
    LPWSTR          lpQueryElementValue;            // data for element
    WORD            idContentValidator;             // id of content validator
    WORD            wValidateNameID;                // validation element name string ID
    DWORD           dwValidateFlag;                 // validation bit flag for this element
}ISPDATAELEMENT, *LPISPDATAELEMENT;

enum IPSDataElements
{
    ISPDATA_USER_FIRSTNAME = 0,
    ISPDATA_USER_LASTNAME,
    ISPDATA_USER_ADDRESS,
    ISPDATA_USER_MOREADDRESS,
    ISPDATA_USER_CITY,
    ISPDATA_USER_STATE,
    ISPDATA_USER_ZIP,
    ISPDATA_USER_PHONE,
    ISPDATA_AREACODE,
    ISPDATA_COUNTRYCODE,
    ISPDATA_USER_FE_NAME,
    ISPDATA_PAYMENT_TYPE,
    ISPDATA_PAYMENT_BILLNAME,
    ISPDATA_PAYMENT_BILLADDRESS,
    ISPDATA_PAYMENT_BILLEXADDRESS,
    ISPDATA_PAYMENT_BILLCITY,
    ISPDATA_PAYMENT_BILLSTATE,
    ISPDATA_PAYMENT_BILLZIP,
    ISPDATA_PAYMENT_BILLPHONE,
    ISPDATA_PAYMENT_DISPLAYNAME,
    ISPDATA_PAYMENT_CARDNUMBER,
    ISPDATA_PAYMENT_EXMONTH,
    ISPDATA_PAYMENT_EXYEAR,
    ISPDATA_PAYMENT_CARDHOLDER,
    ISPDATA_SIGNED_PID,
    ISPDATA_GUID,
    ISPDATA_OFFERID,
    ISPDATA_BILLING_OPTION,
    ISPDATA_PAYMENT_CUSTOMDATA,
    ISPDATA_USER_COMPANYNAME,
    ISPDATA_ICW_VERSION
};

enum ISPDATAValidateLevels
{
    ISPDATA_Validate_None = 0,
    ISPDATA_Validate_DataPresent,
    ISPDATA_Validate_Content
};
//--------------------------------------------------------------------------------
// Prototypes
// functions in MAPICALL.C
BOOL InitMAPI(HWND hWnd);
VOID DeInitMAPI(VOID);
HRESULT SetMailProfileInformation(MAILCONFIGINFO * pMailConfigInfo);
BOOL FindInternetMailService(WCHAR * pszEmailAddress, DWORD cbEmailAddress,
  WCHAR * pszEmailServer, DWORD cbEmailServer);

DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );
BOOL FInsureTCPIP();
LPWSTR GetSz(DWORD dwszID);
//void SetStatusArrow(CState wState);
BOOL FInsureModemTAPI(HWND hwnd);
BOOL FGetModemSpeed(PDWORD pdwSpeed);
BOOL FGetDeviceID(HLINEAPP *phLineApp, PDWORD pdwAPI, PDWORD pdwDevice);
BOOL FDoModemWizard(HWND hWnd);

BOOL FInsureNetwork(PBOOL pfNeedReboot);
BOOL TestInternetConnection();

WORD Sz2W (LPCWSTR szBuf);
DWORD Sz2Dw(LPCWSTR pSz);
DWORD Sz2DwFast(LPCWSTR pSz);
BOOL FSz2Dw(LPCWSTR pSz, LPDWORD dw);
BOOL FSz2DwEx(LPCWSTR pSz, DWORD far *dw);
BOOL FSz2WEx(LPCWSTR pSz, WORD far *w);
BOOL FSz2W(LPCWSTR pSz, WORD far *w);
BOOL FSz2B(LPCWSTR pSz, BYTE far *pb);
BOOL FSz2W(LPCWSTR pSz, WORD far *w);
BOOL FSz2BOOL(LPCWSTR pSz, BOOL far *pbool);
BOOL FSz2SPECIAL(LPCWSTR pSz, BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt);
BOOL FSz2B(LPCWSTR pSz, BYTE far *pb);

int __cdecl CompareCountryNames(const void *pv1, const void *pv2);
DWORD GetCurrentTapiCountryID(void);
int __cdecl CompareNPAEntry(const void *pv1, const void *pv2);
//HRESULT GatherInformation(LPGATHERINFO pGatheredInfo, HWND hwndParent);
HRESULT DownLoadISPInfo(GATHERINFO *pGI);
HRESULT GetDataFromISPFile(LPWSTR pszISPCode, LPWSTR pszSection, LPWSTR pszDataName, LPWSTR pszOutput,
                           DWORD dwOutputLength);
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCWSTR pszKey);
extern HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCWSTR pszKey);
extern HRESULT DeleteSignUpReg(LPCWSTR pszKey);
VOID WINAPI MyProgressCallBack(
    HINTERNET hInternet,
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    );

HRESULT ReleaseBold(HWND hwnd);
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight);
//HRESULT ShowDialingDialog(LPWSTR, LPGATHERINFO, LPWSTR);
DWORD RasErrorToIDS(DWORD dwErr);
HRESULT CreateEntryFromDUNFile(LPWSTR pszDunFile);
//HRESULT RestoreHappyWelcomeScreen();
HRESULT KillHappyWelcomeScreen();
HRESULT GetCurrentWebSettings();
LPWSTR LoadInfoFromWindowUser();
HRESULT GetTapiCountryID2(LPDWORD pdwCountryID);
HRESULT RestoreAutodialer();
//HRESULT FilterStringDigits(LPWSTR);
BOOL IsDigitString(LPWSTR szBuff);
BOOL WaitForAppExit(HINSTANCE hInstance);
VOID PrepareForRunOnceApp(VOID);
void MinimizeRNAWindow(LPWSTR pszConnectoidName, HINSTANCE hInst);
// 3/28/97 ChrisK Olympus 296
void StopRNAReestablishZapper(HANDLE hthread);
HANDLE LaunchRNAReestablishZapper(HINSTANCE hInst);
BOOL FGetSystemShutdownPrivledge();
BOOL LclSetEntryScriptPatch(LPWSTR lpszScript, LPCWSTR lpszEntry);
BOOL IsScriptingInstalled();
void InstallScripter(void);
void DeleteStartUpCommand ();
extern BOOL IsNT (VOID);
extern BOOL IsNT4SP3Lower (VOID);
HRESULT GetCommonAppDataDirectory(LPWSTR szDirectory, DWORD cchDirectory);
HRESULT GetDefaultPhoneBook(LPWSTR szPhoneBook, DWORD cchPhoneBook);
BOOL INetNToW(struct in_addr inaddr, LPWSTR szAddr);

typedef enum tagAUTODIAL_TYPE
{
    AutodialTypeNever = 1,
    AutodialTypeNoNet,
    AutodialTypeAlways
} AUTODIAL_TYPE, *PAUTODIAL_TYPE;

LONG
SetAutodial(
    IN HKEY hUserRoot,
    IN AUTODIAL_TYPE eType,
    IN LPCWSTR szConnectoidName,
    IN BOOL bSetICWCompleted
    );

BOOL
SetMultiUserAutodial(
    IN AUTODIAL_TYPE eType,
    IN LPCWSTR szConnectoidName,
    IN BOOL bSetICWCompleted
    );

BOOL SetDefaultConnectoid(AUTODIAL_TYPE eType, LPCWSTR szConnectoidName);


//
// ChrisK Olympus 6368 6/24/97
//

#if defined(PRERELEASE)
BOOL FCampusNetOverride();
#endif //PRERELEASE

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetClientInfo(
  LPCWSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo);


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetSetClientInfo(
  LPCWSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo);



//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus

//  //10/24/96 jmazner Normandy 6968
//  //No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
HRESULT GetDeskTopInternetCommand();
HRESULT RestoreDeskTopInternetCommand();

//
// 7/24/97 ChrisK Olympus 1923
//
BOOL WaitForConnectionTermination(HRASCONN);

// 11/21/96 jmazner Normandy #11812
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS);
HRESULT ClearProxySettings();
HRESULT RestoreProxySettings();
BOOL FShouldRetry2(HRESULT hrErr);


LPBYTE MyMemCpy(LPBYTE dest, const LPBYTE src, size_t count);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\server.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  SERVER.CPP - component server for MSObWeb
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// The FactoryDataArray contains the components which 
// can be served.

#include "cunknown.h"
#include "cfactory.h"
#include "msobcomm.h"

//MIDL
#include "obcomm.h"



//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, pointer to create function, and the name
// of the component to place in the registry.
//

CFactoryData g_FactoryDataArray[] =
{
   {&CLSID_ObCommunicationManager,  
        CObCommunicationManager::CreateInstance, 
        L"ObCommunicationManager Component",   // Friendly Name
        L"ObCommunicationManager.1",           // ProgID
        L"ObCommunicationManager",             // Version Independent ProgID
        NULL,                                 // Function to register component categories
        NULL,   0},
};
int g_cFactoryDataEntries = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\resource.h ===
#define IDS_INTERNETMAIL_SERVICENAME        500
#define IDS_MESSAGESTORE_SERVICENAME        501
#define IDS_ADDRESSBOOK_SERVICENAME         502
#define IDS_INTERNETMAIL_DESCRIPTION        503
#define IDS_MESSAGESTORE_DESCRIPTION        504
#define IDS_ADDRESSBOOK_DESCRIPTION         505

#define IDS_MESSAGESTORE_FILENAME           506
#define IDS_MESSAGESTORE_FILENAME1          507
#define IDS_ADDRESSBOOK_FILENAME            508       
#define IDS_ADDRESSBOOK_FILENAME1           509

#define IDS_DEFAULT_PROFILE_NAME            513
#define IDS_SCRIPT_FILE_FILTER              514

#define IDS_HTML_DEFAULT_FONTFACE           515
#define IDS_HTML_DEFAULT_FONTSIZE           516
#define IDS_APPNAME                         517

#define IDS_ERR_INVALID_INTRO               518
#define IDS_ERR_INVALID_MSG                 519

#define IDS_PAYMENT_CC_LUHNCHK              520
#define IDS_PAYMENT_CCEXPDATE               521 

#define IDS_USERINFO_FE_NAME                522
#define IDS_USERINFO_FIRSTNAME              523
#define IDS_USERINFO_LASTNAME               524
#define IDS_USERINFO_COMPANYNAME            525
#define IDS_USERINFO_ADDRESS1               526
#define IDS_USERINFO_ADDRESS2               527
#define IDS_USERINFO_CITY                   528
#define IDS_USERINFO_STATE                  529
#define IDS_USERINFO_ZIP                    530
#define IDS_USERINFO_PHONE                  531
#define IDS_PAYMENT_CCNUMBER                532
#define IDS_PAYMENT_CCNAME                  533
#define IDS_PAYMENT_CCADDRESS               534
#define IDS_PAYMENT_CCZIP                   535
#define IDS_PAYMENT_PBNAME                  536
#define IDS_PAYMENT_PBNUMBER                537
#define IDS_USERINFO_FURIGANA               538
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\rnaapi.cpp ===
/*-----------------------------------------------------------------------------
	rnaapi.cpp

	Wrapper to softlink to RNAPH and RASAPI32.DLL

	Copyright (C) 1999 Microsoft Corporation
	All rights reserved.

	Authors:
		vyung		

	History:
        2/7/99      Vyung created 

-----------------------------------------------------------------------------*/
#include <util.h>
#include "obcomglb.h"
#include "rnaapi.h"
#include "enumodem.h"
#include "mapicall.h"
#include "wininet.h"
#include "wancfg.h"
#include "assert.h"

extern DWORD SetIEClientInfo(LPINETCLIENTINFO lpClientInfo);

static const WCHAR cszRASAPI32_DLL[] = L"RASAPI32.DLL";
static const WCHAR cszRNAPH_DLL[] = L"RNAPH.DLL";
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesW";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryName";
static const CHAR cszRasValidateEntryNameA[] = "RasValidateEntryNameW";
static const CHAR cszRasSetCredentials[] = "RasSetCredentialsW";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryW";
static const CHAR cszRasHangUp[] = "RasHangUpW";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusW";
static const CHAR cszRasDial[] = "RasDialW";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsW";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoW";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsW";
static const WCHAR cszWininet[] = L"WININET.DLL";
static const CHAR cszInternetSetOption[] = "InternetSetOptionW";
static const CHAR cszInternetQueryOption[] = "InternetQueryOptionW";

#define INTERNET_OPTION_PER_CONNECTION_OPTION   75

//
// Options used in INTERNET_PER_CONN_OPTON struct
//
#define INTERNET_PER_CONN_FLAGS                         1
#define INTERNET_PER_CONN_PROXY_SERVER                  2
#define INTERNET_PER_CONN_PROXY_BYPASS                  3
#define INTERNET_PER_CONN_AUTOCONFIG_URL                4
#define INTERNET_PER_CONN_AUTODISCOVERY_FLAGS           5

//
// PER_CONN_FLAGS
//
#define PROXY_TYPE_DIRECT                               0x00000001   // direct to net
#define PROXY_TYPE_PROXY                                0x00000002   // via named proxy
#define PROXY_TYPE_AUTO_PROXY_URL                       0x00000004   // autoproxy URL
#define PROXY_TYPE_AUTO_DETECT                          0x00000008   // use autoproxy detection

//
// PER_CONN_AUTODISCOVERY_FLAGS
//
#define AUTO_PROXY_FLAG_USER_SET                        0x00000001   // user changed this setting
#define AUTO_PROXY_FLAG_ALWAYS_DETECT                   0x00000002   // force detection even when its not needed
#define AUTO_PROXY_FLAG_DETECTION_RUN                   0x00000004   // detection has been run
#define AUTO_PROXY_FLAG_MIGRATED                        0x00000008   // migration has just been done 
#define AUTO_PROXY_FLAG_DONT_CACHE_PROXY_RESULT         0x00000010   // don't cache result of host=proxy name
#define AUTO_PROXY_FLAG_CACHE_INIT_RUN                  0x00000020   // don't initalize and run unless URL expired
#define AUTO_PROXY_FLAG_DETECTION_SUSPECT               0x00000040   // if we're on a LAN & Modem, with only one IP, bad?!?

typedef DWORD (WINAPI* RASSETCREDENTIALS)(
  LPCTSTR lpszPhonebook,
  LPCTSTR lpszEntry,
  LPRASCREDENTIALS lpCredentials, 
  BOOL fClearCredentials
);

typedef HRESULT (WINAPI * INTERNETSETOPTION) (IN HINTERNET hInternet OPTIONAL, IN DWORD dwOption,IN LPVOID lpBuffer,IN DWORD dwBufferLength);


typedef INTERNET_PER_CONN_OPTION_LISTW INTERNET_PER_CONN_OPTION_LIST;
typedef LPINTERNET_PER_CONN_OPTION_LISTW LPINTERNET_PER_CONN_OPTION_LIST;

// on NT we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// This is a bug in WinNT4.0 RAS, that didn't get fixed.
//
#define RASENTRY_SIZE_PATCH (7 * sizeof(DWORD))
HRESULT UpdateMailSettings(
  HWND              hwndParent,
  LPINETCLIENTINFO  lpINetClientInfo,
  LPWSTR             lpszEntryName);

DWORD EntryTypeFromDeviceType(
    LPCWSTR szDeviceType
    );

//+----------------------------------------------------------------------------LPRASDEVINFO
//
//	Function:	RNAAPI::RNAAPI
//
//	Synopsis:	Initialize class members and load DLLs
//
//	Arguments:	None
//
//	Returns:	None
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::RNAAPI()
{
	m_hInst = LoadLibrary(cszRASAPI32_DLL);
    m_bUseAutoProxyforConnectoid = 0;

    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
	    m_hInst2 = LoadLibrary(cszRNAPH_DLL);
    }
    else
    {
        m_hInst2 =  NULL;
    }

	m_fnRasEnumDeviecs = NULL;
	m_fnRasValidateEntryName = NULL;
	m_fnRasSetEntryProperties = NULL;
	m_fnRasGetEntryProperties = NULL;
	m_fnRasDeleteEntry = NULL;
	m_fnRasHangUp = NULL;
	m_fnRasGetConnectStatus = NULL;
	m_fnRasEnumConnections = NULL;
	m_fnRasDial = NULL;
	m_fnRasGetEntryDialParams = NULL;
	m_fnRasGetCountryInfo = NULL;
	m_fnRasSetEntryDialParams = NULL;
    m_pEnumModem = NULL;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::~RNAAPI
//
//	Synopsis:	release DLLs
//
//	Arguments:	None
//
//	Returns:	None
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::~RNAAPI()
{
	//
	// Clean up
	//
	if (m_hInst) FreeLibrary(m_hInst);
	if (m_hInst2) FreeLibrary(m_hInst2);
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasEnumDevices
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
							 LPDWORD lpcDevices)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasEnumDevices, (FARPROC*)&m_fnRasEnumDeviecs);

	if (m_fnRasEnumDeviecs)
		dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::LoadApi
//
//	Synopsis:	If the given function pointer is NULL, then try to load the API
//				from the first DLL, if that fails, try to load from the second
//				DLL
//
//	Arguments:	pszFName - the name of the exported function
//				pfnProc - point to where the proc address will be returned
//
//	Returns:	TRUE - success
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
BOOL RNAAPI::LoadApi(LPCSTR pszFName, FARPROC* pfnProc)
{
    USES_CONVERSION;

	if (*pfnProc == NULL)
	{
		// Look for the entry point in the first DLL
		if (m_hInst)
			*pfnProc = GetProcAddress(m_hInst, pszFName);
		
		// if that fails, look for the entry point in the second DLL
		if (m_hInst2 && !(*pfnProc))
			*pfnProc = GetProcAddress(m_hInst2, pszFName);
	}

	return (pfnProc != NULL);
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetConnectStatus
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		7/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetConnectStatus(HRASCONN hrasconn, LPRASCONNSTATUS lprasconnstatus)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetConnectStatus, (FARPROC*)&m_fnRasGetConnectStatus);

	if (m_fnRasGetConnectStatus)
		dwRet = (*m_fnRasGetConnectStatus) (hrasconn, lprasconnstatus);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasValidateEntryName
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasValidateEntryName(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasValidateEntryName, (FARPROC*)&m_fnRasValidateEntryName);

	LoadApi(cszRasValidateEntryNameA, (FARPROC*)&m_fnRasValidateEntryName);

	if (m_fnRasValidateEntryName)
		dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetEntryProperties
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryProperties(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry,
									LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
									LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;
	RASENTRY FAR *lpRE = NULL;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetEntryProperties, (FARPROC*)&m_fnRasSetEntryProperties);

	/*//////Assert(
		(NULL != lpbDeviceInfo) && (NULL != dwDeviceInfoSize)
		||
		(NULL == lpbDeviceInfo) && (NULL == dwDeviceInfoSize)
		);*/

#define RASGETCOUNTRYINFO_BUFFER_SIZE 256
	if (0 == ((LPRASENTRY)lpbEntryInfo)->dwCountryCode)
	{
		BYTE rasCI[RASGETCOUNTRYINFO_BUFFER_SIZE];
		LPRASCTRYINFO prasCI;
		DWORD dwSize;
		DWORD dw;
		prasCI = (LPRASCTRYINFO)rasCI;
		ZeroMemory(prasCI, sizeof(rasCI));
		prasCI->dwSize = sizeof(RASCTRYINFO);
		dwSize = sizeof(rasCI);

		////////Assert(((LPRASENTRY)lpbEntryInfo)->dwCountryID);
		prasCI->dwCountryID = ((LPRASENTRY)lpbEntryInfo)->dwCountryID;

		dw = RNAAPI::RasGetCountryInfo(prasCI, &dwSize);
		if (ERROR_SUCCESS == dw)
		{
			////////Assert(prasCI->dwCountryCode);
			((LPRASENTRY)lpbEntryInfo)->dwCountryCode = prasCI->dwCountryCode;
		} 
		else
		{
			////////AssertMsg(0, L"Unexpected error from RasGetCountryInfo.\r\n");
		}
	}

	if (m_fnRasSetEntryProperties)
		dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, dwEntryInfoSize,
									lpbDeviceInfo, dwDeviceInfoSize);
	lpRE = (RASENTRY FAR*)lpbEntryInfo;
	LclSetEntryScriptPatch(lpRE->szScript, lpszEntry);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetEntryProperties
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//				jmazner	9/17/96 Modified to allow calls with buffers = NULL and
//				                InfoSizes = 0. (Based on earlier modification
//				                to the same procedure in icwdial) See
//				                RasGetEntryProperties docs to learn why this is
//				                needed.
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetEntryProperties(LPCWSTR lpszPhonebook, LPCWSTR lpszEntry,
									LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
									LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;
	LPBYTE lpbEntryInfoPatch = NULL;
	LPDWORD  lpdwEntryInfoPatchSize = 0;

    // BUGBUG: 990203 (dane) Changed WINVER != 0x400 to WINVER < 0x400 so code
    // would compile for Whistler.  This has the potential for causing many
    // problems.  Per ChrisK this code was hand tuned for WINVER == 0x400 and
    // is very fragile.  If something is failing in regard to modems, RAS,
    // ISPs, etc. LOOK HERE FIRST.
    //

#if defined(_REMOVE_)   // What is the significance of this?  Can it be changed to (WINVER < 0x400)?
#if (WINVER != 0x400)
#error This was built with WINVER not equal to 0x400.  The size of RASENTRY may not be valid.
#endif
#endif  //  _REMOVE_
#if (WINVER < 0x400)
#error This was built with WINVER less than 0x400.  The size of RASENTRY may not be valid.
#endif




	if( (NULL == lpbEntryInfo) && (NULL == lpbDeviceInfo) )
	{
		////////Assert( NULL != lpdwEntryInfoSize );
		//////Assert( NULL != lpdwDeviceInfoSize );

		//////Assert( 0 == *lpdwEntryInfoSize );
		//////Assert( 0 == *lpdwDeviceInfoSize );

		// we're here to ask RAS what size these buffers need to be, don't use the patch stuff
		// (see RasGetEntryProperties docs)
		lpbEntryInfoPatch = lpbEntryInfo;
		lpdwEntryInfoPatchSize = lpdwEntryInfoSize;
	}
	else
	{

		//////Assert((*lpdwEntryInfoSize) >= sizeof(RASENTRY));
		//////Assert(lpbEntryInfo && lpdwEntryInfoSize);

		//
		// We are going to fake out RasGetEntryProperties by creating a slightly larger
		// temporary buffer and copying the data in and out.
		//
		lpdwEntryInfoPatchSize = (LPDWORD) GlobalAlloc(GPTR, sizeof(DWORD));
		if (NULL == lpdwEntryInfoPatchSize)
			return ERROR_NOT_ENOUGH_MEMORY;

		*lpdwEntryInfoPatchSize = (*lpdwEntryInfoSize) + RASENTRY_SIZE_PATCH;
		lpbEntryInfoPatch = (LPBYTE)GlobalAlloc(GPTR, *lpdwEntryInfoPatchSize);
		if (NULL == lpbEntryInfoPatch)
			return ERROR_NOT_ENOUGH_MEMORY;

		// RAS expects the dwSize field to contain the size of the LPRASENTRY struct
		// (used to check which version of the struct we're using) rather than the amount
		// of memory actually allocated to the pointer.
		//((LPRASENTRY)lpbEntryInfoPatch)->dwSize = dwEntryInfoPatch;
		((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);
	}

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetEntryProperties, (FARPROC*)&m_fnRasGetEntryProperties);

	if (m_fnRasGetEntryProperties)
		dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfoPatch, lpdwEntryInfoPatchSize,
									lpbDeviceInfo, lpdwDeviceInfoSize);

    //TraceMsg(TF_RNAAPI, L"ICWHELP: RasGetEntryProperties returned %lu\r\n", dwRet); 


	if( NULL != lpbEntryInfo )
	{
		//
		// Copy out the contents of the temporary buffer UP TO the size of the original buffer
		//
		//////Assert(lpbEntryInfoPatch);
		memcpy(lpbEntryInfo, lpbEntryInfoPatch,*lpdwEntryInfoSize);
		GlobalFree(lpbEntryInfoPatch);
		lpbEntryInfoPatch = NULL;

		if( lpdwEntryInfoPatchSize )
		{
			GlobalFree( lpdwEntryInfoPatchSize );
			lpdwEntryInfoPatchSize = NULL;
		}
		//
		// We are again faking Ras functionality here by over writing the size value;
		// This is neccesary due to a bug in the NT implementation of RasSetEntryProperties
		*lpdwEntryInfoSize = sizeof(RASENTRY);
	}

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasDeleteEntry
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasDeleteEntry(LPWSTR lpszPhonebook, LPWSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasDeleteEntry, (FARPROC*)&m_fnRasDeleteEntry);

	if (m_fnRasDeleteEntry)
		dwRet = (*m_fnRasDeleteEntry) (lpszPhonebook, lpszEntry);
	
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasHangUp
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasHangUp(HRASCONN hrasconn)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasHangUp, (FARPROC*)&m_fnRasHangUp);

	if (m_fnRasHangUp)
	{
		dwRet = (*m_fnRasHangUp) (hrasconn);
		Sleep(3000);
	}

	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions, LPWSTR lpszPhonebook,
					  LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,
					  LPVOID lpvNotifier, LPHRASCONN lphRasConn)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasDial, (FARPROC*)&m_fnRasDial);

	if (m_fnRasDial)
	{
		dwRet = (*m_fnRasDial) (lpRasDialExtensions, lpszPhonebook,lpRasDialParams,
								dwNotifierType, lpvNotifier,lphRasConn);
	}
	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasEnumConnections(LPRASCONN lprasconn, LPDWORD lpcb,LPDWORD lpcConnections)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasEnumConnections, (FARPROC*)&m_fnRasEnumConnections);

	if (m_fnRasEnumConnections)
	{
		dwRet = (*m_fnRasEnumConnections) (lprasconn, lpcb,lpcConnections);
	}
	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasGetEntryDialParams(LPCWSTR lpszPhonebook, LPRASDIALPARAMS lprasdialparams,
									LPBOOL lpfPassword)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetEntryDialParams, (FARPROC*)&m_fnRasGetEntryDialParams);

	if (m_fnRasGetEntryDialParams)
	{
		dwRet = (*m_fnRasGetEntryDialParams) (lpszPhonebook, lprasdialparams,lpfPassword);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetCountryInfo
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		8/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetCountryInfo(LPRASCTRYINFO lprci, LPDWORD lpdwSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetCountryInfo, (FARPROC*)&m_fnRasGetCountryInfo);

	if (m_fnRasGetCountryInfo)
	{
		dwRet = (*m_fnRasGetCountryInfo) (lprci, lpdwSize);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetEntryDialParams
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		8/20/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryDialParams(LPCWSTR lpszPhonebook, LPRASDIALPARAMS lprasdialparams,
							BOOL fRemovePassword)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetEntryDialParams, (FARPROC*)&m_fnRasSetEntryDialParams);

	if (m_fnRasSetEntryDialParams)
	{
		dwRet = (*m_fnRasSetEntryDialParams) (lpszPhonebook, lprasdialparams,
							fRemovePassword);
	}
	return dwRet;
}

/*******************************************************************

  NAME:    CreateConnectoid

  SYNOPSIS:  Creates a connectoid (phone book entry) with specified
        name and phone number

  ENTRY:    pszConnectionName - name for the new connectoid
        pszUserName - optional.  If non-NULL, this will be set for the
          user name in new connectoid
        pszPassword - optional.  If non-NULL, this will be set for the
          password in new connectoid

  EXIT:    returns ERROR_SUCCESS if successful, or an RNA error code

  HISTORY:
  96/02/26  markdu    Moved ClearConnectoidIPParams functionality 
            into CreateConnectoid

********************************************************************/
DWORD RNAAPI::CreateConnectoid(LPCWSTR pszPhonebook, LPCWSTR pszConnectionName,
  LPRASENTRY lpRasEntry, LPCWSTR pszUserName, LPCWSTR pszPassword, LPBYTE lpDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    //DEBUGMSG(L"rnacall.c::CreateConnectoid()");

    DWORD dwRet;

    ////Assert(pszConnectionName);

    // if we don't have a valid RasEntry, bail
    if ((NULL == lpRasEntry) || (sizeof(RASENTRY) != lpRasEntry->dwSize))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Enumerate the modems.
    if (m_pEnumModem)
    {
        // Re-enumerate the modems to be sure we have the most recent changes  
        dwRet = m_pEnumModem->ReInit();
    }
    else
    {
        // The object does not exist, so create it.
        m_pEnumModem = new CEnumModem;
        if (m_pEnumModem)
        {
            dwRet = m_pEnumModem->GetError();
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    // Make sure there is at least one device
    if (0 == m_pEnumModem->GetNumDevices())
    {
        return ERROR_DEVICE_DOES_NOT_EXIST;
    }

    // Validate the device if possible
    if (lstrlen(lpRasEntry->szDeviceName) && lstrlen(lpRasEntry->szDeviceType))
    {
        // Verify that there is a device with the given name and type
        if (!m_pEnumModem->VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
                lpRasEntry->szDeviceType))
        {
            // There was no device that matched both name and type,
            // so try to get the first device with matching name.
            LPWSTR szDeviceType = 
                m_pEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName);
            if (szDeviceType)
            {
                lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
            }
            else
            {
                // There was no device that matched the given name,
                // so try to get the first device with matching type.
                // If this fails, fall through to recovery case below.
                LPWSTR szDeviceName = 
                    m_pEnumModem->GetDeviceNameFromType(lpRasEntry->szDeviceType);
                if (szDeviceName)
                {
                    lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
                }
                else
                {
                    // There was no device that matched the given name OR
                    // the given type.  Reset the values so they will be
                    // replaced with the first device.
                    lpRasEntry->szDeviceName[0] = L'\0';
                    lpRasEntry->szDeviceType[0] = L'\0';
                }
            }
        }
    }
    else if (lstrlen(lpRasEntry->szDeviceName))
    {
        // Only the name was given.  Try to find a matching type.
        // If this fails, fall through to recovery case below.
        LPWSTR szDeviceType = 
            m_pEnumModem->GetDeviceTypeFromName(lpRasEntry->szDeviceName);
        if (szDeviceType)
        {
            lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
        }
    }
    else if (lstrlen(lpRasEntry->szDeviceType))
    {
        // Only the type was given.  Try to find a matching name.
        // If this fails, fall through to recovery case below.
        LPWSTR szDeviceName = 
            m_pEnumModem->GetDeviceNameFromType(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
            lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
    }

    // If either name or type is missing, just get first device.
    // Since we already verified that there was at least one device,
    // we can assume that this will succeed.
    if(!lstrlen(lpRasEntry->szDeviceName) ||
        !lstrlen(lpRasEntry->szDeviceType))
    {
        LPWSTR szDeviceName = m_pEnumModem->GetDeviceNameFromType(RASDT_Modem);
        if (NULL != szDeviceName)
        {
            lstrcpyn(lpRasEntry->szDeviceType, RASDT_Modem, RAS_MaxDeviceType);
            lstrcpyn(lpRasEntry->szDeviceName, szDeviceName, RAS_MaxDeviceName);
        }
        else
        {
            return ERROR_INETCFG_UNKNOWN;
        }
    }

    lpRasEntry->dwType = EntryTypeFromDeviceType(lpRasEntry->szDeviceType);

    // Verify the connectoid name
    dwRet = RasValidateEntryName(pszPhonebook, pszConnectionName);
    if ((ERROR_SUCCESS != dwRet) &&
        (ERROR_ALREADY_EXISTS != dwRet))
    {
        //DEBUGMSG(L"RasValidateEntryName returned %lu", dwRet);
        return dwRet;
    }

    //  96/04/07  markdu  NASH BUG 15645
    // If there is no area code string, and RASEO_UseCountryAndAreaCodes is not
    // set, then the area code will be ignored so put in a default otherwise the
    // call to RasSetEntryProperties will fail due to an RNA bug.
    // if RASEO_UseCountryAndAreaCodes is set, then area code is required, so not
    // having one is an error.  Let RNA report the error.
    if (!lstrlen(lpRasEntry->szAreaCode) &&
        !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
    {
        lstrcpy (lpRasEntry->szAreaCode, szDefaultAreaCode);
    }

    lpRasEntry->dwfOptions |= RASEO_ModemLights;

    // 96/05/14 markdu  NASH BUG 22730 Work around RNA bug.  Flags for terminal
    // settings are swapped by RasSetEntryproperties, so we swap them before
    // the call.  
    /*if (IsWin95())
      SwapDWBits(&lpRasEntry->dwfOptions, RASEO_TerminalBeforeDial,
      RASEO_TerminalAfterDial);*/

    // call RNA to create the connectoid
    ////Assert(lpRasSetEntryProperties);
    dwRet = RasSetEntryProperties(pszPhonebook, pszConnectionName,
        (LPBYTE)lpRasEntry, sizeof(RASENTRY), NULL, 0);

    // 96/05/14 markdu  NASH BUG 22730 Work around RNA bug.  Put the bits back
    // to the way they were originally,
    /*if (IsWin95())
      SwapDWBits(&lpRasEntry->dwfOptions, RASEO_TerminalBeforeDial,
      RASEO_TerminalAfterDial);*/

    // populate the connectoid with user's account name and password.
    if (dwRet == ERROR_SUCCESS)
    {
        if (pszUserName || pszPassword)
        {
            dwRet = SetConnectoidUsername(pszPhonebook, pszConnectionName,
                pszUserName, pszPassword);
        }
    }

    // RAS ATM (PPPOA) Integration: We have to set auxillary device properties!
    if ( !lstrcmpi(lpRasEntry->szDeviceType, RASDT_Atm) ) {
        if ( (lpDeviceInfo != 0) && (lpdwDeviceInfoSize != 0) && (*lpdwDeviceInfoSize > 0) )
        {


            LPATMPBCONFIG  lpAtmConfig = (LPATMPBCONFIG) lpDeviceInfo;
            LPBYTE  lpBuffer  = 0;
            DWORD   dwBufSize = 0;
            DWORD   dwRasEntrySize = sizeof(RASENTRY);
            if (!m_fnRasSetEntryProperties) 
                LoadApi(cszRasSetEntryProperties, (FARPROC*)&m_fnRasSetEntryProperties);

            if (!m_fnRasGetEntryProperties) 
                LoadApi(cszRasGetEntryProperties, (FARPROC*)&m_fnRasGetEntryProperties);

            if (m_fnRasGetEntryProperties) 
            {
                if (!(*m_fnRasGetEntryProperties)(pszPhonebook, pszConnectionName, (LPBYTE)lpRasEntry, &dwRasEntrySize, 0, &dwBufSize))
                {
                    if ( dwBufSize )
                    {
                        if ( !(lpBuffer = (LPBYTE) malloc ( dwBufSize ) ))
                        {
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            memset ( lpBuffer, 0, dwBufSize );
                        }
                        if (!( (*m_fnRasGetEntryProperties) (pszPhonebook, pszConnectionName, (LPBYTE)lpRasEntry, &dwRasEntrySize, lpBuffer, &dwBufSize) ))
                        {
                            // buffer is now available. we now update its content.
                            LPWANPBCONFIG   lpw = (LPWANPBCONFIG) lpBuffer;
                            assert ( lpw->cbDeviceSize == sizeof (ATMPBCONFIG) );
                            assert ( lpw->cbVendorSize == sizeof (ATMPBCONFIG) );
                            assert ( lpw->cbTotalSize <= dwBufSize );
                            memcpy ( lpBuffer+(lpw->dwDeviceOffset), lpDeviceInfo, sizeof(ATMPBCONFIG) );
                            memcpy ( lpBuffer+(lpw->dwVendorOffset), lpDeviceInfo, sizeof(ATMPBCONFIG) );
                            if ( m_fnRasSetEntryProperties )
                            {
                                (*m_fnRasSetEntryProperties)(pszPhonebook, pszConnectionName, (LPBYTE)lpRasEntry, sizeof(RASENTRY), lpBuffer, dwBufSize);
                            }
                            else
                            {
                                // free (lpBuffer);
                                // report error?
                            }
                        }
                        free (lpBuffer);
                        lpBuffer = NULL;
                    }
                }
            }
        }
    }

#ifndef _NT_    // BUGBUG: Should this be in Whistler?

    if (dwRet == ERROR_SUCCESS)
    {

        // We don't use auto discovery for referral and signup connectoid
        if (!m_bUseAutoProxyforConnectoid)
        {
            // VYUNG 12/16/1998
            // REMOVE AUTO DISCOVERY FROM THE DIALUP CONNECTOID



            INTERNET_PER_CONN_OPTION_LIST list;
            DWORD   dwBufSize = sizeof(list);

            // fill out list struct
            list.dwSize = sizeof(list);
            WCHAR szConnectoid [RAS_MaxEntryName];
            lstrcpyn(szConnectoid, pszConnectionName, lstrlen(pszConnectionName)+1);
            list.pszConnection = szConnectoid;         
            list.dwOptionCount = 1;                         // one option
            list.pOptions = new INTERNET_PER_CONN_OPTION[1];   

            if(list.pOptions)
            {
                // set flags
                list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
                list.pOptions[0].Value.dwValue = PROXY_TYPE_DIRECT;           // no proxy, autoconfig url, or autodiscovery

                // tell wininet
                HINSTANCE hInst = NULL;
                FARPROC fpInternetSetOption = NULL;

                dwRet = ERROR_SUCCESS;

                hInst = LoadLibrary(cszWininet);
                if (hInst)
                {
                    fpInternetSetOption = GetProcAddress(hInst, cszInternetSetOption);
                    if (fpInternetSetOption)
                    {
                        if( !((INTERNETSETOPTION)fpInternetSetOption) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize) )
                        {
                            dwRet = GetLastError();
                            //DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
                        }
                    }
                    else
                        dwRet = GetLastError();
                    FreeLibrary(hInst);
                }

                delete [] list.pOptions;
            }

        }

    }

#endif //_NT_




    return dwRet;
}

/*******************************************************************

  NAME:     SetConnectoidUsername

  SYNOPSIS: Set the username and password strings for the phonebook
            entry name specified.

            The RASCM_DefaultCreds bit makes this entry available to all users.

  ENTRY:    pszConnectoidName - phonebook entry name
            pszUserName - string with user name
            pszPassword - string with password

  EXIT:     Return value of GetEntryDialParams or SetEntryDialParams

********************************************************************/
DWORD RNAAPI::SetConnectoidUsername(
    LPCWSTR             pszPhonebook, 
    LPCWSTR             pszConnectoidName,
    LPCWSTR             pszUserName, 
    LPCWSTR             pszPassword
    )
{
    DWORD               dwRet = ERROR_SUCCESS;

    TRACE(L"rnacall.c::SetConnectoidUsername()");

    MYASSERT(pszConnectoidName);

    FARPROC fp = GetProcAddress(m_hInst, cszRasSetCredentials);

    if (fp)
    {
        // fill in credential structure
        RASCREDENTIALS rascred;
        ZeroMemory(&rascred, sizeof(rascred));
        rascred.dwSize = sizeof(rascred);
        rascred.dwMask = RASCM_UserName 
                       | RASCM_Password 
                       | RASCM_Domain
                       | RASCM_DefaultCreds;
        lstrcpyn(rascred.szUserName, pszUserName,UNLEN);
        lstrcpyn(rascred.szPassword, pszPassword,PWLEN);
        lstrcpyn(rascred.szDomain, L"",DNLEN);

        dwRet = ((RASSETCREDENTIALS)fp)(NULL, 
                                        (LPWSTR)pszConnectoidName,
                                        &rascred,
                                        FALSE
                                        );
        TRACE1(L"RasSetCredentials returned, %lu", dwRet);
    }
    else
    {
        TRACE(L"RasSetCredentials api not found.");
    }

    return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetConfigClientEx
//
//  PURPOSE:    This function requires a valid phone book entry name
//              (unless it is being used just to set the client info).
//              If lpRasEntry points to a valid RASENTRY struct, the phone
//              book entry will be created (or updated if it already exists)
//              with the data in the struct.
//              If username and password are given, these
//              will be set as the dial params for the phone book entry.
//              If a client info struct is given, that data will be set.
//              Any files (ie TCP and RNA) that are needed will be
//              installed by calling InetConfigSystem().
//              This function will also perform verification on the device
//              specified in the RASENTRY struct.  If no device is specified,
//              the user will be prompted to install one if there are none
//              installed, or they will be prompted to choose one if there
//              is more than one installed.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              lpszPhonebook - name of phone book to store the entry in
//              lpszEntryName - name of phone book entry to be
//              created or modified
//              lpRasEntry - specifies a RASENTRY struct that contains
//              the phone book entry data for the entry lpszEntryName
//              lpszUsername - username to associate with the phone book entry
//              lpszPassword - password to associate with the phone book entry
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//              lpINetClientInfo - client information
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.  Note that if
//                                       no modem is installed and this flag
//                                       is not set, the function will fail
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_SETASAUTODIAL - Set the phone book entry for autodial
//                INETCFG_OVERWRITEENTRY - Overwrite the phone book entry if it
//                                         exists.  Note: if this flag is not
//                                         set, and the entry exists, a unique
//                                         name will be created for the entry.
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

HRESULT RNAAPI::InetConfigClientEx(
  HWND              hwndParent,
  LPCWSTR            lpszPhonebook,
  LPCWSTR            lpszEntryName,
  LPRASENTRY        lpRasEntry,
  LPCWSTR            lpszUsername,
  LPCWSTR            lpszPassword,
  LPCWSTR            lpszProfileName,
  LPINETCLIENTINFO  lpINetClientInfo,
  DWORD             dwfOptions,
  LPBOOL            lpfNeedsRestart,
  LPWSTR             szConnectoidName,
  DWORD             dwSizeOfCreatedEntryName,
  LPBYTE			lpDeviceInfo,
  LPDWORD			lpdwDeviceInfoSize)
{
    BOOL  fNeedsRestart = FALSE;  // Default to no reboot needed
    HWND hwndWaitDlg = NULL;
    DWORD dwRet = ERROR_SUCCESS;

    //DEBUGMSG(L"export.c::InetConfigClient()");

    // Install files if needed.
    // Note:  the parent hwnd is validated in InetConfigSystem
    // We must also mask out the InstallModem flag since we want to
    // do that here, not in InetConfigSystem
    /*
    DWORD dwRet = InetConfigSystem(hwndParent,
    dwfOptions & ~INETCFG_INSTALLMODEM, &fNeedsRestart);
    if (ERROR_SUCCESS != dwRet)
    {
    return dwRet;
    }*/

    if (dwSizeOfCreatedEntryName < MAX_ISP_NAME + 1)
    {
      return E_FAIL;
    }

    // Make sure we have a connectoid name
    if (lpszEntryName && lstrlen(lpszEntryName))
    {
        // Copy the name into a private buffer in case we have 
        // to muck around with it
        lstrcpyn(szConnectoidName, lpszEntryName, dwSizeOfCreatedEntryName);

        // Make sure the name is valid.
        dwRet = RasValidateEntryName(lpszPhonebook, szConnectoidName);
        if ((ERROR_SUCCESS == dwRet) ||
          (ERROR_ALREADY_EXISTS == dwRet))
        {
            // Find out if we can overwrite an existing connectoid
            if (!(dwfOptions & INETCFG_OVERWRITEENTRY) && (ERROR_ALREADY_EXISTS == dwRet))
            {
                WCHAR szConnectoidNameBase[MAX_ISP_NAME + 1];

                // Create a base string that is truncated to leave room for a space
                // and a 3-digit number to be appended.  So, the buffer size will be
                // MAX_ISP_NAME + 1 - (LEN_APPEND_INT + 1)
                lstrcpyn(szConnectoidNameBase, szConnectoidName,
                  MAX_ISP_NAME - LEN_APPEND_INT);

                // If the entry exists, we have to create a unique name
                int nSuffix = 2;
                while ((ERROR_ALREADY_EXISTS == dwRet) && (nSuffix < MAX_APPEND_INT))
                {
                    // Add the integer to the end of the base string and then bump it
                    wsprintf(szConnectoidName, szFmtAppendIntToString,
                    szConnectoidNameBase, nSuffix++);

                    // Validate this new name
                    dwRet = RasValidateEntryName(lpszPhonebook, szConnectoidName);
                }

                // If we could not create a unique name, bail
                // Note that dwRet should still be ERROR_ALREADY_EXISTS in this case
                if (nSuffix >= MAX_APPEND_INT)
                {
                  return dwRet;
                }
            }

            if (lpRasEntry && lpRasEntry->dwSize == sizeof(RASENTRY))
            {

                // For NT 5 and greater, File sharing is disabled per connectoid by setting this RAS option.
                //if (TRUE == IsNT5())
                //{   
                //    lpRasEntry->dwfOptions |= RASEO_SecureLocalFiles;
                //}    

                // Create a connectoid with given properties
                dwRet = MakeConnectoid(hwndParent, dwfOptions, lpszPhonebook,
                  szConnectoidName, lpRasEntry, lpszUsername, lpszPassword, &fNeedsRestart, lpDeviceInfo, lpdwDeviceInfoSize);
            }
            else if ((lpszUsername && lstrlen(lpszUsername)) ||
                  (lpszPassword && lstrlen(lpszPassword)))
            {
                // If we created a connectoid, we already updated the dial params
                // with the user name and password.  However, if we didn't create a
                // connectoid we still may need to update dial params of an existing one
                // Update the dial params for the given connectoid. 
                dwRet = SetConnectoidUsername(lpszPhonebook, szConnectoidName,
                  lpszUsername, lpszPassword);
            }

            // If the connectoid was created/updated successfully, see
            // if it is supposed to be set as the autodial connectoid.
            if ((ERROR_SUCCESS == dwRet) && (dwfOptions & INETCFG_SETASAUTODIAL))
            {
            // dwRet = InetSetAutodial((DWORD)TRUE, szConnectoidName);
            }
        }
    }

    // Now set the client info if provided and no errors have occurred yet.
    if (ERROR_SUCCESS == dwRet)
    {
        if (NULL != lpINetClientInfo)
        {
            dwRet = InetSetClientInfo(lpszProfileName, lpINetClientInfo);
            if (ERROR_SUCCESS != dwRet)
            {
                if (NULL != hwndWaitDlg)
                  DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
                return dwRet;
            }
            // update IE news settings
            dwRet = SetIEClientInfo(lpINetClientInfo);
            if (ERROR_SUCCESS != dwRet)
            {
                if (NULL != hwndWaitDlg)
                  DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
                return dwRet;
            }
        }

        // Now update the mail client if we were asked to do so.
        // Note: if we got here without errors, and INETCFG_INSTALLMAIL is set,
        // then mail has been installed by now.
        
        if (dwfOptions & INETCFG_INSTALLMAIL)
        {
          INETCLIENTINFO    INetClientInfo;
          ZeroMemory(&INetClientInfo, sizeof(INETCLIENTINFO));
          INetClientInfo.dwSize = sizeof(INETCLIENTINFO);

          // Use a temp pointer that we can modify.
          LPINETCLIENTINFO  lpTmpINetClientInfo = lpINetClientInfo;

          // If no client info struct was given, try to get the profile by name
          if ((NULL == lpTmpINetClientInfo) && (NULL != lpszProfileName) &&
            lstrlen(lpszProfileName))
          {
            lpTmpINetClientInfo = &INetClientInfo;
            dwRet = InetGetClientInfo(lpszProfileName, lpTmpINetClientInfo);
            if (ERROR_SUCCESS != dwRet)
            {
              if (NULL != hwndWaitDlg)
                DestroyWindow(hwndWaitDlg);
              hwndWaitDlg = NULL;
              return dwRet;
            }
          }

          // If we still don't have client info, we should enumerate the profiles
          // If there is one profile, get it.  If multiple, show UI to allow user
          // to choose.  If none, there is nothing to do at this point.
          // For now, we don't support enumeration, so just try to get the default.
          if (NULL == lpTmpINetClientInfo)
          {
            lpTmpINetClientInfo = &INetClientInfo;
            dwRet = InetGetClientInfo(NULL, lpTmpINetClientInfo);
            if (ERROR_SUCCESS != dwRet)
            {
              if (NULL != hwndWaitDlg)
                DestroyWindow(hwndWaitDlg);
              hwndWaitDlg = NULL;
              return dwRet;
            }
          }

          // If we have client info, update mail settings.
          if (NULL != lpTmpINetClientInfo)
          {
              dwRet = UpdateMailSettings(hwndParent, lpTmpINetClientInfo, szConnectoidName);
          }
        }
    }

    // tell caller whether we need to reboot or not
    if ((ERROR_SUCCESS == dwRet) && (lpfNeedsRestart))
    {
    *lpfNeedsRestart = fNeedsRestart;
    }

    if (NULL != hwndWaitDlg)
    DestroyWindow(hwndWaitDlg);
    hwndWaitDlg = NULL;

    return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   MakeConnectoid
//
//  PURPOSE:    This function will create a connectoid with the
//              supplied name if lpRasEntry points to a valid RASENTRY
//              struct.  If username and password are given, these
//              will be set as the dial params for the connectoid.
//
//  PARAMETERS: 
//  hwndParent - window handle of calling application.  This
//               handle will be used as the parent for any dialogs that
//               are required for error messages or the "choose modem"
//               dialog.
//  dwfOptions - a combination of INETCFG_ flags that controls
//               the installation and configuration.
//  lpszPhonebook - name of phone book to store the entry in
//  lpszEntryName  - name of connectoid to create/modify
//  lpRasEntry - connectoid data
//  lpszUsername - username to associate with connectoid
//  lpszPassword - password to associate with connectoid
//  lpfNeedsRestart - set to true if we need a restart.  Note that
//                    since this is an internal helper function, we
//                    assume that the pointer is valid, and we don't
//                    initialize it (we only touch it if we are setting
//                    it to TRUE).
//  
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/12  markdu  Created.
//
//*******************************************************************

DWORD RNAAPI::MakeConnectoid(
  HWND        hwndParent,
  DWORD       dwfOptions,
  LPCWSTR      lpszPhonebook,
  LPCWSTR      lpszEntryName,
  LPRASENTRY  lpRasEntry,
  LPCWSTR      lpszUsername,
  LPCWSTR      lpszPassword,
  LPBOOL      lpfNeedsRestart,
  LPBYTE		lpDeviceInfo,
  LPDWORD		lpdwDeviceInfoSize)
{
    DWORD dwRet;

    //ASSERT(lpfNeedsRestart);

    if (dwfOptions & RASEO_UseCountryAndAreaCodes)
    {
        if ((0 == lpRasEntry->dwCountryCode) || (0 == lpRasEntry->dwCountryID))
            return ERROR_INVALID_PARAMETER;
    }

    if (0 == lstrlen(lpRasEntry->szLocalPhoneNumber))
    {
        return ERROR_INVALID_PARAMETER;  
    }


    // Load RNA if not already loaded since ENUM_MODEM needs it.
    /*dwRet = EnsureRNALoaded();
    if (ERROR_SUCCESS != dwRet)
    {
    return dwRet;
    }*/

    //
    // Enumerate the modems 
    //
    CEnumModem  EnumModem;
    dwRet = EnumModem.GetError();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    // If there are no modems, install one if requested.
    if (0 == EnumModem.GetNumDevices())
    {
        // We have not been asked to install a modem, so there
        // is nothing further we can do.
        return ERROR_INVALID_PARAMETER;
        /*

        if (FALSE == IsNT())
        {
            //
            // 5/22/97 jmazner    Olympus #4698
            // On Win95, calling RasEnumDevices launches RNAAP.EXE
            // If RNAAP.EXE is running, any modems you install won't be usable
            // So, nuke RNAAP.EXE before installing the modem.
            //
            WCHAR szWindowTitle[255] = L"\0nogood";

            //
            // Unload the RAS dll's before killing RNAAP, just to be safe
            //
            DeInitRNA();

            LoadSz(IDS_RNAAP_TITLE, szWindowTitle,255);
            HWND hwnd = FindWindow(szWindowTitle, NULL);
            if (NULL != hwnd)
            {
                if (!PostMessage(hwnd, WM_CLOSE, 0, 0))
                {
                    DEBUGMSG(L"Trying to kill RNAAP window returned getError %d", GetLastError());
                }
            }
        }*/
    }

    // Validate the device if possible
    if (lstrlen(lpRasEntry->szDeviceName) && lstrlen(lpRasEntry->szDeviceType))
    {
        // Verify that there is a device with the given name and type
        if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
          lpRasEntry->szDeviceType))
        {
            // There was no device that matched both name and type,
            // so reset the strings and bring up the choose modem UI.
            lpRasEntry->szDeviceName[0] = L'\0';
            lpRasEntry->szDeviceType[0] = L'\0';
        }
    }
    else if (lstrlen(lpRasEntry->szDeviceName))
    {
        // Only the name was given.  Try to find a matching type.
        // If this fails, fall through to recovery case below.
        LPWSTR szDeviceType = 
        EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
        if (szDeviceType)
        {
            lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
        }
    }
    else if (lstrlen(lpRasEntry->szDeviceType))
    {
    // Only the type was given.  Try to find a matching name.
        // If this fails, fall through to recovery case below.
        LPWSTR szDeviceName = 
          EnumModem.GetDeviceNameFromType(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
            lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
    }

    // If either name or type is missing, bring up choose modem UI if there
    // are multiple devices, else just get first device.
    // Since we already verified that there was at least one device,
    // we can assume that this will succeed.

    // If either name or type is missing at this point, fall back to the modem
    // that is enumerated first.  If no modem is enumerated, return an error.
    //
    if(!lstrlen(lpRasEntry->szDeviceName) ||
       !lstrlen(lpRasEntry->szDeviceType))
    {
        LPWSTR szDeviceName = EnumModem.GetDeviceNameFromType(RASDT_Modem);
        if (NULL != szDeviceName)
        {
            lstrcpyn(lpRasEntry->szDeviceType, RASDT_Modem, RAS_MaxDeviceType);
            lstrcpyn(lpRasEntry->szDeviceName, szDeviceName, RAS_MaxDeviceName);
        }
        else
        {
            return ERROR_INETCFG_UNKNOWN;
        }

    }

    // Create a connectoid with given properties
    dwRet = CreateConnectoid(lpszPhonebook, lpszEntryName, lpRasEntry,
                             lpszUsername, lpszPassword, lpDeviceInfo, lpdwDeviceInfoSize);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function	LclSetEntryScriptPatch
//
//	Synopsis	Softlink to RasSetEntryPropertiesScriptPatch
//
//	Arguments	see RasSetEntryPropertiesScriptPatch
//
//	Returns		see RasSetEntryPropertiesScriptPatch
//
//	Histroy		10/3/96	ChrisK Created
//
//-----------------------------------------------------------------------------
//typedef BOOL (WINAPI* LCLSETENTRYSCRIPTPATCH)(LPWSTR, LPWSTR);
/*
BOOL RNAAPI::LclSetEntryScriptPatch(LPCWSTR lpszScript, LPCWSTR lpszEntry)
{
	HINSTANCE hinst = NULL;
	LCLSETENTRYSCRIPTPATCH fp = NULL;
	BOOL bRC = FALSE;

	hinst = LoadLibrary(L"ICWDIAL.DLL");
	if (hinst)
	{
		fp = (LCLSETENTRYSCRIPTPATCH)GetProcAddress(hinst, L"RasSetEntryPropertiesScriptPatch");
		if (fp)
			bRC = (fp)(lpszScript, lpszEntry);
		FreeLibrary(hinst);
		hinst = NULL;
		fp = NULL;
	}
	return bRC;
}
*/
//+----------------------------------------------------------------------------
//
//    Function    RemoveOldScriptFilenames
//
//    Synopsis    Given the data returned from a call to GetPrivateProfileSection
//                remove any information about existing script file so that
//                we can replace it with the new script information.
//
//    Arguments    lpszData - pointer to input data
//
//    Returns        TRUE - success
//                lpdwSize - size of resulting data
//
//    History        10/2/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL RemoveOldScriptFilenames(LPWSTR lpszData, LPDWORD lpdwSize)
{
    BOOL bRC = FALSE;
    LPWSTR lpszTemp = lpszData;
    LPWSTR lpszCopyTo = lpszData;
    INT iLen = 0;

    //
    // Walk through list of name value pairs
    //
    if (!lpszData || L'\0' == lpszData[0])
        goto RemoveOldScriptFilenamesExit;
    while (*lpszTemp) {
        if (0 != lstrcmpi(lpszTemp, cszDeviceSwitch))
        {
            //
            //    Keep pairs that don't match criteria
            //
            iLen = BYTES_REQUIRED_BY_SZ(lpszTemp);
            if (lpszCopyTo != lpszTemp)
            {
                memmove(lpszCopyTo, lpszTemp, iLen+1);
            }
            lpszCopyTo += iLen + 1;
            lpszTemp += iLen + 1;
        }
        else
        {
            //
            // Skip the pair that matches and the one after that
            //
            lpszTemp += lstrlen(lpszTemp) + 1;
            if (*lpszTemp)
                lpszTemp += lstrlen(lpszTemp) + 1;
        }
    }

    //
    // Add second trailing NULL
    //
    *lpszCopyTo = L'\0';
    //
    // Return new size
    // Note the size does not include the final \0
    //
    *lpdwSize = (DWORD)(lpszCopyTo - lpszData);

    bRC = TRUE;
RemoveOldScriptFilenamesExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    GleanRealScriptFileName
//
//    Synopsis    Given a string figure out the real filename
//                Due to another NT4.0 Ras bug, script filenames returned by
//                RasGetEntryProperties may contain a leading garbage character
//
//    Arguments    lppszOut - pointer that will point to real filename
//                lpszIn - points to current filename
//
//    Returns        TRUE - success
//                *lppszOut - points to real file name, remember to free the memory
//                    in this variable when you are done.  And don't talk with
//                    your mouth full - mom.
//
//    History        10/2/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL GleanRealScriptFileName(LPWSTR *lppszOut, LPWSTR lpszIn)
{
    BOOL bRC = FALSE;
    LPWSTR lpsz = NULL;
    DWORD dwRet = 0;

    //
    // Validate parameters
    //
    //Assert(lppszOut && lpszIn);
    if (!(lppszOut && lpszIn))
        goto GleanFilenameExit;

    //
    // first determine if the filename is OK as is
    //
    dwRet = GetFileAttributes(lpszIn);
    if (L'\0' != lpszIn[0] && 0xFFFFFFFF == dwRet) // Empty filename is OK
    {
        //
        // Check for the same filename without the first character
        //
        lpsz = lpszIn+1;
        dwRet = GetFileAttributes(lpsz);
        if (0xFFFFFFFF == dwRet)
            goto GleanFilenameExit;
    } 
    else
    {
        lpsz = lpszIn;
    }

    //
    // Return filename
    //
    *lppszOut = (LPWSTR)GlobalAlloc(GPTR, BYTES_REQUIRED_BY_SZ(lpsz));
    lstrcpy(*lppszOut, lpsz);

    bRC = TRUE;
GleanFilenameExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    IsScriptPatchNeeded
//
//    Synopsis    Check version to see if patch is needed
//
//    Arguments    lpszData - contents of section in rasphone.pbk
//                lpszScript - name of script file
//
//    Returns        TRUE - patch is needed
//
//    Histroy        10/1/96
//
//-----------------------------------------------------------------------------
static BOOL IsScriptPatchNeeded(LPWSTR lpszData, LPWSTR lpszScript)
{
    BOOL bRC = FALSE;
    LPWSTR lpsz = lpszData;
    WCHAR szType[MAX_PATH + MAX_CHARS_IN_BUFFER(cszType) + 1];

    lstrcpy(szType, cszType);
    lstrcat(szType, lpszScript);

    //Assert(MAX_PATH + MAX_CHARS_IN_BUFFER(cszType) +1 > lstrlen(szType));

    lpsz = lpszData;
    while(*lpsz)
    {
        if (0 == lstrcmp(lpsz, cszDeviceSwitch))
        {
            lpsz += lstrlen(lpsz)+1;
            // if we find a DEVICE=switch statement and the script is empty
            // then we'll have to patch the entry
            if (0 == lpszScript[0])
                bRC = TRUE;
            // if we find a DEVICE=switch statement and the script is different
            // then we'll have to patch the entry
            else if (0 != lstrcmp(lpsz, szType))
                bRC = TRUE;
            // if we find a DEVICE=switch statement and the script is the same
            // then we DON'T have to patch it
            else
                bRC = FALSE;
            break; // get out of while statement
        }
        lpsz += lstrlen(lpsz)+1;
    }
    
    if (L'\0' == *lpsz)
    {
        // if we didn't find DEVICE=switch statement and the script is empty
        // then we DON'T have to patch it
        if (L'\0' == lpszScript[0])
            bRC = FALSE;
        // if we didn't find DEVICE=switch statement and the script is not
        // empty the we'll have to patch it.
        else
            bRC = TRUE;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    GetRasPBKFilename
//
//    Synopsis    Find the Ras phone book and return the fully qualified path
//                in the buffer
//
//    Arguments    lpBuffer - pointer to buffer
//                dwSize    - size of buffer (must be at least MAX_PATH)
//
//    Returns        TRUE - success
//
//    History        10/1/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL GetRasPBKFilename(LPWSTR lpBuffer, DWORD dwSize)
{
    BOOL bRC = FALSE;
    UINT urc = 0;
    LPWSTR lpsz = NULL;

    //
    // Validate parameters
    //
    //Assert(lpBuffer && (dwSize >= MAX_PATH));
    //
    // Get path to system directory
    //
    urc = GetSystemDirectory(lpBuffer, dwSize);
    if (0 == urc || urc > dwSize)
        goto GetRasPBKExit;
    //
    // Check for trailing '\' and add \ras\rasphone.pbk to path
    //
    lpsz = &lpBuffer[lstrlen(lpBuffer)-1];
    if (L'\\' != *lpsz)
        lpsz++;
    lstrcpy(lpsz, cszRasPBKFilename);

    bRC = TRUE;
GetRasPBKExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    RasSetEntryPropertiesScriptPatch
//
//    Synopsis    Work around bug in NT4.0 that does not save script file names
//                to RAS phone book entries
//
//    Arguments    lpszScript - name of script file
//                lpszEntry - name of phone book entry
//
//    Returns        TRUE - success
//
//    Histroy        10/1/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL WINAPI RasSetEntryPropertiesScriptPatch(LPWSTR lpszScript, LPCWSTR lpszEntry)
{
    BOOL bRC = FALSE;
    WCHAR szRasPBK[MAX_PATH+1];
    WCHAR szData[SCRIPT_PATCH_BUFFER_SIZE];
    DWORD dwrc = 0;
    LPWSTR lpszTo;
    LPWSTR lpszFixedFilename = NULL;

    //
    // Validate parameters
    //
    //Assert(lpszScript && lpszEntry);
    //TraceMsg(TF_GENERAL, L"ICWDIAL: ScriptPatch script %s, entry %s.\r\n", lpszScript, lpszEntry);    

    //
    // Verify and fix filename
    //
    if (!GleanRealScriptFileName(&lpszFixedFilename, lpszScript))
        goto ScriptPatchExit;

    //
    // Get the path to the RAS phone book
    //
    if (!GetRasPBKFilename(szRasPBK, MAX_PATH+1))
        goto ScriptPatchExit;
    //
    //    Get data
    //
    ZeroMemory(szData, SCRIPT_PATCH_BUFFER_SIZE);
    dwrc = GetPrivateProfileSection(lpszEntry, szData,SCRIPT_PATCH_BUFFER_SIZE,szRasPBK);
    if (SCRIPT_PATCH_BUFFER_SIZE == (dwrc + 2))
        goto ScriptPatchExit;
    //
    // Verify version
    //
    if (!IsScriptPatchNeeded(szData, lpszFixedFilename))
    {
        bRC = TRUE;
        goto ScriptPatchExit;
    }

    //
    // Clean up data
    //
    RemoveOldScriptFilenames(szData, &dwrc);
    //
    // Make sure there is enough space left to add new data
    //
    if (SCRIPT_PATCH_BUFFER_SIZE <=
        (dwrc + sizeof(cszDeviceSwitch) + SIZEOF_NULL + MAX_CHARS_IN_BUFFER(cszType) + MAX_PATH))
        goto ScriptPatchExit;
    //
    // Add data
    //
    if (L'\0' != lpszFixedFilename[0])
    {
        lpszTo = &szData[dwrc];
        lstrcpy(lpszTo, cszDeviceSwitch);
        lpszTo += MAX_CHARS_IN_BUFFER(cszDeviceSwitch);
        lstrcpy(lpszTo, cszType);
        lpszTo += MAX_CHARS_IN_BUFFER(cszType) - 1;
        lstrcpy(lpszTo, lpszFixedFilename);
        lpszTo += lstrlen(lpszFixedFilename) + SIZEOF_NULL;
        *lpszTo = L'\0';    // extra terminating NULL

        //Assert(&lpszTo[SIZEOF_NULL]<&szData[SCRIPT_PATCH_BUFFER_SIZE]);
    }
    //
    //    Write data
    //
    bRC = WritePrivateProfileSection(lpszEntry, szData,szRasPBK);

ScriptPatchExit:
    if (lpszFixedFilename)
        GlobalFree(lpszFixedFilename);
    lpszFixedFilename = NULL;
    //if (!bRC)
      //  TraceMsg(TF_GENERAL, L"ICWDIAL: ScriptPatch failed.\r\n");
    return bRC;
}

//+----------------------------------------------------------------------------
//
//	Function	LclSetEntryScriptPatch
//
//	Synopsis	Softlink to RasSetEntryPropertiesScriptPatch
//
//	Arguments	see RasSetEntryPropertiesScriptPatch
//
//	Returns		see RasSetEntryPropertiesScriptPatch
//
//	Histroy		10/3/96	ChrisK Created
//
//-----------------------------------------------------------------------------
typedef BOOL (WINAPI* LCLSETENTRYSCRIPTPATCH)(LPCWSTR, LPCWSTR);

BOOL LclSetEntryScriptPatch(LPWSTR lpszScript, LPCWSTR lpszEntry)
{
	return RasSetEntryPropertiesScriptPatch(lpszScript, lpszEntry);
}


//*******************************************************************
//
//  FUNCTION:   UpdateMailSettings
//
//  PURPOSE:    This function will update the settings for mail in
//              the profile of the user's choice.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "choose profile"
//              dialog.
//              lpINetClientInfo - client information
//              lpszEntryName - name of phone book entry to be
//              set for connection.
//  
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/26  markdu  Created.
//
//*******************************************************************

HRESULT UpdateMailSettings(
  HWND              hwndParent,
  LPINETCLIENTINFO  lpINetClientInfo,
  LPWSTR             lpszEntryName)
{
    DWORD                 dwRet = ERROR_SUCCESS;
    MAILCONFIGINFO MailConfigInfo;
    ZeroMemory(&MailConfigInfo, sizeof(MAILCONFIGINFO));    // zero out structure

    //    96/04/06    markdu    NASH BUG 16404 
    // Funcionts in mapicall.c expect us to allocate global structure

    // call MAPI to set up profile and store this information in it
    if (InitMAPI(NULL))
    {
        // structure to pass to dialog to fill out
        CHOOSEPROFILEDLGINFO ChooseProfileDlgInfo;
        ZeroMemory(&ChooseProfileDlgInfo, sizeof(CHOOSEPROFILEDLGINFO));
        ChooseProfileDlgInfo.fSetProfileAsDefault = TRUE;

        // 96/04/25    markdu    NASH BUG 19572 Only show choose profile dialog
        // if there are any existing profiles, 

        // 99/2/18 Remove multi profile dialog for OOBE

        // set up a structure with mail config information
        MailConfigInfo.pszEmailAddress = lpINetClientInfo->szEMailAddress;
        MailConfigInfo.pszEmailServer = lpINetClientInfo->szPOPServer;
        MailConfigInfo.pszEmailDisplayName = lpINetClientInfo->szEMailName;
        MailConfigInfo.pszEmailAccountName = lpINetClientInfo->szPOPLogonName;
        MailConfigInfo.pszEmailAccountPwd = lpINetClientInfo->szPOPLogonPassword;
        MailConfigInfo.pszConnectoidName = lpszEntryName;
        MailConfigInfo.fRememberPassword = TRUE;
        MailConfigInfo.pszProfileName = ChooseProfileDlgInfo.szProfileName;
        MailConfigInfo.fSetProfileAsDefault = ChooseProfileDlgInfo.fSetProfileAsDefault;

        // BUGBUG SMTP

        // set up the profile through MAPI
        dwRet = SetMailProfileInformation(&MailConfigInfo);

        // Hide error messages for OOBE
        /*
        if (ERROR_SUCCESS != dwRet)
        {
            DisplayErrorMessage(hwndParent, IDS_ERRConfigureMail,
                (DWORD) dwRet, ERRCLS_MAPI,MB_ICONEXCLAMATION);
        }*/

        DeInitMAPI();
    }
    else
    {
        // an error occurred.
        dwRet = GetLastError();
        if (ERROR_SUCCESS == dwRet)
        {
            // Error occurred, but the error code was not set.
            dwRet = ERROR_INETCFG_UNKNOWN;
        }
    }

    return dwRet;
}

DWORD EntryTypeFromDeviceType(
    LPCWSTR szDeviceType
    )
{
    DWORD dwType;

    MYASSERT(
        !lstrcmpi(RASDT_PPPoE, szDeviceType) ||
        !lstrcmpi(RASDT_Atm, szDeviceType) ||
        !lstrcmpi(RASDT_Isdn, szDeviceType) ||
        !lstrcmpi(RASDT_Modem, szDeviceType)
        );
    
    if (lstrcmpi(RASDT_PPPoE, szDeviceType) == 0)
    {
        dwType = RASET_Broadband;
    }
    else
    {
        dwType = RASET_Phone;
    }

    return dwType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\usbhwchk.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  usbHwChk.CPP - Implementation of USB Keyboard and Mouse checking
//
//  HISTORY:
//
//  8/20/99 vyung Created.
//

#include "msobcomm.h"
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <util.h>

#define ENUM_SUCCESS            0
#define ENUM_GENFAILURE         4
#define ENUM_CHILDFAILURE       2
#define ENUM_SIBLINGFAILURE     1

#define DEVICETYPE_MOUSE        L"Mouse"
#define DEVICETYPE_KEYBOARD     L"keyboard"


// BUGBUG: should be defined by sdk\inc\devguid.h
#ifndef GUID_DEVCLASS_USB
    DEFINE_GUID( GUID_DEVCLASS_USB,             0x36fc9e60L, 0xc465, 0x11cf, 0x80, 0x56, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 );
#endif

// Function prototypes for cfgmgr32.dll
typedef CMAPI
CONFIGRET
(WINAPI*
PFNCMGETCHILD)(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
typedef CMAPI
CONFIGRET
(WINAPI*
PFCMGETSIBLING)(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags
             );
typedef CMAPI

#if defined(_REMOVE_)   // looks like a typo
CMAPI
#endif  //  _REMOVE_

CONFIGRET
(WINAPI*
PFCMGETDEVNODEREGISTRYPROPERTYA)(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );

BOOL g_bKeyboard    = FALSE;
BOOL g_bMouse       = FALSE;

/***************************************************************************
   Function: ProcessDevNode

   Retrieve each DevNode in the system and checks for keyboard and mouse

***************************************************************************/
void ProcessDevNode(DEVNODE dnDevNode, FARPROC pfGetDevNodeProp)
{
    //
    // We have gotten a child or a sibling. Get the class of device.
    //
    WCHAR buf[512];
    DWORD len = 0;
    len = MAX_CHARS_IN_BUFFER(buf);// BUGBUG: look up params to GetDevNodeProp

    DWORD cr = ((PFCMGETDEVNODEREGISTRYPROPERTYA)pfGetDevNodeProp)(dnDevNode,
                                          CM_DRP_CLASS,    // Or CM_DRP_CLASSGUID
                                          NULL,
                                          buf,
                                          &len,
                                          0);
    //
    // Does it match the keyboard class or the mouse class?
    // If so, set that variable and continue.
    //
    if(0 == lstrcmpi((LPCWSTR)buf, DEVICETYPE_KEYBOARD))
    {
        g_bKeyboard = TRUE;
    }
    if(0 == lstrcmp((LPCWSTR)buf, DEVICETYPE_MOUSE))
    {
        g_bMouse = TRUE;
    }

}

/***************************************************************************
   Function: EnumerateDevices

   Used to walk through every DevNode in the system and retrieve it's resources
   in the registry

***************************************************************************/
long EnumerateDevices(DEVNODE dnDevNodeTraverse,
                      int j,
                      DEVNODE dnParentNode,
                      FARPROC pfGetChild,
                      FARPROC pfGetSibling,
                      FARPROC pfGetDevNodeProp)
{
    DEVNODE     dnDevNodeMe;
    DEVNODE     dnDevNodeSibling;
    DEVNODE     dnDevNodeChild;
    CONFIGRET   cr;
    static long lError;

    dnDevNodeMe = dnDevNodeTraverse;

    while( TRUE )
    {
        cr = ((PFNCMGETCHILD)pfGetChild)(&dnDevNodeChild, dnDevNodeMe, 0);

        switch(cr)
        {
            case CR_SUCCESS:
                //Write new node, as a branch or root
                ProcessDevNode(dnDevNodeMe, pfGetDevNodeProp);

                //Pass up failure
                lError = EnumerateDevices(dnDevNodeChild, 0, dnDevNodeMe, pfGetChild, pfGetSibling, pfGetDevNodeProp);
                if ( lError != ENUM_SUCCESS )
                    return lError;
                break;
                //No children, I am a bottom branch!
            case CR_NO_SUCH_DEVNODE:
                // This is ok too. If just means the the call couldn't find
                // either a sibling or a child.
                // Write new node, as a leaf
                ProcessDevNode(dnDevNodeMe, pfGetDevNodeProp);
                break;
                //We puked on something, return code of 3 will end entire traversal
            default:
                return ENUM_CHILDFAILURE;
        }

        //Get next sibling, repeat
        cr = ((PFCMGETSIBLING)pfGetSibling)(&dnDevNodeSibling, dnDevNodeMe, 0);

        switch(cr)
        {
            case CR_SUCCESS:
                dnDevNodeMe = dnDevNodeSibling; // I'm now the sibling
                break;
            case CR_NO_SUCH_DEVNODE:
                return ENUM_SUCCESS; //Out of siblings...
            default:
                return ENUM_SIBLINGFAILURE ; //We puked on something, return code of 2 will end entire traversal
        }
    }
}

/***************************************************************************
   Function: IsMouseOrKeyboardPresent

   Used to walk through every USB DevNode in the system and check it's resources
   in the registry for keyboard and mouse

***************************************************************************/
DWORD
IsMouseOrKeyboardPresent(HWND  HWnd,
                         PBOOL pbKeyboardPresent,
                         PBOOL pbMousePresent)
{
    SP_DEVINFO_DATA     DevData;
    HDEVINFO            hDevInfo;
    DEVNODE             dnDevInst;
    DWORD               dwPropertyType;
    BYTE*               lpPropertyBuffer = NULL; //buf[MAX_PATH];
    DWORD               requiredSize = MAX_PATH;
    DWORD               dwRet = ERROR_SUCCESS;
    GUID                tempGuid;
    int                 i;
    memcpy(&tempGuid, &GUID_DEVCLASS_USB, sizeof(GUID));

    HINSTANCE hInst = NULL;
    g_bKeyboard = FALSE;
    g_bMouse    = FALSE;
    FARPROC pfGetChild = NULL, pfGetSibling = NULL, pfGetDevNodeProp = NULL;

    hInst = LoadLibrary(L"CFGMGR32.DLL");
    if (hInst)
    {
        // Load the CM_Get_* API
        pfGetChild = GetProcAddress(hInst, "CM_Get_Child");
        pfGetSibling = GetProcAddress(hInst, "CM_Get_Sibling");
        pfGetDevNodeProp = GetProcAddress(hInst, "CM_Get_DevNode_Registry_PropertyW");

        if (pfGetChild && pfGetSibling && pfGetDevNodeProp)
        {
            lpPropertyBuffer = new BYTE[requiredSize];
            if ( ! lpPropertyBuffer ) {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                goto IsMouseOrKeyboardPresentError;
            }

            hDevInfo = SetupDiGetClassDevs(&tempGuid,
                                           NULL,
                                           HWnd,
                                           DIGCF_PRESENT);
            //Set the size of DevData
            DevData.cbSize = sizeof(DevData);

            for (i = 0;
                 SetupDiEnumDeviceInfo(hDevInfo, i, &DevData);
                 i++)
            {
                if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                      &DevData,
                                                      SPDRP_HARDWAREID,
                                                      (PDWORD)&dwPropertyType,
                                                      lpPropertyBuffer,
                                                      requiredSize,
                                                      &requiredSize))
                {
                    dwRet = GetLastError();

                    if (dwRet == ERROR_INSUFFICIENT_BUFFER) {
                        //
                        // Allocate an appropriate size buffer and call
                        // SetupDiGetDeviceRegistryProperty again to get
                        // the hardware ids.
                        //
                        dwRet = ERROR_SUCCESS;
                        delete [] lpPropertyBuffer;
                        lpPropertyBuffer = new BYTE[requiredSize];
                        if ( ! lpPropertyBuffer ) {
                            dwRet = ERROR_NOT_ENOUGH_MEMORY;
                            goto IsMouseOrKeyboardPresentError;
                        }

                        if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                              &DevData,
                                                              SPDRP_HARDWAREID,
                                                              (PDWORD)&dwPropertyType,
                                                              lpPropertyBuffer,
                                                              requiredSize,
                                                              &requiredSize))
                        {
                            dwRet = GetLastError();
                            goto IsMouseOrKeyboardPresentError;

                        }

                    } else {
                        goto IsMouseOrKeyboardPresentError;
                    }
                }

                //
                // We've now got the hardware ids.
                // Using your best string compare code for MULTI_SZ strings,
                // Find out if one of the ids is "USB\ROOT_HUB"
                //
                // if (one of the ids is not "USB\ROOT_HUB") {
                //     continue;
                // }
                //
                if(0 != wmemcmp( (LPCWSTR)lpPropertyBuffer, L"USB", MAX_CHARS_IN_BUFFER(L"USB") ))
                {
                    continue;
                }

                dnDevInst = DevData.DevInst;

                //
                // One of the ids is USB\ROOT_HUB.
                // Time to search for a keyboard or a mouse!
                // Use the following two apis to search through the tree underneath
                // the root hub to find devnodes. I haven't included this search code,
                // but I'm sure you can be creative and use a depth or breadth algorithm
                // of some sort. When you're done, break out of the loop.
                //
                if (ENUM_SUCCESS != EnumerateDevices(dnDevInst, 2, 0, pfGetChild, pfGetSibling, pfGetDevNodeProp))
                {
                    dwRet = GetLastError();
                    TRACE1( L"EnumerateDevices failed.  Error = %d", dwRet);
                }

            }

        }
        else
        {
            dwRet = GetLastError();
        }

    }
    else
    {
        dwRet = GetLastError();
    }

    MYASSERT( dwRet == ERROR_SUCCESS );

IsMouseOrKeyboardPresentError:

    if (hInst) {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    if (lpPropertyBuffer) {
        delete [] lpPropertyBuffer;
        lpPropertyBuffer = NULL;
    }

    *pbKeyboardPresent = g_bKeyboard;
    *pbMousePresent    = g_bMouse;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\validate.cpp ===
#include "obcomglb.h"
#include "appdefs.h"

// BUGBUG - This function is not very effecient since it requires a alloc/free for each validation
// plus strtok will tokenize the fill string requring a full search of the string.
BOOL IsValid(LPCWSTR pszText, HWND hWndParent, WORD wNameID)
{
    //ASSERT(pszText);

    WCHAR* pszTemp = NULL;
    BOOL   bRetVal = FALSE;

    pszTemp = _wcsdup (pszText);    

    if (lstrlen(pszTemp))
    {
        WCHAR seps[]   = L" ";
        WCHAR* token   = NULL;
        token = wcstok( pszTemp, seps );
        if (token)
        {
            bRetVal = TRUE;
        }
    }
      
    free(pszTemp);
    
      
    return bRetVal;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\validate.h ===
#ifndef   _VALIDATE_H
#define  _VALIDATE_H

BOOL IsValid(LPCWSTR pszText, HWND hWndParent, WORD wNameID);
        
#endif //_VALIDATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\boyer.h ===
#ifndef _INC_BOYER
#define _INC_BOYER

/* store the pattern, pattern length and skip table for 256 alphabets */
/* maximum pattern length (MAXPAT) cannot be larger than 65535 */

#define MAXPAT  256

typedef struct {
	unsigned int plen;
	CHAR p[MAXPAT + 1];
	unsigned int skip[256];
} FINDSTRUCT;

typedef FINDSTRUCT FAR * LPFIND;
typedef LPFIND HFIND;

/* boyer.c prototypes */

#ifdef __cplusplus
extern "C" {
#endif
	
	
	HFIND SetFindPattern( LPSTR lpszPattern );
	void FreeFindPattern( HFIND hfind );
	LPSTR Find( HFIND hfind, LPSTR s, long slen );
	
#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\webgate.h ===
// webgate.h : Declaration of the CWebGate

#ifndef __WEBGATE_H_
#define __WEBGATE_H_

#include <urlmon.h>  
#include <wininet.h>
#include <shlwapi.h>
#include <windowsx.h>
#include "obcomglb.h"

/////////////////////////////////////////////////////////////////////////////
// CWebGate
class CWebGate : public IBindStatusCallback, IHttpNegotiate
{
public:
     CWebGate ();
    ~CWebGate ();

    // IUnknown methods
    STDMETHODIMP QueryInterface  (REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef  ();
    STDMETHODIMP_(ULONG) Release ();

    // IBindStatusCallback methods
    STDMETHODIMP OnStartBinding    (DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP GetPriority       (LONG* pnPriority);
    STDMETHODIMP OnLowResource     (DWORD dwReserved);
    STDMETHODIMP OnProgress        (ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText);
    STDMETHODIMP OnStopBinding     (HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP GetBindInfo       (DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP OnDataAvailable   (DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc, STGMEDIUM* pstgmed);
    STDMETHODIMP OnObjectAvailable (REFIID riid, IUnknown* punk);

    // IHttpNegotiate methods
	STDMETHODIMP BeginningTransaction (LPCWSTR szURL, LPCWSTR szHeaders, DWORD dwReserved, LPWSTR* pszAdditionalHeaders);
    STDMETHODIMP OnResponse           (DWORD dwResponseCode, LPCWSTR szResponseHeaders, LPCWSTR szRequestHeaders, LPWSTR* pszAdditionalRequestHeaders);

    //WebGate
    STDMETHOD (get_DownloadFname) (BSTR *pVal);
    STDMETHOD (FetchPage)         (DWORD dwDoWait, BOOL *pbRetVal);
    STDMETHOD (put_Path)          (BSTR newVal);

private:
    DWORD     m_cRef;
    IMoniker* m_pmk;
    IBindCtx* m_pbc;
    IStream*  m_pstm;
    BSTR      m_bstrCacheFileName;
    HANDLE    m_hEventComplete;
    HANDLE    m_hEventError;
    BSTR      m_bstrPath;

    void FlushCache();
};

/*
// ===========================================================================
//                     CWebGateBindStatusCallback Definition
//
// This class will be use to indicate download progress
//
// ===========================================================================

class CWebGateBindStatusCallback : public IBindStatusCallback
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface (REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef         ();
    STDMETHODIMP_(ULONG)    Release        ();

    // IBindStatusCallback methods
    STDMETHODIMP OnStartBinding    (DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP GetPriority       (LONG* pnPriority);
    STDMETHODIMP OnLowResource     (DWORD dwReserved);
    STDMETHODIMP OnProgress        (ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText);
    STDMETHODIMP OnStopBinding     (HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP GetBindInfo       (DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP OnDataAvailable   (DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc, STGMEDIUM* pstgmed);
    STDMETHODIMP OnObjectAvailable (REFIID riid, IUnknown* punk);

    // constructors/destructors
     CWebGateBindStatusCallback (CWebGate* lpWebGate);
    ~CWebGateBindStatusCallback ();

    // data members
    DWORD     m_cRef;
    IBinding* m_pbinding;
    IStream*  m_pstm;
    CWebGate* m_lpWebGate;
};
*/
#endif //__WEBGATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\boyer.cpp ===
/*-----------------------------------------------------------------------------
    Program Specification

    in:     search space s, pattern p
    out:    a pointer where p is exactly matched at s[i], NULL indicates fail
    why:    Boyer-Moore algorithm is best for general text search. On
            "average" it takes length(s)/length(p) steps to match p in s.

    ref:    I recommend the following references:

            "Algorithms". Robert Sedgewick. Addison Wesley Publishing Company.
            1988. 2nd addition. p286. QA76.6.S435 1983

            "Faster String Searches". Doctor Dobb's Journal. Volume 14
            Issue 7 July 1989. Costas Menico. p74.

    usage:  e.g. to find a pattern "tiger" in a text in RAM starting at
                 pointer "txtp" with a length of 1, 000,000 characters,
                 program like this:

            LPSTR matchp;

            SetFindPattern( "tiger" );
            matchp = Find( txtp, 1000000L );
            if (matchp != NULL)
                // found
            else
                // not found

            matchp = FindBackward( txtp + 1000000L - 1, 1000000L);
            if (matchp != NULL)
                // found
            else
                // not found


    Q:      Can I use Find() with a GlobalLock() pointer in Windows?
    A:      Yes.

    Q:      Must I delcare my pointer as HPSTR (huge pointer) ?
    A:      Not necessary.  Find() and FindBackward() will convert your
            LPSTR as HPSTR.  However, in your own code you must aware
            that you are holding a LPSTR and take care of the pointer
            arithmetic and conversion. (see demo.c for example)

    Q:      What is the limit of the memory space I can search?
    A:      To the limit of huge pointer implementation and your hardware.

-----------------------------------------------------------------------------*/

#include "pch.hpp"


/*-----------------------------------------------------------------------------
    func:   SetFindPattern
    desc:   initialize the pattern to be matched and generate skip table
    pass:   lpszPattern = pattern string
    rtrn:   HFIND - the find handle for further text search
-----------------------------------------------------------------------------*/
HFIND SetFindPattern( LPSTR lpszPattern )
{
    register unsigned int j;
    register CHAR c;
    HFIND hfind;
   

    hfind = (HFIND)MyAlloc(sizeof(FINDSTRUCT));
    
    hfind->plen = lstrlenA( lpszPattern );

    if (hfind->plen > MAXPAT)
        hfind->plen = MAXPAT;

    lstrcpyA( (LPSTR)(hfind->p), lpszPattern );
    

    for (j=0; j<256; j++)
    {
        hfind->skip[j] = hfind->plen;
    }

    for (j=0; j<hfind->plen; j++)
    {
        c = lpszPattern[j];
        hfind->skip[c] =  hfind->plen - (j +1);
    }

    return (hfind);
}

/*-----------------------------------------------------------------------------
    func:   FreeFindPattern
    desc:   free the memory occupied by SetFindPattern
    pass:   hfind - the find handle
    rtrn:   nothing
-----------------------------------------------------------------------------*/
void FreeFindPattern( HFIND hfind )
{
	
	MyFree((LPSTR)hfind);
}

/*-----------------------------------------------------------------------------
    func:   Find
    desc:   match a pattern defined in SetFindPattern against string s
    pass:   hfind = the find handle created by SetFindPattern
            s = start of search space, slen = length of s
    rtrn:   NULL = match fail
            else = a LPSTR to p[0] in s matches p
-----------------------------------------------------------------------------*/
LPSTR Find( HFIND hfind, LPSTR s, long slen )

{
    register int i;
    unsigned int n, j;
    register unsigned char c;
    LPSTR lpresult;
    

    
    i = hfind->plen;
	j = hfind->plen;
  

    do
    {
        c = *(s + (i - 1));

        if (c == hfind->p[j - 1])
        {
			i--;
			j--;
        }
		else
        {
            n = hfind->plen - j + 1;
            if (n > hfind->skip[c] )
            {
                i += n;
            }
			else
            {
                i += hfind->skip[c];
            }
            j = hfind->plen;
        }
    }
    while ((j >= 1) && (i <= slen));

    /* match fails */
    if (i >= slen)
    {
        lpresult = (LPSTR)NULL;
    }
    /* match successful */
    else
    {
        lpresult = s + i;
    }

    
    return (lpresult);
}




#ifdef TEST_MAIN
#pragma message("Building with TEST_MAIN")
#include <stdio.h>
CHAR test_buffer[]=L"___________12191919191919This is string for testing our find ___________12191919191919function 12abE Is it in here somehwere ?";
CHAR test_pattern[]=L"___________12191919191919";

void main(void)
{
	HFIND hFind;
	CHAR *tmp;

	hFind=SetFindPattern(test_pattern);
	tmp=Find(hFind, test_buffer, strlen(test_buffer));
	if (tmp!=NULL) wsprintf(L"Found pattern at offset %u, %s", tmp-test_buffer,tmp);
	FreeFindPattern(hFind);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\webgate.cpp ===
#include "webgate.h"
#include "msobcomm.h"
#include "commerr.h"

extern CObCommunicationManager* gpCommMgr;

HRESULT hrCallbackSet;

/////////////////////////////////////////////////////////////////////////////
// CWebGate

CWebGate::CWebGate()
{
    m_pmk               = NULL;
    m_pstm              = NULL;
    m_pbc               = NULL;
    m_cRef              = 0;
    m_bstrCacheFileName = NULL;
    m_hEventComplete    = NULL;
    m_hEventError       = NULL;
    m_bstrPath          = NULL;

    AddRef();
}

CWebGate::~CWebGate()
{
    if(m_pbc)
    {
        m_pbc->Release();
        m_pbc = NULL;
    
    }

    FlushCache();
}

// ---------------------------------------------------------------------------
// CWebGate::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        AddRef();
        *ppv = this;
        hr = S_OK;
    }
    else if (riid == IID_IBindStatusCallback)
    {
        AddRef();
        *ppv = (IBindStatusCallback*)this;
        hr = S_OK;
    }
    else if (riid == IID_IHttpNegotiate)
    {
        AddRef();
        *ppv = (IHttpNegotiate*)this;
        hr = S_OK;
    }
    
    return hr;
}

// ---------------------------------------------------------------------------
// CWebGate::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWebGate::AddRef()
{
    return m_cRef++;
} 

// ---------------------------------------------------------------------------
// CWebGate::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWebGate::Release()
{
    --m_cRef;
     
    if(m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
} 

// ---------------------------------------------------------------------------
// CWebGate::put_Path
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::put_Path(BSTR newVal)
{
    BSTR bstrTemp = SysAllocString(newVal);
    if (NULL == bstrTemp)
    {
        return E_OUTOFMEMORY;
    }

    if (NULL != m_bstrPath)
    {
        SysFreeString(m_bstrPath);
    }
    m_bstrPath = bstrTemp;
    bstrTemp = NULL;

    return S_OK;
}

void CWebGate::FlushCache()
{

    if(m_bstrCacheFileName)
    {
        DeleteFile(m_bstrCacheFileName);
        SysFreeString(m_bstrCacheFileName);
        m_bstrCacheFileName = NULL;
    }
}
// ---------------------------------------------------------------------------
// CWebGate::FetchPage
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::FetchPage(DWORD dwDoWait, BOOL* pbRetVal)
{
    HRESULT  hr   = E_FAIL;
    IStream* pstm = NULL;

    FlushCache();
    
    if(SUCCEEDED(CreateBindCtx(0, &m_pbc)) && m_pbc)
    {
        RegisterBindStatusCallback(m_pbc,
                                   this,
                                   0,
                                   0L);
    }

    if(SUCCEEDED(CreateURLMoniker(NULL, m_bstrPath, &m_pmk)) && m_pmk && m_pbc)
    {  
        hr = m_pmk->BindToStorage(m_pbc, 0, IID_IStream, (void**)&pstm);
        m_pmk->Release();
        m_pmk = NULL;
    }

    if (dwDoWait)
    {
        MSG     msg;
        DWORD   dwRetCode;
        HANDLE  hEventList[2];
      
        m_hEventComplete = CreateEvent(NULL, TRUE, FALSE, NULL);
        m_hEventError    = CreateEvent(NULL, TRUE, FALSE, NULL);

        hEventList[0] = m_hEventComplete;
        hEventList[1] = m_hEventError;

        while(TRUE)
        {
            // We will wait on window messages and also the named event.
            dwRetCode = MsgWaitForMultipleObjects(2, 
                                                  &hEventList[0], 
                                                  FALSE, 
                                                  300000,            // 5 minutes
                                                  QS_ALLINPUT);            
            if(dwRetCode == WAIT_TIMEOUT)
            {
                *pbRetVal = FALSE;
                break;
            }
            else if(dwRetCode == WAIT_OBJECT_0)
            {
                *pbRetVal = TRUE;
                break;
            }
            else if(dwRetCode == WAIT_OBJECT_0 + 1)
            {
                *pbRetVal = FALSE;
                break;
            }
            else
            {
                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT == msg.message)
                    {
                        *pbRetVal = FALSE;
                        break;
                    }
                    else
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }                
            }
            
        }
        CloseHandle(m_hEventComplete);
        CloseHandle(m_hEventError);
        m_hEventComplete = NULL;
        m_hEventError    = NULL;
    }
    else
        *pbRetVal = TRUE;

    if(m_pbc)
    {
        m_pbc->Release();
        m_pbc = NULL;
    
    }

    return hr;
}

// ---------------------------------------------------------------------------
// CWebGate::get_DownloadFname
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::get_DownloadFname(BSTR *pVal)
{
    if (pVal == NULL)
        return(E_POINTER);
    
    *pVal = SysAllocString(m_bstrCacheFileName);
    return(S_OK);
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//////  IBindStatusCallback
//////
//////
//////

// ---------------------------------------------------------------------------
// CWebGate::GetBindInfo
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    *pgrfBINDF = BINDF_PULLDATA         | 
                 BINDF_ASYNCHRONOUS     | 
                 BINDF_ASYNCSTORAGE     |
                 BINDF_GETNEWESTVERSION | 
                 BINDF_SILENTOPERATION  | 
                 BINDF_NOWRITECACHE;

    pbindInfo->cbSize       = sizeof(BINDINFO);
    pbindInfo->szExtraInfo  = NULL;
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb   = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));

    return S_OK;
}

HANDLE g_hFile = NULL;
int g_nOBEFileCount = 0;
#define HTML_TAG_BASE_REF L"<BASE HREF=\"%s\">"
// ---------------------------------------------------------------------------
// CWebGate::OnStartBinding
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{  

    WCHAR szTempFileFullName[MAX_PATH];
    WCHAR szTempFileName[MAX_PATH];

    if(g_hFile)
        CloseHandle(g_hFile);

    GetTempPath(MAX_PATH, szTempFileFullName);

    wsprintf( szTempFileName, L"OOBE%x.htm", g_nOBEFileCount++); 

    lstrcat(szTempFileFullName, szTempFileName);

    if((g_hFile = CreateFile(szTempFileFullName, 
                                 GENERIC_WRITE, 
                                 0, 
                                 NULL, 
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL, 
                                 NULL)) == INVALID_HANDLE_VALUE)
    {
        return E_FAIL;
    }

    m_bstrCacheFileName = SysAllocString(szTempFileFullName);

    return S_OK;
} 

// ---------------------------------------------------------------------------
// CWebGate::OnStopBinding
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    
    if(g_hFile)
    {
        CloseHandle(g_hFile);
        g_hFile = NULL;
    }

    if(S_OK == hrStatus)
    {
        if(m_hEventError)
            SetEvent(m_hEventComplete);
        else
            gpCommMgr->Fire_DownloadComplete(m_bstrCacheFileName);
    }
    else
    {
        if(m_hEventError)
            SetEvent(m_hEventError);
        //else
        //    PostMessage(gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONSERVERERROR, (WPARAM)0, (LPARAM)ERR_COMM_SERVER_BINDFAILED);
    }

    return S_OK;
}

// ---------------------------------------------------------------------------
// CWebGate::OnDataAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::OnDataAvailable
(   
    DWORD      grfBSCF, 
    DWORD      dwSize, 
    FORMATETC* pfmtetc, 
    STGMEDIUM* pstgmed
)
{
    HRESULT hr;
    DWORD   dwActuallyRead = 0;
    DWORD   dwWritten = 0;

     // Get the Stream passed
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
    {       
        if (!m_pstm && pstgmed->tymed == TYMED_ISTREAM)
        {
            m_pstm = pstgmed->pstm;
            if (m_pstm)
                m_pstm->AddRef();
        }
    }
     
    if (m_pstm && dwSize)
    {
        BYTE* pszBuff = (BYTE*)malloc(dwSize);

        do 
        {  
            dwActuallyRead = 0;

            // Read what we can 
            hr = m_pstm->Read(pszBuff, dwSize, &dwActuallyRead);

            if (g_hFile)                               
            {
                WriteFile(g_hFile, pszBuff, dwActuallyRead, &dwWritten, NULL);
            }

        } while (hr == E_PENDING || hr != S_FALSE);
        
        free(pszBuff);
    }

    if (BSCF_LASTDATANOTIFICATION & grfBSCF)
    {
        if (m_pstm)
        {
            m_pstm->Release();
            m_pstm = NULL;
        }
    }

    return S_OK;
}

// ---------------------------------------------------------------------------
// CWebGate::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    return S_OK;
}

// ---------------------------------------------------------------------------
// CWebGate::OnObjectAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// CWebGate::GetPriority
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::GetPriority(LONG* pnPriority)
{
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// CWebGate::OnLowResource
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//////  IHttpNegotiate
//////
//////
//////

// ---------------------------------------------------------------------------
// CWebGate::BeginningTransaction
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::BeginningTransaction
(
    LPCWSTR szURL,
    LPCWSTR szHeaders,
    DWORD   dwReserved,
    LPWSTR* pszAdditionalHeaders
)
{
    // Here's our opportunity to add headers
    if (!pszAdditionalHeaders)
    {
        return E_POINTER;
    }

    *pszAdditionalHeaders = NULL;

    return NOERROR;
}
  
// ---------------------------------------------------------------------------
// CWebGate::BeginningTransaction
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGate::OnResponse
(
    DWORD   dwResponseCode,
    LPCWSTR szResponseHeaders,
    LPCWSTR szRequestHeaders,
    LPWSTR* pszAdditionalRequestHeaders)
{
    if (!pszAdditionalRequestHeaders)
    {
        return E_POINTER;
    }

    *pszAdditionalRequestHeaders = NULL;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\cabhdlr.cpp ===
/*
 *  FDIDLL.C -- FDI interface using CABINET.DLL
 *
 *  Copyright (C) Microsoft Corporation 1997
 *  All Rights Reserved.
 *
 *  Overview:
 *      This code is a wrapper which provides access to the actual FDI code
 *      in CABINET.DLL.  CABINET.DLL dynamically loads/unloads as needed.
 */
 
#include    "pch.hpp"
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <appdefs.h>

#include "fdi.h"

static HINSTANCE hCabinetDll = NULL;   /* DLL module handle */

/* pointers to the functions in the DLL */
typedef HFDI (FAR DIAMONDAPI *PFNFDICREATE)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf);

static PFNFDICREATE pfnFDICreate = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDIIsCabinet)(
        HFDI                hfdi,
        int                 hf,
        PFDICABINETINFO     pfdici);

static PFNFDIIsCabinet pfnFDIIsCabinet = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDICopy)(
        HFDI                hfdi,
        CHAR               *pszCabinet,
        CHAR               *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser);

static PFNFDICopy pfnFDICopy = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDIDestroy)(
        HFDI                hfdi);

static PFNFDIDestroy pfnFDIDestroy = NULL;

/*
 *  FDICreate -- Create an FDI context
 *
 *  See fdi.h for entry/exit conditions.
 */

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;


    if ( hCabinetDll != NULL )
    {
        goto gotEntryPoints;
    }

    hCabinetDll = LoadLibraryA("CABINET");
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = (PFNFDICREATE) GetProcAddress(hCabinetDll, "FDICreate");
    pfnFDICopy = (PFNFDICopy) GetProcAddress(hCabinetDll, "FDICopy");
    pfnFDIIsCabinet = (PFNFDIIsCabinet) GetProcAddress(hCabinetDll, "FDIIsCabinet");
    pfnFDIDestroy = (PFNFDIDestroy) GetProcAddress(hCabinetDll, "FDIDestroy");

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);
        hCabinetDll = NULL;
        return(NULL);
    }

gotEntryPoints:
    hfdi = pfnFDICreate(pfnalloc, pfnfree,
            pfnopen, pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
        hCabinetDll = NULL;
    }

    return(hfdi);
}


/*
 *  FDIIsCabinet -- Determines if file is a cabinet, returns info if it is
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 int             hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFDIIsCabinet(hfdi, hf,pfdici));
}


/*
 *  FDICopy -- extracts files from a cabinet
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            CHAR         *pszCabinet,
                            CHAR        *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi, pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


/*
 *  FDIDestroy -- Destroy an FDI context
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);

    return(rc);
}


/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
        return new BYTE[cb];
}


/*
 * Memory free function
 */
FNFREE(mem_free)
{
        delete pv;
}


FNOPEN(file_open)
{
    return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
        return _read(hf, pv, cb);
}


FNWRITE(file_write)
{
        return _write(hf, pv, cb);
}


FNCLOSE(file_close)
{
        return _close(hf);
}


FNSEEK(file_seek)
{
        return _lseek(hf, dist, seektype);
}

FNFDINOTIFY(notification_function)
{
    switch (fdint)
    {
        case fdintCABINET_INFO: // general information about the cabinet
#if 0
            printf(
                "fdintCABINET_INFO\n"
                "  next cabinet     = %s\n"
                "  next disk        = %s\n"
                "  cabinet path     = %s\n"
                "  cabinet set ID   = %d\n"
                "  cabinet # in set = %d (zero based)\n"
                "\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3,
                pfdin->setID,
                pfdin->iCabinet
            );
#endif
            return 0;

        case fdintPARTIAL_FILE: // first file in cabinet is continuation
#if 0
            printf(
                "fdintPARTIAL_FILE\n"
                "   name of continued file            = %s\n"
                "   name of cabinet where file starts = %s\n"
                "   name of disk where file starts    = %s\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3
            );
#endif
            return 0;

        case fdintCOPY_FILE:    // file to be copied
        {
            int        handle;
#if 0
            int        response;

            printf(
                "fdintCOPY_FILE\n"
                "  file name in cabinet = %s\n"
                "  uncompressed file size = %d\n"
                "  copy this file? (y/n): ",
                pfdin->psz1,
                pfdin->cb
            );
#endif

            handle = file_open(
                pfdin->psz1,
                _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL | _O_TRUNC,
                _S_IREAD | _S_IWRITE 
            );

            return handle;
        }

        case fdintCLOSE_FILE_INFO:    // close the file, set relevant info
        {
#if 0
            HANDLE  handle;
            DWORD   attrs;
            CHAR    destination[256];

            printf(
                "fdintCLOSE_FILE_INFO\n"
                "   file name in cabinet = %s\n"
                "\n",
                pfdin->psz1
            );
#endif

            file_close(pfdin->hf);

            return TRUE;
        }

        case fdintNEXT_CABINET:    // file continued to next cabinet
#if 0
            printf(
                "fdintNEXT_CABINET\n"
                "   name of next cabinet where file continued = %s\n"
                "   name of next disk where file continued    = %s\n"
                "   cabinet path name                         = %s\n"
                "\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3
            );
#endif
            return 0;
    }

    return 0;
}

HRESULT HandleCab(LPSTR cabinet_fullpath)
{
    ERF             erf;
    HFDI            hfdi;
    int                hf;
    FDICABINETINFO    fdici;
    CHAR            *p;
    CHAR            cabinet_name[256];
    CHAR            cabinet_path[256];
    CHAR            szCurrentDirectory[MAX_PATH];
    CHAR            szdrive[_MAX_DRIVE];   
    CHAR            szPathName[_MAX_PATH];     // This will be the dir we need to create
    CHAR            szdir[_MAX_DIR];
    CHAR            szfname[_MAX_FNAME];   
    CHAR            szext[_MAX_EXT];
	CHAR            szcabinet_fullpath[MAX_PATH+1];
    HRESULT         err = S_OK;

	lstrcpyA(szcabinet_fullpath, cabinet_fullpath);

    if (GetCurrentDirectoryA(sizeof(szCurrentDirectory), szCurrentDirectory))
    {
        // Split the provided path to get at the drive and path portion
        _splitpath( szcabinet_fullpath, szdrive, szdir, szfname, szext );
        wsprintfA(szPathName, "%s%s", szdrive, szdir);
   
        // Set the directory to where the cab is
        if (!SetCurrentDirectoryA(szPathName))
        {
            return(GetLastError());
        }
    }
    else
    {
        return(GetLastError());
    }
    
    
    do
    {
        hfdi = FDICreate(mem_alloc,
                              mem_free,
                              file_open,
                              file_read,
                              file_write,
                              file_close,
                              file_seek,
                              cpuUNKNOWN,
                              &erf);

        if (hfdi == NULL)
        {
            err =  -1;
            break;
        }

        /*
         * Is this file really a cabinet?
         */
        hf = file_open(
            szcabinet_fullpath,
            _O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
            0
        );

        if (hf == -1)
        {
            (void) FDIDestroy(hfdi);

            // Error Opening the file
            err =  -2;
            break;
            
        }

        if (FALSE == FDIIsCabinet(
                hfdi,
                hf,
                &fdici))
        {
            /*
             * No, it's not a cabinet!
             */
            _close(hf);

            (void) FDIDestroy(hfdi);
            err =  -3;
            break;
            
        }
        else
        {
            _close(hf);
        }

        p = strrchr(szcabinet_fullpath, '\\');

        if (p == NULL)
        {
            lstrcpyA(cabinet_name, szcabinet_fullpath);
            lstrcpyA(cabinet_path, "");
        }
        else
        {
            lstrcpyA(cabinet_name, ++p);
            // Need to make space for the null-terminator that lstrcpyn adds
            lstrcpynA(cabinet_path, szcabinet_fullpath, (int) (p-szcabinet_fullpath)+1);
        }

        if (TRUE != FDICopy(
            hfdi,
            cabinet_name,
            cabinet_path,
            0,
            notification_function,
            NULL,
            NULL))
        {
            // Extract Failed.
            (void) FDIDestroy(hfdi);
            err =  -4;
            break;
        }

        if (FDIDestroy(hfdi) != TRUE)
        {

            // why in the world would the context destroy fail ?
            err =  -5;
            break;
            
        }
        
        break;
    }
    while(1 );


    // Set the directory back to the original place
    if (!SetCurrentDirectoryA(szCurrentDirectory))
        return(GetLastError());
        
    
    return err;
}

void CleanupCabHandler()
{
    if (hCabinetDll != NULL)
    {
        FreeLibrary(hCabinetDll);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\wancfg.h ===
//****************************************************************************
//
//  File:       wancfg.h
//  Content:    This file contains the general WAN-device related declaration
//
//  Copyright (c) 1992-1995, Microsoft Corporation, all rights reserved
//
//  History:
//      Tues  8-15-95   ScottH          Created
//
//****************************************************************************

#ifndef _WANCFG_H_
#define _WANCFG_H_

//
// Device types known to the WAN.TSP 
//

#define WAN_DEVICETYPE_ISDN      0
#define WAN_DEVICETYPE_PPTP      1
#define WAN_DEVICETYPE_ATM       2


#define MAX_DEVICETYPE  32
#define MAX_DEVICEDESC  260

typedef struct tagWANCONFIG {
    DWORD   cbSize;                 /* size of structure */
    DWORD   cbTotalSize;            /* Total mem used by struct & var data */
    TCHAR   szDeviceType[MAX_DEVICETYPE];   /* device type */
    TCHAR   szDeviceDesc[MAX_DEVICEDESC];   /* device description */
    DWORD   dwDeviceOffset;         /* offset of device specific data in 
                                       bytes from the start */
    DWORD   cbDeviceSize;           /* size of the device specific data 
                                       field */
    WCHAR   wcData[1];              /* device specific data */
    } WANCONFIG, FAR * LPWANCONFIG;

// WAN Device Types
#define SZ_WANTYPE_ISDN     "ISDN"
#define SZ_WANTYPE_X25      "X.25"
#define SZ_WANTYPE_PPTP     "PPTP"
#define SZ_WANTYPE_ATM      "ATM"


//
//  WAN Phone book data.  This data is stored on a per connection basis
//  and the device info used for TAPI get and set dev config.
//
typedef struct tagWANPBCONFIG {
    DWORD   cbSize;                 /* size of structure */
    DWORD   cbTotalSize;            /* Total size used by struct & var data */

    TCHAR   szDeviceType[MAX_DEVICETYPE];   /* device type */

    DWORD   dwDeviceOffset;         /* offset of device specific data in 
                                       bytes from the start */
    DWORD   cbDeviceSize;           /* size of the device specific data 
                                       field */
    DWORD   dwVendorOffset;         /* offset of vendor specific data in
                                       bytes from the start */
    DWORD   cbVendorSize;           /* size of the vendor specific data
                                       field */
    DWORD   dwReservedOffset;       /* offset of reserved data in bytes 
                                       from the start */
    DWORD   cbReservedSize;         /* size of the reserved data field */
    WCHAR   wcData[1];              /* variable data */
    } WANPBCONFIG, FAR * LPWANPBCONFIG;



//
//  ISDN Phone book data.  This data is stored on a per connection basis
//  and is the structure returned for get and set dev config.
//
typedef struct tagISDNPBCONFIG {
    DWORD   dwFlags;                /* flags for the line (ISDN_CHAN_*) */
    DWORD   dwOptions;              /* options for the line (ISDN_CHANOPT_) */
    DWORD   dwSpeedType;            /* channel speed and type */
    DWORD   dwInactivityTimeout;    /* disconnect time in seconds */
} ISDNPBCONFIG, FAR * LPISDNPBCONFIG;


typedef struct tagISDNDEVCAPS {
    DWORD   cbSize;                 /* size of structure */
    DWORD   dwFlags;                /* flags for the device (ISDN_*) */
    DWORD   nSubType;               /* device subtype (ISDN_SUBTYPE_*) */
    DWORD   cLinesMax;              /* number of physical lines supported */
    DWORD   cActiveLines;           /* number of active physical lines */
    } ISDNDEVCAPS, FAR * LPISDNDEVCAPS;

// Flags for ISDNDEVCAPS
#define ISDN_DEFAULT            0x00000000L
#define ISDN_NO_RESTART         0x00000001L
#define ISDN_VENDOR_CONFIG      0x00000002L

// Subtype ordinals
#define ISDN_SUBTYPE_INTERNAL   0L
#define ISDN_SUBTYPE_PCMCIA     1L
#define ISDN_SUBTYPE_PPTP       2L


typedef struct tagISDNLINECAPS {
    DWORD   cbSize;                 /* size of structure */
    DWORD   dwFlags;                /* flags for the line (ISDN_LINE_*) */
    DWORD   dwChannelFlags;         /* flags for the channels (ISDN_CHAN_*) */
    DWORD   dwSwitchType;           /* switches supported */
    DWORD   dwSpeedType;            /* speed type */
    DWORD   cChannelsMax;           /* number of B-channels per line supported */
    DWORD   cActiveChannels;        /* number of active channels */
    } ISDNLINECAPS, FAR * LPISDNLINECAPS;

// Flags for ISDNLINECAPS
#define ISDN_LINE_DEFAULT       0x00000000L
#define ISDN_LINE_INACTIVE      0x00000001L     

// Channel flags for ISDNLINECAPS
#define ISDN_CHAN_DEFAULT       0x00000000L
#define ISDN_CHAN_INACTIVE      0x00000001L
#define ISDN_CHAN_SPEED_ADJUST  0x00000002L

// Switch type
//#define ISDN_SWITCH_NONE        0x00000000L
#define ISDN_SWITCH_AUTO        0x00000001L
#define ISDN_SWITCH_ATT         0x00000002L
#define ISDN_SWITCH_NI1         0x00000004L
#define ISDN_SWITCH_NTI         0x00000008L
#define ISDN_SWITCH_INS64       0x00000010L
#define ISDN_SWITCH_1TR6        0x00000020L
#define ISDN_SWITCH_VN3         0x00000040L /* retained for compatibility, use VN4*/
#define ISDN_SWITCH_NET3        0x00000080L /* retained for compatibility, use DSS1*/
#define ISDN_SWITCH_DSS1        0x00000080L
#define ISDN_SWITCH_AUS         0x00000100L
#define ISDN_SWITCH_BEL         0x00000200L
#define ISDN_SWITCH_VN4         0x00000400L
#define ISDN_SWITCH_NI2         0x00000800L

#define MAX_SWITCH              12          /* Needs to be updated with above list */


// Speed type
#define ISDN_SPEED_64K_DATA     0x00000001L
#define ISDN_SPEED_56K_DATA     0x00000002L
#define ISDN_SPEED_56K_VOICE    0x00000004L
#define ISDN_SPEED_128K_DATA    0x00000008L


typedef struct tagISDNCONFIG {
    DWORD   cbSize;                 /* size of structure */
    DWORD   cbTotalSize;            /* Total mem used by struct & var data */
    DWORD   dwFlags;                /* flags for the device (ISDN_*) */
    ISDNDEVCAPS idc;                /* device capabilities */
    DWORD   cLines;                 /* number of physical lines in the 
                                       line specific data block */
    HKEY    hkeyDriver;             /* handle to driver registry key */
    DWORD   dwVendorOffset;         /* offset of vendor specific data in
                                       bytes from the start */
    DWORD   cbVendorSize;           /* size of the vendor specific data
                                       field */
    DWORD   dwReservedOffset;       /* offset of reserved data in bytes 
                                       from the start */
    DWORD   cbReservedSize;         /* size of the reserved data field */
    DWORD   dwLineOffset;           /* offset of line specific data
                                       in bytes from the start */
    DWORD   cbLineSize;             /* size of the line specific data */

	WORD	padding;				/* padding for dword alignment */

    WCHAR   wcData[1];              /* variable data */
    } ISDNCONFIG, FAR * LPISDNCONFIG;


typedef struct tagISDNLINE {
    DWORD   cbSize;                 /* size of structure */
    DWORD   cbTotalSize;            /* Total mem used by struct & var data */
    DWORD   dwLineID;               /* unique line ID */
    DWORD   dwFlags;                /* flags for the line (ISDN_LINE_*) */
    DWORD   dwOptions;              /* options for the line (ISDN_LINEOPT_) */
    DWORD   dwSwitchType;           /* switch type */
    DWORD   dwUseChannel;           /* specific channel to use or number
                                       of channels to use */
    ISDNLINECAPS ilc;               /* line capabilities */
    DWORD   cChannels;              /* number of channels in the channel
                                       specific data block */
    HKEY    hkeyLine;               /* handle to line registry key */
    DWORD   dwVendorOffset;         /* offset of vendor specific data in
                                       bytes from the start */
    DWORD   cbVendorSize;           /* size of the vendor specific data
                                       field */
    DWORD   dwReservedOffset;       /* offset of reserved data in bytes 
                                       from the start */
    DWORD   cbReservedSize;         /* size of the reserved data field */
    DWORD   dwChannelOffset;        /* offset of channel specific data
                                       in bytes from the start */
    DWORD   cbChannelSize;          /* size of the channel specific data */

	WORD	padding;				/* padding for dword alignment */

    WCHAR   wcData[1];              /* variable data */
    } ISDNLINE, FAR * LPISDNLINE;

// Options for line
#define ISDN_LINEOPT_DEFAULT    0x00000000L
#define ISDN_LINEOPT_CHANNELID  0x00000001L
#define ISDN_LINEOPT_FIXEDCOUNT 0x00000002L


#define MAX_PHONE   32
#define MAX_SPID    32

typedef struct tagISDNCHANNEL {
    DWORD   cbSize;                 /* size of structure */
    DWORD   cbTotalSize;            /* Total mem used by struct & var data */
    DWORD   dwChannelID;            /* unique channel ID */
    DWORD   dwFlags;                /* flags for the line (ISDN_CHAN_*) */
    DWORD   dwOptions;              /* options for the line (ISDN_CHANOPT_) */
    DWORD   dwSpeedType;            /* channel speed and type */
    DWORD   dwInactivityTimeout;    /* disconnect time in seconds */
    TCHAR   szPhone[MAX_PHONE];     /* phone number */
    TCHAR   szSPID[MAX_SPID];       /* SPID */
    HKEY    hkeyChannel;            /* handle to channel registry key */
    DWORD   dwVendorOffset;         /* offset of vendor specific data in
                                       bytes from the start */
    DWORD   cbVendorSize;           /* size of the vendor specific data
                                       field */
    DWORD   dwReservedOffset;       /* offset of reserved data in bytes 
                                       from the start */
    DWORD   cbReservedSize;         /* size of the reserved data field */

	WORD	padding;				/* padding for dword alignment */

    WCHAR   wcData[1];              /* variable data */
    } ISDNCHANNEL, FAR * LPISDNCHANNEL;

// Options for channel
#define ISDN_CHANOPT_DEFAULT            0x00000000L
#define ISDN_CHANOPT_SHOW_STATUS        0x00000001L
#define ISDN_CHANOPT_ENABLE_LOG         0x00000002L
#define ISDN_CHANOPT_INACTIVE_TIMEOUT   0x00000004L



//
// ATM Configuration info
//

typedef struct tagATMCONFIG {
    DWORD   cbSize;                 /* size of structure */
    DWORD   cbTotalSize;            /* Total mem used by struct & var data */
    DWORD   dwFlags;                /* flags for the device */
    DWORD   dwCircuitFlags;         /* flags for the circuit */

    HKEY    hkeyDriver;             /* handle to driver registry key */
    DWORD   dwVendorOffset;         /* offset of vendor specific data in
                                       bytes from the start */
    DWORD   cbVendorSize;           /* size of the vendor specific data
                                       field */
    DWORD   dwReservedOffset;       /* offset of reserved data in bytes 
                                       from the start */
    DWORD   cbReservedSize;         /* size of the reserved data field */

    WCHAR   wcData[1];              /* variable data */
    } ATMCONFIG, FAR * LPATMCONFIG;


//
//  ATM Phone book data.  This data is stored on a per connection basis
//  and is the structure returned for get and set dev config.
//

typedef struct tagATMPBCONFIG {
    DWORD   dwGeneralOpt;           /* General options */
    DWORD   dwCircuitOpt;           /* Circuit options */
    DWORD   dwCircuitSpeed;         /* Circuit Speed */
    WORD    wPvcVpi;                /* PVC: VPI */
    WORD    wPvcVci;                /* PVC: VCI */
} ATMPBCONFIG, FAR * LPATMPBCONFIG;



//
// Flags for ATM Phone Book entry
//

//
// ATM General Options
//
#define ATM_GENERAL_OPT_VENDOR_CONFIG   0x00000001L
#define ATM_GENERAL_OPT_SHOW_STATUS     0x00000002L
#define ATM_GENERAL_OPT_ENABLE_LOG      0x00000004L

#define ATM_GENERAL_OPT_MASK            0x0000000FL
#define ATM_GENERAL_OPT_DEFAULT         0x00000000L


//
// ATM Circuit Options
//
#define ATM_CIRCUIT_OPT_QOS_ADJUST      0x00000010L
#define ATM_CIRCUIT_OPT_SPEED_ADJUST    0x00000020L
#define ATM_CIRCUIT_OPT_SVC             0x00000040L
#define ATM_CIRCUIT_OPT_PVC             0x00000080L

#define ATM_CIRCUIT_OPT_MASK            0x000000F0L
#define ATM_CIRCUIT_OPT_DEFAULT         (ATM_CIRCUIT_OPT_SVC | ATM_CIRCUIT_OPT_QOS_ADJUST | ATM_CIRCUIT_OPT_SPEED_ADJUST)


//
// ATM QOS Flags
//
#define ATM_CIRCUIT_QOS_VBR             0x00000100L
#define ATM_CIRCUIT_QOS_CBR             0x00000200L
#define ATM_CIRCUIT_QOS_ABR             0x00000400L
#define ATM_CIRCUIT_QOS_UBR             0x00000800L

#define ATM_CIRCUIT_QOS_MASK            0x00000F00L
#define ATM_CIRCUIT_QOS_DEFAULT         (ATM_CIRCUIT_QOS_UBR)

//
// ATM Speed Flags
//
#define ATM_CIRCUIT_SPEED_LINE_RATE     0x00001000L
#define ATM_CIRCUIT_SPEED_USER_SPEC     0x00002000L
#define ATM_CIRCUIT_SPEED_512KB         0x00004000L
#define ATM_CIRCUIT_SPEED_1536KB        0x00008000L
#define ATM_CIRCUIT_SPEED_25MB          0x00010000L
#define ATM_CIRCUIT_SPEED_155MB         0x00020000L

#define ATM_CIRCUIT_SPEED_MASK          0x000FF000L
#define ATM_CIRCUIT_SPEED_DEFAULT       (ATM_CIRCUIT_SPEED_LINE_RATE)

//
// ATM Encapsulation Flags
//
#define ATM_CIRCUIT_ENCAP_NULL          0x00100000L
#define ATM_CIRCUIT_ENCAP_LLC           0x00200000L

#define ATM_CIRCUIT_ENCAP_MASK          0x00F00000L
#define ATM_CIRCUIT_ENCAP_DEFAULT       (ATM_CIRCUIT_ENCAP_NULL)


// 
// WAN Handler binding
//

DWORD   WINAPI WanBind_Get(LPCTSTR pszDeviceType);
DWORD   WINAPI WanBind_Release(LPCTSTR pszDeviceType);
HICON   WINAPI WanBind_GetIcon(LPCTSTR pszDeviceType);
DWORD   WINAPI WanBind_ConfigDialog(LPCTSTR pszDeviceType, LPCTSTR pszFriendlyName, HWND hwndOwner, LPWANCONFIG pwc, LPWANPBCONFIG pwpbc);
DWORD   WINAPI WanBind_QueryConfigData(LPCTSTR pszDeviceType, HKEY hkey, DWORD dwLineID, LPVOID pvData, LPDWORD pcbData);


//
// Exports by the handler
//

DWORD   WINAPI WanQueryConfigData(HKEY hkey, DWORD dwLineID, LPVOID pvData, LPDWORD pcbData);
DWORD   WINAPI WanConfigDialog(LPCTSTR pszFriendlyName, HWND hwndOwner, LPWANCONFIG lpwanconfig, LPWANPBCONFIG pwpbc);

#endif  //_WANCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\mydefs.h ===
#if !defined(WIN16)
extern HANDLE g_hDLLHeap;		// private Win32 heap

#define MyAlloc(n)			((LPBYTE)HeapAlloc(g_hDLLHeap, HEAP_ZERO_MEMORY, sizeof(BYTE)*(n)))
#define MyFree(pv)			HeapFree(g_hDLLHeap, 0, pv)
#define MyRealloc(pv, n)	((LPBYTE)HeapReAlloc(g_hDLLHeap, HEAP_ZERO_MEMORY, (pv), sizeof(BYTE)*(n)))
#define MyHeapSize(pv)     HeapSize(g_hDLLHeap, 0, pv)

LPSTR MyStrDup(LPSTR);

#ifdef DEBUG

#define MyAssert(f)			((f) ? 0 : MyAssertProc(__FILE__, __LINE__, #f))
#define MyDbgSz(x)			{ puts x; OutputDebugString x; }
int MyAssertProc(LPSTR, int, LPSTR);
void CDECL MyDprintf(LPCSTR pcsz, ...);

#else // DEBUG

#	define MyTrace(x)			
#	define MyDbgSz(x)			
#	define MyAssert(f)			

#endif // DEBUG

#define W32toHR(x)	HRESULT_FROM_WIN32(x)

#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by download.rc
//
#define IDS_DOWNLOAD                    1
#define IDS_APPNAME                     3
#define IDS_TMPVAR                      4
#define IDS_TEMPVAR                     5

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\fdi.h ===
/*
 *  FDI.H -- File Decompression Interface
 *
 *  Copyright (C) Microsoft Corporation 1993-1997
 *  All Rights Reserved.
 */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)

//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif


/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

#ifdef DBG
// don't hide statics from map during debugging
#define STATIC      
#else // !DBG
#define STATIC static
#endif // !DBG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK         0x7ffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256

/***    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompTYPE_LZX           0x0003  // LZX
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_LZX_WINDOW    0x1F00  // Mask for LZX Compression Memory
#define tcompLZX_WINDOW_LO      0x0F00  // Lowest LZX Memory (15)
#define tcompLZX_WINDOW_HI      0x1500  // Highest LZX Memory (21)
#define tcompSHIFT_LZX_WINDOW        8  // Amount to shift over to get int

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t, l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))

#define LZXCompressionWindowFromTCOMP(tc) \
            (((tc) & tcompMASK_LZX_WINDOW) >> tcompSHIFT_LZX_WINDOW)

#define TCOMPfromLZXWindow(w)      \
            (((w) << tcompSHIFT_LZX_WINDOW ) |  \
             ( tcompTYPE_LZX ))


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_TYPES_FCI_FDI

/*
 *  Concepts:
 *      A *cabinet* file contains one or more *folders*.  A folder contains
 *      one or more (pieces of) *files*.  A folder is by definition a
 *      decompression unit, i.e., to extract a file from a folder, all of
 *      the data from the start of the folder up through and including the
 *      desired file must be read and decompressed.
 *
 *      A folder can span one (or more) cabinet boundaries, and by implication
 *      a file can also span one (or more) cabinet boundaries.  Indeed, more
 *      than one file can span a cabinet boundary, since FCI concatenates
 *      files together into a single data stream before compressing (actually,
 *      at most one file will span any one cabinet boundary, but FCI does
 *      not know which file this is, since the mapping from uncompressed bytes
 *      to compressed bytes is pretty obscure.  Also, since FCI compresses
 *      in blocks of 32K (at present), any files with data in a 32K block that
 *      spans a cabinet boundary require FDI to read both cabinet files
 *      to get the two halves of the compressed block).
 *
 *  Overview:
 *      The File Decompression Interface is used to simplify the reading of
 *      cabinet files.  A setup program will proceed in a manner very
 *      similar to the pseudo code below.  An FDI context is created, the
 *      setup program calls FDICopy() for each cabinet to be processed.  For
 *      each file in the cabinet, FDICopy() calls a notification callback
 *      routine, asking the setup program if the file should be copied.
 *      This call-back approach is great because it allows the cabinet file
 *      to be read and decompressed in an optimal manner, and also makes FDI
 *      independent of the run-time environment -- FDI makes *no* C run-time
 *      calls whatsoever.  All memory allocation and file I/O functions are
 *      passed into FDI by the client.
 *
 *      main(...)
 *      {
 *          // Read INF file to construct list of desired files.   
 *          //  Ideally, these would be sorted in the same order as the
 *          //  files appear in the cabinets, so that you can just walk
 *          //  down the list in response to fdintCOPY_FILE notifications.
 *
 *          // Construct list of required cabinets. 
 *
 *          hfdi = FDICreate(...);          // Create FDI context
 *          For (cabinet in List of Cabinets) {
 *              FDICopy(hfdi, cabinet,fdiNotify,...);  // Process each cabinet
 *          }
 *          FDIDestroy(hfdi);
 *          ...
 *      }
 *
 *      // Notification callback function 
 *      fdiNotify(fdint, ...)
 *      {
 *          If (User Aborted)               // Permit cancellation
 *              if (fdint == fdintCLOSE_FILE_INFO)
 *                  close open file
 *              return -1;
 *          switch (fdint) {
 *              case fdintCOPY_FILE:        // File to copy, maybe
 *                  // Check file against list of desired files 
 *                  if want to copy file
 *                      open destination file and return handle
 *                  else
 *                      return NULL;        // Skip file
 *              case fdintCLOSE_FILE_INFO:
 *                  close file
 *                  set date, time, and attributes
 *
 *              case fdintNEXT_CABINET:
 *                  if not an error callback
 *                      Tell FDI to use suggested directory name
 *                  else
 *                      Tell user what the problem was, and prompt
 *                          for a new disk and/or path.
 *                      if user aborts
 *                          Tell FDI to abort
 *                      else
 *                          return to FDI to try another cabinet
 *
 *              default:
 *                  return 0;               // more messages may be defined
 *              ...
 *      }
 *
 *  Error Handling Suggestions:
 *      Since you the client have passed in *all* of the functions that
 *      FDI uses to interact with the "outside" world, you are in prime
 *      position to understand and deal with errors.
 *
 *      The general philosophy of FDI is to pass all errors back up to
 *      the client.  FDI returns fairly generic error codes in the case
 *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail,
 *      since it assumes that the callback function will save enough
 *      information in a static/global so that when FDICopy() returns
 *      fail, the client can examine this information and report enough
 *      detail about the problem that the user can take corrective action.
 *
 *      For very specific errors (CORRUPT_CABINET, for example), FDI returns
 *      very specific error codes.
 *
 *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING
 *      ERRORS TO FDI!
 *
 *      Examples:
 *          (1) If the disk is getting full, instead of returning an error
 *              from your PFNWRITE function, you should -- inside your
 *              PFNWRITE function -- put up a dialog telling the user to free
 *              some disk space.
 *          (2) When you get the fdintNEXT_CABINET notification, you should
 *              verify that the cabinet you return is the correct one (call
 *              FDIIsCabinet(), and make sure the setID matches the one for
 *              the current cabinet specified in the fdintCABINET_INFO, and
 *              that the disk number is one greater.
 *
 *              NOTE: FDI will continue to call fdintNEXT_CABINET until it
 *                    gets the cabinet it wants, or until you return -1
 *                    to abort the FDICopy() call.
 *
 *      The documentation below on the FDI error codes provides explicit
 *      guidance on how to avoid each error.
 *
 *      If you find you must return a failure to FDI from one of your
 *      callback functions, then FDICopy() frees all resources it allocated
 *      and closes all files.  If you can figure out how to overcome the
 *      problem, you can call FDICopy() again on the last cabinet, and
 *      skip any files that you already copied.  But, note that FDI does
 *      *not* maintain any state between FDICopy() calls, other than possibly
 *      memory allocated for the decompressor.
 *
 *      See FDIERROR for details on FDI error codes and recommended actions.
 *
 *
 *  Progress Indicator Suggestions:
 *      As above, all of the file I/O functions are supplied by you.  So,
 *      updating a progress indicator is very simple.  You keep track of
 *      the target files handles you have opened, along with the uncompressed
 *      size of the target file.  When you see writes to the handle of a
 *      target file, you use the write count to update your status!
 *      Since this method is available, there is no separate callback from
 *      FDI just for progess indication.
 */

#ifndef INCLUDED_FDI
#define INCLUDED_FDI    1

//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)


/***    FDIERROR - Error codes returned in erf.erfOper field
 *
 *  In general, FDI will only fail if one of the passed in memory or
 *  file I/O functions fails.  Other errors are pretty unlikely, and are
 *  caused by corrupted cabinet files, passing in a file which is not a
 *  cabinet file, or cabinet files out of order.
 *
 *  Description:    Summary of error.
 *  Cause:          List of possible causes of this error.
 *  Response:       How client might respond to this error, or avoid it in
 *                  the first place.
 */
typedef enum {
    FDIERROR_NONE,
        // Description: No error
        // Cause:       Function was successfull.
        // Response:    Keep going!

    FDIERROR_CABINET_NOT_FOUND,
        // Description: Cabinet not found
        // Cause:       Bad file name or path passed to FDICopy(), or returned
        //              to fdintNEXT_CABINET.
        // Response:    To prevent this error, validate the existence of the
        //              the cabinet *before* passing the path to FDI.

    FDIERROR_NOT_A_CABINET,
        // Description: Cabinet file does not have the correct format
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, is too small to be a cabinet file,
        //              or does not have the cabinet signature in its first
        //              four bytes.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_UNKNOWN_CABINET_VERSION,
        // Description: Cabinet file has an unknown version number.
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, has what looks like a cabinet file
        //              header, but the version of the cabinet file format
        //              is not one understood by this version of FDI.  The
        //              erf.erfType field is filled in with the version number
        //              found in the cabinet file.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_CORRUPT_CABINET,
        // Description: Cabinet file is corrupt
        // Cause:       FDI returns this error any time it finds a problem
        //              with the logical format of a cabinet file, and any
        //              time one of the passed-in file I/O calls fails when
        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD,
        //              or PFNCLOSE).  The client can distinguish these two
        //              cases based upon whether the last file I/O call
        //              failed or not.
        // Response:    Assuming this is not a real corruption problem in
        //              a cabinet file, the file I/O functions could attempt
        //              to do retries on failure (for example, if there is a
        //              temporary network connection problem).  If this does
        //              not work, and the file I/O call has to fail, then the
        //              FDI client will have to clean up and call the
        //              FDICopy() function again.

    FDIERROR_ALLOC_FAIL,
        // Description: Could not allocate enough memory
        // Cause:       FDI tried to allocate memory with the PFNALLOC
        //              function, but it failed.
        // Response:    If possible, PFNALLOC should take whatever steps
        //              are possible to allocate the memory requested.  If
        //              memory is not immediately available, it might post a
        //              dialog asking the user to free memory, for example.
        //              Note that the bulk of FDI's memory allocations are
        //              made at FDICreate() time and when the first cabinet
        //              file is opened during FDICopy().

    FDIERROR_BAD_COMPR_TYPE,
        // Description: Unknown compression type in a cabinet folder
        // Cause:       [Should never happen.]  A folder in a cabinet has an
        //              unknown compression type.  This is probably caused by
        //              a mismatch between the version of FCI.LIB used to
        //              create the cabinet and the FDI.LIB used to read the
        //              cabinet.
        // Response:    Abort.

    FDIERROR_MDI_FAIL,
        // Description: Failure decompressing data from a cabinet file
        // Cause:       The decompressor found an error in the data coming
        //              from the file cabinet.  The cabinet file was corrupted.
        //              [11-Apr-1994 bens When checksuming is turned on, this
        //              error should never occur.]
        // Response:    Probably should abort; only other choice is to cleanup
        //              and call FDICopy() again, and hope there was some
        //              intermittent data error that will not reoccur.

    FDIERROR_TARGET_FILE,
        // Description: Failure writing to target file
        // Cause:       FDI returns this error any time it gets an error back
        //              from one of the passed-in file I/O calls fails when
        //              writing to a file being extracted from a cabinet.
        // Response:    To avoid or minimize this error, the file I/O functions
        //              could attempt to avoid failing.  A common cause might
        //              be disk full -- in this case, the PFNWRITE function
        //              could have a check for free space, and put up a dialog
        //              asking the user to free some disk space.

    FDIERROR_RESERVE_MISMATCH,
        // Description: Cabinets in a set do not have the same RESERVE sizes
        // Cause:       [Should never happen]. FDI requires that the sizes of
        //              the per-cabinet, per-folder, and per-data block
        //              RESERVE sections be consistent across all the cabinets
        //              in a set.
        // Response:    Abort.

    FDIERROR_WRONG_CABINET,
        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect
        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()!
        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET
        //              callback until either the correct cabinet is specified,
        //              or you return ABORT.
        //              When FDICopy() is extracting a file that crosses a
        //              cabinet boundary, it calls fdintNEXT_CABINET to ask
        //              for the path to the next cabinet.  Not being very
        //              trusting, FDI then checks to make sure that the
        //              correct continuation cabinet was supplied!  It does
        //              this by checking the "setID" and "iCabinet" fields
        //              in the cabinet.  When MAKECAB.EXE creates a set of
        //              cabinets, it constructs the "setID" using the sum
        //              of the bytes of all the destination file names in
        //              the cabinet set.  FDI makes sure that the 16-bit
        //              setID of the continuation cabinet matches the
        //              cabinet file just processed.  FDI then checks that
        //              the cabinet number (iCabinet) is one more than the
        //              cabinet number for the cabinet just processed.
        // Response:    You need code in your fdintNEXT_CABINET (see below)
        //              handler to do retries if you get recalled with this
        //              error.  See the sample code (EXTRACT.C) to see how
        //              this should be handled.

    FDIERROR_USER_ABORT,
        // Description: FDI aborted.
        // Cause:       An FDI callback returnd -1 (usually).
        // Response:    Up to client.

} FDIERROR;


/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 */
#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 */
#ifndef _A_EXEC
#define _A_EXEC         0x40
#endif


/***    HFDI - Handle to an FDI context
 *
 *  FDICreate() creates this, and it must be passed to all other FDI
 *  functions.
 */
typedef void FAR *HFDI; /* hfdi */


/***    FDICABINETINFO - Information about a cabinet
 *
 */
typedef struct {
    long        cbCabinet;              // Total length of cabinet file
    USHORT      cFolders;               // Count of folders in cabinet
    USHORT      cFiles;                 // Count of files in cabinet
    USHORT      setID;                  // Cabinet set ID
    USHORT      iCabinet;               // Cabinet number in set (0 based)
    BOOL        fReserve;               // TRUE => RESERVE present in cabinet
    BOOL        hasprev;                // TRUE => Cabinet is chained prev
    BOOL        hasnext;                // TRUE => Cabinet is chained next
} FDICABINETINFO; /* fdici */
typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */


/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types
 *
 */
typedef enum {
    fdidtNEW_CABINET,                   // New cabinet
    fdidtNEW_FOLDER,                    // New folder
    fdidtDECRYPT,                       // Decrypt a data block
} FDIDECRYPTTYPE; /* fdidt */


/***    FDIDECRYPT - Data for PFNFDIDECRYPT function
 *
 */
typedef struct {
    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below)
    void FAR         *pvUser;           // Decryption context
    union {
        struct {                        // fdidtNEW_CABINET
            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER
            USHORT    cbHeaderReserve;  // Size of pHeaderReserve
            USHORT    setID;            // Cabinet set ID
            int       iCabinet;         // Cabinet number in set (0 based)
        } cabinet;

        struct {                        // fdidtNEW_FOLDER
            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER
            USHORT    cbFolderReserve;  // Size of pFolderReserve
            USHORT    iFolder;          // Folder number in cabinet (0 based)
        } folder;

        struct {                        // fdidtDECRYPT
            void FAR *pDataReserve;     // RESERVE section from CFDATA
            USHORT    cbDataReserve;    // Size of pDataReserve
            void FAR *pbData;           // Data buffer
            USHORT    cbData;           // Size of data buffer
            BOOL      fSplit;           // TRUE if this is a split data block
            USHORT    cbPartial;        // 0 if this is not a split block, or
                                        //  the first piece of a split block;
                                        // Greater than 0 if this is the
                                        //  second piece of a split block.
        } decrypt;
    };
} FDIDECRYPT; /* fdid */
typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */


/***    FNALLOC - Memory Allocation
 *      FNFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FDI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           PFNALLOC and PFNFREE calls -- incremental releases of
 *           FDI may have radically different numbers of
 *           PFNALLOC calls and allocation sizes!
 */
//** Memory functions for FDI
typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)


/***    PFNOPEN  - File I/O callbacks for FDI
 *      PFNREAD
 *      PFNWRITE
 *      PFNCLOSE
 *      PFNSEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  FDI will usually
 *           stick to opening cabinet files, but it is possible
 *           that in a future implementation it may open temporary
 *           files or open cabinet files in a different order.
 *
 *  Notes for Memory Mapped File fans:
 *      You can write wrapper routines to allow FDI to work on memory
 *      mapped files.  You'll have to create your own "handle" type so that
 *      you can store the base memory address of the file and the current
 *      seek position, and then you'll allocate and fill in one of these
 *      structures and return a pointer to it in response to the PFNOPEN
 *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
 *      functions will do memcopy(), and update the seek position in your
 *      "handle" structure.  PFNSEEK will just change the seek position
 *      in your "handle" structure.
 */
//** File I/O functions for FDI
typedef int  (FAR DIAMONDAPI *PFNOPEN) (CHAR FAR *pszFile, int oflag, int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);

#define FNOPEN(fn) int FAR DIAMONDAPI fn(CHAR FAR *pszFile, int oflag, int pmode)
#define FNREAD(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNWRITE(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNCLOSE(fn) int FAR DIAMONDAPI fn(int hf)
#define FNSEEK(fn) long FAR DIAMONDAPI fn(int hf, long dist, int seektype)



/***    PFNFDIDECRYPT - FDI Decryption callback
 *
 *  If this function is passed on the FDICopy() call, then FDI calls it
 *  at various times to update the decryption state and to decrypt FCDATA
 *  blocks.
 *
 *  Common Entry Conditions:
 *      pfdid->fdidt  - Command type
 *      pfdid->pvUser - pvUser value from FDICopy() call
 *
 *  fdidtNEW_CABINET:   //** Notification of a new cabinet
 *      Entry:
 *        pfdid->cabinet.
 *          pHeaderReserve  - RESERVE section from CFHEADER
 *          cbHeaderReserve - Size of pHeaderReserve
 *          setID           - Cabinet set ID
 *          iCabinet        - Cabinet number in set (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *      (1) This call allows the decryption code to pick out any information
 *          from the cabinet header reserved area (placed there by DIACRYPT)
 *          needed to perform decryption.  If there is no such information,
 *          this call would presumably be ignored.
 *      (2) This call is made very soon after fdintCABINET_INFO.
 *
 *  fdidtNEW_FOLDER:    //** Notification of a new folder
 *      Entry:
 *        pfdid->folder.
 *          pFolderReserve  - RESERVE section from CFFOLDER
 *          cbFolderReserve - Size of pFolderReserve
 *          iFolder         - Folder number in cabinet (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          This call allows the decryption code to pick out any information
 *          from the folder reserved area (placed there by DIACRYPT) needed
 *          to perform decryption.  If there is no such information, this
 *          call would presumably be ignored.
 *
 *  fdidtDECRYPT:       //** Decrypt a data buffer
 *      Entry:
 *        pfdid->folder.
 *          pDataReserve  - RESERVE section for this CFDATA block
 *          cbDataReserve - Size of pDataReserve
 *          pbData        - Data buffer
 *          cbData        - Size of data buffer
 *          fSplit        - TRUE if this is a split data block
 *          cbPartial     - 0 if this is not a split block, or the first
 *                              piece of a split block; Greater than 0 if
 *                              this is the second piece of a split block.
 *      Exit-Success:
 *          returns TRUE;
 *      Exit-Failure:
 *          returns FALSE; error during decrypt
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          FCI will split CFDATA blocks across cabinet boundaries if
 *          necessary.  To provide maximum flexibility, FDI will call the
 *          fdidtDECRYPT function twice on such split blocks, once when
 *          the first portion is read, and again when the second portion
 *          is read.  And, of course, most data blocks will not be split.
 *          So, there are three cases:
 *
 *           1) fSplit == FALSE
 *              You have the entire data block, so decrypt it.
 *
 *           2) fSplit == TRUE, cbPartial == 0
 *              This is the first portion of a split data block, so cbData
 *              is the size of this portion.  You can either choose to decrypt
 *              this piece, or ignore this call and decrypt the full CFDATA
 *              block on the next (second) fdidtDECRYPT call.
 *
 *           3) fSplit == TRUE, cbPartial > 0
 *              This is the second portion of a split data block (indeed,
 *              cbPartial will have the same value as cbData did on the
 *              immediately preceeding fdidtDECRYPT call!).  If you decrypted
 *              the first portion on the first call, then you can decrypt the
 *              second portion now.  If you ignored the first call, then you
 *              can decrypt the entire buffer.
 *              NOTE: pbData points to the second portion of the split data
 *                    block in this case, *not* the entire data block.  If
 *                    you want to wait until the second piece to decrypt the
 *                    *entire* block, pbData-cbPartial is the address of the
 *                    start of the whole block, and cbData+cbPartial is its
 *                    size.
 */
typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */
#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid)


/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY
 *
 *  See the FDINOTIFICATIONTYPE definition for information on usage and
 *  meaning of these fields.
 */
typedef struct {
// long fields
    long      cb;
    CHAR FAR *psz1;
    CHAR FAR *psz2;
    CHAR FAR *psz3;                     // Points to a 256 character buffer
    void FAR *pv;                       // Value for client

// int fields
    int       hf;

// short fields
    USHORT    date;
    USHORT    time;
    USHORT    attribs;

    USHORT    setID;                    // Cabinet set ID
    USHORT    iCabinet;                 // Cabinet number (0-based)
    USHORT    iFolder;                  // Folder number (0-based)

    FDIERROR  fdie;
} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */


/***    FDINOTIFICATIONTYPE - FDICopy notification types
 *
 *  The notification function for FDICopy can be called with the following
 *  values for the fdint parameter.  In all cases, the pfdin->pv field is
 *  filled in with the value of the pvUser argument passed in to FDICopy().
 *
 *  A typical sequence of calls will be something like this:
 *      fdintCABINET_INFO     // Info about the cabinet
 *      fdintENUMERATE        // Starting enumeration
 *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and
 *                            // one or more files were continued from the
 *                            // previous cabinet.
 *      ...
 *      fdintPARTIAL_FILE
 *      fdintCOPY_FILE        // The first file that starts in this cabinet
 *      ...
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintNEXT_CABINET     // File was continued to next cabinet!
 *      fdintCABINET_INFO     // Info about the new cabinet
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *      ...
 *      fdintENUMERATE        // Ending enumeration
 *
 *  fdintCABINET_INFO:
 *        Called exactly once for each cabinet opened by FDICopy(), including
 *        continuation cabinets opened due to file(s) spanning cabinet
 *        boundaries. Primarily intended to permit EXTRACT.EXE to
 *        automatically select the next cabinet in a cabinet sequence even if
 *        not copying files that span cabinet boundaries.
 *      Entry:
 *          pfdin->psz1     = name of next cabinet
 *          pfdin->psz2     = name of next disk
 *          pfdin->psz3     = cabinet path name
 *          pfdin->setID    = cabinet set ID (a random 16-bit number)
 *          pfdin->iCabinet = Cabinet number within cabinet set (0-based)
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is made *every* time a new cabinet is examined by
 *          FDICopy().  So if "foo2.cab" is examined because a file is
 *          continued from "foo1.cab", and then you call FDICopy() again
 *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all
 *          told.
 *
 *  fdintCOPY_FILE:
 *        Called for each file that *starts* in the current cabinet, giving
 *        the client the opportunity to request that the file be copied or
 *        skipped.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->cb      = uncompressed size of file
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *      Exit-Success:
 *          Return non-zero file handle for destination file; FDI writes
 *          data to this file use the PFNWRITE function supplied to FDICreate,
 *          and then calls fdintCLOSE_FILE_INFO to close the file and set
 *          the date, time, and attributes.  NOTE: This file handle returned
 *          must also be closeable by the PFNCLOSE function supplied to
 *          FDICreate, since if an error occurs while writing to this handle,
 *          FDI will use the PFNCLOSE function to close the file so that the
 *          client may delete it.
 *      Exit-Failure:
 *          Returns 0  => Skip file, do not copy
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintCLOSE_FILE_INFO:
 *        Called after all of the data has been written to a target file.
 *        This function must close the file and set the file date, time,
 *        and attributes.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->hf      = file handle
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *          pfdin->cb      = Run After Extract (0 - don't run, 1 Run)
 *      Exit-Success:
 *          Returns TRUE
 *      Exit-Failure:
 *          Returns FALSE, or -1 to abort;
 *
 *              IMPORTANT NOTE IMPORTANT:
 *                  pfdin->cb is overloaded to no longer be the size of
 *                  the file but to be a binary indicated run or not
 *
 *              IMPORTANT NOTE:
 *                  FDI assumes that the target file was closed, even if this
 *                  callback returns failure.  FDI will NOT attempt to use
 *                  the PFNCLOSE function supplied on FDICreate() to close
 *                  the file!
 *
 *  fdintPARTIAL_FILE:
 *        Called for files at the front of the cabinet that are CONTINUED
 *        from a previous cabinet.  This callback occurs only when FDICopy is
 *        started on second or subsequent cabinet in a series that has files
 *        continued from a previous cabinet.
 *      Entry:
 *          pfdin->psz1 = file name of file CONTINUED from a PREVIOUS cabinet
 *          pfdin->psz2 = name of cabinet where file starts
 *          pfdin->psz3 = name of disk where file starts
 *      Exit-Success:
 *          Return anything other than -1; enumeration continues
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintENUMERATE:
 *        Called once after a call to FDICopy() starts scanning a CAB's
 *        CFFILE entries, and again when there are no more CFFILE entries.
 *        If CAB spanning occurs, an additional call will occur after the
 *        first spanned file is completed.  If the pfdin->iFolder value is
 *        changed from zero, additional calls will occur next time it reaches
 *        zero.  If iFolder is changed to zero, FDICopy will terminate, as if
 *        there were no more CFFILE entries.  Primarily intended to allow an
 *        application with it's own file list to help FDI advance quickly to
 *        a CFFILE entry of interest.  Can also be used to allow an
 *        application to determine the cb values for each file in the CAB.
 *      Entry:
 *        pfdin->cb        = current CFFILE position
 *        pfdin->iFolder   = number of files remaining
 *        pfdin->setID     = current CAB's setID value
 *      Exit-Don't Care:
 *        Don't change anything.
 *        Return anything but -1.
 *      Exit-Forcing a skip:
 *        pfdin->cb        = desired CFFILE position
 *        pfdin->iFolder   = desired # of files remaining
 *        Return anything but -1.
 *      Exit-Stop:
 *        pfdin->iFolder    = set to 0
 *        Return anything but -1.
 *      Exit-Failure:
 *        Return -1 => Abort FDICopy call ("user aborted".)
 *      Notes:
 *        This call can be ignored by applications which want normal file
 *        searching.  The application can adjust the supplied values to
 *        force FDICopy() to continue it's search at another location, or
 *        to force FDICopy() to terminate the search, by setting iFolder to 0.
 *        (FDICopy() will report no error when terminated this way.)
 *        FDI has no means to verify the supplied cb or iFolder values.
 *        Arbitrary values are likely to cause undesirable results.  An
 *        application should cross-check pfdin->setID to be certain the
 *        external database is in sync with the CAB.  Reverse-skips are OK
 *        (but may be inefficient) unless fdintNEXT_CABINET has been called.
 *
 *  fdintNEXT_CABINET:
 *        This function is *only* called when fdintCOPY_FILE was told to copy
 *        a file in the current cabinet that is continued to a subsequent
 *        cabinet file.  It is important that the cabinet path name (psz3)
 *        be validated before returning!  This function should ensure that
 *        the cabinet exists and is readable before returning.  So, this
 *        is the function that should, for example, issue a disk change
 *        prompt and make sure the cabinet file exists.
 *
 *        When this function returns to FDI, FDI will check that the setID
 *        and iCabinet match the expected values for the next cabinet.
 *        If not, FDI will continue to call this function until the correct
 *        cabinet file is specified, or until this function returns -1 to
 *        abort the FDICopy() function.  pfdin->fdie is set to
 *        FDIERROR_WRONG_CABINET to indicate this case.
 *
 *        If you *haven't* ensured that the cabinet file is present and
 *        readable, or the cabinet file has been damaged, pfdin->fdie will
 *        receive other appropriate error codes:
 *
 *              FDIERROR_CABINET_NOT_FOUND
 *              FDIERROR_NOT_A_CABINET
 *              FDIERROR_UNKNOWN_CABINET_VERSION
 *              FDIERROR_CORRUPT_CABINET
 *              FDIERROR_BAD_COMPR_TYPE
 *              FDIERROR_RESERVE_MISMATCH
 *              FDIERROR_WRONG_CABINET
 *
 *      Entry:
 *          pfdin->psz1 = name of next cabinet where current file is continued
 *          pfdin->psz2 = name of next disk where current file is continued
 *          pfdin->psz3 = cabinet path name; FDI concatenates psz3 with psz1
 *                          to produce the fully-qualified path for the cabinet
 *                          file.  The 256-byte buffer pointed at by psz3 may
 *                          be modified, but psz1 may not!
 *          pfdin->fdie = FDIERROR_WRONG_CABINET if the previous call to
 *                        fdintNEXT_CABINET specified a cabinet file that
 *                        did not match the setID/iCabinet that was expected.
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is almost always made when a target file is open and
 *          being written to, and the next cabinet is needed to get more
 *          data for the file.
 */
typedef enum {
    fdintCABINET_INFO,              // General information about cabinet
    fdintPARTIAL_FILE,              // First file in cabinet is continuation
    fdintCOPY_FILE,                 // File to be copied
    fdintCLOSE_FILE_INFO,           // close the file, set relevant info
    fdintNEXT_CABINET,              // File continued to next cabinet
    fdintENUMERATE,                 // Enumeration status
} FDINOTIFICATIONTYPE; /* fdint */

typedef int (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint,
                                           PFDINOTIFICATION    pfdin); /* pfnfdin */

#define FNFDINOTIFY(fn) int FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \
                                              PFDINOTIFICATION    pfdin)


/*** cpuType values for FDICreate()
 *
 *  (Ignored by 32-bit FDI.)
 */
#define     cpuUNKNOWN         (-1)    /* FDI does detection */
#define     cpu80286           (0)     /* '286 opcodes only */
#define     cpu80386           (1)     /* '386 opcodes used */


/***    FDICreate - Create an FDI context
 *
 *  Entry:
 *      pfnalloc
 *      pfnfree
 *      pfnopen
 *      pfnread
 *      pfnwrite
 *      pfnclose
 *      pfnlseek
 *      cpuType  - Select CPU type (auto-detect, 286, or 386+)
 *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored!
 *      perf
 *
 *  Exit-Success:
 *      Returns non-NULL FDI context handle.
 *
 *  Exit-Failure:
 *      Returns NULL; perf filled in with error code
 *
 */
HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf);


/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is
 *
 *  Entry:
 *      hfdi   - Handle to FDI context (created by FDICreate())
 *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned
 *               at offset 0 in the file to test.
 *      pfdici - Buffer to receive info about cabinet if it is one.
 *
 *  Exit-Success:
 *      Returns TRUE; file is a cabinet, pfdici filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE, file is not a cabinet;  If an error occurred,
 *          perf (passed on FDICreate call!) filled in with error.
 */
BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 int             hf,
                                 PFDICABINETINFO pfdici);


/***    FDICopy - extracts files from a cabinet
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - main name of cabinet file
 *      pszCabPath  - Path to cabinet file(s)
 *      flags       - Flags to modify behavior
 *      pfnfdin     - Notification function
 *      pfnfdid     - Decryption function (pass NULL if not used)
 *      pvUser      - User specified value to pass to notification function
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE, perf (passed on FDICreate call!) filled in with
 *          error.
 *
 *  Notes:
 *  (1) If FDICopy() fails while a target file is being written out, then
 *      FDI will use the PFNCLOSE function to close the file handle for that
 *      target file that was returned from the fdintCOPY_FILE notification.
 *      The client application is then free to delete the target file, since
 *      it will not be in a valid state (since there was an error while
 *      writing it out).
 */
BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            CHAR FAR     *pszCabinet,
                            CHAR FAR     *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void FAR     *pvUser);


/***    FDIDestroy - Destroy an FDI context
 *
 *  Entry:
 *      hfdi - handle to FDI context (created by FDICreate())
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;
 */
BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_FDI

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\pch.hpp ===
#include <windows.h> 
#include <shellapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <wtypes.h>

#include "boyer.h"
#include "mydefs.h"

#include "download.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\download.cpp ===
/*****************************************************************************\

    MAIN.CPP

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

\*****************************************************************************/

#include    <windows.h>
#include    "pch.hpp"
#include    <stdio.h>
#include    <stdlib.h>
#include    <stdarg.h>
#include    <shellapi.h>
#include    <shlobj.h>
#include    <intshcut.h>
#include    <wininet.h>
//#include    "icwdl.h"
#include    "msobdl.h"

// 12/4/96 jmazner    Normandy #12193
// path to icwconn1.exe registry key from HKEY_LOCAL_MACHINE
#define ICWCONN1PATHKEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CONNWIZ.EXE"
#define PATHKEYNAME     "Path"

#include <winreg.h>

// Cabbing up.
extern HRESULT HandleCab(LPSTR pszPath);
extern void CleanupCabHandler();

// all global data is static shared, read-only
// (written only during DLL-load)
HANDLE      g_hDLLHeap;        // private Win32 heap
HINSTANCE   g_hInst;        // our DLL hInstance

HWND        g_hWndMain;        // hwnd of icwconn1 parent window


#define DllExport extern "C" __declspec(dllexport)

#define MAX_RES_LEN         255 // max length of string resources

#define SMALL_BUF_LEN       48  // convenient size for small text buffers


LPSTR LoadSz(UINT idString, LPSTR lpszBuf,UINT cbBuf);


///////////////////////////////////////////////////////////
// DLL module information
//
/*
BOOL APIENTRY DllMain(HANDLE hModule, 
                             DWORD dwReason, 
                             void* lpReserved )
{
    return TRUE;
}*/

#if     0
// MSOBDL is not currently a COM object so there is no need to implement these.
//
//////////////////////////////////////////////////////////
// DllCanUnloadNow
//
STDAPI DllCanUnloadNow()
{
    return S_OK ;
}

//////////////////////////////////////////////////////////
// Server Registration
//
STDAPI DllRegisterServer()
{
    return S_OK ;
}


//////////////////////////////////////////////////////////
// Unregistration
//
STDAPI DllUnregisterServer()
{
    return S_OK ;
}
#endif  //  0



LPSTR LoadSz(UINT idString, LPSTR lpszBuf,UINT cbBuf);

//+---------------------------------------------------------------------------
//
//  Function:   MyGetTempPath()
//
//  Synopsis:   Gets the path to temporary directory
//                - Use GetTempFileName to get a file name
//                  and strips off the filename portion to get the temp path
//
//  Arguments:  [uiLength - Length of buffer to contain the temp path]
//                [szPath      - Buffer in which temp path will be returned]
//
//    Returns:    Length of temp path if successful
//                0 otherwise
//
//  History:    7/6/96     VetriV    Created
//                8/23/96        VetriV        Delete the temp file
//                12/4/96        jmazner     Modified to serve as a wrapper of sorts;
//                                     if TMP or TEMP don't exist, setEnv our own
//                                     vars that point to conn1's installed path
//                                     (Normandy #12193)
//
//----------------------------------------------------------------------------
DWORD MyGetTempPath(UINT uiLength, LPSTR szPath)
{
    CHAR szEnvVarName[SMALL_BUF_LEN + 1] = "\0unitialized szEnvVarName\0";
    DWORD dwFileAttr = 0;

    lstrcpynA( szPath, "\0unitialized szPath\0", 20 );

    // is the TMP variable set?
    LoadSz(IDS_TMPVAR, szEnvVarName,sizeof(szEnvVarName));
    if( GetEnvironmentVariableA( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributesA(szPath);
        // if there was any error, this directory isn't valid.
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlenA(szPath) );
            }
        }
    }

    lstrcpynA( szEnvVarName, "\0unitialized again\0", 19 );

    // if not, is the TEMP variable set?
    LoadSz(IDS_TEMPVAR, szEnvVarName,sizeof(szEnvVarName));
    if( GetEnvironmentVariableA( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributesA(szPath);
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlenA(szPath) );
            }
        }
    }

    // neither one is set, so let's use the path to the installed icwconn1.exe
    // from the registry  SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN1.EXE\Path
    HKEY hkey = NULL;

    if ((RegOpenKeyExA(HKEY_LOCAL_MACHINE, ICWCONN1PATHKEY, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
        RegQueryValueExA(hkey, PATHKEYNAME, NULL, NULL, (BYTE *)szPath, (DWORD *)&uiLength);
    if (hkey)
    {
        RegCloseKey(hkey);
    }

    //The path variable is supposed to have a semicolon at the end of it.
    // if it's there, remove it.
    if( ';' == szPath[uiLength - 2] )
        szPath[uiLength - 2] = '\0';

    // go ahead and set the TEMP variable for future reference
    // (only effects currently running process)
    if( szEnvVarName[0] )
    {
        SetEnvironmentVariableA( szEnvVarName, szPath );
    }
    else
    {
        lstrcpynA( szPath, "\0unitialized again\0", 19 );
        return( 0 );
    }

    return( uiLength );
}


extern "C" BOOL _stdcall DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lbv)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // Need to use OLE/Com later
        if (FAILED(CoInitialize(NULL)))
            return(FALSE);

        //
        // ChrisK Olympus 6373 6/13/97
        // Disable thread attach calls in order to avoid race condition
        // on Win95 golden
        //
        DisableThreadLibraryCalls(hInstance);
        g_hInst = hInstance;
        g_hDLLHeap = HeapCreate(0, 0, 0);
        MyAssert(g_hDLLHeap);
        if (g_hDLLHeap == NULL)
            return FALSE;
        break;

    case DLL_PROCESS_DETACH:
        CoUninitialize();
        HeapDestroy(g_hDLLHeap);

        // Cleanup the cabbing stuff.
        CleanupCabHandler();
        break;
    }
    return TRUE;
}


LPSTR MyStrDup(LPSTR pszIn)
{
    int len;
    LPSTR pszOut;

    MyAssert(pszIn);
    len = lstrlenA(pszIn);
    if(!(pszOut = (LPSTR)MyAlloc((len+1) * sizeof(CHAR))))
    {
        MyAssert(FALSE);
        return NULL;
    }
    lstrcpyA(pszOut, pszIn);
    pszOut[len] = 0;

    return pszOut;
}

int MyAssertProc(LPSTR pszFile, int nLine, LPSTR pszExpr)
{
    CHAR szBuf[512];

    wsprintfA(szBuf, "Assert failed at line %d in file %s. (%s)\r\n", nLine, pszFile, pszExpr);
    MyDbgSz((szBuf));
    return 0;
}

void _cdecl MyDprintf(LPCSTR pcsz, ...)
{
    va_list    argp;
    CHAR szBuf[1024];

    if ((NULL == pcsz) || ('\0' == pcsz[0]))
        return;

    va_start(argp, pcsz);

    wvsprintfA(szBuf, pcsz, argp);

    MyDbgSz((szBuf));
    va_end(argp);
} // Dprintf()


// ############################################################################
//  operator new
//
//  This function allocate memory for C++ classes
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
void * MyBaseClass::operator new( size_t cb )
{
    return MyAlloc(cb);
}

// ############################################################################
//  operator delete
//
//  This function frees memory for C++ classes
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
void MyBaseClass::operator delete( void * p )
{
    MyFree( p );
}

void CDownLoad::AddToFileList(CFileInfo* pfi)
{
    CFileInfo **ppfi;

    // must add at tail
    for(ppfi=&m_pfiHead; *ppfi; ppfi = &((*ppfi)->m_pfiNext))
        ;
    *ppfi = pfi;
}


CDownLoad::CDownLoad(LPSTR psz)
{
    CHAR           szUserAgent[128];
    OSVERSIONINFO   osVer;
    LPSTR          pszOS = "";

    memset(this, 0, sizeof(CDownLoad));

    if(psz)
        m_pszURL = MyStrDup(psz);

    memset(&osVer, 0, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);
    GetVersionEx(&osVer);

    switch(osVer.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:
            pszOS = "Windows95";
            break;
        case VER_PLATFORM_WIN32_NT:
            pszOS = "WindowsNT";
            break;
    }

    wsprintfA(szUserAgent, USERAGENT_FMT, pszOS, osVer.dwMajorVersion,
                osVer.dwMinorVersion, GetSystemDefaultLangID());

    m_hSession = InternetOpenA(szUserAgent, 0, NULL, NULL, 0);

    CHAR szBuf[MAX_PATH+1];

    if (GetWindowsDirectoryA(szBuf, MAX_PATH) == 0)
    {
        szBuf[MAX_PATH] = 0;
        m_pszWindowsDir = MyStrDup(szBuf);
        m_dwWindowsDirLen = lstrlenA(m_pszWindowsDir);
    }

    GetSystemDirectoryA(szBuf, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    m_pszSystemDir = MyStrDup(szBuf);
    m_dwSystemDirLen = lstrlenA(m_pszSystemDir);

    MyGetTempPath(MAX_PATH, szBuf);
    szBuf[MAX_PATH] = 0;
    m_pszTempDir = MyStrDup(szBuf);
    if (m_pszTempDir != NULL)
    {
        m_dwTempDirLen = lstrlenA(m_pszTempDir);
        if(m_dwTempDirLen > 0 && m_pszTempDir[m_dwTempDirLen-1]=='\\')
        {
            m_pszTempDir[m_dwTempDirLen-1]=0;
            m_dwTempDirLen--;
        }
    }

    // form the ICW98 dir.  It is basically the CWD
    m_dwICW98DirLen = 0;
    m_pszICW98Dir = (LPSTR)MyAlloc((MAX_PATH +1) * sizeof(CHAR));
    if (m_pszICW98Dir != NULL)
    {
        if (0 < GetSystemDirectoryA(m_pszICW98Dir, MAX_PATH))
        {
		    lstrcatA(m_pszICW98Dir, "\\OOBE");
        }
        m_dwICW98DirLen = lstrlenA(m_pszICW98Dir);
    }

    LPSTR pszCmdLine = GetCommandLineA();
    LPSTR pszTemp = NULL, pszTemp2 = NULL;

    lstrcpynA(szBuf, pszCmdLine, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    pszTemp = strtok(szBuf, " \t\r\n");
    if (NULL != pszTemp)
    {
        pszTemp2 = strchr(pszTemp, TEXT('\\'));
        if(!pszTemp2)
            pszTemp2 = strrchr(pszTemp, TEXT('/'));
    }
    if(pszTemp2)
    {
        *pszTemp2 = 0;
        m_pszSignupDir = MyStrDup(pszTemp);
    }
    else
    {
        MyAssert(FALSE);
        GetCurrentDirectoryA(MAX_PATH, szBuf);
        szBuf[MAX_PATH] = 0;
        m_pszSignupDir = MyStrDup(szBuf);
    }
    m_dwSignupDirLen = lstrlenA(m_pszSignupDir);

    m_dwReadLength = 0;
    
}

CDownLoad::~CDownLoad(void)
{
    MyDprintf("ICWDL: CDownLoad::~CDownLoad called\n", this);

    CFileInfo *pfi, *pfiNext;
    for(pfi=m_pfiHead; pfi; pfi=pfiNext)
    {
        pfiNext = pfi->m_pfiNext;
        delete pfi;
    }

    if(m_pszWindowsDir)
        MyFree(m_pszWindowsDir);
    if(m_pszSystemDir)
        MyFree(m_pszSystemDir);
    if(m_pszTempDir)
        MyFree(m_pszTempDir);
    if(m_pszICW98Dir)
        MyFree(m_pszICW98Dir);
    if(m_pszSignupDir)
        MyFree(m_pszSignupDir);
    if(m_pszURL)
        MyFree(m_pszURL);
    if(m_pszBoundary)
        MyFree(m_pszBoundary);
    if(m_hSession)
        InternetSessionCloseHandle(m_hSession);
    MyAssert(!m_hRequest);

    //
    // 5/23/97 jmazner Olympus #4652
    // Make sure that any waiting threads are freed up.
    //
    if( m_hCancelSemaphore )
    {
        ReleaseSemaphore( m_hCancelSemaphore, 1, NULL );

        CloseHandle( m_hCancelSemaphore );
        m_hCancelSemaphore = NULL;
    }
}

// perform a file name substitution
LPSTR CDownLoad::FileToPath(LPSTR pszFile)
{
    CHAR szBuf[MAX_PATH+1];

    for(long j=0; *pszFile; pszFile++)
    {
        if(j>=MAX_PATH)
            return NULL;
        if(*pszFile=='%')
        {
            pszFile++;
            LPSTR pszTemp = strchr(pszFile, '%');
            if(!pszTemp)
                return NULL;
            *pszTemp = 0;
            if(lstrcmpiA(pszFile, SIGNUP)==0)
            {
                lstrcpyA(szBuf+j, m_pszSignupDir);
                j+= m_dwSignupDirLen;
            }
            else if(lstrcmpiA(pszFile, WINDOWS)==0)
            {
                lstrcpyA(szBuf+j, m_pszWindowsDir);
                j+= m_dwWindowsDirLen;
            }
            else if(lstrcmpiA(pszFile, SYSTEM)==0)
            {
                lstrcpyA(szBuf+j, m_pszSystemDir);
                j+= m_dwSystemDirLen;
            }
            else if(lstrcmpiA(pszFile, TEMP)==0)
            {
                lstrcpyA(szBuf+j, m_pszTempDir);
                j+= m_dwTempDirLen;
            }
            else if(lstrcmpiA(pszFile, ICW98DIR)==0 && m_pszICW98Dir != NULL)
            {
                lstrcpyA(szBuf+j, m_pszICW98Dir);
                j+= m_dwICW98DirLen;
            }
            else
                return NULL;
            pszFile=pszTemp;
        }
        else
            szBuf[j++] = *pszFile;
    }
    szBuf[j] = 0;
    return MyStrDup(szBuf);
}

// Chops input up into CRLF-delimited chunks
// Modifies input
LPSTR GetNextLine(LPSTR pszIn)
{
    LPSTR pszNext;
    while(*pszIn)
    {
        pszNext = strchr(pszIn, '\r');

        if(!pszNext)
            return NULL;
        else if(pszNext[1]=='\n')
        {
            pszNext[0] = pszNext[1] = 0;
            return pszNext+2;
        }
        else
            pszIn = pszNext+1;
    }
    return NULL;
}

// Modifies input. Output is *in-place*
LPSTR FindHeaderParam(LPSTR pszIn, LPSTR pszLook)
{
    LPSTR pszEnd = pszIn + lstrlenA(pszIn);
    BOOL fFound = FALSE;
    LPSTR pszToken = NULL;

    while(pszIn<pszEnd)
    {
        pszToken=strtok(pszIn, " \t;=");
        if(fFound || !pszToken)
            break;

        pszIn = pszToken+lstrlenA(pszToken)+1;

        if(lstrcmpiA(pszToken, pszLook)==0)
            fFound = TRUE;
    }
    if(fFound && pszToken)
    {
        if(pszToken[0]=='"')
            pszToken++;
        int iLen = lstrlenA(pszToken);
        if(pszToken[iLen-1]=='"')
            pszToken[iLen-1]=0;
        return pszToken;
    }
    return NULL;
}

// Modifies input!!
LPSTR ParseHeaders(LPSTR pszIn, LPSTR* ppszBoundary, LPSTR* ppszFilename, BOOL* pfInline)
{
    LPSTR pszNext=NULL, pszCurr=NULL, pszToken=NULL, pszToken2=NULL, pszTemp=NULL;
    // int iLen;    ChrisK

    if(pfInline)     *pfInline = FALSE;
    if(ppszFilename) *ppszFilename = NULL;
    if(ppszBoundary) *ppszBoundary = NULL;

    for(pszCurr=pszIn; pszCurr; pszCurr=pszNext)
    {
        // terminate current line with null & get ptr to next
        pszNext = GetNextLine(pszCurr);

        // if we have a blank line, done with headers--exit loop
        if(*pszCurr==0)
        {
            pszCurr = pszNext;
            break;
        }

        if(!(pszToken = strtok(pszCurr, " \t:;")))
            continue;
        pszCurr = pszToken+lstrlenA(pszToken)+1;

        if(lstrcmpiA(pszToken, MULTIPART_MIXED)==0)
        {
            if(ppszBoundary)
            {
                pszTemp = FindHeaderParam(pszCurr, BOUNDARY);
                if(pszTemp)
                {
                    int iLen = lstrlenA(pszTemp);
                    *ppszBoundary = (LPSTR)MyAlloc((iLen+2+1) * sizeof(CHAR));
                    if (*ppszBoundary != NULL)
                    {
                        (*ppszBoundary)[0] = (*ppszBoundary)[1] = '-';
                        lstrcpyA(*ppszBoundary+2, pszTemp);
                    }
                }
            }
        }
        else if(lstrcmpiA(pszToken, CONTENT_DISPOSITION)==0)
        {
            if(!(pszToken2 = strtok(pszCurr, " \t:;")))
                continue;
            pszCurr = pszToken2+lstrlenA(pszToken2)+1;

            if(lstrcmpiA(pszToken2, INLINE)==0)
            {
                if(pfInline)
                    *pfInline = TRUE;
            }
            else if(lstrcmpiA(pszToken2, ATTACHMENT)!=0)
                continue;

            if(ppszFilename)
            {
                pszTemp = FindHeaderParam(pszCurr, FILENAME);
                if(pszTemp)
                    *ppszFilename = MyStrDup(pszTemp);
            }
        }
    }
    return pszCurr;
}

BOOL g_ForceOnlineAttempted = FALSE;

HRESULT CDownLoad::Execute(void)
{
    CHAR    szBuf[256];
    DWORD    dwLen;
    HRESULT hr = ERROR_GEN_FAILURE;

    if(!m_hSession || !m_pszURL)
        return ERROR_INVALID_PARAMETER;

    m_hRequest = InternetOpenUrlA(m_hSession, m_pszURL, NULL, 0,
                (INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE), (DWORD_PTR)this);

    if(!m_hRequest)
    {
        if (!m_hSession)
            return GetLastError();
        else
        {
            HRESULT hRes = InternetGetLastError(m_hSession);

            if (hRes == INTERNET_STATE_DISCONNECTED)
            {
                DWORD dwConnectedFlags = 0;

                InternetGetConnectedStateEx(&dwConnectedFlags,
                                             NULL,
                                             0,
                                             0);

                if(dwConnectedFlags & INTERNET_CONNECTION_OFFLINE)
                {
                    if(g_ForceOnlineAttempted)
                    {
                        g_ForceOnlineAttempted = FALSE;
                        hRes = INTERNET_CONNECTION_OFFLINE;
                    }
                    else
                    {
                        //ack! the user is offline. not good. let's put them back online.
                        INTERNET_CONNECTED_INFO ci;

                        memset(&ci, 0, sizeof(ci));
                        ci.dwConnectedState = INTERNET_STATE_CONNECTED;

                        InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

                        g_ForceOnlineAttempted = TRUE;

                        //now that we've reset the state let's recurse the call.
                        //if we fail again, then we'll tell the user they need
                        //to disable the Offline themseleve
                        return Execute();
                    }
                }

            }
            return hRes;
        }
    }

    dwLen = sizeof(szBuf);
    if(HttpQueryInfoA(m_hRequest, HTTP_QUERY_CONTENT_LENGTH, szBuf, &dwLen, NULL))
    {
        m_dwContentLength = atol(szBuf);
    }
    else
    {
        m_dwContentLength = 0;
    }


    dwLen = sizeof(szBuf);
    if(HttpQueryInfoA(m_hRequest, HTTP_QUERY_CONTENT_TYPE, szBuf, &dwLen, NULL))
    {
        ParseHeaders(szBuf, &m_pszBoundary, NULL, NULL);
        if(m_pszBoundary)
            m_dwBoundaryLen = lstrlenA(m_pszBoundary);
        else
            goto ExecuteExit; // Chrisk, you have to clean up before exiting

        hr = ProcessRequest();
    }

ExecuteExit:
    if (m_hRequest)
        InternetRequestCloseHandle(m_hRequest);
    m_hRequest = NULL;
    return hr;
}



//+----------------------------------------------------------------------------
//
//    Function:    ShowProgress
//
//    Synopsis:    update running total & call progress callback
//
//    Arguments:    dwRead - additional number of bytes read
//
//    Returns:    none
//
//    History:            ArulM    Created
//                8/896    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
void CDownLoad::ShowProgress(DWORD dwRead)
{
    int    prc;

    m_dwReadLength += dwRead;    // running total bytes read
    MyAssert(m_dwReadLength <= m_dwContentLength);

    if (m_lpfnCB)
    {
        if (m_dwContentLength)
        {
            prc = (int)((DWORD)100 * m_dwReadLength / m_dwContentLength);
        }
        else
        {
            prc = 0;
        }
        //
        // 5/27/97 jmazner Olympus #4579
        // need to pass in a valid pointer to a CDialingDlg!
        //
        (m_lpfnCB)(m_hRequest, m_lpCDialingDlg,CALLBACK_TYPE_PROGRESS,(LPVOID)&prc,sizeof(prc));
    }
}

//+----------------------------------------------------------------------------
//
//    Function:    FillBuffer
//
//    Synopsis:    takes a buffer that is partially-filled and reads until it is
//                full or until we've reached the end.
//
//    Arguments:    Buffer pointer, buffer size, count of valid data bytes
//
//    Returns:    total number of bytes in buf
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
DWORD CDownLoad::FillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwRead)
{
    DWORD dwTemp;

    while(dwRead < dwLen)
    {
        dwTemp = 0;
        if(!InternetReadFile(m_hRequest, pbBuf+dwRead, (dwLen-dwRead), &dwTemp))
            break;
        if(!dwTemp)
            break;

        ShowProgress(dwTemp);
        dwRead += dwTemp;
    }
    if(dwLen-dwRead)
        memset(pbBuf+dwRead, 0, (size_t)(dwLen-dwRead));
    return dwRead;
}



//+----------------------------------------------------------------------------
//
//    Function:    MoveAndFillBuffer
//
//    Synopsis:    move remaining contents of buffer from middle of buffer back to
//                the beginning & refill buffer.
//
//    Arguements:    Buffer pointer, Buffer size, count of *total* valid data bytes
//                Pointer to start of data to be moved (everything before is nuked)
//
//    Returns:    total number of bytes in buffer
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
DWORD CDownLoad::MoveAndFillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwValid, LPBYTE pbNewStart)
{
    MyAssert(pbNewStart >= pbBuf);
    MyAssert(pbBuf+dwValid >= pbNewStart);

    dwValid -= (DWORD)(pbNewStart-pbBuf);
    if(dwValid)
        memmove(pbBuf, pbNewStart, (size_t)dwValid);

    return FillBuffer(pbBuf, dwLen, dwValid);
}


//+----------------------------------------------------------------------------
//
//    Function:    HandlwDLFile
//
//    Synopsis:    Handle filename:
//                    (1) get full path after macro substituition. (2) Free
//                    pszFile string.
//                    (3) save the file path & inline/attach info internally for
//                    later handling
//                    (4) Create file on disk & return HANDLE
//
//    Aruguments:    pszFile - filename
//                fInLine - value of inline/attached header from the MIME mutli-part
//
//    Returns:    phFile - handle of file created
//                return - ERROR_SUCCESS == success
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
HRESULT CDownLoad::HandleDLFile(LPSTR pszFile, BOOL fInline, LPHANDLE phFile)
{
    CHAR szdrive[_MAX_DRIVE];
    CHAR szPathName[_MAX_PATH];     // This will be the dir we need to create
    CHAR szdir[_MAX_DIR];
    CHAR szfname[_MAX_FNAME];
    CHAR szext[_MAX_EXT];

    MyAssert(phFile);
    *phFile = INVALID_HANDLE_VALUE;

    LPSTR pszPath = FileToPath(pszFile);
    MyFree(pszFile);

    if(!pszPath)
        return ERROR_INVALID_DATA;


    // Split the provided path to get at the drive and path portion
    _splitpath( pszPath, szdrive, szdir, szfname, szext );
    wsprintfA (szPathName, "%s%s", szdrive, szdir);

    // Create the Directory
    CreateDirectoryA(szPathName, NULL);

    // create the file
    *phFile = CreateFileA(pszPath,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
    if(*phFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    CFileInfo* pfi = new CFileInfo(pszPath, fInline);
    if(!pfi)
        return GetLastError();
    AddToFileList(pfi);

    return ERROR_SUCCESS;
}


/*******************************************************************
*
*  NAME:    LoadSz
*
*  SYNOPSIS:  Loads specified string resource into buffer
*
*  EXIT:    returns a pointer to the passed-in buffer
*
*  NOTES:    If this function fails (most likely due to low
*        memory), the returned buffer will have a leading NULL
*        so it is generally safe to use this without checking for
*        failure.
*
********************************************************************/
LPSTR LoadSz(UINT idString, LPSTR lpszBuf,UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadStringA( g_hInst, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

HRESULT CDownLoad::ProcessRequest(void)
{
    LPBYTE  pbData = NULL, pBoundary = NULL;
    DWORD   dwLen = 0;
    HFIND   hFindBoundary = NULL;
    LPSTR   pszDLFileName = NULL;
    HANDLE  hOutFile = INVALID_HANDLE_VALUE;
    HRESULT hr = E_FAIL;

    MyAssert(m_hRequest && m_pszBoundary);
    MyAssert(m_pszBoundary[0]=='\r' && m_pszBoundary[1]=='\n');
    MyAssert(m_pszBoundary[2]=='-' && m_pszBoundary[3]=='-');
    // Buf Size must be greater than larget possible block of headers
    // also must be greater than the OVERLAP, which must be greater
    // than max size of MIME part boundary (70?)
    MyAssert(DEFAULT_DATABUF_SIZE > OVERLAP_LEN);
    MyAssert(OVERLAP_LEN > 80);

    // init buffer & find-pattern
    if(! (pbData = (LPBYTE)MyAlloc(DEFAULT_DATABUF_SIZE+SLOP)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    hFindBoundary = SetFindPattern(m_pszBoundary);
    
    // find first boundary. If not in first blob, we have too much
    // white-space. Discard & try again (everything before the first
    // boundary is discardable)
    for(pBoundary=NULL; !pBoundary; )
    {
        if(!(dwLen = FillBuffer(pbData, DEFAULT_DATABUF_SIZE, 0)))
            goto iNetError;
        pBoundary = (LPBYTE)Find(hFindBoundary, (LPSTR)pbData, dwLen);
    }

    for(;;)
    {
        MyAssert(pBoundary && pbData && dwLen);
        MyAssert(pBoundary>=pbData && (pBoundary+m_dwBoundaryLen)<=(pbData+dwLen));

        // move remaining data to front of buffer & refill.
        if(!(dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pBoundary+m_dwBoundaryLen)))
            goto iNetError;
        pBoundary = NULL;

        // look for trailing -- after boundary to indicate end of last part
        if(pbData[0]=='-' && pbData[1]=='-')
            break;

        // skip leading CRLF (alway one after boundary)
        MyAssert(pbData[0]=='\r' && pbData[1]=='\n');

        // reads headers and skips everything until doubleCRLF. assumes all
        // headers fit in the single buffer. Pass in pbData+2 to skip
        // leading CRLF. Return value is ptr to first byte past the dbl crlf
        LPSTR pszFile = NULL;
        BOOL fInline = FALSE;

        LPBYTE pbNext = (LPBYTE)ParseHeaders((LPSTR)pbData+2, NULL, &pszFile, &fInline);

         if(!pszFile || !pbNext)
         {
             hr = ERROR_INVALID_DATA;
             goto error;
         }

        //
        // Make a copy of the file name - will be used
        // for displaying error message
        //
        pszDLFileName = (LPSTR) MyAlloc((lstrlenA(pszFile) + 1) * sizeof(CHAR));
        lstrcpyA(pszDLFileName, pszFile);


        // Handle filename: (1) get full path after macro substituition.
        // (2) Free pszFile string. (3) save the file path & inline/attach info
        // internally for later handling (4) Create file on disk &return HANDLE
        if(hr = HandleDLFile(pszFile, fInline, &hOutFile))
            goto error;

        // move remaining data (after headers) to front of buffer & refill.
        dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pbNext);
        pBoundary = NULL;

        MyAssert(dwLen);
        while(dwLen)
        {
            DWORD dwWriteLen = 0;
            DWORD dwTemp = 0;

            // look for boundary. careful of boundary cut across
            // blocks. Overlapping blocks by 100 bytes to cover this case.
            if(pBoundary = (LPBYTE)Find(hFindBoundary, (LPSTR)pbData, dwLen))
                dwWriteLen = (DWORD)(pBoundary - pbData);
            else if(dwLen > OVERLAP_LEN)
                dwWriteLen = dwLen-OVERLAP_LEN;
            else
                dwWriteLen = dwLen;

            MyAssert(dwWriteLen <= dwLen);
            MyAssert(hOutFile != INVALID_HANDLE_VALUE);

            if(dwWriteLen)
            {
                dwTemp = 0;
                if(!WriteFile(hOutFile, pbData, dwWriteLen, &dwTemp, NULL)
                    || dwTemp!=dwWriteLen)
                {
                    hr = GetLastError();
                    //
                    // If we are out of diskspace, get the drive letter
                    // and display an out of diskspace message
                    //
                    goto error;
                }

            }

            if(pBoundary)
                break;

            // move remaining data (after last byte written) to front of buffer & refill
            dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pbData+dwWriteLen);
        }

        // *truncate* file & close
        MyAssert(hOutFile != INVALID_HANDLE_VALUE);
        SetEndOfFile(hOutFile);

        // close file
        CloseHandle(hOutFile);
        hOutFile = INVALID_HANDLE_VALUE;
        if (NULL != pszDLFileName)
        {
            MyFree(pszDLFileName);
            pszDLFileName = NULL;
        }

        if(!pBoundary)
        {
            MyAssert(dwLen==0); // can only get here on dwLen==0 or found boundary
            goto iNetError;
        }
        // at start of loop we'll discard everything upto and including the boundary
        // if we loop back with pBoundary==NULL, we'll GPF
    }
    return ERROR_SUCCESS;

iNetError:
    hr = InternetGetLastError(m_hSession);
    if(!hr)
        hr = ERROR_INVALID_DATA;
    // goto error;
    // fall through

error:
    if(pbData) MyFree(pbData);
    if(hFindBoundary) FreeFindPattern(hFindBoundary);
    if (NULL != pszDLFileName)
    {
        MyFree(pszDLFileName);
        pszDLFileName = NULL;
    }
    if (hOutFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hOutFile);
        hOutFile = INVALID_HANDLE_VALUE;
    }
    return hr;
}


HRESULT HandleExe(LPSTR pszPath, HANDLE hCancelSemaphore)
{
    MyAssert( hCancelSemaphore );

    struct _STARTUPINFOA        si;
    PROCESS_INFORMATION         pi;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    if(!CreateProcessA(pszPath, NULL, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleExe about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleExe done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
         CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return NO_ERROR;
    }
}

HRESULT HandleReg(LPSTR pszPath, HANDLE hCancelSemaphore)
{
    struct _STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    CHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );
    MyAssert( hCancelSemaphore );

    // 11/20/96  jmazner  Normandy #5272
    // Wrap quotes around pszPath in a directory or file name includes a space.

    lstrcpyA(szCmd, REGEDIT_CMD);

    if( '\"' != pszPath[0] )
    {
        // add 2 for two quotes
        MyAssert( (lstrlenA(REGEDIT_CMD) + lstrlenA(pszPath)) < MAX_PATH );

        lstrcatA(szCmd, "\"");
        lstrcatA(szCmd, pszPath);

        int i = lstrlenA(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        MyAssert( (lstrlenA(REGEDIT_CMD) + lstrlenA(pszPath)) < MAX_PATH );

        lstrcatA(szCmd, pszPath);
    }



    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    if(!CreateProcessA(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        // HRESULT hr = (WaitAndKillRegeditWindow(10) ? NO_ERROR : E_FAIL);
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleReg about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleReg done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return ERROR_SUCCESS;
    }
}


HRESULT HandleInf(LPSTR pszPath, HANDLE hCancelSemaphore)
{
    CHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );
    MyAssert( hCancelSemaphore );

    // add 2 for two quotes,
    // subtract 70 for approximate length of string in sprintf
    MyAssert( (lstrlenA(pszPath) - 70 + 2) < MAX_PATH );

    // 11/20/96 jmazner Normandy #5272
    // wrap pszPath in quotes in case it includes a space
    if( '\"' != pszPath[0] )
    {
        wsprintfA(szCmd, "rundll setupx.dll, InstallHinfSection DefaultInstall 128 \"%s", pszPath);
        int i = lstrlenA(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        wsprintfA(szCmd, "rundll setupx.dll, InstallHinfSection DefaultInstall 128 %s", pszPath);
    }


    struct _STARTUPINFOA si;
    PROCESS_INFORMATION pi;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));

    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    if(!CreateProcessA(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleInf about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleInf done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
         CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return NO_ERROR;
    }
}

#define STR_BSTR    0
#define STR_OLESTR  1
#ifdef UNICODE
#define BSTRFROMANSI(x) (BSTR)(x)
#define OLESTRFROMANSI(x) (LPCOLESTR)(x)
#else
#define BSTRFROMANSI(x) (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x) (LPCOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#endif
#define TO_ASCII(x) (CHAR)((unsigned char)x + 0x30)

// Get the URL location from the .URL file, and send it to the progress dude
HRESULT CDownLoad::HandleURL(LPSTR pszPath)
{
    MyAssert( pszPath );

    // Data for CALLBACK_TYPE_URL is a wide string.
    LPWSTR   pszURL;

    // Create a IUniformResourceLocator object
    IUniformResourceLocator * pURL;
    if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IUniformResourceLocator,
                                   (LPVOID*)&pURL)))
    {
        // Get a persist file interface
        IPersistFile *ppf;
        if (SUCCEEDED(pURL->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf)))
        {
            // Attempt to connect the storage of the IURL to the .URL file we
            // downloaded
            if (SUCCEEDED(ppf->Load(OLESTRFROMANSI(pszPath), STGM_READ)))
            {
                // OK, have the URL object give us the location
                if (SUCCEEDED(pURL->GetURL(&pszURL)) && pszURL)
                {
                    // Notify the callback about the URL location
                    (m_lpfnCB)(m_hRequest, m_lpCDialingDlg, CALLBACK_TYPE_URL, (LPVOID)pszURL, lstrlenW(pszURL));

                    // Free the allocated URL, since the callback made a copy of it
                    IMalloc* pMalloc;
                    HRESULT hres = SHGetMalloc(&pMalloc);
                    if (SUCCEEDED(hres))
                    {
                        pMalloc->Free(pszURL);
                        pMalloc->Release();
                    }
                }
            }
            // Release the persist file interface
            ppf->Release();
        }
        // release the URL object
        pURL->Release();
    }
    return(NO_ERROR);
}

#define PHONEBOOK_LIBRARY "ICWPHBK.DLL"
#define PHBK_LOADAPI "PhoneBookLoad"
#define PHBK_MERGEAPI "PhoneBookMergeChanges"
#define PHBK_UNLOADAPI "PhoneBookUnload"
#define PHONEBOOK_SUFFIX ".PHB"

typedef HRESULT (CALLBACK* PFNPHONEBOOKLOAD)(LPCSTR pszISPCode, DWORD *pdwPhoneID);
typedef HRESULT (CALLBACK* PFNPHONEBOOKMERGE)(DWORD dwPhoneID, LPSTR pszFileName);
typedef HRESULT (CALLBACK *PFNPHONEBOOKUNLOAD) (DWORD dwPhoneID);

HRESULT HandleChg(LPSTR pszPath)
{
    CHAR szPhoneBookPath[MAX_PATH+1];
    CHAR *p;
    LPSTR szFilePart;
    HRESULT hr = ERROR_FILE_NOT_FOUND;
    HINSTANCE hPHBKDLL = NULL;
    FARPROC fp;
    DWORD dwPhoneBook;

    lstrcpyA(szPhoneBookPath, pszPath);
    if (lstrlenA(szPhoneBookPath) > 4)
    {
        p = &(szPhoneBookPath[lstrlenA(szPhoneBookPath)-4]);
    } else {
        hr = ERROR_INVALID_PARAMETER;
        goto HandleChgExit;
    }

    lstrcpyA(p, PHONEBOOK_SUFFIX);

    while (*p != '\\' && p > &szPhoneBookPath[0])
        p--;

    p++;
    if(!SearchPathA(NULL, p,NULL,MAX_PATH,szPhoneBookPath,&szFilePart))
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hPHBKDLL = LoadLibraryA(PHONEBOOK_LIBRARY);
    if (!hPHBKDLL)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    fp = GetProcAddress(hPHBKDLL, PHBK_LOADAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hr = ((PFNPHONEBOOKLOAD)fp)(pszPath, &dwPhoneBook);
    if(hr != ERROR_SUCCESS)
        goto HandleChgExit;

    fp = GetProcAddress(hPHBKDLL, PHBK_MERGEAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hr = ((PFNPHONEBOOKMERGE)fp)(dwPhoneBook, pszPath);

    fp = GetProcAddress(hPHBKDLL, PHBK_UNLOADAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    ((PFNPHONEBOOKUNLOAD)fp)(dwPhoneBook);

HandleChgExit:
    return hr;
}


HRESULT HandleOthers(LPSTR pszPath)
{
    DWORD_PTR dwErr;
    CHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );

    // 11/20/96  jmazner  Normandy #5272
    // Wrap quotes around pszPath in case it includes a space.

    // add 2 for two quotes
    MyAssert( (lstrlenA(pszPath) + 2) < MAX_PATH );

    if( '\"' != pszPath[0] )
    {
        lstrcpyA(szCmd, "\"");
        lstrcatA(szCmd, pszPath);

        int i = lstrlenA(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        lstrcpyA(szCmd, pszPath);
    }


    if((dwErr=(DWORD_PTR)ShellExecuteA(NULL, NULL, szCmd, NULL, NULL, SW_SHOWNORMAL)) < 32)
        return (DWORD)dwErr;
    else
        return ERROR_SUCCESS;
}



LPSTR GetExtension(LPSTR pszPath)
{
    LPSTR pszRet = strrchr(pszPath, '.');
    if(pszRet)
        return pszRet+1;
    else
        return NULL;
}

// Normandy 12093 - ChrisK 12/3/96
// return the error code for the first error that occurs while processing a file,
// but don't stop processing files.
//
HRESULT CDownLoad::Process(void)
{
    HRESULT     hr;
    HRESULT     hrProcess = ERROR_SUCCESS;
    LPSTR       pszExt;
    CFileInfo   *pfi;

    for(pfi=m_pfiHead; pfi; pfi=pfi->m_pfiNext)
    {
        // Normandy 12093 - ChrisK 12/3/96
        hr = ERROR_SUCCESS;
        if(pfi->m_fInline)
        {
            pszExt = GetExtension(pfi->m_pszPath);
            if(!pszExt)
                continue;

        	if (lstrcmpiA(pszExt, EXT_CAB)==0)
				hr = HandleCab(pfi->m_pszPath);
            else if(lstrcmpiA(pszExt, EXT_EXE)==0)
                hr = HandleExe(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpiA(pszExt, EXT_REG)==0)
                hr = HandleReg(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpiA(pszExt, EXT_CHG)==0)
                hr = HandleChg(pfi->m_pszPath);
            else if(lstrcmpiA(pszExt, EXT_INF)==0)
                hr = HandleInf(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpiA(pszExt, EXT_URL)==0)
                hr = HandleURL(pfi->m_pszPath);
            else
                hr = HandleOthers(pfi->m_pszPath);

            // Normandy 12093 - ChrisK 12/3/96
            if ((ERROR_SUCCESS == hrProcess) && (ERROR_SUCCESS != hr))
                hrProcess = hr;
        }
    }

    // Normandy 12093 - ChrisK 12/3/96
    return hrProcess;
}


HRESULT CDownLoad::SetStatusCallback (INTERNET_STATUS_CALLBACK lpfnCB)
{
    HRESULT hr;

    hr = ERROR_SUCCESS;
    if (!lpfnCB)
    {
        hr = ERROR_INVALID_PARAMETER;
    } else {
        m_lpfnCB = lpfnCB;
    }
    return hr;
}




#ifdef DEBUG
extern "C" HRESULT WINAPI DLTest(LPSTR pszURL)
{
    CDownLoad* pdl = new CDownLoad(pszURL);
    HRESULT hr = pdl->Execute();
    if(hr) goto done;

    hr = pdl->Process();
done:
    delete pdl;
    return hr;
}
#endif //DEBUG


HRESULT WINAPI DownLoadInit(LPWSTR wszURL, DWORD FAR *lpCDialingDlg, DWORD_PTR FAR *pdwDownLoad, HWND hWndMain)
{
    g_hWndMain = hWndMain;

    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    int _convert;
    LPSTR lpa = NULL;
    CDownLoad* pdl;

    _convert = WideCharToMultiByte(CP_ACP, 0, wszURL, -1, lpa, 0, NULL, NULL);
    if (_convert == 0) goto DownLoadInitExit;

    lpa = new char[_convert];
    if (lpa == NULL) goto DownLoadInitExit;

    if (WideCharToMultiByte(CP_ACP, 0, wszURL, -1, lpa, _convert, NULL, NULL) == 0) goto DownLoadInitExit;

    pdl = new CDownLoad(lpa);
    if (!pdl) goto DownLoadInitExit;

    *pdwDownLoad = (DWORD_PTR)pdl;

    //
    // 5/27/97    jmazner Olympus #4579
    //
    pdl->m_lpCDialingDlg = (DWORD_PTR)lpCDialingDlg;

    hr = ERROR_SUCCESS;

    //
    // 5/23/97    jmazner    Olympus #4652
    // create a semaphore in non-signaled state.  If we ever get a downLoadCancel, we
    // should signal the semaphore, and any waiting threads should notice that and bail out.
    //
    pdl->m_hCancelSemaphore = CreateSemaphoreA( NULL, 0, 1, "ICWDL DownloadCancel Semaphore" );
    if( !pdl->m_hCancelSemaphore || (ERROR_ALREADY_EXISTS == GetLastError()) )
    {
        MyDprintf("ICWDL: Unable to create CancelSemaphore!!\n");
        hr = ERROR_ALREADY_EXISTS;
    }

DownLoadInitExit:
    if (lpa != NULL)
    {
        delete [] lpa;
    }

    return hr;
}

HRESULT WINAPI DownLoadCancel(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadCancel called\n");
    if (dwDownLoad)
    {

        MyDprintf("ICWDL: DownLoadCancel releasing m_hCancelSemaphore\n");
        MyAssert( ((CDownLoad*)dwDownLoad)->m_hCancelSemaphore );
        ReleaseSemaphore( ((CDownLoad*)dwDownLoad)->m_hCancelSemaphore, 1, NULL );

        ((CDownLoad*)dwDownLoad)->Cancel();
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}

HRESULT WINAPI DownLoadExecute(DWORD_PTR dwDownLoad)
{
    if (dwDownLoad)
    {
        return     ((CDownLoad*)dwDownLoad)->Execute();
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}
HRESULT WINAPI DownLoadClose(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadClose called \n");

    if (dwDownLoad)
    {
        // be good and cancel any downloads that are in progress
        ((CDownLoad*)dwDownLoad)->Cancel();

        delete ((CDownLoad*)dwDownLoad);
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}




HRESULT WINAPI DownLoadSetStatusCallback
(
    DWORD_PTR dwDownLoad,
    INTERNET_STATUS_CALLBACK lpfnCB
)
{
    if (dwDownLoad)
    {
        return     ((CDownLoad*)dwDownLoad)->SetStatusCallback(lpfnCB);
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}

HRESULT WINAPI DownLoadProcess(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadProcess\n");
    if (dwDownLoad)
    {
        return ((CDownLoad*)dwDownLoad)->Process();
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobdl\download.h ===
/*----------------------------------------------------------------------------
    download.h
        
        Download handling for Signup

    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
  --------------------------------------------------------------------------*/

  
class MyBaseClass
{
public:
    void * operator new( size_t cb );
    void operator delete( void * p );
};

#include     <wininet.h>

#define InternetSessionCloseHandle(h)        InternetCloseHandle(h)            
#define InternetRequestCloseHandle(h)        InternetCloseHandle(h)
#define InternetGetLastError(h)                GetLastError()
#define InternetCancel(h)                    InternetCloseHandle(h)

extern HANDLE       g_hDLLHeap;        // private Win32 heap
extern HINSTANCE    g_hInst;        // our DLL hInstance

class CFileInfo //: public MyBaseClass
{
public:
    CFileInfo*    m_pfiNext;
    LPSTR        m_pszPath;
    BOOL          m_fInline;
    
    CFileInfo(LPSTR psz, BOOL f) { m_pfiNext = NULL; m_pszPath = psz; m_fInline = f; }
    ~CFileInfo() { if(m_pszPath) MyFree(m_pszPath); }
};

class CDownLoad //: public MyBaseClass
{
    CFileInfo*    m_pfiHead;
    LPSTR        m_pszURL;
    HINTERNET    m_hSession;
    HINTERNET    m_hRequest;
    DWORD        m_dwContentLength;
    DWORD        m_dwReadLength;
    LPSTR       m_pszBoundary;
    DWORD        m_dwBoundaryLen;
    LPSTR       m_pszWindowsDir;
    LPSTR       m_pszSystemDir;
    LPSTR       m_pszTempDir;
    LPSTR       m_pszICW98Dir;
    LPSTR       m_pszSignupDir;
    DWORD        m_dwWindowsDirLen;
    DWORD        m_dwSystemDirLen;
    DWORD        m_dwTempDirLen;
    DWORD        m_dwSignupDirLen;
    DWORD        m_dwICW98DirLen;
    INTERNET_STATUS_CALLBACK m_lpfnCB;
    INTERNET_STATUS_CALLBACK m_lpfnPreviousCB;
    
    void AddToFileList(CFileInfo* pfi);
    LPSTR FileToPath(LPSTR pszFile);
    HRESULT ProcessRequest(void);
    void ShowProgress(DWORD dwRead);
    DWORD FillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwRead);
    DWORD MoveAndFillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwValid, LPBYTE pbNewStart);
#if defined(WIN16)
    HRESULT HandleDLFile(LPSTR pszFile, BOOL fInline, LPHFILE phFile);
#else
    HRESULT HandleDLFile(LPSTR pszFile, BOOL fInline, LPHANDLE phFile);
#endif
    HRESULT HandleURL(LPSTR pszPath);

public:
    CDownLoad(LPSTR psz);
    ~CDownLoad(void);
    HRESULT Execute(void);
    HRESULT Process(void);
    HINTERNET GetSession(void) { return m_hRequest; }
    HANDLE        m_hCancelSemaphore;
    DWORD_PTR        m_lpCDialingDlg;
    HRESULT SetStatusCallback (INTERNET_STATUS_CALLBACK lpfnCB);
    void Cancel() { if(m_hRequest) InternetCancel(m_hRequest); }
};

#define USERAGENT_FMT           "MSSignup/1.1 (%s; %d.%d; Lang=%04x\")"
#define SIGNUP                  "signup"
#define SIGNUP_LEN              (sizeof(SIGNUP)-1)
#define SYSTEM                  "system"
#define SYSTEM_LEN              (sizeof(SYSTEM)-1)
#define WINDOWS                 "windows"
#define WINDOWS_LEN             (sizeof(WINDOWS)-1)
#define TEMP                    "temp"
#define TEMP_LEN                (sizeof(TEMP)-1)
#define ICW98DIR                "icw98dir"
#define ICW98DIR_LEN            (sizeof(ICW98DIR)-1)

#define MULTIPART_MIXED         "multipart/mixed"
#define MULTIPART_MIXED_LEN     (sizeof(MULTIPART_MIXED)-1)
#define CONTENT_DISPOSITION     "content-disposition"
#define CONTENT_DISPOSITION_LEN (sizeof(CONTENT_DISPOSITION)-1)
#define BOUNDARY                "boundary"
#define BOUNDARY_LEN            (sizeof(BOUNDARY)-1)
#define FILENAME                "filename"
#define FILENAME_LEN            (sizeof(FILENAME)-1)
#define INLINE                  "inline"
#define INLINE_LEN              (sizeof(INLINE)-1)
#define ATTACHMENT              "attachment"
#define ATTACHMENT_LEN          (sizeof(ATTACHMENT)-1)

#define DEFAULT_DATABUF_SIZE    4096
#define SLOP                    5
#define OVERLAP_LEN             100

#define DOUBLE_CRLF             "\r\n\r\n"
#define DOUBLE_CRLF_LEN         (sizeof(DOUBLE_CRLF)-1)

#define DIALOGBOXCLASS          "#32770"
#define REGEDIT_CMD             "regedit /s "

#define EXT_EXE                 "exe"
#define EXT_REG                 "reg"
#define EXT_INF                 "inf"
#define EXT_CHG                 "chg"
#define EXT_URL                 "url"

// ICW Version 2.0 stuff.  Ref Server can send cabbed files now,
// this is the extension for it.  We have a cab File Handler which
// blasts open the cab and decompresses the files.
#define EXT_CAB                 "cab"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\api.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  API.H - Header for the implementation of CAPI
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#ifndef _API_H_
#define _API_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>


class CAPI : public IDispatch
{
private:
    ULONG m_cRef;

	HRESULT WrapSHGetSpecialFolderPath(HWND hwndOwner, LPWSTR lpszPath, int nFolder,  BOOL fCreate);
	HRESULT SaveFile(LPCWSTR szPath, LPCWSTR szURL, LPCWSTR szNewFileName);
	HRESULT SaveFile(INT iCSIDLPath, BSTR bstrURL, BSTR bstrNewFileName);
	HRESULT SaveFile(BSTR bstrPath, BSTR bstrURL);
	HRESULT SaveFile(INT iCSIDLPath, BSTR bstrURL);

	HRESULT get_INIKey(BSTR bstrINIFileName, BSTR bstrSectionName, BSTR bstrKeyName, LPVARIANT pvResult);

	HRESULT set_RegValue(HKEY hkey, BSTR bstrSubKey, BSTR bstrValue, LPVARIANT pvData);
	HRESULT get_RegValue(HKEY hkey, BSTR bstrSubKey,
										BSTR bstrValue, LPVARIANT pvResult);
	HRESULT DeleteRegKey(HKEY hkey, BSTR bstrSubKey);
	HRESULT DeleteRegValue(HKEY hkey, BSTR bstrSubKey, BSTR bstrValue);

	HRESULT get_SystemDirectory(LPVARIANT pvResult);
	HRESULT get_CSIDLDirectory(UINT iCSIDLPath, LPVARIANT pvResult);

    HRESULT LoadFile(BSTR bstrPath, LPVARIANT pvResult);

    HRESULT get_UserDefaultLCID(LPVARIANT pvResult);

    HRESULT get_ComputerName(LPVARIANT pvResult);
    HRESULT set_ComputerName(BSTR bstrComputerName);

    HRESULT FlushRegKey(HKEY hkey);
    HRESULT ValidateComputername(BSTR bstrComputername);

    STDMETHOD(OEMComputername)    ();
    STDMETHOD(FormatMessage)    (   LPVARIANT pvResult, // message buffer
                                    BSTR bstrSource,    // message source
                                    int cArgs,          // number of inserts
                                    VARIANTARG *rgArgs  // array of message inserts
                                );

    STDMETHOD(set_ComputerDesc)     (BSTR bstrComputerDesc);
    STDMETHOD(get_UserDefaultUILanguage)    (LPVARIANT pvResult);

public:

	CAPI (HINSTANCE hInstance);
    ~CAPI ();

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\api.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  API.CPP - Header for the implementation of CAPI
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "api.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include "resource.h"
#include <shlobj.h>     // bugbug SHGetFolderPath should be used in the future
#include <shlwapi.h>
#include <util.h>

//
// List of characters that are not legal in netnames.
//
static const WCHAR IllegalNetNameChars[] = L"\"/\\[]:|<>+=;,.?* ";

#define REGSTR_PATH_COMPUTERNAME \
    L"System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"
#define REGSTR_PATH_ACTIVECOMPUTERNAME \
    L"System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
#define REGSTR_PATH_TCPIP_PARAMETERS \
    L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
#define REGSTR_PATH_VOLATILEENVIRONMENT \
    L"VolatileEnvironment"
#define REGSTR_VALUE_HOSTNAME L"Hostname"
#define REGSTR_VALUE_LOGONSERVER L"LOGONSERVER"

DISPATCHLIST APIExternalInterface[] =
{
    {L"SaveFile",                   DISPID_API_SAVEFILE             },
    {L"SaveFileByCSIDL",            DISPID_API_SAVEFILEBYCSIDL      },
    {L"get_INIKey",                 DISPID_API_GET_INIKEY           },
    {L"get_RegValue",               DISPID_API_GET_REGVALUE         },
    {L"set_RegValue",               DISPID_API_SET_REGVALUE         },
    {L"DeleteRegValue",             DISPID_API_DELETEREGVALUE       },
    {L"DeleteRegKey",               DISPID_API_DELETEREGKEY         },
    {L"get_SystemDirectory",        DISPID_API_GET_SYSTEMDIRECTORY  },
    {L"get_CSIDLDirectory",         DISPID_API_GET_CSIDLDIRECTORY   },
    {L"LoadFile",                   DISPID_API_LOADFILE,            },
    {L"get_UserDefaultLCID",        DISPID_API_GET_USERDEFAULTLCID  },
    {L"get_ComputerName",           DISPID_API_GET_COMPUTERNAME     },
    {L"set_ComputerName",           DISPID_API_SET_COMPUTERNAME     },
    {L"FlushRegKey",                DISPID_API_FLUSHREGKEY          },
    {L"ValidateComputername",       DISPID_API_VALIDATECOMPUTERNAME },
    {L"OEMComputername",            DISPID_API_OEMCOMPUTERNAME      },
    {L"FormatMessage",              DISPID_API_FORMATMESSAGE        },
    {L"set_ComputerDesc",           DISPID_API_SET_COMPUTERDESC     },
    {L"get_UserDefaultUILanguage",  DISPID_API_GET_USERDEFAULTUILANGUAGE }
};

/////////////////////////////////////////////////////////////
// CAPI::CAPI
CAPI::CAPI(HINSTANCE hInstance)
{
    m_cRef = 0;
}

/////////////////////////////////////////////////////////////
// CAPI::~CAPI
CAPI::~CAPI()
{
    MYASSERT(m_cRef == 0);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: APILocale
////

HRESULT CAPI::SaveFile(LPCWSTR szPath, LPCWSTR szURL, LPCWSTR szNewFileName)
{
    WCHAR szFilePath[MAX_PATH];

    lstrcpy(szFilePath, szPath);
    lstrcat(szFilePath, szNewFileName);

    return URLDownloadToFile(NULL, szURL, szFilePath, 0, NULL);
}


//SHGetSpecialFolderPath is only available if you have the new shell32.dll that came with IE 4.0
typedef BOOL (WINAPI* PFNSHGetPath)(HWND hwndOwner, LPWSTR lpszPath, int nFolder,  BOOL fCreate);

// bugbug SHGetFolderPath should be used in the future
HRESULT CAPI::WrapSHGetSpecialFolderPath(HWND hwndOwner, LPWSTR lpszPath, int nFolder,  BOOL fCreate)
{
    HRESULT hr = E_NOTIMPL;
    HINSTANCE hShell32 = LoadLibrary(L"SHELL32.DLL");

    if (NULL != hShell32)
    {
        PFNSHGetPath pfnGetPath = (PFNSHGetPath)GetProcAddress(hShell32, "SHGetSpecialFolderPathW");

        if (NULL != pfnGetPath)
        {
            hr = pfnGetPath(hwndOwner, lpszPath, nFolder, fCreate) ? S_OK : E_FAIL;
        }

        FreeLibrary(hShell32);
    }

    return hr;
}


HRESULT CAPI::SaveFile(INT iCSIDLPath, BSTR bstrURL, BSTR bstrNewFileName)
{
    WCHAR szFilePath[MAX_PATH];

    // bugbug should we always create this?
    HRESULT hr = WrapSHGetSpecialFolderPath(NULL, szFilePath, iCSIDLPath, TRUE);

    if (FAILED(hr))
        return (hr);

    lstrcat(szFilePath, L"\\");

    return SaveFile(szFilePath, bstrURL, bstrNewFileName);
}


HRESULT CAPI::SaveFile(BSTR bstrPath, BSTR bstrURL)
{
    WCHAR szURLPath[MAX_PATH];

    lstrcpy(szURLPath, bstrURL);

    LPWSTR pchFileName = wcsrchr(szURLPath, L'/');

    if (NULL != pchFileName)
    {
        *pchFileName++;

        return SaveFile(bstrPath, szURLPath, pchFileName);
    }
    else
        return E_FAIL;
}


HRESULT CAPI::SaveFile(INT iCSIDLPath, BSTR bstrURL)
{
    WCHAR szURLPath[MAX_PATH];
    WCHAR szFilePath[MAX_PATH];

    // bugbug should we always create this?
    HRESULT hr = WrapSHGetSpecialFolderPath(NULL, szFilePath, iCSIDLPath, TRUE);

    if (FAILED(hr))
        return (hr);

    lstrcpy(szURLPath, bstrURL);

    LPWSTR pchFileName = wcsrchr(szURLPath, L'/');

    if (NULL != pchFileName)
    {
        *pchFileName++;

        lstrcat(szFilePath, L"\\");

        return SaveFile(szFilePath, szURLPath, pchFileName);
    }
    else
        return E_FAIL;
}


HRESULT CAPI::get_INIKey(BSTR bstrINIFileName, BSTR bstrSectionName, BSTR bstrKeyName, LPVARIANT pvResult)
{
    WCHAR szItem[1024]; //bugbug bad constants

    VariantInit(pvResult);

    if (GetPrivateProfileString(bstrSectionName, bstrKeyName, L"",
                                    szItem, MAX_CHARS_IN_BUFFER(szItem), bstrINIFileName))
    {
        V_VT(pvResult) = VT_BSTR;
        V_BSTR(pvResult) = SysAllocString(szItem);
        return S_OK;
    }
    else
        return S_FALSE;
}


bool VerifyHKEY(HKEY hkey)
{
    if (HKEY_CLASSES_ROOT == hkey ||
        HKEY_CURRENT_USER == hkey ||
        HKEY_LOCAL_MACHINE == hkey ||
        HKEY_USERS == hkey ||
        HKEY_PERFORMANCE_DATA == hkey ||
        HKEY_CURRENT_CONFIG == hkey ||
        HKEY_DYN_DATA == hkey)
            return true;

    return false;
}

HRESULT CAPI::FlushRegKey(HKEY hkey)
{
    DWORD dwResult;

    dwResult = RegFlushKey(hkey);

    return ERROR_SUCCESS == dwResult ? S_OK : E_FAIL;
}

HRESULT CAPI::set_RegValue(HKEY hkey, BSTR bstrSubKey, BSTR bstrValue, LPVARIANT pvData)
{
    if (!VerifyHKEY(hkey))
        return E_INVALIDARG;

    DWORD dwResult, dwData;

    switch (V_VT(pvData))
    {
     default:
        dwResult = E_FAIL;
        break;

     case VT_R8:
        dwData = (DWORD) V_R8(pvData);
        dwResult = SHSetValue(hkey, bstrSubKey, bstrValue,
                                        REG_DWORD, (LPVOID) &dwData, sizeof(dwData));
        break;

     case VT_I4:
        dwResult = SHSetValue(hkey, bstrSubKey, bstrValue,
                                        REG_DWORD, (LPVOID) &V_I4(pvData), sizeof(V_I4(pvData)));
        break;

     case VT_BSTR:
        dwResult = SHSetValue(hkey, bstrSubKey, bstrValue,
                                        REG_SZ, (LPVOID) (V_BSTR(pvData)), BYTES_REQUIRED_BY_SZ(V_BSTR(pvData)));
        break;
    }

    return ERROR_SUCCESS == dwResult ? S_OK : E_FAIL;
}


HRESULT CAPI::get_RegValue(HKEY hkey, BSTR bstrSubKey,
                                    BSTR bstrValue, LPVARIANT pvResult)
{
    if (!VerifyHKEY(hkey))
        return E_INVALIDARG;

    DWORD dwType = REG_DWORD, cbData = 1024;
    BYTE rgbData[1024]; //  bugbug data size

    HRESULT hr = ERROR_SUCCESS == SHGetValue(hkey, bstrSubKey, bstrValue,
                                    &dwType, (LPVOID) rgbData, &cbData) ? S_OK : E_FAIL;

    VariantInit(pvResult);
    switch (dwType)
    {
     default:
     case REG_DWORD:
        V_VT(pvResult) = VT_I4;
        V_I4(pvResult) = (SUCCEEDED(hr) && cbData >= sizeof(long)) ? * (long *) &rgbData : 0;
        break;

     case REG_SZ:
        V_VT(pvResult) = VT_BSTR;
        V_BSTR(pvResult) = SysAllocString(SUCCEEDED(hr) ? (LPCWSTR) rgbData : L"");
        break;
    }

    return hr;
}


HRESULT CAPI::DeleteRegKey(HKEY hkey, BSTR bstrSubKey)
{
    if (!VerifyHKEY(hkey))
        return E_INVALIDARG;

    return ERROR_SUCCESS == SHDeleteKey(hkey, bstrSubKey) ? S_OK : E_FAIL;
}


HRESULT CAPI::DeleteRegValue(HKEY hkey, BSTR bstrSubKey, BSTR bstrValue)
{
    if (!VerifyHKEY(hkey))
        return E_INVALIDARG;

    return ERROR_SUCCESS == SHDeleteValue(hkey, bstrSubKey, bstrValue) ? S_OK : E_FAIL;
}


HRESULT CAPI::get_SystemDirectory(LPVARIANT pvResult)
{
    WCHAR szSysPath[MAX_PATH];

    if (0 == GetSystemDirectory(szSysPath, MAX_PATH))
        return E_FAIL;

    V_VT(pvResult) = VT_BSTR;
    V_BSTR(pvResult) = SysAllocString(szSysPath);

    return S_OK;
};

HRESULT CAPI::get_CSIDLDirectory(UINT iCSIDLPath, LPVARIANT pvResult)
{
    WCHAR szSysPath[MAX_PATH];

    // bugbug should we always create this?
    HRESULT hr = WrapSHGetSpecialFolderPath(NULL, szSysPath, iCSIDLPath, TRUE);

    V_VT(pvResult) = VT_BSTR;
    V_BSTR(pvResult) = SysAllocString(SUCCEEDED(hr) ? (LPCWSTR) szSysPath : L"");

    return hr ;
};


HRESULT CAPI::LoadFile(BSTR bstrPath, LPVARIANT pvResult)
{
    HANDLE fh = INVALID_HANDLE_VALUE;
    HRESULT hr = E_FAIL;

    VariantInit(pvResult);
    V_VT(pvResult) = VT_BSTR;
    V_BSTR(pvResult) = NULL;

    fh = CreateFile(bstrPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fh != INVALID_HANDLE_VALUE)
    {
        DWORD cbSizeHigh = 0;
        DWORD cbSizeLow = GetFileSize(fh, &cbSizeHigh);
        BYTE* pbContents = new BYTE[cbSizeLow+1];


        // We don't plan to read files greater than a DWORD in length, but we
        // want to know if we do.
        MYASSERT(0 == cbSizeHigh);

        if (NULL != pbContents)
        {
            if (ReadFile(fh, pbContents, cbSizeLow, &cbSizeHigh, NULL))
            {
                // File contains ANSI chars
                //
                USES_CONVERSION;
                LPSTR szContents = (LPSTR) pbContents;
                pbContents[cbSizeLow] = '\0';
                // Make sure there's no imbedded NULs because we rely on lstrlen
                MYASSERT( strlen((const char *)pbContents) == cbSizeLow );
                V_BSTR(pvResult) = SysAllocString(A2W(szContents));
                if (V_BSTR(pvResult)
                    )
                {
                    hr = S_OK;
                }
                szContents = NULL;
            }

            delete [] pbContents;
            pbContents = NULL;
        }
        CloseHandle(fh);
        fh = INVALID_HANDLE_VALUE;
    }
    return hr;
}

HRESULT CAPI::get_UserDefaultLCID(LPVARIANT pvResult)
{
    VariantInit(pvResult);
    V_VT(pvResult) = VT_I4;
    V_I4(pvResult) = GetUserDefaultLCID();

    return S_OK;
};


STDMETHODIMP
CAPI::get_UserDefaultUILanguage(
    LPVARIANT pvResult
    )
{
    if (pvResult != NULL) {
        VariantInit(pvResult);
        V_VT(pvResult) = VT_I4;
        V_I4(pvResult) = GetUserDefaultUILanguage();
    }

    return S_OK;
}


HRESULT
CAPI::get_ComputerName(
    LPVARIANT           pvResult
    )
{
    HRESULT             hr = S_OK;
    WCHAR               szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD               cch = sizeof(szComputerName) / sizeof(WCHAR);


    if (! ::GetComputerName( szComputerName, &cch))
    {
        DWORD   dwErr = ::GetLastError();
        TRACE1(L"GetComputerName failed (0x%08X)", dwErr);
        szComputerName[0] = '\0';
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    if (SUCCEEDED(hr))
    {
        V_VT(pvResult) = VT_BSTR;
        V_BSTR(pvResult) = SysAllocString(szComputerName);
        if (NULL == V_BSTR(pvResult))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// set_ComputerName
//
//  Sets the computer name to a given string.  SetComputerNameEx adjusts most
//  of the registry entries.  However, the following need to be changed
//  directly because WinLogon changes them prior to running msoobe.exe:
//  * System\CurrentControlSet\Control\ComputerName\\ActiveComputerName
//      \ComputerName
//  * HKLM\System\CurrentControlSet\Services\Tcpip\Parameters
//      \Hostname
//  * HKEY_CURRENT_USER\VolatileEnvironment
//      \LOGONSERVER
//
//  The ActiveComputerName key contains the name currently used by the computer
//  and returned by GetComputerName.
//
//  The Tcpip\Parameters\Hostname value contains the non-volatile hostname
//  returned by ??.
//
//  The LOGONSERVER value is used as the value of the LOGONSERVER environment
//  variable.
//
HRESULT
CAPI::set_ComputerName(
    BSTR                bstrComputerName
    )
{
    HRESULT             hr = S_OK;
    LRESULT             lResult;
    HKEY                hkey = NULL;

    MYASSERT(NULL != bstrComputerName);
    if (   NULL == bstrComputerName
        || MAX_COMPUTERNAME_LENGTH < lstrlen((LPCWSTR)bstrComputerName)
        )
    {
        return E_INVALIDARG;
    }

    // Trim spaces before we use the name
    StrTrim(bstrComputerName, TEXT(" "));

    // SetComputerNameEx validates the name,sets
    // HKLM\System\CurrentControlSet\Control\ComputerName\ComputerName, and
    // changes the appropriate network registry entries.
    if (! ::SetComputerNameEx(ComputerNamePhysicalDnsHostname,
                              (LPCWSTR)bstrComputerName)
        )
    {
        DWORD   dwErr = ::GetLastError();
        TRACE2(L"SetComputerNameEx(%s) failed (0x%08X)",
               (LPCWSTR)bstrComputerName, dwErr
               );
        return HRESULT_FROM_WIN32(dwErr);
    }

    // The following keys must be set explicitly because SetComputerNameEx does
    // not set them.
    //
    // HKLM\System\CurrentControlSet\Control\ComputerName\ActiveComputerName
    // must be set because it is the key that is used to determine the
    // current computer name.
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REGSTR_PATH_ACTIVECOMPUTERNAME,
                         0,
                         KEY_WRITE,
                         &hkey
                         );
    if (ERROR_SUCCESS == lResult)
    {
        lResult = RegSetValueEx(hkey,
                                REGSTR_VAL_COMPUTERNAME,
                                0,
                                REG_SZ,
                                (LPBYTE)bstrComputerName,
                                BYTES_REQUIRED_BY_SZ(bstrComputerName)
                                );
        RegCloseKey(hkey);
        hkey = NULL;
    }

    if (ERROR_SUCCESS != lResult)
    {
        TRACE3(L"Failed to set %s to %s (0x%08X)\n",
               REGSTR_VAL_COMPUTERNAME,
               (LPCWSTR)bstrComputerName,
               lResult
               );
    }


    // HKLM\System\CurrentControlSet\Services\Tcpip\Parameters\Hostname
    // contains the volatile hostname (ie this is the entry that is changed on
    // the fly)  Winlogon has already updated this entry during boot so we
    // must update it ourselves.
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REGSTR_PATH_TCPIP_PARAMETERS,
                         0,
                         KEY_WRITE,
                         &hkey
                         );
    if (ERROR_SUCCESS == lResult)
    {
        lResult = RegSetValueEx(hkey,
                                REGSTR_VALUE_HOSTNAME,
                                0,
                                REG_SZ,
                                (LPBYTE)bstrComputerName,
                                BYTES_REQUIRED_BY_SZ(bstrComputerName)
                                );
        RegCloseKey(hkey);
        hkey = NULL;
    }
    if (ERROR_SUCCESS != lResult)
    {
        TRACE3(L"Failed to set %s to %s (0x%08X)\n",
               REGSTR_VALUE_HOSTNAME,
               (LPCWSTR)bstrComputerName,
               lResult
               );
    }

    // Key should have been closed already.
    //
    MYASSERT(NULL == hkey);

    if (!SetAccountsDomainSid(0, bstrComputerName))
    {
        TRACE(L"SetAccountsDomainSid failed\n\r",);
    }

    return S_OK;
}

HRESULT CAPI::ValidateComputername(BSTR bstrComputername)
{
    HRESULT hr = E_FAIL;
    UINT Length,u;

    if (!bstrComputername)
        return hr;

    // Trim spaces before validation.
    StrTrim(bstrComputername, TEXT(" "));

    Length = lstrlen(bstrComputername);
    if ((Length == 0) || (Length > MAX_COMPUTERNAME_LENGTH))
        return hr;

    u = 0;
    hr = S_OK;
    while ((hr == S_OK) && (u < Length))
    {
        //
        // Control chars are invalid, as are characters in the illegal chars list.
        //
        if((bstrComputername[u] < L' ') || wcschr(IllegalNetNameChars,bstrComputername[u]))
        {
            hr = E_FAIL;
        }
        u++;
    }
    return hr;
}

STDMETHODIMP CAPI::OEMComputername()
{
    WCHAR szIniFile[MAX_PATH] = L"";
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    HRESULT hr = E_FAIL;
    // Get the name from the INI file.
    if (GetCanonicalizedPath(szIniFile, INI_SETTINGS_FILENAME))
    {
        if (GetPrivateProfileString(USER_INFO_KEYNAME,
                                    L"Computername",
                                    L"\0",
                                    szComputerName,
                                    MAX_CHARS_IN_BUFFER(szComputerName),
                                    szIniFile) != 0)
        {
            if (SUCCEEDED(hr = ValidateComputername(szComputerName)))
            {
                hr = set_ComputerName(szComputerName);
                if (hr != S_OK)
                {
                    TRACE2(TEXT("OEMComputername: set_ComputerName on %s failed with %lx"), szComputerName, hr);
                }
            }
            else
            {
                TRACE1(TEXT("OEMComputername: Computername %s is invalid"), szComputerName);
            }
        }
    }
    return hr;
}

STDMETHODIMP CAPI::FormatMessage(   LPVARIANT pvResult, // message buffer
                                    BSTR bstrSource,    // message source
                                    int cArgs,          // number of inserts
                                    VARIANTARG *rgArgs  // array of message inserts
                                )
{
    DWORD   dwErr;
    BSTR*   rgbstr = NULL;
    LPTSTR  str = NULL;

    if (pvResult == NULL)
    {
        return S_OK;
    }

    VariantInit(pvResult);

    if (bstrSource == NULL)
    {
        return E_FAIL;
    }

    if (cArgs > 0 && rgArgs != NULL)
    {
        rgbstr = (BSTR*)LocalAlloc(LPTR, cArgs * sizeof(BSTR));
        if (rgbstr == NULL)
        {
            return E_FAIL;
        }
        // Since IDispatch::Invoke gets argument right to left, and
        // since we need to pass argument to FormatMessage left to right,
        // we need to reverse the order of argument while copying.
        for (int i = 0; i < cArgs; i++)
        {
            rgbstr[cArgs - 1 - i] = V_BSTR(&rgArgs[i]);
        }
    }

    dwErr = ::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            bstrSource,
                            0,
                            0,
                            (LPTSTR)&str,
                            MAX_PATH,
                            (va_list *)rgbstr
                           );

    if (dwErr != 0)
    {
        V_VT(pvResult) = VT_BSTR;
        V_BSTR(pvResult) = SysAllocString(str);
    }

    if (str != NULL)
    {
        LocalFree(str);
    }
    if (rgbstr != NULL)
    {
        LocalFree(rgbstr);
    }

    return (dwErr != 0 ? S_OK : E_FAIL);
}

STDMETHODIMP CAPI::set_ComputerDesc(BSTR bstrComputerDesc)
{
    WCHAR   szKeyName[] = REG_KEY_OOBE_TEMP;
    HKEY    hKey;

    if ( bstrComputerDesc )
    {
        if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS )
        {
            RegSetValueEx(hKey, REG_VAL_COMPUTERDESCRIPTION, 0, REG_SZ, (LPBYTE) bstrComputerDesc, BYTES_REQUIRED_BY_SZ(bstrComputerDesc));

            RegFlushKey(hKey);
            RegCloseKey(hKey);
        }
    }
    return S_OK;

}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CAPI::QueryInterface
STDMETHODIMP CAPI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CAPI::AddRef
STDMETHODIMP_(ULONG) CAPI::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CAPI::Release
STDMETHODIMP_(ULONG) CAPI::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CAPI::GetTypeInfo
STDMETHODIMP CAPI::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CAPI::GetTypeInfoCount
STDMETHODIMP CAPI::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CAPI::GetIDsOfNames
STDMETHODIMP CAPI::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(APIExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(APIExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = APIExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CAPI::Invoke
HRESULT CAPI::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    // Assume everything is hunky-dory.  Only return an HRESULT other than S_OK
    // in case of a catastrophic failure.  Result codes should be returned to
    // script via pvarResult.
    //
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_API_SAVEFILE:
        {

            TRACE(L"DISPID_API_SAVEFILE\n");

            if (NULL != pdispparams)
            {
                if (2 < pdispparams->cArgs)
                    SaveFile(V_BSTR(&pdispparams->rgvarg[2]), V_BSTR(&pdispparams->rgvarg[1]), V_BSTR(&pdispparams->rgvarg[0]));
                else
                    if (1 < pdispparams->cArgs)
                        SaveFile(V_BSTR(&pdispparams->rgvarg[1]), V_BSTR(&pdispparams->rgvarg[0]));
            }
            break;
        }

// bugbug If VariantChangeType returns DISP_E_TYPEMISMATCH, the implementor would set *puArgErr to 0 (indicating the argument in error) and return DISP_E_TYPEMISMATCH from IDispatch::Invoke.

        case DISPID_API_SAVEFILEBYCSIDL:
        {

            TRACE(L"DISPID_API_SAVEFILEBYCSIDL\n");

            if (NULL != pdispparams)
            {
                VARIANTARG vaConverted;
                VariantInit(&vaConverted);
                if (2 < pdispparams->cArgs)
                {

                    hr = VariantChangeType(&vaConverted, &pdispparams->rgvarg[2], 0, VT_I4);
                    if (SUCCEEDED(hr))
                        hr = SaveFile(V_I4(&vaConverted), V_BSTR(&pdispparams->rgvarg[1]), V_BSTR(&pdispparams->rgvarg[0]));
                }
                else
                    if (1 < pdispparams->cArgs)
                    {
                        hr = VariantChangeType(&vaConverted, &pdispparams->rgvarg[1], 0, VT_I4);
                        if (SUCCEEDED(hr))
                            hr = SaveFile(V_I4(&vaConverted), V_BSTR(&pdispparams->rgvarg[0]));
                    }
            }
            hr = S_OK;  // don't cause script engine to throw exception
            break;
        }

        case DISPID_API_GET_INIKEY:
        {
             TRACE(L"DISPID_API_GET_INIKEY\n");

             if (pdispparams != NULL && pvarResult != NULL)
             {
                 if (pdispparams->cArgs > 2)
                 {
                     get_INIKey(
                         V_BSTR(&pdispparams->rgvarg[2]),
                         V_BSTR(&pdispparams->rgvarg[1]),
                         V_BSTR(&pdispparams->rgvarg[0]),
                         pvarResult
                         );
                 }
                 else if (pdispparams->cArgs == 2)
                 {
                     BSTR bstrFile = SysAllocStringLen(NULL, MAX_PATH);

                     if (bstrFile)
                     {
                         if (GetCanonicalizedPath(bstrFile, INI_SETTINGS_FILENAME))
                         {
                             get_INIKey(
                                bstrFile,
                                V_BSTR(&pdispparams->rgvarg[1]),
                                V_BSTR(&pdispparams->rgvarg[0]),
                                pvarResult
                                );

                         }
                         SysFreeString(bstrFile);
                     }
                 }
             }

             break;
        }

        case DISPID_API_SET_REGVALUE:

            TRACE(L"DISPID_API_SET_REGVALUE: ");

            if (NULL != pdispparams && 3 < pdispparams->cArgs)
            {
                BSTR bstrSubKey = NULL;
                BSTR bstrValueName = NULL;
                BOOL bValid = TRUE;

                switch (V_VT(&pdispparams->rgvarg[1]))
                {
                case VT_NULL:
                    bstrValueName = NULL;
                    break;
                case VT_BSTR:
                    bstrValueName = V_BSTR(&pdispparams->rgvarg[1]);
                    break;
                default:
                    bValid = FALSE;
                }

                bstrSubKey = V_BSTR(&pdispparams->rgvarg[2]);

                if (bValid)
                {
                    TRACE2(L"%s, %s\n", bstrSubKey, bstrValueName);

                    set_RegValue((HKEY) (DWORD_PTR) V_R8(&pdispparams->rgvarg[3]),
                                  bstrSubKey,
                                  bstrValueName,
                                  &pdispparams->rgvarg[0]);
                }
            }
            break;

        case DISPID_API_GET_REGVALUE:

            TRACE(L"DISPID_API_GET_REGVALUE: ");

            if (NULL != pdispparams && NULL != pvarResult && 2 < pdispparams->cArgs)
            {
                BSTR bstrSubKey = NULL;
                BSTR bstrValueName = NULL;
                BOOL bValid = TRUE;

                switch (V_VT(&pdispparams->rgvarg[0]))
                {
                case VT_NULL:
                    bstrValueName = NULL;
                    break;
                case VT_BSTR:
                    bstrValueName = V_BSTR(&pdispparams->rgvarg[0]);
                    break;
                default:
                    bValid = FALSE;
                }

                bstrSubKey = V_BSTR(&pdispparams->rgvarg[1]);

                if (bValid)
                {
                    TRACE2(L"%s: %s", bstrSubKey, bstrValueName);
                    get_RegValue((HKEY) (DWORD_PTR) V_R8(&pdispparams->rgvarg[2]),
                                        bstrSubKey,
                                        bstrValueName,
                                        pvarResult);
                }
            }

            break;

        case DISPID_API_DELETEREGVALUE:

            TRACE(L"DISPID_API_DELETEREGVALUE\n");

            if (NULL != pdispparams && 1 < pdispparams->cArgs)
                DeleteRegValue((HKEY) (DWORD_PTR) V_R8(&pdispparams->rgvarg[2]),
                                    V_BSTR(&pdispparams->rgvarg[1]),
                                    V_BSTR(&pdispparams->rgvarg[0]));
            break;

        case DISPID_API_DELETEREGKEY:

            TRACE(L"DISPID_API_DELETEREGKEY\n");

            if (NULL != pdispparams && 1 < pdispparams->cArgs)
                DeleteRegKey((HKEY) (DWORD_PTR) V_R8(&pdispparams->rgvarg[1]),
                                    V_BSTR(&pdispparams->rgvarg[0]));
            break;

        case DISPID_API_GET_SYSTEMDIRECTORY:

            TRACE(L"DISPID_API_GET_SYSTEMDIRECTORY\n");

            if (NULL != pvarResult)
                get_SystemDirectory(pvarResult);
            break;

        case DISPID_API_GET_CSIDLDIRECTORY:

            TRACE(L"DISPID_API_GET_CSIDLDIRECTORY\n");

            if (NULL != pdispparams && 0 < pdispparams->cArgs && pvarResult != NULL)
                get_CSIDLDirectory(V_I4(&pdispparams->rgvarg[0]), pvarResult);
            break;

        case DISPID_API_LOADFILE:

            TRACE(L"DISPID_API_LOADFILE\n");

            if (NULL != pdispparams && 0 < pdispparams->cArgs && pvarResult != NULL)
            {
                LoadFile(V_BSTR(&pdispparams->rgvarg[0]), pvarResult);
            }
            break;

        case DISPID_API_GET_USERDEFAULTLCID:

            TRACE(L"DISPID_API_GET_USERDEFAULTLCID\n");

            if (pvarResult != NULL)
                get_UserDefaultLCID(pvarResult);
            break;

        case DISPID_API_GET_COMPUTERNAME:

            TRACE(L"DISPID_API_GET_COMPUTERNAME\n");

            if (NULL != pvarResult)
            {
                get_ComputerName(pvarResult);
            }
            break;

        case DISPID_API_SET_COMPUTERNAME:

            TRACE(L"DISPID_API_SET_COMPUTERNAME\n");

            if (pdispparams && &(pdispparams[0].rgvarg[0]))
            {
                hr =  set_ComputerName(pdispparams[0].rgvarg[0].bstrVal);
                if (pvarResult)
                {
                    VariantInit(pvarResult);
                    V_VT(pvarResult) = VT_BOOL;
                    V_BOOL(pvarResult) = Bool2VarBool(SUCCEEDED(hr));
                }
            }
            hr = S_OK;  // don't cause an exception in the scripting engine.
            break;

        case DISPID_API_FLUSHREGKEY:

            TRACE(L"DISPID_API_FLUSHREGKEY\n");

            if (pdispparams && &(pdispparams[0].rgvarg[0]))
            {
                FlushRegKey((HKEY) (DWORD_PTR) V_R8(&pdispparams->rgvarg[0]));
            }
            break;

        case DISPID_API_VALIDATECOMPUTERNAME:

            TRACE(L"DISPID_API_VALIDATECOMPUTERNAME\n");

            if (pdispparams && (0 < pdispparams->cArgs))
            {
                hr =  ValidateComputername(pdispparams[0].rgvarg[0].bstrVal);
                if (pvarResult)
                {
                    VariantInit(pvarResult);
                    V_VT(pvarResult) = VT_BOOL;
                    V_BOOL(pvarResult) = Bool2VarBool(SUCCEEDED(hr));
                }
            }
            hr = S_OK;  // don't cause an exception in the scripting engine.
            break;

        case DISPID_API_OEMCOMPUTERNAME:
            TRACE(L"DISPID_API_OEMCOMPUTERNAME");

            hr =  OEMComputername();

            if (pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;
                V_BOOL(pvarResult) = Bool2VarBool(SUCCEEDED(hr));
            }
            hr = S_OK;  // don't cause an exception in the scripting engine.
            break;

        case DISPID_API_FORMATMESSAGE:

            TRACE(L"DISPID_API_FORMATMESSAGE");

            if (pdispparams != NULL)
            {
                int cArgs = pdispparams->cArgs - 1;

                if (cArgs >= 0 && V_VT(&pdispparams->rgvarg[cArgs]) == VT_BSTR)
                {
                    FormatMessage(pvarResult, V_BSTR(&pdispparams->rgvarg[cArgs]), cArgs, &pdispparams->rgvarg[0]);
                }
            }
            break;

        case DISPID_API_SET_COMPUTERDESC:

            TRACE(L"DISPID_API_SET_COMPUTERDESC\n");

            if (pdispparams && &(pdispparams[0].rgvarg[0]))
            {
                hr =  set_ComputerDesc(pdispparams[0].rgvarg[0].bstrVal);
                if (pvarResult)
                {
                    VariantInit(pvarResult);
                    V_VT(pvarResult) = VT_BOOL;
                    V_BOOL(pvarResult) = Bool2VarBool(SUCCEEDED(hr));
                }
            }
            hr = S_OK;  // don't cause an exception in the scripting engine.
            break;

        case DISPID_API_GET_USERDEFAULTUILANGUAGE:

            TRACE(L"DISPID_API_GET_USERDEFAULTUILANGUAGE");
            get_UserDefaultUILanguage(pvarResult);
            break;

        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\auditmd.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  auditmd.CPP - Implementation of CObWebBrowser
//
//  HISTORY:
//  
//  9/17/99 vyung Created.
// 
//  Class which will call up setupx.dll

#include <windows.h>
#include <windowsx.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>


#include "appdefs.h"
#include "msobmain.h"
#include "resource.h"




// The licence agreement needs to be in this path
#define SZ_OEMAUDIT_LICENSE_TXT     L"%SystemRoot%\\OPTIONS\\OEMLCNS.TXT"   // text file for the oem license page
#define SZ_EULA_LICENSE_TXT     L"%SystemRoot%\\SYSTEM32\\EULA.TXT"   // text file for the oem license page

#define DX_MARGIN           4       // Pixels between status buttons.
#define UI_POS_MARGIN       8       // Pixels to allow on edges.
#define DLG_CENTERH         0x01
#define DLG_CENTERV         0x02
#define DLG_TOP             0x04
#define DLG_BOTTOM          0x08
#define DLG_RIGHT           0x10
#define DLG_LEFT            0x11

HINSTANCE   ghInst = NULL;

/****************************************************************************
 *
 * uiPositionDialog()
 *
 * This routine will position your dialog based on the flags
 * passed to it.
 *
 * ENTRY:
 *  hwndDlg     - Dialog window.
 *  wPosFlags   - Defines how to position the dialog.  Valid flags are
 *                  DLG_CENTERV, DLG_CENTERH, DLG_TOP, DLG_BOTTOM,
 *                  DLG_RIGHT, DLG_LEFT, or DLG_CENTER.
 *
 * EXIT:
 *  None.
 *
 * NOTES:
 *  None.
 *
 ***************************************************************************/
BOOL WINAPI uiPositionDialog( HWND hwndDlg, WORD wPosFlags )
{
    RECT    rc;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen = GetSystemMetrics( SM_CXSCREEN );
    int     cyScreen = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect(hwndDlg, &rc);

    x = rc.left;    // Default is to leave the dialog where the template
    y = rc.top;     //  was going to place it.

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;
    
    if ( wPosFlags & DLG_TOP )
    {
        y = UI_POS_MARGIN;
    }
    if ( wPosFlags & DLG_BOTTOM )
        y = cyScreen - cyDlg;

    if ( wPosFlags & DLG_LEFT )
    {
       	x = UI_POS_MARGIN;
	}

    if ( wPosFlags & DLG_RIGHT )
    {
        x = cxScreen - cxDlg;
    }

    if ( wPosFlags & DLG_CENTERV )
    {
        y = (cyScreen - cyDlg) / 2;
    }
    
    if ( wPosFlags & DLG_CENTERH )
    {
        x = (cxScreen - cxDlg) / 2;
    }
        

    // Position the dialog.
    //
    return SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
}

BOOL FillInOEMAuditLicense(HWND hwnd)
{
    DWORD   reRet = 0;
    HANDLE  hfile = NULL;
    DWORD   dwBytesRead;
    TCHAR   szEulaFile[MAX_PATH];

    ExpandEnvironmentStrings(SZ_EULA_LICENSE_TXT,
                            szEulaFile,
                            sizeof(szEulaFile)/sizeof(szEulaFile[0]));

    if (INVALID_HANDLE_VALUE != (hfile = CreateFile(szEulaFile,
                                                  GENERIC_READ,
                                                  0,
                                                  NULL,
                                                  OPEN_EXISTING,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  NULL)))
    {
        DWORD dwFileSize = GetFileSize(hfile, NULL);
        if (dwFileSize <= 0xFFFF)
        {
            BYTE * lpszText = new BYTE[dwFileSize + 1];
            if (lpszText != NULL)
            {
                // Read complete file
                // Attempt a synchronous read operation. 
                if (ReadFile(hfile, (LPVOID) lpszText, dwFileSize, &dwBytesRead, NULL) &&
                    ( dwBytesRead != dwFileSize))
                {
                    reRet = 100;
                }

                SetWindowTextA( GetDlgItem(hwnd, IDC_OEMLICENSE_TEXT), (LPCSTR)lpszText);
                delete [] lpszText;
            }
            else
                reRet = 102;
        }
        else
            reRet = 103;

        // Close the File
        CloseHandle(hfile);

    }
    else
        reRet = 101;


    return (reRet == 0);

}

// Dlg proc for the OEM license page. This is used in manual auditing.
INT_PTR CALLBACK sxOemAuditLicenseDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static HBRUSH hbrBkGnd = NULL;
    static DWORD dwAuditMode;
    WCHAR szTitle[MAX_PATH] = L"\0";

    switch( msg )
    {
        case WM_INITDIALOG:

            // Look for the OEM audit child windows
            LoadString(ghInst, IDS_OEM_LICENSE_DLG_TITLE, szTitle, MAX_CHARS_IN_BUFFER(szTitle));
            SetWindowText(hwnd, szTitle);
            SetFocus(hwnd);

            hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

            // Checks if we allow maual audit boot
            if (FillInOEMAuditLicense(hwnd))
                uiPositionDialog( hwnd, DLG_CENTERH | DLG_CENTERV );
            else
                EndDialog(hwnd, IDCANCEL);   
            
            return FALSE;

        case WM_CTLCOLOR:
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_BTNFACE) );
            return (INT_PTR)hbrBkGnd;

        case WM_DESTROY:
            if (hbrBkGnd)
                DeleteObject(hbrBkGnd);
            hbrBkGnd = NULL;
            break;

        case WM_COMMAND:
            
            switch( wParam )
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hwnd, wParam);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE; 
    }

    return TRUE;
}

BOOL ProcessAuditBoot(HINSTANCE hInst, HWND hwndParent)
{
    ghInst = hInst;
    return (DialogBox(hInst, MAKEINTRESOURCE(IDD_OEMLICENSE), hwndParent, sxOemAuditLicenseDlgProc) == IDOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\debug.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  DEBUG.CPP - Implementation for CDebug
//
//  HISTORY:
//
//  05/08/00 dane    Created.
//

#include "precomp.h"
#include "msobmain.h"
#include "appdefs.h"
#include "dispids.h"


DISPATCHLIST DebugExternalInterface[] =
{
    {L"Trace",                DISPID_DEBUG_TRACE           },
    {L"get_MsDebugMode",      DISPID_DEBUG_ISMSDEBUGMODE   },
    {L"get_OemDebugMode",     DISPID_DEBUG_ISOEMDEBUGMODE  }
};

/////////////////////////////////////////////////////////////
// CDebug::CDebug
CDebug::CDebug()
{

    // Init member vars
    m_cRef = 0;
    m_fMsDebugMode = IsMsDebugMode( );
    m_fOemDebugMode = IsOEMDebugMode();
}

/////////////////////////////////////////////////////////////
// CDebug::~CDebug
CDebug::~CDebug()
{
    MYASSERT(m_cRef == 0);
}

void
CDebug::Trace(
    BSTR bstrVal
    )
{
    pSetupDebugPrint( L"OOBE Trace", 0, NULL, bstrVal );
#if 1
    if (m_fMsDebugMode)
    {
        ::MyTrace(bstrVal);
    }
#endif
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CDebug::QueryInterface
STDMETHODIMP CDebug::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CDebug::AddRef
STDMETHODIMP_(ULONG) CDebug::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CDebug::Release
STDMETHODIMP_(ULONG) CDebug::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CDebug::GetTypeInfo
STDMETHODIMP CDebug::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CDebug::GetTypeInfoCount
STDMETHODIMP CDebug::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CDebug::GetIDsOfNames
STDMETHODIMP CDebug::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(DebugExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(DebugExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = DebugExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CDebug::Invoke
HRESULT CDebug::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_DEBUG_TRACE:
        {
            if(pdispparams && &pdispparams[0].rgvarg[0])
                Trace(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

        case DISPID_DEBUG_ISMSDEBUGMODE:
        {
            if (pvarResult != NULL)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;
                V_BOOL(pvarResult) = Bool2VarBool(m_fMsDebugMode);
            }
            break;
        }

        case DISPID_DEBUG_ISOEMDEBUGMODE:
        {
            if (   NULL != pdispparams
                && 0 < pdispparams->cArgs
                && pvarResult != NULL)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;
                V_BOOL(pvarResult) = Bool2VarBool(m_fOemDebugMode);
            }
            break;
        }

        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}


/////////////////////////////////////////////////////////////
// CDebug::GetMsDebugMode
BOOL
CDebug::IsMsDebugMode( )
{
    // Allow default MsDebugMode to be overridden by
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\OOBE\MsDebug
    //

#ifdef DBG
    DWORD dwIsDebug = TRUE;
#else
    DWORD dwIsDebug = FALSE;
#endif
    HKEY   hKey      = NULL;
    DWORD  dwSize    = sizeof(DWORD);

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    OOBE_MAIN_REG_KEY,
                    0,
                    KEY_QUERY_VALUE,
                    &hKey) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey,
                        OOBE_MSDEBUG_REG_VAL,
                        0,
                        NULL,
                        (LPBYTE)&dwIsDebug,
                        &dwSize);
        RegCloseKey(hKey);
    }

    return (BOOL) dwIsDebug;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\direct.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  Directions.H - Header for the implementation of CDirections
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#ifndef _DIRECTIONS_H_
#define _DIRECTIONS_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>


class CDirections : public IDispatch
{
private:
    ULONG m_cRef;
    HINSTANCE m_hInstance;
    DWORD m_dwAppMode;

    //GET functions
    HRESULT get_DoMouseTutorial(LPVARIANT pvResult);
    HRESULT get_DoOEMRegistration(LPVARIANT pvResult);
    HRESULT get_DoRegionalKeyboard(LPVARIANT pvResult);
    HRESULT get_DoOEMHardwareCheck(LPVARIANT pvResult);
    HRESULT get_DoBrowseNow(LPVARIANT pvResult);
    HRESULT get_Offline(LPVARIANT pvResult);
    HRESULT get_OEMOfferCode(LPVARIANT pvResult);
    HRESULT get_OEMCust(LPVARIANT pvResult);
    HRESULT get_TimeZoneValue(LPVARIANT pvResult);
    HRESULT get_DoTimeZone(LPVARIANT pvResult);
    HRESULT get_DoIMETutorial(LPVARIANT pvResult);
    HRESULT get_DoOEMAddRegistration(LPVARIANT pvResult);
    HRESULT get_DoSkipAnimation(LPVARIANT pvResult);
    HRESULT get_DoWelcomeFadeIn(LPVARIANT pvResult);
    HRESULT get_AgentDisabled(LPVARIANT pvResult);
    HRESULT get_ShowISPMigration(LPVARIANT pvResult);
    HRESULT get_DoJoinDomain(LPVARIANT pvResult);
    HRESULT get_DoAdminPassword(LPVARIANT pvResult);

public:

    HRESULT get_ISPSignup(LPVARIANT pvResult);
    HRESULT get_RetailOOBE(LPVARIANT pvResult);
    HRESULT get_IntroOnly(LPVARIANT pvResult);

    CDirections (HINSTANCE hInstance, DWORD dwAppMode);
    ~CDirections ();

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid,
                                  WORD wFlags, DISPPARAMS* pdispparams,
                                  VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
                                  UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\eula.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  EULA.CPP - Header for the implementation of CEula
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 

#include "precomp.h"
#include "msobmain.h"
#include "eula.h"
#include "appdefs.h"
#include "dispids.h"
#include "resource.h"


#define REG_VAL_EULA        L"Eula"
#define EULA_FILE_NAME      L"EULA.TXT"

DISPATCHLIST EulaExternalInterface[] = 
{
    {L"get_EULAAcceptance", DISPID_EULA_GET_ACCEPTED },
    {L"set_EULAAcceptance", DISPID_EULA_SET_ACCEPTED },
    {L"ValidateEULA",       DISPID_EULA_VALIDATEEULA }
};
 
/////////////////////////////////////////////////////////////
// CEula::CEula
CEula::CEula(HINSTANCE hInstance)
{
    WCHAR   szKeyName[]     = REG_KEY_OOBE_TEMP,
            szBuffer[16]    = L"\0";
    HKEY    hKey            = NULL;
    DWORD   cb              = sizeof(szBuffer),
            dwType;

    // Init member vars
    m_cRef = 0;
    m_hInstance = hInstance;

    // Retreive the state from the registry.
    //
    m_bAccepted = ( ( RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey) == ERROR_SUCCESS ) &&
                    ( RegQueryValueEx(hKey, REG_VAL_EULA, NULL, &dwType, (LPBYTE) szBuffer, &cb) == ERROR_SUCCESS ) &&
                    ( cb > 0 ) &&
                    ( dwType == REG_SZ ) &&
                    ( szBuffer[0] == L'1' ) &&
                    ( szBuffer[1] == L'\0' ) );
    if ( hKey )
        RegCloseKey(hKey);

    //  Preconfigured EULA for direct OEM scenario
    //
    WCHAR szEulaValue[MAX_PATH] = L"\0";
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    NOEULA_REGKEY,
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS)
    {
        DWORD cb, dwType;
        cb = sizeof(szEulaValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REG_VAL_NOEULA, NULL, &dwType, (LPBYTE) szEulaValue, &cb))
        {
            if(lstrcmp(szEulaValue, OOBE_SKIP_EULA_VAL) == 0)
            {
                set_EULAAcceptance(TRUE);
                createLicenseHtm();
            }
        }
        RegCloseKey(hKey);
    }

}

/////////////////////////////////////////////////////////////
// CEula::~CEula
CEula::~CEula()
{
    MYASSERT(m_cRef == 0);
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: EULAAcceptance
////
HRESULT CEula::set_EULAAcceptance(BOOL bVal)
{
    WCHAR   szKeyName[]     = REG_KEY_OOBE_TEMP;
    HKEY    hKey;

    m_bAccepted = bVal;

    // Save the state of the EULA acceptance.
    //
    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS )
    {
        if ( bVal )
            RegSetValueEx(hKey, REG_VAL_EULA, 0, REG_SZ, (LPBYTE) L"1", BYTES_REQUIRED_BY_SZ(L"1"));
        else
            RegDeleteValue(hKey, REG_VAL_EULA);

        RegFlushKey(hKey);
        RegCloseKey(hKey);
    }

    return S_OK;
}

HRESULT CEula::get_EULAAcceptance(BOOL* pbVal)
{
    *pbVal = m_bAccepted;

    return S_OK;
}

HRESULT CEula::GetValidEulaFilename(BSTR* bstrVal)
{

    WCHAR       szEulaPath[MAX_PATH]= L"\0";
    BOOL        bValid              = FALSE;

    *bstrVal = NULL;
#if         0
    if (SetupGetValidEulaFilename(EULA_FILE_NAME, szEulaPath))
    {
            *bstrVal = SysAllocString(szEulaPath);
    }
    else
    {
        *bstrVal = NULL;
    }
#else
    // BUGBUG: Temporary hack until SetupGetValidEulaFilename is implemented.
#define EULA_FILENAME L"EULA.TXT"
        if (0 != GetSystemDirectory(szEulaPath, MAX_PATH))
        {
            if (MAX_PATH > 
                    lstrlen(szEulaPath) + lstrlen(EULA_FILENAME) + lstrlen(L"\\")
                )
                    
            {
                lstrcat(szEulaPath, L"\\");
                lstrcat(szEulaPath, EULA_FILENAME);
                *bstrVal = SysAllocString(szEulaPath);
            }
        }
#endif  //  0

    return (NULL != *bstrVal) ? S_OK : E_FAIL;
}

HRESULT CEula::createLicenseHtm()
{

    // Get the handle of the HTML Application file stored in this .dll's resources.
    HRSRC   hRes = 0;
    HGLOBAL hGlobalMem = 0;
    WCHAR   szDir [MAX_PATH] = L"\0";

    int nLen = 0, i = 0;
    LPVOID pBytes = 0;
    BSTR bstrEulaPath = NULL;

    WCHAR szEulaPath[MAX_PATH] = L"\0";
    WCHAR* szIn = NULL;
   
    if ( !( hRes = FindResource( m_hInstance, L"LICENSE_RESOURCE.HTM",  RT_HTML  ) ) )
    {
        return E_FAIL;
    }
    
    // Look for at least a few bytes of script, or something is wrong.
    nLen = SizeofResource( m_hInstance, hRes );

    if ( ( hGlobalMem = LoadResource( m_hInstance, hRes ) ) == NULL )
    {
        return E_FAIL;    
    }

    // Get a pointer to the bytes.
    if ( ( pBytes = (LPBYTE)LockResource( hGlobalMem )) == NULL )
    {
        return E_FAIL;
    }

    GetValidEulaFilename(&bstrEulaPath);

    GetOOBEPath(szDir);

    // Replace backslash with forwardslash for Jscript
    szIn = szDir;
    for ( i = 0; i < lstrlen(szDir); i++) { if (szIn[i] == L'\\') szIn[i] = L'/'; }

    lstrcpy(szEulaPath, bstrEulaPath);
    szIn = szEulaPath;
    for ( i = 0; i < lstrlen(szDir); i++) { if (szIn[i] == L'\\') szIn[i] = L'/'; }

    // Create "This software is licensed.htm in the windows desktop"
    HANDLE hfile = INVALID_HANDLE_VALUE;
    DWORD cbRet = 0;
    WCHAR szDesktop[MAX_PATH*2];

    GetDesktopDirectory(szDesktop);
    lstrcat(szDesktop, L"\\");

    WCHAR szTitle [MAX_PATH] = L"\0";
    LoadString(m_hInstance, IDS_SFTW_IS_LICENSED, szTitle, sizeof(szTitle));
    lstrcat(szDesktop, szTitle);

    hfile = CreateFile(szDesktop, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
           
    if (hfile != INVALID_HANDLE_VALUE)
    {
        WCHAR *szCurr = (LPWSTR)pBytes;
        WCHAR *szOrig = (LPWSTR)pBytes;
        WCHAR *szDest = NULL;
        // BUGBUG: Search and replace the %s with Eula and Window's path.  This
        // should be done with messages.
        while(NULL != (szDest = wcschr( szCurr, L'%' ))) 
        {
            if (szDest+1)
            {
                if (L's' == *(szDest+1))   
                    break;
            }
            szCurr = szDest+1;
        }
        WriteFile(hfile, szOrig, (DWORD)(szDest - szOrig), (LPDWORD)&cbRet, NULL);
        nLen -= cbRet;

        WriteFile(hfile, szDir, BYTES_REQUIRED_BY_SZ(szDir), (LPDWORD)&cbRet, NULL);

        szCurr = szDest + 2;
        szOrig = szCurr;

        while(NULL != (szDest = wcschr( szCurr, L'%' ))) 
        {
            if (szDest+1)
            {
                if (L's' == *(szDest+1))   
                    break;
            }
            szCurr = szDest+1;
        }
        WriteFile(hfile, szOrig, (DWORD)(szDest - szOrig), (LPDWORD)&cbRet, NULL);
        nLen -= cbRet;

        WriteFile(hfile, szEulaPath, BYTES_REQUIRED_BY_SZ(szEulaPath), (LPDWORD)&cbRet, NULL);

        szCurr = szDest + 2;
        szOrig = szCurr;

        // Need to substract 4 for the %s characters
        WriteFile(hfile, szOrig, nLen - 4, (LPDWORD)&cbRet, NULL);
        CloseHandle(hfile);
    }

    FreeResource(hGlobalMem);

    return S_OK;


}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CEula::QueryInterface
STDMETHODIMP CEula::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;     

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CEula::AddRef
STDMETHODIMP_(ULONG) CEula::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CEula::Release
STDMETHODIMP_(ULONG) CEula::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CEula::GetTypeInfo
STDMETHODIMP CEula::GetTypeInfo(UINT, LCID, ITypeInfo**)
{ 
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CEula::GetTypeInfoCount
STDMETHODIMP CEula::GetTypeInfoCount(UINT* pcInfo)
{ 
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CEula::GetIDsOfNames
STDMETHODIMP CEula::GetIDsOfNames(REFIID    riid, 
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{ 

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(EulaExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(EulaExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = EulaExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }      
        
    return hr;
}

/////////////////////////////////////////////////////////////
// CEula::Invoke
HRESULT CEula::Invoke
( 
    DISPID      dispidMember, 
    REFIID      riid, 
    LCID        lcid, 
    WORD        wFlags, 
    DISPPARAMS* pdispparams, 
    VARIANT*    pvarResult,  
    EXCEPINFO*  pexcepinfo, 
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;
    
    switch(dispidMember)
    {   
        case DISPID_EULA_GET_ACCEPTED:
        {

            TRACE(L"DISPID_EULA_GET_ACCEPTED\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;    
         
                get_EULAAcceptance((BOOL*)&(pvarResult->boolVal));
            }
            break;
        }
         
        case DISPID_EULA_SET_ACCEPTED:
        {

            TRACE(L"DISPID_EULA_SET_ACCEPTED\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_EULAAcceptance(pdispparams[0].rgvarg[0].boolVal);
            break;
        }
        
        case DISPID_EULA_VALIDATEEULA:
        {

            TRACE(L"DISPID_EULA_VALIDATEEULA\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;    
        
                GetValidEulaFilename(&(pvarResult->bstrVal));
            }
            break;
        }
       
        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\direct.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  Directions.CPP - Header for the implementation of CDirections
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "direct.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include "resource.h"

DISPATCHLIST DirectionsExternalInterface[] =
{
    {L"get_DoMouseTutorial",        DISPID_DIRECTIONS_GET_DOMOUSETUTORIAL     },
    {L"get_DoOEMRegistration",      DISPID_DIRECTIONS_GET_DOOEMREGISTRATION   },
    {L"get_DoRegionalKeyboard",     DISPID_DIRECTIONS_GET_DOREGIONALKEYBOARD  },
    {L"get_DoOEMHardwareCheck",     DISPID_DIRECTIONS_GET_DOOEMHARDWARECHECK  },
    {L"get_DoBrowseNow",            DISPID_DIRECTIONS_GET_DOBROWSENOW         },
    {L"get_ISPSignup",              DISPID_DIRECTIONS_GET_ISPSIGNUP           },
    {L"get_Offline",                DISPID_DIRECTIONS_GET_OFFLINE             },
    {L"get_OEMOfferCode",           DISPID_DIRECTIONS_GET_OFFERCODE           },
    {L"get_AppMode",                DISPID_DIRECTIONS_GET_APPMODE             },
    {L"get_OEMCust",                DISPID_DIRECTIONS_GET_OEMCUST             },
    {L"get_DoOEMAddRegistration",   DISPID_DIRECTIONS_GET_DOOEMADDREGISTRATION},
    {L"get_DoIMETutorial",          DISPID_DIRECTIONS_GET_DOIMETUTORIAL       },
    {L"get_DoTimeZone",             DISPID_DIRECTIONS_GET_DOTIMEZONE          },
    {L"get_TimeZoneValue",          DISPID_DIRECTIONS_GET_TIMEZONEVALUE       },
    {L"get_DoSkipAnimation",        DISPID_DIRECTIONS_GET_DOSKIPANIMATION     },
    {L"get_DoWelcomeFadeIn",        DISPID_DIRECTIONS_GET_DOWELCOMEFADEIN     },
    {L"get_IntroOnly",              DISPID_DIRECTIONS_GET_INTROONLY           },
    {L"get_AgentDisabled",          DISPID_DIRECTIONS_GET_AGENTDISABLED       },
    {L"get_ShowISPMigration",       DISPID_DIRECTIONS_GET_SHOWISPMIGRATION    },
    {L"get_DoJoinDomain",           DISPID_DIRECTIONS_GET_DOJOINDOMAIN        },
    {L"get_DoAdminPassword",        DISPID_DIRECTIONS_GET_DOADMINPASSWORD     }
};

/////////////////////////////////////////////////////////////
// CDirections::CDirections
CDirections::CDirections(HINSTANCE hInstance, DWORD dwAppMode)
{

    // Init member vars
    m_cRef      = 0;
    m_hInstance = hInstance;
    m_dwAppMode = dwAppMode;
}

/////////////////////////////////////////////////////////////
// CDirections::~CDirections
CDirections::~CDirections()
{
    assert(m_cRef == 0);
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: DirectionsLocale
////
HRESULT CDirections::get_DoMouseTutorial(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                            IDS_KEY_MOUSETUTORIAL, pvResult);
}

HRESULT CDirections::get_DoOEMRegistration(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OEMREGISTRATIONPAGE,
                            IDS_KEY_OEMREGPAGE, pvResult);
}

HRESULT CDirections::get_DoRegionalKeyboard(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                                IDS_KEY_INTL_SETTINGS, pvResult);
}

HRESULT CDirections::get_DoOEMHardwareCheck(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OEMHARDWARECHECK,
                                IDS_KEY_OEMHWCHECK, pvResult);
}

HRESULT CDirections::get_DoBrowseNow(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_BROWSENOW,
                                IDS_KEY_BROWSENOW, pvResult);
}

HRESULT CDirections::get_ISPSignup(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_SIGNUP,
                            IDS_KEY_ISPSIGNUP, pvResult);
}

HRESULT CDirections::get_Offline(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_STARTUPOPTIONS,
                                IDS_KEY_OFFLINE, pvResult);
}

HRESULT CDirections::get_OEMOfferCode(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_SIGNUP,
                                IDS_KEY_OEMOFFERCODE, pvResult);
}

HRESULT CDirections::get_OEMCust(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                                IDS_KEY_OEMCUST, pvResult);
}

HRESULT CDirections::get_DoOEMAddRegistration(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OEMREGISTRATIONPAGE,
                            IDS_KEY_OEMADDREGPAGE, pvResult);
}

HRESULT CDirections::get_DoTimeZone(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                            IDS_KEY_TIMEZONE, pvResult);
}

HRESULT CDirections::get_TimeZoneValue(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                    IDS_KEY_TIMEZONEVAL, pvResult);
}

HRESULT CDirections::get_DoIMETutorial(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                            IDS_KEY_IMETUTORIAL, pvResult);
}

HRESULT CDirections::get_DoSkipAnimation(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_STARTUPOPTIONS,
                            IDS_SKIPANIMATION, pvResult);
}

HRESULT CDirections::get_DoWelcomeFadeIn(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_STARTUPOPTIONS,
                            IDS_DOWELCOMEFADEIN, pvResult);
}

HRESULT CDirections::get_IntroOnly(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                            IDS_INTROONLY, pvResult);
}

HRESULT CDirections::get_AgentDisabled(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                            IDS_AGENTDISABLED, pvResult);
}

HRESULT CDirections::get_ShowISPMigration(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_SIGNUP,
                            IDS_KEY_SHOWISPMIGRATION, pvResult);
}
HRESULT CDirections::get_DoJoinDomain(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                            IDS_KEY_JOINDOMAIN, pvResult);
}

HRESULT CDirections::get_DoAdminPassword(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OPTIONS,
                            IDS_KEY_ADMINPASSWORD, pvResult);
}



/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CDirections::QueryInterface
STDMETHODIMP CDirections::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CDirections::AddRef
STDMETHODIMP_(ULONG) CDirections::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CDirections::Release
STDMETHODIMP_(ULONG) CDirections::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CDirections::GetTypeInfo
STDMETHODIMP CDirections::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CDirections::GetTypeInfoCount
STDMETHODIMP CDirections::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CDirections::GetIDsOfNames
STDMETHODIMP CDirections::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(DirectionsExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(DirectionsExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = DirectionsExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CDirections::Invoke
HRESULT CDirections::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
    case DISPID_DIRECTIONS_GET_AGENTDISABLED:
        TRACE(L"DISPID_DIRECTIONS_GET_AGENTDISABLED\n");
        if (NULL != pvarResult)
            get_AgentDisabled(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOMOUSETUTORIAL:
        TRACE(L"DISPID_DIRECTIONS_GET_DOMOUSETUTORIAL\n");
        if (NULL != pvarResult)
            get_DoMouseTutorial(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOTIMEZONE:
        TRACE(L"DISPID_DIRECTIONS_GET_DOTIMEZONE\n");
        if (NULL != pvarResult)
            get_DoTimeZone(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOIMETUTORIAL:
        TRACE(L"DISPID_DIRECTIONS_GET_DOIMETUTORIAL\n");
        if (NULL != pvarResult)
            get_DoIMETutorial(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_TIMEZONEVALUE:
        TRACE(L"DISPID_DIRECTIONS_GET_TIMEZONEVALUE\n");
        if (NULL != pvarResult)
            get_TimeZoneValue(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOOEMREGISTRATION:
        TRACE(L"DISPID_DIRECTIONS_GET_DOOEMREGISTRATION\n");
        if (NULL != pvarResult)
            get_DoOEMRegistration(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOREGIONALKEYBOARD:
        TRACE(L"DISPID_DIRECTIONS_GET_DOREGIONALKEYBOARD\n");
        if (NULL != pvarResult)
            get_DoRegionalKeyboard(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOOEMHARDWARECHECK:
        TRACE(L"DISPID_DIRECTIONS_GET_DOOEMHARDWARECHECK\n");
        if (NULL != pvarResult)
            get_DoOEMHardwareCheck(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOBROWSENOW:
        TRACE(L"DISPID_DIRECTIONS_GET_DOBROWSENOW\n");
        if (NULL != pvarResult)
            get_DoBrowseNow(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOSKIPANIMATION:
        TRACE(L"DISPID_DIRECTIONS_GET_DOSKIPANIMATION\n");
        if (NULL != pvarResult)
            get_DoSkipAnimation(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOWELCOMEFADEIN:
        TRACE(L"DISPID_DIRECTIONS_GET_DOWELCOMEFADEIN\n");
        if (NULL != pvarResult)
            get_DoWelcomeFadeIn(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_INTROONLY:
        TRACE(L"DISPID_DIRECTIONS_GET_INTROONLY\n");
        if (NULL != pvarResult)
            get_IntroOnly(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_ISPSIGNUP:
        TRACE(L"DISPID_DIRECTIONS_GET_ISPSIGNUP\n");
        if (NULL != pvarResult)
            get_ISPSignup(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_OFFLINE:
        TRACE(L"DISPID_DIRECTIONS_GET_OFFLINE\n");
        if (NULL != pvarResult)
            get_Offline(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_OFFERCODE:
        TRACE(L"DISPID_DIRECTIONS_GET_OFFERCODE\n");
        if (NULL != pvarResult)
            get_OEMOfferCode(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_OEMCUST:
        TRACE(L"DISPID_DIRECTIONS_GET_OEMCUST\n");
        if (NULL != pvarResult)
            get_OEMCust(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOOEMADDREGISTRATION:
        TRACE(L"DISPID_DIRECTIONS_GET_DOOEMADDREGISTRATION\n");
        if (NULL != pvarResult)
            get_DoOEMAddRegistration(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_APPMODE:
        TRACE(L"DISPID_DIRECTIONS_GET_APPMODE\n");
        if (NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = m_dwAppMode;
            hr = S_OK;
        }
        break;

    case DISPID_DIRECTIONS_GET_SHOWISPMIGRATION:
        TRACE(L"DISPID_DIRECTIONS_GET_SHOWISPMIGRATION\n");
        if (NULL != pvarResult)
        {
            get_ShowISPMigration(pvarResult);
        }
        break;

    case DISPID_DIRECTIONS_GET_DOJOINDOMAIN:
        TRACE(L"DISPID_DIRECTIONS_GET_DOJOINDOMAIN");
        if (NULL != pvarResult)
            get_DoJoinDomain(pvarResult);
        break;

    case DISPID_DIRECTIONS_GET_DOADMINPASSWORD:
        TRACE(L"DISPID_DIRECTIONS_GET_DOADMINPASSWORD");
        if (NULL != pvarResult)
            get_DoAdminPassword(pvarResult);
        break;

    default:
        hr = DISP_E_MEMBERNOTFOUND;
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\debug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  DEBUG.H - Header for the implementation of CDebug.  This object is part of
//  the window.external interface and should only contain code that returns
//  debug information to scripts.  General debug code for OOBE belongs in
//  common\util.cpp and inc\util.h.
//
//  HISTORY:
//
//  05/08/00 dane Created.
//

#ifndef _OOBEDEBUG_H_
#define _OOBEDEBUG_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>


class CDebug : public IDispatch
{
private:
    ULONG m_cRef;
    BOOL  m_fMsDebugMode;
    BOOL  m_fOemDebugMode;

    void  Trace(BSTR bstrVal);
    BOOL  IsMsDebugMode( );

    //GET functions

    //SET functions

public:

     CDebug ();
    ~CDebug ();

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid,
                                  WORD wFlags, DISPPARAMS* pdispparams,
                                  VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
                                  UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\eula.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  EULA.H - Header for the implementation of CEula
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 

#ifndef _EULA_H_ 
#define _EULA_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>

class CEula : public IDispatch
{  
private:
    ULONG m_cRef;
    BOOL  m_bAccepted;
    HINSTANCE m_hInstance;

    //SET functions
    HRESULT set_EULAAcceptance (BOOL  bVal);
    
    //Methods
    HRESULT GetValidEulaFilename(BSTR* bstrEULAFile);

public: 
    
     CEula (HINSTANCE hInstance);
    ~CEula ();

    //GET functions
    HRESULT get_EULAAcceptance (BOOL* pbVal);
    HRESULT createLicenseHtm   ();
    
    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, 
                                  WORD wFlags, DISPPARAMS* pdispparams, 
                                  VARIANT* pvarResult, EXCEPINFO* pexcepinfo, 
                                  UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\htmparse.cpp ===
#include <urlmon.h>
#include <mshtmdid.h>
#include <mshtml.h>
#include <shlobj.h>
#include "htmparse.h"


CHTMLParser::CHTMLParser()
{
    m_cRef              = 1;
    m_hrConnected       = CONNECT_E_CANNOTCONNECT;
    m_dwCookie          = 0;
    m_pCP               = NULL;
    m_pMSHTML           = NULL;
    m_hEventTridentDone = 0;
}

CHTMLParser::~CHTMLParser()
{
    if (m_pMSHTML)
        m_pMSHTML->Release();
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

STDMETHODIMP CHTMLParser::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IPropertyNotifySink == riid)
    {
        *ppv = (LPUNKNOWN)(IPropertyNotifySink*)this;
        AddRef();
        return NOERROR;
    }
    else if (IID_IOleClientSite == riid)
    {
        *ppv = (IOleClientSite*)this;
        AddRef();
        return NOERROR;
    }
    else if (IID_IDispatch == riid)
    {
        *ppv = (IDispatch*)this;
        AddRef();
        return NOERROR;
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP_(ULONG) CHTMLParser::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CHTMLParser::Release()
{
    if (!(--m_cRef)) 
        delete this; 

    return m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IPropertyNotifySink implementation
///////
///////

// Fired on change of the value of a 'bindable' property
STDMETHODIMP CHTMLParser::OnChanged(DISPID dispID)
{
    if (DISPID_READYSTATE == dispID)
    {
        EXCEPINFO  excepInfo;
        UINT       uArgErr;

        VARIANT    varResult  = {0};
        DISPPARAMS dispparams = {NULL, NULL, 0, 0};
        

        // check the value of the readystate property
        assert(m_pMSHTML);

        if (SUCCEEDED(m_pMSHTML->Invoke(DISPID_READYSTATE, 
                                        IID_NULL, 
                                        LOCALE_SYSTEM_DEFAULT, 
                                        DISPATCH_PROPERTYGET, 
                                        &dispparams, 
                                        &varResult, 
                                        &excepInfo, 
                                        &uArgErr)))
        {
            assert(VT_I4 == V_VT(&varResult));

            if (READYSTATE_COMPLETE == (READYSTATE)V_I4(&varResult))
                SetEvent(m_hEventTridentDone);
            
            VariantClear(&varResult);
        }
    }
    return NOERROR;
}

STDMETHODIMP CHTMLParser::OnRequestEdit(DISPID dispID)
{
    return NOERROR; 
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IOleClientSite implementation
///////
///////

STDMETHODIMP CHTMLParser::SaveObject()
{ 
    return E_NOTIMPL; 
}
    
STDMETHODIMP CHTMLParser::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CHTMLParser::GetContainer(IOleContainer** ppContainer)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CHTMLParser::ShowObject()
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CHTMLParser::OnShowWindow(BOOL fShow)
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CHTMLParser::RequestNewObjectLayout()
{ 
    return E_NOTIMPL; 
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

STDMETHODIMP CHTMLParser::GetTypeInfoCount(UINT* pctinfo)                                  
{ 
    return E_NOTIMPL; 
}
    
STDMETHODIMP CHTMLParser::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo)    
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CHTMLParser::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgDispId)                    
{ 
    return E_NOTIMPL; 
}

// MSHTML Queries for the IDispatch interface of the host through the IOleClientSite
// interface that MSHTML is passed through its implementation of IOleObject::SetClientSite()
STDMETHODIMP CHTMLParser::Invoke(DISPID      dispIdMember,
                                 REFIID      riid,
                                 LCID        lcid,
                                 WORD        wFlags,
                                 DISPPARAMS* pDispParams,
                                 VARIANT*    pvarResult,
                                 EXCEPINFO*  pExcepInfo,
                                 UINT*       puArgErr)
{
    if (!pvarResult)
        return E_POINTER;
    
    switch(dispIdMember)
    {
        case DISPID_AMBIENT_DLCONTROL: 
        {
            // respond to this ambient to indicate that we only want to
            // download the page, but we don't want to run scripts,
            // Java applets, or ActiveX controls
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) =  DLCTL_DOWNLOADONLY | 
                                DLCTL_NO_SCRIPTS | 
                                DLCTL_NO_JAVA |
                                DLCTL_NO_DLACTIVEXCTLS |
                                DLCTL_NO_RUNACTIVEXCTLS;
            break;
        }    
        default:
            return DISP_E_MEMBERNOTFOUND;
    }
    return NOERROR;
}


// A more traditional form of persistence. 
// MSHTML performs this asynchronously as well.
HRESULT CHTMLParser::LoadURLFromFile(BSTR   bstrURL)
{
    HRESULT hr;

    LPPERSISTFILE  pPF;
    // MSHTML supports file persistence for ordinary files.
    if ( SUCCEEDED(hr = m_pMSHTML->QueryInterface(IID_IPersistFile, (LPVOID*) &pPF)))
    {
        hr = pPF->Load(bstrURL, 0);
        pPF->Release();
    }

    return hr;
}

// This function will attached trient to a location FILE: URL, and ensure that it is ready
// to be walked
HRESULT CHTMLParser::InitForMSHTML()
{
    HRESULT hr;
    LPCONNECTIONPOINTCONTAINER pCPC = NULL;
    LPOLEOBJECT pOleObject = NULL;
    LPOLECONTROL pOleControl = NULL;

    // Create an instance of an dynamic HTML document
    if (FAILED(hr = CoCreateInstance( CLSID_HTMLDocument, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IHTMLDocument2, 
                    (LPVOID*)&m_pTrident )))
    {
        goto Error;
    }

    
    if (FAILED(hr = m_pTrident->QueryInterface(IID_IOleObject, (LPVOID*)&pOleObject)))
    {
        goto Error;
    }
    hr = pOleObject->SetClientSite((IOleClientSite*)this);
    pOleObject->Release();

    if (FAILED(hr = m_pTrident->QueryInterface(IID_IOleControl, (LPVOID*)&pOleControl)))
    {
        goto Error;
    }
    hr = pOleControl->OnAmbientPropertyChange(DISPID_AMBIENT_DLCONTROL);
    pOleControl->Release();

    // Hook up sink to catch ready state property change
    if (FAILED(hr = m_pTrident->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pCPC)))
    {
        goto Error;
    }

    if (FAILED(hr = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &m_pCP)))
    {
        goto Error;
    }

    m_hrConnected = m_pCP->Advise((LPUNKNOWN)(IPropertyNotifySink*)this, &m_dwCookie);
    
Error:
    if (pCPC) 
        pCPC->Release();

    return hr;
}

// Clean up connection point
HRESULT CHTMLParser::TermForMSHTML()
{
    HRESULT hr = NOERROR;

    // Disconnect from property change notifications
    if (SUCCEEDED(m_hrConnected))
    {
        hr = m_pCP->Unadvise(m_dwCookie);
    }

    // Release the connection point
    if (m_pCP) 
        m_pCP->Release();

    if (m_pTrident)
        m_pTrident->Release();
        
    return hr;
}

HRESULT CHTMLParser::AttachToMSHTML(BSTR bstrURL)
{
    HRESULT hr;
    
    // Release any previous instance of the HTML document pointer we might be holding on to
    if(m_pMSHTML)
    {
        m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
    
    m_pMSHTML = m_pTrident;
    m_pMSHTML->AddRef();
    
    m_hEventTridentDone = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    hr = LoadURLFromFile(bstrURL);
    if (SUCCEEDED(hr) || (E_PENDING == hr))
    {
        if (m_hEventTridentDone)
        {
            MSG     msg;
            DWORD   dwRetCode;
            HANDLE  hEventList[1];
            hEventList[0] = m_hEventTridentDone;
    
            while (TRUE)
            {
                // We will wait on window messages and also the named event.
                dwRetCode = MsgWaitForMultipleObjects(1, 
                                                  &hEventList[0], 
                                                  FALSE, 
                                                  300000,            // 5 minutes
                                                  QS_ALLINPUT);

                // Determine why we came out of MsgWaitForMultipleObjects().  If
                // we timed out then let's do some TrialWatcher work.  Otherwise
                // process the message that woke us up.
                if (WAIT_TIMEOUT == dwRetCode)
                {
                    break;
                }
                else if (WAIT_OBJECT_0 == dwRetCode)
                {
                    break;
                }
                else if (WAIT_OBJECT_0 + 1 == dwRetCode)
                {
                    // Process all messages in the Queue, since MsgWaitForMultipleObjects
                    // will not do this for us
                    while (TRUE)
                    {   
                        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                            if (WM_QUIT == msg.message)
                            {
                                break;
                            }
                            else
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }                                
                        } 
                        else
                        {
                            break;
                        }                   
                    }
                }
            }
            
            CloseHandle(m_hEventTridentDone);
            m_hEventTridentDone = 0;
        }            
        else
        {
            // If we were pending, and we could not wait, we got a problem...
            if(E_PENDING == hr)
                hr = E_FAIL;
        }
    }
    return (hr);
}

HRESULT CHTMLParser::AttachToDocument(IWebBrowser2 *lpWebBrowser)
{
    HRESULT     hr;
    LPDISPATCH  pDisp; 
   
    // Release any previous instance of the HTML document pointer we might be holding on to
    if(m_pMSHTML)
    {
        // If the m_pMSHMTL is NOT our internal Trident object (for walking files)
        // then sombody did not do a detach, so we need to release the previous
        // MSHTML object
        if (m_pMSHTML != m_pTrident)
            m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
       
    // Make sure we have a webbrowser to grab onto      
    assert(lpWebBrowser);

    // Get the document pointer from this webbrowser.
    if (SUCCEEDED(hr = lpWebBrowser->get_Document(&pDisp)))  
    {
        if (pDisp)
        {
            hr = pDisp->QueryInterface( IID_IHTMLDocument2, (LPVOID*)&m_pMSHTML );
            // Paranoia, but trident/shdocvw might say OK, but really not give us a document
            if (!m_pMSHTML)
                hr = E_FAIL;
                
            pDisp->Release();                
        }
        else
        {
            hr = E_FAIL;                
        }            
    }
    return (hr);    
}


HRESULT CHTMLParser::Detach()
{
   if(m_pMSHTML)
    {
        // If the m_pMSHMTL is NOT our internal Trident object (for walking files)
        // then sombody did not do a detach, so we need to release the previous
        // MSHTML object
        if (m_pMSHTML != m_pTrident)
            m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
    return S_OK;
}


HRESULT CHTMLParser::ConcatURLValue(BSTR bstrValue, BSTR bstrName, WCHAR* lpszQuery)
{

    if(bstrName)
    {
        // Append the Name
        lstrcat(lpszQuery, bstrName);
        lstrcat(lpszQuery, cszEquals);
     
        if(bstrValue)
        {
            //we need to be three times as big since 1 char decoded == 3 char encoded
            size_t cch = (lstrlen(bstrValue) + 1) * 3;
            WCHAR* szVal = (WCHAR*)malloc(BYTES_REQUIRED_BY_CCH(cch));
            lstrcpy(szVal, bstrValue);
            URLEncode(szVal, cch);
            lstrcat(lpszQuery, szVal); 
            free(szVal);
            SysFreeString(bstrValue);            
        }
        lstrcat(lpszQuery, cszAmpersand); 

        SysFreeString(bstrName);
    }

    return S_OK;
}

HRESULT CHTMLParser::CreateQueryString
(
    IHTMLFormElement    *pForm,
    LPWSTR               lpszQuery
)    
{

    VARIANT vIndex;
    

    HRESULT                   hr            = E_FAIL;
    long                      lFormLength   = 0;
    VARIANT                   var2          = { 0 };
    LPDISPATCH                pDisp         = NULL;
    IHTMLButtonElement*       pButton       = NULL;
    IHTMLInputButtonElement*  pInputButton  = NULL;
    IHTMLInputFileElement*    pInputFile    = NULL;
    IHTMLInputHiddenElement*  pInputHidden  = NULL;
    IHTMLInputTextElement*    pInputText    = NULL;
    IHTMLSelectElement*       pSelect       = NULL;
    IHTMLTextAreaElement*     pTextArea     = NULL;
    IHTMLOptionButtonElement* pOptionButton = NULL;
    BSTR                      bstrName      = NULL;
    BSTR                      bstrValue     = NULL;
                    
    vIndex.vt = VT_UINT;
     
    if (SUCCEEDED(pForm->get_length(&lFormLength)))
    {
        for (int i = 0; i < lFormLength; i++)
        {
            vIndex.lVal = i;
           
            if (SUCCEEDED(hr = pForm->item( vIndex, var2, &pDisp )))
            {
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputHiddenElement, (LPVOID*)&pInputHidden )))
                {
                    //We could take out the repetative calls to get_name/get_value but that would require 
                    //us to make a sketchy cast
                    if (SUCCEEDED(pInputHidden->get_name(&bstrName))   && 
                        SUCCEEDED(pInputHidden->get_value(&bstrValue)))
                    {
                        ConcatURLValue(bstrValue, bstrName, lpszQuery);
                    }
                    // Release the interface pointer                    
                    pInputHidden->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputTextElement, (LPVOID*)&pInputText )))
                {               
                    if (SUCCEEDED(pInputText->get_name(&bstrName)) &&
                        SUCCEEDED(pInputText->get_value(&bstrValue)) )
                    {
                        ConcatURLValue(bstrValue, bstrName, lpszQuery);
                    }
                    
                    // Release the interface pointer                    
                    pInputText->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLSelectElement, (LPVOID*)&pSelect )))
                {                
                    if (SUCCEEDED(pSelect->get_name(&bstrName)) &&
                        SUCCEEDED(pSelect->get_value(&bstrValue)) )
                    {
                        ConcatURLValue(bstrValue, bstrName, lpszQuery);
                    }
                    
                    // Release the interface pointer                    
                    pSelect->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLTextAreaElement, (LPVOID*)&pTextArea )))
                {
                                    
                    if (SUCCEEDED(pTextArea->get_name(&bstrName)) &&
                        SUCCEEDED(pTextArea->get_value(&bstrValue)) )
                    {
                        ConcatURLValue(bstrValue, bstrName, lpszQuery);
                    }
                    
                    // Release the interface pointer                    
                    pTextArea->Release();
                }

                // First check to see if this is an OptionButton.
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLOptionButtonElement, (LPVOID*)&pOptionButton )))
                {
                    BSTR bstr = NULL;
                    
                    // See if it is a Radio or a CheckBox
                    if (SUCCEEDED(pOptionButton->get_type(&bstr)))
                    {
                        LPWSTR   lpszType = bstr;
                        
                        if ((lstrcmpi(lpszType, L"radio") == 0) || (lstrcmpi(lpszType, L"checkbox") == 0))
                        {
                            short bChecked;
                            // See if the button is checked. If it is, then it needs to be
                            // added to the query string
                            if (SUCCEEDED(pOptionButton->get_checked(&bChecked)))
                            {
                                if(bChecked)
                                {
                                    if ( SUCCEEDED(pOptionButton->get_name(&bstrName)) &&
                                         SUCCEEDED(pOptionButton->get_value(&bstrValue)) )
                                    {
                                        ConcatURLValue(bstrValue, bstrName, lpszQuery);
                                    }

                                }
                            }
                        }
                        SysFreeString(bstr);
                        
                    }
                    
                    // Release the interface
                    pOptionButton->Release();
                    continue;
                }                                
                
                // For the rest we need to form Name=Value pairs
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLButtonElement, (LPVOID*)&pButton )))
                {                 
                    if (SUCCEEDED(pButton->get_name(&bstrName)) &&
                        SUCCEEDED(pButton->get_value(&bstrValue)) )
                    {
                        ConcatURLValue(bstrValue, bstrName, lpszQuery);
                    }
                    
                    // Release the interface pointer                    
                    pButton->Release();
                    continue;
                }
                
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputFileElement, (LPVOID*)&pInputFile )))
                {                   
                    if (SUCCEEDED(pInputFile->get_name(&bstrName)) &&
                        SUCCEEDED(pInputFile->get_value(&bstrValue)) )
                    {
                        ConcatURLValue(bstrValue, bstrName, lpszQuery);
                    }
                    
                    // Release the interface pointer                    
                    pInputFile->Release();
                    continue;
                }
                pDisp->Release();
            }                
        }
    }
    
    // Null out the last Ampersand, since we don't know when we added the last pair, so we got
    // a trailing ampersand
    lpszQuery[lstrlen(lpszQuery)-1] = L'\0';
    
    return S_OK;
}

HRESULT CHTMLParser::get_QueryStringForForm(IDispatch* pDisp, WCHAR* szUrl)
{

    HRESULT           hr                   = E_FAIL;   //don't assume succeess
    WCHAR             szQuery [MAX_PATH*7] = L"\0";
    IHTMLFormElement* pForm                = NULL;
    BSTR              bstrAction           = NULL;
  
    if (!pDisp)
        return (E_FAIL);
               
    if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLFormElement, (void**)&pForm)) && pForm)
    {
        // Get the Action for the Next Form
        if (SUCCEEDED(pForm->get_action(&bstrAction)) && bstrAction)
        {
            lstrcpy(szUrl, bstrAction);
            lstrcat(szUrl, cszQuestion);
    
            SysFreeString(bstrAction);

            // Get the Query String
            if (SUCCEEDED(CreateQueryString(pForm, szQuery)))
            {
                lstrcat(szUrl, szQuery);
            }             
        }    
    }    
    return hr;
}


void CHTMLParser::URLEncode(WCHAR* pszUrl, size_t cchUrlMax)
{   
    assert(pszUrl);
    WCHAR* pszEncoded = NULL;   
    WCHAR* pchEncoded = NULL;   
    WCHAR* pchUrl   = pszUrl + lstrlen(pszUrl);
    int   cchUrl   = (int)(pchUrl-pszUrl);
    
    WCHAR  c;

    if ((size_t)(cchUrl * 3) < cchUrlMax)
    {
        
        pszEncoded = (WCHAR*)malloc(BYTES_REQUIRED_BY_CCH(cchUrl * 3 + 1));
        if(pszEncoded)
        {
            ZeroMemory(pszEncoded, BYTES_REQUIRED_BY_CCH(cchUrl * 3 + 1));
            
            for(pchUrl = pszUrl, pchEncoded = pszEncoded; 
                L'\0' != *pchUrl; 
                pchUrl++
                )
            {
                switch(*pchUrl)
                {
                    case L' ': //SPACE
                        lstrcpyn(pchEncoded, L"+", 1);
                        pchEncoded+=1;
                        break;
                    case L'#':
                        lstrcpyn(pchEncoded, L"%23", 3);
                        pchEncoded+=3;
                        break;
                    case L'&':
                        lstrcpyn(pchEncoded, L"%26", 3);
                        pchEncoded+=3;
                        break;
                    case L'%':
                        lstrcpyn(pchEncoded, L"%25", 3);
                        pchEncoded+=3;
                        break;
                    case L'=':
                        lstrcpyn(pchEncoded, L"%3D", 3);
                        pchEncoded+=3;
                        break;
                    case L'<':
                        lstrcpyn(pchEncoded, L"%3C", 3);
                        pchEncoded+=3;
                        break;
                    case L'+':
                        lstrcpyn(pchEncoded, L"%2B", 3);
                        pchEncoded += 3;
                        break;
                    default:
                        *pchEncoded++ = *pchUrl; 
                        break;          
                }
            }

            // String should be null-terminated since the buffer was zeroed
            //
            ASSERT(L'\0' == *pchEncoded);

            // Did we overflow the buffer?
            //
            ASSERT(pchEncoded - pszEncoded < cchUrlMax);

            lstrcpy(pszUrl , pszEncoded);
            free(pszEncoded);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\htmparse.h ===
#ifndef _HTMPARSE_H_ 
#define _HTMPARSE_H_


#include <windows.h>
#include <assert.h>
#include <oleauto.h>
#include <mshtml.h>
#include <exdisp.h>
//#include <exdispid.h>

#include "appdefs.h"

class CHTMLParser : public IPropertyNotifySink, IOleClientSite, IDispatch
{
private:
    ULONG             m_cRef;
 
    DWORD             m_dwCookie;
    LPCONNECTIONPOINT m_pCP;
    HRESULT           m_hrConnected;
    IHTMLDocument2*   m_pTrident;
    IHTMLDocument2*   m_pMSHTML;
    HANDLE            m_hEventTridentDone;        

    HRESULT CreateQueryString   (IHTMLFormElement* pForm, LPWSTR lpszQuery);  
    void    URLEncode           (WCHAR* pszUrl, size_t cchMax);
    HRESULT ConcatURLValue      (BSTR bstrValue, BSTR bstrName, WCHAR* lpszQuery);

public:
    CHTMLParser  (); 
    ~CHTMLParser ();
  
    // IUnknown methods
    STDMETHODIMP   QueryInterface           (REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef             ();
    STDMETHODIMP_(ULONG) Release            (); 

    // IPropertyNotifySink methods
    STDMETHOD  (OnChanged)              (DISPID dispID);
    STDMETHOD  (OnRequestEdit)          (DISPID dispID);

    // IOleClientSite methods
    STDMETHOD  (SaveObject)             ();
    STDMETHOD  (GetMoniker)             (DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk);
    STDMETHOD  (GetContainer)           (IOleContainer** ppContainer);
    STDMETHOD  (ShowObject)             ();
    STDMETHOD  (OnShowWindow)           (BOOL fShow);
    STDMETHOD  (RequestNewObjectLayout) ();
                                                                                                                        
    // IDispatch methods                                                                                             
    STDMETHOD  (GetTypeInfoCount)       (UINT* pctinfo);
    STDMETHOD  (GetTypeInfo)            (UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
    STDMETHOD  (GetIDsOfNames)          (REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgDispId);
    STDMETHOD  (Invoke)                 (DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr);
    
    HRESULT    LoadURLFromFile          (BSTR bstrURL);
    HRESULT    InitForMSHTML            ();
    HRESULT    TermForMSHTML            ();
    HRESULT    AttachToMSHTML           (BSTR bstrURL);
    HRESULT    AttachToDocument         (IWebBrowser2* lpWebBrowser);
    HRESULT    Detach                   ();
      
    HRESULT    get_QueryStringForForm   (IDispatch* pDisp, WCHAR* szUrl);
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\language.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  LANGUAGE.H - Header for the implementation of CLanguage
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#ifndef _LANGUAGE_H_
#define _LANGUAGE_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>

#define LANGUAGE_REBOOT_NEVER   0
#define LANGUAGE_REBOOT_NOW     1
#define LANGUAGE_REBOOT_END     2

// BUGBUG: SetupGetLocaleInfo will return sorted array so NAMELOOKUPELEMENT will not be needed.
typedef struct tagNAMELOOKUPELEMENT {
    LPWSTR  pszName;
    int     nIndex;
} NAMELOOKUPELEMENT, far *LPNAMELOOKUPELEMENT;


class CLanguage : public IDispatch
{
private:

    ULONG   m_cRef;

    DWORD   m_lRebootState;

    long    m_lRegionIndex;
    long    m_lRegionDefault;
    long    m_lRegionTotal;
    POOBE_LOCALE_INFO   m_poliRegions;

    long   m_lLangIndex;
    long   m_lLangDefault;
    long   m_lLangTotal;
    POOBE_LOCALE_INFO   m_poliLangs;

    long    m_lKeyboardLayoutIndex;
    long    m_lKeyboardLayoutDefault;
    long    m_lKeyboardLayoutTotal;
    POOBE_LOCALE_INFO   m_poliKeyboards;

    long    m_DefaultRegion;
    long    m_DefaultLanguage;
    long    m_DefaultKeyboard;

    //GET functions
    HRESULT get_NumOfRegions         (long* plVal);
    HRESULT get_RegionIndex          (long* plVal);
    HRESULT get_RegionName           (long lIndex, BSTR* pbstrVal);

    HRESULT get_NumOfLangs           (long* plVal);
    HRESULT get_LangIndex            (long* plVal);
    HRESULT get_LangName             (long lIndex, BSTR* pbstrVal);

    HRESULT get_NumOfKeyboardLayouts (long* plVal);
    HRESULT get_KeyboardLayoutIndex  (long* plVal);
    HRESULT get_KeyboardLayoutName   (long lIndex, BSTR* pbstrVal);

    //SET functions
    HRESULT set_RegionIndex          (long lVal);
    HRESULT set_LangIndex            (long lVal);
    HRESULT set_KeyboardLayoutIndex  (long lVal);

    HRESULT SaveSettings             ();
    VOID    GetPhoneCountries        ();

public:

     CLanguage ();
    ~CLanguage ();

    // Public GET functions
    HRESULT get_RebootState          (long* plVal);

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef      ();
    STDMETHODIMP_(ULONG) Release     ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount)     (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)          (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)        (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)               (DISPID dispidMember, REFIID riid,
                                      LCID lcid, WORD wFlags,
                                      DISPPARAMS* pdispparams,
                                      VARIANT* pvarResult,
                                      EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\passport.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  PASSPORT.H - Header for the implementation of CPassport
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 

#ifndef _PASSPORT_H_ 
#define _PASSPORT_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>


class CPassport : public IDispatch
{  
private:
    ULONG m_cRef;
    BSTR  m_bstrID;
    BSTR  m_bstrPassword;
    BSTR  m_bstrLocale;

    //GET functions
    HRESULT get_PassportID       (BSTR* pbstrVal);
    HRESULT get_PassportPassword (BSTR* pbstrVal);
    HRESULT get_PassportLocale   (BSTR* pbstrVal);

    //SET functions
    HRESULT set_PassportID       (BSTR  bstrVal);
    HRESULT set_PassportPassword (BSTR  bstrVal);
    HRESULT set_PassportLocale   (BSTR  bstrVal);

public: 
    
     CPassport ();
    ~CPassport ();
    
    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\main.cpp ===
/*****************************************************************************\

    MAIN.CPP

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Contains...

    1/99 - JCOHEN
        Created main program file.

\*****************************************************************************/

#include "precomp.h"
#include "msobmain.h"
#include "setupkey.h"
#include "resource.h"

#define ICWDESKTOPCHANGED           L"DesktopChanged"
#define MAX_MESSAGE_LEN             256
#define ICWSETTINGSPATH             L"Software\\Microsoft\\Internet Connection Wizard"
#define ICW_REGKEYCOMPLETED         L"Completed"
#define REGSTR_PATH_SETUPKEY        REGSTR_PATH_SETUP REGSTR_KEY_SETUP
#define REGSTR_PATH_SYSTEMSETUPKEY  L"System\\Setup"
#define REGSTR_VALUE_CMDLINE        L"CmdLine"
#define REGSTR_VALUE_SETUPTYPE      L"SetupType"
#define REGSTR_VALUE_MINISETUPINPROGRESS L"MiniSetupInProgress"
#define REGSTR_PATH_IEONDESKTOP     REGSTR_PATH_IEXPLORER L"\\AdvancedOptions\\BROWSE\\IEONDESKTOP"
static const WCHAR g_szRegPathWelcomeICW[]  = L"Welcome\\ICW";
static const WCHAR g_szAllUsers[]           = L"All Users";
static const WCHAR g_szConnectApp[]         = L"ICWCONN1.EXE";
static const WCHAR g_szConnectLink[]        = L"Connect to the Internet";
static const WCHAR g_szOEApp[]              = L"MSINM.EXE";
static const WCHAR g_szOELink[]             = L"Outlook Express";
static const WCHAR g_szRegPathICWSettings[] = L"Software\\Microsoft\\Internet Connection Wizard";
static const WCHAR g_szRegValICWCompleted[] = L"Completed";

WCHAR g_szShellNext       [MAX_PATH+1]      = L"\0nogood";
WCHAR g_szShellNextParams [MAX_PATH+1]      = L"\0nogood";
HINSTANCE g_hInstance                       = NULL;

/*******************************************************************

    NAME:       RegisterComObjects

    SYNOPSIS:   App entry point

********************************************************************/
BOOL SelfRegisterComObject(LPWSTR szDll, BOOL fRegister)
{
    HINSTANCE hModule = LoadLibrary(szDll);
    BOOL      bRet    = FALSE;

    if (hModule)
    {
        HRESULT (STDAPICALLTYPE *pfn)(void);

        if (fRegister)
            (FARPROC&)pfn = GetProcAddress(hModule, REG_SERVER);
        else
            (FARPROC&)pfn = GetProcAddress(hModule, UNREG_SERVER);

        if (pfn && SUCCEEDED((*pfn)()))
            bRet = TRUE;

        FreeLibrary(hModule);
    }

    return bRet;
}


// This undoes what DoDesktopChanges did
void UndoDesktopChanges()
{

    WCHAR   szConnectTotheInternetTitle[MAX_PATH];
    HKEY    hkey;

    // Verify that we really changed the desktop
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      ICWSETTINGSPATH,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkey))
    {
        DWORD   dwDesktopChanged = 0;
        DWORD   dwTmp = sizeof(DWORD);
        DWORD   dwType = 0;

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                        ICWDESKTOPCHANGED,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwDesktopChanged,
                        &dwTmp))
        {
        }
        RegCloseKey(hkey);

        // Bail if the desktop was not changed by us
        if(!dwDesktopChanged)
        {
            return;
        }
    }

    // Always nuke the Connect to the internet icon
   HINSTANCE hInst = LoadLibrary(OOBE_MAIN_DLL);

    if (!LoadString(hInst,
                    IDS_CONNECT_DESKTOP_TITLE,
                    szConnectTotheInternetTitle,
                    MAX_CHARS_IN_BUFFER(szConnectTotheInternetTitle)))
    {
        lstrcpy(szConnectTotheInternetTitle, g_szConnectLink);
    }

    RemoveDesktopShortCut(szConnectTotheInternetTitle);
}

void StartIE
(
    LPWSTR  lpszURL
)
{
    WCHAR   szIEPath[MAX_PATH];
    HKEY    hkey;

    // first get the app path
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_APPPATHS,
                     0,
                     KEY_READ,
                     &hkey) == ERROR_SUCCESS)
    {

        DWORD dwTmp = sizeof(szIEPath);
        if(RegQueryValue(hkey, L"iexplore.exe", szIEPath, (PLONG)&dwTmp) != ERROR_SUCCESS)
        {
            ShellExecute(NULL, L"open",szIEPath,lpszURL,NULL,SW_NORMAL);
        }
        else
        {
            ShellExecute(NULL, L"open",L"iexplore.exe",lpszURL,NULL,SW_NORMAL);

        }
        RegCloseKey(hkey);
    }
    else
    {
        ShellExecute(NULL, L"open",L"iexplore.exe",lpszURL,NULL,SW_NORMAL);
    }

}

void HandleShellNext()
{
    DWORD dwVal  = 0;
    DWORD dwSize = sizeof(dwVal);
    HKEY  hKey   = NULL;

    if(RegOpenKeyEx(HKEY_CURRENT_USER,
                    ICWSETTINGSPATH,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey,
                    ICW_REGKEYCOMPLETED,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

        RegCloseKey(hKey);
    }

    if (dwVal)
    {
        TRACE3(L"Starting IE because HKCU\\%s\\%s = %d", ICWSETTINGSPATH, ICW_REGKEYCOMPLETED, dwVal);

        UndoDesktopChanges();

        if (PathIsURL(g_szShellNext))
        {
            TRACE1(L"Navigating to %s", g_szShellNext);
            StartIE(g_szShellNext);
        }
        else if(g_szShellNext[0] != L'\0')
        {
            // Let the shell deal with it
            TRACE1(L"ShellExecuting %s", g_szShellNext);
            ShellExecute(NULL, L"open",g_szShellNext,g_szShellNextParams,NULL,SW_NORMAL);
        }
    }
}


//+----------------------------------------------------------------------------
//
//    Function:    GetShellNextFromReg
//
//    Synopsis:    Reads the ShellNext key from the registry, and then parses it
//                into a command and parameter.  This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
BOOL GetShellNextFromReg
(
    LPWSTR lpszCommand,
    LPWSTR lpszParams
)
{
    BOOL    fRet                      = TRUE;
    WCHAR   szShellNextCmd [MAX_PATH] = L"\0";
    DWORD   dwShellNextSize           = sizeof(szShellNextCmd);
    LPWSTR  lpszTemp                  = NULL;
    HKEY    hkey                      = NULL;

    if( !lpszCommand || !lpszParams )
    {
        return FALSE;
    }

    if ((RegOpenKey(HKEY_CURRENT_USER, ICWSETTINGSPATH, &hkey)) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkey,
                            L"ShellNext",
                            NULL,
                            NULL,
                            (BYTE *)szShellNextCmd,
                            (DWORD *)&dwShellNextSize) != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto GetShellNextFromRegExit;
        }
    }
    else
    {
        fRet = FALSE;
        goto GetShellNextFromRegExit;
    }

    //
    // This call will parse the first token into lpszCommand, and set szShellNextCmd
    // to point to the remaining tokens (these will be the parameters).  Need to use
    // the pszTemp var because GetCmdLineToken changes the pointer's value, and we
    // need to preserve lpszShellNextCmd's value so that we can GlobalFree it later.
    //
    lpszTemp = szShellNextCmd;
    GetCmdLineToken( &lpszTemp, lpszCommand );

    lstrcpy( lpszParams, lpszTemp );

    //
    // it's possible that the shellNext command was wrapped in quotes for
    // parsing purposes.  But since ShellExec doesn't understand quotes,
    // we now need to remove them.
    //
    if( L'"' == lpszCommand[0] )
    {
        //
        // get rid of the first quote
        // note that we're shifting the entire string beyond the first quote
        // plus the terminating NULL down by one byte.
        //
        memmove( lpszCommand, &(lpszCommand[1]), BYTES_REQUIRED_BY_SZ(lpszCommand) );

        //
        // now get rid of the last quote
        //
        lpszCommand[lstrlen(lpszCommand) - 1] = L'\0';
    }

GetShellNextFromRegExit:
    if (hkey)
        RegCloseKey(hkey);
    return fRet;
}


//+----------------------------------------------------------------------------
//
//    Function:    RemoveShellNextFromReg
//
//    Synopsis:    deletes the ShellNext reg key if present. This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
void RemoveShellNextFromReg( void )
{
    HKEY    hkey;

    if ((RegOpenKey(HKEY_CURRENT_USER, ICWSETTINGSPATH, &hkey)) == ERROR_SUCCESS)
    {
        RegDeleteValue(hkey, L"ShellNext");
        RegCloseKey(hkey);
    }
}

//GetShellNext
//
// 5/21/97    jmazner    Olympus #4157
// usage: /shellnext c:\path\executeable [parameters]
// the token following nextapp will be shellExec'd at the
// end of the "current" path.  It can be anything that the shell
// knows how to handle -- an .exe, a URL, etc..  If executable
// name contains white space (eg: c:\program files\foo.exe), it
// should be wrapped in double quotes, "c:\program files\foo.exe"
// This will cause us to treat it as a single token.
//
// all consecutive subsequent tokens will
// be passed to ShellExec as the parameters until a token is
// encountered of the form /<non-slash character>.  That is to say,
// the character combination // will be treated as an escape character
//
// this is easiest to explain by way of examples.
//
// examples of usage:
//
//    icwconn1.exe /shellnext "C:\prog files\wordpad.exe" file.txt
//    icwconn1.exe /prod IE /shellnext msimn.exe /promo MCI
//  icwconn1.exe /shellnext msimn.exe //START_MAIL /promo MCI
//
// the executeable string and parameter string are limited to
// a length of MAX_PATH
//
BOOL GetShellNextToken(LPWSTR szCmdLine, LPWSTR szOut)
{
    if (lstrcmpi(szOut, CMD_SHELLNEXT)==0)
    {
        // next token is expected to be white space
        GetCmdLineToken(&szCmdLine, szOut);

        if (szOut[0])
        {
            ZeroMemory(g_szShellNext, sizeof(g_szShellNext));
            ZeroMemory(g_szShellNextParams, sizeof(g_szShellNextParams));

            // Read white space
            GetCmdLineToken(&szCmdLine, szOut);
            //this should be the thing to ShellExec
            if(*szCmdLine != L'/')
            {
                // watch closely, this gets a bit tricky
                //
                // if this command begins with a double quote, assume it ends
                // in a matching quote.  We do _not_ want to store the
                // quotes, however, since ShellExec doesn't parse them out.
                if( L'"' != szOut[0] )
                {
                    // no need to worry about any of this quote business
                    lstrcpy( g_szShellNext, szOut );
                }
                else
                {
                    lstrcpy( g_szShellNext, &szOut[1] );
                    g_szShellNext[lstrlen(g_szShellNext) - 1] = L'\0';
                }
                TRACE1(L"g_szShellNext = %s", g_szShellNext);

                // now read in everything up to the next command line switch
                // and consider it to be the parameter.  Treat the sequence
                // "//" as an escape sequence, and allow it through.
                // Example:
                //        the token /whatever is considered to be a switch to
                //        icwconn1, and thus will break us out of the whle loop.
                //
                //        the token //something is should be interpreted as a
                //        command line /something to the the ShellNext app, and
                //        should not break us out of the while loop.
                GetCmdLineToken(&szCmdLine, szOut);
                while( szOut[0] )
                {
                    if( L'/' == szOut[0] )
                    {
                        if( L'/' != szOut[1] )
                        {
                            // it's not an escape sequence, so we're done
                            break;
                        }
                        else
                        {
                            // it is an escape sequence, so store it in
                            // the parameter list, but remove the first /
                            lstrcat( g_szShellNextParams, &szOut[1] );
                        }
                    }
                    else
                    {
                        lstrcat( g_szShellNextParams, szOut );
                    }

                    GetCmdLineToken(&szCmdLine, szOut);
                }
                TRACE1(L"g_szShellNextParams = %s", g_szShellNextParams);
                return TRUE;
            }
        }
    }
    return FALSE;

}

void ParseCommandLine(LPTSTR lpszCmdParam, APMD *pApmd, DWORD *pProp, int *pRmdIndx)
{
    if(lpszCmdParam && pApmd && pProp && pRmdIndx)
    {
        WCHAR szOut[MAX_PATH];
        GetCmdLineToken(&lpszCmdParam, szOut);

        while (szOut[0])
        {
            if (0 == lstrcmpi(szOut, CMD_FULLSCREENMODE))
            {   // For now, full screen => OEM OOBE mode
                *pProp |= (PROP_FULLSCREEN | PROP_OOBE_OEM);
                *pApmd = APMD_OOBE;
            }
            else if (0 == lstrcmpi(szOut, CMD_RETAIL))
            {   // retail => full screen => OOBE mode
                *pProp |= PROP_FULLSCREEN;
                *pProp &= ~PROP_OOBE_OEM;
                *pApmd = APMD_OOBE;
            }
            else if (0 == lstrcmpi(szOut, CMD_PRECONFIG))
            {
                *pApmd = APMD_MSN;
            }
            else if (0 == lstrcmpi(szOut, CMD_OFFLINE))
            {
                *pApmd = APMD_MSN;
            }
            else if (0 == lstrcmpi(szOut, CMD_SETPWD))
            {
                *pProp |= PROP_SETCONNECTIOD;
            }
            else if (0 == lstrcmpi(szOut, CMD_OOBE))
            {
                *pApmd = APMD_OOBE;
            }
            else if (0 == lstrcmpi(szOut, CMD_REG))
            {
                *pApmd = APMD_REG;
            }
            else if (0 == lstrcmpi(szOut, CMD_ISP))
            {
                *pApmd = APMD_ISP;
            }
            else if (0 == lstrcmpi(szOut, CMD_ACTIVATE))
            {
                *pApmd = APMD_ACT;
            }
            else if (0 == lstrcmpi(szOut, CMD_1))
            {
                *pRmdIndx = 1;
            }
            else if (0 == lstrcmpi(szOut, CMD_2))
            {
                *pRmdIndx = 2;
            }
            else if (0 == lstrcmpi(szOut, CMD_3))
            {
                *pRmdIndx = 3;
            }
            else if (0 == lstrcmpi(szOut, CMD_MSNMODE))
            {
                *pApmd = APMD_MSN;
                *pProp |= PROP_CALLFROM_MSN;
            }
            else if (0 == lstrcmpi(szOut, CMD_ICWMODE))
            {
                *pApmd = APMD_MSN;
            }
            else if (GetShellNextToken(lpszCmdParam, szOut))
            {
                //*pApmd = APMD_DEFAULT;
            }
            else if (0 == lstrcmpi(szOut, CMD_2NDINSTANCE))
            {
                *pProp |= PROP_2NDINSTANCE;
            }

            GetCmdLineToken(&lpszCmdParam, szOut);
        }
    }
}

void AutoActivation()
{
    // See if we are in an unattend case
    WCHAR File   [MAX_PATH*2] = L"\0";
    DWORD dwExit;
    BOOL AutoActivate = FALSE;

    TRACE( L"Starting AutoActivation");
    if (GetCanonicalizedPath(File, INI_SETTINGS_FILENAME))
    {
        TRACE1( L"GetCanonicalizedPath: %s",File);
        if (GetPrivateProfileInt(OPTIONS_SECTION,
                                      L"IntroOnly",
                                      0,
                                      File) > 0)
        {
            TRACE( L"Found intro Only");
            AutoActivate = TRUE;
        }
    }
    if (AutoActivate)
    {
        // Since we did intro only call autoactivation. it checks
        // if it should run.
        ExpandEnvironmentStrings(
            TEXT("%SystemRoot%\\System32\\oobe\\oobebaln.exe /S"),
            File,
            sizeof(File)/sizeof(WCHAR));

        TRACE1( L"Launching:%s", File);
        // Launch and wait.
        // I tried without wait and the activation did not succeed.
        InvokeExternalApplicationEx(NULL, File, &dwExit, INFINITE, TRUE);
    }
    TRACE( L"AutoActivation done");
}

VOID
RunFactory(
    )
{
    TCHAR   szFileName[MAX_PATH + 32]   = TEXT("");
    DWORD   dwExit;


    if ( ( ExpandEnvironmentStrings(
            TEXT("%SystemDrive%\\sysprep\\factory.exe"),
            szFileName,
            sizeof(szFileName) / sizeof(TCHAR)) == 0 ) ||
         ( szFileName[0] == TEXT('\0') ) ||
         ( GetFileAttributes(szFileName) == 0xFFFFFFFF ) )
    {
        // If this fails, there is nothing we can really do.
        //
        TRACE( L"Factory.exe not found");

    } else {

        InvokeExternalApplicationEx(
            szFileName,
            L"-oobe",
            &dwExit,
            INFINITE,
            TRUE
            );
    }
}

void RemoveIntroOnly()
{
    WCHAR File   [MAX_PATH*2] = L"\0";
    if (GetCanonicalizedPath(File, INI_SETTINGS_FILENAME))
    {
        WritePrivateProfileString(OPTIONS_SECTION,
                                      L"IntroOnly",
                                      L"0",
                                      File);
    }
}

INT WINAPI LaunchMSOOBE(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpszCmdParam, INT nCmdShow)
{
    HANDLE Mutex;
    BOOL bRegisteredDlls = FALSE;
    BOOL bUseOleUninitialize = FALSE;
    int iReturn=1;
    APMD Apmd   = APMD_DEFAULT;
    DWORD Prop  = 0;
    int RmdIndx = 0;


    //
    // We can't use TRACE() until this is called, so don't put anything before it.
    //
    SetupOobeInitDebugLog();
    TRACE1( L"OOBE run with the following parameters: %s", lpszCmdParam );

    OOBE_SHUTDOWN_ACTION osa = SHUTDOWN_NOACTION;

    g_hInstance = hInstance;

    // Parse the command line early. The out params are passed to CObMain to
    // set the private members.
    ParseCommandLine(lpszCmdParam, &Apmd, &Prop, &RmdIndx);

    // If we are not the 2nd instance
    if (!(Prop & PROP_2NDINSTANCE))
    {
        CheckDigitalID();

        if (Apmd == APMD_OOBE) {

            CSetupKey   setupkey;

            MYASSERT(setupkey.IsValid());
            if ( Prop & PROP_OOBE_OEM ) {
                // Remove IntroOnly, just in case it is still set from the original install.
                RemoveIntroOnly();

                // reset the SetupType so that OOBe can be restarted (OEM case)
                if (ERROR_SUCCESS != setupkey.set_SetupType(SETUPTYPE_NOREBOOT)) {
                    return FALSE;
                }
            } else {

                //
                // In the retail OOBE case, clean up the registry early, in case we
                // fail to run to completion for some reason.  We need to make sure
                // we get rid of the OobeInProgress key.
                //
                CleanupForLogon(setupkey);
            }
        }

        // If we are the first instance, do the checking and register the DLLs
        // If we are the 2nd instance this is not needed.
        //Exit if MSN app window is aready running and push that window to front
        HWND hWnd = FindWindow(OOBE_MAIN_CLASSNAME, NULL);
        if(hWnd != NULL)
        {
            SetForegroundWindow(hWnd);
            if (IsIconic(hWnd))
                SendMessage(hWnd, WM_SYSCOMMAND, SC_RESTORE, NULL);

            TRACE(L"OOBE is already running in this session.");
            return 0;
        }

        // It's possible that OOBE is running in another session.  If so, we need
        // to bail out.
        Mutex = CreateMutex( NULL, TRUE, TEXT("Global\\OOBE is running") );
        if ( !Mutex || GetLastError() == ERROR_ALREADY_EXISTS ) {

            WCHAR szTitle [MAX_PATH] = L"\0";
            WCHAR szMsg   [MAX_PATH] = L"\0";

            HINSTANCE hInst = GetModuleHandle(OOBE_MAIN_DLL);

            TRACE(L"OOBE is already running in another session.");

            if(hInst) {
                LoadString(hInst, IDS_APPNAME, szTitle, MAX_CHARS_IN_BUFFER(szTitle));
                LoadString(hInst, IDS_ALREADY_RUNNING, szMsg, MAX_CHARS_IN_BUFFER(szMsg));

                MessageBox( NULL, szMsg, szTitle,  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL );
            }
            if ( Mutex ) {
                CloseHandle( Mutex );
            }
            return 0;
        }

        if(!SelfRegisterComObject(OOBE_WEB_DLL, TRUE)) {
            TRACE(L"SelfRegisterComObject() failed.");
            return 1;
        }

        if(!SelfRegisterComObject(OOBE_SHELL_DLL, TRUE)) {
            TRACE(L"SelfRegisterComObject() failed.");
            return 1;
        }

        if(!SelfRegisterComObject(OOBE_COMM_DLL, TRUE)) {
            TRACE(L"SelfRegisterComObject() failed.");
            return 1;
        }
        bRegisteredDlls = TRUE;
    }

    //If CoInit fails something is seriously messed up, run away
    if (!(Prop & PROP_FULLSCREEN))
    {
        bUseOleUninitialize = TRUE;
        // Need to use OleInitialize to get Clipboard support or Ctrl+C (Copy) does not work
        // in the edit controls on the OOBE pages.
        if(FAILED(OleInitialize(NULL))) {
            TRACE(L"OleInitialize() failed.");
            return 1;
        }

    }
    else
    {
        // Don't have the support in fullscreen OOBE.
        if(FAILED(CoInitialize(NULL))) {
            TRACE(L"CoInitialize() failed.");
            return 1;
        }
    }


    {
        // DO NOT REMOVE THIS SCOPE BLOCK.  It controls the scope of ObMain.
        // ObMain must be initialized after CoInitialize is called and
        // destroyed prior to calling CoUninitialize.
        //
        CObMain ObMain(Apmd, Prop, RmdIndx);

        // If we are the 1st instance or
        // if we are the second instance and we are in OOBE mode and in fullscreen mode
        if (!ObMain.Is2ndInstance() ||
            (ObMain.Is2ndInstance() && ObMain.FHasProperty(PROP_OOBE_OEM)))
        {
            // If not in safe mode proceed.
            //
            if (!InSafeMode())
            {
                BOOL fOemOobeMode = ObMain.InOobeMode() && ObMain.FHasProperty(PROP_OOBE_OEM);

                // Start the fullscreen background
                //
                if (!ObMain.Is2ndInstance() && ObMain.FFullScreen())
                {
                    ObMain.CreateBackground();
                }

                // Run factory.exe if we're in OEM mode.
                //
                if (fOemOobeMode && !ObMain.Is2ndInstance()) {

                    RunFactory();
                }

                // CObMain::Init contains critical initialization.  DO NOT call any other
                // CObMain methods prior to it.
                //
                if (ObMain.Init())
                {
                    if (Prop & PROP_SETCONNECTIOD)
                    {
                        ObMain.SetConnectoidInfo();
                    }
                    else if ((osa = ObMain.DisplayReboot()) != SHUTDOWN_NOACTION)
                    {
                        // Either we ran minisetup or we're done.
                        //
                        if (osa == SHUTDOWN_REBOOT)
                        {
                            ObMain.PowerDown(TRUE);
                        }
                    }
                    else
                    {
                        if (!ObMain.Is2ndInstance())
                        {
                            // If we are the 1st instance, call syssetup
                            // and start the magnifier if needed.
                            // The 2nd instance does not need this.

                            SetupOobeInitPreServices( fOemOobeMode );

                            if (ObMain.FFullScreen())
                            {
                                WCHAR WinntPath[MAX_PATH];
                                WCHAR Answer[MAX_PATH];

                                // Check if we should run Magnifier
                                if(GetCanonicalizedPath(WinntPath, WINNT_INF_FILENAME))
                                {
                                    if(GetPrivateProfileString( L"Accessibility",
                                                                L"AccMagnifier",
                                                                L"",
                                                                Answer,
                                                                sizeof(Answer)/sizeof(WCHAR),
                                                                WinntPath
                                                                ))
                                    {
                                        if ( lstrcmpi( Answer, L"1") == 0)
                                        {
                                            InvokeExternalApplication(L"magnify.exe", L"", NULL);
                                        }
                                    }
                                }

                            }
                        }
                        else
                        {
                            //
                            // The first instance did the minisetup stuff, so
                            // we don't need to do it again.
                            //
                            SetupOobeInitPreServices(FALSE);
                        }

                        if(0 != ObMain.InitApplicationWindow())
                        {
                            // BUGBUG: Is the following true for NT?
                            // If we finish OOBE, we return 0 to let the machine boot,
                            // otherwise we return 1 and the machine shutsdown because
                            // the user canceled or there was a fatal error.
                            //
                            iReturn = ObMain.RunOOBE() ? 0 : 1;
                        }

                        if (!ObMain.InAuditMode())
                        {
                            // We need to remove this entry now, so ICWMAN (INETWIZ) does not
                            // pick it up later
                            RemoveShellNextFromReg();

                            HandleShellNext();

                            if (!ObMain.Is2ndInstance())
                            {
                                // Only the 1st instance can do this.
                                // it called SetupOobeInitPreServices
                                CSetupKey            setupkey;
                                OOBE_SHUTDOWN_ACTION action;

                                // We want to clear the restart stuff before
                                // calling SetupOobeCleanup. SetupOobeCleanup
                                // enables System Restore, which creates a restore
                                // point immediately and the restore point would
                                // cause Winlogon to start OOBE.

                                ObMain.RemoveRestartStuff(setupkey);

                                // SHUTDOWN_POWERDOWN happens only if bad pid
                                // is entered or eula is declined. We don't want to call
                                // SetupOobeCleanup and enable system restore
                                // at this point. This has to be called after
                                // RemoveRestartStuff.

                                if ((setupkey.get_ShutdownAction(&action) != ERROR_SUCCESS) ||
                                    (action != SHUTDOWN_POWERDOWN))
                                {
                                    if (fOemOobeMode)
                                    {
                                        ObMain.CreateBackground();
                                        SetupOobeCleanup( fOemOobeMode );
                                        ObMain.StopBackgroundWindow();
                                    }
                                    else
                                    {
                                        SetupOobeCleanup( fOemOobeMode );
                                    }
                                }
                            }
                        }
                    }
                }
                if (!ObMain.InAuditMode() && ObMain.FFullScreen())
                {
                    // OOBE is done, let see if we should launch AutoActivation?
                    AutoActivation();
                }
                ObMain.Cleanup();

            } else if (ObMain.InMode(APMD_ACT)) {

                WCHAR szTitle [MAX_PATH] = L"\0";
                WCHAR szMsg   [MAX_PATH] = L"\0";

                HINSTANCE hInst = GetModuleHandle(OOBE_MAIN_DLL);

                TRACE(L"Desktop activation cannot be run in safe mode.");

                if(hInst) {
                    LoadString(hInst, IDS_APPNAME, szTitle, MAX_CHARS_IN_BUFFER(szTitle));
                    LoadString(hInst, IDS_SAFEMODE, szMsg, MAX_CHARS_IN_BUFFER(szMsg));

                    MessageBox( NULL, szMsg, szTitle,  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL );
                }

            } else {

                // we are in safemode and not running Activation.
                // At least start the services.
                SignalComputerNameChangeComplete();
            }
        }
        // DO NOT REMOVE THIS SCOPE BLOCK.  It controls the scope of ObMain.
        // ObMain must be initialized after CoInitialize is called and
        // destroyed prior to calling CoUninitialize.
        //
    }

    if (bUseOleUninitialize)
    {
        OleUninitialize();
    }
    else
    {
        CoUninitialize();
    }

    if (bRegisteredDlls)
    {
        SelfRegisterComObject(OOBE_WEB_DLL, FALSE);
        SelfRegisterComObject(OOBE_SHELL_DLL, FALSE);
        SelfRegisterComObject(OOBE_COMM_DLL, FALSE);
        CloseHandle( Mutex );
    }

    TRACE( L"OOBE has finished." );
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\pid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  PID.H - Header for the implementation of CProductID
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#ifndef _PID_H_
#define _PID_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>

#define PID_STATE_UNKNOWN     0
#define PID_STATE_INVALID     1
#define PID_STATE_VALID       2

class CProductID : public IDispatch
{
private:
    ULONG   m_cRef;
    DWORD   m_dwPidState;
    BSTR    m_bstrPID;
    WCHAR   m_szPID2[24];
    BYTE    m_abPID3[256];
    WCHAR   m_szProdType[5];

    //SET functions
    HRESULT set_PID           (BSTR    bstrVal);

    VOID    SaveState         ();

    //Methods
    HRESULT ValidatePID       (BOOL*   pbIsValid);

public:

     CProductID ();
    ~CProductID ();

    //GET functions
    HRESULT get_PID           (BSTR*   pbstrVal);
    HRESULT get_PID2          (LPWSTR* lplpszPid2);
    HRESULT get_PID3Data      (LPBYTE* lplpabPid3Data);
    HRESULT get_PIDAcceptance (BOOL*   pbVal);
    HRESULT get_ProductType   (LPWSTR* lplpszProductType);
    HRESULT get_CurrentPID2   (LPWSTR* lplpszPid2);

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\language.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  LANGUAGE.CPP - Header for the implementation of CLanguage
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "precomp.h"
#include "msobmain.h"
#include "language.h"
#include "appdefs.h"
#include "dispids.h"

#define DEFAULT_BUFFER_SIZE BYTES_REQUIRED_BY_CCH(2048)

DISPATCHLIST LanguageExternalInterface[] =
{
    {L"get_NumOfRegions",         DISPID_GETNUMOFREGIONS         },
    {L"get_RegionName",           DISPID_GETREGIONNAME           },
    {L"get_RegionIndex",          DISPID_GETREGIONINDEX          },
    {L"set_RegionIndex",          DISPID_SETREGIONINDEX          },
    {L"get_NumOfLangs",           DISPID_GETNUMOFLANGS           },
    {L"get_LangName",             DISPID_GETLANGNAME             },
    {L"get_LangIndex",            DISPID_GETLANGINDEX            },
    {L"set_LangIndex",            DISPID_SETLANGINDEX            },
    {L"get_NumOfKeyboardLayouts", DISPID_GETNUMOFKEYLAYOUTS      },
    {L"get_KeyboardLayoutName",   DISPID_GETKEYNAME              },
    {L"get_KeyboardLayoutIndex",  DISPID_GETKEYLAYOUTINDEX       },
    {L"set_KeyboardLayoutIndex",  DISPID_SETKEYLAYOUTINDEX       },
    {L"get_RebootState",          DISPID_LANGUAGE_GETREBOOTSTATE },
    {L"SaveSettings",             DISPID_LANGUAGE_SAVESETTINGS   },
    {L"get_PhoneCountries",       DISPID_GETPHONECOUNTRIES       }
};


//+---------------------------------------------------------------------------
//
//  Function:   CompareNameLookUpElements()
//
//  Synopsis:   Function to compare names used by sort
//
//+---------------------------------------------------------------------------
int __cdecl CompareNameLookUpElements(const void *e1, const void *e2)
{

    LPNAMELOOKUPELEMENT pCUE1 = (LPNAMELOOKUPELEMENT)e1;
    LPNAMELOOKUPELEMENT pCUE2 = (LPNAMELOOKUPELEMENT)e2;

    return CompareString(LOCALE_USER_DEFAULT, 0,
        pCUE1->pszName,
        -1,
        pCUE2->pszName,
        -1) - 2;
}

/////////////////////////////////////////////////////////////
// CLanguage::CLanguage
CLanguage::CLanguage()
{
    WCHAR szINIPath[MAX_PATH] = L"";
    WCHAR Answer[MAX_PATH];


    // Init member vars
    m_cRef                   = 0;
    m_lRebootState           = LANGUAGE_REBOOT_NEVER;

    m_poliRegions            = NULL;
    m_lRegionTotal           = 0;
    m_lRegionDefault         = -1;

    m_poliLangs              = NULL;
    m_lLangTotal             = 0;
    m_lLangDefault           = -1;

    m_poliKeyboards          = NULL;
    m_lKeyboardLayoutTotal   = 0;
    m_lKeyboardLayoutDefault = -1;

    GetCanonicalizedPath(szINIPath, INI_SETTINGS_FILENAME);

    m_DefaultRegion = GetPrivateProfileInt(
        OPTIONS_SECTION,
        DEFAULT_REGION,
        0,
        szINIPath
        );

    GetPrivateProfileString(
        OPTIONS_SECTION,
        DEFAULT_LANGUAGE,
        L"",
        Answer,
        MAX_PATH,
        szINIPath
        );
    m_DefaultLanguage = wcstoul(Answer, NULL, 16);

    GetPrivateProfileString(
        OPTIONS_SECTION,
        DEFAULT_KEYBOARD,
        L"",
        Answer,
        MAX_PATH,
        szINIPath
        );
    m_DefaultKeyboard = wcstoul(Answer, NULL, 16);

    SetupGetGeoOptions(
        m_DefaultRegion,
        &m_poliRegions,
        (LPDWORD) &m_lRegionTotal,
        (LPDWORD) &m_lRegionDefault
        );
    MYASSERT( m_poliRegions );

    SetupGetLocaleOptions(
        m_DefaultLanguage,
        &m_poliLangs,
        (LPDWORD) &m_lLangTotal,
        (LPDWORD) &m_lLangDefault
        );
    MYASSERT( m_poliLangs );

    SetupGetKeyboardOptions(
        m_DefaultKeyboard,
        &m_poliKeyboards,
        (LPDWORD) &m_lKeyboardLayoutTotal,
        (LPDWORD) &m_lKeyboardLayoutDefault);
    MYASSERT( m_poliKeyboards );

    // The current index should be the defaults.
    //
    m_lRegionIndex           = m_lRegionDefault;
    m_lLangIndex             = m_lLangDefault;
    m_lKeyboardLayoutIndex   = m_lKeyboardLayoutDefault;
}

/////////////////////////////////////////////////////////////
// CLanguage::~CLanguage
CLanguage::~CLanguage()
{
    if ( m_poliRegions )
        SetupDestroyLanguageList( m_poliRegions, m_lRegionTotal );
    if ( m_poliLangs )
        SetupDestroyLanguageList( m_poliLangs, m_lLangTotal );
    if ( m_poliKeyboards )
        SetupDestroyLanguageList( m_poliKeyboards, m_lKeyboardLayoutTotal );

    MYASSERT(m_cRef == 0);
}

HRESULT CLanguage::get_NumOfRegions(long* plVal)
{
    *plVal = m_lRegionTotal;

    return S_OK;
}

HRESULT CLanguage::get_NumOfKeyboardLayouts(long* plVal)
{
    *plVal = m_lKeyboardLayoutTotal;

    return S_OK;
}

HRESULT CLanguage::get_RegionName(long lIndex, BSTR* pbstrVal)
{

    if ( lIndex >= m_lRegionTotal )
        return E_FAIL;

    // *pbstrVal = SysAllocString(m_pRegionNameLookUp[lIndex].pszName);
    *pbstrVal = SysAllocString( m_poliRegions[lIndex].Name );

    return S_OK;
}

HRESULT CLanguage::get_KeyboardLayoutName(long lIndex, BSTR* pbstrVal)
{

    if ( lIndex >= m_lKeyboardLayoutTotal )
        return E_FAIL;

    // *pbstrVal = SysAllocString(m_pKeyboardNameLookUp[lIndex].pszName);
    *pbstrVal = SysAllocString( m_poliKeyboards[lIndex].Name );

    return S_OK;
}

HRESULT CLanguage::get_RebootState(long* plVal)
{
    *plVal = m_lRebootState;

    return S_OK;
}

HRESULT CLanguage::SaveSettings()
{
    // Only save the settings if they changed.
    //
    if ( ( m_lRegionIndex >= 0 ) &&
         ( m_lLangIndex >= 0 ) &&
         ( m_lKeyboardLayoutIndex >= 0 ) &&
         m_poliRegions &&
         m_poliLangs &&
         m_poliKeyboards
         )
         //( m_lRegionDefault != m_lRegionIndex ) ||
         //( m_lKeyboardLayoutDefault != m_lKeyboardLayoutIndex ) )
    {
        if (SetupSetIntlOptions(
            m_poliRegions[m_lRegionIndex].Id,
            m_poliLangs[m_lLangIndex].Id,
            m_poliKeyboards[m_lKeyboardLayoutIndex].Id
            ))
        {
            // BUGBUG: The return value from SetIntlOptions on Win9x is
            // interpreted as a reboot state.  How do we determine reboot state
            // on Whistler?
            // Now the defaults are what is currently saved.
            //
            m_lRegionDefault = m_lRegionIndex;
            m_lLangDefault = m_lLangIndex;
            m_lKeyboardLayoutDefault = m_lKeyboardLayoutIndex;
        }

    }

    return S_OK;
}



////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: RegionIndex
////
HRESULT CLanguage::get_RegionIndex(long* plVal)
{
    *plVal = m_lRegionIndex;

    return S_OK;
}

HRESULT CLanguage::set_RegionIndex(long lVal)
{
    m_lRegionIndex = lVal;
    // m_lRegionIndex = m_pRegionNameLookUp[lVal].nIndex;

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: KeyboardLayoutIndex
////
HRESULT CLanguage::get_KeyboardLayoutIndex(long* plVal)
{
    *plVal = m_lKeyboardLayoutIndex;

    return S_OK;
}

HRESULT CLanguage::set_KeyboardLayoutIndex(long lVal)
{
    m_lKeyboardLayoutIndex = lVal;
    // m_lKeyboardLayoutIndex = m_pKeyboardNameLookUp[lVal].nIndex;;

    return S_OK;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CLanguage::QueryInterface
STDMETHODIMP CLanguage::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CLanguage::AddRef
STDMETHODIMP_(ULONG) CLanguage::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CLanguage::Release
STDMETHODIMP_(ULONG) CLanguage::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CLanguage::GetTypeInfo
STDMETHODIMP CLanguage::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CLanguage::GetTypeInfoCount
STDMETHODIMP CLanguage::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CLanguage::GetIDsOfNames
STDMETHODIMP CLanguage::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(LanguageExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(LanguageExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = LanguageExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CLanguage::Invoke
HRESULT CLanguage::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_GETNUMOFREGIONS:
        {

            TRACE(L"DISPID_GETNUMOFREGIONS\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                get_NumOfRegions(&(pvarResult->lVal));
            }
            break;
        }

        case DISPID_GETREGIONINDEX:
        {

            TRACE(L"DISPID_GETREGIONINDEX\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                get_RegionIndex(&(pvarResult->lVal));
            }
            break;
        }

        case DISPID_SETREGIONINDEX:
        {

            TRACE(L"DISPID_SETREGIONINDEX\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_RegionIndex(pdispparams[0].rgvarg[0].lVal);
            break;
        }

        case DISPID_GETREGIONNAME:
        {

            TRACE(L"DISPID_GETREGIONNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                if(pdispparams && &pdispparams[0].rgvarg[0])
                    get_RegionName(pdispparams[0].rgvarg[0].lVal, &(pvarResult->bstrVal));
            }
            break;
        }

    // BUGBUG: Need to Lang processing to syssetup.dll
        case DISPID_GETNUMOFLANGS:
        {

            TRACE(L"DISPID_GETNUMOFFLANGS\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                pvarResult->lVal = m_lLangTotal;
            }
            break;
        }

        case DISPID_GETLANGINDEX:
        {

            TRACE(L"DISPID_GETLANGINDEX\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                pvarResult->lVal =  m_lLangIndex;
            }
            break;
        }

        case DISPID_SETLANGINDEX:
        {

            TRACE(L"DISPID_SETLANGINDEX\n");

            if(pdispparams && &pdispparams[0].rgvarg[0]) {
               m_lLangIndex = pdispparams[0].rgvarg[0].lVal;
            }
            break;
        }

        case DISPID_GETLANGNAME:
        {

            TRACE(L"DISPID_GETLANGNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                if(pdispparams && &pdispparams[0].rgvarg[0]) {

                    long lIndex = pdispparams[0].rgvarg[0].lVal;

                    // BUGBUG: What if lIndex < 0??
                    if ( lIndex >= m_lLangTotal )
                        return E_FAIL;

                    pvarResult->bstrVal = SysAllocString( m_poliLangs[lIndex].Name );
                }
            }
            break;
        }


         case DISPID_GETNUMOFKEYLAYOUTS:
        {

            TRACE(L"DISPID_GETNUMOFKEYLAYOUTS\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                get_NumOfKeyboardLayouts(&(pvarResult->lVal));
            }
            break;
        }

        case DISPID_GETKEYLAYOUTINDEX:
        {

            TRACE(L"DISPID_GETKEYLAYOUTINDEX\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                get_KeyboardLayoutIndex(&(pvarResult->lVal));
            }
            break;
        }

        case DISPID_SETKEYLAYOUTINDEX:
        {

            TRACE(L"DISPID_SETKEYLAYOUTINDEX\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_KeyboardLayoutIndex(pdispparams[0].rgvarg[0].lVal);
            break;
        }

        case DISPID_GETKEYNAME:
        {

            TRACE(L"DISPID_GETKEYNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                if(pdispparams && &pdispparams[0].rgvarg[0])
                    get_KeyboardLayoutName(pdispparams[0].rgvarg[0].lVal, &(pvarResult->bstrVal));
            }
            break;
        }

        case DISPID_LANGUAGE_GETREBOOTSTATE:
        {

            TRACE(L"DISPID_LANGUAGE_GETREBOOTSTATE\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                get_RebootState(&(pvarResult->lVal));
            }
            break;
        }

        case DISPID_LANGUAGE_SAVESETTINGS:
        {

            TRACE(L"DISPID_LANGUAGE_SAVESETTINGS\n");

            SaveSettings();
            break;
        }

        case DISPID_GETPHONECOUNTRIES:
        {

            TRACE(L"DISPID_GETPHONECOUNTRIES");

            if(pvarResult)
            {
                WCHAR   PhoneInfName[MAX_PATH];

                GetOOBEMUIPath( PhoneInfName );
                lstrcat( PhoneInfName, L"\\phone.inf" );

                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                pvarResult->bstrVal = SysAllocString(
                    SetupReadPhoneList( PhoneInfName ) );
            }
            break;
        }

        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\msobmain.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOBMAIN.H - Header for the implementation of CObMain
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#ifndef _MSOBMAIN_H_
#define _MSOBMAIN_H_

#include <util.h>
#include "licdll.h"

#include "debug.h"
#include "userinfo.h"
#include "tapiloc.h"
#include "pid.h"
#include "signup.h"
#include "status.h"
#include "direct.h"
#include "register.h"
#include "api.h"
#include "language.h"
#include "eula.h"
#include "sysclock.h"
#include "appdefs.h"
#include "obshel.h"
#include "obcomm.h"
#include "setup.h"  // // BUGBUG: Temp syssetup stub declarations
#include "setupkey.h"

#define OOBE_STATUS_HEIGHT  12  // Percent height of the status pane

#define FINISH_OK           0x00000000
#define FINISH_REBOOT       0x00000001
#define FINISH_BAD_PID      0x00000002
#define FINISH_BAD_EULA     0x00000004
#define FINISH_BAD_STAMP    0x00000008

// Setup types from winlogon\setup.h
#define SETUPTYPE_NONE      0
#define SETUPTYPE_FULL      1
#define SETUPTYPE_NOREBOOT  2
#define SETUPTYPE_UPGRADE   4

#define MNRMAXCREDENTIAL    128

typedef UINT   APIERR;
typedef LPVOID HPWL;
typedef HPWL*  LPHPWL;

typedef APIERR (WINAPI* LPFnCreatePasswordCache) (LPHPWL lphCache, const CHAR* pszUsername, const CHAR* pszPassword);

typedef  PVOID           HDEVNOTIFY;
typedef  HDEVNOTIFY     *PHDEVNOTIFY;

#define DEVICE_NOTIFY_WINDOW_HANDLE     0x00000000
#define DEVICE_NOTIFY_SERVICE_HANDLE    0x00000001
#define DEVICE_NOTIFY_COMPLETION_HANDLE 0x00000002
#define DBT_DEVTYP_DEVICEINTERFACE      0x00000005  // device interface class
#define DBT_DEVTYP_HANDLE               0x00000006  // file system handle
static const CHAR cszRegisterDeviceNotification[]
                                            = "RegisterDeviceNotificationA";
static const CHAR cszUnregisterDeviceNotification[]
                                            = "UnregisterDeviceNotification";

typedef HDEVNOTIFY (WINAPI * REGISTERDEVICENOTIFICATIONA) (
    IN HANDLE hRecipient,
    IN LPVOID NotificationFilter,
    IN DWORD Flags
    );


typedef BOOL (WINAPI* UNREGISTERDEVICENOTIFICATION) (
    IN HDEVNOTIFY Handle
    );

#define OOBE_1ND_SERVICESSTARTED   L"oobe_1nd_servicesstarted"
#define OOBE_2ND_CONTINUE   L"oobe_2nd_continue"
#define OOBE_2ND_DONE       L"oobe_2nd_done"

/* A5DCBF10-6530-11D2-901F-00C04FB951ED */
DEFINE_GUID(GUID_CLASS_USB_DEVICE, 0xA5DCBF10L, 0x6530, 0x11D2, 0x90, 0x1F,  0x00, 0xC0, 0x4F, 0xB9, 0x51, 0xED);

class CObMain : public IDispatch
{
public:     // data
    IObShellMainPane*        m_pObShellMainPane;
    IObCommunicationManager2* m_pObCommunicationManager;

    // License Agent
    ICOMLicenseAgent*        m_pLicenseAgent;
    BOOL                     m_bPostToMs;

    CTapiLocationInfo*       m_pTapiInfo;
    CUserInfo*               m_pUserInfo;
    WCHAR                    m_szStartPage[MAX_PATH];
    WCHAR                    m_szIspUrl [MAX_PATH*4];
    BOOL m_fIsOEMDebugMode;
    BOOL m_bProcessQueuedEvents;

private:    // data
    // Ref count
    //
    ULONG                    m_cRef;

    // Instance info
    //
    HINSTANCE                m_hInstance;
    HWND                     m_hwndBackground;
    HANDLE                   m_BackgroundWindowThreadHandle;
    // Parent window info
    //
    HWND                     m_hwndParent;
    RECT                     m_rectMainPane;
    BOOL                     m_bMainPaneReady;
    BOOL                     m_bStatusPaneReady;
    int                      m_iCurrentSelection;
    int                      m_iTotalItems;

    // System Metrics
    //
    int                      m_iScrWidth;
    int                      m_iScrHeight;

    // window.external objects
    //
    CProductID*              m_pProductID;
    CSignup*                 m_pSignup;
    CStatus*                 m_pStatus;
    CDirections*             m_pDirections;
    CLanguage*               m_pLanguage;
    CEula*                   m_pEula;
    CRegister*               m_pRegister;
    CSystemClock*            m_pSysClock;
    CAPI*                    m_pAPI;
    CDebug*                  m_pDebug;

    // Reminder info
    //
    BOOL                     m_bRemindRegistered;
    BOOL                     m_bRemindISPSignuped;
    int                      m_nRmdIndx;

    // OOBE state info
    //
    APMD                     m_apmd;
    DWORD                    m_prop;
    BOOL                     m_fFinished;
    OOBE_SHUTDOWN_ACTION     m_OobeShutdownAction;
    BOOL                     m_fRunIEOnClose;
    BOOL                     m_bDisableFontSmoothingOnExit;
    BOOL                     m_bAuditMode;

    // Hardware info
    //
    BOOL                     m_bDoCheck;
    DWORD                    m_dwHWChkResult;
    HDEVNOTIFY               m_hDevNotify;
    HINSTANCE                m_hInstShell32;

    // Network info
    //
    DWORD                    m_dwJoinStatus;

    //INI stuff
    WCHAR                    m_szStatusLogo   [MAX_PATH+1];
    WCHAR                    m_szStatusLogoBg [MAX_PATH+1];

    HANDLE                   m_CompNameStartThread;
    // Debugging info
    //
    ATOM                     m_atomDebugKey;

    // Migrated user list
    PSTRINGLIST              m_pMigratedUserList;
    int                      m_iMigratedUserCount;
    WCHAR                    m_szDefaultAccount[UNLEN];

    // 2nd instance of OOBE
    BOOL                     m_bSecondInstanceNeeded;
    BOOL                     m_bSecondInstance;
    HANDLE                   m_1ndInst_ServicesReady;
    HANDLE                   m_2ndInst_Continue;
    HANDLE                   m_2ndInst_Done;
    HANDLE                   m_2ndOOBE_hProcess;

private:    // methods
    void ShowOOBEWindow          ();
    void InitObShellMainPane     ();
    void DoCancelDialog          ();
    void PlaceIEInRunonce        ();
    void CreateDefaultUser       ();
    void CheckForStatusPaneItems (void);
    bool LoadStatusItems         (LPCWSTR szSectionNamePostfix);
    bool LoadStatusItems         (BSTR bstrSectionNamePostfix);
    bool LoadStatusItems         (UINT uiSectionNamePostfix);
    DWORD NeedKbdMouseChk        ();
    DWORD GetAppLCID             ();
    BOOL DeleteReminder          (INT nType,
                                  BOOL bAll=FALSE);
    BOOL AddReminder             (INT nType);
    BOOL DoRegisterDeviceInterface();
    BOOL UnRegisterDeviceInterface();
    void UpdateMuiFiles          ();

    BOOL OnDial                  (UINT nConnectionType,
                                  BSTR bstrISPFile,
                                  DWORD nISPIndex,
                                  BOOL  bRedial
                                  );
    BOOL IsViewerInstalled       (BSTR bstrExt);

    void CreateIdentityAccounts  ();
    BOOL CreateMigratedUserList  ();
    void FixPasswordAttributes   (LPWSTR szName, DWORD flags);
    BOOL RemoveDefaultAccount    ();
    LONG GetLocalUserCount       ();

    HRESULT CreateModemConnectoid(BSTR bstrAreaCode,
                                  BSTR bstrPhoneNumber,
                                  BOOL fAutoIPAddress,
                                  DWORD ipaddr_A,
                                  DWORD ipaddr_B,
                                  DWORD ipaddr_C,
                                  DWORD ipaddr_D,
                                  BOOL fAutoDNS,
                                  DWORD ipaddrDns_A,
                                  DWORD ipaddrDns_B,
                                  DWORD ipaddrDns_C,
                                  DWORD ipaddrDns_D,
                                  DWORD ipaddrDnsAlt_A,
                                  DWORD ipaddrDnsAlt_B,
                                  DWORD ipaddrDnsAlt_C,
                                  DWORD ipaddrDnsAlt_D,
                                  BSTR bstrUserName,
                                  BSTR bstrPassword);
    HRESULT CreatePppoeConnectoid(BSTR bstrServiceName,
                                  BOOL fAutoIPAddress,
                                  DWORD ipaddr_A,
                                  DWORD ipaddr_B,
                                  DWORD ipaddr_C,
                                  DWORD ipaddr_D,
                                  BOOL fAutoDNS,
                                  DWORD ipaddrDns_A,
                                  DWORD ipaddrDns_B,
                                  DWORD ipaddrDns_C,
                                  DWORD ipaddrDns_D,
                                  DWORD ipaddrDnsAlt_A,
                                  DWORD ipaddrDnsAlt_B,
                                  DWORD ipaddrDnsAlt_C,
                                  DWORD ipaddrDnsAlt_D,
                                  BSTR bstrUserName,
                                  BSTR bstrPassword
                                  );
    BOOL IsSetupUpgrade          ();
    BOOL IsUpgrade               ();
    DWORD DetermineUpgradeType   ();
    VOID OnComputerNameChangeComplete(BOOL StartAsThread);
    DWORD JoinDomain             (IN  BSTR    DomainName,
                                  IN  BSTR    UserAccount,
                                  IN  BSTR    Password,
                                  IN  BOOL    Flag
                                  );
    DWORD GetNetJoinInformation  ();
    BOOL IsSelectVariation       ();
    VOID Activate                (IN  DWORD   PostToMs
                                  );
    BSTR GetProxySettings        ();

    VOID AsyncInvoke             (IN  INT           cDispid,
                                  IN  const DISPID* dispids,
                                  IN  LPCWSTR       szReturnFunction,
                                  IN  INT           iTimeout
                                  );

public:     // methods

    CObMain  (APMD Apmd, DWORD Prop, int RmdIndx);
    ~CObMain ();

    BOOL InitApplicationWindow   ();
    BOOL Init                    ();
    DWORD StartRpcSs             ();
    void Cleanup                 ();
    void CleanupForReboot        (CSetupKey& setupkey);
    void CleanupForPowerDown     (CSetupKey& setupkey);
    void RemoveRestartStuff      (CSetupKey& setupkey);
    BOOL SetConnectoidInfo       ();
    BOOL RunOOBE                 ();
    BOOL PowerDown               (BOOL fRestart);
    OOBE_SHUTDOWN_ACTION DisplayReboot();
    void SetAppMode              (APMD apmd) {m_apmd = apmd;}
    BOOL InMode                  (APMD apmd) {return m_apmd == apmd;}
    BOOL InOobeMode              () {return InMode(APMD_OOBE);}
    BOOL InMSNMode               () {return InMode(APMD_MSN);}
    void SetProperty             (DWORD prop) {m_prop |= prop;}
    void ClearProperty           (DWORD prop) {m_prop &= ~prop;}
    BOOL FHasProperty            (DWORD prop) {return m_prop & prop;}
    BOOL FFullScreen             () {return FHasProperty(PROP_FULLSCREEN);}
    void SetStatus               (BOOL b);
    void SetMain                 (BOOL b);
    void DoAuditBootKeySequence  ();
    BOOL DoAuditBoot             ();
    BOOL OEMAuditboot            ();
    void SetReminderIndx         (int nRmdIndx) {m_nRmdIndx = nRmdIndx;}
    BOOL RegisterDebugHotKey     ();
    void UnregisterDebugHotKey   ();
    BOOL IsDebugHotKey           (WORD wKeyCode) {
                                    return (wKeyCode == m_atomDebugKey);
                                    }
    void WaitForPnPCompletion    ();
    void ServiceStartDone       ();

    void Set2ndInstance(BOOL b2ndInstance) { m_bSecondInstance = b2ndInstance;
                                             return;}
    BOOL Is2ndInstance() { return m_bSecondInstance;}
    BOOL CreateBackground();
    void StopBackgroundWindow();
    BOOL OEMPassword();
    BOOL InAuditMode() {return m_bAuditMode;}
    void PlayBackgroundMusic     ();
    void StopBackgroundMusic     ();
    void SetComputerDescription  ();
    HRESULT ExecScriptFn         (IN LPCWSTR szScriptFn,
                                  IN VARIANT* pvarReturns,
                                  IN int cReturns
                                  );

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid,
                                  WORD wFlags, DISPPARAMS* pdispparams,
                                  VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
                                  UINT* puArgErr);
};  //  class CObMain



BOOL IsProfessionalSKU();
void CleanupForLogon(CSetupKey& setupkey);
void RemovePersistData();
void CheckDigitalID();

#endif // _MSOBMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\passport.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  PASSPORT.CPP - Header for the implementation of CPassport
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 

#include "passport.h"
#include "appdefs.h"
#include "dispids.h"

DISPATCHLIST PassportExternalInterface[] = 
{
    {L"get_PassportID",       DISPID_PASSPORT_GET_ID       },      
    {L"set_PassportID",       DISPID_PASSPORT_SET_ID       },
    {L"get_PassportPassword", DISPID_PASSPORT_GET_PASSWORD },
    {L"set_PassportPassword", DISPID_PASSPORT_SET_PASSWORD },
    {L"get_PassportLocale",   DISPID_PASSPORT_GET_LOCALE   },
    {L"set_PassportLocale",   DISPID_PASSPORT_SET_LOCALE   }
};
 
/////////////////////////////////////////////////////////////
// CPassport::CPassport
CPassport::CPassport()
{

    // Init member vars
    m_cRef = 0;

    m_bstrID       = SysAllocString(L"\0");
    m_bstrPassword = SysAllocString(L"\0");
    m_bstrLocale   = SysAllocString(L"\0");    
}

/////////////////////////////////////////////////////////////
// CPassport::~CPassport
CPassport::~CPassport()
{
    assert(m_cRef == 0);
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: PassportID
////
HRESULT CPassport::set_PassportID(BSTR bstrVal)
{
    if (NULL != m_bstrID)
    {
        SysFreeString(m_bstrID);
    }

    m_bstrID = SysAllocString(bstrVal);
    
    return S_OK;
}

HRESULT CPassport::get_PassportID(BSTR* pbstrVal)
{
    *pbstrVal = SysAllocString(m_bstrID);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: PassportPassword
////
HRESULT CPassport::set_PassportPassword(BSTR bstrVal)
{
    if (NULL != m_bstrPassword)
    {
        SysFreeString(m_bstrPassword);
    }

    m_bstrPassword = SysAllocString(bstrVal);
    
    return S_OK;
}

HRESULT CPassport::get_PassportPassword(BSTR* pbstrVal)
{
    *pbstrVal = SysAllocString(m_bstrPassword);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: PassportLocale
////
HRESULT CPassport::set_PassportLocale(BSTR bstrVal)
{
    if (NULL != m_bstrLocale)
    {
        SysFreeString(m_bstrLocale);
    }

    m_bstrLocale = SysAllocString(bstrVal);
    
    return S_OK;
}

HRESULT CPassport::get_PassportLocale(BSTR* pbstrVal)
{
    *pbstrVal = SysAllocString(m_bstrLocale);

    return S_OK;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CPassport::QueryInterface
STDMETHODIMP CPassport::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;     

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CPassport::AddRef
STDMETHODIMP_(ULONG) CPassport::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CPassport::Release
STDMETHODIMP_(ULONG) CPassport::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CPassport::GetTypeInfo
STDMETHODIMP CPassport::GetTypeInfo(UINT, LCID, ITypeInfo**)
{ 
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CPassport::GetTypeInfoCount
STDMETHODIMP CPassport::GetTypeInfoCount(UINT* pcInfo)
{ 
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CPassport::GetIDsOfNames
STDMETHODIMP CPassport::GetIDsOfNames(REFIID    riid, 
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{ 

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(PassportExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(PassportExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = PassportExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }      
        
    return hr;
}

/////////////////////////////////////////////////////////////
// CPassport::Invoke
HRESULT CPassport::Invoke
( 
    DISPID      dispidMember, 
    REFIID      riid, 
    LCID        lcid, 
    WORD        wFlags, 
    DISPPARAMS* pdispparams, 
    VARIANT*    pvarResult,  
    EXCEPINFO*  pexcepinfo, 
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;
    
    switch(dispidMember)
    {   
        case DISPID_PASSPORT_GET_ID:
        {
            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;    
         
                get_PassportID(&(pvarResult->bstrVal));
            }
            break;
        }
         
        case DISPID_PASSPORT_SET_ID:
        {
            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_PassportID(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }
        
        case DISPID_PASSPORT_GET_PASSWORD:
        {
            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;    
         
                get_PassportPassword(&(pvarResult->bstrVal));
            }
            break;
        }
         
        case DISPID_PASSPORT_SET_PASSWORD:
        {
            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_PassportPassword(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

        case DISPID_PASSPORT_GET_LOCALE:
        {
            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;    
         
                get_PassportLocale(&(pvarResult->bstrVal));
            }
            break;
        }
         
        case DISPID_PASSPORT_SET_LOCALE:
        {
            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_PassportLocale(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }
       
        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\pid.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  PID.CPP - Header for the implementation of CProductID
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "pid.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include "digpid.h"

#define REG_VAL_PID2        L"PID2"
#define REG_VAL_PID3        L"PID3"
#define REG_VAL_PID3DATA    L"PID3Data"
#define REG_VAL_PRODUCTKEY  L"ProductKey"

#define SEC_KEY_VER         L"Version"

DISPATCHLIST ProductIDExternalInterface[] =
{
    {L"get_PID",           DISPID_PRODUCTID_GET_PID      },
    {L"set_PID",           DISPID_PRODUCTID_SET_PID      },
    {L"get_PIDAcceptance", DISPID_PRODUCTID_GET_ACCEPTED },
    {L"ValidatePID",       DISPID_PRODUCTID_VALIDATEPID  },
    {L"get_CurrentPID2",   DISPID_PRODUCTID_GET_CURRENT_PID2 }
};

/////////////////////////////////////////////////////////////
// CProductID::CProductID
CProductID::CProductID()
{
    WCHAR   szKeyName[] = REG_KEY_OOBE_TEMP,
            szKeyWindows[] = REG_KEY_WINDOWS,
            szPid3[256],
            szOemInfoFile[MAX_PATH] = L"\0";
    HKEY    hKey;
    DWORD   cb,
            dwType;
    BOOL    bDontCare;
    BSTR    bstrPid;


    // Init member vars
    m_cRef = 0;
    m_dwPidState = PID_STATE_UNKNOWN;

    // Init the data we are going to try to get from the registry.
    //
    m_szPID2[0] = L'\0';
    szPid3[0] = L'\0';
    ZeroMemory(&m_abPID3, sizeof(m_abPID3));

    if ( RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey) == ERROR_SUCCESS )
    {
        // Get the PID 2 from the registry.
        //
        cb = sizeof(m_szPID2);
        RegQueryValueEx(hKey, REG_VAL_PID2, NULL, &dwType, (LPBYTE) m_szPID2, &cb);

        // Get the PID 3 from the registry.
        //
        cb = sizeof(szPid3);
        RegQueryValueEx(hKey, REG_VAL_PID3, NULL, &dwType, (LPBYTE) szPid3, &cb);

        // Get the PID 3 data from the registry.
        //
        cb = sizeof(m_abPID3);
        RegQueryValueEx(hKey, REG_VAL_PID3DATA, NULL, &dwType, m_abPID3, &cb);

        RegCloseKey(hKey);
    }

    // If we don't already have a saved state PID3 string, we need to
    // try to read it from the places where the OEM can pre-populate it.
    //
    if ( ( szPid3[0] == L'\0' ) &&
         ( RegOpenKey(HKEY_LOCAL_MACHINE, szKeyWindows, &hKey) == ERROR_SUCCESS ) )
    {
        // First try the registry.
        //
        cb = sizeof(szPid3);
        if ( ( RegQueryValueEx(hKey, REG_VAL_PRODUCTKEY, NULL, &dwType, (LPBYTE) szPid3, &cb) != ERROR_SUCCESS ) ||
             ( szPid3[0] == L'\0' ) )
        {
            // Now try the INI file.
            //
            GetSystemDirectory(szOemInfoFile, MAX_CHARS_IN_BUFFER(szOemInfoFile));
            lstrcat(szOemInfoFile, OEMINFO_INI_FILENAME);
            GetPrivateProfileString(SEC_KEY_VER, REG_VAL_PRODUCTKEY, L"\0", szPid3, MAX_CHARS_IN_BUFFER(szPid3), szOemInfoFile);
        }
        RegCloseKey(hKey);
    }

    // We need to store the PID we retrieved as a BSTR in the object.
    //
    m_bstrPID = SysAllocString(szPid3);

    // We assume the PID was accepted if we have the PID 2 & 3 strings.
    //
    if ( m_szPID2[0] && szPid3[0] )
        m_dwPidState = PID_STATE_VALID;
    else if ( szPid3[0] )
        ValidatePID(&bDontCare);
    else
        m_dwPidState = PID_STATE_INVALID;

    // If the PID is invalid, we don't want it.
    //
    if ( m_dwPidState == PID_STATE_INVALID )
    {
        bstrPid = SysAllocString(L"\0");
        set_PID(bstrPid);
        SysFreeString(bstrPid);
    }


    m_szProdType[0] = L'\0';
}

/////////////////////////////////////////////////////////////
// CProductID::~CProductID
CProductID::~CProductID()
{
    SysFreeString(m_bstrPID);

    assert(m_cRef == 0);
}

VOID CProductID::SaveState()
{
    WCHAR   szKeyName[] = REG_KEY_OOBE_TEMP;
    HKEY    hKey;
    LPWSTR  lpszPid3;


    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS )
    {
        // Save the PID 2 to the registry.
        //
        if ( m_szPID2[0] )
            RegSetValueEx(hKey, REG_VAL_PID2, 0, REG_SZ, (LPBYTE) m_szPID2, BYTES_REQUIRED_BY_SZ(m_szPID2));
        else
            RegDeleteValue(hKey, REG_VAL_PID2);

        // Save the PID 3 to the registry.
        //
        lpszPid3 = m_bstrPID;
        if ( *lpszPid3 )
            RegSetValueEx(hKey, REG_VAL_PID3, 0, REG_SZ, (LPBYTE) lpszPid3, BYTES_REQUIRED_BY_SZ(lpszPid3));
        else
            RegDeleteValue(hKey, REG_VAL_PID3);

        // Save the PID 3 data from the registry.
        //
        if ( *((LPDWORD) m_abPID3) )
            RegSetValueEx(hKey, REG_VAL_PID3DATA, 0, REG_BINARY, m_abPID3, *((LPDWORD) m_abPID3));
        else
            RegDeleteValue(hKey, REG_VAL_PID3DATA);

        RegFlushKey(hKey);
        RegCloseKey(hKey);
    }
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: PID
////
HRESULT CProductID::set_PID(BSTR bstrVal)
{
    LPWSTR  lpszNew,
            lpszOld;


    lpszNew = bstrVal;
    lpszOld = m_bstrPID;

    // No need to set it if we alread have
    // the same string.
    //
    if ( CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpszNew, -1, lpszOld, -1) != CSTR_EQUAL )
    {
        m_dwPidState = PID_STATE_UNKNOWN;
        SysFreeString(m_bstrPID);
        m_bstrPID = SysAllocString(bstrVal);

        m_szPID2[0] = L'\0';
        ZeroMemory(&m_abPID3, sizeof(m_abPID3));

        SaveState();
    }

    return S_OK;
}

HRESULT CProductID::get_PID(BSTR* pbstrVal)
{
    *pbstrVal = SysAllocString(m_bstrPID);

    return S_OK;
}

HRESULT CProductID::get_PID2(LPWSTR* lplpszPid2)
{
    *lplpszPid2 = SysAllocString(m_szPID2);

    return S_OK;
}

HRESULT CProductID::get_PID3Data(LPBYTE* lplpabPid3Data)
{
    *lplpabPid3Data = m_abPID3;

    return S_OK;
}

HRESULT CProductID::get_PIDAcceptance(BOOL* pbVal)
{
#if         0
    *pbVal = (m_dwPidState == PID_STATE_VALID);
#endif  //  0
    // BUGBUG: get_PIDAcceptance not implemented.
    *pbVal = TRUE;

    return S_OK;
}

HRESULT CProductID::get_ProductType(LPWSTR* lplpszProductType)
{

    // BUGBUG: get_ProductType not implemented

    m_szProdType[0] = L'\0';

    *lplpszProductType = SysAllocString(m_szProdType);

    return S_OK;
}

HRESULT CProductID::ValidatePID(BOOL* pbIsValid)
{
    BOOL        bValid              = FALSE;
    LPWSTR      lpszPid3;
    WCHAR       szOemId[5]          = L"\0";
    DWORD       dwSkuFlags          = 0;

    // Don't need to check if we know it is already valid.
    //
    if ( m_dwPidState == PID_STATE_VALID )
        *pbIsValid = TRUE;
    else if ( m_dwPidState == PID_STATE_INVALID )
        *pbIsValid = FALSE;
    else
    {
        // Need to convert m_bstrPID to an ANSI string.
        //
        lpszPid3 = m_bstrPID;
        if ( ( lpszPid3 != NULL ) &&
             SetupGetProductType( m_szProdType, &dwSkuFlags ) &&
             SetupGetSetupInfo( NULL, 0, NULL, 0,
                 szOemId, sizeof(szOemId), NULL ) )

        {
            // Validate the PID!
            //
            bValid = ( SetupPidGen3(
                lpszPid3,
                dwSkuFlags,
                szOemId,
                FALSE,
                m_szPID2,
                m_abPID3,
                NULL) == PID_VALID );
        }

        // Set the return value.
        //
        if ( *pbIsValid = bValid )
            m_dwPidState = PID_STATE_VALID;
        else
        {
            // Make sure we reset the buffers because the PID isn't valid.
            //
            m_dwPidState = PID_STATE_INVALID;
            m_szPID2[0] = L'\0';
            ZeroMemory(&m_abPID3, sizeof(m_abPID3));
        }

        // Make sure we commit the data to the registry.
        //
        SaveState();
    }

    return S_OK;
}

/*

    This function returns the PID 2.0 string from the registry.  It is needed
    because get_PID2() returns an empty string if set_PID() has not been called.

*/

HRESULT CProductID::get_CurrentPID2(LPWSTR* lplpszPid2)
{
    HKEY    hKey;
    DWORD   cb;
    DWORD   dwType;
    WCHAR   szPID2[24] = L"\0";


    if ( RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_WINDOWSNT, &hKey) == ERROR_SUCCESS )
    {
        // Get the PID 2 from the registry.
        //
        cb = sizeof(szPID2);
        RegQueryValueEx(hKey,
                        REG_VAL_PRODUCTID,
                        NULL,
                        &dwType,
                        (LPBYTE) szPID2,
                        &cb
                        );

        RegCloseKey(hKey);
    }

    *lplpszPid2 = SysAllocString(szPID2);

    return S_OK;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CProductID::QueryInterface
STDMETHODIMP CProductID::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CProductID::AddRef
STDMETHODIMP_(ULONG) CProductID::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CProductID::Release
STDMETHODIMP_(ULONG) CProductID::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CProductID::GetTypeInfo
STDMETHODIMP CProductID::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CProductID::GetTypeInfoCount
STDMETHODIMP CProductID::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CProductID::GetIDsOfNames
STDMETHODIMP CProductID::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(ProductIDExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(ProductIDExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = ProductIDExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CProductID::Invoke
HRESULT CProductID::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_PRODUCTID_GET_PID:
        {

            TRACE(L"DISPID_PRODUCTID_GET_PID\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_PID(&(pvarResult->bstrVal));
            }
            break;
        }

        case DISPID_PRODUCTID_SET_PID:
        {

            TRACE(L"DISPID_PRODUCTID_SET_PID\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_PID(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

        case DISPID_PRODUCTID_GET_ACCEPTED:
        {

            TRACE(L"DISPID_PRODUCTID_GET_ACCEPTED\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;

                get_PIDAcceptance((BOOL*)&(pvarResult->boolVal));
            }
            break;
        }

        case DISPID_PRODUCTID_VALIDATEPID:
        {

            TRACE(L"DISPID_PRODUCTID_VALIDATEPID\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;


                ValidatePID((BOOL*)&(pvarResult->boolVal));
            }
            break;
        }

        case DISPID_PRODUCTID_GET_CURRENT_PID2:
        {

            TRACE(L"DISPID_PRODUCTID_GET_CURRENT_PID2");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_CurrentPID2(&(pvarResult->bstrVal));
            }
            break;
        }

        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}


#ifdef PRERELEASE
BOOL
GetCdKey (
    OUT     PBYTE CdKey
    )
{
    DIGITALPID dpid;
    DWORD type;
    DWORD rc;
    HKEY key;
    DWORD size = sizeof (dpid);
    BOOL b = FALSE;

    rc = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), &key);
    if (rc == ERROR_SUCCESS) {
        rc = RegQueryValueEx (key, TEXT("DigitalProductId"), NULL, &type, (LPBYTE)&dpid, &size);
        if (rc == ERROR_SUCCESS && type == REG_BINARY) {
            CopyMemory (CdKey, &dpid.abCdKey, sizeof (dpid.abCdKey));
            b = TRUE;
        }
        else
        {
            TRACE1(L"OOBE: GetDigitalID, RegQueryValueEx failed, errorcode = %d", rc);
        }

        RegCloseKey (key);
    }
    else
    {
        TRACE1(L"OOBE: GetDigitalID, RegOpenKey failed, errorcode = %d", rc);
    }

    return b;
}
const unsigned int iBase = 24;

//
//	obtained from Jim Harkins 11/27/2000
//
void EncodePid3g(
    TCHAR *pchCDKey3Chars,   // [OUT] pointer to 29+1 character Secure Product key
    LPBYTE pbCDKey3)        // [IN] pointer to 15-byte binary Secure Product Key
{
    // Given the binary PID 3.0 we need to encode
    // it into ASCII characters.  We're only allowed to
    // use 24 characters so we need to do a base 2 to
    // base 24 conversion.  It's just like any other
    // base conversion execpt the numbers are bigger
    // so we have to do the long division ourselves.

    const TCHAR achDigits[] = TEXT("BCDFGHJKMPQRTVWXY2346789");
    int iCDKey3Chars = 29;
    int cGroup = 0;

    pchCDKey3Chars[iCDKey3Chars--] = TEXT('\0');

    while (0 <= iCDKey3Chars)
    {
        unsigned int i = 0;    // accumulator
        int iCDKey3;

        for (iCDKey3 = 15-1; 0 <= iCDKey3; --iCDKey3)
        {
            i = (i * 256) + pbCDKey3[iCDKey3];
            pbCDKey3[iCDKey3] = (BYTE)(i / iBase);
            i %= iBase;
        }

        // i now contains the remainder, which is the current digit
        pchCDKey3Chars[iCDKey3Chars--] = achDigits[i];

        // add '-' between groups of 5 chars
        if (++cGroup % 5 == 0 && iCDKey3Chars > 0)
        {
	        pchCDKey3Chars[iCDKey3Chars--] = TEXT('-');
        }
    }

    return;
}
#endif

void CheckDigitalID()
{
#ifdef PRERELEASE
    WCHAR   WinntPath[MAX_PATH];
    BYTE abCdKey[16];
    TCHAR ProductId[64] = TEXT("\0"),
          szPid[32];

    if (GetCdKey (abCdKey))
    {
        EncodePid3g (ProductId, abCdKey);
        // Now compare this value with the productKey value from $winnt$.inf
        if(GetCanonicalizedPath(WinntPath, WINNT_INF_FILENAME))
        {
            if (GetPrivateProfileString(L"UserData",
                                    REG_VAL_PRODUCTKEY,
                                    L"\0",
                                    szPid, MAX_CHARS_IN_BUFFER(szPid),
                                    WinntPath) != 0)
            {
                if (lstrcmpi(szPid, ProductId) != 0)
                {
                    TRACE1(L"CheckDigitalID: PID in registry and file are different. Registry has: %s",ProductId);
                }
                else
                {
                    TRACE(L"CheckDigitalID checks out OK");
                }
            }
            else
            {
                TRACE1(L"CheckDigitalID:Could not get PID from File: %s", WinntPath);
            }
        }
        else
        {
            TRACE1(L"CheckDigitalID: Could not get path to %s", WINNT_INF_FILENAME);
        }
    }
#endif
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\precomp.h ===
#ifndef     _PRECOMP_H_
#define _PRECOMP_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: precomp.h
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Neptune
//
//  Revision History:
//      00/08/08    dane    Created
//
//////////////////////////////////////////////////////////////////////////////



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <guiddef.h>
#include <wtypes.h>
#include <setupapi.h>
#include <syssetup.h>
#include <ole2.h>
#include <oleauto.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <winsvcp.h>
#include <ntsetup.h>


#endif  //  _PRECOMP_H_

//
///// End of file: precomp.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\register.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  Register.H - Header for the implementation of CRegister
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 

#ifndef _Register_H_ 
#define _Register_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>


class CRegister : public IDispatch
{  
private:
    ULONG m_cRef;
	HINSTANCE m_hInstance;

    //GET functions
    HRESULT get_PostToMSN   (LPVARIANT pvResult);
    HRESULT get_PostToOEM   (LPVARIANT pvResult);
    HRESULT get_RegPostURL   (LPVARIANT pvResult);
    HRESULT get_OEMAddRegPage(LPVARIANT pvResult);

public: 
    
     CRegister (HINSTANCE hInstance);
    ~CRegister ();
    
    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\setup.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  SETUP.CPP - Provides Setup functionality
//
//  HISTORY:
//
//  3/14/2000 steveow Created.
//

#include "precomp.h"
#include "msobmain.h"


BOOL
WINAPI
SetupGetValidEula(
    PCWSTR  Eula,
    PWSTR   Path
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\setup.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  APPDEFS.H - Header for setup functionality
//
//  HISTORY:
//
//  3/14/2000 steveow Created.
//
// Header for setup functionality

BOOL
WINAPI
SetupGetValidEula(
    PCWSTR Eula,
    PWSTR  Path
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\register.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  Register.CPP - Header for the implementation of CRegister
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "register.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include "resource.h"

DISPATCHLIST RegisterExternalInterface[] =
{
    {L"get_PostToMSN",       DISPID_REGISTER_POSTTOMSN    },
    {L"get_PostToOEM",       DISPID_REGISTER_POSTTOOEM    },
    {L"get_RegPostURL",      DISPID_REGISTER_REGPOSTURL   },
    {L"get_OEMAddRegPage",   DISPID_REGISTER_OEMADDREGPAGE}
};

/////////////////////////////////////////////////////////////
// CRegister::CRegister
CRegister::CRegister(HINSTANCE hInstance)
{

    // Init member vars
    m_cRef = 0;
    m_hInstance = hInstance;
}

/////////////////////////////////////////////////////////////
// CRegister::~CRegister
CRegister::~CRegister()
{
    assert(m_cRef == 0);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Register
////

HRESULT CRegister::get_PostToMSN(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OEMREGISTRATIONPAGE,
                            IDS_KEY_POSTTOMSN, pvResult);
}

HRESULT CRegister::get_PostToOEM(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OEMREGISTRATIONPAGE,
                                IDS_KEY_POSTTOOEM, pvResult);
}

HRESULT CRegister::get_RegPostURL(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OEMREGISTRATIONPAGE,
                                IDS_KEY_REGPOSTURL, pvResult);
}

HRESULT CRegister::get_OEMAddRegPage(LPVARIANT pvResult)
{
    return GetINIKeyUINT(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_OEMREGISTRATIONPAGE,
                                IDS_OEM_ADDREGPAGE, pvResult);
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CRegister::QueryInterface
STDMETHODIMP CRegister::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CRegister::AddRef
STDMETHODIMP_(ULONG) CRegister::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CRegister::Release
STDMETHODIMP_(ULONG) CRegister::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CRegister::GetTypeInfo
STDMETHODIMP CRegister::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CRegister::GetTypeInfoCount
STDMETHODIMP CRegister::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CRegister::GetIDsOfNames
STDMETHODIMP CRegister::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(RegisterExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(RegisterExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = RegisterExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CRegister::Invoke
HRESULT CRegister::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_REGISTER_POSTTOMSN:
        {

            TRACE(L"DISPID_REGISTER_POSTTOMSN\n");

            if (NULL != pvarResult)
                get_PostToMSN(pvarResult);
            break;
        }

        case DISPID_REGISTER_POSTTOOEM:
        {

            TRACE(L"DISPID_REGISTER_POSTTOOEM\n");

            if (NULL != pvarResult)
                get_PostToOEM(pvarResult);
            break;
        }

        case DISPID_REGISTER_REGPOSTURL:
        {

            TRACE(L"DISPID_REGISTER_REGPOSTURL\n");

            if (NULL != pvarResult)
                get_RegPostURL(pvarResult);
            break;
        }

        case DISPID_REGISTER_OEMADDREGPAGE:
        {

            TRACE(L"DISPID_REGISTER_OEMADDREGPAGE\n");

            if (NULL != pvarResult)
                get_OEMAddRegPage(pvarResult);
            break;
        }

        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\resource.h ===
#define IDS_APPNAME                             500
#define IDS_QUERYCANCEL                         501
#define IDS_STATUS_REG_KEY                      502
#define IDS_SECTION_STARTUPOPTIONS              504
#define IDS_SECTION_DIALOG_DISPLAY              505
#define IDS_SECTION_OEMHARDWARECHECK            506
#define IDS_SECTION_OEMREGISTRATIONPAGE         507
#define IDS_SECTION_BROWSENOW                   509
#define IDS_SECTION_SIGNUP                      510
#define IDS_KEY_OFFLINE                         512
#define IDS_KEY_MOUSETUTORIAL                   513
#define IDS_KEY_INTL_SETTINGS                   514
#define IDS_KEY_OEMHWCHECK                      515
#define IDS_KEY_OEMREGPAGE                      516
#define IDS_KEY_ISPSIGNUP                       517
#define IDS_KEY_OEMOFFERCODE                    518
#define IDS_KEY_BROWSENOW                       519
#define IDS_KEY_LOCALE                          520
#define IDS_KEY_IDLOCALE                        521
#define IDS_KEY_TEXT1                           522
#define IDS_KEY_TEXT2                           523
#define IDS_SECTION_OPTIONS                     524
#define IDS_MSN_URL                             525
#define IDS_SECTION_STATUS_ITEMS                526
#define IDS_SECTION_BRANDING                    527
#define IDS_KEY_OEMNAME                         528
#define IDS_DESKTOP                             529
#define IDS_CONNECT_DESKTOP_TITLE               530
#define IDS_KEY_OEMCUST                         531
#define IDS_KEY_POSTTOOEM                       532
#define IDS_KEY_POSTTOMSN                       533
#define IDS_KEY_REGPOSTURL                      534
#define IDS_KEY_OEMADDREGPAGE                   535
#define IDS_KEY_TIMEZONE                        536
#define IDS_KEY_TIMEZONEVAL                     537
#define IDS_OEM_LICENSE_DLG_TITLE               538
#define IDS_KEY_IMETUTORIAL                     539
#define IDS_OEM_ADDREGPAGE                      540
#define IDS_TAPI_NEWLOC                         541
#define IDS_REG_REMINDER_TASK                   542
#define IDS_ISP_REMINDER_TASK                   543
#define IDS_OEMEULATEXT                         544
#define IDS_OEMEULA                             545
#define IDS_REG_REMINDER_TITLE                  546
#define IDS_ISP_REMINDER_TITLE                  547
#define IDS_SUPPORT_PHONE_NUMBER                548
#define IDS_MSN_TITLE                           549
#define IDS_KEY_FONTSMOOTHING                   550
#define IDS_NOWELCOMEFINISH                     551
#define IDS_NOISPPRECONFIG                      552
#define IDS_NOEULA                              553
#define IDS_SFTW_IS_LICENSED                    554
#define IDS_DOWELCOMEFADEIN                     555
#define IDS_SKIPANIMATION                       556
#define IDS_KEY_RETAILOOBE                      557
#define IDS_ACCTNAME_ADMINISTRATOR              558
#define IDS_ACCTNAME_GUEST                      559
#define IDS_ACCTNAME_HELPASSISTANT              560
#define IDS_INTROONLY                           561
#define IDS_AGENTDISABLED                       562
#define IDS_ACCTNAME_DEFAULT                    563
#define IDS_ACT_REMINDER_TITLE                  564
#define IDS_GROPNAME_ADMINISTRATORS             565
// The following number is depended on by msobcomm!EnumBuildInAdministrators
// If you change the number for IDS_ACCTLIST_RESERVEDADMINS, you need to change
// the corresponding number in msobcomm\misc.cpp
#define IDS_ACCTLIST_RESERVEDADMINS             566

#define IDS_NOT_ADMIN                           567
#define IDS_ALREADY_RUNNING                     568
#define IDS_PLEASE_WAIT                         569
#define IDS_CONNECTOID_NAME                     570
#define IDS_SCRIPTING_DISABLED                  571
#define IDS_KEY_SHOWISPMIGRATION                573
#define IDS_SAFEMODE                            574

#define IDS_NAME_COLLISION_LIST                 575
#define IDS_NAME_COLLISION_LIST_PER             576

#define IDS_KEY_JOINDOMAIN                      577
#define IDS_KEY_ADMINPASSWORD                   578

#define IDD_OEMLICENSE                          800
#define IDD_OEMAUDIT                            801

#define IDC_OEMLICENSE_TEXT                    1000
#define IDC_STATIC                             1001
#define IDC_RESTORE                            1002
#define IDC_ENDUSER                            1003
#define IDC_NONE_RESTORE                       1004
#define IDC_AUDIT_GRPBOX                       1005

#define IDI_MSN_ICON                            200
//#define IDB_BACKGROUND                          201
#define IDI_OOBE_ICON                           202
#define IDB_PROBACKGROUND                       203
#define IDB_HOMEBACKGROUND                      204
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\setupkey.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: setupkey.cpp
//
//  Author: Dan Elliott
//
//  Abstract: Definition of the CSetupKey object.  This object provides methods
//  for accessing values under HKLM\System\Setup.
//
//  Environment:
//      Neptune
//
//  Revision History:
//      00/08/08    dane    Created.
//
//////////////////////////////////////////////////////////////////////////////

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)


//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include "precomp.h"
#include "msobmain.h"
#include "setupkey.h"

//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//


CSetupKey::CSetupKey()
: m_hkey(NULL)
{
    LONG                lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            REGSTR_PATH_SYSTEMSETUPKEY,
                                            0,
                                            KEY_ALL_ACCESS,
                                            &m_hkey
                                            );
    MYASSERT(ERROR_SUCCESS == lRet);
    MYASSERT(NULL != m_hkey);

}   // CSetupKey::CSetupKey

CSetupKey::~CSetupKey()
{
    if (NULL != m_hkey)
    {
        RegCloseKey(m_hkey);
    }

}   // CSetupKey::~CSetupKey

LRESULT
CSetupKey::set_CommandLine(
    LPCWSTR             szCmdLine
    )
{
    MYASSERT(IsValid());
    MYASSERT(NULL != szCmdLine);

    return RegSetValueEx(m_hkey, REGSTR_VALUE_CMDLINE, 0, REG_SZ,
                         (BYTE*)szCmdLine,
                         BYTES_REQUIRED_BY_SZ(szCmdLine)
                         );

}   //  CSetupKey::set_CommandLine

LRESULT
CSetupKey::get_CommandLine(
    LPWSTR              szCommandLine,
    DWORD               cchCommandLine
    )
{
    MYASSERT(IsValid());
    MYASSERT(NULL != szCommandLine);
    MYASSERT(0 < cchCommandLine);

    if (NULL == szCommandLine || 0 == cchCommandLine)
    {
        return ERROR_INVALID_PARAMETER;
    }

    WCHAR               rgchCommandLine[MAX_PATH + 1];
    DWORD               dwSize = sizeof(rgchCommandLine);
    LRESULT             lResult = RegQueryValueEx(
                                            m_hkey,
                                            REGSTR_VALUE_CMDLINE,
                                            0,
                                            NULL,
                                            (LPBYTE)rgchCommandLine,
                                            &dwSize
                                            );
    if (ERROR_SUCCESS == lResult)
    {
        if (cchCommandLine >= (DWORD)(lstrlen(rgchCommandLine) + 1))
        {
            lstrcpy(szCommandLine, rgchCommandLine);
        }
        else
        {
            lResult = ERROR_INSUFFICIENT_BUFFER;
            *szCommandLine = '\0';
        }
    }

    return lResult;
} //    CSetupKey::get_CommandLine

LRESULT
CSetupKey::set_SetupType(
    DWORD               dwSetupType)
{
    MYASSERT(IsValid());
    MYASSERT(   dwSetupType == SETUPTYPE_NONE
           || dwSetupType == SETUPTYPE_FULL
           || dwSetupType == SETUPTYPE_NOREBOOT
           || dwSetupType == SETUPTYPE_UPGRADE
           );

    return RegSetValueEx(m_hkey, REGSTR_VALUE_SETUPTYPE, 0, REG_DWORD,
                         (BYTE*)&dwSetupType, sizeof(DWORD)
                         );

}   //  CSetupKey::set_SetupType

LRESULT
CSetupKey::get_SetupType(
    DWORD*              pdwSetupType
    )
{
    MYASSERT(IsValid());
    MYASSERT(NULL != pdwSetupType);

    if (NULL == pdwSetupType)
    {
        return ERROR_INVALID_PARAMETER;
    }


    DWORD               dwSetupType;
    DWORD               dwSize = sizeof(DWORD);
    LRESULT             lResult = RegQueryValueEx(
                                            m_hkey,
                                            REGSTR_VALUE_SETUPTYPE,
                                            0,
                                            NULL,
                                            (LPBYTE)&dwSetupType,
                                            &dwSize
                                            );

    *pdwSetupType = (ERROR_SUCCESS == lResult) ? dwSetupType : SETUPTYPE_NONE;

    // Since FALSE is returned in cases where we fail to read a value,
    // ERROR_SUCCESS can always be returned.
    //
    return ERROR_SUCCESS;
}   //  CSetupKey::get_SetupType

LRESULT
CSetupKey::set_MiniSetupInProgress(
    BOOL                fInProgress)
{
    MYASSERT(IsValid());

    if (fInProgress)
    {
        DWORD               dwData = (DWORD)fInProgress;
        return RegSetValueEx(m_hkey, REGSTR_VALUE_MINISETUPINPROGRESS, 0,
                             REG_DWORD, (BYTE*)&dwData, sizeof(DWORD)
                             );
    }
    else
    {
        return RegDeleteValue(m_hkey, REGSTR_VALUE_MINISETUPINPROGRESS);
    }

}   //  CSetupKey::set_MiniSetupInProgress

LRESULT
CSetupKey::get_MiniSetupInProgress(
    BOOL*               pfInProgress
    )
{
    MYASSERT(IsValid());
    MYASSERT(NULL != pfInProgress);

    if (NULL == pfInProgress)
    {
        return ERROR_INVALID_PARAMETER;
    }

    BOOL                fInProgress;
    DWORD               dwSize = sizeof(DWORD);
    LRESULT             lResult = RegQueryValueEx(
                                            m_hkey,
                                            REGSTR_VALUE_MINISETUPINPROGRESS,
                                            0,
                                            NULL,
                                            (LPBYTE)&fInProgress,
                                            &dwSize
                                            );

    *pfInProgress = (ERROR_SUCCESS == lResult) ? fInProgress : FALSE;

    // Since FALSE is returned in cases where we fail to read a value,
    // ERROR_SUCCESS can always be returned.
    //
    return ERROR_SUCCESS;
}   //  CSetupKey::get_MiniSetupInProgress

LRESULT
CSetupKey::set_OobeInProgress(
    BOOL                fInProgress)
{
    MYASSERT(IsValid());

    if (fInProgress)
    {
        DWORD               dwData = (DWORD)fInProgress;
        return RegSetValueEx(m_hkey, REGSTR_VALUE_OOBEINPROGRESS, 0, REG_DWORD,
                             (BYTE*)&dwData, sizeof(DWORD));
    }
    else
    {
        return RegDeleteValue(m_hkey, REGSTR_VALUE_OOBEINPROGRESS);
    }


}   //  CSetupKey::set_OobeInProgress

LRESULT
CSetupKey::get_OobeInProgress(
    BOOL*               pfInProgress
    )
{
    MYASSERT(IsValid());
    MYASSERT(NULL != pfInProgress);

    if (NULL == pfInProgress)
    {
        return ERROR_INVALID_PARAMETER;
    }

    BOOL                fInProgress;
    DWORD               dwSize = sizeof(DWORD);
    LRESULT             lResult = RegQueryValueEx(
                                            m_hkey,
                                            REGSTR_VALUE_OOBEINPROGRESS,
                                            0,
                                            NULL,
                                            (LPBYTE)&fInProgress,
                                            &dwSize
                                            );

    *pfInProgress = (ERROR_SUCCESS == lResult) ? fInProgress : FALSE;

    // Since FALSE is returned in cases where we fail to read a value,
    // ERROR_SUCCESS can always be returned.
    //
    return ERROR_SUCCESS;
}   //  CSetupKey::get_OobeInProgress

LRESULT
CSetupKey::set_ShutdownAction(
    OOBE_SHUTDOWN_ACTION OobeShutdownAction
    )
{
    MYASSERT(IsValid());
    MYASSERT(SHUTDOWN_MAX > OobeShutdownAction);

    DWORD           dwData;

    switch (OobeShutdownAction)
    {
    case SHUTDOWN_NOACTION: // fall through
    case SHUTDOWN_LOGON:
        return RegDeleteValue(m_hkey, REGSTR_VALUE_SHUTDOWNREQUIRED);

    case SHUTDOWN_REBOOT:
        dwData = ShutdownReboot;
        return RegSetValueEx(m_hkey, REGSTR_VALUE_SHUTDOWNREQUIRED, 0,
                             REG_DWORD, (BYTE*)&dwData, sizeof(DWORD)
                             );

    case SHUTDOWN_POWERDOWN:
        dwData = ShutdownNoReboot;
        return RegSetValueEx(m_hkey, REGSTR_VALUE_SHUTDOWNREQUIRED, 0,
                             REG_DWORD, (BYTE*)&dwData, sizeof(DWORD)
                             );

    default:
        return ERROR_INVALID_DATA;
    }


}   //  CSetupKey::set_ShutdownAction

LRESULT
CSetupKey::get_ShutdownAction(
    OOBE_SHUTDOWN_ACTION*    pOobeShutdownAction
    )
{
    MYASSERT(IsValid());
    MYASSERT(NULL != pOobeShutdownAction);

    if (NULL == pOobeShutdownAction)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD               ShutdownAction;
    DWORD               dwSize = sizeof(DWORD);
    LRESULT             lResult = RegQueryValueEx(
                                            m_hkey,
                                            REGSTR_VALUE_SHUTDOWNREQUIRED,
                                            0,
                                            NULL,
                                            (LPBYTE)&ShutdownAction,
                                            &dwSize
                                            );
    if (ERROR_SUCCESS == lResult)
    {
        switch ((SHUTDOWN_ACTION)ShutdownAction)
        {
        case ShutdownReboot:
            *pOobeShutdownAction = SHUTDOWN_REBOOT;
            break;
        case ShutdownNoReboot:  // fall through
        case ShutdownPowerOff:
            *pOobeShutdownAction = SHUTDOWN_POWERDOWN;
            break;
        }

    }
    else
    {
        // if the key doesn't exist, assume no action is required.
        //
        *pOobeShutdownAction = SHUTDOWN_NOACTION;
    }

    // Since FALSE is returned in cases where we fail to read a value,
    // ERROR_SUCCESS can always be returned.
    //
    return ERROR_SUCCESS;

}   //  CSetupKey::get_ShutdownAction


//
///// End of file: setupkey.cpp   ////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\setupkey.h ===
#ifndef     _SETUPKEY_H_
#define _SETUPKEY_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: setupkey.h
//
//  Author: Dan Elliott
//
//  Abstract: Declaration of the CSetupKey object.  This object provides methods
//  for accessing values under HKLM\System\Setup.
//
//  Environment:
//      Neptune
//
//  Revision History:
//      00/08/08    dane    Created.
//
//////////////////////////////////////////////////////////////////////////////


#include <appdefs.h>

#define REGSTR_PATH_SETUPKEY        REGSTR_PATH_SETUP REGSTR_KEY_SETUP
#define REGSTR_PATH_SYSTEMSETUPKEY  L"System\\Setup"
#define REGSTR_VALUE_CMDLINE        L"CmdLine"
#define REGSTR_VALUE_SETUPTYPE      L"SetupType"
#define REGSTR_VALUE_MINISETUPINPROGRESS L"MiniSetupInProgress"
#define REGSTR_VALUE_SHUTDOWNREQUIRED L"SetupShutdownRequired"



//////////////////////////////////////////////////////////////////////////////
//
// CSetupKey
//
class CSetupKey
{
public:                 // operations
    CSetupKey( );
    ~CSetupKey( );
    LRESULT set_CommandLine(LPCWSTR szCmdLine);
    LRESULT get_CommandLine(LPWSTR szCmdLine, DWORD cchCmdLine);
    LRESULT set_SetupType(DWORD dwSetupType);
    LRESULT get_SetupType(DWORD* pdwSetupType);
    LRESULT set_MiniSetupInProgress(BOOL fInProgress);
    LRESULT get_MiniSetupInProgress(BOOL* pfInProgress);
    LRESULT set_OobeInProgress(BOOL fInProgress);
    LRESULT get_OobeInProgress(BOOL* pfInProgress);
    LRESULT set_ShutdownAction(OOBE_SHUTDOWN_ACTION OobeShutdownAction);
    LRESULT get_ShutdownAction(OOBE_SHUTDOWN_ACTION* pOobeShutdownAction);


    BOOL
    IsValid( ) const
    {
        return (NULL != m_hkey);
    }   //  IsValid
protected:              // operations

protected:              // data

private:                // operations



    // Explicitly disallow copy constructor and assignment operator.
    //
    CSetupKey(
        const CSetupKey&      rhs
        );

    CSetupKey&
    operator=(
        const CSetupKey&      rhs
        );


private:                // data
    // Handle to HKLM\System\Setup
    //
    HKEY                    m_hkey;

};  //  class CSetupKey



#endif  //  _SETUPKEY_H_

//
///// End of file: setupkey.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\signup.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  SIGNUP.CPP - Header for the implementation of CSignup
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "signup.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include "resource.h"

DISPATCHLIST SignupExternalInterface[] =
{
    {L"get_Locale",   DISPID_SIGNUP_GET_LOCALE   },
    {L"get_IDLocale",   DISPID_SIGNUP_GET_IDLOCALE   },
    {L"get_Text1",   DISPID_SIGNUP_GET_TEXT1   },
    {L"get_Text2",   DISPID_SIGNUP_GET_TEXT2   },
    {L"get_OEMName",   DISPID_SIGNUP_GET_OEMNAME   },
};

/////////////////////////////////////////////////////////////
// CSignup::CSignup
CSignup::CSignup(HINSTANCE hInstance)
{

    // Init member vars
    m_cRef = 0;
    m_hInstance = hInstance;
}

/////////////////////////////////////////////////////////////
// CSignup::~CSignup
CSignup::~CSignup()
{
    assert(m_cRef == 0);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: SignupLocale
////

HRESULT CSignup::get_Locale(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_SIGNUP,
                            IDS_KEY_LOCALE, pvResult);
}

HRESULT CSignup::get_IDLocale(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_SIGNUP,
                                IDS_KEY_IDLOCALE, pvResult);
}

HRESULT CSignup::get_Text1(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_SIGNUP,
                                IDS_KEY_TEXT1, pvResult);
}

HRESULT CSignup::get_Text2(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_SIGNUP,
                            IDS_KEY_TEXT2, pvResult);
}

HRESULT CSignup::get_OEMName(LPVARIANT pvResult)
{
    return GetINIKeyBSTR(m_hInstance, INI_SETTINGS_FILENAME, IDS_SECTION_BRANDING,
                            IDS_KEY_OEMNAME, pvResult);
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CSignup::QueryInterface
STDMETHODIMP CSignup::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CSignup::AddRef
STDMETHODIMP_(ULONG) CSignup::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CSignup::Release
STDMETHODIMP_(ULONG) CSignup::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CSignup::GetTypeInfo
STDMETHODIMP CSignup::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CSignup::GetTypeInfoCount
STDMETHODIMP CSignup::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CSignup::GetIDsOfNames
STDMETHODIMP CSignup::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(SignupExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(SignupExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = SignupExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CSignup::Invoke
HRESULT CSignup::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_SIGNUP_GET_LOCALE:
        {

            TRACE(L"DISPID_SIGNUP_GET_LOCALE\n");

            if (NULL != pvarResult)
                get_Locale(pvarResult);
            break;
        }

        case DISPID_SIGNUP_GET_IDLOCALE:
        {

            TRACE(L"DISPID_SIGNUP_GET_IDLOCALE\n");

            if (NULL != pvarResult)
                get_IDLocale(pvarResult);
            break;
        }

        case DISPID_SIGNUP_GET_TEXT1:
        {

            TRACE(L"DISPID_SIGNUP_GET_TEXT1\n");

            if (NULL != pvarResult)
                get_Text1(pvarResult);
            break;
        }

        case DISPID_SIGNUP_GET_TEXT2:
        {

            TRACE(L"DISPID_SIGNUP_GET_TEXT2\n");

            if (NULL != pvarResult)
                get_Text2(pvarResult);
            break;
        }

        case DISPID_SIGNUP_GET_OEMNAME:
        {

            TRACE(L"DISPID_SIGNUP_GET_OEMNAME\n");

            if (NULL != pvarResult)
                get_OEMName(pvarResult);
            break;
        }

        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\status.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  Status.H - Header for the implementation of CStatus
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 

#ifndef _STATUS_H_ 
#define _STATUS_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>


class CStatus : public IDispatch
{  
private:
    ULONG m_cRef;
    WCHAR m_szRegPath[1024]; //bugbug could this be smaller?

    //SET functions
    HRESULT set_Status   (LPCWSTR szGUID, LPVARIANT pvBool);

public: 
    
    //GET functions
    HRESULT get_Status   (LPCWSTR szGUID, LPVARIANT pvBool);

    CStatus (HINSTANCE hInstance);
    ~CStatus ();
    
    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif // _STATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\status.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  Status.CPP - Header for the implementation of CStatus
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "status.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include "resource.h"

CONST WCHAR GUIDPIDCOMPLETED[]  = L"{2B7AF08A-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDTAPICOMPLETED[] = L"{2B7AF08B-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDLANGUAGECOMPLETED[]
                                = L"{2B7AF08C-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDEULACOMPLETED[] = L"{2B7AF08D-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDMOUSETUTORCOMPLETED[]
                                = L"{2B7AF08E-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDUSERINFOPOSTED[]
                                = L"{2B7AF08F-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDUSERINFOSTAMPED[]
                                = L"{2B7AF093-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDOEMINFOCOMPLETED[]
                                = L"{2B7AF090-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDISPSIGNUPCOMPLETED[]
                                = L"{2B7AF091-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDSIGNATURECOMPLETED[]
                                = L"{2B7AF092-C619-11d2-B71B-00C04F794977}";
CONST WCHAR GUIDTIMEZONECOMPLETED[]
                                = L"{23EC9481-C951-11d2-B275-0080C7CF863E}";


DISPATCHLIST StatusExternalInterface[] =
{
    {L"get_PIDCompleted",       DISPID_STATUS_GET_PID_COMPLETED         },
    {L"set_PIDCompleted",       DISPID_STATUS_SET_PID_COMPLETED         },
    {L"get_TAPICompleted",      DISPID_STATUS_GET_TAPI_COMPLETED        },
    {L"set_TAPICompleted",      DISPID_STATUS_SET_TAPI_COMPLETED        },
    {L"get_LanguageCompleted",  DISPID_STATUS_GET_LANGUAGE_COMPLETED    },
    {L"set_LanguageCompleted",  DISPID_STATUS_SET_LANGUAGE_COMPLETED    },
    {L"get_EULACompleted",      DISPID_STATUS_GET_EULA_COMPLETED        },
    {L"set_EULACompleted",      DISPID_STATUS_SET_EULA_COMPLETED        },
    {L"get_MouseTutorCompleted",DISPID_STATUS_GET_MOUSETUTOR_COMPLETED  },
    {L"set_MouseTutorCompleted",DISPID_STATUS_SET_MOUSETUTOR_COMPLETED  },
    {L"get_UserInfoPosted",     DISPID_STATUS_GET_USERINFO_POSTED       },
    {L"set_UserInfoPosted",     DISPID_STATUS_SET_USERINFO_POSTED       },
    {L"get_UserInfoStamped",    DISPID_STATUS_GET_USERINFO_STAMPED      },
    {L"set_UserInfoStamped",    DISPID_STATUS_SET_USERINFO_STAMPED      },
    {L"get_OEMInfoCompleted",   DISPID_STATUS_GET_OEMINFO_COMPLETED     },
    {L"set_OEMInfoCompleted",   DISPID_STATUS_SET_OEMINFO_COMPLETED     },
    {L"get_ISPSignupCompleted", DISPID_STATUS_GET_ISPSIGNUP_COMPLETED   },
    {L"set_ISPSignupCompleted", DISPID_STATUS_SET_ISPSIGNUP_COMPLETED   },
    {L"get_SignatureCompleted", DISPID_STATUS_GET_SIGNATURE_COMPLETED   },
    {L"set_SignatureCompleted", DISPID_STATUS_SET_SIGNATURE_COMPLETED   },
    {L"get_TimeZoneCompleted",  DISPID_STATUS_GET_TIMEZONE_COMPLETED    },
    {L"set_TimeZoneCompleted",  DISPID_STATUS_SET_TIMEZONE_COMPLETED    },
    {L"get_Status",             DISPID_STATUS_GET_STATUS                },
    {L"set_Status",             DISPID_STATUS_SET_STATUS                }
};

/////////////////////////////////////////////////////////////
// CStatus::CStatus
CStatus::CStatus(HINSTANCE hInstance)
{

    // Init member vars
    m_cRef = 0;

    lstrcpy(m_szRegPath, OOBE_MAIN_REG_KEY);
    GetString(hInstance, IDS_STATUS_REG_KEY, m_szRegPath + lstrlen(m_szRegPath));
}

/////////////////////////////////////////////////////////////
// CStatus::~CStatus
CStatus::~CStatus()
{
    assert(m_cRef == 0);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Status
////
HRESULT CStatus::set_Status(LPCWSTR szGUID, LPVARIANT pvBool)
{
    HKEY hKey = NULL;
    LONG rc = ERROR_SUCCESS;
    
    if (VARIANT_TRUE == V_BOOL(pvBool))
    {
        WCHAR szCompletePath[1024];
        lstrcpy(szCompletePath, m_szRegPath);
        lstrcat(szCompletePath, L"\\");
        lstrcat(szCompletePath, szGUID);
        rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szCompletePath, 0,
                        NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    }
    else
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                           m_szRegPath,
                                           0,
                                           KEY_QUERY_VALUE,
                                           &hKey))
            RegDeleteKey(hKey, szGUID); 

    }
    if (NULL != hKey)
        RegCloseKey(hKey);
    
    return (ERROR_SUCCESS == rc ? S_OK : E_FAIL);
}

HRESULT CStatus::get_Status(LPCWSTR szGUID, LPVARIANT pvBool)
{
    VariantInit(pvBool);
    V_VT(pvBool) = VT_BOOL;

    HKEY hKey;
    WCHAR szCompletePath[1024];
    lstrcpy(szCompletePath, m_szRegPath);
    lstrcat(szCompletePath, L"\\");
    lstrcat(szCompletePath, szGUID);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       szCompletePath,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hKey))
    {
        V_BOOL(pvBool) = VARIANT_TRUE;
        RegCloseKey(hKey);
    }
    else
        V_BOOL(pvBool) = VARIANT_FALSE;
    
    return (S_OK);
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CStatus::QueryInterface
STDMETHODIMP CStatus::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CStatus::AddRef
STDMETHODIMP_(ULONG) CStatus::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CStatus::Release
STDMETHODIMP_(ULONG) CStatus::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CStatus::GetTypeInfo
STDMETHODIMP CStatus::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CStatus::GetTypeInfoCount
STDMETHODIMP CStatus::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CStatus::GetIDsOfNames
STDMETHODIMP CStatus::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(StatusExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(StatusExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = StatusExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CStatus::Invoke
HRESULT CStatus::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
    case DISPID_STATUS_GET_PID_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_PID_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDPIDCOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_TAPI_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_TAPI_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDTAPICOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_LANGUAGE_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_LANGUAGE_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDLANGUAGECOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_EULA_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_EULA_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDEULACOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_MOUSETUTOR_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_MOUSETUTOR_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDMOUSETUTORCOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_USERINFO_POSTED:

        TRACE(L"DISPID_STATUS_GET_USERINFO_POSTED\n");

        if (NULL != pvarResult)
            get_Status(GUIDUSERINFOPOSTED, pvarResult);
        break;

    case DISPID_STATUS_GET_USERINFO_STAMPED:

        TRACE(L"DISPID_STATUS_GET_USERINFO_STAMPED\n");

        if (NULL != pvarResult)
            get_Status(GUIDUSERINFOSTAMPED, pvarResult);
        break;

    case DISPID_STATUS_GET_OEMINFO_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_OEMINFO_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDOEMINFOCOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_ISPSIGNUP_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_ISPSIGNUP_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDISPSIGNUPCOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_SIGNATURE_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_SIGNATURE_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDSIGNATURECOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_TIMEZONE_COMPLETED:

        TRACE(L"DISPID_STATUS_GET_TIMEZONE_COMPLETED\n");

        if (NULL != pvarResult)
            get_Status(GUIDTIMEZONECOMPLETED, pvarResult);
        break;

    case DISPID_STATUS_GET_STATUS:

        TRACE(L"DISPID_STATUS_GET_STATUS\n");

        if (NULL != pdispparams && NULL != pvarResult && 0 < pdispparams->cArgs)
            get_Status(V_BSTR(pdispparams->rgvarg), pvarResult);
        break;

    case DISPID_STATUS_SET_PID_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_PID_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDPIDCOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_TAPI_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_TAPI_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDTAPICOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_LANGUAGE_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_LANGUAGE_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDLANGUAGECOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_EULA_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_EULA_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDEULACOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_MOUSETUTOR_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_MOUSETUTOR_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDMOUSETUTORCOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_USERINFO_POSTED:

        TRACE(L"DISPID_STATUS_SET_USERINFO_POSTED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDUSERINFOPOSTED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_USERINFO_STAMPED:

        TRACE(L"DISPID_STATUS_SET_USERINFO_STAMPED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDUSERINFOSTAMPED, pdispparams->rgvarg);
        break;

   case DISPID_STATUS_SET_OEMINFO_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_OEMINFO_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDOEMINFOCOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_ISPSIGNUP_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_ISPSIGNUP_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDISPSIGNUPCOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_SIGNATURE_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_SIGNATURE_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDSIGNATURECOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_TIMEZONE_COMPLETED:

        TRACE(L"DISPID_STATUS_SET_TIMEZONE_COMPLETED\n");

        if (NULL != pdispparams && 0 < pdispparams->cArgs)
            set_Status(GUIDTIMEZONECOMPLETED, pdispparams->rgvarg);
        break;

    case DISPID_STATUS_SET_STATUS:

        TRACE(L"DISPID_STATUS_SET_STATUS\n");

        if (NULL != pdispparams && 1 < pdispparams->cArgs)
            set_Status(V_BSTR(&pdispparams->rgvarg[1]), &pdispparams->rgvarg[0]);
        break;

    default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\signup.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  Signup.H - Header for the implementation of CSignup
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 

#ifndef _Signup_H_ 
#define _Signup_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>


class CSignup : public IDispatch
{  
private:
    ULONG m_cRef;
	HINSTANCE m_hInstance;

    //GET functions
    HRESULT get_Locale   (LPVARIANT pvResult);
    HRESULT get_IDLocale   (LPVARIANT pvResult);
    HRESULT get_Text1   (LPVARIANT pvResult);
    HRESULT get_Text2   (LPVARIANT pvResult);
    HRESULT get_OEMName   (LPVARIANT pvResult);

public: 
    
     CSignup (HINSTANCE hInstance);
    ~CSignup ();
    
    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\sysclock.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  PID.CPP - Header for the implementation of CSystemClock
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#include "sysclock.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include "resource.h"
#include <stdlib.h>

int WINAPI StrToWideStr(LPWSTR pwsz, LPCSTR psz)
{
    return MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, MAX_PATH);
}

DISPATCHLIST SystemClockExternalInterface[] =
{
    { L"set_TimeZone",          DISPID_SYSTEMCLOCK_SETTIMEZONE          },
    { L"set_Time",              DISPID_SYSTEMCLOCK_SETTIME              },
    { L"set_Date",              DISPID_SYSTEMCLOCK_SETDATE              },

    // new oobe2 methods below, others are currently unused

    { L"Init",                  DISPID_SYSTEMCLOCK_INIT                 },
    { L"get_AllTimeZones",      DISPID_SYSTEMCLOCK_GETALLTIMEZONES      },
    { L"get_TimeZoneIdx",       DISPID_SYSTEMCLOCK_GETTIMEZONEIDX       },
    { L"set_TimeZoneIdx",       DISPID_SYSTEMCLOCK_SETTIMEZONEIDX       },
    { L"set_AutoDaylight",      DISPID_SYSTEMCLOCK_SETAUTODAYLIGHT      },
    { L"get_AutoDaylight",      DISPID_SYSTEMCLOCK_GETAUTODAYLIGHT      },
    { L"get_DaylightEnabled",   DISPID_SYSTEMCLOCK_GETDAYLIGHT_ENABLED  },
    { L"get_TimeZonewasPreset", DISPID_SYSTEMCLOCK_GETTIMEZONEWASPRESET }
};

/////////////////////////////////////////////////////////////
// CSystemClock::CSystemClock
CSystemClock::CSystemClock(HINSTANCE hInstance)
{

    // Init member vars
    m_cRef                  = 0;
    m_cNumTimeZones         = 0;
    m_pTimeZoneArr          = NULL;
    m_szTimeZoneOptionStrs  = NULL;
    m_uCurTimeZoneIdx       = 0;
    m_bSetAutoDaylightMode  = TRUE;  // on by default
    m_bTimeZonePreset       = FALSE;
    m_hInstance=hInstance;
}

/////////////////////////////////////////////////////////////
// CSystemClock::~CSystemClock
CSystemClock::~CSystemClock()
{
   MYASSERT(m_cRef == 0);

   if ( m_pTimeZoneArr )
       HeapFree(GetProcessHeap(), 0x0, (LPVOID)  m_pTimeZoneArr );

   if(m_szTimeZoneOptionStrs)
        HeapFree(GetProcessHeap(), 0x0,(LPVOID) m_szTimeZoneOptionStrs);

   m_cNumTimeZones = 0;
   m_pTimeZoneArr = NULL;
   m_szTimeZoneOptionStrs = NULL;
}

int CSystemClock::GetTimeZoneValStr() {
    LPCWSTR szINIFileName   = INI_SETTINGS_FILENAME;
    UINT    uiSectionName   = IDS_SECTION_OPTIONS;
    UINT    uiKeyName       = IDS_KEY_TIMEZONEVAL;
    int     Result          = -1;

    WCHAR szSectionName[1024], szKeyName[1024];

    if(GetString(m_hInstance, uiSectionName, szSectionName) && GetString(m_hInstance, uiKeyName, szKeyName))
    {
        WCHAR szINIPath[MAX_PATH];

        if(GetCanonicalizedPath(szINIPath, szINIFileName))
            Result = GetPrivateProfileInt(szSectionName, szKeyName, -1, szINIPath);
    }

    return Result;
}


int
__cdecl
TimeZoneCompare(
    const void *arg1,
    const void *arg2
    )
{
    int     BiasDiff = ((PTZINFO)arg2)->Bias - ((PTZINFO)arg1)->Bias;


    if (BiasDiff) {
        return BiasDiff;
    } else {
        return lstrcmp(
            ((PTZINFO)arg1)->szDisplayName,
            ((PTZINFO)arg2)->szDisplayName
            );
    }
}


HRESULT CSystemClock::InitSystemClock()
{
    // constructor cant return failure, so make separate init fn

    DWORD       cDefltZoneNameLen, cTotalDispNameSize;
    HRESULT     hr;
    HKEY        hRootZoneKey     = NULL;
    HKEY        hTimeZoneInfoKey = NULL;


    hr = RegOpenKey(HKEY_LOCAL_MACHINE, TIME_ZONE_REGKEY, &hRootZoneKey);
    if(hr != ERROR_SUCCESS)
      return hr;

    // find number of keys, length of default keystr
    hr= RegQueryInfoKey(hRootZoneKey, NULL,NULL,NULL,
                        &m_cNumTimeZones,
                        NULL,  // longest subkey name length
                        NULL,  // longest class string length
                        NULL,  // number of value entries
                        &cDefltZoneNameLen,  // longest value name length
                        NULL,  // longest value data length
                        NULL,  // security descriptor length
                        NULL); // last write time

    if(hr != ERROR_SUCCESS)
      return hr;

    MYASSERT(cDefltZoneNameLen<TZNAME_SIZE);

    MYASSERT(m_cNumTimeZones>0  && m_cNumTimeZones<1000);  // ensure reasonable value

    cTotalDispNameSize=0;

    if(m_pTimeZoneArr!=NULL)
        HeapFree(GetProcessHeap(), 0x0,m_pTimeZoneArr);

    m_pTimeZoneArr = (PTZINFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,  (m_cNumTimeZones+2) * sizeof(TZINFO) );

    if( m_pTimeZoneArr == NULL)
      return ERROR_OUTOFMEMORY;

    DWORD   i;
    WCHAR   CurZoneKeyName[MAXKEYNAMELEN];
    DWORD   CurZoneKeyNameLen;
    HKEY    hCurZoneKey = NULL;
    HRESULT hrEnumRes   = ERROR_SUCCESS;

    for(i=0;hrEnumRes==ERROR_SUCCESS; i++) {
       CurZoneKeyNameLen=sizeof(CurZoneKeyName);

       hr = hrEnumRes = RegEnumKeyEx(hRootZoneKey, i,CurZoneKeyName,&CurZoneKeyNameLen,NULL,NULL,NULL,NULL);
       if(!((hr == ERROR_NO_MORE_ITEMS) || (hr ==ERROR_SUCCESS)))
          return hr;

#ifdef DBG
       if(hr!=ERROR_NO_MORE_ITEMS)
          MYASSERT(CurZoneKeyNameLen<MAXKEYNAMELEN);  // for some reason CurZoneKeyNameLen is reset to the orig value at the end of the enumeration
#endif

       // call ReadZoneData for each KeyName

       hr=RegOpenKey(hRootZoneKey, CurZoneKeyName, &hCurZoneKey);
       if(hr != ERROR_SUCCESS)
         return hr;

       hr = ReadZoneData(&m_pTimeZoneArr[i], hCurZoneKey, CurZoneKeyName);

       if(hr != S_OK)
         return hr;

       cTotalDispNameSize+= BYTES_REQUIRED_BY_SZ(m_pTimeZoneArr[i].szDisplayName) + sizeof(WCHAR);  //+1 for safety

       RegCloseKey(hCurZoneKey);
    }

    MYASSERT((i-1)==m_cNumTimeZones);

    DWORD uType, uLen = sizeof(DefltZoneKeyValue);

    MYASSERT(uLen>cDefltZoneNameLen);

    //
    // Get the current timezone name.
    //
    hr = RegOpenKey( HKEY_LOCAL_MACHINE,
                     TIME_ZONE_INFO_REGKEY,
                     &hTimeZoneInfoKey
                     );

    if ( hr != ERROR_SUCCESS )
        return hr;

    hr = RegQueryValueEx( hTimeZoneInfoKey,
                          TIMEZONE_STANDARD_NAME,
                          NULL,
                          &uType,
                          (LPBYTE)DefltZoneKeyValue,
                          &uLen
                          );

    if(hr != ERROR_SUCCESS)
        return hr;

    RegCloseKey( hTimeZoneInfoKey );
    hTimeZoneInfoKey = NULL;

    //
    // Sort our array of timezones.
    //
    qsort(
        m_pTimeZoneArr,
        m_cNumTimeZones,
        sizeof(TZINFO),
        TimeZoneCompare
        );

    // Set the timezone by the value in oobeinfo.ini, if specified
    int iINIidx=GetTimeZoneValStr();

    if ( iINIidx != -1 ) {

        // Search for the specified Index
        for(i=0;i<m_cNumTimeZones; i++) {
            if ( m_pTimeZoneArr[i].Index == iINIidx ) {
                m_uCurTimeZoneIdx = i;
                break;
            }
        }

        // need to tell script to skip tz page if we do the preset
        // set timezone to preset value

        if(i<m_cNumTimeZones) {
            m_bTimeZonePreset=TRUE;
        }
    }

    // find index of default std name
    if ( !m_bTimeZonePreset ) {
        for(i=0;i<m_cNumTimeZones; i++) {
           if(CSTR_EQUAL==CompareString(LOCALE_USER_DEFAULT, 0,
                                        DefltZoneKeyValue, -1,
                                        m_pTimeZoneArr[i].szStandardName, -1))
               break;
        }

        if(i>=m_cNumTimeZones) {
            // search failed, the default stdname value of the timezone root key does not
            // exist in the subkeys's stdnames, use default of 0
            i = 0;
        }

        m_uCurTimeZoneIdx = i;
    }

    // Create the SELECT tag OPTIONS for the html so it can get all the country names in one shot.
    if(m_szTimeZoneOptionStrs)
        HeapFree(GetProcessHeap(), 0x0,m_szTimeZoneOptionStrs);

    cTotalDispNameSize += m_cNumTimeZones * sizeof(szOptionTag) + 1;

    m_szTimeZoneOptionStrs = (WCHAR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cTotalDispNameSize);
    if(m_szTimeZoneOptionStrs == NULL)
      return ERROR_OUTOFMEMORY;

    WCHAR szTempBuf[MAX_PATH];

    for (i=0; i < m_cNumTimeZones; i++)
    {
        wsprintf(szTempBuf, szOptionTag, m_pTimeZoneArr[i].szDisplayName);
        lstrcat(m_szTimeZoneOptionStrs, szTempBuf);
    }

    return hr;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: System clock stuff
////

HRESULT CSystemClock::set_Time(WORD wHour, WORD wMinute, WORD wSec)
{
    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    SystemTime.wHour   = wHour;
    SystemTime.wMinute = wMinute;
    SystemTime.wSecond = wSec;

    SystemTime.wMilliseconds = 0;

    SetLocalTime (&SystemTime);

    SendMessage((HWND)-1, WM_TIMECHANGE, 0, 0);

    return S_OK;
}

HRESULT CSystemClock::set_Date(WORD wMonth, WORD wDay, WORD wYear)
{
    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    SystemTime.wMonth  = wMonth;
    SystemTime.wDay    = wDay;
    SystemTime.wYear   = wYear;

    SetLocalTime (&SystemTime);

    SendMessage((HWND)-1, WM_TIMECHANGE, 0, 0);

    return S_OK;
}

HRESULT CSystemClock::set_TimeZone(BSTR bstrTimeZone)
{

    TZINFO tZone;

    ZeroMemory((void*)&tZone, sizeof(TZINFO));

    BOOL   bRet    = FALSE;
    HKEY   hKey    = NULL;
    HKEY   hSubKey = NULL;

    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TIME_ZONE_REGKEY, &hKey))
    {
        // user can pass key name
        if(RegOpenKey(hKey, bstrTimeZone, &hSubKey) == ERROR_SUCCESS)
        {
            if(ReadZoneData(&tZone, hSubKey, bstrTimeZone))
                bRet = TRUE;
        }
        RegCloseKey(hKey);

        if(bRet)
            SetTheTimezone(m_bSetAutoDaylightMode, &tZone);
    }

    SendMessage((HWND)-1, WM_TIMECHANGE, 0, 0);

    return S_OK;
}

HRESULT CSystemClock::ReadZoneData(PTZINFO ptZone, HKEY hKey, LPCWSTR szKeyName)
{
    DWORD dwLen = 0;
    HRESULT hr;

    dwLen = sizeof(ptZone->szDisplayName);

    if(ERROR_SUCCESS != (hr = RegQueryValueEx(hKey,
                                        TIME_ZONE_DISPLAYNAME_REGVAL,
                                        0,
                                        NULL,
                                        (LPBYTE)ptZone->szDisplayName,
                                        &dwLen)))
    {
        if(hr == ERROR_MORE_DATA) {
            // registry strings from timezone.inf are too long (timezone.inf author error)
            // truncate them
            ptZone->szDisplayName[sizeof(ptZone->szDisplayName)-1]=L'\0';
        } else
           return hr;
    }

    dwLen = sizeof(ptZone->szStandardName);

    if(ERROR_SUCCESS != (hr = RegQueryValueEx(hKey,
                                        TIME_ZONE_STANDARDNAME_REGVAL,
                                        0,
                                        NULL,
                                        (LPBYTE)ptZone->szStandardName,
                                        &dwLen)))
    {
        if(hr == ERROR_MORE_DATA) {
            // registry strings from timezone.inf are too long (timezone.inf author error)
            // truncate them
            ptZone->szStandardName[sizeof(ptZone->szStandardName)-1]=L'\0';
        } else {
          // use keyname if cant get StandardName value
          lstrcpyn(ptZone->szStandardName, szKeyName, MAX_CHARS_IN_BUFFER(ptZone->szStandardName));
        }
    }

    dwLen = sizeof(ptZone->szDaylightName);

    if(ERROR_SUCCESS != (hr = RegQueryValueEx(hKey,
                                        TIME_ZONE_DAYLIGHTNAME_REGVAL,
                                        0,
                                        NULL,
                                        (LPBYTE)ptZone->szDaylightName,
                                        &dwLen)))
    {
        if(hr == ERROR_MORE_DATA) {
            // registry strings from timezone.inf are too long (timezone.inf author error)
            // truncate them
            ptZone->szDaylightName[sizeof(ptZone->szDaylightName)-1]=L'\0';
        } else
           return hr;
    }

    // get the Index
    dwLen = sizeof(ptZone->Index);

    if(ERROR_SUCCESS != (hr = RegQueryValueEx(hKey,
                                        TIME_ZONE_INDEX_REGVAL,
                                        NULL,
                                        NULL,
                                        (LPBYTE) &(ptZone->Index),
                                        &dwLen)))
    {
        return hr;
    }

    // read all these fields in at once, the way they are stored in registry
    dwLen = sizeof(ptZone->Bias)         +
            sizeof(ptZone->StandardBias) +
            sizeof(ptZone->DaylightBias) +
            sizeof(ptZone->StandardDate) +
            sizeof(ptZone->DaylightDate);

    if(ERROR_SUCCESS != (hr = RegQueryValueEx(hKey,
                                        TIME_ZONE_TZI_REGVAL,
                                        NULL,
                                        NULL,
                                        (LPBYTE) &(ptZone->Bias),
                                        &dwLen)))
    {
        // registry data from timezone.inf is too long (timezone.inf author error)
        // no good fallback behavior for binary data, so fail it so people notice the problem
        return hr;
    }

    return S_OK;
}

BOOL CSystemClock::SetTheTimezone(BOOL fAutoDaylightSavings, PTZINFO ptZone)
{
    TIME_ZONE_INFORMATION   tzi;
    WCHAR                   szIniFile[MAX_PATH] = L"";
    BOOL                    KeepCurrentTime = FALSE;
    SYSTEMTIME              SysTime;
    BOOL                    bRet;


    ZeroMemory((void*)&tzi, sizeof(TIME_ZONE_INFORMATION));

    if (ptZone==NULL)
        return FALSE;

    lstrcpyn(tzi.StandardName, ptZone->szStandardName,
            MAX_CHARS_IN_BUFFER(tzi.StandardName));
    lstrcpyn(tzi.DaylightName, ptZone->szStandardName,
            MAX_CHARS_IN_BUFFER(tzi.DaylightName));
    tzi.Bias = ptZone->Bias;
    tzi.StandardBias = ptZone->StandardBias;
    tzi.DaylightBias = ptZone->DaylightBias;
    tzi.StandardDate = ptZone->StandardDate;
    tzi.DaylightDate = ptZone->DaylightDate;

    SetAllowLocalTimeChange(fAutoDaylightSavings);

    //
    // KeepCurrentTime means we don't want the time shift that normally occurs
    // when the timezone is changed.
    //
    if (GetCanonicalizedPath(szIniFile, INI_SETTINGS_FILENAME))
    {
        KeepCurrentTime = (GetPrivateProfileInt(OPTIONS_SECTION,
                                    OOBE_KEEPCURRENTTIME,
                                    -1,
                                    szIniFile) == 1);
    }

    if (KeepCurrentTime)
    {
        GetLocalTime( &SysTime );
    }
    bRet = SetTimeZoneInformation(&tzi);
    if (KeepCurrentTime)
    {
        SetLocalTime( &SysTime );
    }
    return bRet;
}

void CSystemClock::GetTimeZoneInfo(BOOL fAutoDaylightSavings, PTZINFO ptZone)
{
    TIME_ZONE_INFORMATION tzi;

    ZeroMemory((void*)&tzi, sizeof(TIME_ZONE_INFORMATION));

    if (!ptZone)
        return;

    lstrcpyn(tzi.StandardName, ptZone->szStandardName,
            MAX_CHARS_IN_BUFFER(tzi.StandardName));
    lstrcpyn(tzi.DaylightName, ptZone->szStandardName,
            MAX_CHARS_IN_BUFFER(tzi.DaylightName));
    tzi.Bias = ptZone->Bias;
    tzi.StandardBias = ptZone->StandardBias;
    tzi.DaylightBias = ptZone->DaylightBias;
    tzi.StandardDate = ptZone->StandardDate;
    tzi.DaylightDate = ptZone->DaylightDate;

    SetAllowLocalTimeChange(fAutoDaylightSavings);
    SetTimeZoneInformation(&tzi);

}

void CSystemClock::SetAllowLocalTimeChange(BOOL fAutoDaylightSavings)
{
    HKEY  hKey  = NULL;
    DWORD dwVal = 1;

    if(fAutoDaylightSavings)
    {
        // remove the disallow flag from the registry if it exists
        if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
                                       REGSTR_PATH_TIMEZONE,
                                       &hKey))
        {
            RegDeleteValue(hKey, REGSTR_VAL_TZNOAUTOTIME);
        }
    }
    else
    {
        // add/set the nonzero disallow flag
        if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
                                         REGSTR_PATH_TIMEZONE,
                                         &hKey))
        {
            RegSetValueEx(hKey,
                         (LPCWSTR)REGSTR_VAL_TZNOAUTOTIME,
                         0UL,
                         REG_DWORD,
                         (LPBYTE)&dwVal,
                         sizeof(dwVal));
        }
    }

    if(hKey)
        RegCloseKey(hKey);
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CSystemClock::QueryInterface
STDMETHODIMP CSystemClock::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CSystemClock::AddRef
STDMETHODIMP_(ULONG) CSystemClock::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CSystemClock::Release
STDMETHODIMP_(ULONG) CSystemClock::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CSystemClock::GetTypeInfo
STDMETHODIMP CSystemClock::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CSystemClock::GetTypeInfoCount
STDMETHODIMP CSystemClock::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CSystemClock::GetIDsOfNames
STDMETHODIMP CSystemClock::GetIDsOfNames(REFIID    riid,
                                       OLECHAR** rgszNames,
                                       UINT      cNames,
                                       LCID      lcid,
                                       DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(SystemClockExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(SystemClockExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = SystemClockExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CSystemClock::Invoke
HRESULT CSystemClock::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_SYSTEMCLOCK_INIT:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_INIT\n");

            InitSystemClock();
            break;
        }

        case DISPID_SYSTEMCLOCK_GETALLTIMEZONES:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_GETALLTIMEZONES\n");

            if (m_cNumTimeZones && m_szTimeZoneOptionStrs && pvarResult) {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;
                pvarResult->bstrVal = SysAllocString(m_szTimeZoneOptionStrs);
            }
            break;
        }

        case DISPID_SYSTEMCLOCK_GETTIMEZONEIDX:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_GETTIMEZONEIDX\n");

            if(pvarResult==NULL)
              break;

            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = m_uCurTimeZoneIdx;
            break;
        }

        case DISPID_SYSTEMCLOCK_SETTIMEZONEIDX:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_SETTIMEZONEIDX\n");

            if(pdispparams && (&pdispparams[0].rgvarg[0]))
            {
                BOOL bReboot;
                m_uCurTimeZoneIdx = pdispparams[0].rgvarg[0].iVal;

                SetTheTimezone(m_bSetAutoDaylightMode,
                               &m_pTimeZoneArr[m_uCurTimeZoneIdx]
                               );
                if (pvarResult != NULL)
                {
                    WCHAR szWindowsRoot[MAX_PATH];
                    BOOL  bCheckTimezone = TRUE;
                    VariantInit(pvarResult);
                    V_VT(pvarResult) = VT_BOOL;
                    V_BOOL(pvarResult) = Bool2VarBool(FALSE);

                    if (GetWindowsDirectory(szWindowsRoot, MAX_PATH))
                    {
                        // If Windows is installed on an NTFS volume,
                        // no need to check the timezones and evtl reboot
                        // The problem we are working around only exists on FAT
                        bCheckTimezone = !(IsDriveNTFS(szWindowsRoot[0]));
                    }
                    if (bCheckTimezone)
                    {
                        // If the name of the default time zone the now selected one is different, we need a reboot.
                        // Problem with fonts, if the time zone changes.
                        V_BOOL(pvarResult) = Bool2VarBool(CSTR_EQUAL!=CompareString(LOCALE_USER_DEFAULT, 0,
                                            DefltZoneKeyValue, -1,
                                            m_pTimeZoneArr[m_uCurTimeZoneIdx].szStandardName, -1));
                    }

                }
            }
            break;
        }

        case DISPID_SYSTEMCLOCK_GETAUTODAYLIGHT:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_GETAUTODAYLIGHT\n");

            if(pvarResult==NULL)
              break;

            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = Bool2VarBool(m_bSetAutoDaylightMode);
            break;
        }

        case DISPID_SYSTEMCLOCK_GETDAYLIGHT_ENABLED:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_GETDAYLIGHT_ENABLED\n");

            if(pvarResult==NULL)
                break;

            if(!(pdispparams && (&pdispparams[0].rgvarg[0])))
            {
                break;
            }

            DWORD iTzIdx = pdispparams[0].rgvarg[0].iVal;

            if(iTzIdx >= m_cNumTimeZones)
            {
                break;
            }

            // if either daylight change date is invalid (0), no daylight savings time for that zone
            BOOL bEnabled = !((m_pTimeZoneArr[iTzIdx].StandardDate.wMonth == 0) ||
                              (m_pTimeZoneArr[iTzIdx].DaylightDate.wMonth == 0));

            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = Bool2VarBool(bEnabled);
            break;
        }

        case DISPID_SYSTEMCLOCK_GETTIMEZONEWASPRESET:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_GETTIMEZONEWASPRESET\n");

            if(pvarResult==NULL)
              break;

            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = Bool2VarBool(m_bTimeZonePreset);
            break;
        }

        case DISPID_SYSTEMCLOCK_SETAUTODAYLIGHT:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_SETAUTODAYLIGHT\n");

            if(!(pdispparams && (&pdispparams[0].rgvarg[0])))
            {
              break;
            }

            m_bSetAutoDaylightMode = pdispparams[0].rgvarg[0].boolVal;
            break;
        }

        case DISPID_SYSTEMCLOCK_SETTIMEZONE:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_SETTIMEZONE\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_TimeZone(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

        case DISPID_SYSTEMCLOCK_SETTIME:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_SETTIME\n");

            if(pdispparams               &&
               &pdispparams[0].rgvarg[0] &&
               &pdispparams[0].rgvarg[1] &&
               &pdispparams[0].rgvarg[2]
              )
            {
                set_Time(pdispparams[0].rgvarg[2].iVal,
                         pdispparams[0].rgvarg[1].iVal,
                         pdispparams[0].rgvarg[0].iVal);
            }
            break;
        }

        case DISPID_SYSTEMCLOCK_SETDATE:
        {

            TRACE(L"DISPID_SYSTEMCLOCK_SETDATE\n");

            if(pdispparams               &&
               &pdispparams[0].rgvarg[0] &&
               &pdispparams[0].rgvarg[1] &&
               &pdispparams[0].rgvarg[2]
              )
            {
                set_Date(pdispparams[0].rgvarg[2].iVal,
                         pdispparams[0].rgvarg[1].iVal,
                         pdispparams[0].rgvarg[0].iVal);
            }
            break;
        }

        default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\sysclock.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  SYSCLOCK.H - Header for the implementation of CSystemClock
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#ifndef _SYSCLOCK_H_
#define _SYSCLOCK_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>
#include <regstr.h>

// Time Zone data value keys

#define TIME_ZONE_REGKEY \
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"

#define TIME_ZONE_INFO_REGKEY \
    L"SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation"

#define TIMEZONE_STANDARD_NAME \
    L"StandardName"

#define TIME_ZONE_DISPLAYNAME_REGVAL  L"Display"
#define TIME_ZONE_STANDARDNAME_REGVAL L"Std"
#define TIME_ZONE_DAYLIGHTNAME_REGVAL L"Dlt"
#define TIME_ZONE_INDEX_REGVAL        L"Index"
#define TIME_ZONE_TZI_REGVAL          L"TZI"
#define TIME_ZONE_MAPINFO_REGVAL      L"MapID"

#define TZNAME_SIZE 32
#define TZDISPLAYZ  500
#define MAXKEYNAMELEN 100


// stuff from registry goes in here
// whole point of this re-ordered structure is
// because registry stores the last 5 fields
// together in hex, want to read them in all at once
typedef struct tagTZINFO {
    struct tagTZINFO *next;
    WCHAR       szDisplayName[TZDISPLAYZ];
    WCHAR       szStandardName[TZNAME_SIZE];
    WCHAR       szDaylightName[TZNAME_SIZE];
    LONG        Index;
    LONG       Bias;
    LONG       StandardBias;
    LONG       DaylightBias;
    SYSTEMTIME StandardDate;
    SYSTEMTIME DaylightDate;
} TZINFO, NEAR *PTZINFO;


class CSystemClock : public IDispatch
{
private:
    ULONG m_cRef;

    WCHAR   *m_szTimeZoneOptionStrs;
    PTZINFO  m_pTimeZoneArr;
    ULONG    m_cNumTimeZones, m_uCurTimeZoneIdx;
    BOOL     m_bSetAutoDaylightMode;
    BOOL     m_bTimeZonePreset;
    HINSTANCE m_hInstance;
    WCHAR DefltZoneKeyValue[MAXKEYNAMELEN];

    //internal SET functions
    HRESULT  set_TimeZone (BSTR bstrTimeZone);
    HRESULT  set_Time     (WORD wHour, WORD wMinute, WORD wSec);
    HRESULT  set_Date     (WORD wMonth, WORD wDay, WORD wYear);

    //Methods
    void GetTimeZoneInfo(BOOL fAutoDaylightSavings, PTZINFO ptZone);
    void SetAllowLocalTimeChange (BOOL fAutoDaylightSavings);
    BOOL SetTheTimezone          (BOOL fAutoDaylightSavings, PTZINFO ptZone);
    HRESULT ReadZoneData            (PTZINFO ptZone, HKEY hKey, LPCWSTR szKeyName);
    HRESULT InitSystemClock();
    int GetTimeZoneValStr();

public:

     CSystemClock (HINSTANCE m_bhInstance);
    ~CSystemClock ();

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\userinfo.cpp ===
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOBMAIN.CPP - Header for the implementation of CObMain
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
//  Class which will provide the an IOleSite to the WebOC

#include "userinfo.h"
#include "appdefs.h"
#include "dispids.h"
#include "windowsx.h"
#include "msobmain.h"
#include "pid.h"
#include "msobmain.h"
#include "resource.h"
#include "shlwapi.h"

#define USER_INFO_INIFILE                OEMINFO_INI_FILENAME
#define USER_COMP_MANF_SEC               L"General"
#define USER_COMP_MANF_KEY               L"Manufacturer"

#define USERINFO_REG_KEY_FIRSTNAME       L"FirstName"
#define USERINFO_REG_KEY_MIDDLEINITIAL   L"MiddleInitial"
#define USERINFO_REG_KEY_LASTNAME        L"LastName"
#define USERINFO_REG_KEY_FURIGANANAME    L"FuriganaName"
#define USERINFO_REG_KEY_COMPANYNAME     L"CompanyName"
#define USERINFO_REG_KEY_ADDRESS1        L"Address1"
#define USERINFO_REG_KEY_ADDRESS2        L"Address2"
#define USERINFO_REG_KEY_CITY            L"City"
#define USERINFO_REG_KEY_STATE           L"State"
#define USERINFO_REG_KEY_ZIP             L"Zip"
#define USERINFO_REG_KEY_COUNTRY         L"Country"
#define USERINFO_REG_KEY_PRIMARYEMAIL    L"PrimaryEmail"
#define USERINFO_REG_KEY_SECONDARYEMAIL  L"SecondaryEmail"
#define USERINFO_REG_KEY_AREACODE        L"AreaCode"
#define USERINFO_REG_KEY_PHONENUMBER     L"PhoneNumber"
#define USERINFO_REG_KEY_IDENTITY        L"Identity"
#define USERINFO_REG_KEY_OWNERNAME       L"OwnerName"
#define USERINFO_REG_KEY_DEFAULTNEWUSER  L"DefaultNewUser"

#define DEFAULT_USEIDENTITIES   TRUE


DISPATCHLIST UserInfoExternalInterface[] =
{
    {L"get_FirstName",      DISPID_USERINFO_GET_FIRSTNAME      },
    {L"set_FirstName",      DISPID_USERINFO_SET_FIRSTNAME      },
    {L"get_MiddleInitial",  DISPID_USERINFO_GET_MIDDLEINITIAL  },
    {L"set_MiddleInitial",  DISPID_USERINFO_SET_MIDDLEINITIAL  },
    {L"get_LastName",       DISPID_USERINFO_GET_LASTNAME       },
    {L"set_LastName",       DISPID_USERINFO_SET_LASTNAME       },
    {L"get_FuriganaName",   DISPID_USERINFO_GET_FURIGANANAME   },
    {L"set_FuriganaName",   DISPID_USERINFO_SET_FURIGANANAME   },
    {L"get_CompanyName",    DISPID_USERINFO_GET_COMPANYNAME    },
    {L"set_CompanyName",    DISPID_USERINFO_SET_COMPANYNAME    },
    {L"get_Address1",       DISPID_USERINFO_GET_ADDRESS1       },
    {L"set_Address1",       DISPID_USERINFO_SET_ADDRESS1       },
    {L"get_Address2",       DISPID_USERINFO_GET_ADDRESS2       },
    {L"set_Address2",       DISPID_USERINFO_SET_ADDRESS2       },
    {L"get_City",           DISPID_USERINFO_GET_CITY           },
    {L"set_City",           DISPID_USERINFO_SET_CITY           },
    {L"get_State",          DISPID_USERINFO_GET_STATE          },
    {L"set_State",          DISPID_USERINFO_SET_STATE          },
    {L"get_Zip",            DISPID_USERINFO_GET_ZIP            },
    {L"set_Zip",            DISPID_USERINFO_SET_ZIP            },
    {L"get_Country",        DISPID_USERINFO_GET_COUNTRY        },
    {L"set_Country",        DISPID_USERINFO_SET_COUNTRY        },
    {L"get_CountryID",      DISPID_USERINFO_GET_COUNTRYID      },
    {L"set_CountryID",      DISPID_USERINFO_SET_COUNTRYID      },
    {L"get_PrimaryEmail",   DISPID_USERINFO_GET_PRIMARYEMAIL   },
    {L"set_PrimaryEmail",   DISPID_USERINFO_SET_PRIMARYEMAIL   },
    {L"get_SecondaryEmail", DISPID_USERINFO_GET_SECONDARYEMAIL },
    {L"set_SecondaryEmail", DISPID_USERINFO_SET_SECONDARYEMAIL },
    {L"get_AreaCode",       DISPID_USERINFO_GET_AREACODE       },
    {L"set_AreaCode",       DISPID_USERINFO_SET_AREACODE       },
    {L"get_PhoneNumber",    DISPID_USERINFO_GET_PHONENUMBER    },
    {L"set_PhoneNumber",    DISPID_USERINFO_SET_PHONENUMBER    },
    {L"get_MSUpdate",       DISPID_USERINFO_GET_MSUPDATE       },
    {L"set_MSUpdate",       DISPID_USERINFO_SET_MSUPDATE       },
    {L"get_MSOffer",        DISPID_USERINFO_GET_MSOFFER        },
    {L"set_MSOffer",        DISPID_USERINFO_SET_MSOFFER        },
    {L"get_OtherOffer",     DISPID_USERINFO_GET_OTHEROFFER     },
    {L"set_OtherOffer",     DISPID_USERINFO_SET_OTHEROFFER     },
    {L"get_Identity",       DISPID_USERINFO_GET_IDENTITY       },
    {L"set_Identity",       DISPID_USERINFO_SET_IDENTITY       },
    {L"get_IdentitiesMax",  DISPID_USERINFO_GET_IDENTITIESMAX  },
    {L"check_Identity",     DISPID_USERINFO_CHECK_IDENTITY     },
    {L"SuggestIdentity0",   DISPID_USERINFO_SUGGESTIDENTITY0   },
    {L"get_UseIdentities",  DISPID_USERINFO_GET_USEIDENTITIES  },
    {L"set_UseIdentities",  DISPID_USERINFO_SET_USEIDENTITIES  },
    {L"get_OEMIdentities",  DISPID_USERINFO_GET_OEMIDENTITIES  },
    {L"get_OwnerName",      DISPID_USERINFO_GET_OWNERNAME      },
    {L"set_OwnerName",      DISPID_USERINFO_SET_OWNERNAME      },
    {L"get_DefaultNewUser", DISPID_USERINFO_GET_DEFAULTNEWUSER },
};

const WCHAR csz_ADDR1[]                 = L"Addr1";
const WCHAR csz_ADDR2[]                 = L"Addr2";
const WCHAR csz_ADDRTYPE[]              = L"AddrType";
const WCHAR csz_AREACODE[]              = L"AreaCode";
const WCHAR csz_CITY[]                  = L"City";
const WCHAR csz_COMPANYNAME[]           = L"CompanyName";
const WCHAR csz_COUNTRYCODE[]           = L"CountryCode";
const WCHAR csz_DIVISIONNAME[]          = L"DivisionName";
const WCHAR csz_EMAILNAME[]             = L"EmailName";
const WCHAR csz_EXTENSION[]             = L"Extension";
const WCHAR csz_FNAME[]                 = L"FName";
const WCHAR csz_INFLUENCELEVEL[]        = L"InfluenceLevel";
const WCHAR csz_LANGCODE[]              = L"LangCode";
const WCHAR csz_LANGNAME[]              = L"LangName";
const WCHAR csz_LNAME[]                 = L"LName";
const WCHAR csz_MNAME[]                 = L"MName";
const WCHAR csz_NOOTHER[]               = L"NoOther";
const WCHAR csz_PHONE[]                 = L"Phone";
const WCHAR csz_PID[]                   = L"PID";
const WCHAR csz_PRODUCT[]               = L"Product";
const WCHAR csz_REGWIZVER[]             = L"RegWizVer";
const WCHAR csz_SOFTWAREROLE[]          = L"SoftwareRole";
const WCHAR csz_STATE[]                 = L"State";
const WCHAR csz_USERID[]                = L"UserID";
const WCHAR csz_ZIP[]                   = L"Zip";
const WCHAR CSZ_COMPUTERMANF[]          = L"ComputerManf";

REGDATAELEMENT aryRegDataElements[] =
{
    { csz_ADDR1,            NULL,   0},
    { csz_ADDR2,            NULL,   0},
    { csz_ADDRTYPE,         NULL,   0},
    { csz_AREACODE,         NULL,   0},
    { csz_CITY,             NULL,   0},
    { csz_COMPANYNAME,      NULL,   0},
    { csz_COUNTRYCODE,      NULL,   0},
    { csz_DIVISIONNAME,     NULL,   0},
    { csz_EMAILNAME,        NULL,   0},
    { csz_EXTENSION,        NULL,   0},
    { csz_FNAME,            NULL,   0},
    { csz_INFLUENCELEVEL,   NULL,   0},
    { csz_LANGCODE,         NULL,   0},
    { csz_LANGNAME,         NULL,   0},
    { csz_LNAME,            NULL,   0},
    { csz_MNAME,            NULL,   0},
    { csz_NOOTHER,          NULL,   0},
    { csz_PHONE,            NULL,   0},
    { csz_PID,              NULL,   0},
    { csz_PRODUCT,          NULL,   0},
    { csz_REGWIZVER,        NULL,   0},
    { csz_SOFTWAREROLE,     NULL,   0},
    { csz_STATE,            NULL,   0},
    { csz_USERID,           NULL,   0},
    { csz_ZIP,              NULL,   0},
    { CSZ_COMPUTERMANF,     NULL,   0}
};

enum
{
    INDEX_ADDR1                = 0,
    INDEX_ADDR2,               // = 1,
    INDEX_ADDRTYPE,            // = 2,
    INDEX_AREACODE,            // = 3,
    INDEX_CITY,                // = 4,
    INDEX_COMPANYNAME,         // = 5,
    INDEX_COUNTRYCODE,         // = 6,
    INDEX_DIVISIONNAME,        // = 7,
    INDEX_EMAILNAME,           // = 8,
    INDEX_EXTENSION,           // = 9,
    INDEX_FNAME,               // = 10,
    INDEX_INFLUENCELEVEL,      // = 11,
    INDEX_LANGCODE,            // = 12,
    INDEX_LANGNAME,            // = 13,
    INDEX_LNAME,               // = 14,
    INDEX_MNAME,               // = 15,
    INDEX_NOOTHER,             // = 16,
    INDEX_PHONE,               // = 17,
    INDEX_PID,                 // = 18,
    INDEX_PRODUCT,             // = 19,
    INDEX_REGWIZVER,           // = 20,
    INDEX_SOFTWAREROLE,        // = 21,
    INDEX_STATE,               // = 22,
    INDEX_USERID,              // = 23,
    INDEX_ZIP,                 // = 24,
    INDEX_COMPUTERMANF         // = 25

};

#define REGDATAELEMENTS_LEN sizeof(aryRegDataElements) / sizeof(REGDATAELEMENT)

const CUserInfo::RESERVED_IDENTITIES_IDS[] =
{
    IDS_ACCTNAME_ADMINISTRATOR,
    IDS_ACCTNAME_GUEST
};

/////////////////////////////////////////////////////////////
// CUserInfo::CUserInfo
CUserInfo::CUserInfo(HINSTANCE hInstance)
: m_hInstance(hInstance)
{

    WCHAR       szKeyName[]         = REG_KEY_OOBE_TEMP;
    HKEY        hKey                = NULL;

    BOOL        bName,
                bOrg;

    // Init member vars
    m_cRef        = 0;

    // What if it failed?
    GetCanonicalizedPath(m_szUserInfoINIFile, USER_INFO_INIFILE);

    RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hKey);

    // Initialize or restore registration data

    ReadUserInfo(hKey, USERINFO_REG_KEY_FIRSTNAME,      m_szFirstName,      sizeof(m_szFirstName)      );
    ReadUserInfo(hKey, USERINFO_REG_KEY_MIDDLEINITIAL,  m_szMiddleInitial,  sizeof(m_szMiddleInitial)  );
    ReadUserInfo(hKey, USERINFO_REG_KEY_LASTNAME,       m_szLastName,       sizeof(m_szLastName)       );
    ReadUserInfo(hKey, USERINFO_REG_KEY_FURIGANANAME,   m_szFuriganaName,   sizeof(m_szFuriganaName)   );
    ReadUserInfo(hKey, USERINFO_REG_KEY_COMPANYNAME,    m_szCompanyName,    sizeof(m_szCompanyName)    );
    ReadUserInfo(hKey, USERINFO_REG_KEY_ADDRESS1,       m_szAddress1,       sizeof(m_szAddress1)       );
    ReadUserInfo(hKey, USERINFO_REG_KEY_ADDRESS2,       m_szAddress2,       sizeof(m_szAddress2)       );
    ReadUserInfo(hKey, USERINFO_REG_KEY_CITY,           m_szCity,           sizeof(m_szCity)           );
    ReadUserInfo(hKey, USERINFO_REG_KEY_STATE,          m_szState,          sizeof(m_szState)          );
    ReadUserInfo(hKey, USERINFO_REG_KEY_ZIP,            m_szZip,            sizeof(m_szZip)            );
    ReadUserInfo(hKey, USERINFO_REG_KEY_COUNTRY,        m_szCountry,        sizeof(m_szCountry)        );
    ReadUserInfo(hKey, USERINFO_REG_KEY_PRIMARYEMAIL,   m_szPrimaryEmail,   sizeof(m_szPrimaryEmail)   );
    ReadUserInfo(hKey, USERINFO_REG_KEY_SECONDARYEMAIL, m_szSecondaryEmail, sizeof(m_szSecondaryEmail) );
    ReadUserInfo(hKey, USERINFO_REG_KEY_AREACODE,       m_szAreaCode,       sizeof(m_szAreaCode)       );
    ReadUserInfo(hKey, USERINFO_REG_KEY_PHONENUMBER,    m_szPhoneNumber,    sizeof(m_szPhoneNumber)    );

    // Initialize or restore new user accounts

    ReadUserInfo(hKey, USERINFO_REG_KEY_OWNERNAME,      m_szOwnerName,      sizeof(m_szOwnerName)      );
    ReadUserInfo(hKey, USERINFO_REG_KEY_DEFAULTNEWUSER ,m_szDefaultNewUser, sizeof(m_szDefaultNewUser) );
    
    m_fUseIdentities    = DEFAULT_USEIDENTITIES;
    m_fMSUpdate         = VARIANT_TRUE;
    m_fMSOffer          = VARIANT_TRUE;
    m_fOtherOffer       = VARIANT_TRUE;
    m_dwCountryID       = 0;

    // Need to distinguish between OEM preset identities and
    // Registry value, so ReadUserInfo is not used

    m_fOEMIdentities = FALSE;
    for (UINT uiIndex = 0; uiIndex < IDENTITIES_MAX; uiIndex++)
    {
        wsprintf(m_rgIdentities[uiIndex].rgchRegValue,
                 L"%s%03d",
                 USERINFO_REG_KEY_IDENTITY, uiIndex
                 );
        GetPrivateProfileString(USER_INFO_KEYNAME,
                                m_rgIdentities[uiIndex].rgchRegValue,
                                L"\0",
                                m_rgIdentities[uiIndex].rgchIdentity,
                                IDENTITY_CCH_MAX,
                                m_szUserInfoINIFile);
        TRACE4( L"%s/%s/%s=%s",
            m_szUserInfoINIFile,
            USER_INFO_KEYNAME,
            m_rgIdentities[uiIndex].rgchRegValue,
            m_rgIdentities[uiIndex].rgchIdentity );

        m_fOEMIdentities = m_fOEMIdentities ||
            (m_rgIdentities[uiIndex].rgchIdentity[0] != L'\0');
    }

    if ( (!m_fOEMIdentities) && (hKey != NULL) ) {
        for (uiIndex = 0; uiIndex < IDENTITIES_MAX; uiIndex++)
        {
            DWORD dwType = 0;
            DWORD dwSize = IDENTITY_CCH_MAX;

            RegQueryValueEx(hKey,
                            m_rgIdentities[uiIndex].rgchRegValue,
                            0,
                            &dwType,
                            (LPBYTE)m_rgIdentities[uiIndex].rgchIdentity,
                            &dwSize);
        }
    }

    if ( hKey )
        RegCloseKey(hKey);


    // Get the default name or org if there wasn't one already saved.
    //
    bName = FALSE;
    bOrg = ( *m_szCompanyName == L'\0' );

    // This is so OEMs can prepopulate the user or org field.  We just store the name
    // in the first name field.  We might want to split it up into First, MI, and Last
    // in the future?
    //

    if ( bName || bOrg ) {

        SetupGetSetupInfo(
            bName ? m_szFirstName : NULL,
            bName ? sizeof(m_szFirstName) : 0,
            m_szCompanyName ? m_szCompanyName : NULL,
            m_szCompanyName ? sizeof(m_szCompanyName) : 0,
            NULL,
            0,
            NULL
            );
    }

    m_RegDataElements = aryRegDataElements;
    m_RegDataElements[0].lpQueryElementValue  = (LPWSTR) m_szAddress1;
    m_RegDataElements[1].lpQueryElementValue  = (LPWSTR) m_szAddress2;
    m_RegDataElements[3].lpQueryElementValue  = (LPWSTR) m_szAreaCode;
    m_RegDataElements[4].lpQueryElementValue  = (LPWSTR) m_szCity;
    m_RegDataElements[5].lpQueryElementValue  = (LPWSTR) m_szCompanyName;
    m_RegDataElements[8].lpQueryElementValue  = (LPWSTR) m_szPrimaryEmail;
    m_RegDataElements[10].lpQueryElementValue = (LPWSTR) m_szFirstName;
    m_RegDataElements[15].lpQueryElementValue = (LPWSTR) m_szMiddleInitial;
    m_RegDataElements[14].lpQueryElementValue = (LPWSTR) m_szLastName;
    m_RegDataElements[17].lpQueryElementValue = (LPWSTR) m_szPhoneNumber;
    m_RegDataElements[22].lpQueryElementValue = (LPWSTR) m_szState;
    m_RegDataElements[24].lpQueryElementValue = (LPWSTR) m_szZip;

    for (int i = 0; i < RESERVED_IDENTITIES_MAX; i++)
    {
        if (!LoadString(
            m_hInstance,
            RESERVED_IDENTITIES_IDS[i],
            m_szReservedIdentities[i],
            sizeof(m_szReservedIdentities[i]) / sizeof(TCHAR)
            ))
        {
            m_szReservedIdentities[i][0] = L'\0';
        }
    }

}

/////////////////////////////////////////////////////////////
// CUserInfo::~CUserInfo
CUserInfo::~CUserInfo()
{
    assert(m_cRef == 0);
}

void CUserInfo::ReadUserInfo(HKEY hKey, WCHAR* pszKey, WCHAR* pszValue, DWORD dwSize)
{
    DWORD dwType = 0;
    DWORD cSize  = dwSize;

    *pszValue = L'\0';

    if( ( hKey == NULL) ||
        ( ERROR_SUCCESS != RegQueryValueEx(hKey,
                                           pszKey,
                                           0,
                                           &dwType,
                                           (LPBYTE)pszValue,
                                           &dwSize) || *pszValue == L'\0' ) )
    {
        GetPrivateProfileString(USER_INFO_KEYNAME,
                                pszKey,
                                L"\0",
                                pszValue,
                                cSize,
                                m_szUserInfoINIFile);
    }
}

void CUserInfo::WriteUserInfo(WCHAR* pszBuf, WCHAR* pszKey, WCHAR* pszValue)
{
    WCHAR   szKeyName[] = REG_KEY_OOBE_TEMP;
    HKEY    hKey;

    // A null value must be converted to an empty string.
    //
    if ( pszValue )
        lstrcpy(pszBuf, pszValue);
    else
        *pszBuf = L'\0';

    // Commit the data to the registry.
    //
    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS )
    {
        if ( *pszBuf )
            RegSetValueEx(hKey, pszKey, 0, REG_SZ, (LPBYTE) pszValue, BYTES_REQUIRED_BY_SZ(pszValue));
        else
            RegDeleteValue(hKey, pszKey);

        RegFlushKey(hKey);
        RegCloseKey(hKey);
    }
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Identity
////
HRESULT CUserInfo::get_Identity(UINT uiIndex, BSTR* pbstrVal)
{
    if (uiIndex >= IDENTITIES_MAX)
    {
        return E_INVALIDARG;
    }

    *pbstrVal = SysAllocString(m_rgIdentities[uiIndex].rgchIdentity);
    if (NULL == *pbstrVal)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CUserInfo::set_Identity(UINT uiIndex, WCHAR* pszVal)
{
    if (uiIndex < IDENTITIES_MAX)
    {
        if (!pszVal) // delete the account if it exists
        {
            WriteUserInfo(m_rgIdentities[uiIndex].rgchIdentity,
                          m_rgIdentities[uiIndex].rgchRegValue,
                          NULL);
        }
        else
        {
            if (lstrlen(pszVal) <= IDENTITY_CCH_MAX)
            {
                WriteUserInfo(m_rgIdentities[uiIndex].rgchIdentity,
                              m_rgIdentities[uiIndex].rgchRegValue,
                              pszVal
                              );

            }
        }
    }

    return S_OK;
}

HRESULT CUserInfo::get_Identities(PSTRINGLIST* pUserList)
{
    for (UINT uiIndex = 0; uiIndex < IDENTITIES_MAX; uiIndex++)
    {
        if (lstrlen(m_rgIdentities[uiIndex].rgchIdentity) > 0)
        {
            PSTRINGLIST Cell;

            Cell = CreateStringCell(m_rgIdentities[uiIndex].rgchIdentity);
            if (Cell)
            {
                FixString(Cell->String);
                InsertList(pUserList, Cell);
            }
        }
    }

    return S_OK;
}
////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: UseIdentities
////
HRESULT CUserInfo::get_UseIdentities(VARIANT_BOOL *pfVal)
{
    *pfVal = m_fUseIdentities;
    return S_OK;
}

HRESULT CUserInfo::set_UseIdentities(VARIANT_BOOL fVal)
{
    m_fUseIdentities = fVal;
    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: MSUpdate
////
HRESULT CUserInfo::get_MSUpdate(VARIANT_BOOL *pfVal)
{
    *pfVal = m_fMSUpdate;
    return S_OK;
}

HRESULT CUserInfo::set_MSUpdate(VARIANT_BOOL fVal)
{
    m_fMSUpdate = fVal;
    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: MSOffer
////
HRESULT CUserInfo::get_MSOffer(VARIANT_BOOL *pfVal)
{
    *pfVal = m_fMSOffer;
    return S_OK;
}

HRESULT CUserInfo::set_MSOffer(VARIANT_BOOL fVal)
{
    m_fMSOffer = fVal;
    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: OtherOffer
////
HRESULT CUserInfo::get_OtherOffer(VARIANT_BOOL *pfVal)
{
    *pfVal = m_fOtherOffer;
    return S_OK;
}

HRESULT CUserInfo::set_OtherOffer(VARIANT_BOOL fVal)
{
    m_fOtherOffer = fVal;
    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: CountryID
////
HRESULT CUserInfo::get_CountryID(DWORD *pdwVal)
{
    *pdwVal = m_dwCountryID;
    return S_OK;
}

HRESULT CUserInfo::set_CountryID(DWORD dwVal)
{
    m_dwCountryID = dwVal;
    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// CHECK :: Identity
////

// constant strings used for name validation
#define DOT_CHAR            '.'
#define DOT_AND_SPACE_STR   TEXT(". ")

#define CTRL_CHARS_0   TEXT(    "\001\002\003\004\005\006\007")
#define CTRL_CHARS_1   TEXT("\010\011\012\013\014\015\016\017")
#define CTRL_CHARS_2   TEXT("\020\021\022\023\024\025\026\027")
#define CTRL_CHARS_3   TEXT("\030\031\032\033\034\035\036\037")

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3
#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR TEXT("\"*+,/:;<=>?[\\]|")

HRESULT CUserInfo::check_Identity(UINT uiIndex, VARIANT_BOOL* pfValid)
{
    BSTR bstrVal;

    *pfValid = TRUE; // initalize outparam, assume ok

    if (SUCCEEDED(get_Identity(uiIndex, &bstrVal)))
    {
        // check length
        DWORD cchVal = lstrlen(bstrVal);
        if (cchVal > 0) // if cchVal == 0, user trying to delete or didn't define
        {
            check_Identity(bstrVal, pfValid);

            for (UINT i = 0; i < uiIndex; i++) // check not equal to other names
            {
                BSTR bstrValOther;
                if (SUCCEEDED(get_Identity(i, &bstrValOther)))
                {
                    if (0 == StrCmpI(bstrVal, bstrValOther))
                    {
                        *pfValid = FALSE;
                    }
                    SysFreeString(bstrValOther);
                }
            }
        }

        SysFreeString(bstrVal);

    }
    return S_OK;
}


HRESULT CUserInfo::check_Identity(WCHAR* pszVal, VARIANT_BOOL* pfValid)
{
    *pfValid = TRUE; // initalize outparam, assume ok

    if (pszVal)
    {
        WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD cchComputerName = sizeof(szComputerName) / sizeof(WCHAR);

        DWORD cchVal = lstrlen(pszVal);
        if (cchVal > 0) // if cchVal == 0, user trying to delete or didn't define
        {
            if (cchVal > 20)
            {
                *pfValid = FALSE;
            }

            // check for trailing periods
            if (pszVal[cchVal - 1] == DOT_CHAR)
            {
                *pfValid = FALSE;
            }

            // check not all spaces and periods
            if (StrSpn(pszVal, DOT_AND_SPACE_STR) == (int)cchVal)
            {
                *pfValid = FALSE;
            }

            // check nothing from ILLEGAL_FAT_CHARS in name
            if (StrCSpn(pszVal, ILLEGAL_FAT_CHARS) < (int)cchVal)
            {
                *pfValid = FALSE;
            }

            for (int i = 0; i < RESERVED_IDENTITIES_MAX; i++)
            {
                if (!lstrcmpi(m_szReservedIdentities[i], pszVal))
                {
                    *pfValid = FALSE;
                    break;
                }
            }

            if (GetComputerName(szComputerName, &cchComputerName))
            {
                if (!lstrcmpi(szComputerName, pszVal))
                {
                    *pfValid = FALSE;
                }
            }

        }
        else
        {
            *pfValid = FALSE;
        }
    }
    else
    {
        *pfValid = FALSE;
    }

    return S_OK;
}



STDMETHODIMP CUserInfo::SuggestIdentity0()
{
    if (lstrlen(m_rgIdentities[0].rgchIdentity) == 0)
    {
        LPWSTR Candidates[] = {m_szOwnerName, m_szFirstName, m_szLastName, NULL};

        for (int i = 0; Candidates[i]; i++)
        {
            if (lstrlen(Candidates[i]) > 0)
            {
                VARIANT_BOOL b;

                check_Identity(Candidates[i], &b);
                if (b)
                {
                    FixString(Candidates[i]);
                    set_Identity(0, Candidates[i]);
                    break;
                }
            }
        }
    }

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: FirstName
////
HRESULT CUserInfo::set_FirstName(WCHAR* pszVal)
{
    WriteUserInfo(m_szFirstName, USERINFO_REG_KEY_FIRSTNAME, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_FirstName(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szFirstName);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: MiddleInitial
////
HRESULT CUserInfo::set_MiddleInitial(WCHAR* pszVal)
{
    WriteUserInfo(m_szMiddleInitial, USERINFO_REG_KEY_MIDDLEINITIAL, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_MiddleInitial(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szMiddleInitial);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: LastName
////
HRESULT CUserInfo::set_LastName(WCHAR* pszVal)
{
    WriteUserInfo(m_szLastName, USERINFO_REG_KEY_LASTNAME, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_LastName(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szLastName);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: FuriganaName
////
HRESULT CUserInfo::set_FuriganaName(WCHAR* pszVal)
{
    WriteUserInfo(m_szFuriganaName, USERINFO_REG_KEY_FURIGANANAME, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_FuriganaName(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szFuriganaName);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: CompanyName
////
HRESULT CUserInfo::set_CompanyName(WCHAR* pszVal)
{
    WriteUserInfo(m_szCompanyName, USERINFO_REG_KEY_COMPANYNAME, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_CompanyName(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szCompanyName);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Address1
////
HRESULT CUserInfo::set_Address1(WCHAR* pszVal)
{
    WriteUserInfo(m_szAddress1, USERINFO_REG_KEY_ADDRESS1, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_Address1(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szAddress1);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Address2
////
HRESULT CUserInfo::set_Address2(WCHAR* pszVal)
{
    WriteUserInfo(m_szAddress2, USERINFO_REG_KEY_ADDRESS2, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_Address2(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szAddress2);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: City
////
HRESULT CUserInfo::set_City(WCHAR* pszVal)
{
    WriteUserInfo(m_szCity, USERINFO_REG_KEY_CITY, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_City(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szCity);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: State
////
HRESULT CUserInfo::set_State(WCHAR* pszVal)
{
    WriteUserInfo(m_szState, USERINFO_REG_KEY_STATE, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_State(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szState);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Zip
////
HRESULT CUserInfo::set_Zip(WCHAR* pszVal)
{
    WriteUserInfo(m_szZip, USERINFO_REG_KEY_ZIP, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_Zip(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szZip);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Country
////
HRESULT CUserInfo::set_Country(WCHAR* pszVal)
{
    WriteUserInfo(m_szCountry, USERINFO_REG_KEY_COUNTRY, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_Country(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szCountry);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: PrimaryEmail
////
HRESULT CUserInfo::set_PrimaryEmail(WCHAR* pszVal)
{
    WriteUserInfo(m_szPrimaryEmail, USERINFO_REG_KEY_PRIMARYEMAIL, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_PrimaryEmail(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szPrimaryEmail);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: SecondaryEmail
////
HRESULT CUserInfo::set_SecondaryEmail(WCHAR* pszVal)
{
    WriteUserInfo(m_szSecondaryEmail, USERINFO_REG_KEY_SECONDARYEMAIL, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_SecondaryEmail(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szSecondaryEmail);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: AreaCode
////
HRESULT CUserInfo::set_AreaCode(WCHAR* pszVal)
{
    WriteUserInfo(m_szAreaCode, USERINFO_REG_KEY_AREACODE, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_AreaCode(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szAreaCode);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: Number
////
HRESULT CUserInfo::set_PhoneNumber(WCHAR* pszVal)
{
    WriteUserInfo(m_szPhoneNumber, USERINFO_REG_KEY_PHONENUMBER, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_PhoneNumber(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szPhoneNumber);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: OwnerName
////
HRESULT CUserInfo::set_OwnerName(WCHAR* pszVal)
{
    WriteUserInfo(m_szOwnerName, USERINFO_REG_KEY_OWNERNAME, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_OwnerName(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szOwnerName);

    return S_OK;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//// GET / SET :: DefaultNewUser
////
HRESULT CUserInfo::set_DefaultNewUser(WCHAR* pszVal)
{
    WriteUserInfo(m_szDefaultNewUser, USERINFO_REG_KEY_DEFAULTNEWUSER, pszVal);

    return S_OK;
}

HRESULT CUserInfo::get_DefaultNewUser(BSTR* pbstrVal)
{

    *pbstrVal = SysAllocString(m_szDefaultNewUser);

    return S_OK;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CObMain::QueryInterface
STDMETHODIMP CUserInfo::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CUserInfo::AddRef
STDMETHODIMP_(ULONG) CUserInfo::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CUserInfo::Release
STDMETHODIMP_(ULONG) CUserInfo::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CUserInfo::GetTypeInfo
STDMETHODIMP CUserInfo::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CUserInfo::GetTypeInfoCount
STDMETHODIMP CUserInfo::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CUserInfo::GetIDsOfNames
STDMETHODIMP CUserInfo::GetIDsOfNames(REFIID    riid,
                                    OLECHAR** rgszNames,
                                    UINT      cNames,
                                    LCID      lcid,
                                    DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(UserInfoExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(UserInfoExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = UserInfoExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CUserInfo::Invoke
HRESULT CUserInfo::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{

    HRESULT hr = S_OK;

    switch(dispidMember)
    {
    case DISPID_USERINFO_CHECK_IDENTITY:
        {
            TRACE(L"DISPID_USERINFO_CHECK_IDENTITY\n");
            if(pdispparams && &pdispparams[0].rgvarg[0] && pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;
                if (pdispparams[0].rgvarg[0].vt == VT_BSTR)
                {
                    check_Identity(pdispparams[0].rgvarg[0].bstrVal, &pvarResult->boolVal);
                }
                else
                {
                    check_Identity(pdispparams[0].rgvarg[0].uintVal, &pvarResult->boolVal);
                }
            }
            break;
        }
    case DISPID_USERINFO_GET_FIRSTNAME:
        {

            TRACE(L"DISPID_USERINFO_GET_FIRSTNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_FirstName(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_FIRSTNAME:
        {

            TRACE(L"DISPID_USERINFO_SET_FIRSTNAME\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_FirstName(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_MIDDLEINITIAL:
        {

            TRACE(L"DISPID_USERINFO_GET_MIDDLEINITIAL\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_MiddleInitial(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_MIDDLEINITIAL:
        {

            TRACE(L"DISPID_USERINFO_SET_MIDDLEINITIAL\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_MiddleInitial(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_LASTNAME:
        {

            TRACE(L"DISPID_USERINFO_GET_LASTNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_LastName(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_LASTNAME:
        {

            TRACE(L"DISPID_USERINFO_SET_LASTNAME\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_LastName(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_FURIGANANAME:
        {

            TRACE(L"DISPID_USERINFO_GET_FURIGANANAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_FuriganaName(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_FURIGANANAME:
        {

            TRACE(L"DISPID_USERINFO_SET_FURIGANANAME\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_FuriganaName(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_OWNERNAME:
        {

            TRACE(L"DISPID_USERINFO_GET_OWNERNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_OwnerName(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_OWNERNAME:
        {

            TRACE(L"DISPID_USERINFO_SET_OWNERNAME\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_OwnerName(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }


    case DISPID_USERINFO_GET_COMPANYNAME:
        {

            TRACE(L"DISPID_USERINFO_GET_COMPANYNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_CompanyName(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_COMPANYNAME:
        {

            TRACE(L"DISPID_USERINFO_SET_COMPANYNAME\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_CompanyName(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_ADDRESS1:
        {

            TRACE(L"DISPID_USERINFO_GET_ADDRESS1\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_Address1(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_ADDRESS1:
        {

            TRACE(L"DISPID_USERINFO_SET_ADDRESS1\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_Address1(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_ADDRESS2:
        {

            TRACE(L"DISPID_USERINFO_GET_ADDRESS2\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_Address2(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_ADDRESS2:
        {

            TRACE(L"DISPID_USERINFO_SET_ADDRESS2\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_Address2(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_CITY:
        {

            TRACE(L"DISPID_USERINFO_GET_CITY\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_City(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_CITY:
        {

            TRACE(L"DISPID_USERINFO_SET_CITY\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_City(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_STATE:
        {

            TRACE(L"DISPID_USERINFO_GET_STATE\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_State(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_STATE:
        {

            TRACE(L"DISPID_USERINFO_SET_STATE\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_State(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_ZIP:
        {

            TRACE(L"DISPID_USERINFO_GET_ZIP\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_Zip(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_ZIP:
        {

            TRACE(L"DISPID_USERINFO_SET_ZIP\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_Zip(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_COUNTRY:
        {

            TRACE(L"DISPID_USERINFO_GET_COUNTRY\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_Country(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_COUNTRY:
        {

            TRACE(L"DISPID_USERINFO_SET_COUNTRY\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_Country(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_PRIMARYEMAIL:
        {

            TRACE(L"DISPID_USERINFO_GET_PRIMARYEMAIL\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_PrimaryEmail(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_PRIMARYEMAIL:
        {

            TRACE(L"DISPID_USERINFO_SET_PRIMARYEMAIL\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_PrimaryEmail(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_SECONDARYEMAIL:
        {

            TRACE(L"DISPID_USERINFO_GET_SECONDARYEMAIL\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_SecondaryEmail(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_SECONDARYEMAIL:
        {

            TRACE(L"DISPID_USERINFO_SET_SECONDARYEMAIL\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_SecondaryEmail(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_AREACODE:
        {

            TRACE(L"DISPID_USERINFO_GET_AREACODE\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_AreaCode(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_AREACODE:
        {

            TRACE(L"DISPID_USERINFO_SET_AREACODE\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_AreaCode(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_PHONENUMBER:
        {

            TRACE(L"DISPID_USERINFO_GET_PHONENUMBER\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;

                get_PhoneNumber(&pvarResult->bstrVal);
            }
            break;
        }

    case DISPID_USERINFO_SET_PHONENUMBER:
        {

            TRACE(L"DISPID_USERINFO_SET_PHONENUMBER\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
                set_PhoneNumber(pdispparams[0].rgvarg[0].bstrVal);
            break;
        }

    case DISPID_USERINFO_GET_MSUPDATE:
    {
        TRACE(L"DISPID_USERINFO_GET_MSUPDATE");
        if (NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;

            get_MSUpdate(&(pvarResult->boolVal));
        }
        break;
    }

    case DISPID_USERINFO_SET_MSUPDATE:
    {
        TRACE(L"DISPID_USERINFO_SET_MSUPDATE");
        if (pdispparams && 0 < pdispparams->cArgs)
            set_MSUpdate(pdispparams[0].rgvarg[0].boolVal);
        break;
    }

    case DISPID_USERINFO_GET_MSOFFER:
    {
        TRACE(L"DISPID_USERINFO_GET_MSOFFER");
        if (NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;

            get_MSOffer(&(pvarResult->boolVal));
        }
        break;
    }

    case DISPID_USERINFO_SET_MSOFFER:
    {
        TRACE(L"DISPID_USERINFO_SET_MSOFFER");
        if (pdispparams && 0 < pdispparams->cArgs)
            set_MSOffer(pdispparams[0].rgvarg[0].boolVal);
        break;
    }

    case DISPID_USERINFO_GET_OTHEROFFER:
    {
        TRACE(L"DISPID_USERINFO_GET_OTHEROFFER");
        if (NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;

            get_OtherOffer(&(pvarResult->boolVal));
        }
        break;
    }

    case DISPID_USERINFO_SET_OTHEROFFER:
    {
        TRACE(L"DISPID_USERINFO_SET_OTHEROFFER");
        if (pdispparams && 0 < pdispparams->cArgs)
            set_OtherOffer(pdispparams[0].rgvarg[0].boolVal);
        break;
    }

    case DISPID_USERINFO_GET_COUNTRYID:
    {
        TRACE(L"DISPID_USERINFO_GET_COUNTRYID");
        if (NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_I4;
            get_CountryID((PDWORD)&(pvarResult->lVal));
        }
        break;
    }

    case DISPID_USERINFO_SET_COUNTRYID:
    {
        TRACE(L"DISPID_USERINFO_SET_COUNTRYID");
        if (pdispparams && 0 < pdispparams->cArgs)
            set_CountryID(pdispparams[0].rgvarg[0].lVal);
        break;
    }

    case DISPID_USERINFO_GET_IDENTITIESMAX:
    {
        TRACE(L"DISPID_USERINFO_GET_IDENTITIESMAX\n");
        if(pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_I2;

            get_IdentitiesMax(&pvarResult->iVal);
        }
        break;
    }

    case DISPID_USERINFO_GET_IDENTITY:
    {
        TRACE(L"DISPID_USERINFO_GET_IDENTITY\n");
        if (   NULL != pdispparams
            && 0 < pdispparams->cArgs
            && NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BSTR;

            get_Identity(pdispparams[0].rgvarg[0].uintVal,
                            &pvarResult->bstrVal
                            );
        }
        break;
    }

    case DISPID_USERINFO_SET_IDENTITY:
    {
        TRACE(L"DISPID_USERINFO_SET_IDENTITY\n");
        if(pdispparams && 1 < pdispparams->cArgs)
            set_Identity(pdispparams[0].rgvarg[1].uintVal,
                         pdispparams[0].rgvarg[0].bstrVal);
        break;
    }

    case DISPID_USERINFO_GET_USEIDENTITIES:
    {
        TRACE(L"DISPID_USERINFO_GET_USEIDENTITIES");
        if (NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;

            get_UseIdentities(&(pvarResult->boolVal));
        }
        break;
    }

    case DISPID_USERINFO_SET_USEIDENTITIES:
    {
        TRACE(L"DISPID_USERINFO_SET_USEIDENTITIES");
        if (pdispparams && 0 < pdispparams->cArgs)
            set_UseIdentities(pdispparams[0].rgvarg[0].boolVal);
        break;
    }

    case DISPID_USERINFO_GET_OEMIDENTITIES:
    {
        TRACE(L"DISPID_USERINFO_GET_OEMIDENTITIES");
        if (NULL != pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BOOL;

            get_OEMIdentities(&(pvarResult->boolVal));
        }
        break;
    }

    case DISPID_USERINFO_SUGGESTIDENTITY0:
        {
        OutputDebugString(L"DISPID_USERINFO_SUGGESTIDENTITY0\n");
        SuggestIdentity0();
        break;
        }

    case DISPID_USERINFO_GET_DEFAULTNEWUSER:
    {
        TRACE(L"DISPID_USERINFO_GET_DEFAULTNEWUSER");
        if(pvarResult)
        {
            VariantInit(pvarResult);
            V_VT(pvarResult) = VT_BSTR;

            get_DefaultNewUser(&pvarResult->bstrVal);
        }
        break;

    }
    default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}

//
HRESULT CUserInfo::set_CountryCode(DWORD dwCountryCd)
{
    m_dwCountryCode = dwCountryCd;
    return S_OK;
}

// This funtion will form the query string to be sent to the ISP signup server
//
HRESULT CUserInfo::GetQueryString
(
    BSTR    bstrBaseURL,
    BSTR    *lpReturnURL
)
{
    LPWSTR              lpWorkingURL;
    WORD                cchBuffer = 0;
    LPREGDATAELEMENT    lpElement;
    LPWSTR              lpszBaseURL = bstrBaseURL;
    int                 i;

    BSTR pbstrVal = NULL;
    CProductID PidObj;
    PidObj.get_PID(&pbstrVal);
    m_RegDataElements[INDEX_PID].lpQueryElementValue = (LPWSTR) pbstrVal;


    WCHAR buffer[8];
    _itow( m_dwCountryCode, buffer, 8 );
    m_RegDataElements[INDEX_COUNTRYCODE].lpQueryElementValue = (LPWSTR)buffer;

    m_RegDataElements[INDEX_PRODUCT].lpQueryElementValue = REG_VAL_OOBE;

    // Now read the INI file.
    WCHAR szOemInfoFile[MAX_PATH]  = L"\0";
    WCHAR szComputerManf[MAX_PATH] = L"\0";
    GetSystemDirectory(szOemInfoFile, MAX_CHARS_IN_BUFFER(szOemInfoFile));
    lstrcat(szOemInfoFile, OEMINFO_INI_FILENAME);
    GetPrivateProfileString(USER_COMP_MANF_SEC,
                            USER_COMP_MANF_KEY,
                            L"\0",
                            szComputerManf,
                            MAX_CHARS_IN_BUFFER(szComputerManf),
                            szOemInfoFile);

    m_RegDataElements[INDEX_COMPUTERMANF].lpQueryElementValue = szComputerManf;


    //ASSERT(lpReturnURL);
    if (!lpReturnURL)
        return E_FAIL;

    // Calculate how big of a buffer we will need
    cchBuffer += (WORD)lstrlen(lpszBaseURL) + 1;
    for (i = 0; i < REGDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_RegDataElements[i];
        //ASSERT(lpElement);
        if (lpElement->lpQueryElementName)
        {
            cchBuffer += (WORD)(  lstrlen(lpElement->lpQueryElementName)
                                + (lstrlen(lpElement->lpQueryElementValue) * 3)       // *3 for encoding
                                + 3     // For the = and & and the terminator
                                        // (because we copy lpQueryElementValue
                                        // into a new buffer for encoding)
                                );
        }
        else
        {
            // extra character is for the trailing &
            cchBuffer += (WORD)(lstrlen(lpElement->lpQueryElementValue) + 1);
        }
    }
    cchBuffer++;                     // Terminator

    // Allocate a buffer large enough
    if (NULL == (lpWorkingURL = (LPWSTR)GlobalAllocPtr(GPTR, BYTES_REQUIRED_BY_CCH(cchBuffer))))
        return E_FAIL;

    lstrcpy(lpWorkingURL, lpszBaseURL);

    // See if this ISP provided URL is already a Query String.
    if (*lpWorkingURL)
    {
        if (NULL != wcschr(lpWorkingURL, L'?'))
            lstrcat(lpWorkingURL, cszAmpersand);      // Append our params
        else
            lstrcat(lpWorkingURL, cszQuestion);       // Start with our params
    }

    for (i = 0; i < REGDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_RegDataElements[i];
        //ASSERT(lpElement);

        if (lpElement->lpQueryElementName)
        {
            // If there is a query value, then encode it
            if (lpElement->lpQueryElementValue)
            {
                // Allocate a buffer to encode into
                size_t cch = (lstrlen(lpElement->lpQueryElementValue) + 1) * 3;
                LPWSTR lpszVal = (LPWSTR) malloc(BYTES_REQUIRED_BY_CCH(cch));

                lstrcpy(lpszVal, lpElement->lpQueryElementValue);
                URLEncode(lpszVal, cch);

                URLAppendQueryPair(lpWorkingURL,
                                   (LPWSTR)lpElement->lpQueryElementName,
                                   lpszVal);
                free(lpszVal);
            }
            else
            {
                URLAppendQueryPair(lpWorkingURL,
                                   (LPWSTR)lpElement->lpQueryElementName,
                                   NULL);
            }
        }
        else
        {
            if (lpElement->lpQueryElementValue)
            {
                lstrcat(lpWorkingURL, lpElement->lpQueryElementValue);
                lstrcat(lpWorkingURL, cszAmpersand);
            }
        }
    }

    // Terminate the working URL properly, by removing the trailing ampersand
    lpWorkingURL[lstrlen(lpWorkingURL)-1] = L'\0';


    // Set the return VALUE.  We must allocate here, since the caller will free
    // this returned string, and A2W only puts the string in the stack
    *lpReturnURL = SysAllocString(lpWorkingURL);

    // Free the buffer
    GlobalFreePtr(lpWorkingURL);

    return (S_OK);
}

void CUserInfo::FixString(BSTR bstrVal)
{
    if (bstrVal != NULL)
    {
        // StrTrim removes both leading and trailing spaces
        StrTrim(bstrVal, TEXT(" "));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\tapiloc.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  tapiloc.CPP - Header for the implementation of CObMain
//
//  HISTORY:
//
//  1/27/99 vyung Created.
//

#include "tapiloc.h"
#include "appdefs.h"
#include "dispids.h"
#include "msobmain.h"
#include <shlwapi.h>
#include "resource.h"
#include <regapix.h>

DISPATCHLIST TapiExternalInterface[] =
{
    {L"IsTAPIConfigured",        DISPID_TAPI_INITTAPI        },
    {L"get_CountryNameForIndex", DISPID_TAPI_GETCOUNTRYNAME  },
    {L"get_CountryIndex",        DISPID_TAPI_GETCOUNTRYINDEX },
    {L"set_CountryIndex",        DISPID_TAPI_SETCOUNTRYINDEX },
    {L"get_NumOfCountry",        DISPID_TAPI_GETNUMOFCOUNTRY },
    {L"get_AreaCode",            DISPID_TAPI_GETAREACODE     },
    {L"set_AreaCode",            DISPID_TAPI_SETAREACODE     },
    {L"get_DialOut",             DISPID_TAPI_GETDIALOUT      },
    {L"set_DialOut",             DISPID_TAPI_SETDIALOUT      },
    {L"get_PhoneSystem",         DISPID_TAPI_GETPHONESYS     },
    {L"set_PhoneSystem",         DISPID_TAPI_SETPHONESYS     },
    {L"get_CallWaiting",         DISPID_TAPI_GETCALLWAITING  },
    {L"set_CallWaiting",         DISPID_TAPI_SETCALLWAITING  },
    {L"get_AllCountryName",      DISPID_TAPI_GETALLCNTRYNAME },
    {L"IsAreaCodeRequired",      DISPID_TAPI_ISACODEREQUIRED },
    {L"get_CountryID",           DISPID_TAPI_GETCOUNTRYID    },
    {L"IsTapiServiceRunning",     DISPID_TAPI_TAPISERVICERUNNING}
};

//+---------------------------------------------------------------------------
//
//  Function:   CompareCntryNameLookUpElements()
//
//  Synopsis:   Function to compare names used by sort
//
//+---------------------------------------------------------------------------
int __cdecl CompareCntryNameLookUpElements(const void *e1, const void *e2)
{
    LPCNTRYNAMELOOKUPELEMENT pCUE1 = (LPCNTRYNAMELOOKUPELEMENT)e1;
    LPCNTRYNAMELOOKUPELEMENT pCUE2 = (LPCNTRYNAMELOOKUPELEMENT)e2;

    return CompareStringW(LOCALE_USER_DEFAULT, 0,
        pCUE1->psCountryName, -1,
        pCUE2->psCountryName, -1
        ) - 2;
}


//+---------------------------------------------------------------------------
//
//  Function:   LineCallback()
//
//  Synopsis:   Call back for TAPI line
//
//+---------------------------------------------------------------------------
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD_PTR dwInstance,
                           DWORD_PTR dwParam1,
                           DWORD_PTR dwParam2,
                           DWORD_PTR dwParam3)
{
    return;
}

//+---------------------------------------------------------------------------
//  Function: GetCurrentTapiLocation
//
// Synopsis: Open the
//      \HKLM\Software\Microsoft\CurrentVersion\Telephony\Locations\LocationX
//      where X is the id of the current location.  The id is stored in
// HKLM\Software\Microsoft\Windows\CurrentVersion\Telephony\Locations\CurrentID.
//
//+---------------------------------------------------------------------------
HRESULT
GetCurrentTapiLocation(
    LPWSTR              szLocation,
    DWORD               cbLocation
    )
{
    HKEY                hkey    = NULL;
    HRESULT             hr      = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                               TAPI_PATH_LOCATIONS,
                                               0,
                                               KEY_QUERY_VALUE,
                                               &hkey
                                               );
    if (ERROR_SUCCESS == hr)
    {
        DWORD           dwCurrentId = 0;
        DWORD           cbCurrentId = sizeof(DWORD);

        hr = RegQueryValueEx(hkey, TAPI_CURRENTID, NULL, NULL,
                (LPBYTE) &dwCurrentId, &cbCurrentId);
        if (ERROR_SUCCESS == hr)
        {
            if (0 >= wnsprintf(szLocation, cbLocation - 1, L"%s\\%s%lu",
                        TAPI_PATH_LOCATIONS, TAPI_LOCATION, dwCurrentId)
                    )
            {
                hr = E_FAIL;
            }

        }
        RegCloseKey(hkey);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetTapiReg()
//
//  Synopsis:   Set TAPI REG
//
//+---------------------------------------------------------------------------
STDMETHODIMP SetTapiReg(LPCWSTR lpValueName, DWORD dwType, const BYTE* lpByte, DWORD dwSize)
{
    HKEY hKey = 0;
    // get path to the TAPI
    WCHAR               szLocation[MAXIMUM_VALUE_NAME_LENGTH];

    HRESULT hr = GetCurrentTapiLocation(szLocation, MAXIMUM_VALUE_NAME_LENGTH);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegOpenKey(HKEY_LOCAL_MACHINE, szLocation, &hKey);
    }

    if (hr != ERROR_SUCCESS)
        return( E_FAIL );

    hr = RegSetValueEx(hKey, lpValueName, 0, dwType, lpByte, dwSize );

    RegCloseKey(hKey);
    if (hr != ERROR_SUCCESS)
        return( E_FAIL );
    return S_OK;
}


STDMETHODIMP GetTapiReg(LPCWSTR lpValueName, DWORD* pdwType, BYTE* lpByte, DWORD* pdwSize)
{
    HRESULT hr;
    HKEY hKey = 0;

    // get path to the TAPI
    WCHAR               szLocation[MAXIMUM_VALUE_NAME_LENGTH];

    hr = GetCurrentTapiLocation(szLocation, MAXIMUM_VALUE_NAME_LENGTH);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegOpenKey(HKEY_LOCAL_MACHINE, szLocation, &hKey);
    }

    if (hr != ERROR_SUCCESS)
        return( E_FAIL );

    hr = RegQueryValueEx(hKey, lpValueName, 0, pdwType, lpByte, pdwSize );

    RegCloseKey(hKey);
    if (hr != ERROR_SUCCESS) return( E_FAIL );
    return S_OK;
}


/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IUnknown implementation
///////
///////

/////////////////////////////////////////////////////////////
// CObMain::QueryInterface
STDMETHODIMP CTapiLocationInfo::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;

    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*)this;
        return ResultFromScode(S_OK);
    }

    if (riid == IID_IDispatch)
    {
        AddRef();
        *ppvObj = (IDispatch*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// CTapiLocationInfo::AddRef
STDMETHODIMP_(ULONG) CTapiLocationInfo::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// CTapiLocationInfo::Release
STDMETHODIMP_(ULONG) CTapiLocationInfo::Release()
{
    return --m_cRef;
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////// IDispatch implementation
///////
///////

/////////////////////////////////////////////////////////////
// CTapiLocationInfo::GetTypeInfo
STDMETHODIMP CTapiLocationInfo::GetTypeInfo(UINT, LCID, ITypeInfo**)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CTapiLocationInfo::GetTypeInfoCount
STDMETHODIMP CTapiLocationInfo::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////
// CTapiLocationInfo::GetIDsOfNames
STDMETHODIMP CTapiLocationInfo::GetIDsOfNames(REFIID    riid,
                                    OLECHAR** rgszNames,
                                    UINT      cNames,
                                    LCID      lcid,
                                    DISPID*   rgDispId)
{

    HRESULT hr  = DISP_E_UNKNOWNNAME;
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(TapiExternalInterface)/sizeof(DISPATCHLIST); iX ++)
    {
        if(lstrcmp(TapiExternalInterface[iX].szName, rgszNames[0]) == 0)
        {
            rgDispId[0] = TapiExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }

    return hr;
}

/////////////////////////////////////////////////////////////
// CTapiLocationInfo::Invoke
HRESULT CTapiLocationInfo::Invoke
(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr
)
{

    HRESULT hr = S_OK;

    switch(dispidMember)
    {
    case DISPID_TAPI_INITTAPI:
        {

            TRACE(L"DISPID_TAPI_INITTAPI\n");

            BOOL bRet;
            InitTapiInfo(&bRet);
            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;
                pvarResult->boolVal = Bool2VarBool(bRet);
            }
            break;
        }
    case DISPID_TAPI_GETCOUNTRYINDEX:
        {

            TRACE(L"DISPID_TAPI_GETCOUNTRYINDEX\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                GetlCountryIndex(&(pvarResult->lVal));
            }
            break;
        }
    case DISPID_TAPI_SETCOUNTRYINDEX:
        {

            TRACE(L"DISPID_TAPI_SETCOUNTRYINDEX\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
            {
                SetlCountryIndex(pdispparams[0].rgvarg[0].lVal);
            }
            break;
        }
    case DISPID_TAPI_GETNUMOFCOUNTRY:
        {

            TRACE(L"DISPID_TAPI_GETNUMOFCOUNTRY\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;

                GetNumCountries(&(pvarResult->lVal));
            }
            break;
        }
    case DISPID_TAPI_GETCOUNTRYNAME:
        {

            TRACE(L"DISPID_TAPI_GETCOUNTRYNAME\n");

            BSTR bstrCountry;

            if(pdispparams && &pdispparams[0].rgvarg[0])
            {
                GetCountryName(pdispparams[0].rgvarg[0].lVal, &bstrCountry);
            }
            if(pvarResult)
            {
               VariantInit(pvarResult);
               V_VT(pvarResult) = VT_BSTR;
               pvarResult->bstrVal = bstrCountry;
               bstrCountry = NULL;
            }
            break;
        }
    case DISPID_TAPI_GETAREACODE:
        {

            TRACE(L"DISPID_TAPI_GETAREACODE\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;
                GetbstrAreaCode(&(pvarResult->bstrVal));
            }

            break;
        }
    case DISPID_TAPI_SETAREACODE:
        {

            TRACE(L"DISPID_TAPI_SETAREACODE\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
            {
                PutbstrAreaCode(pdispparams[0].rgvarg[0].bstrVal);
            }
            break;
        }
    case DISPID_TAPI_GETDIALOUT:
        {

            TRACE(L"DISPID_TAPI_GETDIALOUT\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;
                GetOutsideDial(&(pvarResult->bstrVal));
            }
            break;
        }
    case DISPID_TAPI_SETDIALOUT:
        {

            TRACE(L"DISPID_TAPI_SETDIALOUT\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
            {
                PutOutsideDial(pdispparams[0].rgvarg[0].bstrVal);
            }
            break;
        }
    case DISPID_TAPI_GETPHONESYS:
        {

            TRACE(L"DISPID_TAPI_GETPHONESYS\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;
                GetPhoneSystem(&(pvarResult->lVal));
            }
            break;
        }
    case DISPID_TAPI_SETPHONESYS:
        {

            TRACE(L"DISPID_TAPI_SETPHONESYS\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
            {
                PutPhoneSystem(pdispparams[0].rgvarg[0].lVal);
            }
            break;
        }
    case DISPID_TAPI_GETCALLWAITING:
        {

            TRACE(L"DISPID_TAPI_GETCALLWAITING\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;
                GetCallWaiting(&(pvarResult->bstrVal));
            }
            break;
        }
    case DISPID_TAPI_SETCALLWAITING:
        {

            TRACE(L"DISPID_TAPI_SETCALLWAITING\n");

            if(pdispparams && &pdispparams[0].rgvarg[0])
            {
                PutCallWaiting(pdispparams[0].rgvarg[0].bstrVal);
            }
            break;
        }
    case DISPID_TAPI_GETALLCNTRYNAME:
        {

            TRACE(L"DISPID_TAPI_GETALLCNTRYNAME\n");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BSTR;
                GetAllCountryName(&(pvarResult->bstrVal));
            }

            break;
        }
    case DISPID_TAPI_ISACODEREQUIRED:
        {

            TRACE(L"DISPID_TAPI_ISACODEREQUIRED\n");

            if(pdispparams && &pdispparams[0].rgvarg[0] && pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;
                IsAreaCodeRequired(pdispparams[0].rgvarg[0].lVal, (BOOL*)&(pvarResult->boolVal));
            }
            break;
        }
    case DISPID_TAPI_GETCOUNTRYID:
        {

            TRACE(L"DISPID_TAPI_GETCOUNTRYID");

            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_I4;
                pvarResult->lVal = m_dwCountryID;
                TRACE1(L"... %d returned", m_dwCountryID);
            }
            break;
        }
    case DISPID_TAPI_TAPISERVICERUNNING:
        {

            TRACE(L"DISPID_TAPI_TAPISERVICERUNNING\n");

            BOOL bRet;
            TapiServiceRunning(&bRet);
            if(pvarResult)
            {
                VariantInit(pvarResult);
                V_VT(pvarResult) = VT_BOOL;
                pvarResult->boolVal = Bool2VarBool(bRet);
            }
            break;
        }

    default:
        {
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CTapiLocationInfo
CTapiLocationInfo::CTapiLocationInfo()
{
    m_wNumTapiLocations   = 0;
    m_dwComboCountryIndex = 0;
    m_dwCountryID         = 0;
    m_dwCurrLoc           = 0;
    m_hLineApp            = NULL;
    m_pLineCountryList    = NULL;
    m_rgNameLookUp        = NULL;
    m_pTC                 = NULL;
    m_bTapiAvailable      = FALSE;
    m_szAreaCode [0]      = L'\0';
    m_szDialOut  [0]      = L'\0';
    m_szAllCountryPairs   = NULL;
    m_bTapiCountrySet     = FALSE;
    m_bCheckModemCountry  = FALSE;
}

CTapiLocationInfo::~CTapiLocationInfo()
{
    //
    // It is possible that the country ID is set but dialing, hence the call
    // to CheckModemCountry, is skipped.
    //

    CheckModemCountry();

    if (m_szAllCountryPairs)
    {
        GlobalFree(m_szAllCountryPairs);
    }
    if (m_pLineCountryList)
    {
        GlobalFree(m_pLineCountryList);
    }
    if (m_rgNameLookUp)
    {
        GlobalFree(m_rgNameLookUp);
    }
    if (m_pTC)
    {
        GlobalFree(m_pTC);
    }
}



const WCHAR gszInternationalSec[] = L"intl";
const WCHAR gszCountryEntry[]     = L"iCountry";

STDMETHODIMP CTapiLocationInfo::InitTapiInfo(BOOL* pbRetVal)
{
    HRESULT             hr          = ERROR_SUCCESS;
    DWORD               cDevices    =0;
    DWORD               dwCurDev    = 0;
    DWORD               dwAPI       = 0;
    LONG                lrc         = 0;
    LINEEXTENSIONID     leid;
    LPVOID              pv          = NULL;
    DWORD               dwCurLoc    = 0;
    WCHAR               szCountryCode[8];
    WCHAR               szIniFile[MAX_PATH*2] = SZ_EMPTY;


    if (0 != m_dwCountryID)
    {
        // TAPI already initialized, don't do it again.
        *pbRetVal = m_bTapiAvailable;
        goto InitTapiInfoExit;
    }

    m_hLineApp=NULL;
    // Assume Failure
    *pbRetVal = FALSE;
    if (m_pTC)
    {
        GlobalFree(m_pTC);
        m_pTC = NULL;
    }

    m_bTapiAvailable = TRUE;
    hr = tapiGetLocationInfo(szCountryCode, m_szAreaCode);
    if (hr)
    {
        HKEY hKey = 0;
        m_bTapiAvailable = FALSE;

        // GetLocation failed.  Normally we show the TAPI mini dialog which
        // has no cancel option, and the user is forced to enter info and hit OK.
        // In OOBE, we have to mimic this dialog in html, so here we will
        // give user country list, and default phone system

        // This code taken from dial.c in tapi32.dll

        m_dwCountryID = (DWORD)GetProfileInt( gszInternationalSec,
                                      gszCountryEntry,
                                      1 );

        // create necessary tapi keys
        *pbRetVal = TRUE;           // Getting here means everything worked
        HRESULT hr = RegCreateKey(HKEY_LOCAL_MACHINE, TAPI_PATH_LOC0, &hKey);
        if (hr != ERROR_SUCCESS)
        {
            *pbRetVal = FALSE;
        }
        else
        {
            RegSetValueEx(hKey, TAPI_CALLWAIT, 0, REG_SZ, (LPBYTE)NULL_SZ, BYTES_REQUIRED_BY_SZ(NULL_SZ) );

            HINSTANCE hInst = GetModuleHandle(L"msobmain.dll");
            WCHAR szTapiNewLoc[MAX_PATH];
            LoadString(hInst, IDS_TAPI_NEWLOC, szTapiNewLoc, MAX_CHARS_IN_BUFFER(szTapiNewLoc));

            RegSetValueEx(hKey, TAPI_NAME, 0, REG_SZ, (LPBYTE)szTapiNewLoc, BYTES_REQUIRED_BY_SZ(szTapiNewLoc) );

            RegCloseKey(hKey);
        }
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TAPI_PATH_LOCATIONS, &hKey))
        {
            DWORD dwVal;

            DWORD dwSize = sizeof(dwVal);

            dwVal = 0;

            hr = RegSetValueEx(hKey, TAPI_CURRENTID, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(DWORD));

            RegQueryValueEx(hKey, TAPI_NUMENTRIES, 0, NULL, (LPBYTE)&dwVal,  &dwSize);

            dwVal++; //bump the entry count up

            RegSetValueEx(hKey, TAPI_NUMENTRIES, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(DWORD));

            RegCloseKey(hKey);
        }

        *pbRetVal = FALSE;


    }
    else
    {
        DWORD dwFlag = REG_DWORD;
        DWORD dwSize = sizeof(dwFlag);
        DWORD dwType = 0;

        if (S_OK !=  GetTapiReg(TAPI_COUNTRY, &dwType, (LPBYTE)&dwFlag, &dwSize))
        {
            m_bTapiAvailable = FALSE;
            goto InitTapiInfoExit;
        }

        // Get CountryID from TAPI
        m_hLineApp = NULL;

        // Get the handle to the line app
        lineInitialize(&m_hLineApp, NULL, LineCallback, NULL, &cDevices);
        if (!m_hLineApp)
        {
            goto InitTapiInfoExit;
        }
        if (cDevices)
        {

            // Get the TAPI API version
            //
            dwCurDev = 0;
            dwAPI = 0;
            lrc = -1;
            while (lrc && dwCurDev < cDevices)
            {
                // NOTE: device ID's are 0 based
                ZeroMemory(&leid, sizeof(leid));
                lrc = lineNegotiateAPIVersion(m_hLineApp, dwCurDev,0x00010004,0x00010004,&dwAPI,&leid);
                dwCurDev++;
            }
            if (lrc)
            {
                // TAPI and us can't agree on anything so nevermind...
                goto InitTapiInfoExit;
            }

            // Find the CountryID in the translate cap structure
            m_pTC = (LINETRANSLATECAPS *)GlobalAlloc(GPTR, sizeof(LINETRANSLATECAPS));
            if (!m_pTC)
            {
                // we are in real trouble here, get out!
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto InitTapiInfoExit;
            }

            // Get the needed size
            m_pTC->dwTotalSize = sizeof(LINETRANSLATECAPS);
            lrc = lineGetTranslateCaps(m_hLineApp, dwAPI,m_pTC);
            if(lrc)
            {
                goto InitTapiInfoExit;
            }

            pv = GlobalAlloc(GPTR, ((size_t)m_pTC->dwNeededSize));
            if (!pv)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto InitTapiInfoExit;
            }
            ((LINETRANSLATECAPS*)pv)->dwTotalSize = m_pTC->dwNeededSize;
            m_pTC = (LINETRANSLATECAPS*)pv;
            pv = NULL;
            lrc = lineGetTranslateCaps(m_hLineApp, dwAPI,m_pTC);
            if(lrc)
            {
                goto InitTapiInfoExit;
            }

            // sanity check
            // Assert(m_pTC->dwLocationListOffset);

            // We have the Number of TAPI locations, so save it now
            m_wNumTapiLocations = (WORD)m_pTC->dwNumLocations;

            // Loop through the locations to find the correct country code
            m_plle = LPLINELOCATIONENTRY (PBYTE(m_pTC) + m_pTC->dwLocationListOffset);
            for (dwCurLoc = 0; dwCurLoc < m_pTC->dwNumLocations; dwCurLoc++)
            {
                if (m_pTC->dwCurrentLocationID == m_plle->dwPermanentLocationID)
                {
                    m_dwCountryID = m_plle->dwCountryID;
                    m_dwCurrLoc = dwCurLoc;
                    break; // for loop
                }
                m_plle++;
            }

            // If we could not find it in the above loop, default to US
            if (!m_dwCountryID)
            {
                m_dwCountryID = 1;
                goto InitTapiInfoExit;
            }
        }
        *pbRetVal = TRUE;           // Getting here means everything worked
    }

    // Settings in INI_SETTINGS_FILENAME should initialize or override the
    // system's Tapi configuration.

    if (GetCanonicalizedPath(szIniFile, INI_SETTINGS_FILENAME))
    {

        //
        // [Options]
        // Tonepulse = 0 for pulse, 1 for tone
        // Areacode = {string}
        // OutsideLine = {string}
        // DisableCallWaiting = {string}
        //

        LONG lTonDialing = (BOOL) GetPrivateProfileInt(OPTIONS_SECTION,
                                      TONEPULSE,
                                      -1,
                                      szIniFile);
        if (lTonDialing != -1)
        {
            PutPhoneSystem(lTonDialing);
        }

        if (GetPrivateProfileString(OPTIONS_SECTION,
                                AREACODE,
                                L"\0",
                                m_szAreaCode,
                                MAX_CHARS_IN_BUFFER(m_szAreaCode),
                                szIniFile))
        {
            PutbstrAreaCode(SysAllocString(m_szAreaCode));
        }

        if (GetPrivateProfileString(OPTIONS_SECTION,
                                OUTSIDELINE,
                                L"\0",
                                m_szDialOut,
                                MAX_CHARS_IN_BUFFER(m_szDialOut),
                                szIniFile))
        {
            PutOutsideDial(SysAllocString(m_szDialOut));
        }

        if (GetPrivateProfileString(OPTIONS_SECTION,
                                DISABLECALLWAITING,
                                L"\0",
                                m_szCallWaiting,
                                MAX_CHARS_IN_BUFFER(m_szCallWaiting),
                                szIniFile))
        {
            PutCallWaiting(SysAllocString(m_szCallWaiting));
        }
    }

InitTapiInfoExit:

    // if we can't figure it out because TAPI is messed up just default to
    // the US.  The user will still have the chance to pick the right answer.
    if (!m_dwCountryID) {
        m_dwCountryID = 1;
    }

    if (m_hLineApp)
    {
        lineShutdown(m_hLineApp);
        m_hLineApp = NULL;
    }

    m_lNumOfCountry = 0;
    GetNumCountries(&m_lNumOfCountry);

    return S_OK;
}



STDMETHODIMP CTapiLocationInfo::GetlCountryIndex(long * plVal)
{
    *plVal = m_dwComboCountryIndex;
    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::SetlCountryIndex(long lVal)
{
    HRESULT hr = E_FAIL;
    
    // Write to registry
    if (lVal < m_lNumOfCountry && lVal > -1)
    {
        m_bTapiCountrySet = TRUE;
        m_dwCountryID = m_rgNameLookUp[lVal].pLCE->dwCountryID;
        m_dwCountrycode = m_rgNameLookUp[lVal].pLCE->dwCountryCode;
        m_dwComboCountryIndex = lVal;
        hr = SetTapiReg(TAPI_COUNTRY, REG_DWORD, (LPBYTE)&m_rgNameLookUp[lVal].pLCE->dwCountryID, sizeof(DWORD) );
    }

    if (SUCCEEDED(hr))
    {
        m_bCheckModemCountry = TRUE;
    }

    return hr;
}

STDMETHODIMP CTapiLocationInfo::GetCountryID(DWORD* dwCountryID)
{
    MYASSERT( m_dwCountryID );
    *dwCountryID = m_dwCountryID;
    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::GetCountryCode(DWORD* dwCountryCode)
{
    *dwCountryCode = m_dwCountrycode;
    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::GetNumCountries(long *plNumOfCountry)
{
    USES_CONVERSION;

    LPLINECOUNTRYLIST   pLineCountryTemp    = NULL;
    LPLINECOUNTRYENTRY  pLCETemp;
    DWORD               idx;
    DWORD               dwCurLID            = 0;
    HINSTANCE           hTapi32Dll          = NULL;
    FARPROC             fp;
    BOOL                bBookLoaded         = FALSE;
    HRESULT             hr                  = S_OK;

    if (NULL == plNumOfCountry)
        goto GetNumCountriesExit;

    // Avoid returning rubbish
    //
    *plNumOfCountry = 0;

    if (m_lNumOfCountry != 0)
    {
        *plNumOfCountry = m_lNumOfCountry;
        goto GetNumCountriesExit;
    }

    hTapi32Dll = LoadLibrary(L"tapi32.dll");
    if (hTapi32Dll)
    {
        fp = GetProcAddress(hTapi32Dll, "lineGetCountryW");
        if (!fp)
        {
            hr = GetLastError();
            goto GetNumCountriesExit;
        }


        // Get TAPI country list
        if (m_pLineCountryList)
            GlobalFree(m_pLineCountryList);

        m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR, sizeof(LINECOUNTRYLIST));
        if (!m_pLineCountryList)
        {
            hr = S_FALSE;
            goto GetNumCountriesExit;
        }

        m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);

        idx = ((LINEGETCOUNTRY)fp)(0, 0x10003,m_pLineCountryList);
        if (idx && idx != LINEERR_STRUCTURETOOSMALL)
        {
            hr = S_FALSE;
            goto GetNumCountriesExit;
        }

        // Assert(m_pLineCountryList->dwNeededSize);

        pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
                                                            (size_t)m_pLineCountryList->dwNeededSize);
        if (!pLineCountryTemp)
        {
            hr = S_FALSE;
            goto GetNumCountriesExit;
        }

        pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
        GlobalFree(m_pLineCountryList);

        m_pLineCountryList = pLineCountryTemp;
        pLineCountryTemp = NULL;

        if (((LINEGETCOUNTRY)fp)(0, 0x10003,m_pLineCountryList))
        {
            hr = S_FALSE;
            goto GetNumCountriesExit;
        }

        // look up array
        pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList +
            m_pLineCountryList->dwCountryListOffset);

        if(m_rgNameLookUp)
            GlobalFree(m_rgNameLookUp);

        m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,
            (int)(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries));

        if (!m_rgNameLookUp)
        {
            hr = S_FALSE;
            goto GetNumCountriesExit;
        }

        CNTRYNAMELOOKUPELEMENT CntryNameLUElement = {NULL, 0, NULL};
        CNTRYNAMELOOKUPELEMENT cnleUS = {NULL, 0, NULL};
        DWORD cbAllCountryPairs = 0;

        for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
        {

            m_rgNameLookUp[idx].psCountryName = (LPWSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
            m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
            m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
#if 0
            TRACE2(L"GetNumCountries:%d:%s",
                   m_rgNameLookUp[idx].pLCE->dwCountryID,
                   m_rgNameLookUp[idx].psCountryName
                   );
#endif
            // Include space for NUL at end of unicode string
            //
            cbAllCountryPairs += m_rgNameLookUp[idx].dwNameSize + 2;

            // If TAPI is not available, we set the default to US
            if ( m_rgNameLookUp[idx].pLCE->dwCountryID == m_dwCountryID)
            {
                // Set the index to our default country in combo box
                m_dwComboCountryIndex = idx;
                m_dwCountrycode = m_rgNameLookUp[idx].pLCE->dwCountryCode;
                if (m_rgNameLookUp[idx].psCountryName)
                {
                    m_bstrDefaultCountry = SysAllocString(m_rgNameLookUp[idx].psCountryName);
                }

                memcpy(&CntryNameLUElement, &m_rgNameLookUp[idx], sizeof(CNTRYNAMELOOKUPELEMENT));
            }
            else if (m_rgNameLookUp[idx].pLCE->dwCountryID == 1)
            {
                // Save the US info away in case we don't find the default
                memcpy(&cnleUS, &m_rgNameLookUp[idx], sizeof(CNTRYNAMELOOKUPELEMENT));
            }
        }

        // If we didn't find the default country, we're going to blow up.
        if (CntryNameLUElement.psCountryName == NULL)
        {
            TRACE1(L"Warning: Couldn't find country id %d. Defaulting to US.", m_dwCountryID);
            memcpy(&CntryNameLUElement, &cnleUS, sizeof(CNTRYNAMELOOKUPELEMENT));
            m_dwCountryID = 1;
        }
        MYASSERT( CntryNameLUElement.psCountryName );

        qsort(m_rgNameLookUp, (int)m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
              CompareCntryNameLookUpElements);

        LPCNTRYNAMELOOKUPELEMENT pResult = (LPCNTRYNAMELOOKUPELEMENT)bsearch(&CntryNameLUElement, m_rgNameLookUp, (int)m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
              CompareCntryNameLookUpElements);


        m_dwComboCountryIndex =  (DWORD)((DWORD_PTR)pResult - (DWORD_PTR)m_rgNameLookUp) / sizeof(CNTRYNAMELOOKUPELEMENT);

        if (m_dwComboCountryIndex > m_pLineCountryList->dwNumCountries)
            m_dwComboCountryIndex = 0;

        *plNumOfCountry = m_pLineCountryList->dwNumCountries;
        m_lNumOfCountry = m_pLineCountryList->dwNumCountries;

        // Create the SELECT tag for the html so it can get all the country names in one shot.
        if (m_szAllCountryPairs)
            GlobalFree(m_szAllCountryPairs);

        // BUGBUG: Does this calculation account for country name strings??
        cbAllCountryPairs += m_lNumOfCountry * sizeof(szOptionTag) + 1;
        m_szAllCountryPairs = (WCHAR *)GlobalAlloc(GPTR, cbAllCountryPairs );
        if (m_szAllCountryPairs)
        {
            WCHAR szBuffer[MAX_PATH];
            for (idx=0; idx < (DWORD)m_lNumOfCountry; idx++)
            {
                wsprintf(szBuffer, szOptionTag, m_rgNameLookUp[idx].psCountryName);
                lstrcat(m_szAllCountryPairs, szBuffer);
            }
        }

    }

GetNumCountriesExit:
    if (hTapi32Dll)
    {
        FreeLibrary(hTapi32Dll);
        hTapi32Dll = NULL;
    }
    return hr;
}

STDMETHODIMP CTapiLocationInfo::GetAllCountryName(BSTR* pbstrAllCountryName)
{
    if (pbstrAllCountryName == NULL)
    {
        return E_POINTER;
    }

    // Avoid returning rubbish
    //
    *pbstrAllCountryName = NULL;

    if (m_lNumOfCountry && pbstrAllCountryName && m_szAllCountryPairs)
    {
        *pbstrAllCountryName = SysAllocString(m_szAllCountryPairs);
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CTapiLocationInfo::GetCountryName(long lCountryIndex, BSTR* pszCountryName)
{
    USES_CONVERSION;

    if (lCountryIndex < m_lNumOfCountry && lCountryIndex >= 0)
    {
        *pszCountryName = SysAllocString(m_rgNameLookUp[lCountryIndex].psCountryName);
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CTapiLocationInfo::GetDefaultCountry(long* lCountryIndex)
{
    if (lCountryIndex)
        *lCountryIndex = m_dwComboCountryIndex;
    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::PutCountry(long lCountryIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTapiLocationInfo::GetbstrAreaCode(BSTR * pbstrAreaCode)
{
    HRESULT hr      = S_OK;
    DWORD   dwType  = REG_SZ;
    DWORD   dwSize  = sizeof(m_szAreaCode);
    BSTR    bstrTmp = NULL;

    if (pbstrAreaCode == NULL)
    {
        hr = E_POINTER;
        goto GetbstrAreaCodeExit;
    }

    // Avoid returning rubbish
    //
    *pbstrAreaCode = NULL;

    // Allocate default return value
    //
    hr = GetTapiReg(TAPI_AREACODE, &dwType, (LPBYTE)m_szAreaCode, &dwSize);
    if (SUCCEEDED(hr))
    {
        bstrTmp = SysAllocString(m_szAreaCode);
    }
    else
    {
        bstrTmp = SysAllocString(SZ_EMPTY);
    }

    // A valid string can be returned (though it may be empty) so we've
    // succeeded.
    //
    hr = S_OK;

GetbstrAreaCodeExit:
    if (SUCCEEDED(hr))
    {
         *pbstrAreaCode = bstrTmp;
        bstrTmp = NULL;
    }

    return hr;
}

STDMETHODIMP CTapiLocationInfo::PutbstrAreaCode(BSTR bstrAreaCode)
{
    LPWSTR  szAreaCode = (NULL != bstrAreaCode) ? bstrAreaCode : SZ_EMPTY;

    DWORD dwSize = BYTES_REQUIRED_BY_SZ(szAreaCode);
    SetTapiReg(TAPI_AREACODE, REG_SZ, (LPBYTE)szAreaCode, dwSize);

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::IsAreaCodeRequired(long lVal, BOOL *pbVal)
{
    LPWSTR szAreaCodeRule = NULL;
    LPWSTR szLongDistanceRule = NULL;
    if (!pbVal)
        return E_POINTER;

    *pbVal = FALSE;

    if (lVal < m_lNumOfCountry && lVal > -1 && m_pLineCountryList)
    {
        szAreaCodeRule = (LPWSTR)m_pLineCountryList + m_rgNameLookUp[lVal].pLCE->dwSameAreaRuleOffset;
        szLongDistanceRule = (LPWSTR)m_pLineCountryList + m_rgNameLookUp[lVal].pLCE->dwLongDistanceRuleOffset;
        if (szAreaCodeRule && szLongDistanceRule)
        {
            *pbVal = (NULL != StrChr(szAreaCodeRule, L'F')) || (NULL != StrChr(szLongDistanceRule, 'F'));
        }
    }

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::GetOutsideDial(BSTR * pbstrOutside)
{
    DWORD   dwType  = REG_SZ;
    DWORD   dwSize  = sizeof(m_szDialOut);
    HRESULT hr      = S_OK;
    BSTR    bstrTmp = NULL;

    if (pbstrOutside == NULL)
    {
        hr = E_POINTER;
        goto GetOutsideDialExit;
    }

    // Avoid returning rubbish in case of error
    //
    *pbstrOutside = NULL;

    // Allocate empty string for default return string
    //
    bstrTmp = SysAllocString(SZ_EMPTY);
    if (NULL == bstrTmp)
    {
        hr = E_OUTOFMEMORY;
        goto GetOutsideDialExit;
    }


    hr = GetTapiReg(TAPI_OUTSIDE, &dwType, (LPBYTE)m_szDialOut, &dwSize);
    if FAILED(hr)
    {
        goto GetOutsideDialExit;
    }

    if (! SysReAllocString(&bstrTmp, m_szDialOut))
    {
        hr = E_OUTOFMEMORY;
        goto GetOutsideDialExit;
    }


GetOutsideDialExit:
    if (SUCCEEDED(hr))
    {
        *pbstrOutside = bstrTmp;
    }
    else
    {
        if (NULL != bstrTmp)
        {
            SysFreeString(bstrTmp);
        }
    }
    bstrTmp = NULL;

    return hr;
}

STDMETHODIMP CTapiLocationInfo::PutOutsideDial(BSTR bstrOutside)
{
    // Is the bstr null-terminated??
    assert(lstrlen(bstrOutside) <= SysStringLen(bstrOutside));

    // If no string is passed in, default to empty string
    //
    lstrcpyn(
        m_szDialOut,
        (NULL != bstrOutside) ? bstrOutside : SZ_EMPTY,
        MAX_CHARS_IN_BUFFER(m_szDialOut));

    DWORD dwSize = BYTES_REQUIRED_BY_SZ(m_szDialOut);

    HRESULT hr = SetTapiReg(TAPI_OUTSIDE, REG_SZ, (LPBYTE)m_szDialOut, dwSize);
    if (SUCCEEDED(hr))
    {
        hr = SetTapiReg(TAPI_LONGDIST, REG_SZ, (LPBYTE)m_szDialOut, dwSize);
    }

    return hr;
}

STDMETHODIMP CTapiLocationInfo::GetPhoneSystem(long* plTone)
{
    DWORD dwFlag = REG_DWORD;
    DWORD dwSize = sizeof(dwFlag);
    DWORD dwType = 0;

    if (NULL == plTone)
        return E_FAIL;
    *plTone = 1;

    if (S_OK == GetTapiReg(TAPI_FLAG, &dwType, (LPBYTE)&dwFlag, &dwSize))
    {
        *plTone = dwFlag & 0x01;
    }

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::PutPhoneSystem(long lTone)
{
    DWORD dwFlag = REG_DWORD;
    DWORD dwSize = sizeof(dwFlag);
    DWORD dwType = 0;

    if (S_OK !=  GetTapiReg(TAPI_FLAG, &dwType, (LPBYTE)&dwFlag, &dwSize))
    {
        dwFlag = 0;
    }

    if (lTone)
        dwFlag |= 0x01;
    else
        dwFlag &= (~0x01);

    return SetTapiReg(TAPI_FLAG, REG_DWORD, (LPBYTE)&dwFlag, sizeof(DWORD) );
}

STDMETHODIMP CTapiLocationInfo::GetCallWaiting(BSTR* pbstrCallWaiting)
{
    DWORD   dwFlag = 0;
    DWORD   dwSize = sizeof(dwFlag);
    DWORD   dwType = REG_DWORD;
    HRESULT hr     = S_OK;
    BSTR    bstrTmp = NULL;


    if (NULL == pbstrCallWaiting)
    {
        hr = E_POINTER;
        goto GetCallWaitingExit;
    }

    // Avoid returning rubbish in case of error
    //
    *pbstrCallWaiting = NULL;

    // Allocate empty string for default return string
    //
    bstrTmp = SysAllocString(SZ_EMPTY);
    if (NULL == bstrTmp)
    {
        hr = E_OUTOFMEMORY;
        goto GetCallWaitingExit;
    }

    if (S_OK == GetTapiReg(TAPI_FLAG, &dwType, (LPBYTE)&dwFlag, &dwSize))
    {
        // If call waiting is not enabled, return default string
        if (!(dwFlag & 0x04))
        {
            goto GetCallWaitingExit;
        }
    }

    dwType = REG_SZ;
    dwSize = sizeof(m_szCallWaiting);

    hr = GetTapiReg(TAPI_CALLWAIT, &dwType, (LPBYTE)m_szCallWaiting, &dwSize);
    if (FAILED(hr))
    {
        goto GetCallWaitingExit;
    }

    // Replace the default string with the retrieved string
    //
    if (! SysReAllocString(&bstrTmp, m_szCallWaiting))
    {
        hr = E_OUTOFMEMORY;
        goto GetCallWaitingExit;
    }

GetCallWaitingExit:
    if (SUCCEEDED(hr))
    {
        *pbstrCallWaiting = bstrTmp;
        bstrTmp = NULL;
    }
    else
    {
        if (NULL != bstrTmp)
        {
            SysFreeString(bstrTmp);
        }
    }

    return hr;
}

STDMETHODIMP CTapiLocationInfo::PutCallWaiting(BSTR bstrCallWaiting)
{
    DWORD   dwFlag  = 0;
    DWORD   dwSize  = sizeof(dwFlag);
    DWORD   dwType  = REG_DWORD;
    HRESULT hr      = S_OK;

    // Is the BSTR null-terminated?
    assert(lstrlen(bstrCallWaiting) <= SysStringLen(bstrCallWaiting));

    if (bstrCallWaiting == NULL || SysStringLen(bstrCallWaiting) == 0)
    {
        if (S_OK == GetTapiReg(TAPI_FLAG, &dwType, (LPBYTE)&dwFlag, &dwSize))
        {
            dwFlag &= (~0x04);
            hr = SetTapiReg(TAPI_FLAG, REG_DWORD, (LPBYTE)&dwFlag, sizeof(DWORD) );
        }
    }
    else
    {
        if (S_OK ==  GetTapiReg(TAPI_FLAG, &dwType, (LPBYTE)&dwFlag, &dwSize))
        {
            dwFlag |= 0x04;
        }
        else
        {
            // Value doesn't exist yet
            //
            dwFlag = (DWORD)0x04;
        }

        dwSize = BYTES_REQUIRED_BY_SZ(bstrCallWaiting);
        hr = SetTapiReg(TAPI_CALLWAIT, REG_SZ, (LPBYTE)bstrCallWaiting, dwSize);
        if (SUCCEEDED(hr))
        {
            hr = SetTapiReg(TAPI_FLAG, REG_DWORD, (LPBYTE)&dwFlag, sizeof(DWORD) );
        }
    }

    return hr;
}

void CTapiLocationInfo::DeleteTapiInfo()
{
    HKEY hKey;
    DWORD dwRun = 0;

    if (!m_bTapiCountrySet && !m_bTapiAvailable)
    {

        // We need to remove the tapi data.
        //
        RegDeleteKey(HKEY_LOCAL_MACHINE, TAPI_PATH_LOC0);

        if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, TAPI_PATH_LOCATIONS, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS )
        {
            RegDeleteValue(hKey, TAPI_NUMENTRIES);
            RegDeleteValue(hKey, TAPI_CURRENTID);
            RegDeleteValue(hKey, TAPI_NEXTID);
            RegCloseKey(hKey);
        }

        // Now pretend that we didn't create these entries so we don't clean up twice
        // (2nd instance case)
        m_bTapiCountrySet = TRUE;
    }

}

STDMETHODIMP CTapiLocationInfo::TapiServiceRunning(BOOL *pbRet)
{
    SC_HANDLE  sc_handle;
    SC_HANDLE  sc_service;
    SERVICE_STATUS service_status;

    TRACE(L"TapiServiceRunning");
    *pbRet = FALSE;
    sc_handle = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
    if (sc_handle)
    {
        TRACE(L"OpenSCManager succeeded");
        sc_service = OpenService(sc_handle, TEXT("TAPISRV"), SERVICE_QUERY_STATUS);
        if (sc_service)
        {
            TRACE(L"OpenService succeeded");
            if (QueryServiceStatus(sc_service, &service_status ))
            {
                *pbRet = (service_status.dwCurrentState == SERVICE_RUNNING);
            }
            else
            {
                TRACE1(L"QueryServiceStatus failed with %lx", GetLastError());
            }
            CloseServiceHandle(sc_service);
        }
        else
        {
            TRACE1(L"OpenService failed. GetLastError()=%lx",GetLastError());

        }
        CloseServiceHandle(sc_handle);
    }

    return S_OK;
}

void CTapiLocationInfo::CheckModemCountry()

/*++

Routine description:

    This is soft modem workaround provided by unimodem team. It should be called
    before dialing when the TAPI country code is changed in OOBE. Also, it
    should be called during OEM install only, as GUI mode setup handles TAPI
    configuration for upgrade and clean install.

    The problem we have is that:
      1. Some vendors set the GCI code incorrectly based on the TAPI location
         key (which is a bad thing L)
      2. Some modems do not conform to GCI
      3. Some modems do not correctly accept AT+GCI commands.
    (+GCI is Modems AT commands for setting country)

    The conformance check ensures the GCI value is properly sync
    with the TAPI location. It disables GCI if the modem does not conform
    to the GCI spec.

Note:

    This function can take as long as 15 seconds. We should make sure the UI
    doesn't appear to hang during the call.

--*/

{

typedef void (*COUNTRYRUNONCE)();

    if (m_bCheckModemCountry)
    {
        TCHAR szIniFile[MAX_PATH];
        
        if (GetCanonicalizedPath(szIniFile, INI_SETTINGS_FILENAME))
        {
            UINT bCheckModem = GetPrivateProfileInt(
                OPTIONS_SECTION,
                CHECK_MODEMGCI,
                0,
                szIniFile);
            
            if (bCheckModem)
            {
                HMODULE   hLib;

                hLib=LoadLibrary(TEXT("modemui.dll"));

                if (hLib != NULL)
                {

                    COUNTRYRUNONCE  Proc;

                    Proc=(COUNTRYRUNONCE)GetProcAddress(hLib,"CountryRunOnce");

                    if (Proc != NULL)
                    {
                        TRACE(L"Start modemui!CountryRunOnce");
                        Proc();
                        TRACE(L"End modemui!CountryRunOnce");
                    }

                    FreeLibrary(hLib);
                }
            }
            
        }
        
        m_bCheckModemCountry = FALSE;

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\tapiloc.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  USERINFO.H - Header for the implementation of CTapiLocationInfo
//
//  HISTORY:
//
//  1/27/99 vyung Created.
//

#ifndef __TAPILOCATIONINFO_H_
#define __TAPILOCATIONINFO_H_

#include <windows.h>
#include <tapi.h>
#include <ras.h>
#include <assert.h>
#include <oleauto.h>

#define TAPI_PATH_LOCATIONS   \
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"
#define TAPI_PATH_LOC0   \
 L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations\\Location0"
#define TAPI_LOCATION   L"Location"
#define TAPI_AREACODE   L"AreaCode"
#define TAPI_COUNTRY    L"Country"
#define TAPILOCKEY      L"Locations"
#define TAPI_FLAG       L"Flags"
#define TAPI_CALLWAIT   L"DisableCallWaiting"
#define TAPI_ID         L"ID"

#define NULL_SZ         L"\0"

#define TAPI_NAME       L"Name"
#define TAPI_OUTSIDE    L"OutsideAccess"
#define TAPI_LONGDIST   L"LongDistanceAccess"

#define TAPI_CURRENTID  L"CurrentID"
#define TAPI_NUMENTRIES L"NumEntries"
#define TAPI_NEXTID     L"NextID"

static const WCHAR szOptionTag[] = L"<OPTION>%ws</OPTION>";

typedef LONG (WINAPI * LINEGETCOUNTRY)  (   DWORD               dwCountryID,
                                            DWORD               dwAPIVersion,
                                            LPLINECOUNTRYLIST   lpLineCountryList
                                            );

typedef struct tagCNTRYNAMELOOKUPELEMENT {
    // psCountryName is an LPSTR because it points to an ANSI string in a
    // LINECOUNTRYLIST structure.
    //
    LPWSTR              psCountryName;
    DWORD               dwNameSize;
    LPLINECOUNTRYENTRY  pLCE;
} CNTRYNAMELOOKUPELEMENT, far *LPCNTRYNAMELOOKUPELEMENT;

class CTapiLocationInfo : public IDispatch
{
// ITapiLocationInfo
public:

    STDMETHOD(GetNumCountries)   (long *plNumOfCountry);
    STDMETHOD(GetCountryName)    (long lCountryIndex, BSTR * pszCountryName);
    STDMETHOD(GetAllCountryName) (BSTR *pbstrAllCountryName);

    STDMETHOD(GetlCountryIndex)  (long *plVal);
    STDMETHOD(SetlCountryIndex)  (long lVal);

    STDMETHOD(GetDefaultCountry) (long* lCountryIndex);
    STDMETHOD(PutCountry)        (long lCountryIndex);

    STDMETHOD(GetbstrAreaCode)   (BSTR *pbstrAreaCode);
    STDMETHOD(PutbstrAreaCode)   (BSTR bstrAreaCode);
    STDMETHOD(IsAreaCodeRequired)(long lVal, BOOL* pbVal);

    STDMETHOD(GetOutsideDial)    (BSTR *pbstrOutside);
    STDMETHOD(PutOutsideDial)    (BSTR bstrOutside);

    STDMETHOD(GetPhoneSystem)    (long* plTone);
    STDMETHOD(PutPhoneSystem)    (long  lTone);

    STDMETHOD(GetCallWaiting)    (BSTR *pbstrCallWaiting);
    STDMETHOD(PutCallWaiting)    (BSTR bstrCallWaiting);

    CTapiLocationInfo();
    ~CTapiLocationInfo();

    STDMETHOD(InitTapiInfo)      (BOOL *pbRetVal);
    STDMETHOD(GetCountryID)      (DWORD* dwCountryID);
    STDMETHOD(GetCountryCode)    (DWORD* dwCountryCode);
    STDMETHOD(TapiServiceRunning) (BOOL *pbRetVal);

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid,
                                  WORD wFlags, DISPPARAMS* pdispparams,
                                  VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
                                  UINT* puArgErr);
    void DeleteTapiInfo          ();
    void CheckModemCountry       ();

protected:
    HLINEAPP                    m_hLineApp;
    WORD                        m_wNumTapiLocations;
    DWORD                       m_dwCountryID;
    DWORD                       m_dwCountrycode;
    DWORD                       m_dwCurrLoc;
    WCHAR                       m_szAreaCode[RAS_MaxAreaCode+1];
    WCHAR                       m_szDialOut[RAS_MaxAreaCode+1];
    WCHAR                       m_szCallWaiting[MAX_PATH];
    BSTR                        m_bstrDefaultCountry;
    LPLINECOUNTRYLIST           m_pLineCountryList;
    LPCNTRYNAMELOOKUPELEMENT    m_rgNameLookUp;
    LPLINELOCATIONENTRY         m_plle;
    LPLINETRANSLATECAPS         m_pTC;
    long                        m_lNumOfCountry;
    BOOL                        m_bTapiAvailable;
    DWORD                       m_dwComboCountryIndex;
    ULONG                       m_cRef;
    LPWSTR                      m_szAllCountryPairs;
    BOOL                        m_bTapiCountrySet;
    BOOL                        m_bCheckModemCountry;
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobshel\mainpane.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MAINPANE.CPP - Implementation of CObShellMainPane
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
//  Class which will create a window, attach and instance of ObWebBrowser,
//  and then provide several specialized interfaces to alter the content of the doc

#include "mainpane.h"
#include "appdefs.h"
#include "commerr.h"
#include "dispids.h"
#include "shlobj.h"
#include "util.h"

#include <assert.h>
#include <shlwapi.h>
#include <wininet.h>

// From MSOBMAIN.DLL
BOOL WINAPI IsOemVer();

//Dialing error callbacks
#define SCRIPTFN_ONDIALINGERROR             L"OnDialingError(%i)"
#define SCRIPTFN_ONSERVERERROR              L"OnServerError(%i)"
#define SCRIPTFN_ONDIALING                  L"OnDialing()"
#define SCRIPTFN_ONCONNECTING               L"OnConnecting()"
#define SCRIPTFN_ONCONNECTED                L"OnConnected()"
#define SCRIPTFN_ONDOWNLOADING              L"OnDownloading()"
#define SCRIPTFN_ONDISCONNECT               L"OnDisconnect()"

//ICS error callback(s)
#define SCRIPTFN_ONICSCONNECTIONSTATUS      _T("OnIcsConnectionStatus(%i)")

// Dialing error callbacks for Migration
#define SCRIPTFN_ONDIALINGERROREX           L"OnDialingErrorEx(%i)"
#define SCRIPTFN_ONSERVERERROREX            L"OnServerErrorEx(%i)"
#define SCRIPTFN_ONDIALINGEX                L"OnDialingEx()"
#define SCRIPTFN_ONCONNECTINGEX             L"OnConnectingEx()"
#define SCRIPTFN_ONCONNECTEDEX              L"OnConnectedEx()"
#define SCRIPTFN_ONDOWNLOADINGEX            L"OnDownloadingEx()"
#define SCRIPTFN_ONDISCONNECTEX             L"OnDisconnectEx()"
#define SCRIPTFN_ONISPDOWNLOADCOMPLETEEX    L"OnISPDownloadCompleteEx(\"%s\")"
#define SCRIPTFN_ONREFDOWNLOADCOMPLETEEX    L"OnRefDownloadCompleteEx(%i)"
#define SCRIPTFN_ONREFDOWNLOADPROGRESSEX    L"OnRefDownloadProgressEx(%i)"

// USB device arrival
#define SCRIPTFN_ONDEVICEARRIVAL            L"OnDeviceArrival(%i)"

//Statuspane callbacks
#define SCRIPTFN_ADDSTATUSITEM    L"AddStatusItem(\"%s\", %i)"
#define SCRIPTFN_REMOVESTATUSITEM L"RemoveStatusItem(%i)"
#define SCRIPTFN_SELECTSTATUSITEM L"SelectStatusItem(%i)"

// Agent help
#define SCRIPTFN_ONHELP                     L"OnHelp()"

#define USES_EX(t) (CONNECTED_REGISTRATION != t)

BOOL ConvertToScript(const WCHAR* pSz, WCHAR* pszUrlOut, INT uSize)
{
    WCHAR   sztemp[INTERNET_MAX_URL_LENGTH] = L"\0";//L"file://";
    WCHAR*  szOut                           = sztemp;
    BOOL    bRet                            = FALSE;

    if (!pszUrlOut || !pSz)
        return bRet;

    szOut += lstrlen(sztemp);

    while (*pSz )
    {
        *szOut++ = *pSz++;
        if(*pSz == L'\\')
        {
            *szOut++ = L'\\';
        }
    }
    if (uSize >= lstrlen(pSz))
    {
        lstrcpy(pszUrlOut, sztemp);
        bRet = TRUE;
    }
    return bRet;
}

///////////////////////////////////////////////////////////
//
// Creation function used by CFactory.
//
HRESULT CObShellMainPane::CreateInstance  (IUnknown*  pOuterUnknown,
                                           CUnknown** ppNewComponent)
{
    if (pOuterUnknown != NULL)
    {
      // Don't allow aggregation. Just for the heck of it.
      return CLASS_E_NOAGGREGATION;
    }

    *ppNewComponent = new CObShellMainPane(pOuterUnknown);
    return S_OK;
}

///////////////////////////////////////////////////////////
//
//  NondelegatingQueryInterface
//
HRESULT __stdcall
CObShellMainPane::NondelegatingQueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IObShellMainPane)
    {
        return FinishQI(static_cast<IObShellMainPane*>(this), ppv);
    }
    if( (iid == DIID_DWebBrowserEvents2) ||
        (iid == IID_IDispatch))
    {
       return FinishQI(static_cast<DWebBrowserEvents2*>(this), ppv);
    }
    else
    {
        return CUnknown::NondelegatingQueryInterface(iid, ppv);
    }
}

///////////////////////////////////////////////////////////
//
//  Constructor
//
CObShellMainPane::CObShellMainPane(IUnknown* pOuterUnknown)
: CUnknown(pOuterUnknown)
{
    IUnknown* pUnk = NULL;

    m_cStatusItems  = 0;
    m_dwAppMode     = 0;
    m_hMainWnd      = NULL;
    m_pObWebBrowser = NULL;
    m_pDispEvent    = NULL;
    m_bstrBaseUrl   = SysAllocString(L"\0");
    m_pIFrmStatPn   = NULL;
    m_pPageIDForm   = NULL;
    m_pBackForm     = NULL;
    m_pPageTypeForm = NULL;
    m_pNextForm     = NULL;
    m_pPageFlagForm = NULL;

     //Try to CoCreate ObWebBrowser

    if(FAILED(CoCreateInstance(CLSID_ObWebBrowser,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IObWebBrowser,
                               (LPVOID*)&m_pObWebBrowser)))
    {
        m_pObWebBrowser = NULL;
    }

    //Let's try to register us as a listener for WebBrowserEvents
    if(SUCCEEDED(QueryInterface(IID_IUnknown, (LPVOID*)&pUnk)) && pUnk)
    {
       HRESULT hr =  m_pObWebBrowser->ListenToWebBrowserEvents(pUnk);
       pUnk->Release();
       pUnk = NULL;
    }

}

///////////////////////////////////////////////////////////
//
//  Destructor
//
CObShellMainPane::~CObShellMainPane()
{
    if(m_pObWebBrowser)
    {
        m_pObWebBrowser->Release();
        m_pObWebBrowser = NULL;
    }
    if (m_pIFrmStatPn)
    {
        delete m_pIFrmStatPn;
    }

}

///////////////////////////////////////////////////////////
//
//  FinalRelease -- Clean up the aggreated objects.
//
void CObShellMainPane::FinalRelease()
{
    CUnknown::FinalRelease();
}


///////////////////////////////////////////////////////////
//  IObShellMainPane Implementation
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
//  CreatePane
//
HRESULT CObShellMainPane::CreateMainPane(HANDLE_PTR hInstance, HWND hwndParent, RECT* prectWindowSize, BSTR bstrStartPage)
{
    WNDCLASS wc;

    //If we don't have an ObWebBrowser, we are seriously messed up,
    //fail so the caller will know what's up.
    assert(m_pObWebBrowser);

    if(!m_pObWebBrowser)
        return E_FAIL;

    ZeroMemory((PVOID)&wc, sizeof(WNDCLASS));

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = OBSHEL_MAINPANE_CLASSNAME;
    wc.lpfnWndProc   = (WNDPROC)&MainPaneWndProc;
    wc.hInstance     = (HINSTANCE)hInstance;
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);

    // Millen Bug 134831 03/03/00 OOBE2: Trident Does not Repaint in Mouse Tutorial
    // Fixed: setting the brush to Null let trident repaint the grey area
    // Removed: wc.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.hbrBackground = NULL;

    RegisterClass(&wc);

    m_hMainWnd = CreateWindow(OBSHEL_MAINPANE_CLASSNAME,
                              OBSHEL_MAINPANE_WINDOWNAME,
                              WS_CHILD,
                              prectWindowSize->left,
                              prectWindowSize->top,
                              prectWindowSize->right,
                              prectWindowSize->bottom,
                              hwndParent,
                              NULL,
                              wc.hInstance,
                              NULL);

    m_hwndParent    = hwndParent;
    m_hInstance     = (HINSTANCE)hInstance;

    //If we don't have an hwnd, once again we are seriously messed up,
    //fail so the caller will know what's up.
    assert(m_pObWebBrowser);

    if(!m_hMainWnd)
        return E_FAIL;

    //Hook the WebOC up to the window
    m_pObWebBrowser->AttachToWindow(m_hMainWnd);



    HINSTANCE hInst = LoadLibrary(OOBE_SHELL_DLL);

    if (hInst)
    {
        BOOL    bRet;
        WCHAR szUrl       [MAX_PATH*3] = L"file://";

        int cchUrl = lstrlen(szUrl);
        // Bail out if we can't find the directory with our files.  Should be
        // %windir%\system32\oobe.
        //
        if ((APMD_ACT == m_dwAppMode) || 
            (APMD_MSN == m_dwAppMode) && !IsOemVer())
        {
            bRet = GetOOBEMUIPath(szUrl + cchUrl);
        } else {
            bRet = GetOOBEPath(szUrl + cchUrl);
        }
        if (! bRet)
        {
            return E_FAIL;
        }

        // append trailing backslash and appropriate file name
        //
        lstrcat(szUrl, L"\\");
        lstrcat(szUrl, bstrStartPage);

        FreeLibrary(hInst);
        m_pObWebBrowser->Navigate(szUrl, NULL);
    }
    // Create the status pane obj
    if(APMD_OOBE == m_dwAppMode)
    {
        if (NULL != (m_pIFrmStatPn = new CIFrmStatusPane()))
            m_pIFrmStatPn->InitStatusPane(m_pObWebBrowser);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////
//  DestroyMainPane
//
HRESULT CObShellMainPane::DestroyMainPane()
{
    IUnknown* pUnk = NULL;
    if (m_pPageIDForm)
    {
        m_pPageIDForm->Release();
        m_pPageIDForm = NULL;
    }
    if (m_pBackForm)
    {
        m_pBackForm->Release();
        m_pBackForm = NULL;
    }
    if (m_pPageTypeForm)
    {
        m_pPageTypeForm->Release();
        m_pPageTypeForm = NULL;
    }
    if (m_pNextForm)
    {
        m_pNextForm->Release();
        m_pNextForm = NULL;
    }
    if (m_pPageFlagForm)
    {
        m_pPageFlagForm->Release();
        m_pPageFlagForm = NULL;
    }
    if(m_pDispEvent)
    {
        m_pDispEvent->Release();
        m_pDispEvent = NULL;
    }


    //Let's try to unregister us as a listener for WebBrowserEvents
    if(SUCCEEDED(QueryInterface(IID_IUnknown, (LPVOID*)&pUnk)) && pUnk)
    {
       HRESULT hr =  m_pObWebBrowser->StopListeningToWebBrowserEvents(pUnk);
       pUnk->Release();
       pUnk = NULL;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////
//  SetAppMode
//
HRESULT CObShellMainPane::SetAppMode(DWORD dwAppMode)
{
    m_dwAppMode = dwAppMode;
    return S_OK;
}

///////////////////////////////////////////////////////////
//  MainPaneShowWindow
//
HRESULT CObShellMainPane::MainPaneShowWindow()
{
    ShowWindow(m_hMainWnd, SW_SHOW);
    if(m_pObWebBrowser)
        m_pObWebBrowser->ObWebShowWindow();
    return S_OK;
}

///////////////////////////////////////////////////////////
//  PreTranslateMessage
//
HRESULT CObShellMainPane::PreTranslateMessage(LPMSG lpMsg)
{
   if(m_pObWebBrowser)
       return m_pObWebBrowser->PreTranslateMessage(lpMsg);

   return S_FALSE;
}

///////////////////////////////////////////////////////////
//  Navigate
//

HRESULT CObShellMainPane::Navigate(WCHAR* pszUrl)
{
    TRACE1(L"Attempting to navigate to %s\n", pszUrl);

   if(m_pObWebBrowser)
   {
       m_pObWebBrowser->Navigate(pszUrl, DEFAULT_FRAME_NAME);
   }

    return S_OK;
}

HRESULT CObShellMainPane::AddStatusItem(BSTR bstrText,int iIndex)
{
    m_cStatusItems++;

    return m_pIFrmStatPn->AddItem(bstrText, iIndex + 1);
}

HRESULT CObShellMainPane::RemoveStatusItem(int iIndex)
{
    return S_OK;
}

HRESULT CObShellMainPane::SelectStatusItem(int iIndex)
{
    m_pIFrmStatPn->SelectItem(iIndex + 1);

    return S_OK;
}
HRESULT CObShellMainPane::ExtractUnHiddenText(BSTR* pbstrText)
{
    VARIANT                  vIndex;
    LPDISPATCH               pDisp;
    IHTMLInputHiddenElement* pHidden;
    IHTMLElement*            pElement;
    BSTR                     bstrValue;
    VARIANT                  var2   = { 0 };
    long                     lLen   = 0;

    vIndex.vt = VT_UINT;
    bstrValue = SysAllocString(L"\0");


    //Walk();

    if (!m_pNextForm)
        return E_UNEXPECTED;

    m_pNextForm->get_length(&lLen);

    for (int i = 0; i < lLen; i++)
    {
        vIndex.lVal = i;
        pDisp = NULL;

        if(SUCCEEDED(m_pNextForm->item(vIndex, var2, &pDisp)) && pDisp)
        {
            pHidden = NULL;

            if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLInputHiddenElement, (LPVOID*)&pHidden)) && pHidden)
            {
                pHidden->put_value(bstrValue);
                pHidden->Release();
            }
            pDisp->Release();
        }
    }

    if (SUCCEEDED(m_pNextForm->QueryInterface(IID_IHTMLElement, (LPVOID*)&pElement)) && pElement)
        pElement->get_innerHTML(pbstrText);

    SysFreeString(bstrValue);

    return S_OK;
}


HRESULT CObShellMainPane::get_IsQuickFinish(BOOL* pbIsQuickFinish)
{
    if (!m_pPageTypeForm)
        return (E_FAIL);

    IHTMLElement* pElement = NULL;
    VARIANT       varValue;
    VariantInit(&varValue);

    V_VT(&varValue) = VT_BSTR;
    *pbIsQuickFinish = FALSE;

    if (SUCCEEDED(m_pPageTypeForm->QueryInterface(IID_IHTMLElement, (void**)&pElement)))
    {
        if (SUCCEEDED(pElement->getAttribute(L"QUICKFINISH", FALSE, &varValue)))
        {
            if (VT_NULL != varValue.vt)
            {
                if(lstrcmpi(varValue.bstrVal, L"TRUE") == 0)
                    *pbIsQuickFinish = TRUE;
            }
        }
        pElement->Release();
    }
    return S_OK;
}

HRESULT CObShellMainPane::get_PageType(LPDWORD pdwPageType)
{
    BSTR    bstrType;
    HRESULT hr;

    if (!m_pPageTypeForm)
        return (E_FAIL);

    *pdwPageType = PAGETYPE_UNDEFINED;

    // Get the Action for the PageType Form
    hr = m_pPageTypeForm->get_action(&bstrType);
    if (SUCCEEDED(hr))
    {
        // See what kind it is
        if (lstrcmpi(bstrType, cszPageTypeTERMS) == 0)
            *pdwPageType = PAGETYPE_ISP_TOS;
        else if (lstrcmpi(bstrType, cszPageTypeCUSTOMFINISH) == 0)
            *pdwPageType = PAGETYPE_ISP_CUSTOMFINISH;
        else if (lstrcmpi(bstrType, cszPageTypeFINISH) == 0)
            *pdwPageType = PAGETYPE_ISP_FINISH;
        else if (lstrcmpi(bstrType, cszPageTypeNORMAL) == 0)
            *pdwPageType = PAGETYPE_ISP_NORMAL;
        else
            *pdwPageType = PAGETYPE_UNDEFINED;

        SysFreeString(bstrType);
    }

    return (hr);
}

HRESULT CObShellMainPane::get_PageFlag(LPDWORD pdwPageFlag)
{
    BSTR    bstrFlag;
    HRESULT hr;

    *pdwPageFlag = 0;

    if (!m_pPageFlagForm)
        return (E_FAIL);

    // Get the Action for the PageFlag Form
    hr = m_pPageFlagForm->get_action(&bstrFlag);
    if (SUCCEEDED(hr))
    {
        // See what kind it is
        *pdwPageFlag = _wtol(bstrFlag);

        SysFreeString(bstrFlag);
    }

    return S_OK;
}

HRESULT CObShellMainPane::get_PageID(BSTR    *pbstrPageID)
{
    HRESULT hr;

    if (!m_pPageIDForm)
        return (E_FAIL);

    if (!pbstrPageID)
        return (E_FAIL);

    // Get the Action for the PageType Form
    hr = m_pPageIDForm->get_action(pbstrPageID);

    return (hr);
}

HRESULT CObShellMainPane::getQueryString
(
    IHTMLFormElement    *pForm,
    LPWSTR               lpszQuery
)
{
    HRESULT hr;
    long    lFormLength;

    if (SUCCEEDED(pForm->get_length(&lFormLength)))
    {
        for (int i = 0; i < lFormLength; i++)
        {
            VARIANT     vIndex;
            vIndex.vt = VT_UINT;
            vIndex.lVal = i;
            VARIANT     var2 = { 0 };
            LPDISPATCH  pDisp;

            if (SUCCEEDED(hr = pForm->item( vIndex, var2, &pDisp )))
            {
                // See if the Item is a Input button
                IHTMLButtonElement* pButton = NULL;
                IHTMLInputButtonElement* pInputButton = NULL;
                IHTMLInputFileElement* pInputFile = NULL;
                IHTMLInputHiddenElement* pInputHidden = NULL;
                IHTMLInputTextElement* pInputText = NULL;
                IHTMLSelectElement* pSelect = NULL;
                IHTMLTextAreaElement* pTextArea = NULL;
                IHTMLOptionButtonElement* pOptionButton = NULL;

                // First check to see if this is an OptionButton.
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLOptionButtonElement, (LPVOID*)&pOptionButton )))
                {
                    BSTR    bstrType = NULL;

                    // See if it is a Radio or a CheckBox
                    if (SUCCEEDED(pOptionButton->get_type(&bstrType)))
                    {
                        if ((lstrcmpi(bstrType, L"radio") == 0) || (lstrcmpi(bstrType, L"checkbox") == 0))
                        {
                            short    bChecked;
                            // See if the button is checked. If it is, then it needs to be
                            // added to the query string
                            if (SUCCEEDED(pOptionButton->get_checked(&bChecked)))
                            {
                                if(bChecked)
                                {
                                    BSTR    bstrName;
                                    BSTR    bstrValue;


                                    if ( SUCCEEDED(pOptionButton->get_name(&bstrName)) &&
                                         SUCCEEDED(pOptionButton->get_value(&bstrValue)) )
                                    {
                                        if (bstrValue)
                                        {
                                            size_t size = BYTES_REQUIRED_BY_SZ(bstrValue);
                                            WCHAR* szVal = (WCHAR*)malloc(size * 3);
                                            if (szVal)
                                            {
                                                memcpy(szVal, bstrValue, size);
                                                URLEncode(szVal, size * 3);
                                                URLAppendQueryPair(lpszQuery, bstrName, szVal);
                                                // Cleanup
                                                free(szVal);
                                            }
                                            SysFreeString(bstrName);
                                            SysFreeString(bstrValue);
                                        }
                                    }

                                }
                            }
                        }
                        SysFreeString(bstrType);

                    }

                    // Release the interface
                    pOptionButton->Release();
                    continue;
                }

                // For the rest we need to form Name=Value pairs
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLButtonElement, (LPVOID*)&pButton )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;

                    if (SUCCEEDED(pButton->get_name(&bstrName)) &&
                        SUCCEEDED(pButton->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = BYTES_REQUIRED_BY_SZ(bstrValue);
                            WCHAR* szVal = (WCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, bstrValue, size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, bstrName, szVal);
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }

                    // Release the interface pointer
                    pButton->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputFileElement, (LPVOID*)&pInputFile )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;

                    if (SUCCEEDED(pInputFile->get_name(&bstrName)) &&
                        SUCCEEDED(pInputFile->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = BYTES_REQUIRED_BY_SZ(bstrValue);
                            WCHAR* szVal = (WCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, bstrValue, size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, bstrName, szVal);
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }

                    // Release the interface pointer
                    pInputFile->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputHiddenElement, (LPVOID*)&pInputHidden )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;

                    if (SUCCEEDED(pInputHidden->get_name(&bstrName)) &&
                        SUCCEEDED(pInputHidden->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = BYTES_REQUIRED_BY_SZ(bstrValue);
                            WCHAR* szVal = (WCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, bstrValue, size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, bstrName, szVal);
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }

                    // Release the interface pointer
                    pInputHidden->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputTextElement, (LPVOID*)&pInputText )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;

                    if (SUCCEEDED(pInputText->get_name(&bstrName)) &&
                        SUCCEEDED(pInputText->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = BYTES_REQUIRED_BY_SZ(bstrValue);
                            WCHAR* szVal = (WCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, bstrValue, size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, bstrName, szVal);
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }

                    // Release the interface pointer
                    pInputText->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLSelectElement, (LPVOID*)&pSelect )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;

                    if (SUCCEEDED(pSelect->get_name(&bstrName)) &&
                        SUCCEEDED(pSelect->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = BYTES_REQUIRED_BY_SZ(bstrValue);
                            WCHAR* szVal= (WCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, bstrValue, size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, bstrName, szVal);
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }

                    // Release the interface pointer
                    pSelect->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLTextAreaElement, (LPVOID*)&pTextArea )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;

                    if (SUCCEEDED(pTextArea->get_name(&bstrName)) &&
                        SUCCEEDED(pTextArea->get_value(&bstrValue)) )
                    {
                         if (bstrValue)
                        {
                            size_t size = BYTES_REQUIRED_BY_SZ(bstrValue);
                            WCHAR* szVal= (WCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, bstrValue, size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, bstrName, szVal);
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }

                    // Release the interface pointer
                    pTextArea->Release();
                }
                pDisp->Release();
            }
        }
    }

    // Null out the last Ampersand, since we don't know when we added the last pair, so we got
    // a trailing ampersand
    lpszQuery[lstrlen(lpszQuery)-1] = L'\0';

    return S_OK;
}


// For the URL for the next page
HRESULT CObShellMainPane::get_URL
(
    BOOL    bForward,
    BSTR    *pbstrReturnURL
)
{
    HRESULT             hr      = S_OK;
    BSTR                bstrURL;
    WCHAR               szQuery[INTERNET_MAX_URL_LENGTH];
    WCHAR               szURL[INTERNET_MAX_URL_LENGTH];
    IHTMLFormElement    * pForm =  bForward ? get_pNextForm() : get_pBackForm();

    if (!pForm || !pbstrReturnURL)
        return (E_FAIL);


    // Get the Action for the Next Form
    hr = pForm->get_action(&bstrURL);
    if (SUCCEEDED(hr))
    {
        memset(szQuery, 0, sizeof(szQuery));
        lstrcpy(szQuery, cszQuestion);

        // Get the Query String
        if (SUCCEEDED(getQueryString(pForm, szQuery)))
        {
            // Catenate the two together into the dest buffer
            lstrcpy(szURL, bstrURL);
            lstrcat(szURL, szQuery);
        }

        SysFreeString(bstrURL);
        *pbstrReturnURL = SysAllocString(szURL);
    }

    return hr;
}


HRESULT CObShellMainPane::Walk(BOOL* pbRet)
{
    IHTMLElement*           pElement    = NULL;
    IHTMLImgElement*        pImage      = NULL;
    HRESULT                 hr          = E_FAIL;
    IDispatch*              pDisp       = NULL;
    IHTMLDocument2*         pDoc        = NULL;
    IHTMLDocument2*         pParentDoc  = NULL;
    IHTMLFramesCollection2* pFrColl     = NULL;
    IHTMLWindow2*           pParentWin  = NULL;
    IHTMLDocument2*         pFrDoc      = NULL;
    IHTMLWindow2*           pFrWin      = NULL;
    IHTMLElementCollection* pColl       = NULL;

    if (m_pPageIDForm)
    {
        m_pPageIDForm->Release();
        m_pPageIDForm = NULL;
    }
    if (m_pBackForm)
    {
        m_pBackForm->Release();
        m_pBackForm = NULL;
    }
    if (m_pPageTypeForm)
    {
        m_pPageTypeForm->Release();
        m_pPageTypeForm = NULL;
    }
    if (m_pNextForm)
    {
        m_pNextForm->Release();
        m_pNextForm = NULL;
    }

    if (m_pObWebBrowser)
    {
        if(SUCCEEDED(m_pObWebBrowser->get_WebBrowserDoc(&pDisp)) && pDisp)
        {
            if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
            {

                if(SUCCEEDED(pDoc->get_parentWindow(&pParentWin)) && pParentWin)
                {
                    if(SUCCEEDED(pParentWin->get_document(&pParentDoc))&& pParentDoc)
                    {

                        if(SUCCEEDED(pParentDoc->get_frames(&pFrColl)) && pFrColl)
                        {
                            VARIANT     varRet;
                            VARIANTARG  varg;
                            VariantInit(&varg);
                            V_VT(&varg) = VT_BSTR;
                            varg.bstrVal= SysAllocString(L"ifrmMainFrame");

                            if(SUCCEEDED(pFrColl->item(&varg, &varRet)) && varRet.pdispVal)
                            {
                                if(SUCCEEDED(varRet.pdispVal->QueryInterface(IID_IHTMLWindow2, (LPVOID*)&pFrWin)) && pFrWin)
                                {
                                    VARIANT varExec;
                                    VariantInit(&varExec);
                                    if(SUCCEEDED(pFrWin->get_document(&pFrDoc)) && pFrDoc)
                                    {
                                        if(SUCCEEDED(pFrDoc->get_all(&pColl)) && pColl)
                                        {

                                            long cElems;

                                            assert(pColl);

                                            // retrieve the count of elements in the collection
                                            if (SUCCEEDED(hr = pColl->get_length( &cElems )))
                                            {
                                                // for each element retrieve properties such as TAGNAME and HREF
                                                for ( int i=0; i<cElems; i++ )
                                                {
                                                    VARIANT     vIndex;
                                                    vIndex.vt   = VT_UINT;
                                                    vIndex.lVal = i;
                                                    VARIANT     var2 = { 0 };
                                                    LPDISPATCH  pDisp;

                                                    if (SUCCEEDED(hr = pColl->item( vIndex, var2, &pDisp )))
                                                    {
                                                        // Look for <FORM> tags
                                                        IHTMLFormElement* pForm = NULL;
                                                        if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLFormElement, (LPVOID*)&pForm )))
                                                        {
                                                            BSTR    bstrName;

                                                            assert(pForm);

                                                            // Get the Name
                                                            hr = pForm->get_name(&bstrName);
                                                            if (SUCCEEDED(hr))
                                                            {
                                                                LPWSTR   lpszName = bstrName;

                                                                // See what kind it is
                                                                if (lstrcmpi(lpszName, cszFormNamePAGEID) == 0)
                                                                {
                                                                    m_pPageIDForm = pForm;
                                                                    m_pPageIDForm->AddRef();
                                                                }
                                                                else if (lstrcmpi(lpszName, cszFormNameBACK) == 0)
                                                                {
                                                                    m_pBackForm = pForm;
                                                                    m_pBackForm->AddRef();
                                                                }
                                                                else if (lstrcmpi(lpszName, cszFormNamePAGETYPE) == 0)
                                                                {
                                                                    m_pPageTypeForm = pForm;
                                                                    m_pPageTypeForm->AddRef();
                                                                }
                                                                else if (lstrcmpi(lpszName, cszFormNameNEXT) == 0)
                                                                {
                                                                    m_pNextForm = pForm;
                                                                    m_pNextForm->AddRef();
                                                                }
                                                                else if (lstrcmpi(lpszName, cszFormNamePAGEFLAG) == 0)
                                                                {
                                                                    m_pPageFlagForm = pForm;
                                                                    m_pPageFlagForm->AddRef();
                                                                }

                                                                SysFreeString(bstrName);
                                                            }
                                                            pForm->Release();
                                                        }
                                                        pDisp->Release();
                                                    } // item
                                                } // for
                                            } // get_length
                                            pColl->Release();
                                            pColl->Release();
                                            pColl = NULL;
                                        } // get_all
                                        pFrDoc->Release();
                                        pFrDoc = NULL;
                                    } // get_document
                                    pFrWin->Release();
                                    pFrWin = NULL;

                                    hr = S_OK;
                                }// QI
                                varRet.pdispVal->Release();
                                varRet.pdispVal = NULL;
                            } //->item
                            pFrColl->Release();
                            pFrColl = NULL;

                        }
                        pParentDoc->Release();
                        pParentDoc = NULL;

                    }
                    pParentWin->Release();
                    pParentWin = NULL;

                }
                pDoc->Release();
                pDoc = NULL;
            }
            pDisp->Release();
            pDisp = NULL;
        }
    }
    return hr;
}

HRESULT CObShellMainPane::SaveISPFile(BSTR bstrSrcFileName, BSTR bstrDestFileName)
{
    WCHAR         szNewFileBuff [MAX_PATH + 1];
    WCHAR         szWorkingDir  [MAX_PATH + 1];
    WCHAR         szDesktopPath [MAX_PATH + 1];
    WCHAR         szLocalFile   [MAX_PATH + 1];
    WCHAR         szISPName     [1024];
    WCHAR         szFmt         [1024];
    WCHAR         szNumber      [1024];
    WCHAR         *args         [2];
    LPWSTR        pszInvalideChars             = L"\\/:*?\"<>|";
    LPVOID        pszIntro                     = NULL;
    LPITEMIDLIST  lpItemDList                  = NULL;
    HRESULT       hr                           = E_FAIL; //don't assume success
    IMalloc      *pMalloc                      = NULL;
    BOOL          ret                          = FALSE;


    GetCurrentDirectory(MAX_PATH, szWorkingDir);

    hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP,&lpItemDList);

    //Get the "DESKTOP" dir

    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDList(lpItemDList, szDesktopPath);

        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }


    // Replace invalid file name char in ISP name with underscore
    lstrcpy(szISPName, bstrDestFileName);
    for( int i = 0; szISPName[i]; i++ )
    {
        if(wcschr(pszInvalideChars, szISPName[i]))
        {
            szISPName[i] = L'_';
        }
    }

    // Load the default file name
    args[0] = (LPWSTR) szISPName;
    args[1] = NULL;
    LoadString(m_hInstance, 0, szFmt, MAX_CHARS_IN_BUFFER(szFmt));

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  szFmt,
                  0,
                  0,
                  (LPWSTR)&pszIntro,
                  0,
                  (va_list*)args);

    lstrcat(szDesktopPath, L"\\");
    wsprintf(szLocalFile, L"\"%s\"", (LPWSTR)pszIntro);
    lstrcpy(szNewFileBuff, szDesktopPath);
    lstrcat(szNewFileBuff, (LPWSTR)pszIntro);
    LocalFree(pszIntro);

    // Check if file already exists
    if (0xFFFFFFFF != GetFileAttributes(szNewFileBuff))
    {
        // If file exists, create new filename with paranthesis
        int     nCurr = 1;
        do
        {
            wsprintf(szNumber, L"%d", nCurr++);
            args[1] = (LPWSTR) szNumber;

            LoadString(m_hInstance, 0, szFmt, MAX_CHARS_IN_BUFFER(szFmt));

            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szFmt,
                          0,
                          0,
                          (LPWSTR)&pszIntro,
                          0,
                          (va_list*)args);
            lstrcpy(szNewFileBuff, szDesktopPath);
            wsprintf(szLocalFile, L"\"%s\"", (LPWSTR)pszIntro);
            lstrcat(szNewFileBuff, (LPWSTR)pszIntro);
            LocalFree(pszIntro);
        } while ((0xFFFFFFFF != GetFileAttributes(szNewFileBuff)) && (nCurr <= 100));

    }

    // Copy the file to permanent location
    HANDLE hFile = CreateFile(szNewFileBuff, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        BSTR bstrText           = NULL;
        DWORD dwByte            = 0;
        if (SUCCEEDED(ExtractUnHiddenText(&bstrText)) && bstrText)
        {
            ret = WriteFile(hFile, bstrText, BYTES_REQUIRED_BY_SZ(bstrText), &dwByte, NULL);
            SysFreeString(bstrText);
        }
        CloseHandle(hFile);

    }
    return S_OK;
}

HRESULT CObShellMainPane::SetStatusLogo(BSTR bstrPath)
{
    return S_OK;
}

HRESULT CObShellMainPane::GetNumberOfStatusItems(int* piTotal)
{
    *piTotal = m_cStatusItems;

    return S_OK;
}

///////////////////////////////////////////////////////////
//  ListenToMainPaneEvents
//
HRESULT CObShellMainPane::ListenToMainPaneEvents(IUnknown* pUnk)
{
    if (FAILED(pUnk->QueryInterface(IID_IDispatch, (LPVOID*)&m_pDispEvent)) || !m_pDispEvent)
        return E_UNEXPECTED;
    return S_OK;
}

///////////////////////////////////////////////////////////
//  SetExternalInterface
//
HRESULT CObShellMainPane::SetExternalInterface(IUnknown* pUnk)
{
    if(m_pObWebBrowser)
       m_pObWebBrowser->SetExternalInterface(pUnk);
    return S_OK;
}

///////////////////////////////////////////////////////////
//  FireObShellDocumentComplete
//
HRESULT CObShellMainPane::FireObShellDocumentComplete()
{
    VARIANTARG varg;
    VariantInit(&varg);
    varg.vt  = VT_I4;
    varg.lVal= S_OK;
    DISPPARAMS disp = { &varg, NULL, 1, 0 };
    if (m_pDispEvent)
        m_pDispEvent->Invoke(DISPID_MAINPANE_NAVCOMPLETE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);

    return S_OK;
}

HRESULT CObShellMainPane::OnDialing(UINT uiType)
{
    VARIANT varRet;

    if (USES_EX(uiType))
        ExecScriptFn(SysAllocString(SCRIPTFN_ONDIALINGEX), &varRet);
    else
        ExecScriptFn(SysAllocString(SCRIPTFN_ONDIALING), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnConnecting(UINT uiType)
{
    VARIANT varRet;

    if (USES_EX(uiType))
        ExecScriptFn(SysAllocString(SCRIPTFN_ONCONNECTINGEX), &varRet);
    else
        ExecScriptFn(SysAllocString(SCRIPTFN_ONCONNECTING), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnDownloading(UINT uiType)
{
    VARIANT varRet;

    if (USES_EX(uiType))
        ExecScriptFn(SysAllocString(SCRIPTFN_ONDOWNLOADINGEX), &varRet);
    else
        ExecScriptFn(SysAllocString(SCRIPTFN_ONDOWNLOADING), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnConnected(UINT uiType)
{
    VARIANT varRet;

    if (USES_EX(uiType))
        ExecScriptFn(SysAllocString(SCRIPTFN_ONCONNECTEDEX), &varRet);
    else
        ExecScriptFn(SysAllocString(SCRIPTFN_ONCONNECTED), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnDisconnect(UINT uiType)
{
    VARIANT varRet;

    if (USES_EX(uiType))
        ExecScriptFn(SysAllocString(SCRIPTFN_ONDISCONNECTEX), &varRet);
    else
        ExecScriptFn(SysAllocString(SCRIPTFN_ONDISCONNECT), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnServerError(UINT uiType, UINT uiErrorCode)
{
    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";

    if (USES_EX(uiType))
        wsprintf(szScriptFn, SCRIPTFN_ONSERVERERROREX ,uiErrorCode);
    else
        wsprintf(szScriptFn, SCRIPTFN_ONSERVERERROR ,uiErrorCode);

    ExecScriptFn(SysAllocString(szScriptFn), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnDialingError(UINT uiType, UINT uiErrorCode)
{
    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";

    if (USES_EX(uiType))
        wsprintf(szScriptFn, SCRIPTFN_ONDIALINGERROREX ,uiErrorCode);
    else
        wsprintf(szScriptFn, SCRIPTFN_ONDIALINGERROR ,uiErrorCode);

    ExecScriptFn(SysAllocString(szScriptFn), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnRefDownloadProgress(UINT uiType, UINT uiPercentDone)
{
    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";

    wsprintf(szScriptFn, SCRIPTFN_ONREFDOWNLOADPROGRESSEX ,uiPercentDone);

    ExecScriptFn(SysAllocString(szScriptFn), &varRet);

    return S_OK;
}

HRESULT CObShellMainPane::OnRefDownloadComplete(UINT uiType, UINT uiErrorCode)
{
    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";

    wsprintf(szScriptFn, SCRIPTFN_ONREFDOWNLOADCOMPLETEEX ,uiErrorCode);

    ExecScriptFn(SysAllocString(szScriptFn), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnISPDownloadComplete(UINT uiType, BSTR bstrURL)
{
    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";
    WCHAR szLocalURL [MAX_PATH] = L"\0";

    ConvertToScript(bstrURL, szLocalURL, MAX_PATH);
    wsprintf(szScriptFn, SCRIPTFN_ONISPDOWNLOADCOMPLETEEX ,szLocalURL);

    ExecScriptFn(SysAllocString(szScriptFn), &varRet);
    return S_OK;
}

HRESULT CObShellMainPane::OnDeviceArrival(UINT uiDeviceType)
{
    USES_CONVERSION;

    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";

    wsprintf(szScriptFn, SCRIPTFN_ONDEVICEARRIVAL ,uiDeviceType);

    ExecScriptFn(SysAllocString(szScriptFn), &varRet);

    return S_OK;
}


HRESULT CObShellMainPane::OnHelp()
{
    USES_CONVERSION;

    VARIANT varRet;

    ExecScriptFn(SysAllocString(SCRIPTFN_ONHELP), &varRet);

    return S_OK;
}

HRESULT CObShellMainPane::OnIcsConnectionStatus(UINT uiType)
{
    USES_CONVERSION;

    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";

    wsprintf(szScriptFn, SCRIPTFN_ONICSCONNECTIONSTATUS, uiType);

    ExecScriptFn(SysAllocString(szScriptFn), &varRet);

    return S_OK;
}

HRESULT CObShellMainPane::ExecScriptFn(BSTR bstrScriptFn, VARIANT* pvarRet)
{
    IDispatch*      pDisp = NULL;
    IHTMLDocument2* pDoc  = NULL;
    IHTMLWindow2*   pWin  = NULL;

    VariantInit(pvarRet);

    if(SUCCEEDED(m_pObWebBrowser->get_WebBrowserDoc(&pDisp)) && pDisp)
    {
        if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
        {
            if(SUCCEEDED(pDoc->get_parentWindow(&pWin)) && pWin)
            {
                pWin->execScript(bstrScriptFn,  NULL, pvarRet);
                pWin->Release();
                pWin = NULL;
            }
            pDoc->Release();
            pDoc = NULL;
        }
        pDisp->Release();
        pDisp = NULL;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
//  DWebBrowserEvents2 / IDispatch implementation
///////////////////////////////////////////////////////////

STDMETHODIMP CObShellMainPane::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CObShellMainPane::GetTypeInfo(UINT, LCID, ITypeInfo** )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CObShellMainPane::GetIDsOfNames
STDMETHODIMP CObShellMainPane::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{
    return DISP_E_UNKNOWNNAME;
}

/////////////////////////////////////////////////////////////
// CObShellMainPane::Invoke
HRESULT CObShellMainPane::Invoke
(
    DISPID       dispidMember,
    REFIID       riid,
    LCID         lcid,
    WORD         wFlags,
    DISPPARAMS*  pdispparams,
    VARIANT*     pvarResult,
    EXCEPINFO*   pexcepinfo,
    UINT*        puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_DOCUMENTCOMPLETE:
        {
            FireObShellDocumentComplete();
            break;
        }
        case DISPID_NAVIGATECOMPLETE:
        {
            break;
        }
        case DISPID_BEFORENAVIGATE2:
        {
            WCHAR  szStatus [INTERNET_MAX_URL_LENGTH*2] = L"\0";
            WCHAR* pszError                      = NULL;

            if(pdispparams                      &&
               &(pdispparams[0].rgvarg[5])      &&
               pdispparams[0].rgvarg[5].pvarVal &&
               pdispparams[0].rgvarg[5].pvarVal->bstrVal)
            {
                // BUGBUG: WE should really check the size of URL before copy
                // Bug This url is from IE, we should be ok here
                lstrcpy(szStatus, pdispparams[0].rgvarg[5].pvarVal->bstrVal);

                //We make an assumption here that if we are going to shdocvw for our html something is fishy
                if((pszError = StrStrI(szStatus, L"SHDOCLC.DLL")) && pszError)
                {
                                       if(&(pdispparams[0].rgvarg[0]) && pdispparams[0].rgvarg[0].pboolVal)
                        *pdispparams[0].rgvarg[0].pboolVal = TRUE;

                    ProcessServerError(pszError);
                }
            }
            break;
        }
        case DISPID_STATUSTEXTCHANGE:
        {
            WCHAR  szStatus [INTERNET_MAX_URL_LENGTH*2] = L"\0";
            WCHAR* pszError                      = NULL;

            if(pdispparams                      &&
               &(pdispparams[0].rgvarg[0])      &&
               pdispparams[0].rgvarg[0].bstrVal)
            {
                lstrcpy(szStatus, pdispparams[0].rgvarg[0].bstrVal);

                //We make an assumption here that if we are going to shdocvw for our html something is fishy
                if((pszError = StrStrI(szStatus, L"SHDOCLC.DLL")) && (StrCmpNI(szStatus, L"Start", 5) == 0) && pszError) //BUGBUG: is Start localized?
                {
                    m_pObWebBrowser->Stop();

                    ProcessServerError(pszError);
                }
            }
            break;
        }

        default:
        {
           hr = DISP_E_MEMBERNOTFOUND;
           break;
        }
    }
    return hr;
}

void CObShellMainPane::ProcessServerError(WCHAR* pszError)
{
    LPARAM lParam = NULL;

    pszError += lstrlen(L"SHDOCLC.DLL/");

    if(StrCmpNI(pszError, L"DNSERROR", 8) == 0)
    {
        lParam = ERR_SERVER_DNS;
    }
    else if(StrCmpNI(pszError, L"SYNTAX", 6) == 0)
    {
        lParam = ERR_SERVER_SYNTAX;
    }
    else if(StrCmpNI(pszError, L"SERVBUSY", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_408;
    }
    else if(StrCmpNI(pszError, L"HTTP_GEN", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_405;
    }
    else if(StrCmpNI(pszError, L"HTTP_400", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_400;
    }
    else if(StrCmpNI(pszError, L"HTTP_403", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_403;
    }
    else if(StrCmpNI(pszError, L"HTTP_404", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_404;
    }
    else if(StrCmpNI(pszError, L"HTTP_406", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_406;
    }
    else if(StrCmpNI(pszError, L"HTTP_410", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_410;
    }
    else if(StrCmpNI(pszError, L"HTTP_500", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_500;
    }
    else if(StrCmpNI(pszError, L"HTTP_501", 8) == 0)
    {
        lParam = ERR_SERVER_HTTP_501;
    }
    SendMessage(m_hwndParent, WM_OBCOMM_ONSERVERERROR, (WPARAM)0, (LPARAM)lParam);
}

LRESULT WINAPI MainPaneWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_CLOSE:
            DestroyWindow(hwnd);
            return TRUE;

        case WM_DESTROY:
            PostQuitMessage(0);
            return TRUE;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobshel\resource.h ===
#define IDS_ISPINFO_FILENAME          685
#define IDS_ISPINFO_FILENAME_COPY     686
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobmain\userinfo.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  USERINFO.H - Header for the implementation of CUserInfo
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//

#ifndef _USERINFO_H_
#define _USERINFO_H_

#include <windows.h>
#include <assert.h>
#include <oleauto.h>
#include <lmcons.h>
#include "util.h"

typedef struct tag_REGDATAELEMENT
{
    LPCWSTR         lpQueryElementName;             // Static name to put in query string
    LPWSTR          lpQueryElementValue;            // data for element
    DWORD           dwValidateFlag;                 // validation bit flag for this element
}REGDATAELEMENT, *LPREGDATAELEMENT;

// "IdentityXXX" where XXX is 3 digit integer
const USHORT IDENTITY_REGVALUE_LEN_MAX = 12;

// Maximum length for data in an identity
//
const USHORT IDENTITY_CCH_MAX = UNLEN;

typedef struct tag_IDENTITYELEMENT
{
    WCHAR           rgchRegValue[IDENTITY_REGVALUE_LEN_MAX];
    WCHAR           rgchIdentity[IDENTITY_CCH_MAX + 1];
} IDENTITYELEMENT;

class CUserInfo : public IDispatch
{
public:
    const static USHORT IDENTITIES_MAX = 6;
    const static USHORT RESERVED_IDENTITIES_MAX = 2;
    const static int    RESERVED_IDENTITIES_IDS[RESERVED_IDENTITIES_MAX];
    
private:
    HINSTANCE m_hInstance;
    ULONG  m_cRef;
    DWORD  m_dwCountryCode;
    WCHAR  m_szUserInfoINIFile [MAX_PATH];

    // BUGBUG: Do all these buffers really need to be MAX_PATH characters??
    // Registration data
    WCHAR  m_szFirstName       [MAX_PATH];
    WCHAR  m_szMiddleInitial   [MAX_PATH];
    WCHAR  m_szLastName        [MAX_PATH];
    WCHAR  m_szFuriganaName    [MAX_PATH];
    WCHAR  m_szCompanyName     [MAX_PATH];
    WCHAR  m_szAddress1        [MAX_PATH*2];
    WCHAR  m_szAddress2        [MAX_PATH*2];
    WCHAR  m_szCity            [MAX_PATH];
    WCHAR  m_szState           [MAX_PATH];
    WCHAR  m_szZip             [MAX_PATH];
    WCHAR  m_szCountry         [MAX_PATH];
    WCHAR  m_szPrimaryEmail    [MAX_PATH];
    WCHAR  m_szSecondaryEmail  [MAX_PATH];
    WCHAR  m_szAreaCode        [MAX_PATH];
    WCHAR  m_szPhoneNumber     [MAX_PATH];
    VARIANT_BOOL     m_fMSUpdate;
    VARIANT_BOOL     m_fMSOffer;
    VARIANT_BOOL     m_fOtherOffer;
    DWORD            m_dwCountryID;
    LPREGDATAELEMENT m_RegDataElements;

    // New user accounts
    WCHAR           m_szOwnerName[MAX_PATH];
    VARIANT_BOOL    m_fOEMIdentities;
    VARIANT_BOOL    m_fUseIdentities;
    IDENTITYELEMENT m_rgIdentities[IDENTITIES_MAX];
    TCHAR           m_szReservedIdentities[RESERVED_IDENTITIES_MAX][MAX_PATH];
    WCHAR           m_szDefaultNewUser[MAX_PATH];

    //GET functions
    HRESULT get_FuriganaName   (BSTR* pbstrVal);
    HRESULT get_SecondaryEmail (BSTR* pbstrVal);
    HRESULT get_AreaCode       (BSTR* pbstrVal);
    HRESULT get_PhoneNumber    (BSTR* pbstrVal);

    //SET functions
    HRESULT set_FirstName      (WCHAR*  pszVal);
    HRESULT set_MiddleInitial  (WCHAR*  pszVal);
    HRESULT set_LastName       (WCHAR*  pszVal);
    HRESULT set_CompanyName    (WCHAR*  pszVal);
    HRESULT set_Address1       (WCHAR*  pszVal);
    HRESULT set_Address2       (WCHAR*  pszVal);
    HRESULT set_City           (WCHAR*  pszVal);
    HRESULT set_State          (WCHAR*  pszVal);
    HRESULT set_Zip            (WCHAR*  pszVal);
    HRESULT set_Country        (WCHAR*  pszVal);
    HRESULT set_PrimaryEmail   (WCHAR*  pszVal);
    HRESULT set_SecondaryEmail (WCHAR*  pszVal);
    HRESULT set_AreaCode       (WCHAR*  pszVal);
    HRESULT set_PhoneNumber    (WCHAR*  pszVal);
    HRESULT set_FuriganaName   (WCHAR*  pszVal);
    HRESULT set_OwnerName      (WCHAR*  pszVal);
    HRESULT set_Identity       (UINT uiIndex, WCHAR* pszVal);
    HRESULT set_UseIdentities  (VARIANT_BOOL fVal);
    HRESULT set_MSUpdate       (VARIANT_BOOL fVal);
    HRESULT set_MSOffer        (VARIANT_BOOL fVal);
    HRESULT set_OtherOffer     (VARIANT_BOOL fVal);
    HRESULT set_CountryID      (DWORD dwVal);

    // CHECK functions
    HRESULT check_Identity     (UINT uiIndex, VARIANT_BOOL* pfValid);
    HRESULT check_Identity     (WCHAR* pszVal, VARIANT_BOOL* pfValid);
    STDMETHOD(SuggestIdentity0)();

    void ReadUserInfo  (HKEY hKey, WCHAR* pszKey, WCHAR* pszValue, DWORD dwSize);
    void WriteUserInfo (WCHAR* pszBuf, WCHAR* pszKey, WCHAR* pszValue);

    void FixString     (BSTR bstrVal);

public:

     CUserInfo                 (HINSTANCE hInstance);
    ~CUserInfo                 ();

    HRESULT GetQueryString     (BSTR bstrBaseURL, BSTR *lpReturnURL);

    //Public GET functions
    HRESULT get_FirstName      (BSTR* pbstrVal);
    HRESULT get_MiddleInitial  (BSTR* pbstrVal);
    HRESULT get_LastName       (BSTR* pbstrVal);
    HRESULT get_Address1       (BSTR* pbstrVal);
    HRESULT get_Address2       (BSTR* pbstrVal);
    HRESULT get_City           (BSTR* pbstrVal);
    HRESULT get_State          (BSTR* pbstrVal);
    HRESULT get_Zip            (BSTR* pbstrVal);
    HRESULT get_Country        (BSTR* pbstrVal);
    HRESULT get_PrimaryEmail   (BSTR* pbstrVal);
    HRESULT get_CompanyName    (BSTR* pbstrVal);
    HRESULT set_CountryCode    (DWORD dwCountryCd);
    HRESULT get_OwnerName      (BSTR* pbstrVal);
    HRESULT get_Identity       (UINT uiIndex, BSTR* pbstrVal);
    HRESULT get_UseIdentities  (VARIANT_BOOL* pfVal);
    HRESULT get_MSUpdate       (VARIANT_BOOL* pfVal);
    HRESULT get_MSOffer        (VARIANT_BOOL* pfVal);
    HRESULT get_OtherOffer     (VARIANT_BOOL* pfVal);
    HRESULT get_CountryID      (DWORD* pdwVal);
    HRESULT get_OEMIdentities  (VARIANT_BOOL* pfVal){
                                                *pfVal = m_fOEMIdentities;
                                                return S_OK;
                                            }
    HRESULT get_IdentitiesMax  (SHORT* uiMax){
                                                *uiMax = IDENTITIES_MAX;
                                                return S_OK;
                                            }
    HRESULT get_Identities     (PSTRINGLIST* pUserList);
    HRESULT set_DefaultNewUser (WCHAR * pszVal);
    HRESULT get_DefaultNewUser (BSTR* pszVal);
    

    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    //IDispatch Interfaces
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);
 };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobshel\mainpane.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MAINPANE.H - Header for the implementation of CObShellMainPane
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Class which will create a window, attach and instance of ObWebBrowser,
//  and then provide several specialized interfaces to alter the content of the doc 

#ifndef _MAINPANE_H_
#define _MAINPANE_H_

#include <tchar.h>
#include <comdef.h> // for COM interface definitions
#include <exdisp.h>
#include <mshtml.h>
#include <exdispid.h>

#include "cunknown.h"
#include "obshel.h" 
#include "obweb.h"
#include "statuspn.h"

class CObShellMainPane   :  public CUnknown,
                            public IObShellMainPane,
                            public DWebBrowserEvents2
{
    // Declare the delegating IUnknown.
    DECLARE_IUNKNOWN

public: 
    static  HRESULT           CreateInstance         (IUnknown* pOuterUnknown, 
                                                      CUnknown** ppNewComponent);
    // IObShellMainPane Members
    virtual HRESULT __stdcall CreateMainPane         (HANDLE_PTR hInstance, HWND hwndParent, RECT* prectWindowSize, BSTR bstrStartPage);
    virtual HRESULT __stdcall PreTranslateMessage    (LPMSG lpMsg);
    virtual HRESULT __stdcall Navigate               (WCHAR* pszUrl);
    virtual HRESULT __stdcall ListenToMainPaneEvents (IUnknown* pUnk);
    virtual HRESULT __stdcall SetExternalInterface   (IUnknown* pUnk);
    virtual HRESULT __stdcall ExecScriptFn           (BSTR bstrScriptFn, VARIANT* pvarRet);
    virtual HRESULT __stdcall SetAppMode             (DWORD dwAppMode);

    virtual HRESULT __stdcall AddStatusItem          (BSTR bstrText,int iIndex);
    virtual HRESULT __stdcall RemoveStatusItem       (int  iIndex);
    virtual HRESULT __stdcall SelectStatusItem       (int  iIndex);   
    virtual HRESULT __stdcall SetStatusLogo          (BSTR bstrPath);
    virtual HRESULT __stdcall GetNumberOfStatusItems (int* piTotal);
 
    virtual HRESULT __stdcall Walk                   (BOOL* pbRet);
    virtual HRESULT __stdcall ExtractUnHiddenText    (BSTR* pbstrText);
    virtual HRESULT __stdcall get_PageType           (LPDWORD pdwPageType);
    virtual HRESULT __stdcall get_IsQuickFinish      (BOOL* pbIsQuickFinish);
    virtual HRESULT __stdcall get_PageFlag           (LPDWORD pdwPageFlag);
    virtual HRESULT __stdcall get_PageID             (BSTR* pbstrPageID);
    virtual HRESULT __stdcall get_URL                (BOOL bForward, 
                                                      BSTR *pbstrReturnURL);

    virtual HRESULT __stdcall OnDialingError         (UINT uiType, UINT uiErrorCode);
    virtual HRESULT __stdcall OnServerError          (UINT uiType, UINT uiErrorCode);
    virtual HRESULT __stdcall OnDialing              (UINT uiType);
    virtual HRESULT __stdcall OnConnecting           (UINT uiType);
    virtual HRESULT __stdcall OnDownloading          (UINT uiType);
    virtual HRESULT __stdcall OnConnected            (UINT uiType);
    virtual HRESULT __stdcall OnDisconnect           (UINT uiType);
    virtual HRESULT __stdcall OnDeviceArrival        (UINT uiDeviceType);
    virtual HRESULT __stdcall OnHelp                 ();

    virtual HRESULT __stdcall OnIcsConnectionStatus  (UINT uiType);
    // Migration functons
    virtual HRESULT __stdcall OnRefDownloadProgress  (UINT uiType, UINT uiPercentDone);
    virtual HRESULT __stdcall OnISPDownloadComplete  (UINT uiType, BSTR bstrURL);
    virtual HRESULT __stdcall OnRefDownloadComplete  (UINT uiType, UINT uiErrorCode);

    virtual HRESULT __stdcall MainPaneShowWindow     ();
    virtual HRESULT __stdcall DestroyMainPane        ();
    virtual HRESULT __stdcall SaveISPFile            (BSTR bstrSrcFileName, 
                                                      BSTR bstrDestFileName);
    STDMETHOD (PlayBackgroundMusic)()                { return m_pObWebBrowser ? m_pObWebBrowser->PlayBackgroundMusic() : S_OK; }
    STDMETHOD (StopBackgroundMusic)()                { return m_pObWebBrowser ? m_pObWebBrowser->StopBackgroundMusic() : S_OK; }
    STDMETHOD (UnhookScriptErrorHandler)()           { return m_pObWebBrowser->UnhookScriptErrorHandler(); }
    // DWebBrowserEvents2        
    STDMETHOD (GetTypeInfoCount)                     (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)                          (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)                        (REFIID, OLECHAR**, UINT, 
                                                      LCID, DISPID* );
    STDMETHOD (Invoke)                               (DISPID dispidMember, 
                                                      REFIID riid, 
                                                      LCID lcid, 
                                                      WORD wFlags, 
                                                      DISPPARAMS* pdispparams, 
                                                      VARIANT* pvarResult, 
                                                      EXCEPINFO* pexcepinfo, 
                                                      UINT* puArgErr);
    IHTMLFormElement* get_pNextForm() { return m_pNextForm; }
    IHTMLFormElement* get_pBackForm() { return m_pBackForm; }

private:
    HWND                m_hMainWnd;
    HWND                m_hwndParent;
    IDispatch*          m_pDispEvent;
    IObWebBrowser*      m_pObWebBrowser;
    BSTR                m_bstrBaseUrl;
    int                 m_cStatusItems;
    DWORD               m_dwAppMode;
    HINSTANCE           m_hInstance;
    CIFrmStatusPane*    m_pIFrmStatPn;
    IHTMLFormElement*   m_pPageIDForm;
    IHTMLFormElement*   m_pBackForm;
    IHTMLFormElement*   m_pPageTypeForm;
    IHTMLFormElement*   m_pNextForm;
    IHTMLFormElement*   m_pPageFlagForm;

    // IUnknown
    virtual HRESULT __stdcall NondelegatingQueryInterface(const IID& iid, void** ppv);
    
            void    ProcessServerError          (WCHAR* pszError);
            HRESULT FireObShellDocumentComplete ();
                    CObShellMainPane            (IUnknown* pOuterUnknown);
    virtual        ~CObShellMainPane            ();
    virtual void    FinalRelease                (); // Notify derived classes that we are releasing
    HRESULT getQueryString                      (IHTMLFormElement *pForm,
                                                 LPWSTR           lpszQuery);  

};

LRESULT WINAPI MainPaneWndProc                  (HWND hwnd, UINT msg, 
                                                 WPARAM wParam, LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobshel\statuspn.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  STATUSPN.CPP - Implementation of CIFrmStatusPane
//
//  HISTORY:
//  
//  9/11/99 vyung Created.
//  
//  Class which will handle the creation of an Iframe which is hosted in the mainpane.

#ifndef _STATUSPN_H_
#define _STATUSPN_H_

#include <tchar.h>
#include <comdef.h> // for COM interface definitions
#include <exdisp.h>
#include <mshtml.h>
#include <exdispid.h>

#include "cunknown.h"
#include "obshel.h" 
#include "obweb.h"

class CIFrmStatusPane
{
public: 
    CIFrmStatusPane            ();
    ~CIFrmStatusPane           ();

    // CIFrmStatusPane Members
    virtual HRESULT  InitStatusPane          (IObWebBrowser* pObWebBrowser);
    virtual HRESULT  AddItem                  (BSTR bstrText, int iIndex);
    virtual HRESULT  SelectItem               (int iIndex);
    virtual HRESULT SetImageSrc(WCHAR* szID, BSTR bstrPath);
    virtual HRESULT ExecScriptFn(BSTR bstrScriptFn, VARIANT* pvarRet);
    
    
private:
    HWND             m_hStatusWnd;
    HWND             m_hwndParent;
    IDispatch*       m_pDispEvent;
    IObWebBrowser*   m_pObWebBrowser;
    int              m_iCurrentSelection;
    int              m_iTotalItems;
    

    HRESULT GetElement                    (WCHAR* szHTMLId, IHTMLElement** lpElem);
    HRESULT GetFrame                      (IHTMLWindow2**            pFrWin);
    HRESULT GetElementFromCollection      (IHTMLElementCollection* pColl, WCHAR* szHTMLId, IHTMLElement** lpElem);  
    HRESULT SetSelectionAttributes        (int iIndex, BOOL bActive);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobshel\server.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  SERVER.CPP - component server for MSObWeb
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// The FactoryDataArray contains the components which 
// can be served.

#include "cunknown.h"
#include "cfactory.h"
#include "mainpane.h"

//MIDL
#include "obshel.h"

//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, pointer to create function, and the name
// of the component to place in the registry.
//

CFactoryData g_FactoryDataArray[] =
{
   {&CLSID_ObShellMainPane,  
        CObShellMainPane::CreateInstance, 
        L"ObShellMainPane Component",        // Friendly Name
        L"ObShellMainPane.1",                // ProgID
        L"ObShellMainPane",                  // Version Independent ProgID
        NULL,                               // Function to register component categories
        NULL,   0}
};
int g_cFactoryDataEntries = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\iocsite.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  IOCSITE.H - Implements IOleClientSite for the WebOC
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.

#ifndef _IOCSITE_H_
#define _IOCSITE_H_

#include <objbase.h>
#include <oleidl.h>

class COleSite;

interface COleClientSite : public IOleClientSite
{
    COleClientSite (COleSite* pSite);
   ~COleClientSite ();

    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    // *** IOleClientSite methods ***
    STDMETHODIMP SaveObject             ();
    STDMETHODIMP GetMoniker             (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppmk);
    STDMETHODIMP GetContainer           (LPOLECONTAINER* ppContainer);
    STDMETHODIMP ShowObject             ();
    STDMETHODIMP OnShowWindow           (BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout ();

private:
    COleSite* m_pOleSite;
    int       m_nCount;
};
#endif //_IOCSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobshel\statuspn.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  STATUSPN.CPP - Implementation of CIFrmStatusPane
//
//  HISTORY:
//
//  9/11/99 vyung Created.
//
//  Class which will handle the creation of an Iframe which is hosted in the mainpane.
//

#include <assert.h>

#include "STATUSPN.h"
#include "appdefs.h"
#include "dispids.h"
#include <shlwapi.h>

#define IMG_ITEM                        L"imgStatus%s"  
#define IMG_ACTIVE                      L"active.gif" 
#define IMG_INACTIVE                    L"inactive.gif" 
#define IMG_ACTIVE_TOP                  L"act_top.gif" 
#define IMG_INACTIVE_TOP                L"inact_top.gif" 

//Statuspane script functions
#define SCRIPTFN_ADDSTATUSITEM          L"AddStatusItem(\"%s\", %i)"
#define SCRIPTFN_REDRAWFORNEWCURITEM    L"RedrawForNewCurrentItem(%i)"

///////////////////////////////////////////////////////////
//
// Creation function used by CIFrmStatusPane.
//
CIFrmStatusPane::CIFrmStatusPane()
: m_hStatusWnd      (NULL),
  m_pObWebBrowser   (NULL),
  m_pDispEvent      (NULL)
{
    m_iCurrentSelection = 0;
    m_iTotalItems       = 0;
}

///////////////////////////////////////////////////////////
//  ~CIFrmStatusPane
//
CIFrmStatusPane::~CIFrmStatusPane()
{
}

///////////////////////////////////////////////////////////
//  InitStatusPane
//
HRESULT CIFrmStatusPane::InitStatusPane(IObWebBrowser* pObWebBrowser)
{
    HRESULT                  hr             = E_FAIL;

    if (pObWebBrowser)
    {
        m_pObWebBrowser = pObWebBrowser;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
//  GetFrame
//
HRESULT CIFrmStatusPane::GetFrame(IHTMLWindow2** pFrWin)
{
    HRESULT                  hr             = E_FAIL;

    IDispatch*               pDisp          = NULL;
    IHTMLDocument2*          pDoc           = NULL;

    IHTMLDocument2*          pParentDoc     = NULL;
    IHTMLFramesCollection2*  pFrColl        = NULL;
    IHTMLWindow2*            pParentWin     = NULL;


    if (m_pObWebBrowser)
    {
        if(SUCCEEDED(m_pObWebBrowser->get_WebBrowserDoc(&pDisp)) && pDisp)
        {
            if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
            {

                if(SUCCEEDED(pDoc->get_parentWindow(&pParentWin)) && pParentWin)
                {
                    if(SUCCEEDED(pParentWin->get_document(&pParentDoc))&& pParentDoc)
                    {

                        if(SUCCEEDED(pParentDoc->get_frames(&pFrColl)) && pFrColl)
                        {
                            VARIANT varRet;
                            VARIANTARG varg;
                            VariantInit(&varg);
                            V_VT(&varg)  = VT_BSTR;
                            varg.bstrVal= SysAllocString(IFRMSTATUSPANE);

                            if(SUCCEEDED(pFrColl->item(&varg, &varRet)) && varRet.pdispVal)
                            {
                                if(SUCCEEDED(varRet.pdispVal->QueryInterface(IID_IHTMLWindow2, (void**)pFrWin)) && *pFrWin)
                                {
                                    VARIANT varExec;
                                    VariantInit(&varExec);
                                    hr = S_OK;
                                }
                                varRet.pdispVal->Release();
                                varRet.pdispVal = NULL;
                            }
                            pFrColl->Release();
                            pFrColl = NULL;

                        }
                        pParentDoc->Release();
                        pParentDoc = NULL;

                    }
                    pParentWin->Release();
                    pParentWin = NULL;

                }
                pDoc->Release();
                pDoc = NULL;
            }
            pDisp->Release();
            pDisp = NULL;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////
//  GetElement
//
HRESULT CIFrmStatusPane::GetElement(WCHAR* szHTMLId, IHTMLElement** lpElem)
{
    IHTMLWindow2*            pFrWin         = NULL;
    IHTMLDocument2*          pFrDoc         = NULL;
    IHTMLElementCollection*  pColl          = NULL;
    HRESULT                  hr             = E_FAIL;


    if(SUCCEEDED(GetFrame(&pFrWin)) && pFrWin)
    {
        VARIANT varExec;
        VariantInit(&varExec);
        if(SUCCEEDED(pFrWin->get_document(&pFrDoc)) && pFrDoc)
        {
            if(SUCCEEDED(pFrDoc->get_all(&pColl)) && pColl)
            {
                if (SUCCEEDED(GetElementFromCollection(pColl, szHTMLId, lpElem)) && *lpElem)
                {
                    hr = S_OK;
                }
                pColl->Release();
                pColl = NULL;
            }
            pFrDoc->Release();
            pFrDoc = NULL;
        }
        pFrWin->Release();
        pFrWin = NULL;

    }
    return hr;
}

///////////////////////////////////////////////////////////
//  SetImageSrc
//
HRESULT CIFrmStatusPane::SetImageSrc(WCHAR* szID, BSTR bstrPath)
{
    IHTMLElement*    pElement = NULL;
    IHTMLImgElement* pImage   = NULL;

    if(SUCCEEDED(GetElement(szID, &pElement)) && pElement)
    {
        if(SUCCEEDED(pElement->QueryInterface(IID_IHTMLImgElement, (void**)&pImage)) && pImage)
        {
            pImage->put_src(bstrPath);
            pImage->Release();
            pImage = NULL;
        }

        pElement->Release();
        pElement = NULL;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
//  GetElementFromCollection
//
HRESULT CIFrmStatusPane::GetElementFromCollection(IHTMLElementCollection* pColl, WCHAR* szHTMLId, IHTMLElement** lpElem)
{
    VARIANT varName;
    VARIANT varIdx;

    IDispatch* pDisp = NULL;
    HRESULT    hr    = E_FAIL;

    VariantInit(&varName);
    V_VT(&varName) = VT_BSTR;
    varIdx.vt = VT_UINT;
    varIdx.lVal = 0;

    varName.bstrVal = SysAllocString(szHTMLId);

    if (SUCCEEDED(pColl->item(varName, varIdx, &pDisp)) && pDisp)
    {
        if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLElement, (void**)lpElem)) && *lpElem)
        {
            hr = S_OK;
        }
        pDisp->Release();
    }
    return hr;
}

///////////////////////////////////////////////////////////
//  SetSelectionAttributes
//
HRESULT CIFrmStatusPane::SetSelectionAttributes(int iIndex, BOOL bActive)
{
    WCHAR         szimgStatus  [20]  = L"\0";
    WCHAR         szIndex      [3]   = L"\0";

    _itow(iIndex, szIndex, 10);

    wsprintf(szimgStatus, IMG_ITEM, szIndex);

    if (1 == iIndex)
    {
        if (bActive)
        {
            SetImageSrc(szimgStatus, IMG_ACTIVE_TOP);
        }
        else
        {
            SetImageSrc(szimgStatus, IMG_INACTIVE_TOP);
        }
    }
    else
    {
        if (bActive)
        {
            SetImageSrc(szimgStatus, IMG_ACTIVE);
        }
        else
        {
            SetImageSrc(szimgStatus, IMG_INACTIVE);
        }
    }

    return S_OK;
}

///////////////////////////////////////////////////////////
//  SelectItem
//
HRESULT CIFrmStatusPane::SelectItem(int iIndex)
{
    if ((iIndex <= m_iTotalItems) && (iIndex >= OBSHEL_STATUSPANE_MINITEM))
    {
        if (iIndex > m_iCurrentSelection)
        {
            for (int i = m_iCurrentSelection + 1; i <= iIndex; i++)
            {
                //  To make the status go from Bottom to top use:
                //  SetSelectionAttributes(m_iTotalItems - i + 1, 1);
                //  Status goes from Top to Bottom:
                SetSelectionAttributes(i, 1);
            }
        }
        else if(iIndex < m_iCurrentSelection)
        {
            for (int i = m_iCurrentSelection; i > iIndex; i--)
            {
                //  To make the status go from Bottom to top use:
                //  SetSelectionAttributes(m_iTotalItems - i + 1, 0);
                //  Status goes from Top to Bottom:
                SetSelectionAttributes(i, 0);
            }
        }

        // reset text colors, current item marker ptr.  easier to do this in script.
        VARIANT varRet;
        WCHAR szScriptFn [MAX_PATH] = L"\0";
        wsprintf(szScriptFn, SCRIPTFN_REDRAWFORNEWCURITEM, iIndex);
        BSTR bstrScriptFn = SysAllocString(szScriptFn);
        if (NULL == bstrScriptFn)
        {
            return E_OUTOFMEMORY;
        }
        ExecScriptFn(bstrScriptFn, &varRet);

        m_iCurrentSelection = iIndex;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
//  AddItem
//
HRESULT CIFrmStatusPane::AddItem(BSTR bstrText, int iIndex)
{

    m_iTotalItems++;

    VARIANT varRet;

    WCHAR szScriptFn [MAX_PATH] = L"\0";

    wsprintf(szScriptFn, SCRIPTFN_ADDSTATUSITEM, bstrText, iIndex);

    BSTR bstrScriptFn = SysAllocString(szScriptFn);
    if (NULL == bstrScriptFn)
    {
        return E_OUTOFMEMORY;
    }

    ExecScriptFn(bstrScriptFn, &varRet);

    SysFreeString(bstrScriptFn);

    return S_OK;
}

///////////////////////////////////////////////////////////
//  ExecScriptFn
//
HRESULT CIFrmStatusPane::ExecScriptFn(BSTR bstrScriptFn, VARIANT* pvarRet)
{
    IHTMLWindow2*            pFrWin         = NULL;
    HRESULT                  hr             = E_FAIL;


    if(SUCCEEDED(GetFrame(&pFrWin)) && pFrWin)
    {
        VariantInit(pvarRet);
        hr = pFrWin->execScript(bstrScriptFn,  NULL, pvarRet);

        pFrWin->Release();
        pFrWin = NULL;

    }
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\iocsite.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  IOCSITE.H - Implements IOleClientSite for the WebOC
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.

#include <assert.h>

#include "iocsite.h"
#include "iosite.h"

//**********************************************************************
// COleClientSite::COleClientSite -- Constructor
//**********************************************************************
COleClientSite::COleClientSite(COleSite* pSite) 
{
    m_pOleSite  = pSite;
    m_nCount    = 0;

    AddRef();
}

//**********************************************************************
// COleClientSite::COleClientSite -- Destructor
//**********************************************************************
COleClientSite::~COleClientSite() 
{
    assert(m_nCount == 0);
}

//**********************************************************************
// COleClientSite::QueryInterface
//**********************************************************************
STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // delegate to the container Site
    return m_pOleSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
// COleClientSite::AddRef
//**********************************************************************
STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
    return ++m_nCount;
}

//**********************************************************************
// COleClientSite::Release
//**********************************************************************
STDMETHODIMP_(ULONG) COleClientSite::Release()
{
    --m_nCount;
    if(m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
// COleClientSite::SaveObject -- Not implemented
//**********************************************************************
STDMETHODIMP COleClientSite::SaveObject()
{
    return ResultFromScode(S_OK); 
}

//**********************************************************************
// COleClientSite::GetMoniker -- Not implemented
//**********************************************************************
STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppmk)
{
    // need to null the out pointer
    *ppmk = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
// COleClientSite::GetContainer  -- Not implemented
//**********************************************************************
STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER* ppContainer)
{
    // NULL the out pointer
    *ppContainer = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
// COleClientSite::ShowObject  -- Not implemented
//**********************************************************************
STDMETHODIMP COleClientSite::ShowObject()
{
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleClientSite::OnShowWindow  -- Not implemented
//**********************************************************************
STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleClientSite::RequestNewObjectLayout  -- Not implemented
//**********************************************************************
STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\ioipfram.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  IOIPFRAM.CPP - Implements IOleInPlaceFrame for the WebOC
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.

#include <assert.h>

#include "ioipfram.h"
#include "iosite.h"

//**********************************************************************
// COleInPlaceFrame::COleInPlaceFrame -- Constructor
//**********************************************************************
COleInPlaceFrame::COleInPlaceFrame(COleSite* pSite) 
{
    m_pOleSite = pSite;
    m_nCount   = 0;

    AddRef();
}

//**********************************************************************
// COleInPlaceFrame::COleInPlaceFrame -- Destructor
//**********************************************************************
COleInPlaceFrame::~COleInPlaceFrame() 
{
    assert(m_nCount == 0);
}

//**********************************************************************
// COleInPlaceFrame::QueryInterface
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // delegate to the document Object
    return m_pOleSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
// COleInPlaceFrame::AddRef
//**********************************************************************
STDMETHODIMP_(ULONG) COleInPlaceFrame::AddRef()
{   
    // increment the interface reference count
    return ++m_nCount;
}

//**********************************************************************
// COleInPlaceFrame::Release
//**********************************************************************
STDMETHODIMP_(ULONG) COleInPlaceFrame::Release()
{
    // decrement the interface reference count
    --m_nCount;
    if(m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
// COleInPlaceFrame::GetWindow
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::GetWindow (HWND* lphwnd)
{
    *lphwnd = m_pOleSite->m_hWnd;
 
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::ContextSensitiveHelp
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::ContextSensitiveHelp (BOOL fEnterMode)
{
    //Returning S_OK here prevents the default one from showing
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::GetBorder
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::GetBorder (LPRECT lprectBorder)
{
    RECT rect;

    // get the rect for the entire frame.
    GetClientRect(m_pOleSite->m_hWnd, &rect);

    CopyRect(lprectBorder, &rect);

    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::RequestBorderSpace -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{
    // always approve the request
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::SetBorderSpace -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::SetBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{   
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::SetActiveObject -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::SetActiveObject(LPOLEINPLACEACTIVEOBJECT lpActiveObject, LPCOLESTR lpszObjName)
{
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::InsertMenus -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::SetMenu -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::RemoveMenus -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::RemoveMenus (HMENU hmenuShared)
{
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::SetStatusText -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCOLESTR lpszStatusText)
{
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
// COleInPlaceFrame::EnableModeless -- Not implemented
//**********************************************************************

STDMETHODIMP COleInPlaceFrame::EnableModeless (BOOL fEnable)
{
    return ResultFromScode(S_OK);
}

//**********************************************************************
// COleInPlaceFrame::TranslateAccelerator -- Not implemented
//**********************************************************************
STDMETHODIMP COleInPlaceFrame::TranslateAccelerator (LPMSG lpmsg, WORD wID)
{
    return ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\ioipsite.cpp ===
#include <assert.h>
#include "ioipsite.h"
#include "iosite.h"

COleInPlaceSite::COleInPlaceSite(COleSite* pSite) 
{
    m_pOleSite = pSite;
    m_nCount   = 0;

    AddRef();
}

COleInPlaceSite::~COleInPlaceSite() 
{
    assert(m_nCount == 0);
}

STDMETHODIMP COleInPlaceSite::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // delegate to the container Site
    return m_pOleSite->QueryInterface(riid, ppvObj);
}

STDMETHODIMP_(ULONG) COleInPlaceSite::AddRef()
{
    return ++m_nCount;
}

STDMETHODIMP_(ULONG) COleInPlaceSite::Release()
{
    --m_nCount;
    if(m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

STDMETHODIMP COleInPlaceSite::GetWindow (HWND* lphwnd)
{
    // return the handle to our editing window.
    *lphwnd = m_pOleSite->m_hWnd;

    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::ContextSensitiveHelp (BOOL fEnterMode)
{
    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::CanInPlaceActivate ()
{
    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::OnInPlaceActivate ()
{
    HRESULT hrErr;

    hrErr = m_pOleSite->m_lpOleObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&m_pOleSite->m_lpInPlaceObject);
    if (hrErr != NOERROR)
            return ResultFromScode(E_FAIL);

    // return S_OK to indicate we can in-place activate.
    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::OnUIActivate ()
{
    m_pOleSite->m_fInPlaceActive = TRUE;

    m_pOleSite->m_lpInPlaceObject->GetWindow((HWND*)&m_pOleSite->m_hwndIPObj);

    // return S_OK to continue in-place activation
    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::GetWindowContext (LPOLEINPLACEFRAME* lplpFrame,
                                                           LPOLEINPLACEUIWINDOW* lplpDoc,
                                                           LPRECT lprcPosRect,
                                                           LPRECT lprcClipRect,
                                                           LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    RECT rect;

    // the frame is associated with the application object.
    // need to AddRef() it...
    m_pOleSite->m_pOleInPlaceFrame->AddRef();
    *lplpFrame = m_pOleSite->m_pOleInPlaceFrame;
    *lplpDoc = NULL;  // must be NULL, cause we're SDI.

    // get the size of the object in pixels
    GetClientRect(m_pOleSite->m_hWnd, &rect);

    // Copy this to the passed buffer
    CopyRect(lprcPosRect, &rect);

    // fill the clipping region
    GetClientRect(m_pOleSite->m_hWnd, &rect);
    CopyRect(lprcClipRect, &rect);

    // fill the FRAMEINFO
    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_pOleSite->m_hWnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;

    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::Scroll (SIZE scrollExtent)
{
    return ResultFromScode(E_FAIL);
}

STDMETHODIMP COleInPlaceSite::OnUIDeactivate (BOOL fUndoable)
{
    // need to clear this flag first
    m_pOleSite->m_fInPlaceActive = FALSE;

    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::OnInPlaceDeactivate ()
{
    if (m_pOleSite->m_lpInPlaceObject) {
            m_pOleSite->m_lpInPlaceObject->Release();
            m_pOleSite->m_lpInPlaceObject = NULL;
    }
    return ResultFromScode(S_OK);
}

STDMETHODIMP COleInPlaceSite::DiscardUndoState ()
{
    return ResultFromScode(E_FAIL);
}

STDMETHODIMP COleInPlaceSite::DeactivateAndUndo ()
{
    return ResultFromScode(E_FAIL);
}


STDMETHODIMP COleInPlaceSite::OnPosRectChange (LPCRECT lprcPosRect)
{
    return ResultFromScode(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\ioipfram.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  IOIPFRAM.H - Implements IOleInPlaceFrame for the WebOC
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.

#ifndef  _IOIPF_H_ 
#define _IOIPF_H_

#include <objbase.h>
#include <oleidl.h>

class COleSite;

interface COleInPlaceFrame : public IOleInPlaceFrame
{
public:
    COleInPlaceFrame (COleSite* pSite);
   ~COleInPlaceFrame ();

    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    STDMETHODIMP GetWindow              (HWND* lphwnd);
    STDMETHODIMP ContextSensitiveHelp   (BOOL fEnterMode);
    // *** IOleInPlaceUIWindow methods ***
    STDMETHODIMP GetBorder              (LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace     (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetBorderSpace         (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetActiveObject        (LPOLEINPLACEACTIVEOBJECT lpActiveObject, LPCOLESTR lpszObjName);
    // *** IOleInPlaceFrame methods ***
    STDMETHODIMP InsertMenus            (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu                (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus            (HMENU hmenuShared);
    STDMETHODIMP SetStatusText          (LPCOLESTR lpszStatusText);
    STDMETHODIMP EnableModeless         (BOOL fEnable);
    STDMETHODIMP TranslateAccelerator   (LPMSG lpmsg, WORD wID);

private:
    int       m_nCount;
    COleSite* m_pOleSite;
};

#endif //#define _IOIPF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\server.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  SERVER.CPP - component server for MSObWeb
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// The FactoryDataArray contains the components which 
// can be served.

#include "cunknown.h"
#include "cfactory.h"
#include "msobweb.h"

//MIDL
#include "obweb.h"

//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, pointer to create function, and the name
// of the component to place in the registry.
//

CFactoryData g_FactoryDataArray[] =
{
   {&CLSID_ObWebBrowser,  
        CObWebBrowser::CreateInstance, 
        L"ObWebBrowser Component",   // Friendly Name
        L"ObWebBrowser.1",           // ProgID
        L"ObWebBrowser",             // Version Independent ProgID
        NULL,                       // Function to register component categories
        NULL,   0},
 };
int g_cFactoryDataEntries = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\ioipsite.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  IOIPSITE.H - Implements IOleClientSite for the WebOC
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.

#ifndef  _IOIPSITE_H_ 
#define _IOIPSITE_H_

#include <objbase.h>
#include <oleidl.h>

class COleSite;

interface COleInPlaceSite : public IOleInPlaceSite
{
public:
    COleInPlaceSite(COleSite* pSite);
    ~COleInPlaceSite();

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);
    // *** IOleInPlaceSite methods ***
    STDMETHODIMP CanInPlaceActivate ();
    STDMETHODIMP OnInPlaceActivate ();
    STDMETHODIMP OnUIActivate ();
    STDMETHODIMP GetWindowContext (LPOLEINPLACEFRAME* lplpFrame,
                                   LPOLEINPLACEUIWINDOW* lplpDoc,
                                   LPRECT lprcPosRect,
                                   LPRECT lprcClipRect,
                                   LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll (SIZE scrollExtent);
    STDMETHODIMP OnUIDeactivate (BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate ();
    STDMETHODIMP DiscardUndoState ();
    STDMETHODIMP DeactivateAndUndo ();
    STDMETHODIMP OnPosRectChange (LPCRECT lprcPosRect);

private:    
    int       m_nCount;
    COleSite* m_pOleSite;

};

#endif //_IOIPSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\msobweb.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOBWEB.H - Header for the implementation of CObWebBrowser
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Class which will call up an IOleSite and the WebOC
//  and provide external interfaces.

#ifndef _MSOBWEB_H_
#define _MSOBWEB_H_

#include <exdisp.h>
#include <oleauto.h>

#include "cunknown.h"
#include "obweb.h" 
#include "iosite.h"
#include "wmp.h"

class CObWebBrowser :   public CUnknown,
                        public IObWebBrowser,
                        public IDispatch
{
    // Declare the delegating IUnknown.
    DECLARE_IUNKNOWN

public:
    static  HRESULT           CreateInstance                  (IUnknown* pOuterUnknown, CUnknown** ppNewComponent);
    // IObWebBrowser Members                                    
    virtual HRESULT __stdcall AttachToWindow                  (HWND hWnd);
    virtual HRESULT __stdcall PreTranslateMessage             (LPMSG lpMsg);
    virtual HRESULT __stdcall Navigate                        (WCHAR* pszUrl, WCHAR* pszTarget);
    virtual HRESULT __stdcall ListenToWebBrowserEvents        (IUnknown* pUnk);
    virtual HRESULT __stdcall StopListeningToWebBrowserEvents (IUnknown* pUnk);
    virtual HRESULT __stdcall get_WebBrowserDoc               (IDispatch** ppDisp);
    virtual HRESULT __stdcall ObWebShowWindow                 ();
    virtual HRESULT __stdcall SetExternalInterface            (IUnknown* pUnk);
    virtual HRESULT __stdcall Stop();
    STDMETHOD (PlayBackgroundMusic)                  ();
    STDMETHOD (StopBackgroundMusic)                  ();
    STDMETHOD (UnhookScriptErrorHandler)             ();
    // IDispatch Members
    STDMETHOD (GetTypeInfoCount)                     (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)                          (UINT, LCID, ITypeInfo** );
    STDMETHOD (GetIDsOfNames)                        (REFIID, OLECHAR**, UINT, 
                                                      LCID, DISPID* );
    STDMETHOD (Invoke)                               (DISPID dispidMember, 
                                                      REFIID riid, 
                                                      LCID lcid, 
                                                      WORD wFlags, 
                                                      DISPPARAMS* pdispparams, 
                                                      VARIANT* pvarResult, 
                                                      EXCEPINFO* pexcepinfo, 
                                                      UINT* puArgErr);

private:
    HWND          m_hMainWnd;
    COleSite*     m_pOleSite;
    LPOLEOBJECT   m_lpOleObject;
    IWebBrowser2* m_lpWebBrowser;
    DWORD         m_dwcpCookie;
    DWORD         m_dwDrawAspect;
    BOOL          m_fInPlaceActive;

    // Script error reporting stuff
    BOOL          m_fOnErrorWasHooked;

    // Need a convenient place to have a WMP control
    COleSite*     m_pOleSiteWMP;
    LPOLEOBJECT   m_lpOleObjectWMP;
    IWMPPlayer*   m_pWMPPlayer;

   
    // IUnknown
    virtual HRESULT __stdcall NondelegatingQueryInterface( const IID& iid, void** ppv);

                    CObWebBrowser            (IUnknown* pOuterUnknown);
    virtual        ~CObWebBrowser            ();
    virtual void    FinalRelease             (); // Notify derived classes that we are releasing
            void    InitBrowserObject        ();   
            void    InPlaceActivate          ();
            void    UIActivate               ();
            void    CloseOleObject           ();
            void    UnloadOleObject          ();
            HRESULT ConnectToConnectionPoint (IUnknown*          punkThis, 
                                              REFIID             riidEvent, 
                                              BOOL               fConnect, 
                                              IUnknown*          punkTarget, 
                                              DWORD*             pdwCookie, 
                                              IConnectionPoint** ppcpOut);
    STDMETHOD(onerror)  (IN VARIANT* pvarMsg,
                         IN VARIANT* pvarUrl,
                         IN VARIANT* pvarLine,
                         OUT VARIANT_BOOL* pfResult);
};

#define SETDefFormatEtc(fe, cf, med) \
{\
(fe).cfFormat=cf;\
(fe).dwAspect=DVASPECT_CONTENT;\
(fe).ptd=NULL;\
(fe).tymed=med;\
(fe).lindex=-1;\
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\iosite.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  IOSITE.CPP - Implementation of IOleSite
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Class which will provide the an IOleSite to the WebOC

#include <windows.h>
#include <assert.h>
#include <tchar.h>
#include <exdispid.h>
#include <mshtmhst.h>
#include <oleacc.h>
#include <mshtmdid.h>

#include "iosite.h"
#include "appdefs.h"
#include "util.h"

/////////////////////////////////////////////////////////////
// COleSite::COleSite

COleSite::COleSite (void)
{
    // Init member vars
    m_cRef            = 0;
    m_hWnd            = NULL;
    m_hwndIPObj       = NULL;
    m_lpInPlaceObject = NULL;
    m_fScrolling      = FALSE;
    m_bIsOEMDebug     = IsOEMDebugMode();

    m_pOleInPlaceFrame = new COleInPlaceFrame (this);
    m_pOleInPlaceSite  = new COleInPlaceSite  (this);
    m_pOleClientSite   = new COleClientSite   (this);

    // Create a storage file for creating/embedding an OLE oject into this site
    StgCreateDocfile (NULL, 
                      STGM_READWRITE       | 
                      STGM_TRANSACTED      | 
                      STGM_SHARE_EXCLUSIVE | 
                      STGM_DELETEONRELEASE, 
                      0, 
                      &m_lpStorage);

    RECT rectWorkArea;
    SystemParametersInfo(SPI_GETWORKAREA, 0, (void*)&rectWorkArea, 0);
    //If the window is too short it should have a scrollbar
    if(rectWorkArea.bottom < MSN_HEIGHT)
        m_fScrolling = TRUE;

    AddRef();
}

/////////////////////////////////////////////////////////////
// COleSite::~COleSite
COleSite::~COleSite ()
{   
    if(m_pOleInPlaceFrame)
    {
        m_pOleInPlaceFrame->Release();
        m_pOleInPlaceFrame = NULL;
    }

    if(m_pOleInPlaceSite)
    {
        m_pOleInPlaceSite->Release();
        m_pOleInPlaceSite = NULL;
    }

    if(m_pOleClientSite)
    {
        m_pOleClientSite->Release();
        m_pOleClientSite = NULL;
    }
    
    if (m_lpStorage) 
    {
        m_lpStorage->Release();
        m_lpStorage = NULL;
    }

    assert(m_cRef == 0);
}

/////////////////////////////////////////////////////////////
// COleSite::QueryInterface
STDMETHODIMP COleSite::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    // must set out pointer parameters to NULL
    *ppvObj = NULL;     

    if(riid == IID_IDocHostUIHandler)
    {
        AddRef();
        *ppvObj = (IDocHostUIHandler*)this;
        return ResultFromScode(S_OK);
    }
    
    if(riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    if(riid == IID_IOleClientSite)
    {
        m_pOleClientSite->AddRef();
        *ppvObj = m_pOleClientSite;
        return ResultFromScode(S_OK);
    }
    
    if(riid == IID_IOleInPlaceSite)
    {
        m_pOleInPlaceSite->AddRef();
        *ppvObj = m_pOleInPlaceSite;
        return ResultFromScode(S_OK);
    }

    if(riid == IID_IAccessible)
    {
        AddRef();
        *ppvObj = (IAccessible*)this;
        return ResultFromScode(S_OK);
    }
       
    if((riid == DIID_DWebBrowserEvents2) ||
        (riid == IID_IDispatch))
    {
        AddRef();
        *ppvObj = (LPVOID)(IUnknown*)(DWebBrowserEvents2*)this;
        return ResultFromScode(S_OK);
    }

    if(riid == IID_IServiceProvider)
    {
        AddRef();
        *ppvObj = (IServiceProvider*)this;
        return ResultFromScode(S_OK);
    }
    
    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////
// COleSite::AddRef
STDMETHODIMP_(ULONG) COleSite::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////
// COleSite::Release
STDMETHODIMP_(ULONG) COleSite::Release()
{
    --m_cRef;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/////////////////////////////////////////////////////////////
// COleSite::QueryService
STDMETHODIMP COleSite::QueryService (REFGUID guidService, REFIID riid, void** ppvService)
{
    // must set out pointer parameters to NULL
    *ppvService = NULL;    
    
    //Is MSHTML looking for a custom security manager?
    if((guidService == SID_SInternetSecurityManager) &&
       (riid        == IID_IInternetSecurityManager))
    {
        AddRef();
        *ppvService = (IInternetSecurityManager*)this;
        return ResultFromScode(S_OK);
    }

    // Not a supported service
    return ResultFromScode(E_NOTIMPL);
}

/////////////////////////////////////////////////////////////
// COleSite::GetHostInfo
HRESULT COleSite::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG             | 
                     DOCHOSTUIFLAG_NO3DBORDER         |
                     DOCHOSTUIFLAG_DISABLE_HELP_MENU;

    if(!m_fScrolling)
        pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
   
    return S_OK;
}

/////////////////////////////////////////////////////////////
// COleSite::ShowUI
HRESULT COleSite::ShowUI
(
    DWORD dwID, 
    IOleInPlaceActiveObject* pActiveObject,
    IOleCommandTarget*       pCommandTarget,
    IOleInPlaceFrame*        pFrame,
    IOleInPlaceUIWindow*     pDoc
)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////
// COleSite::HideUI
HRESULT COleSite::HideUI(void)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////
// COleSite::UpdateUI
HRESULT COleSite::UpdateUI(void)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////
// COleSite::EnableModeless
HRESULT COleSite::EnableModeless(BOOL  fEnable)
{
    if( fEnable )
       UpdateWindow ( m_hWnd );

    return S_OK;
}

/////////////////////////////////////////////////////////////
// COleSite::OnDocWindowActivate
HRESULT COleSite::OnDocWindowActivate(BOOL fActivate)
{ 
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// COleSite::OnFrameWindowActivate
HRESULT COleSite::OnFrameWindowActivate(BOOL fActivate)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// COleSite::ResizeBorder
HRESULT COleSite::ResizeBorder(
                LPCRECT prcBorder, 
                IOleInPlaceUIWindow* pUIWindow,
                BOOL fRameWindow)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// COleSite::ShowContextMenu
HRESULT COleSite::ShowContextMenu(
                DWORD /*dwID*/, 
                POINT* /*pptPosition*/,
                IUnknown* /*pCommandTarget*/,
                IDispatch* /*pDispatchObjectHit*/)
{
#ifdef  DEBUG
    return E_NOTIMPL;
#else
    return S_OK; // We've shown our own context menu. MSHTML.DLL will no longer try to show its own.
#endif
}

/////////////////////////////////////////////////////////////
// COleSite::TranslateAccelerator
HRESULT COleSite::TranslateAccelerator(LPMSG lpMsg,
            /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID)
{
    return ResultFromScode(S_FALSE);
}

/////////////////////////////////////////////////////////////
// COleSite::GetOptionKeyPath
HRESULT COleSite::GetOptionKeyPath(BSTR* pbstrKey, DWORD)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// COleSite::GetDropTarget
STDMETHODIMP COleSite::GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// COleSite::GetExternal
STDMETHODIMP COleSite::GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch)
{
    // return the IDispatch we have for extending the object Model
    // "window.external" from script
    m_pExternalInterface->AddRef();
    *ppDispatch = m_pExternalInterface; 
    return S_OK;
}

/////////////////////////////////////////////////////////////
// COleSite::GetIDsOfNames
STDMETHODIMP COleSite::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{ 
    rgDispId[0] = DISPID_UNKNOWN;

    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }      
 
    return DISP_E_UNKNOWNNAME;
}

/////////////////////////////////////////////////////////////
// COleSite::TranslateUrl   
STDMETHODIMP COleSite::TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut)
{
    return E_NOTIMPL;
}
        
/////////////////////////////////////////////////////////////
// COleSite::FilterDataObject
STDMETHODIMP COleSite::FilterDataObject( 
            /* [in] */ IDataObject __RPC_FAR *pDO,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet)
{
    return E_NOTIMPL;
}

STDMETHODIMP COleSite::SetExternalInterface (IDispatch* pUnk)
{
    m_pExternalInterface = pUnk;
    return S_OK;
}

HRESULT COleSite::GetTypeInfoCount(UINT* pcInfo) 
{ 
    return E_NOTIMPL; 
}

HRESULT COleSite::GetTypeInfo(UINT, LCID, ITypeInfo**) 
{ 
    return E_NOTIMPL; 
}

/////////////////////////////////////////////////////////////
// COleSite::Invoke
HRESULT COleSite::Invoke
( 
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags, 
    DISPPARAMS FAR* pdispparams, 
    VARIANT FAR* pvarResult,  
    EXCEPINFO FAR* pexcepinfo, 
    UINT FAR* puArgErr
)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    if (!m_bIsOEMDebug)
    {
        switch(dispidMember)
        {
            case DISPID_AMBIENT_DLCONTROL:
            {
                if (pvarResult != NULL) 
                {
                    VariantInit(pvarResult);
                    V_VT(pvarResult) = VT_I4;
                    pvarResult->lVal = DLCTL_DLIMAGES| DLCTL_VIDEOS| DLCTL_BGSOUNDS |DLCTL_SILENT;
                }
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT COleSite::GetSecurityId(LPCWSTR pwszUrl, BYTE __RPC_FAR *pbSecurityId, DWORD __RPC_FAR *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT COleSite::GetSecuritySite(IInternetSecurityMgrSite __RPC_FAR *__RPC_FAR *ppSite)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT COleSite::SetSecuritySite(IInternetSecurityMgrSite __RPC_FAR *pSite)
{
    return S_OK;
}

HRESULT COleSite::MapUrlToZone(LPCWSTR pwszUrl, DWORD __RPC_FAR *pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT COleSite::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE __RPC_FAR *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    // *DO NOT CHANGE THIS RETURN VALUE*
    // This is what allows us to override IE.
    switch (dwAction)
    {
        case URLACTION_CROSS_DOMAIN_DATA:
        case URLACTION_HTML_SUBMIT_FORMS:
        case URLACTION_HTML_SUBMIT_FORMS_FROM: 
        case URLACTION_HTML_SUBMIT_FORMS_TO: 
        case URLACTION_SCRIPT_OVERRIDE_SAFETY:
        case URLACTION_HTML_JAVA_RUN:
        case URLACTION_ACTIVEX_RUN:
        {
            return S_OK;    
        }
        default:
            return INET_E_DEFAULT_ACTION;
    }
    
}

HRESULT COleSite::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE __RPC_FAR *__RPC_FAR *ppPolicy, DWORD __RPC_FAR *pcbPolicy, BYTE __RPC_FAR *pContext, DWORD cbContext, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT COleSite::GetZoneMappings(DWORD dwZone, IEnumString __RPC_FAR *__RPC_FAR *ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT COleSite::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{    
    return INET_E_DEFAULT_ACTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\msobweb.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOBWEB.CPP - Implementation of CObWebBrowser
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
//  Class which will call up an IOleSite and the WebOC
//  and provide external interfaces.

#include <exdispid.h>
#include <mshtml.h>     // IHTMLElement, IHTMLDocument2, IHTMLWindow2
#include <mshtmhst.h>
#include <tchar.h>

#include "msobweb.h"
#include "appdefs.h"
#include "zmouse.h"
#include "util.h"

const VARIANT c_vaEmpty = {0};

#define PVAREMPTY ((VARIANT*)&c_vaEmpty)
#define VK_N L'N'
#define VK_P L'P'
#define VK_Z L'Z'
#define VK_ENTER 0x0D

///////////////////////////////////////////////////////////
//
// Creation function used by CFactory.
//
HRESULT CObWebBrowser::CreateInstance(IUnknown*  pOuterUnknown,
                                      CUnknown** ppNewComponent)
{
   if (pOuterUnknown != NULL)
   {
      // Don't allow aggregation. Just for the heck of it.
      return CLASS_E_NOAGGREGATION;
   }

   *ppNewComponent = new CObWebBrowser(pOuterUnknown);
   return S_OK;
}

///////////////////////////////////////////////////////////
//
//  NondelegatingQueryInterface
//
HRESULT __stdcall
CObWebBrowser::NondelegatingQueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IObWebBrowser)
    {
        return FinishQI(static_cast<IObWebBrowser*>(this), ppv);
    }
    else if (iid == IID_IDispatch)
    {
        return FinishQI(static_cast<IDispatch*>(this), ppv);
    }
    else
    {
        return CUnknown::NondelegatingQueryInterface(iid, ppv);
    }
}

///////////////////////////////////////////////////////////
//
//  Constructor
//
CObWebBrowser::CObWebBrowser(IUnknown* pOuterUnknown)
: CUnknown(pOuterUnknown),
    m_hMainWnd       (NULL),
    m_pOleSite       (NULL),
    m_lpOleObject    (NULL),
    m_lpWebBrowser   (NULL),
    m_dwDrawAspect   (0),
    m_dwcpCookie     (0),
    m_fInPlaceActive (FALSE),
    m_fOnErrorWasHooked(FALSE),
    m_pOleSiteWMP    (NULL),
    m_lpOleObjectWMP (NULL),
    m_pWMPPlayer     (NULL)
{
    HRESULT   hr             = E_FAIL;
    IUnknown* pOleSiteIUnkwn = NULL;

    FORMATETC fromAtetc;

    // Create a new OLE site w/ WebOC
    m_pOleSite = new COleSite();
    if (m_pOleSite == NULL)
    {
        // We're hosed if this happens.
        return;
    }

    SETDefFormatEtc(fromAtetc, 0, TYMED_NULL);

    if(SUCCEEDED(OleCreate(CLSID_WebBrowser,
                           IID_IWebBrowser2,
                           OLERENDER_DRAW,
                           &fromAtetc,
                           m_pOleSite->m_pOleClientSite,
                           m_pOleSite->m_lpStorage,
                           (LPVOID*)&m_lpWebBrowser)) && m_lpWebBrowser)
    {

        InitBrowserObject();
    }

    // Create an extra control for the Windows Media Player
    m_pOleSiteWMP = new COleSite();
    if (m_pOleSiteWMP == NULL)
    {
        goto LFail;
    }

    if (FAILED(OleCreate(__uuidof(WMPOCX),
                            __uuidof(IWMPPlayer),
                            OLERENDER_NONE,
                            NULL,
                            NULL,
                            m_pOleSiteWMP->m_lpStorage,
                            (LPVOID*)&m_pWMPPlayer)))
    {
        goto LFail;
    }

    // Get An OleObject from the WebBrowser Interface
    if (FAILED(m_pWMPPlayer->QueryInterface(IID_IOleObject, (LPVOID*)&m_lpOleObjectWMP)))
    {
        goto LFail;
    }

    m_pOleSiteWMP->m_lpOleObject = m_lpOleObjectWMP;
    // inform object handler/DLL object that it is used in the embedding container's context
    OleSetContainedObject(m_lpOleObjectWMP, TRUE);

    return;

LFail:
    if (m_pWMPPlayer != NULL)
    {
        m_pWMPPlayer->Release();
        m_pWMPPlayer = NULL;
    }
    if (m_pOleSiteWMP != NULL)
    {
        m_pOleSiteWMP->Release();
        m_pOleSiteWMP = NULL;
    }
}

///////////////////////////////////////////////////////////
//
//  Destructor
//
CObWebBrowser::~CObWebBrowser()
{
    if (m_lpOleObjectWMP)
    {
        m_lpOleObjectWMP->Close(OLECLOSE_NOSAVE);
        m_pOleSiteWMP->m_hWnd = NULL;;
        m_lpOleObjectWMP->Release();
        m_lpOleObjectWMP = NULL;
        m_pOleSiteWMP->m_lpOleObject = NULL;
    }
    if (m_pWMPPlayer != NULL)
    {
        m_pWMPPlayer->Release();
        m_pWMPPlayer = NULL;
    }
    if (m_pOleSiteWMP != NULL)
    {
        m_pOleSiteWMP->Release();
        m_pOleSiteWMP = NULL;
    }

    if (m_lpOleObject)
    {
        LPVIEWOBJECT lpViewObject = NULL;
        // ensure object is closed;
        CloseOleObject();

        m_lpOleObject->QueryInterface(IID_IViewObject, (LPVOID*)&lpViewObject);

        if (lpViewObject)
        {
            // Remove the view advise
            lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
            lpViewObject->Release();
        }
        m_lpOleObject->Release();
        m_lpOleObject             = NULL;
        m_pOleSite->m_lpOleObject = NULL;
    }

    if (m_lpWebBrowser)
    {
        m_lpWebBrowser->Release();
        m_lpWebBrowser = NULL;
    }

    if (m_lpOleObject)
    {
       m_lpOleObject->Release();
       m_lpOleObject = NULL;
    }

    if(m_pOleSite)
    {
        m_pOleSite->Release();
        m_pOleSite = NULL;
    }
}

///////////////////////////////////////////////////////////
//
//  FinalRelease -- Clean up the aggreated objects.
//
void CObWebBrowser::FinalRelease()
{
    CUnknown::FinalRelease();
}


///////////////////////////////////////////////////////////
//  IObWebBrowser Implementation
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
//  AttachToWindow
//
HRESULT CObWebBrowser::AttachToWindow(HWND hWnd)
{
    if(m_hMainWnd)
    {
        CloseOleObject();
    }

    //Set the new hwnd
    m_hMainWnd = hWnd;
    m_pOleSite->m_hWnd = m_hMainWnd;

    InPlaceActivate();

    return S_OK;
}

///////////////////////////////////////////////////////////
// PreTranslateMessage -- Do not use with size parameters because addin the org...
//
HRESULT CObWebBrowser::PreTranslateMessage(LPMSG lpMsg)
{
    HRESULT hr = S_FALSE;

    switch(lpMsg->message)
    {
        case WM_LBUTTONDOWN:
        {
            WPARAM dwKeys = lpMsg->wParam;              // key flags 

            if (MK_SHIFT & dwKeys)
            {
               return S_OK;
            }
            break;
        }

        case WM_MOUSEWHEEL:
        case WM_MBUTTONDOWN:
        {
            return S_OK;
        }
        case WM_RBUTTONDOWN :
        {
            VARIANT varg1;
            VARIANT varg2;
            IDispatch              *pdisp       = NULL;
            IDispatch*              pDisp       = NULL;
            IHTMLWindow2*           pFrWin      = NULL;
            IHTMLDocument2*         pDoc        = NULL;
            IHTMLElementCollection *pColl       = NULL;

            IHTMLElement* pElement              = NULL;
            IHTMLStyle*   pStyle                = NULL;
            BOOL    bFilter                     = FALSE;
            HRESULT hrDoc                       = S_OK;

            VariantInit(&varg1);
            V_VT(&varg1)  = VT_BSTR;
            varg1.bstrVal= SysAllocString(L"MovieFrame");

            VariantInit(&varg2);
            varg2.vt = VT_UINT;
            varg2.lVal= 0;

            if(SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp))&& pDisp)
            {
                if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
                {
                    if(SUCCEEDED(pDoc->get_all( &pColl )) && pColl)
                    {
                        if(SUCCEEDED(pColl->item(varg1, varg2, &pdisp)) && pdisp)
                        {

                            if(SUCCEEDED(pdisp->QueryInterface(IID_IHTMLElement, (void**)&pElement)) && pElement)
                            {
                                if(SUCCEEDED(pElement->get_style(&pStyle)) && pStyle)
                                {
                                    BSTR bstrVisibility = NULL;
                                    BSTR bstrDisplay = NULL;

                                    pStyle->get_visibility(&bstrVisibility);

                                    pStyle->get_display(&bstrDisplay);

                                    if (bstrDisplay)
                                    {
                                        if (lstrcmpi(bstrDisplay, L"none") != 0)
                                            bFilter = TRUE;
                                    }
                                    if (bstrVisibility)
                                    {
                                        if (lstrcmpi(bstrVisibility, L"hidden") != 0)
                                            bFilter = TRUE;
                                    }

                                    pStyle->Release();
                                    pStyle = NULL;
                                }
                                pElement->Release();
                                pElement = NULL;
                            }
                            pdisp->Release();
                            pdisp = NULL;
                        }

                        pColl->Release();
                        pColl = NULL;
                    }
                    pDoc->Release();
                    pDoc = NULL;
                }
                pDisp->Release();
                pDisp = NULL;
            }
            if (bFilter)
                return S_OK;
            break;

        }

        case WM_KEYDOWN:
        {
            if ( lpMsg->wParam == VK_F3 )
            {
                /* Convert keyboard messages came into WM_COMMANDs to
                 * the found dialog. Return TRUE because we procecessed.
                 */
                if ( (GetKeyState ( VK_SHIFT) & 0x8000) && (GetKeyState( VK_CONTROL) & 0x8000))
                {
                    HWND hWnd = FindWindow(OOBE_MAIN_CLASSNAME, NULL);
                    PostMessage(hWnd, WM_COMMAND, WM_SKIP, 0L); //MAKELPARAM(lpMsg->hwnd, BY_KEYBOARD));
                    return S_FALSE;
                }
            }

            if(lpMsg->wParam == VK_F1)
            {
                HWND hWnd = FindWindow(OOBE_MAIN_CLASSNAME, DEFAULT_WINDOW_TEXT);
                if (hWnd)
                {
                    PostMessage(hWnd, WM_COMMAND, WM_AGENT_HELP, 0L);
                    return S_FALSE;
                }
            }

            if(
#ifndef DBG
                (lpMsg->wParam == VK_F5) ||
#endif
                (lpMsg->wParam == VK_F6) ||  // F6 key deletes the insertation point cursor when filling out the Registration info.
              (((lpMsg->wParam == VK_N)  ||  (lpMsg->wParam == VK_Z)  ||
                (lpMsg->wParam == VK_P)) && ((GetKeyState(VK_CONTROL) & 0x1000))))
                return S_OK;
        }
        //Fall through!!!

        case WM_SYSKEYDOWN:
        {

            if((((lpMsg->wParam == VK_LEFT)  ||
                (lpMsg->wParam == VK_RIGHT) ||
                (lpMsg->wParam == VK_HOME)) && (GetKeyState(VK_MENU) & 0x1000)) ||
                ((lpMsg->wParam == VK_ENTER ) && (GetKeyState( VK_SHIFT) & 0x8000)) ||
                // Space +Shift +Ctrl is a Narrator key combination, don't diable this.
                ((lpMsg->wParam == VK_SPACE) && (GetKeyState( VK_SHIFT) & 0x8000) &&
                 (GetKeyState( VK_CONTROL ) & 0x8000))
                )
                return S_OK;
            else if((lpMsg->wParam == VK_BACK) || (lpMsg->wParam == VK_SPACE))
            {
                VARIANT varRet;
                VARIANTARG varg;

                IDispatch*              pDisp     = NULL;
                IHTMLWindow2*           pFrWin    = NULL;
                IHTMLDocument2*         pDoc      = NULL;
                IHTMLDocument2*         pFrDoc    = NULL;
                IHTMLElement*           pActElem  = NULL;
                IHTMLFramesCollection2* pColl     = NULL;
                BOOL                    bDontTA   = TRUE;
                HRESULT hrDoc = S_OK;

                VariantInit(&varg);
                V_VT(&varg)  = VT_BSTR;
                varg.bstrVal= SysAllocString(DEFAULT_FRAME_NAME);

                if(SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp))&& pDisp)
                {
                    if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
                    {
                        if(SUCCEEDED(pDoc->get_frames(&pColl)) && pColl)
                        {
                            if(SUCCEEDED(pColl->item(&varg, &varRet)) && varRet.pdispVal)
                            {
                                if(SUCCEEDED(varRet.pdispVal->QueryInterface(IID_IHTMLWindow2, (void**)&pFrWin)) && pFrWin)
                                {
                                    if(SUCCEEDED( hrDoc = pFrWin->get_document(&pFrDoc)) && pFrDoc)
                                    {
                                        if(SUCCEEDED(pFrDoc->get_activeElement(&pActElem)) && pActElem)
                                        {
                                            BSTR bstr = NULL;

                                            if (SUCCEEDED(pActElem->get_tagName(&bstr)))
                                            {
                                                LPWSTR   lpszType = bstr;

                                                if ( (lstrcmpi(lpszType, L"TEXTAREA") == 0) ||
                                                     (lstrcmpi(lpszType, L"INPUT") == 0) ||
                                                     (lstrcmpi(lpszType, L"BUTTON") == 0) )
                                                    bDontTA = FALSE;
                                            }

                                            pActElem->Release();
                                            pActElem = NULL;
                                        }
                                        pFrDoc->Release();
                                        pFrDoc = NULL;
                                    }
                                }
                                varRet.pdispVal->Release();
                                varRet.pdispVal = NULL;
                            }
                            pColl->Release();
                            pColl = NULL;
                        }
                        pDoc->Release();
                        pDoc = NULL;
                    }
                    pDisp->Release();
                    pDisp = NULL;
                }

                if(bDontTA)
                {
                    if ( !SUCCEEDED(hrDoc) )  // cross frame access denied for server page.
                    {
                        return S_FALSE;     // Send VK_BACK to the page.
                    }

                    return S_OK;
                }
                else
                {
                    return S_FALSE;
                }
            }
        }
        default:
            break;
    }

    if(m_lpWebBrowser)
    {
        IOleInPlaceActiveObject* lpIPA;

        if(SUCCEEDED(m_lpWebBrowser->QueryInterface(IID_IOleInPlaceActiveObject,(void**)&lpIPA)))
        {
            hr = lpIPA->TranslateAccelerator(lpMsg);

            lpIPA->Release();
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////
// Navigate
HRESULT CObWebBrowser::Navigate(WCHAR* pszUrl, WCHAR* pszTarget)
{
    VARIANT varURL;
    VARIANT varTarget;
    VARIANT         v;
    IDispatch       *pdisp  = NULL;
    IHTMLWindow2    *pwin   = NULL;
    IHTMLDocument2  *pdoc   = NULL;

    TRACE2(L"Attempting to navigate: \n\tUrl: %s\n\tTarget: %s\n",
          (NULL != pszUrl) ? pszUrl : L"NONE",
          (NULL != pszTarget) ? pszTarget : L"NONE"
          );

    VariantInit(&varURL);
    VariantInit(&varTarget);
    VariantInit(&v);

    V_VT(&varURL)    = VT_BSTR;
    V_VT(&varTarget) = VT_BSTR;

    varURL.bstrVal    = SysAllocString(pszUrl);
    varTarget.bstrVal = SysAllocString(pszTarget);

    m_lpWebBrowser->Navigate2(&varURL, PVAREMPTY, &varTarget, PVAREMPTY, PVAREMPTY);

    if (FAILED(m_lpWebBrowser->get_Document(&pdisp)) || pdisp == NULL)
    {
        TRACE(L"Couldn't find the web browser's document object!");
        goto LCleanup;
    }

    if (FAILED(pdisp->QueryInterface(IID_IHTMLDocument2, (void**)&pdoc)))
    {
        TRACE(L"The web browser's document doesn't support IHTMLDocument2!");
        goto LCleanup;
    }

    if (FAILED(pdoc->get_parentWindow(&pwin)) || pwin == NULL)
    {
        TRACE(L"There's no window for the web browser's document object!");
        goto LCleanup;
    }

    V_VT(&v) = VT_DISPATCH;
    QueryInterface(IID_IDispatch, (void**)&V_DISPATCH(&v));

    if (FAILED(pwin->put_onerror(v)))
    {
        TRACE(L"Couldn't set the script error hook!");
        goto LCleanup;
    }

    m_fOnErrorWasHooked = TRUE;

LCleanup:
    if (V_VT(&v) == VT_DISPATCH)
    {
        V_DISPATCH(&v)->Release();
    }
    if (pwin != NULL)
    {
        pwin->Release();
        pwin = NULL;
    }
    if (pdoc != NULL)
    {
        pdoc->Release();
        pdoc = NULL;
    }
    if (pdisp != NULL)
    {
        pdisp->Release();
        pdisp = NULL;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////
// Stop
HRESULT CObWebBrowser::Stop()
{
    m_lpWebBrowser->Stop();
    return S_OK;
}

///////////////////////////////////////////////////////////
// PlayBackgroundMusic
STDMETHODIMP
CObWebBrowser::PlayBackgroundMusic()
{
    IWMPSettings* psettings = NULL;
    IWMPControls* pcontrols = NULL;
    HRESULT hr;
    BSTR bstr = NULL;
    WCHAR szFile[MAX_PATH];

    if (m_pWMPPlayer == NULL)
    {
        TRACE(L"Couldn't access the media player control.");
        goto LExit;
    }

    ExpandEnvironmentStrings(
                    L"%SystemRoot%\\system32\\oobe\\images\\title.wma",
                    szFile,
                    sizeof(szFile)/sizeof(szFile[0]));

    bstr = SysAllocString(szFile);
    if (bstr == NULL)
    {
        TRACE(L"Couldn't allocate the background sound file string.");
        goto LExit;
    }

    hr = m_pWMPPlayer->put_URL(bstr);

    SysFreeString(bstr);

    if (FAILED(hr))
    {
        TRACE(L"Couldn't set the movie file.");
        goto LExit;
    }

    // Turn off the WMP error dialogs

    hr = m_pWMPPlayer->QueryInterface(__uuidof(IWMPSettings), (LPVOID*)&psettings);
    if (FAILED(hr))
    {
        TRACE(L"Couldn't access WMP settings.");
        goto LExit;
    }

    hr = psettings->put_enableErrorDialogs(VARIANT_FALSE);
    if (FAILED(hr))
    {
        TRACE(L"Couldn't turn off WMP error dialogs.");
        goto LExit;
    }

    // Now, start playing

    hr = m_pWMPPlayer->QueryInterface(__uuidof(IWMPControls), (LPVOID*)&pcontrols);
    if (FAILED(hr))
    {
        TRACE(L"Couldn't access WMP controls.");
        goto LExit;
    }
    pcontrols->play();

LExit:
    if (pcontrols != NULL)
    {
        pcontrols->Release();
        pcontrols = NULL;
    }
    if (psettings != NULL)
    {
        psettings->Release();
        psettings = NULL;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
// PlayBackgroundMusic
STDMETHODIMP
CObWebBrowser::StopBackgroundMusic()
{
    IWMPControls* pcontrols = NULL;
    HRESULT hr;

    if (m_pWMPPlayer == NULL)
    {
        TRACE(L"Couldn't access the media player control.");
        goto LExit;
    }

    hr = m_pWMPPlayer->QueryInterface(__uuidof(IWMPControls), (LPVOID*)&pcontrols);
    if (FAILED(hr))
    {
        TRACE(L"Couldn't access WMP controls.");
        goto LExit;
    }
    pcontrols->stop();

LExit:
    if (pcontrols != NULL)
    {
        pcontrols->Release();
        pcontrols = NULL;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
// UnhookScriptErrorHandler
STDMETHODIMP
CObWebBrowser::UnhookScriptErrorHandler()
{
    VARIANT         v;
    IDispatch       *pdisp  = NULL;
    IHTMLWindow2    *pwin   = NULL;
    IHTMLDocument2  *pdoc   = NULL;

    if (!m_fOnErrorWasHooked)
    {
        goto LCleanup;
    }

    if (FAILED(m_lpWebBrowser->get_Document(&pdisp)) || pdisp == NULL)
    {
        TRACE(L"Couldn't find the web browser's document object!");
        goto LCleanup;
    }

    if (FAILED(pdisp->QueryInterface(IID_IHTMLDocument2, (void**)&pdoc)))
    {
        TRACE(L"The web browser's document doesn't support IHTMLDocument2!");
        goto LCleanup;
    }

    if (FAILED(pdoc->get_parentWindow(&pwin)) || pwin == NULL)
    {
        TRACE(L"There's no window for the web browser's document object!");
        goto LCleanup;
    }

    VariantInit(&v);
    V_VT(&v) = VT_DISPATCH;
    V_DISPATCH(&v) = NULL;

    pwin->put_onerror(v);

LCleanup:
    if (pwin != NULL)
    {
        pwin->Release();
        pwin = NULL;
    }
    if (pdoc != NULL)
    {
        pdoc->Release();
        pdoc = NULL;
    }
    if (pdisp != NULL)
    {
        pdisp->Release();
        pdisp = NULL;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////
//  IDispatch Implementation
///////////////////////////////////////////////////////////

STDMETHODIMP CObWebBrowser::GetTypeInfoCount(UINT* pcInfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CObWebBrowser::GetTypeInfo(UINT, LCID, ITypeInfo** )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////
// CObWebBrowser::GetIDsOfNames
STDMETHODIMP CObWebBrowser::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{
    return DISP_E_UNKNOWNNAME;
}

/////////////////////////////////////////////////////////////
// CObWebBrowser::Invoke
HRESULT CObWebBrowser::Invoke
(
    DISPID       dispidMember,
    REFIID       riid,
    LCID         lcid,
    WORD         wFlags,
    DISPPARAMS*  pdispparams,
    VARIANT*     pvarResult,
    EXCEPINFO*   pexcepinfo,
    UINT*        puArgErr
)
{
    HRESULT hr = S_OK;

    switch(dispidMember)
    {
        case DISPID_VALUE:
        {
            if (pdispparams                             &&
                pdispparams->cArgs == 3)
            {
                VARIANT_BOOL f;

                onerror(&pdispparams[0].rgvarg[2],
                        &pdispparams[0].rgvarg[1],
                        &pdispparams[0].rgvarg[0],
                        &f);
                if (pvarResult != NULL)
                {
                    V_VT(pvarResult) = VT_BOOL;
                    V_BOOL(pvarResult) = f;
                }
            }
            break;
        }

        default:
        {
           hr = DISP_E_MEMBERNOTFOUND;
           break;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////
// onerror
STDMETHODIMP
CObWebBrowser::onerror(IN VARIANT* pvarMsg,
                       IN VARIANT* pvarUrl,
                       IN VARIANT* pvarLine,
                       OUT VARIANT_BOOL* pfResult)
{
    BSTR bstrMsg, bstrUrl;
    int iLine;

    *pfResult = Bool2VarBool(FALSE);

    if (pvarMsg == NULL || V_VT(pvarMsg) != VT_BSTR)
    {
        return S_OK;
    }
    bstrMsg = V_BSTR(pvarMsg);

    if (pvarUrl == NULL || V_VT(pvarUrl) != VT_BSTR)
    {
        return S_OK;
    }
    bstrUrl = V_BSTR(pvarUrl);

    if (pvarLine == NULL || V_VT(pvarLine) != VT_I4)
    {
        return S_OK;
    }
    iLine = V_I4(pvarLine);

    TRACE3(L"%s: %s: Line %d", bstrMsg, bstrUrl, iLine);

#ifdef PRERELEASE
    WCHAR wsz[MAX_PATH];

    wsprintf(wsz, L"%s\nLine %d\nPlease notify OOBEDEV.", bstrUrl, iLine);
    MessageBox(NULL, wsz, bstrMsg, MB_ICONERROR | MB_OK | MB_DEFAULT_DESKTOP_ONLY | MB_SETFOREGROUND);
#endif

    *pfResult = Bool2VarBool(TRUE);
    return S_OK;
}

///////////////////////////////////////////////////////////
// get_WebBrowserDoc
HRESULT CObWebBrowser::get_WebBrowserDoc(IDispatch** ppDisp)
{
    m_lpWebBrowser->get_Document(ppDisp);

    return S_OK;
}

///////////////////////////////////////////////////////////
// ListenToWebBrowserEvents
HRESULT CObWebBrowser::ListenToWebBrowserEvents(IUnknown* pUnk)
{
    //first things first
    if (!pUnk)
        return E_FAIL;

    //Ok, everything looks OK, try to setup a connection point.
    // Setup to get WebBrowserEvents
    return ConnectToConnectionPoint(pUnk,
                                    DIID_DWebBrowserEvents2,
                                    TRUE,
                                    (IUnknown*)m_lpWebBrowser,
                                    &m_dwcpCookie,
                                    NULL);
}

///////////////////////////////////////////////////////////
// StopListeningToWebBrowserEvents
HRESULT CObWebBrowser::StopListeningToWebBrowserEvents(IUnknown* pUnk)
{
    //first things first
    if (!pUnk)
        return E_FAIL;

    //Ok, everything looks OK, try to setup a connection point.
    // Setup to get WebBrowserEvents
    return ConnectToConnectionPoint(pUnk,
                                    DIID_DWebBrowserEvents2,
                                    FALSE,
                                    (IUnknown*)m_lpWebBrowser,
                                    &m_dwcpCookie,
                                    NULL);
}

HRESULT CObWebBrowser::SetExternalInterface(IUnknown* pUnk)
{
    m_pOleSite->SetExternalInterface((IDispatch*)pUnk);

    return S_OK;
}
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//////  Methods
//////
//////
//////

/////////////////////////////////////////////////////////////
// CObWebBrowser::CloseOleObject
void CObWebBrowser::CloseOleObject (void)
{
    if (m_lpOleObject)
    {
       if (m_fInPlaceActive)
       {
            LPOLEINPLACEOBJECT lpObject     = NULL;
            LPVIEWOBJECT       lpViewObject = NULL;

            m_lpOleObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&lpObject);
            lpObject->UIDeactivate();

            // don't need to worry about inside-out because the object
            // is going away.
            lpObject->InPlaceDeactivate();
            lpObject->Release();
       }
       m_lpOleObject->Close(OLECLOSE_NOSAVE);
       m_hMainWnd         = NULL;
       m_pOleSite->m_hWnd = NULL;;
    }
}

/////////////////////////////////////////////////////////////
// CObWebBrowser::InitBrowserObject
void CObWebBrowser::InitBrowserObject()
{
    // If we don't have a WebBrowser object to initialize, then bail
    if (!m_lpWebBrowser)
        return;

    // Get An OleObject from the WebBrowser Interface
    if(SUCCEEDED(m_lpWebBrowser->QueryInterface(IID_IOleObject, (LPVOID*)&m_lpOleObject)) && m_lpOleObject)
    {
        m_pOleSite->m_lpOleObject = m_lpOleObject;
        // inform object handler/DLL object that it is used in the embedding container's context
        OleSetContainedObject(m_lpOleObject, TRUE);

        // setup the client setup
        m_lpOleObject->SetClientSite(m_pOleSite->m_pOleClientSite);
    }
}


/////////////////////////////////////////////////////////////
// CObWebBrowser::InPlaceActivate
void CObWebBrowser::InPlaceActivate()
{
    RECT rect;

    m_lpOleObject->DoVerb( OLEIVERB_INPLACEACTIVATE,
                           NULL,
                           m_pOleSite->m_pOleClientSite,
                           -1,
                           m_hMainWnd,
                           &rect);
}

/////////////////////////////////////////////////////////////
// CObWebBrowser::UIActivate
void CObWebBrowser::UIActivate()
{
    RECT rect;

    m_lpOleObject->DoVerb( OLEIVERB_UIACTIVATE,
                           NULL,
                           m_pOleSite->m_pOleClientSite,
                           -1,
                           m_hMainWnd,
                           &rect);
}


/////////////////////////////////////////////////////////////
// CObWebBrowser::ShowWindow
HRESULT CObWebBrowser::ObWebShowWindow()
{
    RECT rect;

    m_lpOleObject->DoVerb( OLEIVERB_SHOW,
                           NULL,
                           m_pOleSite->m_pOleClientSite,
                           -1,
                           m_hMainWnd,
                           &rect);


    //InPlaceActivate();
    //UIActivate();

    return S_OK;
}

HRESULT CObWebBrowser::ConnectToConnectionPoint(IUnknown*          punkThis,
                                                REFIID             riidEvent,
                                                BOOL               fConnect,
                                                IUnknown*          punkTarget,
                                                DWORD*             pdwCookie,
                                                IConnectionPoint** ppcpOut)
{
    HRESULT hr = E_FAIL;
    IConnectionPointContainer* pcpContainer = NULL;

    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;

    if (SUCCEEDED(hr = punkTarget->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpContainer)))
    {
        IConnectionPoint *pcp;
        if(SUCCEEDED(hr = pcpContainer->FindConnectionPoint(riidEvent, &pcp)))
        {
            if(fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punkThis, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
                pcp = NULL;
        }
        pcpContainer->Release();
        pcpContainer = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\iosite.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  IOSITE.H - Header for the implementation of IOleSite
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Class which will provide the an IOleSite to the WebOC

#ifndef _IOSITE_H_ 
#define _IOSITE_H_

#include <mshtmhst.h>
#include <exdisp.h>

#include "iocsite.h"
#include "ioipsite.h"
#include "ioipfram.h"

class COleSite : public IServiceProvider, public IDocHostUIHandler, public DWebBrowserEvents2, public IInternetSecurityManager
{  
private:
    IDispatch* m_pExternalInterface;
    BOOL       m_fScrolling;
    BOOL       m_bIsOEMDebug;

public:
     COleSite();
    ~COleSite();
    
    ULONG                    m_cRef;
    HWND                     m_hWnd;
    HWND                     m_hwndIPObj;
    LPSTORAGE                m_lpStorage;
    LPOLEOBJECT              m_lpOleObject;
    LPOLEINPLACEOBJECT       m_lpInPlaceObject;
    BOOL                     m_fInPlaceActive;
    COleClientSite*          m_pOleClientSite;
    COleInPlaceSite*         m_pOleInPlaceSite;
    COleInPlaceFrame*        m_pOleInPlaceFrame;
    
    // IUnknown Interfaces
    STDMETHODIMP         QueryInterface (REFIID riid, LPVOID* ppvObj);
    STDMETHODIMP_(ULONG) AddRef         ();
    STDMETHODIMP_(ULONG) Release        ();

    // IServiceProvider
    STDMETHODIMP QueryService (REFGUID guidService, REFIID riid, void** ppvService);

    // IDocHostUIHandler
    HRESULT STDMETHODCALLTYPE ShowContextMenu       (DWORD dwID, POINT* ppt, IUnknown* pcmdtReserved, IDispatch* pdispReserved);
    HRESULT STDMETHODCALLTYPE GetHostInfo           (DOCHOSTUIINFO* pInfo);
    HRESULT STDMETHODCALLTYPE ShowUI                (DWORD dwID, IOleInPlaceActiveObject* pActiveObject, IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame, IOleInPlaceUIWindow* pDoc);
    HRESULT STDMETHODCALLTYPE HideUI                (void);
    HRESULT STDMETHODCALLTYPE UpdateUI              (void);
    HRESULT STDMETHODCALLTYPE EnableModeless        (BOOL fEnable);
    HRESULT STDMETHODCALLTYPE OnDocWindowActivate   (BOOL fActivate);
    HRESULT STDMETHODCALLTYPE OnFrameWindowActivate (BOOL fActivate);
    HRESULT STDMETHODCALLTYPE ResizeBorder          (LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fRameWindow);
    HRESULT STDMETHODCALLTYPE TranslateAccelerator  (LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID);
    HRESULT STDMETHODCALLTYPE GetOptionKeyPath      (BSTR* pbstrKey, DWORD dw);
    HRESULT STDMETHODCALLTYPE GetDropTarget         (IDropTarget* pDropTarget, IDropTarget** ppDropTarget);
    HRESULT STDMETHODCALLTYPE GetExternal           (IDispatch** ppDisp);
    HRESULT STDMETHODCALLTYPE TranslateUrl          (DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut);
    HRESULT STDMETHODCALLTYPE FilterDataObject      (IDataObject* pDO, IDataObject** ppDORet);
    HRESULT STDMETHODCALLTYPE SetExternalInterface  (IDispatch* pUnk);

    // DWebBrowserEvents2        
    STDMETHOD (GetTypeInfoCount) (UINT* pcInfo);
    STDMETHOD (GetTypeInfo)      (UINT, LCID, ITypeInfo**);
    STDMETHOD (GetIDsOfNames)    (REFIID, OLECHAR**, UINT, LCID, DISPID* );
    STDMETHOD (Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // IInternetSecurityManager

    HRESULT STDMETHODCALLTYPE SetSecuritySite(IInternetSecurityMgrSite __RPC_FAR *pSite); 
    HRESULT STDMETHODCALLTYPE GetSecuritySite(IInternetSecurityMgrSite __RPC_FAR *__RPC_FAR *ppSite);
    HRESULT STDMETHODCALLTYPE MapUrlToZone(LPCWSTR pwszUrl, DWORD __RPC_FAR *pdwZone, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE GetSecurityId(LPCWSTR pwszUrl, BYTE __RPC_FAR *pbSecurityId, DWORD __RPC_FAR *pcbSecurityId, DWORD_PTR dwReserved);
    HRESULT STDMETHODCALLTYPE ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE __RPC_FAR *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    HRESULT STDMETHODCALLTYPE QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE __RPC_FAR *__RPC_FAR *ppPolicy, DWORD __RPC_FAR *pcbPolicy, BYTE __RPC_FAR *pContext, DWORD cbContext, DWORD dwReserved);
    HRESULT STDMETHODCALLTYPE SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE GetZoneMappings(DWORD dwZone, IEnumString __RPC_FAR *__RPC_FAR *ppenumString, DWORD dwFlags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\oobebaln\resource.h ===
#define IDI_OOBEBALN_ICON                       200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msoobe\msoobe.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOOBE.H - WinMain and initialization code for MSOOBE stub EXE
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.

#ifndef _MSOOBE_H_
#define _MSOOBE_H_

#include <windows.h> 
#include <appdefs.h>

typedef BOOL (WINAPI *PFNMsObWinMain)(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow);

#define IDS_APPNAME      3000
#define IDS_SETUPFAILURE 3001
#endif //_MSOOBE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msoobe\msoobe.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  MSOOBE.CPP - WinMain and initialization code for MSOOBE stub EXE
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
  
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <util.h>
#include "msoobe.h"    
/*******************************************************************

    NAME:       WinMain

    SYNOPSIS:   App entry point

********************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    int iReturn = 0;
    int iCount = 0;

    PTEB pteb = NULL;
    WCHAR szLogfile[MAX_PATH];

    ExpandEnvironmentStrings(
                            L"%SystemRoot%\\system32\\oobe\\msoobe.err",
                            szLogfile,
                            sizeof(szLogfile)/sizeof(szLogfile[0]));
    //
    // call our DLL to run the OOBE
    //

    HINSTANCE hObMain;

    do
    {
        hObMain = LoadLibrary(OOBE_MAIN_DLL);
  
        if (hObMain)
        {
            iCount = 0;
            
            PFNMsObWinMain pfnWinMain = NULL;

            if (pfnWinMain = (PFNMsObWinMain)GetProcAddress(hObMain, MSOBMAIN_ENTRY))
            {
                iReturn = pfnWinMain(hInstance, hPrevInstance, GetCommandLine( ), nCmdShow);
            }
            FreeLibrary(hObMain);
        }
        else
        {
            TCHAR szMsg[256];
            TCHAR szCount[10];
            wsprintf(szMsg, TEXT("LoadLibrary(OOBE_MAIN_DLL) failed. GetLastError=%d"), GetLastError());
            wsprintf(szCount, L"Failure%d",iCount);
            WritePrivateProfileString(szCount, L"LoadLibrary", szMsg,szLogfile);

            pteb = NtCurrentTeb();
            if (pteb)
            {
                wsprintf(szMsg, TEXT("Teb.LastStatusValue = %lx"), pteb->LastStatusValue);
                WritePrivateProfileString(szCount, L"NtCurrentTeb" ,szMsg,szLogfile);
            }

            iCount++;


        }
    } while ((hObMain == NULL) && (iCount <= 10)); // && (iMsgRet == IDYES));

    if (iCount > 10)
    {
#define REGSTR_PATH_SYSTEMSETUPKEY  L"System\\Setup"
#define REGSTR_VALUE_SETUPTYPE      L"SetupType"
#define REGSTR_VALUE_SHUTDOWNREQUIRED L"SetupShutdownRequired"
        HKEY hKey;
        // failed 10 times to LoadLibrary msobmain.dll, tell the user
        WCHAR szTitle [MAX_PATH] = L"\0";
        WCHAR szMsg   [MAX_PATH] = L"\0";
        DWORD dwValue = 2;

        // Make sure Winlogon starts us again.
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SYSTEMSETUPKEY,
                         0,KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
            RegSetValueEx(hKey, REGSTR_VALUE_SETUPTYPE, 0, REG_DWORD,
                         (BYTE*)&dwValue, sizeof(dwValue) );
            dwValue = ShutdownReboot;
            RegSetValueEx(hKey, REGSTR_VALUE_SHUTDOWNREQUIRED, 0,
                                 REG_DWORD, (BYTE*)&dwValue, sizeof(dwValue)
                                 );
        }
#ifdef PRERELEASE
        LoadString(GetModuleHandle(NULL), IDS_APPNAME, szTitle, MAX_PATH);
        LoadString(GetModuleHandle(NULL), IDS_SETUPFAILURE, szMsg, MAX_PATH);

        MessageBox(NULL, szMsg, szTitle,  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
#endif
    }

    ExitProcess(iReturn);
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\oobebaln\activate.cpp ===
#include <windows.h>
#include <shlobj.h>
#include <shellapi.h>
#include <comctrlp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <limits.h>
#include <mstask.h>

extern "C"
{
#include <winsta.h>
#include <syslib.h>
}
#include "appdefs.h"
#include "util.h"
#include "msg.h"

#include <Wininet.h>
#include <limits.h>
#include <activation.h>
#include <licdll.h>
#include <eslerr.h>
#include <LAModes.h>
#include <cherror.h>
#include <ldefines.h>

#define REGSTR_PATH_SYSTEMSETUPKEY  L"System\\Setup"
#define REGSTR_VALUE_CMDLINE        L"CmdLine"

ICOMLicenseAgent*        m_pLicenseAgent;
TCHAR   File[MAX_PATH];
TCHAR   msg[1024];

BOOL SaveProxySettings(LPTSTR ProxySave);
BOOL RestoreProxySettings(LPTSTR ProxySave);
BOOL ApplyProxySettings(LPTSTR ProxyPath);
void RemoveCmdline(HINSTANCE hInstance);

void OpenLogFile();
void WriteToLog(LPWSTR pszFormatString, ...);
void CloseLogFile();

void RemoveActivationShortCut()
{
    HINF hinf;
    hinf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    if(hinf != INVALID_HANDLE_VALUE)
    {

        if (SetupInstallFromInfSection(NULL,
                                       hinf,
                                       L"DEL_OOBE_ACTIVATE",
                                       SPINST_PROFILEITEMS , //SPINST_ALL,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL) != 0)
        {
            // Success
            WriteToLog(L"Remove Activation shortcut succeeded\r\n");
        }
        else
        {
            // Failure
            WriteToLog(L"Remove Activation shortcut failed. GetLastError=%1!ld!\r\n",GetLastError());
        }
        SetupCloseInfFile(hinf);

    }
}

HRESULT InitActivation()
{
    HRESULT hr = E_FAIL;
    //CoCreate LicenseAgent
    hr = CoCreateInstance(CLSID_COMLicenseAgent,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_ICOMLicenseAgent,
                               (LPVOID*)&m_pLicenseAgent);
    return hr;
}



HRESULT ActivationHandShake()
{
    DWORD   Status;
    DWORD   dwType;
    DWORD   Data;
    DWORD   cbData = sizeof(Data);


    MYASSERT( m_pLicenseAgent );
    if ( !m_pLicenseAgent ) {
        TRACE( L"License Agent is inaccessible" );
        WriteToLog(L"License Agent is inaccessible\r\n" );
        return ERR_ACT_INTERNAL_WINDOWS_ERR;
    }

    m_pLicenseAgent->Initialize(
        WINDOWSBPC,
        LA_MODE_ONLINE_CH,
        NULL,
        &Status
        );
    if ( Status != ERROR_SUCCESS ) {
        TRACE1( L"m_pLicenseAgent->Initialize() failed.  Error = %d", Status );
        WriteToLog(L"m_pLicenseAgent->Initialize() failed.  Error = %1!ld!\r\n", Status);
        return Status;
    }

    Status = m_pLicenseAgent->SetIsoLanguage( GetSystemDefaultLCID() );
    if ( Status != ERROR_SUCCESS ) {
        TRACE1( L"m_pLicenseAgent->SetIsoLanguage() failed.  Error = %d", Status );
        WriteToLog( L"m_pLicenseAgent->SetIsoLanguage() failed.  Error = %1!ld!\r\n", Status );
        return Status;
    }

    Status = m_pLicenseAgent->AsyncProcessHandshakeRequest( FALSE );

    return Status;
}


HRESULT ActivationLicenseRequest(BOOL bReissueLicense)
{
    DWORD   Status;

    if (bReissueLicense)
    {
        Status = m_pLicenseAgent->AsyncProcessReissueLicenseRequest();
    }
    else
    {
        Status = m_pLicenseAgent->AsyncProcessNewLicenseRequest();
    }

    if ( Status != ERROR_SUCCESS ) {
        TRACE1( L"m_pLicenseAgent->AsyncProcessXxxLicenseRequest() failed.  Error = %d", Status );
        WriteToLog(L"m_pLicenseAgent->AsyncProcessXxxLicenseRequest() failed.  Error = %1!ld!\r\n", Status);
    }

    return Status;
}


HRESULT WaitForActivationPhase()
{
    DWORD   Status;
    MSG msg;
    do
    {
        m_pLicenseAgent->GetAsyncProcessReturnCode( &Status );
        if( LA_ERR_REQUEST_IN_PROGRESS == Status )
        {
            Sleep(1000);
        }
    } while (LA_ERR_REQUEST_IN_PROGRESS == Status);

    return Status;
}

HRESULT DoActivationEx()
{
    static const WCHAR OOBE_HTTP_AGENT_NAME[] =  
        L"Mozilla/4.0 (compatible; MSIE 6.0b; Windows NT 5.1)";
    HRESULT hr = E_FAIL;
    DWORD   WPADaysLeft;
    DWORD   EvalDaysLeft;
    DWORD   dwValue = 1;
    BOOL    bReissueLicense = FALSE;
    DWORD   time = GetTickCount();
    HINTERNET hInternet = NULL;

    TRACE(L"DoActivation.");
    WriteToLog(L"DoActivation.\r\n");

    hInternet = InternetOpen(
            OOBE_HTTP_AGENT_NAME,
            PRE_CONFIG_INTERNET_ACCESS,
            NULL,
            NULL,
            0);
    if (!hInternet)
    {
        TRACE(L"InternetOpen Failed.");
        WriteToLog(L"InternetOpen Failed.\r\n");
    }
    else
    {
        if (!InternetSetOption(
            hInternet,
            INTERNET_OPTION_DISABLE_AUTODIAL,
            &dwValue,
            sizeof(DWORD)))
        {
            dwValue = GetLastError();
            TRACE1(L"InternetSetOption INTERNET_OPTION_DISABLE_AUTODIAL Failed. GetLastError=%1!lx!", dwValue);
            WriteToLog(L"InternetSetOption INTERNET_OPTION_DISABLE_AUTODIAL Failed. GetLastError=%1!lx!\r\n", dwValue);
        }
        else
        {
            hr = S_OK;
        }
    }

    if (hr == S_OK)
    {
        hr = InitActivation();
    }
    else
    {
        TRACE1(L"InitActivation failed with error code:%d.", hr);
        WriteToLog(L"InitActivation failed with error code:%1!ld!.\r\n", hr);
    }
    if (hr == S_OK)
    {
        hr = m_pLicenseAgent->GetExpirationInfo(
            &WPADaysLeft,
            &EvalDaysLeft
            );
        if ( hr == S_OK && WPADaysLeft != INT_MAX )
        {
            hr = ActivationHandShake();
            if (hr == S_OK)
            {
                hr = WaitForActivationPhase();
                TRACE1(L"ActivationHandShake returned with :%d.", hr);
                WriteToLog(L"ActivationHandShake returned with :%1!ld!.\r\n", hr);

                if ( hr == ESL_ERR_NEW_LICENSE ) {

                    bReissueLicense = FALSE;
                    hr = S_OK;
                } else if ( hr == ESL_ERR_ORW_REISSUE ) {

                    bReissueLicense = TRUE;
                    hr = S_OK;

                }
                if (hr == S_OK)
                {
                    hr = ActivationLicenseRequest(bReissueLicense);
                    if (hr == S_OK)
                    {
                        hr = WaitForActivationPhase();
                        TRACE1(L"ActivationLicenseRequest returned with :%d.", hr);
                        WriteToLog(L"ActivationLicenseRequest returned with :%1!ld!.\r\n", hr);
                        if (hr == S_OK)
                        {
                            RemoveActivationShortCut();
                        }
                    }
                    else
                    {
                        TRACE1(L"ActivationLicenseRequest failed with error code:%d.", hr);
                        WriteToLog(L"ActivationLicenseRequest failed with error code:%1!ld!.\r\n", hr);
                    }
                }
            }
            else
            {
                TRACE1(L"ActivationHandShake failed with error code:%d.", hr);
                WriteToLog(L"ActivationHandShake failed with error code:%1!ld!.\r\n", hr);
            }
        }
        else
        {
            TRACE(L"Product already activated.");
            WriteToLog(L"Product already activated.\r\n");
        }
    }
    TRACE(L"DoActivation is done.");
    WriteToLog(L"DoActivation is done.\r\n");

    time = GetTickCount() - time;
    WriteToLog(L"Activation took %1!ld! msec.\r\n", time);
    if (hInternet)
    {
        InternetCloseHandle(hInternet);
    }

    return hr;
}

HRESULT DoActivation(HINSTANCE hInstance)
{
    HRESULT hr = E_FAIL;
    WCHAR WinntPath[MAX_PATH];
    WCHAR ProxyPath[MAX_PATH];
    WCHAR ProxySave[MAX_PATH];
    WCHAR      Answer[50];
    BOOL    bSaveRestoreProxy = FALSE;

    // Need to see if we need to remove the CmdLine reg entry

    OpenLogFile();

    if(GetCanonicalizedPath(WinntPath, WINNT_INF_FILENAME))
    {
        // See if we should autoactivate
        if( GetPrivateProfileString( TEXT("Unattended"),
                                     TEXT("AutoActivate"),
                                     TEXT(""),
                                     Answer,
                                     sizeof(Answer)/sizeof(TCHAR),
                                     WinntPath ) && !lstrcmpi(Answer, YES_ANSWER))
        {
            // Check if there is a proxy section specified
            if( GetPrivateProfileString( TEXT("Unattended"),
                                         TEXT("ActivateProxy"),
                                         TEXT(""),
                                         Answer,
                                         sizeof(Answer)/sizeof(TCHAR),
                                         WinntPath ) )
            {
                // We have a section
                // Now we should create a temp file with the entries from that section
                // and pass them to iedkcs32.dll so that they can get applied to the registry
                // Before calling iedkcs32.dll save the registry
                if (GetOOBEPath(ProxyPath))
                {
                    WCHAR section[1024];
                    lstrcpy(ProxySave, ProxyPath);
                    lstrcat(ProxySave, L"\\oobeact.pry");

                    lstrcat(ProxyPath, L"\\oobeact.prx");
                    DeleteFile(ProxyPath);
                    // Read the proxy section
                    GetPrivateProfileSection(Answer, section, 1024, WinntPath);
                    // Write it to the temp file under section [Proxy]
                    WritePrivateProfileSection(TEXT("Proxy"), section, ProxyPath);
                    bSaveRestoreProxy = TRUE;
                    // Save the internet setting registry key
                    SaveProxySettings(ProxySave);
                    // Apply the settings
                    ApplyProxySettings(ProxyPath);

                    // Don't need the temp file for iedkcs32.dll any more.
                    DeleteFile(ProxyPath);
                }
                else
                {
                    WriteToLog(L"Cannot the path for OOBE\r\n");
                }
            }
            hr = DoActivationEx();
            if (bSaveRestoreProxy)
            {
                // Restore the internet settings registry key
                RestoreProxySettings(ProxySave);
                // Don;t need the file
                DeleteFile(ProxySave);
            }

        }
        else
        {
            WriteToLog(L"No AutoActivate in %1\r\n",WinntPath);
        }
    }
    else
    {
        WriteToLog(L"Cannot get the location for %1\r\n",WINNT_INF_FILENAME);
    }
    RemoveCmdline(hInstance);
    CloseLogFile();
    return hr;
}


BOOL SaveProxySettings(LPTSTR ProxySave)
{
    BOOL bRet = FALSE;
    HKEY hkey = NULL;
    HANDLE   Token;
    LUID     Luid;
    TOKEN_PRIVILEGES NewPrivileges;
    // Make sure the file does not exist.
    DeleteFile(ProxySave);
    if(OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token))
    {

        if(LookupPrivilegeValue(NULL,SE_BACKUP_NAME,&Luid))
        {
            NewPrivileges.PrivilegeCount = 1;
            NewPrivileges.Privileges[0].Luid = Luid;
            NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            AdjustTokenPrivileges(Token,FALSE,&NewPrivileges,0,NULL,NULL);
        }
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                    TEXT("Software\\Microsoft\\windows\\currentVersion\\Internet Settings"),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey) == ERROR_SUCCESS)
    {
        bRet = (RegSaveKey(hkey,ProxySave, NULL) == ERROR_SUCCESS);
        RegCloseKey(hkey);
    }
    WriteToLog(L"SaveProxySettings returned with :%1!ld!.\r\n", bRet);

    return bRet;
}

BOOL RestoreProxySettings(LPTSTR ProxySave)
{
    BOOL bRet = FALSE;
    HKEY hkey = NULL;
    HANDLE   Token;
    LUID     Luid;
    TOKEN_PRIVILEGES NewPrivileges;

    if(OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token))
    {

        if(LookupPrivilegeValue(NULL,SE_RESTORE_NAME,&Luid))
        {
            NewPrivileges.PrivilegeCount = 1;
            NewPrivileges.Privileges[0].Luid = Luid;
            NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            AdjustTokenPrivileges(Token,FALSE,&NewPrivileges,0,NULL,NULL);
        }
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                    TEXT("Software\\Microsoft\\windows\\currentVersion\\Internet Settings"),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey) == ERROR_SUCCESS)
    {
        bRet = (RegRestoreKey(hkey,
                          ProxySave,
                          REG_FORCE_RESTORE) == ERROR_SUCCESS);
        RegCloseKey(hkey);
    }
    WriteToLog(L"RestoreProxySettings returned with :%1!ld!.\r\n", bRet);
    return bRet;
}

BOOL ApplyProxySettings(LPTSTR ProxyPath)
{
    typedef     BOOL (*BRANDINTRAPROC) ( LPCSTR );
//  typedef     BOOL (*BRANDCLEANSTUBPROC) (HWND, HINSTANCE, LPCSTR, int);
    HMODULE     IedkHandle = NULL;
    BRANDINTRAPROC      BrandIntraProc;
//    BRANDCLEANSTUBPROC  BrandCleanStubProc;
    CHAR BrandingFileA[MAX_PATH];
    BOOL bRet = FALSE;

    __try {

        if( IedkHandle = LoadLibrary(L"IEDKCS32") )
        {

//            BrandCleanStubProc = (BRANDCLEANSTUBPROC) GetProcAddress(IedkHandle,"BrandCleanInstallStubs");
            BrandIntraProc =  (BRANDINTRAPROC) GetProcAddress(IedkHandle,"BrandIntra");
            if( BrandIntraProc )
            {
                if (!WideCharToMultiByte(
                                     CP_ACP,
                                     0,
                                     ProxyPath,
                                     -1,
                                     BrandingFileA,
                                     sizeof(BrandingFileA),
                                     NULL,
                                     NULL
                                     ))
                {
                    bRet = FALSE;

                }
                else
                {
//                    bRet = BrandCleanStubProc( NULL, NULL, "", 0);
//                    if( bRet )
                    {
                        bRet = BrandIntraProc( BrandingFileA );
                    }
                }
            }
            else
            {
                bRet = FALSE;
            }
            FreeLibrary(IedkHandle);
        }
        else
        {
            bRet = FALSE;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    WriteToLog(L"ApplyProxySettings returned with :%1!ld!.\r\n", bRet);
    return bRet;
}


HANDLE hLogFile = INVALID_HANDLE_VALUE;
void CloseLogFile()
{
    if (hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hLogFile);
        hLogFile = INVALID_HANDLE_VALUE;
    }
}
void OpenLogFile()
{
    WCHAR File[MAX_PATH];
    DWORD Result;

    if (hLogFile == INVALID_HANDLE_VALUE)
    {
        Result = GetWindowsDirectory( File, MAX_PATH );
        if(Result == 0)
        {
            return;
        }
        lstrcat(File,TEXT("\\oobeact.log"));
        hLogFile = CreateFile(
            File,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
            NULL
            );
    }
    return;
}

void WriteToLog(LPWSTR pszFormatString, ...)
{
    va_list args;
    LPWSTR pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (hLogFile != INVALID_HANDLE_VALUE)
    {
        va_start(args, pszFormatString);
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &args);
        if (pszFullErrMsg)
        {
            PSTR str;
            ULONG Bytes;
            Bytes = (wcslen( pszFullErrMsg )*2) + 4;

            str = (PSTR)malloc( Bytes );
            if (str)
            {
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pszFullErrMsg,
                    -1,
                    str,
                    Bytes,
                    NULL,
                    NULL
                    );


                WriteFile(hLogFile, str, lstrlenA(str), &dwBytesWritten, NULL);
                free(str);
            }
            LocalFree(pszFullErrMsg);
        }
    }
}

void RemoveCmdline(HINSTANCE hInstance)
{
    HKEY hkey;
    LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    REGSTR_PATH_SYSTEMSETUPKEY,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hkey
                                    );
    if (lRet == ERROR_SUCCESS)
    {
        WCHAR               rgchCommandLine[MAX_PATH + 1];
        DWORD               dwSize = sizeof(rgchCommandLine);
        LRESULT             lResult = RegQueryValueEx(
                                                hkey,
                                                REGSTR_VALUE_CMDLINE,
                                                0,
                                                NULL,
                                                (LPBYTE)rgchCommandLine,
                                                &dwSize
                                                );
        if (ERROR_SUCCESS == lResult)
        {
            WCHAR file[MAX_PATH];
            if (GetModuleFileName(hInstance, file, MAX_PATH) == 0)
            {
                lstrcpy(file, L"OOBEBALN");
            }

            // Check if oobebaln is on the cmd line
            if (StrStrI(rgchCommandLine, file) != NULL)
            {
                // Remove the entry
                RegDeleteValue(hkey,REGSTR_VALUE_CMDLINE);
            }
        }
        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobweb\wmp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu May 03 06:48:12 2001
 */
/* Compiler settings for wmp.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmp_h__
#define __wmp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMPErrorItem_FWD_DEFINED__
#define __IWMPErrorItem_FWD_DEFINED__
typedef interface IWMPErrorItem IWMPErrorItem;
#endif 	/* __IWMPErrorItem_FWD_DEFINED__ */


#ifndef __IWMPError_FWD_DEFINED__
#define __IWMPError_FWD_DEFINED__
typedef interface IWMPError IWMPError;
#endif 	/* __IWMPError_FWD_DEFINED__ */


#ifndef __IWMPMedia_FWD_DEFINED__
#define __IWMPMedia_FWD_DEFINED__
typedef interface IWMPMedia IWMPMedia;
#endif 	/* __IWMPMedia_FWD_DEFINED__ */


#ifndef __IWMPControls_FWD_DEFINED__
#define __IWMPControls_FWD_DEFINED__
typedef interface IWMPControls IWMPControls;
#endif 	/* __IWMPControls_FWD_DEFINED__ */


#ifndef __IWMPSettings_FWD_DEFINED__
#define __IWMPSettings_FWD_DEFINED__
typedef interface IWMPSettings IWMPSettings;
#endif 	/* __IWMPSettings_FWD_DEFINED__ */


#ifndef __IWMPClosedCaption_FWD_DEFINED__
#define __IWMPClosedCaption_FWD_DEFINED__
typedef interface IWMPClosedCaption IWMPClosedCaption;
#endif 	/* __IWMPClosedCaption_FWD_DEFINED__ */


#ifndef __IWMPPlaylist_FWD_DEFINED__
#define __IWMPPlaylist_FWD_DEFINED__
typedef interface IWMPPlaylist IWMPPlaylist;
#endif 	/* __IWMPPlaylist_FWD_DEFINED__ */


#ifndef __IWMPCdrom_FWD_DEFINED__
#define __IWMPCdrom_FWD_DEFINED__
typedef interface IWMPCdrom IWMPCdrom;
#endif 	/* __IWMPCdrom_FWD_DEFINED__ */


#ifndef __IWMPCdromCollection_FWD_DEFINED__
#define __IWMPCdromCollection_FWD_DEFINED__
typedef interface IWMPCdromCollection IWMPCdromCollection;
#endif 	/* __IWMPCdromCollection_FWD_DEFINED__ */


#ifndef __IWMPStringCollection_FWD_DEFINED__
#define __IWMPStringCollection_FWD_DEFINED__
typedef interface IWMPStringCollection IWMPStringCollection;
#endif 	/* __IWMPStringCollection_FWD_DEFINED__ */


#ifndef __IWMPMediaCollection_FWD_DEFINED__
#define __IWMPMediaCollection_FWD_DEFINED__
typedef interface IWMPMediaCollection IWMPMediaCollection;
#endif 	/* __IWMPMediaCollection_FWD_DEFINED__ */


#ifndef __IWMPPlaylistArray_FWD_DEFINED__
#define __IWMPPlaylistArray_FWD_DEFINED__
typedef interface IWMPPlaylistArray IWMPPlaylistArray;
#endif 	/* __IWMPPlaylistArray_FWD_DEFINED__ */


#ifndef __IWMPPlaylistCollection_FWD_DEFINED__
#define __IWMPPlaylistCollection_FWD_DEFINED__
typedef interface IWMPPlaylistCollection IWMPPlaylistCollection;
#endif 	/* __IWMPPlaylistCollection_FWD_DEFINED__ */


#ifndef __IWMPNetwork_FWD_DEFINED__
#define __IWMPNetwork_FWD_DEFINED__
typedef interface IWMPNetwork IWMPNetwork;
#endif 	/* __IWMPNetwork_FWD_DEFINED__ */


#ifndef __IWMPCore_FWD_DEFINED__
#define __IWMPCore_FWD_DEFINED__
typedef interface IWMPCore IWMPCore;
#endif 	/* __IWMPCore_FWD_DEFINED__ */


#ifndef __IWMPPlayer_FWD_DEFINED__
#define __IWMPPlayer_FWD_DEFINED__
typedef interface IWMPPlayer IWMPPlayer;
#endif 	/* __IWMPPlayer_FWD_DEFINED__ */


#ifndef __IWMPPlayer2_FWD_DEFINED__
#define __IWMPPlayer2_FWD_DEFINED__
typedef interface IWMPPlayer2 IWMPPlayer2;
#endif 	/* __IWMPPlayer2_FWD_DEFINED__ */


#ifndef __IWMPMedia2_FWD_DEFINED__
#define __IWMPMedia2_FWD_DEFINED__
typedef interface IWMPMedia2 IWMPMedia2;
#endif 	/* __IWMPMedia2_FWD_DEFINED__ */


#ifndef __IWMPControls2_FWD_DEFINED__
#define __IWMPControls2_FWD_DEFINED__
typedef interface IWMPControls2 IWMPControls2;
#endif 	/* __IWMPControls2_FWD_DEFINED__ */


#ifndef __IWMPDVD_FWD_DEFINED__
#define __IWMPDVD_FWD_DEFINED__
typedef interface IWMPDVD IWMPDVD;
#endif 	/* __IWMPDVD_FWD_DEFINED__ */


#ifndef __IWMPCore2_FWD_DEFINED__
#define __IWMPCore2_FWD_DEFINED__
typedef interface IWMPCore2 IWMPCore2;
#endif 	/* __IWMPCore2_FWD_DEFINED__ */


#ifndef __IWMPPlayer3_FWD_DEFINED__
#define __IWMPPlayer3_FWD_DEFINED__
typedef interface IWMPPlayer3 IWMPPlayer3;
#endif 	/* __IWMPPlayer3_FWD_DEFINED__ */


#ifndef ___WMPOCXEvents_FWD_DEFINED__
#define ___WMPOCXEvents_FWD_DEFINED__
typedef interface _WMPOCXEvents _WMPOCXEvents;
#endif 	/* ___WMPOCXEvents_FWD_DEFINED__ */


#ifndef __WMPOCX_FWD_DEFINED__
#define __WMPOCX_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPOCX WMPOCX;
#else
typedef struct WMPOCX WMPOCX;
#endif /* __cplusplus */

#endif 	/* __WMPOCX_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmp_0000 */
/* [local] */ 

typedef /* [public][helpstring] */ 
enum WMPOpenState
    {	wmposUndefined	= 0,
	wmposPlaylistChanging	= wmposUndefined + 1,
	wmposPlaylistLocating	= wmposPlaylistChanging + 1,
	wmposPlaylistConnecting	= wmposPlaylistLocating + 1,
	wmposPlaylistLoading	= wmposPlaylistConnecting + 1,
	wmposPlaylistOpening	= wmposPlaylistLoading + 1,
	wmposPlaylistOpenNoMedia	= wmposPlaylistOpening + 1,
	wmposPlaylistChanged	= wmposPlaylistOpenNoMedia + 1,
	wmposMediaChanging	= wmposPlaylistChanged + 1,
	wmposMediaLocating	= wmposMediaChanging + 1,
	wmposMediaConnecting	= wmposMediaLocating + 1,
	wmposMediaLoading	= wmposMediaConnecting + 1,
	wmposMediaOpening	= wmposMediaLoading + 1,
	wmposMediaOpen	= wmposMediaOpening + 1,
	wmposBeginCodecAcquisition	= wmposMediaOpen + 1,
	wmposEndCodecAcquisition	= wmposBeginCodecAcquisition + 1,
	wmposBeginLicenseAcquisition	= wmposEndCodecAcquisition + 1,
	wmposEndLicenseAcquisition	= wmposBeginLicenseAcquisition + 1,
	wmposBeginIndividualization	= wmposEndLicenseAcquisition + 1,
	wmposEndIndividualization	= wmposBeginIndividualization + 1,
	wmposMediaWaiting	= wmposEndIndividualization + 1,
	wmposOpeningUnknownURL	= wmposMediaWaiting + 1
    }	WMPOpenState;

typedef /* [public][helpstring] */ 
enum WMPPlayState
    {	wmppsUndefined	= 0,
	wmppsStopped	= wmppsUndefined + 1,
	wmppsPaused	= wmppsStopped + 1,
	wmppsPlaying	= wmppsPaused + 1,
	wmppsScanForward	= wmppsPlaying + 1,
	wmppsScanReverse	= wmppsScanForward + 1,
	wmppsBuffering	= wmppsScanReverse + 1,
	wmppsWaiting	= wmppsBuffering + 1,
	wmppsMediaEnded	= wmppsWaiting + 1,
	wmppsTransitioning	= wmppsMediaEnded + 1,
	wmppsReady	= wmppsTransitioning + 1
    }	WMPPlayState;

typedef /* [public][helpstring] */ 
enum WMPPlaylistChangeEventType
    {	wmplcUnknown	= 0,
	wmplcClear	= wmplcUnknown + 1,
	wmplcInfoChange	= wmplcClear + 1,
	wmplcMove	= wmplcInfoChange + 1,
	wmplcDelete	= wmplcMove + 1,
	wmplcInsert	= wmplcDelete + 1,
	wmplcAppend	= wmplcInsert + 1,
	wmplcPrivate	= wmplcAppend + 1,
	wmplcNameChange	= wmplcPrivate + 1,
	wmplcMorph	= wmplcNameChange + 1,
	wmplcLast	= wmplcMorph + 1
    }	WMPPlaylistChangeEventType;




extern RPC_IF_HANDLE __MIDL_itf_wmp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmp_0000_v0_0_s_ifspec;

#ifndef __IWMPErrorItem_INTERFACE_DEFINED__
#define __IWMPErrorItem_INTERFACE_DEFINED__

/* interface IWMPErrorItem */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3614C646-3B3B-4de7-A81E-930E3F2127B3")
    IWMPErrorItem : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_errorCode( 
            /* [retval][out] */ long __RPC_FAR *phr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_errorDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_errorContext( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarContext) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_remedy( 
            /* [retval][out] */ long __RPC_FAR *plRemedy) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_customUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCustomUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPErrorItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPErrorItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_errorCode )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_errorDescription )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_errorContext )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarContext);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_remedy )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plRemedy);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_customUrl )( 
            IWMPErrorItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCustomUrl);
        
        END_INTERFACE
    } IWMPErrorItemVtbl;

    interface IWMPErrorItem
    {
        CONST_VTBL struct IWMPErrorItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPErrorItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPErrorItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPErrorItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPErrorItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPErrorItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPErrorItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPErrorItem_get_errorCode(This,phr)	\
    (This)->lpVtbl -> get_errorCode(This,phr)

#define IWMPErrorItem_get_errorDescription(This,pbstrDescription)	\
    (This)->lpVtbl -> get_errorDescription(This,pbstrDescription)

#define IWMPErrorItem_get_errorContext(This,pvarContext)	\
    (This)->lpVtbl -> get_errorContext(This,pvarContext)

#define IWMPErrorItem_get_remedy(This,plRemedy)	\
    (This)->lpVtbl -> get_remedy(This,plRemedy)

#define IWMPErrorItem_get_customUrl(This,pbstrCustomUrl)	\
    (This)->lpVtbl -> get_customUrl(This,pbstrCustomUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPErrorItem_get_errorCode_Proxy( 
    IWMPErrorItem __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *phr);


void __RPC_STUB IWMPErrorItem_get_errorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPErrorItem_get_errorDescription_Proxy( 
    IWMPErrorItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IWMPErrorItem_get_errorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPErrorItem_get_errorContext_Proxy( 
    IWMPErrorItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarContext);


void __RPC_STUB IWMPErrorItem_get_errorContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPErrorItem_get_remedy_Proxy( 
    IWMPErrorItem __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plRemedy);


void __RPC_STUB IWMPErrorItem_get_remedy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPErrorItem_get_customUrl_Proxy( 
    IWMPErrorItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCustomUrl);


void __RPC_STUB IWMPErrorItem_get_customUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPErrorItem_INTERFACE_DEFINED__ */


#ifndef __IWMPError_INTERFACE_DEFINED__
#define __IWMPError_INTERFACE_DEFINED__

/* interface IWMPError */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A12DCF7D-14AB-4c1b-A8CD-63909F06025B")
    IWMPError : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clearErrorQueue( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_errorCount( 
            /* [retval][out] */ long __RPC_FAR *plNumErrors) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE webHelp( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clearErrorQueue )( 
            IWMPError __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_errorCount )( 
            IWMPError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plNumErrors);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_item )( 
            IWMPError __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *webHelp )( 
            IWMPError __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPErrorVtbl;

    interface IWMPError
    {
        CONST_VTBL struct IWMPErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPError_clearErrorQueue(This)	\
    (This)->lpVtbl -> clearErrorQueue(This)

#define IWMPError_get_errorCount(This,plNumErrors)	\
    (This)->lpVtbl -> get_errorCount(This,plNumErrors)

#define IWMPError_get_item(This,dwIndex,ppErrorItem)	\
    (This)->lpVtbl -> get_item(This,dwIndex,ppErrorItem)

#define IWMPError_webHelp(This)	\
    (This)->lpVtbl -> webHelp(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPError_clearErrorQueue_Proxy( 
    IWMPError __RPC_FAR * This);


void __RPC_STUB IWMPError_clearErrorQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPError_get_errorCount_Proxy( 
    IWMPError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plNumErrors);


void __RPC_STUB IWMPError_get_errorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPError_get_item_Proxy( 
    IWMPError __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [retval][out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem);


void __RPC_STUB IWMPError_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPError_webHelp_Proxy( 
    IWMPError __RPC_FAR * This);


void __RPC_STUB IWMPError_webHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPError_INTERFACE_DEFINED__ */


#ifndef __IWMPMedia_INTERFACE_DEFINED__
#define __IWMPMedia_INTERFACE_DEFINED__

/* interface IWMPMedia */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPMedia;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94D55E95-3FAC-11d3-B155-00C04F79FAA6")
    IWMPMedia : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isIdentical( 
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_sourceURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_imageSourceWidth( 
            /* [retval][out] */ long __RPC_FAR *pWidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_imageSourceHeight( 
            /* [retval][out] */ long __RPC_FAR *pHeight) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_markerCount( 
            /* [retval][out] */ long __RPC_FAR *pMarkerCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getMarkerTime( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double __RPC_FAR *pMarkerTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getMarkerName( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_duration( 
            /* [retval][out] */ double __RPC_FAR *pDuration) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_durationString( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDuration) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_attributeCount( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttributeName( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrItemName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getItemInfo( 
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setItemInfo( 
            /* [in] */ BSTR bstrItemName,
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getItemInfoByAtom( 
            /* [in] */ long lAtom,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE isMemberOf( 
            /* [in] */ IWMPPlaylist __RPC_FAR *pPlaylist,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsMemberOf) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE isReadOnlyItem( 
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsReadOnly) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPMediaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPMedia __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPMedia __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPMedia __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isIdentical )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_sourceURL )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_imageSourceWidth )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_imageSourceHeight )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHeight);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_markerCount )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMarkerCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getMarkerTime )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double __RPC_FAR *pMarkerTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getMarkerName )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_duration )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pDuration);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_durationString )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDuration);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributeCount )( 
            IWMPMedia __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttributeName )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrItemName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getItemInfo )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setItemInfo )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ BSTR bstrItemName,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getItemInfoByAtom )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ long lAtom,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isMemberOf )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pPlaylist,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsMemberOf);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isReadOnlyItem )( 
            IWMPMedia __RPC_FAR * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsReadOnly);
        
        END_INTERFACE
    } IWMPMediaVtbl;

    interface IWMPMedia
    {
        CONST_VTBL struct IWMPMediaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPMedia_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPMedia_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPMedia_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPMedia_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPMedia_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPMedia_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPMedia_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPMedia_get_isIdentical(This,pIWMPMedia,pvbool)	\
    (This)->lpVtbl -> get_isIdentical(This,pIWMPMedia,pvbool)

#define IWMPMedia_get_sourceURL(This,pbstrSourceURL)	\
    (This)->lpVtbl -> get_sourceURL(This,pbstrSourceURL)

#define IWMPMedia_get_name(This,pbstrName)	\
    (This)->lpVtbl -> get_name(This,pbstrName)

#define IWMPMedia_put_name(This,bstrName)	\
    (This)->lpVtbl -> put_name(This,bstrName)

#define IWMPMedia_get_imageSourceWidth(This,pWidth)	\
    (This)->lpVtbl -> get_imageSourceWidth(This,pWidth)

#define IWMPMedia_get_imageSourceHeight(This,pHeight)	\
    (This)->lpVtbl -> get_imageSourceHeight(This,pHeight)

#define IWMPMedia_get_markerCount(This,pMarkerCount)	\
    (This)->lpVtbl -> get_markerCount(This,pMarkerCount)

#define IWMPMedia_getMarkerTime(This,MarkerNum,pMarkerTime)	\
    (This)->lpVtbl -> getMarkerTime(This,MarkerNum,pMarkerTime)

#define IWMPMedia_getMarkerName(This,MarkerNum,pbstrMarkerName)	\
    (This)->lpVtbl -> getMarkerName(This,MarkerNum,pbstrMarkerName)

#define IWMPMedia_get_duration(This,pDuration)	\
    (This)->lpVtbl -> get_duration(This,pDuration)

#define IWMPMedia_get_durationString(This,pbstrDuration)	\
    (This)->lpVtbl -> get_durationString(This,pbstrDuration)

#define IWMPMedia_get_attributeCount(This,plCount)	\
    (This)->lpVtbl -> get_attributeCount(This,plCount)

#define IWMPMedia_getAttributeName(This,lIndex,pbstrItemName)	\
    (This)->lpVtbl -> getAttributeName(This,lIndex,pbstrItemName)

#define IWMPMedia_getItemInfo(This,bstrItemName,pbstrVal)	\
    (This)->lpVtbl -> getItemInfo(This,bstrItemName,pbstrVal)

#define IWMPMedia_setItemInfo(This,bstrItemName,bstrVal)	\
    (This)->lpVtbl -> setItemInfo(This,bstrItemName,bstrVal)

#define IWMPMedia_getItemInfoByAtom(This,lAtom,pbstrVal)	\
    (This)->lpVtbl -> getItemInfoByAtom(This,lAtom,pbstrVal)

#define IWMPMedia_isMemberOf(This,pPlaylist,pvarfIsMemberOf)	\
    (This)->lpVtbl -> isMemberOf(This,pPlaylist,pvarfIsMemberOf)

#define IWMPMedia_isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly)	\
    (This)->lpVtbl -> isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_isIdentical_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvbool);


void __RPC_STUB IWMPMedia_get_isIdentical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_sourceURL_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceURL);


void __RPC_STUB IWMPMedia_get_sourceURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_name_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IWMPMedia_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_put_name_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IWMPMedia_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_imageSourceWidth_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pWidth);


void __RPC_STUB IWMPMedia_get_imageSourceWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_imageSourceHeight_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHeight);


void __RPC_STUB IWMPMedia_get_imageSourceHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_markerCount_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMarkerCount);


void __RPC_STUB IWMPMedia_get_markerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_getMarkerTime_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ double __RPC_FAR *pMarkerTime);


void __RPC_STUB IWMPMedia_getMarkerTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_getMarkerName_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName);


void __RPC_STUB IWMPMedia_getMarkerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_duration_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pDuration);


void __RPC_STUB IWMPMedia_get_duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_durationString_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDuration);


void __RPC_STUB IWMPMedia_get_durationString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_get_attributeCount_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IWMPMedia_get_attributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_getAttributeName_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrItemName);


void __RPC_STUB IWMPMedia_getAttributeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_getItemInfo_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ BSTR bstrItemName,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);


void __RPC_STUB IWMPMedia_getItemInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_setItemInfo_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ BSTR bstrItemName,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IWMPMedia_setItemInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_getItemInfoByAtom_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ long lAtom,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);


void __RPC_STUB IWMPMedia_getItemInfoByAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_isMemberOf_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ IWMPPlaylist __RPC_FAR *pPlaylist,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsMemberOf);


void __RPC_STUB IWMPMedia_isMemberOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia_isReadOnlyItem_Proxy( 
    IWMPMedia __RPC_FAR * This,
    /* [in] */ BSTR bstrItemName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsReadOnly);


void __RPC_STUB IWMPMedia_isReadOnlyItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPMedia_INTERFACE_DEFINED__ */


#ifndef __IWMPControls_INTERFACE_DEFINED__
#define __IWMPControls_INTERFACE_DEFINED__

/* interface IWMPControls */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPControls;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74C09E02-F828-11d2-A74B-00A0C905F36E")
    IWMPControls : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isAvailable( 
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE play( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE stop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE fastForward( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE fastReverse( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_currentPosition( 
            /* [retval][out] */ double __RPC_FAR *pdCurrentPosition) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_currentPosition( 
            /* [in] */ double dCurrentPosition) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_currentPositionString( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCurrentPosition) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE next( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE previous( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_currentItem( 
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppIWMPMedia) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentItem( 
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_currentMarker( 
            /* [retval][out] */ long __RPC_FAR *plMarker) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_currentMarker( 
            /* [in] */ long lMarker) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE playItem( 
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPControlsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPControls __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPControls __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPControls __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isAvailable )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *play )( 
            IWMPControls __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *stop )( 
            IWMPControls __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *pause )( 
            IWMPControls __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *fastForward )( 
            IWMPControls __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *fastReverse )( 
            IWMPControls __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPosition )( 
            IWMPControls __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pdCurrentPosition);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPosition )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ double dCurrentPosition);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPositionString )( 
            IWMPControls __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCurrentPosition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *next )( 
            IWMPControls __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *previous )( 
            IWMPControls __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentItem )( 
            IWMPControls __RPC_FAR * This,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppIWMPMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentItem )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentMarker )( 
            IWMPControls __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMarker);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentMarker )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ long lMarker);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *playItem )( 
            IWMPControls __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);
        
        END_INTERFACE
    } IWMPControlsVtbl;

    interface IWMPControls
    {
        CONST_VTBL struct IWMPControlsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPControls_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPControls_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPControls_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPControls_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPControls_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPControls_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPControls_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPControls_get_isAvailable(This,bstrItem,pIsAvailable)	\
    (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable)

#define IWMPControls_play(This)	\
    (This)->lpVtbl -> play(This)

#define IWMPControls_stop(This)	\
    (This)->lpVtbl -> stop(This)

#define IWMPControls_pause(This)	\
    (This)->lpVtbl -> pause(This)

#define IWMPControls_fastForward(This)	\
    (This)->lpVtbl -> fastForward(This)

#define IWMPControls_fastReverse(This)	\
    (This)->lpVtbl -> fastReverse(This)

#define IWMPControls_get_currentPosition(This,pdCurrentPosition)	\
    (This)->lpVtbl -> get_currentPosition(This,pdCurrentPosition)

#define IWMPControls_put_currentPosition(This,dCurrentPosition)	\
    (This)->lpVtbl -> put_currentPosition(This,dCurrentPosition)

#define IWMPControls_get_currentPositionString(This,pbstrCurrentPosition)	\
    (This)->lpVtbl -> get_currentPositionString(This,pbstrCurrentPosition)

#define IWMPControls_next(This)	\
    (This)->lpVtbl -> next(This)

#define IWMPControls_previous(This)	\
    (This)->lpVtbl -> previous(This)

#define IWMPControls_get_currentItem(This,ppIWMPMedia)	\
    (This)->lpVtbl -> get_currentItem(This,ppIWMPMedia)

#define IWMPControls_put_currentItem(This,pIWMPMedia)	\
    (This)->lpVtbl -> put_currentItem(This,pIWMPMedia)

#define IWMPControls_get_currentMarker(This,plMarker)	\
    (This)->lpVtbl -> get_currentMarker(This,plMarker)

#define IWMPControls_put_currentMarker(This,lMarker)	\
    (This)->lpVtbl -> put_currentMarker(This,lMarker)

#define IWMPControls_playItem(This,pIWMPMedia)	\
    (This)->lpVtbl -> playItem(This,pIWMPMedia)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_get_isAvailable_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [in] */ BSTR bstrItem,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable);


void __RPC_STUB IWMPControls_get_isAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_play_Proxy( 
    IWMPControls __RPC_FAR * This);


void __RPC_STUB IWMPControls_play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_stop_Proxy( 
    IWMPControls __RPC_FAR * This);


void __RPC_STUB IWMPControls_stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_pause_Proxy( 
    IWMPControls __RPC_FAR * This);


void __RPC_STUB IWMPControls_pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_fastForward_Proxy( 
    IWMPControls __RPC_FAR * This);


void __RPC_STUB IWMPControls_fastForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_fastReverse_Proxy( 
    IWMPControls __RPC_FAR * This);


void __RPC_STUB IWMPControls_fastReverse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_get_currentPosition_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pdCurrentPosition);


void __RPC_STUB IWMPControls_get_currentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_put_currentPosition_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [in] */ double dCurrentPosition);


void __RPC_STUB IWMPControls_put_currentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_get_currentPositionString_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCurrentPosition);


void __RPC_STUB IWMPControls_get_currentPositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_next_Proxy( 
    IWMPControls __RPC_FAR * This);


void __RPC_STUB IWMPControls_next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_previous_Proxy( 
    IWMPControls __RPC_FAR * This);


void __RPC_STUB IWMPControls_previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_get_currentItem_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppIWMPMedia);


void __RPC_STUB IWMPControls_get_currentItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_put_currentItem_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);


void __RPC_STUB IWMPControls_put_currentItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_get_currentMarker_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMarker);


void __RPC_STUB IWMPControls_get_currentMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_put_currentMarker_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [in] */ long lMarker);


void __RPC_STUB IWMPControls_put_currentMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls_playItem_Proxy( 
    IWMPControls __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);


void __RPC_STUB IWMPControls_playItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPControls_INTERFACE_DEFINED__ */


#ifndef __IWMPSettings_INTERFACE_DEFINED__
#define __IWMPSettings_INTERFACE_DEFINED__

/* interface IWMPSettings */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9104D1AB-80C9-4fed-ABF0-2E6417A6DF14")
    IWMPSettings : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isAvailable( 
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_autoStart( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfAutoStart) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_autoStart( 
            /* [in] */ VARIANT_BOOL fAutoStart) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_baseURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_baseURL( 
            /* [in] */ BSTR bstrBaseURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_defaultFrame( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_defaultFrame( 
            /* [in] */ BSTR bstrDefaultFrame) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_invokeURLs( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfInvokeURLs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_invokeURLs( 
            /* [in] */ VARIANT_BOOL fInvokeURLs) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_mute( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMute) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_mute( 
            /* [in] */ VARIANT_BOOL fMute) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_playCount( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_playCount( 
            /* [in] */ long lCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_rate( 
            /* [retval][out] */ double __RPC_FAR *pdRate) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_rate( 
            /* [in] */ double dRate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_balance( 
            /* [retval][out] */ long __RPC_FAR *plBalance) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_volume( 
            /* [retval][out] */ long __RPC_FAR *plVolume) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getMode( 
            /* [in] */ BSTR bstrMode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setMode( 
            /* [in] */ BSTR bstrMode,
            /* [in] */ VARIANT_BOOL varfMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_enableErrorDialogs( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnableErrorDialogs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_enableErrorDialogs( 
            /* [in] */ VARIANT_BOOL fEnableErrorDialogs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPSettings __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPSettings __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPSettings __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isAvailable )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_autoStart )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfAutoStart);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_autoStart )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fAutoStart);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseURL )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_baseURL )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_defaultFrame )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_defaultFrame )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_invokeURLs )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfInvokeURLs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_invokeURLs )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fInvokeURLs);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mute )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMute);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_mute )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fMute);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playCount )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_playCount )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ long lCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_rate )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pdRate);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_rate )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ double dRate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_balance )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBalance);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_balance )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ long lBalance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_volume )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVolume);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_volume )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ long lVolume);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getMode )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ BSTR bstrMode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setMode )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ BSTR bstrMode,
            /* [in] */ VARIANT_BOOL varfMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enableErrorDialogs )( 
            IWMPSettings __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnableErrorDialogs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enableErrorDialogs )( 
            IWMPSettings __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fEnableErrorDialogs);
        
        END_INTERFACE
    } IWMPSettingsVtbl;

    interface IWMPSettings
    {
        CONST_VTBL struct IWMPSettingsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPSettings_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPSettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPSettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPSettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPSettings_get_isAvailable(This,bstrItem,pIsAvailable)	\
    (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable)

#define IWMPSettings_get_autoStart(This,pfAutoStart)	\
    (This)->lpVtbl -> get_autoStart(This,pfAutoStart)

#define IWMPSettings_put_autoStart(This,fAutoStart)	\
    (This)->lpVtbl -> put_autoStart(This,fAutoStart)

#define IWMPSettings_get_baseURL(This,pbstrBaseURL)	\
    (This)->lpVtbl -> get_baseURL(This,pbstrBaseURL)

#define IWMPSettings_put_baseURL(This,bstrBaseURL)	\
    (This)->lpVtbl -> put_baseURL(This,bstrBaseURL)

#define IWMPSettings_get_defaultFrame(This,pbstrDefaultFrame)	\
    (This)->lpVtbl -> get_defaultFrame(This,pbstrDefaultFrame)

#define IWMPSettings_put_defaultFrame(This,bstrDefaultFrame)	\
    (This)->lpVtbl -> put_defaultFrame(This,bstrDefaultFrame)

#define IWMPSettings_get_invokeURLs(This,pfInvokeURLs)	\
    (This)->lpVtbl -> get_invokeURLs(This,pfInvokeURLs)

#define IWMPSettings_put_invokeURLs(This,fInvokeURLs)	\
    (This)->lpVtbl -> put_invokeURLs(This,fInvokeURLs)

#define IWMPSettings_get_mute(This,pfMute)	\
    (This)->lpVtbl -> get_mute(This,pfMute)

#define IWMPSettings_put_mute(This,fMute)	\
    (This)->lpVtbl -> put_mute(This,fMute)

#define IWMPSettings_get_playCount(This,plCount)	\
    (This)->lpVtbl -> get_playCount(This,plCount)

#define IWMPSettings_put_playCount(This,lCount)	\
    (This)->lpVtbl -> put_playCount(This,lCount)

#define IWMPSettings_get_rate(This,pdRate)	\
    (This)->lpVtbl -> get_rate(This,pdRate)

#define IWMPSettings_put_rate(This,dRate)	\
    (This)->lpVtbl -> put_rate(This,dRate)

#define IWMPSettings_get_balance(This,plBalance)	\
    (This)->lpVtbl -> get_balance(This,plBalance)

#define IWMPSettings_put_balance(This,lBalance)	\
    (This)->lpVtbl -> put_balance(This,lBalance)

#define IWMPSettings_get_volume(This,plVolume)	\
    (This)->lpVtbl -> get_volume(This,plVolume)

#define IWMPSettings_put_volume(This,lVolume)	\
    (This)->lpVtbl -> put_volume(This,lVolume)

#define IWMPSettings_getMode(This,bstrMode,pvarfMode)	\
    (This)->lpVtbl -> getMode(This,bstrMode,pvarfMode)

#define IWMPSettings_setMode(This,bstrMode,varfMode)	\
    (This)->lpVtbl -> setMode(This,bstrMode,varfMode)

#define IWMPSettings_get_enableErrorDialogs(This,pfEnableErrorDialogs)	\
    (This)->lpVtbl -> get_enableErrorDialogs(This,pfEnableErrorDialogs)

#define IWMPSettings_put_enableErrorDialogs(This,fEnableErrorDialogs)	\
    (This)->lpVtbl -> put_enableErrorDialogs(This,fEnableErrorDialogs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_isAvailable_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ BSTR bstrItem,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable);


void __RPC_STUB IWMPSettings_get_isAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_autoStart_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfAutoStart);


void __RPC_STUB IWMPSettings_get_autoStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_autoStart_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fAutoStart);


void __RPC_STUB IWMPSettings_put_autoStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_baseURL_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL);


void __RPC_STUB IWMPSettings_get_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_baseURL_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ BSTR bstrBaseURL);


void __RPC_STUB IWMPSettings_put_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_defaultFrame_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame);


void __RPC_STUB IWMPSettings_get_defaultFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_defaultFrame_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ BSTR bstrDefaultFrame);


void __RPC_STUB IWMPSettings_put_defaultFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_invokeURLs_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfInvokeURLs);


void __RPC_STUB IWMPSettings_get_invokeURLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_invokeURLs_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fInvokeURLs);


void __RPC_STUB IWMPSettings_put_invokeURLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_mute_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMute);


void __RPC_STUB IWMPSettings_get_mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_mute_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fMute);


void __RPC_STUB IWMPSettings_put_mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_playCount_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IWMPSettings_get_playCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_playCount_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ long lCount);


void __RPC_STUB IWMPSettings_put_playCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_rate_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pdRate);


void __RPC_STUB IWMPSettings_get_rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_rate_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ double dRate);


void __RPC_STUB IWMPSettings_put_rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_balance_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBalance);


void __RPC_STUB IWMPSettings_get_balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_balance_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ long lBalance);


void __RPC_STUB IWMPSettings_put_balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_volume_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVolume);


void __RPC_STUB IWMPSettings_get_volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_volume_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ long lVolume);


void __RPC_STUB IWMPSettings_put_volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_getMode_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ BSTR bstrMode,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfMode);


void __RPC_STUB IWMPSettings_getMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_setMode_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ BSTR bstrMode,
    /* [in] */ VARIANT_BOOL varfMode);


void __RPC_STUB IWMPSettings_setMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_get_enableErrorDialogs_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnableErrorDialogs);


void __RPC_STUB IWMPSettings_get_enableErrorDialogs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPSettings_put_enableErrorDialogs_Proxy( 
    IWMPSettings __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fEnableErrorDialogs);


void __RPC_STUB IWMPSettings_put_enableErrorDialogs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPSettings_INTERFACE_DEFINED__ */


#ifndef __IWMPClosedCaption_INTERFACE_DEFINED__
#define __IWMPClosedCaption_INTERFACE_DEFINED__

/* interface IWMPClosedCaption */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPClosedCaption;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F2DF574-C588-11d3-9ED0-00C04FB6E937")
    IWMPClosedCaption : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMIStyle) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIStyle( 
            /* [in] */ BSTR bstrSAMIStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMILang( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMILang) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMILang( 
            /* [in] */ BSTR bstrSAMILang) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIFileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMIFileName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIFileName( 
            /* [in] */ BSTR bstrSAMIFileName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_captioningId( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaptioningID) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_captioningId( 
            /* [in] */ BSTR bstrCaptioningID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPClosedCaptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPClosedCaption __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPClosedCaption __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMIStyle )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMIStyle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMIStyle )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ BSTR bstrSAMIStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMILang )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMILang);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMILang )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ BSTR bstrSAMILang);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMIFileName )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMIFileName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMIFileName )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ BSTR bstrSAMIFileName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_captioningId )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaptioningID);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_captioningId )( 
            IWMPClosedCaption __RPC_FAR * This,
            /* [in] */ BSTR bstrCaptioningID);
        
        END_INTERFACE
    } IWMPClosedCaptionVtbl;

    interface IWMPClosedCaption
    {
        CONST_VTBL struct IWMPClosedCaptionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPClosedCaption_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPClosedCaption_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPClosedCaption_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPClosedCaption_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPClosedCaption_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPClosedCaption_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPClosedCaption_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPClosedCaption_get_SAMIStyle(This,pbstrSAMIStyle)	\
    (This)->lpVtbl -> get_SAMIStyle(This,pbstrSAMIStyle)

#define IWMPClosedCaption_put_SAMIStyle(This,bstrSAMIStyle)	\
    (This)->lpVtbl -> put_SAMIStyle(This,bstrSAMIStyle)

#define IWMPClosedCaption_get_SAMILang(This,pbstrSAMILang)	\
    (This)->lpVtbl -> get_SAMILang(This,pbstrSAMILang)

#define IWMPClosedCaption_put_SAMILang(This,bstrSAMILang)	\
    (This)->lpVtbl -> put_SAMILang(This,bstrSAMILang)

#define IWMPClosedCaption_get_SAMIFileName(This,pbstrSAMIFileName)	\
    (This)->lpVtbl -> get_SAMIFileName(This,pbstrSAMIFileName)

#define IWMPClosedCaption_put_SAMIFileName(This,bstrSAMIFileName)	\
    (This)->lpVtbl -> put_SAMIFileName(This,bstrSAMIFileName)

#define IWMPClosedCaption_get_captioningId(This,pbstrCaptioningID)	\
    (This)->lpVtbl -> get_captioningId(This,pbstrCaptioningID)

#define IWMPClosedCaption_put_captioningId(This,bstrCaptioningID)	\
    (This)->lpVtbl -> put_captioningId(This,bstrCaptioningID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_get_SAMIStyle_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMIStyle);


void __RPC_STUB IWMPClosedCaption_get_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_put_SAMIStyle_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [in] */ BSTR bstrSAMIStyle);


void __RPC_STUB IWMPClosedCaption_put_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_get_SAMILang_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMILang);


void __RPC_STUB IWMPClosedCaption_get_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_put_SAMILang_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [in] */ BSTR bstrSAMILang);


void __RPC_STUB IWMPClosedCaption_put_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_get_SAMIFileName_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSAMIFileName);


void __RPC_STUB IWMPClosedCaption_get_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_put_SAMIFileName_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [in] */ BSTR bstrSAMIFileName);


void __RPC_STUB IWMPClosedCaption_put_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_get_captioningId_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaptioningID);


void __RPC_STUB IWMPClosedCaption_get_captioningId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPClosedCaption_put_captioningId_Proxy( 
    IWMPClosedCaption __RPC_FAR * This,
    /* [in] */ BSTR bstrCaptioningID);


void __RPC_STUB IWMPClosedCaption_put_captioningId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPClosedCaption_INTERFACE_DEFINED__ */


#ifndef __IWMPPlaylist_INTERFACE_DEFINED__
#define __IWMPPlaylist_INTERFACE_DEFINED__

/* interface IWMPPlaylist */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlaylist;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5F0F4F1-130C-11d3-B14E-00C04F79FAA6")
    IWMPPlaylist : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_attributeCount( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_attributeName( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAttributeName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            long lIndex,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppIWMPMedia) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getItemInfo( 
            BSTR bstrName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setItemInfo( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isIdentical( 
            /* [in] */ IWMPPlaylist __RPC_FAR *pIWMPPlaylist,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvbool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE insertItem( 
            /* [in] */ long lIndex,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE appendItem( 
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeItem( 
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE moveItem( 
            long lIndexOld,
            long lIndexNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlaylistVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPPlaylist __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPPlaylist __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributeCount )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributeName )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAttributeName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_item )( 
            IWMPPlaylist __RPC_FAR * This,
            long lIndex,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppIWMPMedia);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getItemInfo )( 
            IWMPPlaylist __RPC_FAR * This,
            BSTR bstrName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setItemInfo )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isIdentical )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pIWMPPlaylist,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvbool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clear )( 
            IWMPPlaylist __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertItem )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendItem )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeItem )( 
            IWMPPlaylist __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *moveItem )( 
            IWMPPlaylist __RPC_FAR * This,
            long lIndexOld,
            long lIndexNew);
        
        END_INTERFACE
    } IWMPPlaylistVtbl;

    interface IWMPPlaylist
    {
        CONST_VTBL struct IWMPPlaylistVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlaylist_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPPlaylist_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPPlaylist_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPPlaylist_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPPlaylist_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPPlaylist_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPPlaylist_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPPlaylist_get_count(This,plCount)	\
    (This)->lpVtbl -> get_count(This,plCount)

#define IWMPPlaylist_get_name(This,pbstrName)	\
    (This)->lpVtbl -> get_name(This,pbstrName)

#define IWMPPlaylist_put_name(This,bstrName)	\
    (This)->lpVtbl -> put_name(This,bstrName)

#define IWMPPlaylist_get_attributeCount(This,plCount)	\
    (This)->lpVtbl -> get_attributeCount(This,plCount)

#define IWMPPlaylist_get_attributeName(This,lIndex,pbstrAttributeName)	\
    (This)->lpVtbl -> get_attributeName(This,lIndex,pbstrAttributeName)

#define IWMPPlaylist_get_item(This,lIndex,ppIWMPMedia)	\
    (This)->lpVtbl -> get_item(This,lIndex,ppIWMPMedia)

#define IWMPPlaylist_getItemInfo(This,bstrName,pbstrVal)	\
    (This)->lpVtbl -> getItemInfo(This,bstrName,pbstrVal)

#define IWMPPlaylist_setItemInfo(This,bstrName,bstrValue)	\
    (This)->lpVtbl -> setItemInfo(This,bstrName,bstrValue)

#define IWMPPlaylist_get_isIdentical(This,pIWMPPlaylist,pvbool)	\
    (This)->lpVtbl -> get_isIdentical(This,pIWMPPlaylist,pvbool)

#define IWMPPlaylist_clear(This)	\
    (This)->lpVtbl -> clear(This)

#define IWMPPlaylist_insertItem(This,lIndex,pIWMPMedia)	\
    (This)->lpVtbl -> insertItem(This,lIndex,pIWMPMedia)

#define IWMPPlaylist_appendItem(This,pIWMPMedia)	\
    (This)->lpVtbl -> appendItem(This,pIWMPMedia)

#define IWMPPlaylist_removeItem(This,pIWMPMedia)	\
    (This)->lpVtbl -> removeItem(This,pIWMPMedia)

#define IWMPPlaylist_moveItem(This,lIndexOld,lIndexNew)	\
    (This)->lpVtbl -> moveItem(This,lIndexOld,lIndexNew)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_get_count_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IWMPPlaylist_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_get_name_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IWMPPlaylist_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_put_name_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IWMPPlaylist_put_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_get_attributeCount_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IWMPPlaylist_get_attributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_get_attributeName_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrAttributeName);


void __RPC_STUB IWMPPlaylist_get_attributeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_get_item_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    long lIndex,
    /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppIWMPMedia);


void __RPC_STUB IWMPPlaylist_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_getItemInfo_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    BSTR bstrName,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);


void __RPC_STUB IWMPPlaylist_getItemInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_setItemInfo_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWMPPlaylist_setItemInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_get_isIdentical_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [in] */ IWMPPlaylist __RPC_FAR *pIWMPPlaylist,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvbool);


void __RPC_STUB IWMPPlaylist_get_isIdentical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_clear_Proxy( 
    IWMPPlaylist __RPC_FAR * This);


void __RPC_STUB IWMPPlaylist_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_insertItem_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);


void __RPC_STUB IWMPPlaylist_insertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_appendItem_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);


void __RPC_STUB IWMPPlaylist_appendItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_removeItem_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);


void __RPC_STUB IWMPPlaylist_removeItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylist_moveItem_Proxy( 
    IWMPPlaylist __RPC_FAR * This,
    long lIndexOld,
    long lIndexNew);


void __RPC_STUB IWMPPlaylist_moveItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPPlaylist_INTERFACE_DEFINED__ */


#ifndef __IWMPCdrom_INTERFACE_DEFINED__
#define __IWMPCdrom_INTERFACE_DEFINED__

/* interface IWMPCdrom */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCdrom;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cfab6e98-8730-11d3-b388-00c04f68574b")
    IWMPCdrom : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_driveSpecifier( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDrive) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_playlist( 
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPlaylist) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE eject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCdromVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCdrom __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCdrom __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCdrom __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPCdrom __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPCdrom __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPCdrom __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPCdrom __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_driveSpecifier )( 
            IWMPCdrom __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDrive);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playlist )( 
            IWMPCdrom __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPlaylist);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *eject )( 
            IWMPCdrom __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPCdromVtbl;

    interface IWMPCdrom
    {
        CONST_VTBL struct IWMPCdromVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCdrom_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCdrom_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCdrom_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCdrom_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPCdrom_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPCdrom_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPCdrom_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPCdrom_get_driveSpecifier(This,pbstrDrive)	\
    (This)->lpVtbl -> get_driveSpecifier(This,pbstrDrive)

#define IWMPCdrom_get_playlist(This,ppPlaylist)	\
    (This)->lpVtbl -> get_playlist(This,ppPlaylist)

#define IWMPCdrom_eject(This)	\
    (This)->lpVtbl -> eject(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCdrom_get_driveSpecifier_Proxy( 
    IWMPCdrom __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDrive);


void __RPC_STUB IWMPCdrom_get_driveSpecifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCdrom_get_playlist_Proxy( 
    IWMPCdrom __RPC_FAR * This,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPlaylist);


void __RPC_STUB IWMPCdrom_get_playlist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPCdrom_eject_Proxy( 
    IWMPCdrom __RPC_FAR * This);


void __RPC_STUB IWMPCdrom_eject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCdrom_INTERFACE_DEFINED__ */


#ifndef __IWMPCdromCollection_INTERFACE_DEFINED__
#define __IWMPCdromCollection_INTERFACE_DEFINED__

/* interface IWMPCdromCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCdromCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE4C8FE2-34B2-11d3-A3BF-006097C9B344")
    IWMPCdromCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IWMPCdrom __RPC_FAR *__RPC_FAR *ppItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getByDriveSpecifier( 
            /* [in] */ BSTR bstrDriveSpecifier,
            /* [retval][out] */ IWMPCdrom __RPC_FAR *__RPC_FAR *ppCdrom) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCdromCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCdromCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCdromCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IWMPCdrom __RPC_FAR *__RPC_FAR *ppItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getByDriveSpecifier )( 
            IWMPCdromCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrDriveSpecifier,
            /* [retval][out] */ IWMPCdrom __RPC_FAR *__RPC_FAR *ppCdrom);
        
        END_INTERFACE
    } IWMPCdromCollectionVtbl;

    interface IWMPCdromCollection
    {
        CONST_VTBL struct IWMPCdromCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCdromCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCdromCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCdromCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCdromCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPCdromCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPCdromCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPCdromCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPCdromCollection_get_count(This,plCount)	\
    (This)->lpVtbl -> get_count(This,plCount)

#define IWMPCdromCollection_item(This,lIndex,ppItem)	\
    (This)->lpVtbl -> item(This,lIndex,ppItem)

#define IWMPCdromCollection_getByDriveSpecifier(This,bstrDriveSpecifier,ppCdrom)	\
    (This)->lpVtbl -> getByDriveSpecifier(This,bstrDriveSpecifier,ppCdrom)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCdromCollection_get_count_Proxy( 
    IWMPCdromCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IWMPCdromCollection_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPCdromCollection_item_Proxy( 
    IWMPCdromCollection __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IWMPCdrom __RPC_FAR *__RPC_FAR *ppItem);


void __RPC_STUB IWMPCdromCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPCdromCollection_getByDriveSpecifier_Proxy( 
    IWMPCdromCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrDriveSpecifier,
    /* [retval][out] */ IWMPCdrom __RPC_FAR *__RPC_FAR *ppCdrom);


void __RPC_STUB IWMPCdromCollection_getByDriveSpecifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCdromCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPStringCollection_INTERFACE_DEFINED__
#define __IWMPStringCollection_INTERFACE_DEFINED__

/* interface IWMPStringCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPStringCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a976298-8c0d-11d3-b389-00c04f68574b")
    IWMPStringCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPStringCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPStringCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPStringCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPStringCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPStringCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPStringCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPStringCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPStringCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IWMPStringCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IWMPStringCollection __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrString);
        
        END_INTERFACE
    } IWMPStringCollectionVtbl;

    interface IWMPStringCollection
    {
        CONST_VTBL struct IWMPStringCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPStringCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPStringCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPStringCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPStringCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPStringCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPStringCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPStringCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPStringCollection_get_count(This,plCount)	\
    (This)->lpVtbl -> get_count(This,plCount)

#define IWMPStringCollection_item(This,lIndex,pbstrString)	\
    (This)->lpVtbl -> item(This,lIndex,pbstrString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPStringCollection_get_count_Proxy( 
    IWMPStringCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IWMPStringCollection_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPStringCollection_item_Proxy( 
    IWMPStringCollection __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrString);


void __RPC_STUB IWMPStringCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPStringCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPMediaCollection_INTERFACE_DEFINED__
#define __IWMPMediaCollection_INTERFACE_DEFINED__

/* interface IWMPMediaCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPMediaCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8363BC22-B4B4-4b19-989D-1CD765749DD1")
    IWMPMediaCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE add( 
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAll( 
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getByName( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getByGenre( 
            /* [in] */ BSTR bstrGenre,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getByAuthor( 
            /* [in] */ BSTR bstrAuthor,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getByAlbum( 
            /* [in] */ BSTR bstrAlbum,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getByAttribute( 
            /* [in] */ BSTR bstrAttribute,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in] */ IWMPMedia __RPC_FAR *pItem,
            /* [in] */ VARIANT_BOOL varfDeleteFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttributeStringCollection( 
            /* [in] */ BSTR bstrAttribute,
            /* [in] */ BSTR bstrMediaType,
            /* [retval][out] */ IWMPStringCollection __RPC_FAR *__RPC_FAR *ppStringCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getMediaAtom( 
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ long __RPC_FAR *plAtom) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setDeleted( 
            /* [in] */ IWMPMedia __RPC_FAR *pItem,
            /* [in] */ VARIANT_BOOL varfIsDeleted) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE isDeleted( 
            /* [in] */ IWMPMedia __RPC_FAR *pItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsDeleted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPMediaCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPMediaCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPMediaCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *add )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAll )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getByName )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getByGenre )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrGenre,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getByAuthor )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrAuthor,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getByAlbum )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrAlbum,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getByAttribute )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrAttribute,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *remove )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pItem,
            /* [in] */ VARIANT_BOOL varfDeleteFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttributeStringCollection )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrAttribute,
            /* [in] */ BSTR bstrMediaType,
            /* [retval][out] */ IWMPStringCollection __RPC_FAR *__RPC_FAR *ppStringCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getMediaAtom )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ long __RPC_FAR *plAtom);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setDeleted )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pItem,
            /* [in] */ VARIANT_BOOL varfIsDeleted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isDeleted )( 
            IWMPMediaCollection __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsDeleted);
        
        END_INTERFACE
    } IWMPMediaCollectionVtbl;

    interface IWMPMediaCollection
    {
        CONST_VTBL struct IWMPMediaCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPMediaCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPMediaCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPMediaCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPMediaCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPMediaCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPMediaCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPMediaCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPMediaCollection_add(This,bstrURL,ppItem)	\
    (This)->lpVtbl -> add(This,bstrURL,ppItem)

#define IWMPMediaCollection_getAll(This,ppMediaItems)	\
    (This)->lpVtbl -> getAll(This,ppMediaItems)

#define IWMPMediaCollection_getByName(This,bstrName,ppMediaItems)	\
    (This)->lpVtbl -> getByName(This,bstrName,ppMediaItems)

#define IWMPMediaCollection_getByGenre(This,bstrGenre,ppMediaItems)	\
    (This)->lpVtbl -> getByGenre(This,bstrGenre,ppMediaItems)

#define IWMPMediaCollection_getByAuthor(This,bstrAuthor,ppMediaItems)	\
    (This)->lpVtbl -> getByAuthor(This,bstrAuthor,ppMediaItems)

#define IWMPMediaCollection_getByAlbum(This,bstrAlbum,ppMediaItems)	\
    (This)->lpVtbl -> getByAlbum(This,bstrAlbum,ppMediaItems)

#define IWMPMediaCollection_getByAttribute(This,bstrAttribute,bstrValue,ppMediaItems)	\
    (This)->lpVtbl -> getByAttribute(This,bstrAttribute,bstrValue,ppMediaItems)

#define IWMPMediaCollection_remove(This,pItem,varfDeleteFile)	\
    (This)->lpVtbl -> remove(This,pItem,varfDeleteFile)

#define IWMPMediaCollection_getAttributeStringCollection(This,bstrAttribute,bstrMediaType,ppStringCollection)	\
    (This)->lpVtbl -> getAttributeStringCollection(This,bstrAttribute,bstrMediaType,ppStringCollection)

#define IWMPMediaCollection_getMediaAtom(This,bstrItemName,plAtom)	\
    (This)->lpVtbl -> getMediaAtom(This,bstrItemName,plAtom)

#define IWMPMediaCollection_setDeleted(This,pItem,varfIsDeleted)	\
    (This)->lpVtbl -> setDeleted(This,pItem,varfIsDeleted)

#define IWMPMediaCollection_isDeleted(This,pItem,pvarfIsDeleted)	\
    (This)->lpVtbl -> isDeleted(This,pItem,pvarfIsDeleted)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_add_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppItem);


void __RPC_STUB IWMPMediaCollection_add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getAll_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);


void __RPC_STUB IWMPMediaCollection_getAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getByName_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);


void __RPC_STUB IWMPMediaCollection_getByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getByGenre_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrGenre,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);


void __RPC_STUB IWMPMediaCollection_getByGenre_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getByAuthor_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrAuthor,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);


void __RPC_STUB IWMPMediaCollection_getByAuthor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getByAlbum_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrAlbum,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);


void __RPC_STUB IWMPMediaCollection_getByAlbum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getByAttribute_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrAttribute,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppMediaItems);


void __RPC_STUB IWMPMediaCollection_getByAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_remove_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pItem,
    /* [in] */ VARIANT_BOOL varfDeleteFile);


void __RPC_STUB IWMPMediaCollection_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getAttributeStringCollection_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrAttribute,
    /* [in] */ BSTR bstrMediaType,
    /* [retval][out] */ IWMPStringCollection __RPC_FAR *__RPC_FAR *ppStringCollection);


void __RPC_STUB IWMPMediaCollection_getAttributeStringCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_getMediaAtom_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrItemName,
    /* [retval][out] */ long __RPC_FAR *plAtom);


void __RPC_STUB IWMPMediaCollection_getMediaAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_setDeleted_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pItem,
    /* [in] */ VARIANT_BOOL varfIsDeleted);


void __RPC_STUB IWMPMediaCollection_setDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPMediaCollection_isDeleted_Proxy( 
    IWMPMediaCollection __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pItem,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsDeleted);


void __RPC_STUB IWMPMediaCollection_isDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPMediaCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPPlaylistArray_INTERFACE_DEFINED__
#define __IWMPPlaylistArray_INTERFACE_DEFINED__

/* interface IWMPPlaylistArray */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlaylistArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("679409c0-99f7-11d3-9fb7-00105aa620bb")
    IWMPPlaylistArray : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlaylistArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPPlaylistArray __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPPlaylistArray __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPPlaylistArray __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPPlaylistArray __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPPlaylistArray __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPPlaylistArray __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPPlaylistArray __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_count )( 
            IWMPPlaylistArray __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IWMPPlaylistArray __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppItem);
        
        END_INTERFACE
    } IWMPPlaylistArrayVtbl;

    interface IWMPPlaylistArray
    {
        CONST_VTBL struct IWMPPlaylistArrayVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlaylistArray_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPPlaylistArray_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPPlaylistArray_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPPlaylistArray_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPPlaylistArray_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPPlaylistArray_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPPlaylistArray_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPPlaylistArray_get_count(This,plCount)	\
    (This)->lpVtbl -> get_count(This,plCount)

#define IWMPPlaylistArray_item(This,lIndex,ppItem)	\
    (This)->lpVtbl -> item(This,lIndex,ppItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistArray_get_count_Proxy( 
    IWMPPlaylistArray __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IWMPPlaylistArray_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistArray_item_Proxy( 
    IWMPPlaylistArray __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppItem);


void __RPC_STUB IWMPPlaylistArray_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPPlaylistArray_INTERFACE_DEFINED__ */


#ifndef __IWMPPlaylistCollection_INTERFACE_DEFINED__
#define __IWMPPlaylistCollection_INTERFACE_DEFINED__

/* interface IWMPPlaylistCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlaylistCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10A13217-23A7-439b-B1C0-D847C79B7774")
    IWMPPlaylistCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE newPlaylist( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAll( 
            /* [retval][out] */ IWMPPlaylistArray __RPC_FAR *__RPC_FAR *ppPlaylistArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getByName( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IWMPPlaylistArray __RPC_FAR *__RPC_FAR *ppPlaylistArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setDeleted( 
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
            /* [in] */ VARIANT_BOOL varfIsDeleted) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE isDeleted( 
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsDeleted) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE importPlaylist( 
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppImportedItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlaylistCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPPlaylistCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPPlaylistCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *newPlaylist )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAll )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylistArray __RPC_FAR *__RPC_FAR *ppPlaylistArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getByName )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IWMPPlaylistArray __RPC_FAR *__RPC_FAR *ppPlaylistArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *remove )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setDeleted )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
            /* [in] */ VARIANT_BOOL varfIsDeleted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isDeleted )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsDeleted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *importPlaylist )( 
            IWMPPlaylistCollection __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppImportedItem);
        
        END_INTERFACE
    } IWMPPlaylistCollectionVtbl;

    interface IWMPPlaylistCollection
    {
        CONST_VTBL struct IWMPPlaylistCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlaylistCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPPlaylistCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPPlaylistCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPPlaylistCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPPlaylistCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPPlaylistCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPPlaylistCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPPlaylistCollection_newPlaylist(This,bstrName,ppItem)	\
    (This)->lpVtbl -> newPlaylist(This,bstrName,ppItem)

#define IWMPPlaylistCollection_getAll(This,ppPlaylistArray)	\
    (This)->lpVtbl -> getAll(This,ppPlaylistArray)

#define IWMPPlaylistCollection_getByName(This,bstrName,ppPlaylistArray)	\
    (This)->lpVtbl -> getByName(This,bstrName,ppPlaylistArray)

#define IWMPPlaylistCollection_remove(This,pItem)	\
    (This)->lpVtbl -> remove(This,pItem)

#define IWMPPlaylistCollection_setDeleted(This,pItem,varfIsDeleted)	\
    (This)->lpVtbl -> setDeleted(This,pItem,varfIsDeleted)

#define IWMPPlaylistCollection_isDeleted(This,pItem,pvarfIsDeleted)	\
    (This)->lpVtbl -> isDeleted(This,pItem,pvarfIsDeleted)

#define IWMPPlaylistCollection_importPlaylist(This,pItem,ppImportedItem)	\
    (This)->lpVtbl -> importPlaylist(This,pItem,ppImportedItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistCollection_newPlaylist_Proxy( 
    IWMPPlaylistCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppItem);


void __RPC_STUB IWMPPlaylistCollection_newPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistCollection_getAll_Proxy( 
    IWMPPlaylistCollection __RPC_FAR * This,
    /* [retval][out] */ IWMPPlaylistArray __RPC_FAR *__RPC_FAR *ppPlaylistArray);


void __RPC_STUB IWMPPlaylistCollection_getAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistCollection_getByName_Proxy( 
    IWMPPlaylistCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ IWMPPlaylistArray __RPC_FAR *__RPC_FAR *ppPlaylistArray);


void __RPC_STUB IWMPPlaylistCollection_getByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistCollection_remove_Proxy( 
    IWMPPlaylistCollection __RPC_FAR * This,
    /* [in] */ IWMPPlaylist __RPC_FAR *pItem);


void __RPC_STUB IWMPPlaylistCollection_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistCollection_setDeleted_Proxy( 
    IWMPPlaylistCollection __RPC_FAR * This,
    /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
    /* [in] */ VARIANT_BOOL varfIsDeleted);


void __RPC_STUB IWMPPlaylistCollection_setDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistCollection_isDeleted_Proxy( 
    IWMPPlaylistCollection __RPC_FAR * This,
    /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsDeleted);


void __RPC_STUB IWMPPlaylistCollection_isDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPPlaylistCollection_importPlaylist_Proxy( 
    IWMPPlaylistCollection __RPC_FAR * This,
    /* [in] */ IWMPPlaylist __RPC_FAR *pItem,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppImportedItem);


void __RPC_STUB IWMPPlaylistCollection_importPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPPlaylistCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPNetwork_INTERFACE_DEFINED__
#define __IWMPNetwork_INTERFACE_DEFINED__

/* interface IWMPNetwork */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPNetwork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC21B779-EDEF-462d-BBA4-AD9DDE2B29A7")
    IWMPNetwork : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_bandWidth( 
            /* [retval][out] */ long __RPC_FAR *plBandwidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_recoveredPackets( 
            /* [retval][out] */ long __RPC_FAR *plRecoveredPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_sourceProtocol( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceProtocol) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_receivedPackets( 
            /* [retval][out] */ long __RPC_FAR *plReceivedPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_lostPackets( 
            /* [retval][out] */ long __RPC_FAR *plLostPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_receptionQuality( 
            /* [retval][out] */ long __RPC_FAR *plReceptionQuality) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_bufferingCount( 
            /* [retval][out] */ long __RPC_FAR *plBufferingCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_bufferingProgress( 
            /* [retval][out] */ long __RPC_FAR *plBufferingProgress) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_bufferingTime( 
            /* [retval][out] */ long __RPC_FAR *plBufferingTime) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_bufferingTime( 
            /* [in] */ long lBufferingTime) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_frameRate( 
            /* [retval][out] */ long __RPC_FAR *plFrameRate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_maxBitRate( 
            /* [retval][out] */ long __RPC_FAR *plBitRate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_bitRate( 
            /* [retval][out] */ long __RPC_FAR *plBitRate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProxySettings( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long __RPC_FAR *plProxySetting) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProxySettings( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxySetting) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProxyName( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProxyName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProxyName( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR bstrProxyName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProxyPort( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long __RPC_FAR *lProxyPort) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProxyPort( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxyPort) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProxyExceptionList( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrExceptionList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProxyExceptionList( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR pbstrExceptionList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProxyBypassForLocal( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfBypassForLocal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProxyBypassForLocal( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ VARIANT_BOOL fBypassForLocal) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_maxBandwidth( 
            /* [retval][out] */ long __RPC_FAR *lMaxBandwidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_maxBandwidth( 
            /* [in] */ long lMaxBandwidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_downloadProgress( 
            /* [retval][out] */ long __RPC_FAR *plDownloadProgress) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_encodedFrameRate( 
            /* [retval][out] */ long __RPC_FAR *plFrameRate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_framesSkipped( 
            /* [retval][out] */ long __RPC_FAR *plFrames) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPNetworkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPNetwork __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPNetwork __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPNetwork __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bandWidth )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBandwidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_recoveredPackets )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plRecoveredPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_sourceProtocol )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceProtocol);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_receivedPackets )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plReceivedPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lostPackets )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLostPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_receptionQuality )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plReceptionQuality);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bufferingCount )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBufferingCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bufferingProgress )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBufferingProgress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bufferingTime )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBufferingTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bufferingTime )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ long lBufferingTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frameRate )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plFrameRate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_maxBitRate )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBitRate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bitRate )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plBitRate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProxySettings )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long __RPC_FAR *plProxySetting);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setProxySettings )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxySetting);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProxyName )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProxyName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setProxyName )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR bstrProxyName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProxyPort )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long __RPC_FAR *lProxyPort);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setProxyPort )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxyPort);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProxyExceptionList )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrExceptionList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setProxyExceptionList )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR pbstrExceptionList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProxyBypassForLocal )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfBypassForLocal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setProxyBypassForLocal )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ VARIANT_BOOL fBypassForLocal);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_maxBandwidth )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *lMaxBandwidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_maxBandwidth )( 
            IWMPNetwork __RPC_FAR * This,
            /* [in] */ long lMaxBandwidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_downloadProgress )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plDownloadProgress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_encodedFrameRate )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plFrameRate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_framesSkipped )( 
            IWMPNetwork __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plFrames);
        
        END_INTERFACE
    } IWMPNetworkVtbl;

    interface IWMPNetwork
    {
        CONST_VTBL struct IWMPNetworkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPNetwork_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPNetwork_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPNetwork_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPNetwork_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPNetwork_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPNetwork_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPNetwork_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPNetwork_get_bandWidth(This,plBandwidth)	\
    (This)->lpVtbl -> get_bandWidth(This,plBandwidth)

#define IWMPNetwork_get_recoveredPackets(This,plRecoveredPackets)	\
    (This)->lpVtbl -> get_recoveredPackets(This,plRecoveredPackets)

#define IWMPNetwork_get_sourceProtocol(This,pbstrSourceProtocol)	\
    (This)->lpVtbl -> get_sourceProtocol(This,pbstrSourceProtocol)

#define IWMPNetwork_get_receivedPackets(This,plReceivedPackets)	\
    (This)->lpVtbl -> get_receivedPackets(This,plReceivedPackets)

#define IWMPNetwork_get_lostPackets(This,plLostPackets)	\
    (This)->lpVtbl -> get_lostPackets(This,plLostPackets)

#define IWMPNetwork_get_receptionQuality(This,plReceptionQuality)	\
    (This)->lpVtbl -> get_receptionQuality(This,plReceptionQuality)

#define IWMPNetwork_get_bufferingCount(This,plBufferingCount)	\
    (This)->lpVtbl -> get_bufferingCount(This,plBufferingCount)

#define IWMPNetwork_get_bufferingProgress(This,plBufferingProgress)	\
    (This)->lpVtbl -> get_bufferingProgress(This,plBufferingProgress)

#define IWMPNetwork_get_bufferingTime(This,plBufferingTime)	\
    (This)->lpVtbl -> get_bufferingTime(This,plBufferingTime)

#define IWMPNetwork_put_bufferingTime(This,lBufferingTime)	\
    (This)->lpVtbl -> put_bufferingTime(This,lBufferingTime)

#define IWMPNetwork_get_frameRate(This,plFrameRate)	\
    (This)->lpVtbl -> get_frameRate(This,plFrameRate)

#define IWMPNetwork_get_maxBitRate(This,plBitRate)	\
    (This)->lpVtbl -> get_maxBitRate(This,plBitRate)

#define IWMPNetwork_get_bitRate(This,plBitRate)	\
    (This)->lpVtbl -> get_bitRate(This,plBitRate)

#define IWMPNetwork_getProxySettings(This,bstrProtocol,plProxySetting)	\
    (This)->lpVtbl -> getProxySettings(This,bstrProtocol,plProxySetting)

#define IWMPNetwork_setProxySettings(This,bstrProtocol,lProxySetting)	\
    (This)->lpVtbl -> setProxySettings(This,bstrProtocol,lProxySetting)

#define IWMPNetwork_getProxyName(This,bstrProtocol,pbstrProxyName)	\
    (This)->lpVtbl -> getProxyName(This,bstrProtocol,pbstrProxyName)

#define IWMPNetwork_setProxyName(This,bstrProtocol,bstrProxyName)	\
    (This)->lpVtbl -> setProxyName(This,bstrProtocol,bstrProxyName)

#define IWMPNetwork_getProxyPort(This,bstrProtocol,lProxyPort)	\
    (This)->lpVtbl -> getProxyPort(This,bstrProtocol,lProxyPort)

#define IWMPNetwork_setProxyPort(This,bstrProtocol,lProxyPort)	\
    (This)->lpVtbl -> setProxyPort(This,bstrProtocol,lProxyPort)

#define IWMPNetwork_getProxyExceptionList(This,bstrProtocol,pbstrExceptionList)	\
    (This)->lpVtbl -> getProxyExceptionList(This,bstrProtocol,pbstrExceptionList)

#define IWMPNetwork_setProxyExceptionList(This,bstrProtocol,pbstrExceptionList)	\
    (This)->lpVtbl -> setProxyExceptionList(This,bstrProtocol,pbstrExceptionList)

#define IWMPNetwork_getProxyBypassForLocal(This,bstrProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> getProxyBypassForLocal(This,bstrProtocol,pfBypassForLocal)

#define IWMPNetwork_setProxyBypassForLocal(This,bstrProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> setProxyBypassForLocal(This,bstrProtocol,fBypassForLocal)

#define IWMPNetwork_get_maxBandwidth(This,lMaxBandwidth)	\
    (This)->lpVtbl -> get_maxBandwidth(This,lMaxBandwidth)

#define IWMPNetwork_put_maxBandwidth(This,lMaxBandwidth)	\
    (This)->lpVtbl -> put_maxBandwidth(This,lMaxBandwidth)

#define IWMPNetwork_get_downloadProgress(This,plDownloadProgress)	\
    (This)->lpVtbl -> get_downloadProgress(This,plDownloadProgress)

#define IWMPNetwork_get_encodedFrameRate(This,plFrameRate)	\
    (This)->lpVtbl -> get_encodedFrameRate(This,plFrameRate)

#define IWMPNetwork_get_framesSkipped(This,plFrames)	\
    (This)->lpVtbl -> get_framesSkipped(This,plFrames)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_bandWidth_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBandwidth);


void __RPC_STUB IWMPNetwork_get_bandWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_recoveredPackets_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plRecoveredPackets);


void __RPC_STUB IWMPNetwork_get_recoveredPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_sourceProtocol_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceProtocol);


void __RPC_STUB IWMPNetwork_get_sourceProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_receivedPackets_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plReceivedPackets);


void __RPC_STUB IWMPNetwork_get_receivedPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_lostPackets_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plLostPackets);


void __RPC_STUB IWMPNetwork_get_lostPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_receptionQuality_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plReceptionQuality);


void __RPC_STUB IWMPNetwork_get_receptionQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_bufferingCount_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBufferingCount);


void __RPC_STUB IWMPNetwork_get_bufferingCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_bufferingProgress_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBufferingProgress);


void __RPC_STUB IWMPNetwork_get_bufferingProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_bufferingTime_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBufferingTime);


void __RPC_STUB IWMPNetwork_get_bufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_put_bufferingTime_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ long lBufferingTime);


void __RPC_STUB IWMPNetwork_put_bufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_frameRate_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plFrameRate);


void __RPC_STUB IWMPNetwork_get_frameRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_maxBitRate_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBitRate);


void __RPC_STUB IWMPNetwork_get_maxBitRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_bitRate_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plBitRate);


void __RPC_STUB IWMPNetwork_get_bitRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_getProxySettings_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [retval][out] */ long __RPC_FAR *plProxySetting);


void __RPC_STUB IWMPNetwork_getProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_setProxySettings_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [in] */ long lProxySetting);


void __RPC_STUB IWMPNetwork_setProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_getProxyName_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrProxyName);


void __RPC_STUB IWMPNetwork_getProxyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_setProxyName_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [in] */ BSTR bstrProxyName);


void __RPC_STUB IWMPNetwork_setProxyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_getProxyPort_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [retval][out] */ long __RPC_FAR *lProxyPort);


void __RPC_STUB IWMPNetwork_getProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_setProxyPort_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [in] */ long lProxyPort);


void __RPC_STUB IWMPNetwork_setProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_getProxyExceptionList_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrExceptionList);


void __RPC_STUB IWMPNetwork_getProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_setProxyExceptionList_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [in] */ BSTR pbstrExceptionList);


void __RPC_STUB IWMPNetwork_setProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_getProxyBypassForLocal_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfBypassForLocal);


void __RPC_STUB IWMPNetwork_getProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_setProxyBypassForLocal_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ BSTR bstrProtocol,
    /* [in] */ VARIANT_BOOL fBypassForLocal);


void __RPC_STUB IWMPNetwork_setProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_maxBandwidth_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *lMaxBandwidth);


void __RPC_STUB IWMPNetwork_get_maxBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_put_maxBandwidth_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [in] */ long lMaxBandwidth);


void __RPC_STUB IWMPNetwork_put_maxBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_downloadProgress_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plDownloadProgress);


void __RPC_STUB IWMPNetwork_get_downloadProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_encodedFrameRate_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plFrameRate);


void __RPC_STUB IWMPNetwork_get_encodedFrameRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPNetwork_get_framesSkipped_Proxy( 
    IWMPNetwork __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plFrames);


void __RPC_STUB IWMPNetwork_get_framesSkipped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPNetwork_INTERFACE_DEFINED__ */


#ifndef __IWMPCore_INTERFACE_DEFINED__
#define __IWMPCore_INTERFACE_DEFINED__

/* interface IWMPCore */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D84CCA99-CCE2-11d2-9ECC-0000F8085981")
    IWMPCore : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE close( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_openState( 
            /* [retval][out] */ WMPOpenState __RPC_FAR *pwmpos) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_playState( 
            /* [retval][out] */ WMPPlayState __RPC_FAR *pwmpps) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_controls( 
            /* [retval][out] */ IWMPControls __RPC_FAR *__RPC_FAR *ppControl) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_settings( 
            /* [retval][out] */ IWMPSettings __RPC_FAR *__RPC_FAR *ppSettings) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_currentMedia( 
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppMedia) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentMedia( 
            /* [in] */ IWMPMedia __RPC_FAR *pMedia) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_mediaCollection( 
            /* [retval][out] */ IWMPMediaCollection __RPC_FAR *__RPC_FAR *ppMediaCollection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_playlistCollection( 
            /* [retval][out] */ IWMPPlaylistCollection __RPC_FAR *__RPC_FAR *ppPlaylistCollection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_versionInfo( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersionInfo) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE launchURL( 
            BSTR bstrURL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_network( 
            /* [retval][out] */ IWMPNetwork __RPC_FAR *__RPC_FAR *ppQNI) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_currentPlaylist( 
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPL) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_currentPlaylist( 
            /* [in] */ IWMPPlaylist __RPC_FAR *pPL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_cdromCollection( 
            /* [retval][out] */ IWMPCdromCollection __RPC_FAR *__RPC_FAR *ppCdromCollection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_closedCaption( 
            /* [retval][out] */ IWMPClosedCaption __RPC_FAR *__RPC_FAR *ppClosedCaption) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isOnline( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfOnline) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_error( 
            /* [retval][out] */ IWMPError __RPC_FAR *__RPC_FAR *ppError) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPCore __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPCore __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPCore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPCore __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *close )( 
            IWMPCore __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IWMPCore __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_openState )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ WMPOpenState __RPC_FAR *pwmpos);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playState )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ WMPPlayState __RPC_FAR *pwmpps);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_controls )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPControls __RPC_FAR *__RPC_FAR *ppControl);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_settings )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPSettings __RPC_FAR *__RPC_FAR *ppSettings);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentMedia )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentMedia )( 
            IWMPCore __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pMedia);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mediaCollection )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPMediaCollection __RPC_FAR *__RPC_FAR *ppMediaCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playlistCollection )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylistCollection __RPC_FAR *__RPC_FAR *ppPlaylistCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_versionInfo )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *launchURL )( 
            IWMPCore __RPC_FAR * This,
            BSTR bstrURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_network )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPNetwork __RPC_FAR *__RPC_FAR *ppQNI);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPlaylist )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPL);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPlaylist )( 
            IWMPCore __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pPL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cdromCollection )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPCdromCollection __RPC_FAR *__RPC_FAR *ppCdromCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_closedCaption )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPClosedCaption __RPC_FAR *__RPC_FAR *ppClosedCaption);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isOnline )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfOnline);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_error )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ IWMPError __RPC_FAR *__RPC_FAR *ppError);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IWMPCore __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        END_INTERFACE
    } IWMPCoreVtbl;

    interface IWMPCore
    {
        CONST_VTBL struct IWMPCoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCore_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPCore_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPCore_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPCore_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPCore_close(This)	\
    (This)->lpVtbl -> close(This)

#define IWMPCore_get_URL(This,pbstrURL)	\
    (This)->lpVtbl -> get_URL(This,pbstrURL)

#define IWMPCore_put_URL(This,bstrURL)	\
    (This)->lpVtbl -> put_URL(This,bstrURL)

#define IWMPCore_get_openState(This,pwmpos)	\
    (This)->lpVtbl -> get_openState(This,pwmpos)

#define IWMPCore_get_playState(This,pwmpps)	\
    (This)->lpVtbl -> get_playState(This,pwmpps)

#define IWMPCore_get_controls(This,ppControl)	\
    (This)->lpVtbl -> get_controls(This,ppControl)

#define IWMPCore_get_settings(This,ppSettings)	\
    (This)->lpVtbl -> get_settings(This,ppSettings)

#define IWMPCore_get_currentMedia(This,ppMedia)	\
    (This)->lpVtbl -> get_currentMedia(This,ppMedia)

#define IWMPCore_put_currentMedia(This,pMedia)	\
    (This)->lpVtbl -> put_currentMedia(This,pMedia)

#define IWMPCore_get_mediaCollection(This,ppMediaCollection)	\
    (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection)

#define IWMPCore_get_playlistCollection(This,ppPlaylistCollection)	\
    (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection)

#define IWMPCore_get_versionInfo(This,pbstrVersionInfo)	\
    (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo)

#define IWMPCore_launchURL(This,bstrURL)	\
    (This)->lpVtbl -> launchURL(This,bstrURL)

#define IWMPCore_get_network(This,ppQNI)	\
    (This)->lpVtbl -> get_network(This,ppQNI)

#define IWMPCore_get_currentPlaylist(This,ppPL)	\
    (This)->lpVtbl -> get_currentPlaylist(This,ppPL)

#define IWMPCore_put_currentPlaylist(This,pPL)	\
    (This)->lpVtbl -> put_currentPlaylist(This,pPL)

#define IWMPCore_get_cdromCollection(This,ppCdromCollection)	\
    (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection)

#define IWMPCore_get_closedCaption(This,ppClosedCaption)	\
    (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption)

#define IWMPCore_get_isOnline(This,pfOnline)	\
    (This)->lpVtbl -> get_isOnline(This,pfOnline)

#define IWMPCore_get_error(This,ppError)	\
    (This)->lpVtbl -> get_error(This,ppError)

#define IWMPCore_get_status(This,pbstrStatus)	\
    (This)->lpVtbl -> get_status(This,pbstrStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_close_Proxy( 
    IWMPCore __RPC_FAR * This);


void __RPC_STUB IWMPCore_close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_URL_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IWMPCore_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_put_URL_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IWMPCore_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_openState_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ WMPOpenState __RPC_FAR *pwmpos);


void __RPC_STUB IWMPCore_get_openState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_playState_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ WMPPlayState __RPC_FAR *pwmpps);


void __RPC_STUB IWMPCore_get_playState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_controls_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPControls __RPC_FAR *__RPC_FAR *ppControl);


void __RPC_STUB IWMPCore_get_controls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_settings_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPSettings __RPC_FAR *__RPC_FAR *ppSettings);


void __RPC_STUB IWMPCore_get_settings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_currentMedia_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppMedia);


void __RPC_STUB IWMPCore_get_currentMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_put_currentMedia_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [in] */ IWMPMedia __RPC_FAR *pMedia);


void __RPC_STUB IWMPCore_put_currentMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_mediaCollection_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPMediaCollection __RPC_FAR *__RPC_FAR *ppMediaCollection);


void __RPC_STUB IWMPCore_get_mediaCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_playlistCollection_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPPlaylistCollection __RPC_FAR *__RPC_FAR *ppPlaylistCollection);


void __RPC_STUB IWMPCore_get_playlistCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_versionInfo_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrVersionInfo);


void __RPC_STUB IWMPCore_get_versionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWMPCore_launchURL_Proxy( 
    IWMPCore __RPC_FAR * This,
    BSTR bstrURL);


void __RPC_STUB IWMPCore_launchURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_network_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPNetwork __RPC_FAR *__RPC_FAR *ppQNI);


void __RPC_STUB IWMPCore_get_network_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_currentPlaylist_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPL);


void __RPC_STUB IWMPCore_get_currentPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_put_currentPlaylist_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [in] */ IWMPPlaylist __RPC_FAR *pPL);


void __RPC_STUB IWMPCore_put_currentPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_cdromCollection_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPCdromCollection __RPC_FAR *__RPC_FAR *ppCdromCollection);


void __RPC_STUB IWMPCore_get_cdromCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_closedCaption_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPClosedCaption __RPC_FAR *__RPC_FAR *ppClosedCaption);


void __RPC_STUB IWMPCore_get_closedCaption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_isOnline_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfOnline);


void __RPC_STUB IWMPCore_get_isOnline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_error_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ IWMPError __RPC_FAR *__RPC_FAR *ppError);


void __RPC_STUB IWMPCore_get_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore_get_status_Proxy( 
    IWMPCore __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);


void __RPC_STUB IWMPCore_get_status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCore_INTERFACE_DEFINED__ */


#ifndef __IWMPPlayer_INTERFACE_DEFINED__
#define __IWMPPlayer_INTERFACE_DEFINED__

/* interface IWMPPlayer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BF52A4F-394A-11d3-B153-00C04F79FAA6")
    IWMPPlayer : public IWMPCore
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_fullScreen( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_fullScreen( 
            VARIANT_BOOL bFullScreen) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_enableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_enableContextMenu( 
            VARIANT_BOOL bEnableContextMenu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_uiMode( 
            /* [in] */ BSTR bstrMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_uiMode( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPPlayer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPPlayer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPPlayer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *close )( 
            IWMPPlayer __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_openState )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ WMPOpenState __RPC_FAR *pwmpos);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playState )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ WMPPlayState __RPC_FAR *pwmpps);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_controls )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPControls __RPC_FAR *__RPC_FAR *ppControl);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_settings )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPSettings __RPC_FAR *__RPC_FAR *ppSettings);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentMedia )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentMedia )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pMedia);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mediaCollection )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPMediaCollection __RPC_FAR *__RPC_FAR *ppMediaCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playlistCollection )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylistCollection __RPC_FAR *__RPC_FAR *ppPlaylistCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_versionInfo )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *launchURL )( 
            IWMPPlayer __RPC_FAR * This,
            BSTR bstrURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_network )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPNetwork __RPC_FAR *__RPC_FAR *ppQNI);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPlaylist )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPL);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPlaylist )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pPL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cdromCollection )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPCdromCollection __RPC_FAR *__RPC_FAR *ppCdromCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_closedCaption )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPClosedCaption __RPC_FAR *__RPC_FAR *ppClosedCaption);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isOnline )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfOnline);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_error )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ IWMPError __RPC_FAR *__RPC_FAR *ppError);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enabled )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enabled )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fullScreen )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fullScreen )( 
            IWMPPlayer __RPC_FAR * This,
            VARIANT_BOOL bFullScreen);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enableContextMenu )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enableContextMenu )( 
            IWMPPlayer __RPC_FAR * This,
            VARIANT_BOOL bEnableContextMenu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_uiMode )( 
            IWMPPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_uiMode )( 
            IWMPPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMode);
        
        END_INTERFACE
    } IWMPPlayerVtbl;

    interface IWMPPlayer
    {
        CONST_VTBL struct IWMPPlayerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPPlayer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPPlayer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPPlayer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPPlayer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPPlayer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPPlayer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPPlayer_close(This)	\
    (This)->lpVtbl -> close(This)

#define IWMPPlayer_get_URL(This,pbstrURL)	\
    (This)->lpVtbl -> get_URL(This,pbstrURL)

#define IWMPPlayer_put_URL(This,bstrURL)	\
    (This)->lpVtbl -> put_URL(This,bstrURL)

#define IWMPPlayer_get_openState(This,pwmpos)	\
    (This)->lpVtbl -> get_openState(This,pwmpos)

#define IWMPPlayer_get_playState(This,pwmpps)	\
    (This)->lpVtbl -> get_playState(This,pwmpps)

#define IWMPPlayer_get_controls(This,ppControl)	\
    (This)->lpVtbl -> get_controls(This,ppControl)

#define IWMPPlayer_get_settings(This,ppSettings)	\
    (This)->lpVtbl -> get_settings(This,ppSettings)

#define IWMPPlayer_get_currentMedia(This,ppMedia)	\
    (This)->lpVtbl -> get_currentMedia(This,ppMedia)

#define IWMPPlayer_put_currentMedia(This,pMedia)	\
    (This)->lpVtbl -> put_currentMedia(This,pMedia)

#define IWMPPlayer_get_mediaCollection(This,ppMediaCollection)	\
    (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection)

#define IWMPPlayer_get_playlistCollection(This,ppPlaylistCollection)	\
    (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection)

#define IWMPPlayer_get_versionInfo(This,pbstrVersionInfo)	\
    (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo)

#define IWMPPlayer_launchURL(This,bstrURL)	\
    (This)->lpVtbl -> launchURL(This,bstrURL)

#define IWMPPlayer_get_network(This,ppQNI)	\
    (This)->lpVtbl -> get_network(This,ppQNI)

#define IWMPPlayer_get_currentPlaylist(This,ppPL)	\
    (This)->lpVtbl -> get_currentPlaylist(This,ppPL)

#define IWMPPlayer_put_currentPlaylist(This,pPL)	\
    (This)->lpVtbl -> put_currentPlaylist(This,pPL)

#define IWMPPlayer_get_cdromCollection(This,ppCdromCollection)	\
    (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection)

#define IWMPPlayer_get_closedCaption(This,ppClosedCaption)	\
    (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption)

#define IWMPPlayer_get_isOnline(This,pfOnline)	\
    (This)->lpVtbl -> get_isOnline(This,pfOnline)

#define IWMPPlayer_get_error(This,ppError)	\
    (This)->lpVtbl -> get_error(This,ppError)

#define IWMPPlayer_get_status(This,pbstrStatus)	\
    (This)->lpVtbl -> get_status(This,pbstrStatus)


#define IWMPPlayer_get_enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_enabled(This,pbEnabled)

#define IWMPPlayer_put_enabled(This,bEnabled)	\
    (This)->lpVtbl -> put_enabled(This,bEnabled)

#define IWMPPlayer_get_fullScreen(This,pbFullScreen)	\
    (This)->lpVtbl -> get_fullScreen(This,pbFullScreen)

#define IWMPPlayer_put_fullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> put_fullScreen(This,bFullScreen)

#define IWMPPlayer_get_enableContextMenu(This,pbEnableContextMenu)	\
    (This)->lpVtbl -> get_enableContextMenu(This,pbEnableContextMenu)

#define IWMPPlayer_put_enableContextMenu(This,bEnableContextMenu)	\
    (This)->lpVtbl -> put_enableContextMenu(This,bEnableContextMenu)

#define IWMPPlayer_put_uiMode(This,bstrMode)	\
    (This)->lpVtbl -> put_uiMode(This,bstrMode)

#define IWMPPlayer_get_uiMode(This,pbstrMode)	\
    (This)->lpVtbl -> get_uiMode(This,pbstrMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_get_enabled_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);


void __RPC_STUB IWMPPlayer_get_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_put_enabled_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IWMPPlayer_put_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_get_fullScreen_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);


void __RPC_STUB IWMPPlayer_get_fullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_put_fullScreen_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    VARIANT_BOOL bFullScreen);


void __RPC_STUB IWMPPlayer_put_fullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_get_enableContextMenu_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu);


void __RPC_STUB IWMPPlayer_get_enableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_put_enableContextMenu_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    VARIANT_BOOL bEnableContextMenu);


void __RPC_STUB IWMPPlayer_put_enableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_put_uiMode_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrMode);


void __RPC_STUB IWMPPlayer_put_uiMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer_get_uiMode_Proxy( 
    IWMPPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMode);


void __RPC_STUB IWMPPlayer_get_uiMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPPlayer_INTERFACE_DEFINED__ */


#ifndef __IWMPPlayer2_INTERFACE_DEFINED__
#define __IWMPPlayer2_INTERFACE_DEFINED__

/* interface IWMPPlayer2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E6B01D1-D407-4c85-BF5F-1C01F6150280")
    IWMPPlayer2 : public IWMPCore
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_fullScreen( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_fullScreen( 
            VARIANT_BOOL bFullScreen) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_enableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_enableContextMenu( 
            VARIANT_BOOL bEnableContextMenu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_uiMode( 
            /* [in] */ BSTR bstrMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_uiMode( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_stretchToFit( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_stretchToFit( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_windowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_windowlessVideo( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPPlayer2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPPlayer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *close )( 
            IWMPPlayer2 __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_openState )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ WMPOpenState __RPC_FAR *pwmpos);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playState )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ WMPPlayState __RPC_FAR *pwmpps);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_controls )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPControls __RPC_FAR *__RPC_FAR *ppControl);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_settings )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPSettings __RPC_FAR *__RPC_FAR *ppSettings);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentMedia )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentMedia )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pMedia);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mediaCollection )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPMediaCollection __RPC_FAR *__RPC_FAR *ppMediaCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playlistCollection )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylistCollection __RPC_FAR *__RPC_FAR *ppPlaylistCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_versionInfo )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *launchURL )( 
            IWMPPlayer2 __RPC_FAR * This,
            BSTR bstrURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_network )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPNetwork __RPC_FAR *__RPC_FAR *ppQNI);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPlaylist )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPL);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPlaylist )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pPL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cdromCollection )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPCdromCollection __RPC_FAR *__RPC_FAR *ppCdromCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_closedCaption )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPClosedCaption __RPC_FAR *__RPC_FAR *ppClosedCaption);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isOnline )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfOnline);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_error )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ IWMPError __RPC_FAR *__RPC_FAR *ppError);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enabled )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enabled )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fullScreen )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fullScreen )( 
            IWMPPlayer2 __RPC_FAR * This,
            VARIANT_BOOL bFullScreen);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enableContextMenu )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enableContextMenu )( 
            IWMPPlayer2 __RPC_FAR * This,
            VARIANT_BOOL bEnableContextMenu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_uiMode )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ BSTR bstrMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_uiMode )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_stretchToFit )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_stretchToFit )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_windowlessVideo )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_windowlessVideo )( 
            IWMPPlayer2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        END_INTERFACE
    } IWMPPlayer2Vtbl;

    interface IWMPPlayer2
    {
        CONST_VTBL struct IWMPPlayer2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPPlayer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPPlayer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPPlayer2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPPlayer2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPPlayer2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPPlayer2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPPlayer2_close(This)	\
    (This)->lpVtbl -> close(This)

#define IWMPPlayer2_get_URL(This,pbstrURL)	\
    (This)->lpVtbl -> get_URL(This,pbstrURL)

#define IWMPPlayer2_put_URL(This,bstrURL)	\
    (This)->lpVtbl -> put_URL(This,bstrURL)

#define IWMPPlayer2_get_openState(This,pwmpos)	\
    (This)->lpVtbl -> get_openState(This,pwmpos)

#define IWMPPlayer2_get_playState(This,pwmpps)	\
    (This)->lpVtbl -> get_playState(This,pwmpps)

#define IWMPPlayer2_get_controls(This,ppControl)	\
    (This)->lpVtbl -> get_controls(This,ppControl)

#define IWMPPlayer2_get_settings(This,ppSettings)	\
    (This)->lpVtbl -> get_settings(This,ppSettings)

#define IWMPPlayer2_get_currentMedia(This,ppMedia)	\
    (This)->lpVtbl -> get_currentMedia(This,ppMedia)

#define IWMPPlayer2_put_currentMedia(This,pMedia)	\
    (This)->lpVtbl -> put_currentMedia(This,pMedia)

#define IWMPPlayer2_get_mediaCollection(This,ppMediaCollection)	\
    (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection)

#define IWMPPlayer2_get_playlistCollection(This,ppPlaylistCollection)	\
    (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection)

#define IWMPPlayer2_get_versionInfo(This,pbstrVersionInfo)	\
    (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo)

#define IWMPPlayer2_launchURL(This,bstrURL)	\
    (This)->lpVtbl -> launchURL(This,bstrURL)

#define IWMPPlayer2_get_network(This,ppQNI)	\
    (This)->lpVtbl -> get_network(This,ppQNI)

#define IWMPPlayer2_get_currentPlaylist(This,ppPL)	\
    (This)->lpVtbl -> get_currentPlaylist(This,ppPL)

#define IWMPPlayer2_put_currentPlaylist(This,pPL)	\
    (This)->lpVtbl -> put_currentPlaylist(This,pPL)

#define IWMPPlayer2_get_cdromCollection(This,ppCdromCollection)	\
    (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection)

#define IWMPPlayer2_get_closedCaption(This,ppClosedCaption)	\
    (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption)

#define IWMPPlayer2_get_isOnline(This,pfOnline)	\
    (This)->lpVtbl -> get_isOnline(This,pfOnline)

#define IWMPPlayer2_get_error(This,ppError)	\
    (This)->lpVtbl -> get_error(This,ppError)

#define IWMPPlayer2_get_status(This,pbstrStatus)	\
    (This)->lpVtbl -> get_status(This,pbstrStatus)


#define IWMPPlayer2_get_enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_enabled(This,pbEnabled)

#define IWMPPlayer2_put_enabled(This,bEnabled)	\
    (This)->lpVtbl -> put_enabled(This,bEnabled)

#define IWMPPlayer2_get_fullScreen(This,pbFullScreen)	\
    (This)->lpVtbl -> get_fullScreen(This,pbFullScreen)

#define IWMPPlayer2_put_fullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> put_fullScreen(This,bFullScreen)

#define IWMPPlayer2_get_enableContextMenu(This,pbEnableContextMenu)	\
    (This)->lpVtbl -> get_enableContextMenu(This,pbEnableContextMenu)

#define IWMPPlayer2_put_enableContextMenu(This,bEnableContextMenu)	\
    (This)->lpVtbl -> put_enableContextMenu(This,bEnableContextMenu)

#define IWMPPlayer2_put_uiMode(This,bstrMode)	\
    (This)->lpVtbl -> put_uiMode(This,bstrMode)

#define IWMPPlayer2_get_uiMode(This,pbstrMode)	\
    (This)->lpVtbl -> get_uiMode(This,pbstrMode)

#define IWMPPlayer2_get_stretchToFit(This,pbEnabled)	\
    (This)->lpVtbl -> get_stretchToFit(This,pbEnabled)

#define IWMPPlayer2_put_stretchToFit(This,bEnabled)	\
    (This)->lpVtbl -> put_stretchToFit(This,bEnabled)

#define IWMPPlayer2_get_windowlessVideo(This,pbEnabled)	\
    (This)->lpVtbl -> get_windowlessVideo(This,pbEnabled)

#define IWMPPlayer2_put_windowlessVideo(This,bEnabled)	\
    (This)->lpVtbl -> put_windowlessVideo(This,bEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_get_enabled_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);


void __RPC_STUB IWMPPlayer2_get_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_put_enabled_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IWMPPlayer2_put_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_get_fullScreen_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);


void __RPC_STUB IWMPPlayer2_get_fullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_put_fullScreen_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    VARIANT_BOOL bFullScreen);


void __RPC_STUB IWMPPlayer2_put_fullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_get_enableContextMenu_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu);


void __RPC_STUB IWMPPlayer2_get_enableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_put_enableContextMenu_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    VARIANT_BOOL bEnableContextMenu);


void __RPC_STUB IWMPPlayer2_put_enableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_put_uiMode_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [in] */ BSTR bstrMode);


void __RPC_STUB IWMPPlayer2_put_uiMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_get_uiMode_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMode);


void __RPC_STUB IWMPPlayer2_get_uiMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_get_stretchToFit_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);


void __RPC_STUB IWMPPlayer2_get_stretchToFit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_put_stretchToFit_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IWMPPlayer2_put_stretchToFit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_get_windowlessVideo_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);


void __RPC_STUB IWMPPlayer2_get_windowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer2_put_windowlessVideo_Proxy( 
    IWMPPlayer2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IWMPPlayer2_put_windowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPPlayer2_INTERFACE_DEFINED__ */


#ifndef __IWMPMedia2_INTERFACE_DEFINED__
#define __IWMPMedia2_INTERFACE_DEFINED__

/* interface IWMPMedia2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPMedia2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB7C88BB-143E-4ea4-ACC3-E4350B2106C3")
    IWMPMedia2 : public IWMPMedia
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_error( 
            /* [retval][out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppIWMPErrorItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPMedia2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPMedia2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPMedia2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isIdentical )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_sourceURL )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_name )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_imageSourceWidth )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_imageSourceHeight )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHeight);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_markerCount )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMarkerCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getMarkerTime )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double __RPC_FAR *pMarkerTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getMarkerName )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_duration )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pDuration);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_durationString )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDuration);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributeCount )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttributeName )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrItemName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getItemInfo )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setItemInfo )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ BSTR bstrItemName,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getItemInfoByAtom )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ long lAtom,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isMemberOf )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pPlaylist,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsMemberOf);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isReadOnlyItem )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvarfIsReadOnly);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_error )( 
            IWMPMedia2 __RPC_FAR * This,
            /* [retval][out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppIWMPErrorItem);
        
        END_INTERFACE
    } IWMPMedia2Vtbl;

    interface IWMPMedia2
    {
        CONST_VTBL struct IWMPMedia2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPMedia2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPMedia2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPMedia2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPMedia2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPMedia2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPMedia2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPMedia2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPMedia2_get_isIdentical(This,pIWMPMedia,pvbool)	\
    (This)->lpVtbl -> get_isIdentical(This,pIWMPMedia,pvbool)

#define IWMPMedia2_get_sourceURL(This,pbstrSourceURL)	\
    (This)->lpVtbl -> get_sourceURL(This,pbstrSourceURL)

#define IWMPMedia2_get_name(This,pbstrName)	\
    (This)->lpVtbl -> get_name(This,pbstrName)

#define IWMPMedia2_put_name(This,bstrName)	\
    (This)->lpVtbl -> put_name(This,bstrName)

#define IWMPMedia2_get_imageSourceWidth(This,pWidth)	\
    (This)->lpVtbl -> get_imageSourceWidth(This,pWidth)

#define IWMPMedia2_get_imageSourceHeight(This,pHeight)	\
    (This)->lpVtbl -> get_imageSourceHeight(This,pHeight)

#define IWMPMedia2_get_markerCount(This,pMarkerCount)	\
    (This)->lpVtbl -> get_markerCount(This,pMarkerCount)

#define IWMPMedia2_getMarkerTime(This,MarkerNum,pMarkerTime)	\
    (This)->lpVtbl -> getMarkerTime(This,MarkerNum,pMarkerTime)

#define IWMPMedia2_getMarkerName(This,MarkerNum,pbstrMarkerName)	\
    (This)->lpVtbl -> getMarkerName(This,MarkerNum,pbstrMarkerName)

#define IWMPMedia2_get_duration(This,pDuration)	\
    (This)->lpVtbl -> get_duration(This,pDuration)

#define IWMPMedia2_get_durationString(This,pbstrDuration)	\
    (This)->lpVtbl -> get_durationString(This,pbstrDuration)

#define IWMPMedia2_get_attributeCount(This,plCount)	\
    (This)->lpVtbl -> get_attributeCount(This,plCount)

#define IWMPMedia2_getAttributeName(This,lIndex,pbstrItemName)	\
    (This)->lpVtbl -> getAttributeName(This,lIndex,pbstrItemName)

#define IWMPMedia2_getItemInfo(This,bstrItemName,pbstrVal)	\
    (This)->lpVtbl -> getItemInfo(This,bstrItemName,pbstrVal)

#define IWMPMedia2_setItemInfo(This,bstrItemName,bstrVal)	\
    (This)->lpVtbl -> setItemInfo(This,bstrItemName,bstrVal)

#define IWMPMedia2_getItemInfoByAtom(This,lAtom,pbstrVal)	\
    (This)->lpVtbl -> getItemInfoByAtom(This,lAtom,pbstrVal)

#define IWMPMedia2_isMemberOf(This,pPlaylist,pvarfIsMemberOf)	\
    (This)->lpVtbl -> isMemberOf(This,pPlaylist,pvarfIsMemberOf)

#define IWMPMedia2_isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly)	\
    (This)->lpVtbl -> isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly)


#define IWMPMedia2_get_error(This,ppIWMPErrorItem)	\
    (This)->lpVtbl -> get_error(This,ppIWMPErrorItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPMedia2_get_error_Proxy( 
    IWMPMedia2 __RPC_FAR * This,
    /* [retval][out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppIWMPErrorItem);


void __RPC_STUB IWMPMedia2_get_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPMedia2_INTERFACE_DEFINED__ */


#ifndef __IWMPControls2_INTERFACE_DEFINED__
#define __IWMPControls2_INTERFACE_DEFINED__

/* interface IWMPControls2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPControls2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6F030D25-0890-480f-9775-1F7E40AB5B8E")
    IWMPControls2 : public IWMPControls
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE step( 
            /* [in] */ long lStep) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPControls2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPControls2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPControls2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPControls2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isAvailable )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *play )( 
            IWMPControls2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *stop )( 
            IWMPControls2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *pause )( 
            IWMPControls2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *fastForward )( 
            IWMPControls2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *fastReverse )( 
            IWMPControls2 __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPosition )( 
            IWMPControls2 __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pdCurrentPosition);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPosition )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ double dCurrentPosition);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPositionString )( 
            IWMPControls2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCurrentPosition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *next )( 
            IWMPControls2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *previous )( 
            IWMPControls2 __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentItem )( 
            IWMPControls2 __RPC_FAR * This,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppIWMPMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentItem )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentMarker )( 
            IWMPControls2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMarker);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentMarker )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ long lMarker);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *playItem )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pIWMPMedia);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *step )( 
            IWMPControls2 __RPC_FAR * This,
            /* [in] */ long lStep);
        
        END_INTERFACE
    } IWMPControls2Vtbl;

    interface IWMPControls2
    {
        CONST_VTBL struct IWMPControls2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPControls2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPControls2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPControls2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPControls2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPControls2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPControls2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPControls2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPControls2_get_isAvailable(This,bstrItem,pIsAvailable)	\
    (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable)

#define IWMPControls2_play(This)	\
    (This)->lpVtbl -> play(This)

#define IWMPControls2_stop(This)	\
    (This)->lpVtbl -> stop(This)

#define IWMPControls2_pause(This)	\
    (This)->lpVtbl -> pause(This)

#define IWMPControls2_fastForward(This)	\
    (This)->lpVtbl -> fastForward(This)

#define IWMPControls2_fastReverse(This)	\
    (This)->lpVtbl -> fastReverse(This)

#define IWMPControls2_get_currentPosition(This,pdCurrentPosition)	\
    (This)->lpVtbl -> get_currentPosition(This,pdCurrentPosition)

#define IWMPControls2_put_currentPosition(This,dCurrentPosition)	\
    (This)->lpVtbl -> put_currentPosition(This,dCurrentPosition)

#define IWMPControls2_get_currentPositionString(This,pbstrCurrentPosition)	\
    (This)->lpVtbl -> get_currentPositionString(This,pbstrCurrentPosition)

#define IWMPControls2_next(This)	\
    (This)->lpVtbl -> next(This)

#define IWMPControls2_previous(This)	\
    (This)->lpVtbl -> previous(This)

#define IWMPControls2_get_currentItem(This,ppIWMPMedia)	\
    (This)->lpVtbl -> get_currentItem(This,ppIWMPMedia)

#define IWMPControls2_put_currentItem(This,pIWMPMedia)	\
    (This)->lpVtbl -> put_currentItem(This,pIWMPMedia)

#define IWMPControls2_get_currentMarker(This,plMarker)	\
    (This)->lpVtbl -> get_currentMarker(This,plMarker)

#define IWMPControls2_put_currentMarker(This,lMarker)	\
    (This)->lpVtbl -> put_currentMarker(This,lMarker)

#define IWMPControls2_playItem(This,pIWMPMedia)	\
    (This)->lpVtbl -> playItem(This,pIWMPMedia)


#define IWMPControls2_step(This,lStep)	\
    (This)->lpVtbl -> step(This,lStep)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPControls2_step_Proxy( 
    IWMPControls2 __RPC_FAR * This,
    /* [in] */ long lStep);


void __RPC_STUB IWMPControls2_step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPControls2_INTERFACE_DEFINED__ */


#ifndef __IWMPDVD_INTERFACE_DEFINED__
#define __IWMPDVD_INTERFACE_DEFINED__

/* interface IWMPDVD */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPDVD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8DA61686-4668-4a5c-AE5D-803193293DBE")
    IWMPDVD : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isAvailable( 
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_domain( 
            /* [retval][out] */ BSTR __RPC_FAR *strDomain) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE topMenu( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE titleMenu( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE back( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPDVDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPDVD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPDVD __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPDVD __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPDVD __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPDVD __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPDVD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPDVD __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isAvailable )( 
            IWMPDVD __RPC_FAR * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_domain )( 
            IWMPDVD __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strDomain);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *topMenu )( 
            IWMPDVD __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *titleMenu )( 
            IWMPDVD __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *back )( 
            IWMPDVD __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *resume )( 
            IWMPDVD __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPDVDVtbl;

    interface IWMPDVD
    {
        CONST_VTBL struct IWMPDVDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPDVD_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPDVD_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPDVD_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPDVD_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPDVD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPDVD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPDVD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPDVD_get_isAvailable(This,bstrItem,pIsAvailable)	\
    (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable)

#define IWMPDVD_get_domain(This,strDomain)	\
    (This)->lpVtbl -> get_domain(This,strDomain)

#define IWMPDVD_topMenu(This)	\
    (This)->lpVtbl -> topMenu(This)

#define IWMPDVD_titleMenu(This)	\
    (This)->lpVtbl -> titleMenu(This)

#define IWMPDVD_back(This)	\
    (This)->lpVtbl -> back(This)

#define IWMPDVD_resume(This)	\
    (This)->lpVtbl -> resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPDVD_get_isAvailable_Proxy( 
    IWMPDVD __RPC_FAR * This,
    /* [in] */ BSTR bstrItem,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsAvailable);


void __RPC_STUB IWMPDVD_get_isAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPDVD_get_domain_Proxy( 
    IWMPDVD __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strDomain);


void __RPC_STUB IWMPDVD_get_domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPDVD_topMenu_Proxy( 
    IWMPDVD __RPC_FAR * This);


void __RPC_STUB IWMPDVD_topMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPDVD_titleMenu_Proxy( 
    IWMPDVD __RPC_FAR * This);


void __RPC_STUB IWMPDVD_titleMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPDVD_back_Proxy( 
    IWMPDVD __RPC_FAR * This);


void __RPC_STUB IWMPDVD_back_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMPDVD_resume_Proxy( 
    IWMPDVD __RPC_FAR * This);


void __RPC_STUB IWMPDVD_resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPDVD_INTERFACE_DEFINED__ */


#ifndef __IWMPCore2_INTERFACE_DEFINED__
#define __IWMPCore2_INTERFACE_DEFINED__

/* interface IWMPCore2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCore2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC17E5B7-7561-4c18-BB90-17D485775659")
    IWMPCore2 : public IWMPCore
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_dvd( 
            /* [retval][out] */ IWMPDVD __RPC_FAR *__RPC_FAR *ppDVD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCore2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCore2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCore2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCore2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPCore2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPCore2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPCore2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPCore2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *close )( 
            IWMPCore2 __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IWMPCore2 __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_openState )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ WMPOpenState __RPC_FAR *pwmpos);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playState )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ WMPPlayState __RPC_FAR *pwmpps);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_controls )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPControls __RPC_FAR *__RPC_FAR *ppControl);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_settings )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPSettings __RPC_FAR *__RPC_FAR *ppSettings);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentMedia )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentMedia )( 
            IWMPCore2 __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pMedia);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mediaCollection )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPMediaCollection __RPC_FAR *__RPC_FAR *ppMediaCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playlistCollection )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylistCollection __RPC_FAR *__RPC_FAR *ppPlaylistCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_versionInfo )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *launchURL )( 
            IWMPCore2 __RPC_FAR * This,
            BSTR bstrURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_network )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPNetwork __RPC_FAR *__RPC_FAR *ppQNI);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPlaylist )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPL);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPlaylist )( 
            IWMPCore2 __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pPL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cdromCollection )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPCdromCollection __RPC_FAR *__RPC_FAR *ppCdromCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_closedCaption )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPClosedCaption __RPC_FAR *__RPC_FAR *ppClosedCaption);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isOnline )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfOnline);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_error )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPError __RPC_FAR *__RPC_FAR *ppError);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dvd )( 
            IWMPCore2 __RPC_FAR * This,
            /* [retval][out] */ IWMPDVD __RPC_FAR *__RPC_FAR *ppDVD);
        
        END_INTERFACE
    } IWMPCore2Vtbl;

    interface IWMPCore2
    {
        CONST_VTBL struct IWMPCore2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCore2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCore2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCore2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCore2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPCore2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPCore2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPCore2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPCore2_close(This)	\
    (This)->lpVtbl -> close(This)

#define IWMPCore2_get_URL(This,pbstrURL)	\
    (This)->lpVtbl -> get_URL(This,pbstrURL)

#define IWMPCore2_put_URL(This,bstrURL)	\
    (This)->lpVtbl -> put_URL(This,bstrURL)

#define IWMPCore2_get_openState(This,pwmpos)	\
    (This)->lpVtbl -> get_openState(This,pwmpos)

#define IWMPCore2_get_playState(This,pwmpps)	\
    (This)->lpVtbl -> get_playState(This,pwmpps)

#define IWMPCore2_get_controls(This,ppControl)	\
    (This)->lpVtbl -> get_controls(This,ppControl)

#define IWMPCore2_get_settings(This,ppSettings)	\
    (This)->lpVtbl -> get_settings(This,ppSettings)

#define IWMPCore2_get_currentMedia(This,ppMedia)	\
    (This)->lpVtbl -> get_currentMedia(This,ppMedia)

#define IWMPCore2_put_currentMedia(This,pMedia)	\
    (This)->lpVtbl -> put_currentMedia(This,pMedia)

#define IWMPCore2_get_mediaCollection(This,ppMediaCollection)	\
    (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection)

#define IWMPCore2_get_playlistCollection(This,ppPlaylistCollection)	\
    (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection)

#define IWMPCore2_get_versionInfo(This,pbstrVersionInfo)	\
    (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo)

#define IWMPCore2_launchURL(This,bstrURL)	\
    (This)->lpVtbl -> launchURL(This,bstrURL)

#define IWMPCore2_get_network(This,ppQNI)	\
    (This)->lpVtbl -> get_network(This,ppQNI)

#define IWMPCore2_get_currentPlaylist(This,ppPL)	\
    (This)->lpVtbl -> get_currentPlaylist(This,ppPL)

#define IWMPCore2_put_currentPlaylist(This,pPL)	\
    (This)->lpVtbl -> put_currentPlaylist(This,pPL)

#define IWMPCore2_get_cdromCollection(This,ppCdromCollection)	\
    (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection)

#define IWMPCore2_get_closedCaption(This,ppClosedCaption)	\
    (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption)

#define IWMPCore2_get_isOnline(This,pfOnline)	\
    (This)->lpVtbl -> get_isOnline(This,pfOnline)

#define IWMPCore2_get_error(This,ppError)	\
    (This)->lpVtbl -> get_error(This,ppError)

#define IWMPCore2_get_status(This,pbstrStatus)	\
    (This)->lpVtbl -> get_status(This,pbstrStatus)


#define IWMPCore2_get_dvd(This,ppDVD)	\
    (This)->lpVtbl -> get_dvd(This,ppDVD)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPCore2_get_dvd_Proxy( 
    IWMPCore2 __RPC_FAR * This,
    /* [retval][out] */ IWMPDVD __RPC_FAR *__RPC_FAR *ppDVD);


void __RPC_STUB IWMPCore2_get_dvd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCore2_INTERFACE_DEFINED__ */


#ifndef __IWMPPlayer3_INTERFACE_DEFINED__
#define __IWMPPlayer3_INTERFACE_DEFINED__

/* interface IWMPPlayer3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayer3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54062B68-052A-4c25-A39F-8B63346511D4")
    IWMPPlayer3 : public IWMPCore2
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_fullScreen( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_fullScreen( 
            VARIANT_BOOL bFullScreen) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_enableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_enableContextMenu( 
            VARIANT_BOOL bEnableContextMenu) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_uiMode( 
            /* [in] */ BSTR bstrMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_uiMode( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_stretchToFit( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_stretchToFit( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_windowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_windowlessVideo( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayer3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPPlayer3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPPlayer3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *close )( 
            IWMPPlayer3 __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_openState )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ WMPOpenState __RPC_FAR *pwmpos);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playState )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ WMPPlayState __RPC_FAR *pwmpps);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_controls )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPControls __RPC_FAR *__RPC_FAR *ppControl);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_settings )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPSettings __RPC_FAR *__RPC_FAR *ppSettings);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentMedia )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPMedia __RPC_FAR *__RPC_FAR *ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentMedia )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ IWMPMedia __RPC_FAR *pMedia);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mediaCollection )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPMediaCollection __RPC_FAR *__RPC_FAR *ppMediaCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_playlistCollection )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylistCollection __RPC_FAR *__RPC_FAR *ppPlaylistCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_versionInfo )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *launchURL )( 
            IWMPPlayer3 __RPC_FAR * This,
            BSTR bstrURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_network )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPNetwork __RPC_FAR *__RPC_FAR *ppQNI);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPlaylist )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPPlaylist __RPC_FAR *__RPC_FAR *ppPL);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPlaylist )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ IWMPPlaylist __RPC_FAR *pPL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cdromCollection )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPCdromCollection __RPC_FAR *__RPC_FAR *ppCdromCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_closedCaption )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPClosedCaption __RPC_FAR *__RPC_FAR *ppClosedCaption);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_isOnline )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfOnline);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_error )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPError __RPC_FAR *__RPC_FAR *ppError);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dvd )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ IWMPDVD __RPC_FAR *__RPC_FAR *ppDVD);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enabled )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enabled )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fullScreen )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_fullScreen )( 
            IWMPPlayer3 __RPC_FAR * This,
            VARIANT_BOOL bFullScreen);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enableContextMenu )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enableContextMenu )( 
            IWMPPlayer3 __RPC_FAR * This,
            VARIANT_BOOL bEnableContextMenu);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_uiMode )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ BSTR bstrMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_uiMode )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_stretchToFit )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_stretchToFit )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_windowlessVideo )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_windowlessVideo )( 
            IWMPPlayer3 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        END_INTERFACE
    } IWMPPlayer3Vtbl;

    interface IWMPPlayer3
    {
        CONST_VTBL struct IWMPPlayer3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayer3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPPlayer3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPPlayer3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPPlayer3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMPPlayer3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMPPlayer3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMPPlayer3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMPPlayer3_close(This)	\
    (This)->lpVtbl -> close(This)

#define IWMPPlayer3_get_URL(This,pbstrURL)	\
    (This)->lpVtbl -> get_URL(This,pbstrURL)

#define IWMPPlayer3_put_URL(This,bstrURL)	\
    (This)->lpVtbl -> put_URL(This,bstrURL)

#define IWMPPlayer3_get_openState(This,pwmpos)	\
    (This)->lpVtbl -> get_openState(This,pwmpos)

#define IWMPPlayer3_get_playState(This,pwmpps)	\
    (This)->lpVtbl -> get_playState(This,pwmpps)

#define IWMPPlayer3_get_controls(This,ppControl)	\
    (This)->lpVtbl -> get_controls(This,ppControl)

#define IWMPPlayer3_get_settings(This,ppSettings)	\
    (This)->lpVtbl -> get_settings(This,ppSettings)

#define IWMPPlayer3_get_currentMedia(This,ppMedia)	\
    (This)->lpVtbl -> get_currentMedia(This,ppMedia)

#define IWMPPlayer3_put_currentMedia(This,pMedia)	\
    (This)->lpVtbl -> put_currentMedia(This,pMedia)

#define IWMPPlayer3_get_mediaCollection(This,ppMediaCollection)	\
    (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection)

#define IWMPPlayer3_get_playlistCollection(This,ppPlaylistCollection)	\
    (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection)

#define IWMPPlayer3_get_versionInfo(This,pbstrVersionInfo)	\
    (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo)

#define IWMPPlayer3_launchURL(This,bstrURL)	\
    (This)->lpVtbl -> launchURL(This,bstrURL)

#define IWMPPlayer3_get_network(This,ppQNI)	\
    (This)->lpVtbl -> get_network(This,ppQNI)

#define IWMPPlayer3_get_currentPlaylist(This,ppPL)	\
    (This)->lpVtbl -> get_currentPlaylist(This,ppPL)

#define IWMPPlayer3_put_currentPlaylist(This,pPL)	\
    (This)->lpVtbl -> put_currentPlaylist(This,pPL)

#define IWMPPlayer3_get_cdromCollection(This,ppCdromCollection)	\
    (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection)

#define IWMPPlayer3_get_closedCaption(This,ppClosedCaption)	\
    (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption)

#define IWMPPlayer3_get_isOnline(This,pfOnline)	\
    (This)->lpVtbl -> get_isOnline(This,pfOnline)

#define IWMPPlayer3_get_error(This,ppError)	\
    (This)->lpVtbl -> get_error(This,ppError)

#define IWMPPlayer3_get_status(This,pbstrStatus)	\
    (This)->lpVtbl -> get_status(This,pbstrStatus)


#define IWMPPlayer3_get_dvd(This,ppDVD)	\
    (This)->lpVtbl -> get_dvd(This,ppDVD)


#define IWMPPlayer3_get_enabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_enabled(This,pbEnabled)

#define IWMPPlayer3_put_enabled(This,bEnabled)	\
    (This)->lpVtbl -> put_enabled(This,bEnabled)

#define IWMPPlayer3_get_fullScreen(This,pbFullScreen)	\
    (This)->lpVtbl -> get_fullScreen(This,pbFullScreen)

#define IWMPPlayer3_put_fullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> put_fullScreen(This,bFullScreen)

#define IWMPPlayer3_get_enableContextMenu(This,pbEnableContextMenu)	\
    (This)->lpVtbl -> get_enableContextMenu(This,pbEnableContextMenu)

#define IWMPPlayer3_put_enableContextMenu(This,bEnableContextMenu)	\
    (This)->lpVtbl -> put_enableContextMenu(This,bEnableContextMenu)

#define IWMPPlayer3_put_uiMode(This,bstrMode)	\
    (This)->lpVtbl -> put_uiMode(This,bstrMode)

#define IWMPPlayer3_get_uiMode(This,pbstrMode)	\
    (This)->lpVtbl -> get_uiMode(This,pbstrMode)

#define IWMPPlayer3_get_stretchToFit(This,pbEnabled)	\
    (This)->lpVtbl -> get_stretchToFit(This,pbEnabled)

#define IWMPPlayer3_put_stretchToFit(This,bEnabled)	\
    (This)->lpVtbl -> put_stretchToFit(This,bEnabled)

#define IWMPPlayer3_get_windowlessVideo(This,pbEnabled)	\
    (This)->lpVtbl -> get_windowlessVideo(This,pbEnabled)

#define IWMPPlayer3_put_windowlessVideo(This,bEnabled)	\
    (This)->lpVtbl -> put_windowlessVideo(This,bEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_get_enabled_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);


void __RPC_STUB IWMPPlayer3_get_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_put_enabled_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IWMPPlayer3_put_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_get_fullScreen_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);


void __RPC_STUB IWMPPlayer3_get_fullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_put_fullScreen_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    VARIANT_BOOL bFullScreen);


void __RPC_STUB IWMPPlayer3_put_fullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_get_enableContextMenu_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnableContextMenu);


void __RPC_STUB IWMPPlayer3_get_enableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_put_enableContextMenu_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    VARIANT_BOOL bEnableContextMenu);


void __RPC_STUB IWMPPlayer3_put_enableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_put_uiMode_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [in] */ BSTR bstrMode);


void __RPC_STUB IWMPPlayer3_put_uiMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_get_uiMode_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMode);


void __RPC_STUB IWMPPlayer3_get_uiMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_get_stretchToFit_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);


void __RPC_STUB IWMPPlayer3_get_stretchToFit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_put_stretchToFit_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IWMPPlayer3_put_stretchToFit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_get_windowlessVideo_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbEnabled);


void __RPC_STUB IWMPPlayer3_get_windowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWMPPlayer3_put_windowlessVideo_Proxy( 
    IWMPPlayer3 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IWMPPlayer3_put_windowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPPlayer3_INTERFACE_DEFINED__ */



#ifndef __WMPOCX_LIBRARY_DEFINED__
#define __WMPOCX_LIBRARY_DEFINED__

/* library WMPOCX */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WMPOCX;

#ifndef ___WMPOCXEvents_DISPINTERFACE_DEFINED__
#define ___WMPOCXEvents_DISPINTERFACE_DEFINED__

/* dispinterface _WMPOCXEvents */
/* [hidden][helpstring][uuid] */ 


EXTERN_C const IID DIID__WMPOCXEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("6BF52A51-394A-11d3-B153-00C04F79FAA6")
    _WMPOCXEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _WMPOCXEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _WMPOCXEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _WMPOCXEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _WMPOCXEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _WMPOCXEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _WMPOCXEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _WMPOCXEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _WMPOCXEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _WMPOCXEventsVtbl;

    interface _WMPOCXEvents
    {
        CONST_VTBL struct _WMPOCXEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _WMPOCXEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _WMPOCXEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _WMPOCXEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _WMPOCXEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _WMPOCXEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _WMPOCXEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _WMPOCXEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___WMPOCXEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WMPOCX;

#ifdef __cplusplus

class DECLSPEC_UUID("6BF52A52-394A-11d3-B153-00C04F79FAA6")
WMPOCX;
#endif
#endif /* __WMPOCX_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\autorun.h ===
// welcome.h: interface for the CDataSource class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#define ARM_CHANGESCREEN   WM_USER + 1
// Forced to define these myself because they weren't on Win95.
#undef StrRChr
#undef StrChr

LPSTR StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LPSTR StrChr(LPCSTR lpStart, WORD wMatch);

#include "dataitem.h"

// Relative Version
enum RELVER
{ 
    VER_UNKNOWN,        // we haven't checked the version yet
    VER_INCOMPATIBLE,   // the current os cannot be upgraded using this CD (i.e. win32s)
    VER_OLDER,          // current os is an older version on NT or is win9x
    VER_SAME,           // current os is the same version as the CD
    VER_NEWER,          // the CD contains a newer version of the OS
};

class CDataSource
{
public:

    CDataItem   m_data[9];
    int         m_iItems;
    RELVER      m_Version;

    CDataSource();
    ~CDataSource();

    bool Init();
    CDataItem & operator [] ( int i );
    void Invoke( int i, HWND hwnd );
    void Uninit( DWORD dwData );
    void ShowSplashScreen(HWND hwnd);
    bool DisplayErrorMessage(int ids);

protected:
    HWND    m_hwndDlg;
    const int     *m_piScreen; //pointer to array of menu items on the screen

    BOOL IsNec98();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources

Abstract:

    This file specifies project-wide macros for the OPK tools.

Author:

    Jason Cohen (jcohen)

!ENDIF

OPKROOT=$(PROJECT_ROOT)\ntsetup\opktools
OPK_LIB_PATH=$(OPKROOT)\lib\$(O)
OPK_INC_PATH=$(OPKROOT)\inc

OPKLIB=$(OPKROOT)\opklib\$(O)
OPKINC=$(OPK_INC_PATH)

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

!IF DEFINED (OPK_BINPLACE_ARCH)
BINPLACE_PLACEFILE=$(OPKROOT)\$(TARGET_DIRECTORY)\placefil.txt
!ELSE
BINPLACE_PLACEFILE=$(OPKROOT)\placefil.txt
!ENDIF

INCLUDES=$(INCLUDES);$(OPKINC);$(PROJECT_INC_PATH);$(BASE_INC_PATH);$(SHELL_INC_PATH)

!INCLUDE $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\autorun.cpp ===
// autorun.cpp: implementation of the CDataSource class for the welcome applet.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <ntverp.h>
#include <winbase.h>
#include "autorun.h"
#include "resource.h"
#include <tchar.h>

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#define MAJOR           (VER_PRODUCTMAJORVERSION)       // defined in ntverp.h
#define MINOR           (VER_PRODUCTMINORVERSION)       // defined in ntverp.h
#define BUILD           (VER_PRODUCTBUILD)              // defined in ntverp.h

#define REG_KEY_OPK             _T("SOFTWARE\\Microsoft\\OPK")
#define REG_KEY_OPK_LANGS       REG_KEY_OPK _T("\\Langs")
#define REG_VAL_PATH            _T("Path")
#define REG_VAL_LANG            _T("Lang")
#define STR_VAL_EXE_NAME        _T("langinst.exe")
#define STR_VAL_INF_NAME        _T("langinst.inf")
#define INF_SEC_STRINGS         _T("Strings")
#define INF_KEY_LANG            _T("Lang")

// Memory managing macros.
//
#ifdef MALLOC
#undef MALLOC
#endif // MALLOC
#define MALLOC(cb)          HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)

#ifdef REALLOC
#undef REALLOC
#endif // REALLOC
#define REALLOC(lp, cb)     HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lp, cb)

#ifdef FREE
#undef FREE
#endif // FREE
#define FREE(lp)            ( (lp != NULL) ? ( (HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, (LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )


// I'm doing my own version of these functions because they weren't in win95.
// These come from shell\shlwapi\strings.c.

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif

LPTSTR RegGetStringEx(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue, BOOL bExpand)
{
    HKEY    hOpenKey    = NULL;
    LPTSTR  lpBuffer    = NULL,
            lpExpand    = NULL;
    DWORD   dwSize      = 0,
            dwType;

    // If the key is specified, we must open it.  Otherwise we can
    // just use the HKEY passed in.
    //
    if (lpKey)
    {
        // If the open key fails, return NULL because the value can't exist.
        //
        if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
            return NULL;
    }
    else
        hOpenKey = hKeyReg;

    // Now query the value to get the size to allocate.  Make sure the date
    // type is a string and that the malloc doesn't fail.
    //
    if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS ) &&
         ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) &&
         ( lpBuffer = (LPTSTR) MALLOC(dwSize) ) )
    {
        // We know the value exists and we have the memory we need to query the value again.
        //
        if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) == ERROR_SUCCESS ) &&
             ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) )
        {
            // We should expand it if it is supposed to be.
            //
            if ( ( bExpand ) &&
                 ( dwType == REG_EXPAND_SZ ) )
            {
                if ( ( dwSize = ExpandEnvironmentStrings(lpBuffer, NULL, 0) ) &&
                     ( lpExpand = (LPTSTR) MALLOC(dwSize * sizeof(TCHAR)) ) &&
                     ( ExpandEnvironmentStrings(lpBuffer, lpExpand, dwSize) ) &&
                     ( *lpExpand ) )
                {
                    // The expand worked, so free the original buffer and return
                    // the expanded one.
                    //
                    FREE(lpBuffer);
                    lpBuffer = lpExpand;
                }
                else
                {
                    // The expand failed see we should free everything up
                    // and return NULL.
                    //
                    FREE(lpExpand);
                    FREE(lpBuffer);
                }
            }
        }
        else
            // For some reason the query failed, that shouldn't happen
            // but now we need to free and return NULL.
            //
            FREE(lpBuffer);
    }

    // If we opened a key, we must close it.
    //
    if (lpKey)
        RegCloseKey(hOpenKey);

    // Return the buffer allocated, or NULL if something failed.
    //
    return lpBuffer;
}

LPTSTR RegGetString(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
    return RegGetStringEx(hKeyReg, lpKey, lpValue, FALSE);
}


/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    ASSERT(lpStart);
    ASSERT(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart));

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS)
{
    if (fMBCS) {
        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    } else {
        for ( ; *lpStart; lpStart++)
        {
            if ((BYTE)*lpStart == LOBYTE(wMatch)) {
                return((LPSTR)lpStart);
            }
        }
    }
    return (NULL);
}

LPSTR StrChr(LPCSTR lpStart, WORD wMatch)
{
    CPINFO cpinfo;
    return _StrChrA(lpStart, wMatch, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

// Must match string table entries in resource.rc 
//
#define INSTALL_WINNT   0
#define LAUNCH_ARP      1
#define SUPPORT_TOOLS   2
#define OPK_TOOLS       3
#define EXIT_AUTORUN    4
#define BACK            5
#define BROWSE_CD       6
#define HOMENET_WIZ     7
#define TS_CLIENT       8
#define COMPAT_WEB      9
#define MAX_OPTIONS     10

const int c_aiMain[] = {INSTALL_WINNT, SUPPORT_TOOLS, EXIT_AUTORUN};
const int c_aiWhistler[] = {INSTALL_WINNT, LAUNCH_ARP, SUPPORT_TOOLS, EXIT_AUTORUN};
const int c_aiOpk[] = {OPK_TOOLS, BROWSE_CD, EXIT_AUTORUN};

#if BUILD_PERSONAL_VERSION
const int c_aiSupport[] = {HOMENET_WIZ, BROWSE_CD, TS_CLIENT, COMPAT_WEB, BACK};
#else
const int c_aiSupport[] = {TS_CLIENT, COMPAT_WEB, BACK};
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataSource::CDataSource()
{
    m_iItems = 0;
}

CDataSource::~CDataSource()
{
}

CDataItem & CDataSource::operator[](int i)
{
    return m_data[m_piScreen[i]];
}

/*
    10.05.96    Shunichi Kajisa (shunk)     Support NEC PC-98

    1. Determine if autorun is running on PC-98 or regular PC/AT by:

            bNEC98 = (HIBYTE(LOWORD(GetKeyboardType(1))) == 0x0D)? TRUE : FALSE;

        Following description is from KB Q130054, and this can be applied on NT and Win95:

            If an application uses the GetKeyboardType API, it can get OEM ID by
            specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
            is listed here:
             
               OEM Windows       OEM ID
               ------------------------------
               Microsoft         00H (DOS/V)
               ....
               NEC               0DH

 
    2. If autorun is running on PC-98, replace every "I386" resource with "PC98" at runtime,
       regardless that autorun is running on NT or Win95.


    Notes:
    - NEC PC-98 is available only in Japan.
    - NEC PC-98 uses x86 processor, but the underlaying hardware architecture is different.
      The PC98 files is stored under CD:\pc98 directory instead of CD:\i386.
    - There was an idea that we should detect PC-98 in SHELL32.DLL, and treat PC98 as a different
      platform, like having [AutoRun.Pc98] section in NT CD's autorun.inf. We don't do this, since
      Win95 doesn't support this, and we don't want to introduce the apps incompatibility.
      In any case, if app has any dependency on the hardware and needs to do any special things,
      the app should detect the hardware and OS. This is separate issue from Autorun.exe.
    
*/
BOOL CDataSource::IsNec98()
{
    return ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));
}

void PathRemoveFilespec( LPTSTR psz )
{
    TCHAR * pszT = StrRChr( psz, psz+lstrlen(psz)-1, TEXT('\\') );

    if (pszT)
        *(pszT+1) = NULL;
}

void PathAppend(LPTSTR pszPath, LPTSTR pMore)
{
    lstrcpy(pszPath+lstrlen(pszPath), pMore);
}

BOOL PathFileExists( LPTSTR pszPath )
{
    BOOL fResult = FALSE;
    DWORD dwErrMode;

    dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    fResult = ((UINT)GetFileAttributes(pszPath) != (UINT)-1);

    SetErrorMode(dwErrMode);

    return fResult;
}

#ifdef BUILD_OPK_VERSION

void RunLangInst(LPTSTR lpszFileName, LPTSTR lpszLangInstInf) 
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR szCmdLine[MAX_PATH * 2];  // Make sure that we have enough space.
    
    lstrcpyn(szCmdLine, lpszFileName, ARRAYSIZE(szCmdLine) );
    lstrcat(szCmdLine, _T(" "));
    lstrcpyn(szCmdLine + lstrlen(szCmdLine), lpszLangInstInf, ARRAYSIZE(szCmdLine) - lstrlen(szCmdLine));
    
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);
    
    // Run langinst. Create a message pump so that the window redraws properly.
    //
    if (CreateProcess(NULL,
                  szCmdLine, 
                  NULL, 
                  NULL, 
                  FALSE, 
                  0,
                  NULL,                  
                  NULL,
                  &si,
                  &pi)) 
    {
        if (NULL != pi.hProcess)
        {
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
    }
}

#endif

// Init
//
// For autorun we read all the items out of the resources.
bool CDataSource::Init()
{
    // read the text for the items from the resources
    HINSTANCE hinst = GetModuleHandle(NULL);
    TCHAR szModuleName[MAX_PATH];

    TCHAR szTitle[256];
    TCHAR szDesc[1024];
    TCHAR szMenu[256];
    TCHAR szConfig[MAX_PATH];
    TCHAR szArgs[MAX_PATH];

    szModuleName[0] = TEXT('\0');                                       // in case GetModuleFileName fails to initialize szModuleName
    GetModuleFileName(hinst, szModuleName, ARRAYSIZE(szModuleName));    // ex: "e:\i386\autorun.exe" or "e:\setup.exe"
    PathRemoveFilespec(szModuleName);                                   // ex: "e:\i386\" or "e:\"
    PathAppend(szModuleName, TEXT("winnt32.exe"));                      //

    if ( PathFileExists(szModuleName) )
    {
        // we were launched from the platform directory, use szModuleName as the winnt32 path
    }
    else
    {
        // we were launched from the root.  Append either "alpha", "i386", or "NEC98" to the path.
        SYSTEM_INFO si;

        PathRemoveFilespec(szModuleName);
        GetSystemInfo(&si);

#if !(defined(_AMD64_) || defined(_X86_) || defined(_IA64_))
#error New architecture must be added to switch statement.
#endif
        switch (si.wProcessorArchitecture)
        {
            case PROCESSOR_ARCHITECTURE_AMD64:
            {
                PathAppend(szModuleName, TEXT("amd64\\winnt32.exe"));
            }

            case PROCESSOR_ARCHITECTURE_IA64:
            {
                PathAppend(szModuleName, TEXT("ia64\\winnt32.exe"));
            }
            break;

            case PROCESSOR_ARCHITECTURE_INTEL:
            default:
            {
                if (IsNec98())
                {
                    PathAppend(szModuleName, TEXT("nec98\\winnt32.exe"));
                }
                else
                {
                    PathAppend(szModuleName, TEXT("i386\\winnt32.exe"));
                }
            }
            break;
        }
    }

    for (int i=0; i<MAX_OPTIONS; i++)
    {
        LoadString(hinst, IDS_TITLE0+i, szTitle, ARRAYSIZE(szTitle));
        LoadString(hinst, IDS_MENU0+i, szMenu, ARRAYSIZE(szMenu));
        LoadString(hinst, IDS_DESC0+i, szDesc, ARRAYSIZE(szDesc));

        // for INSTALL_WINNT we prepend the correct path to winnt32 in front of the string
        if ( INSTALL_WINNT == i )
        {
            lstrcpy( szConfig, szModuleName );
            if ( !PathFileExists(szModuleName) )
            {
                // we can't run the item if it's not there.  This will prevent an
                // alpha CD from trying to install on an x86 and vice versa.
                m_data[INSTALL_WINNT].m_dwFlags |= WF_DISABLED|WF_ALTERNATECOLOR;
            }
        }
        // Copied this code from nt\shell\applets\autorun\autorun.cpp
        //
        else if (BROWSE_CD == i) // for BROWSE_CD we pass the directory as an argument to explorer.exe
        {
            // PathRemoveFileSpce twice to remove the path added to module name above.  
            // This is really crappy code!!!
            //
            lstrcpy( szArgs, szModuleName );
            PathRemoveFilespec( szArgs );
            PathRemoveFilespec( szArgs );
            LoadString(hinst, IDS_CONFIG0+i, szConfig, ARRAYSIZE(szConfig));
        }
        else
        {
            LoadString(hinst, IDS_CONFIG0+i, szConfig, ARRAYSIZE(szConfig));
            LoadString(hinst, IDS_ARGS0+i, szArgs, ARRAYSIZE(szArgs));
        }

        

        m_data[i].SetData( szTitle, szMenu, szDesc, szConfig, *szArgs?szArgs:NULL, 0, (i+1)%4 );
        //these are not implemented yet
        switch (i)
        {
        case HOMENET_WIZ:
        case TS_CLIENT:
        case COMPAT_WEB:
            m_data[i].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
            break;
        default:
            break;
        }
    }

     // Should we display the "This CD contains a newer version" dialog?
        OSVERSIONINFO ovi;
        ovi.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO );
    if ( !GetVersionEx(&ovi) || ovi.dwPlatformId==VER_PLATFORM_WIN32s )
    {
        // We cannot upgrade win32s systems.
        m_Version = VER_INCOMPATIBLE;
    }
    else if ( ovi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS )
    {
        if (ovi.dwMajorVersion > 3)
        {
            // we can always upgrade win98+ systems to NT
            m_Version = VER_OLDER;
            // Disable ARP.  ARP is only enabled if the CD and the OS are the same version
            m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
        }
        else
        {
            m_Version = VER_INCOMPATIBLE;
        }
    }
    else if ((MAJOR > ovi.dwMajorVersion) ||
             ((MAJOR == ovi.dwMajorVersion) && ((MINOR > ovi.dwMinorVersion) || ((MINOR == ovi.dwMinorVersion) && (BUILD > ovi.dwBuildNumber)))))
    {
        // For NT to NT upgrades, we only upgrade if the version is lower

        // For NT 3.51 we have some special case code
        if ( ovi.dwMajorVersion == 3 )
        {
            // must be at least NT 3.51
            if ( ovi.dwMinorVersion < 51 )
            {
                // On NT 3.1 we might be able to launch winnt32.exe
                STARTUPINFO sinfo =
                {
                    sizeof(STARTUPINFO),
                };
                PROCESS_INFORMATION pinfo;
                CreateProcess(NULL,szModuleName,NULL,NULL,FALSE,0,NULL,NULL,&sinfo,&pinfo);

                return FALSE;
            }
        }

        m_Version = VER_OLDER;
        
        // Disable ARP.  ARP is only enabled if the CD and the OS are the same version
        m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
    }
    else if ((MAJOR < ovi.dwMajorVersion) || (MINOR < ovi.dwMinorVersion) || (BUILD < ovi.dwBuildNumber))
    {
        m_Version = VER_NEWER;

        // disable upgrade and ARP buttons
        m_data[INSTALL_WINNT].m_dwFlags |= WF_DISABLED|WF_ALTERNATECOLOR;
        m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
    }
    else
    {
        m_Version = VER_SAME;
    }

#ifdef BUILD_OPK_VERSION
    // 
    // We don't support Win9x and NT 4 or older
    //
    if ( (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
         ((ovi.dwMajorVersion <= 4) && (ovi.dwPlatformId==VER_PLATFORM_WIN32_NT))
       )
    {
        return DisplayErrorMessage(IDS_WRONGOS);
    }

    m_piScreen = c_aiOpk;
    m_iItems = ARRAYSIZE(c_aiOpk);
#else
    if (m_Version == VER_SAME)
    {
        m_piScreen = c_aiWhistler;
        m_iItems = ARRAYSIZE(c_aiWhistler);
    }
    else
    {
        m_piScreen = c_aiMain;
        m_iItems = ARRAYSIZE(c_aiMain);
    }
#endif

    return true;
}

void CDataSource::Invoke( int i, HWND hwnd )
{
    i = m_piScreen[i];
    // if this item is disalbled then do nothing
    if ( m_data[i].m_dwFlags & WF_DISABLED )
    {
        MessageBeep(0);
        return;
    }

    // otherwise we have already built the correct command and arg strings so just invoke them
    switch (i)
    {
    case INSTALL_WINNT:
    case LAUNCH_ARP:
        m_data[i].Invoke(hwnd);
        break;
    case EXIT_AUTORUN:
        DestroyWindow( m_hwndDlg );
        PostQuitMessage( 0 );
        break;

#ifdef BUILD_OPK_VERSION
    case OPK_TOOLS:
        {
            LPTSTR lpPath;
            LPTSTR lpLang;
            TCHAR  szBuffer[10] = TEXT(""); // Languages are normally 3 characters.
            BOOL   bLangInstRun = FALSE;

            // Check here to see if the opktools are installed already.
            // If they are, and the language we are trying to install is different
            // then run langinst.exe instead of the msi.
            //
            lpPath = RegGetString(HKEY_LOCAL_MACHINE, REG_KEY_OPK, REG_VAL_PATH);
            lpLang = RegGetString(HKEY_LOCAL_MACHINE, REG_KEY_OPK, REG_VAL_LANG);
        
            if ( lpPath && lpLang)
            {
                TCHAR szLangInstExe[MAX_PATH];
                TCHAR szLangInstInf[MAX_PATH] = TEXT("\0");

                // Build the path to the langinst.inf from the install media.
                //
                GetModuleFileName(NULL, szLangInstInf, MAX_PATH);
                PathRemoveFilespec(szLangInstInf);
                PathAppend(szLangInstInf, STR_VAL_INF_NAME);
                
                // Create the path to point to langinst.exe that's installed on the system.
                //
                lstrcpy(szLangInstExe, lpPath);
                PathAppend(szLangInstExe, STR_VAL_EXE_NAME);

                // Only run langinst if the language that is installed on the machine is different than
                // the language we are trying to install.
                //
                if ( GetPrivateProfileString(INF_SEC_STRINGS, INF_KEY_LANG, _T(""), szBuffer, ARRAYSIZE(szBuffer), szLangInstInf) &&
                     szBuffer[0] &&
                     (0 != lstrcmpi(szBuffer, lpLang))
                   )
                {
                    // Remove the inf name from the path.
                    //
                    PathRemoveFilespec(szLangInstInf);

                    if ( PathFileExists( szLangInstExe ) )
                    {
                        // Run langinst.exe if it's there on the disk but with the langinst.inf from the
                        // install media
                        //
                        RunLangInst(szLangInstExe, szLangInstInf);
                        bLangInstRun = TRUE;
                    }
                }
            }
            
            // If Langinst.exe did not run for any reason just run the opk.msi.
            //
            if ( !bLangInstRun )
            {
                m_data[i].Invoke(hwnd);
            }
            
            FREE(lpPath);  // MACRO checks for NULL
            FREE(lpLang);  // MACRO checks for NULL
            PostQuitMessage(0);
            break;
        }
    case BROWSE_CD:
        m_data[i].Invoke(hwnd);
        break;
#endif

    case SUPPORT_TOOLS:
        m_piScreen = c_aiSupport;
        m_iItems = ARRAYSIZE(c_aiSupport);
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, 0, 0);
        break;

    case BACK:
        if (m_Version == VER_SAME)
        {
            m_piScreen = c_aiWhistler;
            m_iItems = ARRAYSIZE(c_aiWhistler);
        }
        else
        {
            m_piScreen = c_aiMain;
            m_iItems = ARRAYSIZE(c_aiMain);
        }
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, 0, 0);
        break;

    default:
        // Assert?  Debug trace message?
        break;
    }
}

// Uninit
//
// This is a chance to do any required shutdown stuff, such as persisting state information.
void CDataSource::Uninit(DWORD dwData)
{
}

// ShowSplashScreen
//
// This hook is provided to allow the display of additional UI right after the main window is diaplyed.
// In our case we want to show a dialog asking if the user wants to upgrade.
void CDataSource::ShowSplashScreen(HWND hwnd)
{
    m_hwndDlg = hwnd;
}

// DisplayMessage
// 
// Displays the ids in a message box and returns false so we quit the app.
//
bool CDataSource::DisplayErrorMessage(int ids)
{
    HINSTANCE hinst = GetModuleHandle(NULL);
    TCHAR szMessage[256], szTitle[256];

    if (hinst)
    {
        LoadString(hinst, IDS_TITLE_OPK, szTitle, ARRAYSIZE(szTitle));
        LoadString(hinst, ids, szMessage, ARRAYSIZE(szMessage));
        MessageBox(0, szMessage, szTitle, MB_ICONSTOP|MB_OK);
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\dataitem.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <commctrl.h>
#include "dataitem.h"
#include "resource.h"
#include "autorun.h"

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

CDataItem::CDataItem()
{
    m_pszTitle = m_pszMenuName = m_pszDescription = m_pszCmdLine = m_pszArgs = NULL;
    m_dwFlags = 0;
    m_chAccel = NULL;
}

CDataItem::~CDataItem()
{
    if ( m_pszTitle )
        delete [] m_pszTitle;
    if ( m_pszMenuName )
        delete [] m_pszMenuName;
    if ( m_pszDescription )
        delete [] m_pszDescription;
    if ( m_pszCmdLine )
        delete [] m_pszCmdLine;
    if ( m_pszArgs )
        delete [] m_pszArgs;
}

BOOL CDataItem::SetData( LPTSTR szTitle, LPTSTR szMenu, LPTSTR szDesc, LPTSTR szCmd, LPTSTR szArgs, DWORD dwFlags, int iImgIndex )
{
    TCHAR * psz;

    // This function should only be called once or else we will leak like a, like a, a thing that leaks a lot.
    ASSERT( NULL==m_pszTitle && NULL==m_pszMenuName && NULL==m_pszDescription && NULL==m_pszCmdLine && NULL==m_pszArgs );

    m_pszTitle = new TCHAR[lstrlen(szTitle)+1];
    if ( m_pszTitle )
        lstrcpy( m_pszTitle, szTitle );

    if ( szMenu )
    {
        // menuname is allowed to remain NULL.  This is only used if you want the
        // text on the menu item to be different than the description. This could
        // be useful for localization where a shortened name might be required.
        m_pszMenuName = new TCHAR[lstrlen(szMenu)+1];
        if ( m_pszMenuName )
            lstrcpy( m_pszMenuName, szMenu );

        psz = StrChr(szMenu, TEXT('&'));
        if ( psz )
            m_chAccel = *(CharNext(psz));
    }

    m_pszDescription = new TCHAR[lstrlen(szDesc)+1];
    if ( m_pszDescription )
        lstrcpy( m_pszDescription, szDesc );

    m_pszCmdLine = new TCHAR[lstrlen(szCmd)+1];
    if ( m_pszCmdLine )
        lstrcpy( m_pszCmdLine, szCmd );

    if ( szArgs )
    {
        // Some commands don't have any args so this can remain NULL.  This is only used
        // if the executable requires arguments.
        m_pszArgs = new TCHAR[lstrlen(szArgs)+1];
        if ( m_pszArgs )
            lstrcpy( m_pszArgs, szArgs );
    }

    m_dwFlags = dwFlags;
    m_iImage = iImgIndex;

    return TRUE;
}

BOOL CDataItem::Invoke(HWND hwnd)
{
    BOOL fResult;
    TCHAR szCmdLine[MAX_PATH*2];
    PROCESS_INFORMATION ei;
    STARTUPINFO si = {0};
    si.cb = sizeof(si);

    lstrcpy( szCmdLine, m_pszCmdLine );
    if ( m_pszArgs )
    {
        strcat( szCmdLine, TEXT(" ") );
        strcat( szCmdLine, m_pszArgs );
    }

    fResult = CreateProcess(NULL, szCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &ei);
    if (fResult)
    {
        if (NULL != ei.hProcess)
        {
            DWORD dwObject;

            // passing in a NULL HWND is used as a signal not to wait in this inner loop.
            while (hwnd)
            {
                dwObject = MsgWaitForMultipleObjects(1, &ei.hProcess, FALSE, INFINITE, QS_ALLINPUT);
                
                if (WAIT_OBJECT_0 == dwObject)
                {
                    break;
                }
                else if (WAIT_OBJECT_0+1 == dwObject)
                {
                    MSG msg;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
                    {
                        if ( WM_QUIT == msg.message )
                        {
                            CloseHandle(ei.hProcess);
                            return fResult;
                        }
                        else
                        {
                            GetMessage(&msg, NULL, 0, 0);

                            // IsDialogMessage cannot understand the concept of ownerdraw default pushbuttons.  It treats
                            // these attributes as mutually exclusive.  As a result, we handle this ourselves.  We want
                            // whatever control has focus to act as the default pushbutton.
                            if ( (WM_KEYDOWN == msg.message) && (VK_RETURN == msg.wParam) )
                            {
                                HWND hwndFocus = GetFocus();
                                if ( hwndFocus )
                                {
                                    SendMessage(hwnd, WM_COMMAND, MAKELONG(GetDlgCtrlID(hwndFocus), BN_CLICKED), (LPARAM)hwndFocus);
                                }
                                continue;
                            }

                            if ( IsDialogMessage(hwnd, &msg) )
                                continue;

                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                    }
                }
            }

            if ( !hwnd )
            {
                // A NULL hwnd means we were called in the mode by which we execute the item and then immediately
                // exit.  If our process exits before the other process is ready it'll end up in the wrong place
                // in the z-order.  To prevent this, when we're in "exit when done" mode we need to wait for the
                // process we created to be ready.  The way to do this is to call WaitForInputIdle.  This is really
                // only needed on NT5 and above due to the new "rude window activation" stuff, but since this API
                // is available all the way back to NT 3.1 we simply call it blindly.
                WaitForInputIdle(ei.hProcess, 20*1000);     // we wait a maximum of 20 seconds
            }

            CloseHandle(ei.hProcess);
        }
    }
    else
    {
        // do something if we fail to create a process?
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#pragma warning (disable:4096)      // '__cdecl' must be used with '...'
#pragma warning (disable:4201)      // nonstandard extension used : nameless struct/union
#pragma warning (disable:4115)      // named type definition in parentheses

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR FAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR FAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  FAR c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipMsg[] = SZ_MODULE "  RIP: ";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

#endif // !UNIX


// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_qwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern ULONGLONG g_qwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs
#define BF_LEAKS            0x80000000      // Break on detecting a leak

// Trace flags for g_qwTraceFlags
#define TF_ALWAYS           0xFFFFFFFFFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
#define TF_MEMUSAGE                       0x0000000100000000      
#define TF_KEEP_ALLOCATION_STACKS         0x0000000200000000      
// (Upper 28 bits reserved for custom use per-module)

#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

// Old, archaic debug flags.  
// APPCOMPAT (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

void    AttachUserModeDebugger (void);

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        AttachUserModeDebugger();                       \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                _asm int 3                              \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
        } while (gAlwaysAssert);                        \
    }
#else
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        AttachUserModeDebugger();                       \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                DebugBreak();                           \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
            __endexcept                                 \
        } while (gAlwaysAssert);                        \
    }
#endif

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);


void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define Assert(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);


#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

#else  // DEBUG

#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_qwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_qwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

UINT GetStack(UINT nDepth, CHAR *szBuffer, UINT nBufferLength);
void CDECL CcshellDebugMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(ULONGLONG flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(ULONGLONG flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg

#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#else // DEBUG

#define DEBUGWhackPathBufferA(psz, cch)
#define DEBUGWhackPathBufferW(psz, cch)
#define DEBUGWhackPathStringA(psz, cch)
#define DEBUGWhackPathStringW(psz, cch)

#endif // DEBUG

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
// These are turned off because they normally don't give
// feedback of error cases and so many fire that they
// swamp out other useful debug spew.
//#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#define ATLTRACE2           1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// APPCOMPAT (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#else  // NOSHELLDEBUG

#ifdef UNIX
#include <crtdbg.h>
#define ASSERT(f)	_ASSERT(f)
#include <mainwin.h>
#define TraceMsg(type, sformat)  DebugMessage(0, sformat)
#define TraceMSG(type, sformat, args)  DebugMessage(0, sformat, args)
#endif

#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\dataitem.h ===
//
//
//

#pragma once

#include "debug.h"

enum {
    WF_PERUSER          = 0x0001,   // item is per user as opposed to per machine
    WF_ADMINONLY        = 0x0002,   // only show item if user is an admin
    WF_ALTERNATECOLOR   = 0x1000,   // show menu item text in the "visited" color
    WF_DISABLED         = 0x2000,   // Treated normally except cannot be launched
};

class CDataItem
{
public:
    CDataItem();
    ~CDataItem();

    TCHAR * GetTitle()      { return m_pszTitle; }
    TCHAR * GetMenuName()   { return m_pszMenuName?m_pszMenuName:m_pszTitle; }
    TCHAR * GetDescription(){ return m_pszDescription; }
    TCHAR   GetAccel()      { return m_chAccel; }
    int     GetImgIndex()   { return m_iImage; }

    BOOL SetData( LPTSTR szTitle, LPTSTR szMenu, LPTSTR szDesc, LPTSTR szCmd, LPTSTR szArgs, DWORD dwFlags, int iImgIndex );
    BOOL Invoke( HWND hwnd );

    // flags
    //
    // This var is a bit mask of the following values
    //  PERUSER     True if item must be completed on a per user basis
    //              False if it's per machine
    //  ADMINONLY   True if this item can only be run by an admin
    //              False if all users should do this
    DWORD   m_dwFlags;

protected:
    TCHAR * m_pszTitle;
    TCHAR * m_pszMenuName;
    TCHAR * m_pszDescription;
    TCHAR   m_chAccel;
    int     m_iImage;

    TCHAR * m_pszCmdLine;
    TCHAR * m_pszArgs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\dlgapp.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  dlgapp.cpp
//
//      This file contains the main entry point into the application and
//      the implementation of the CDlgApp class.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>
#include <shlwapi.h>    // for string compare functions
#include "debug.h"
#include <tchar.h>

#pragma hdrstop

#include "dlgapp.h"
#include "resource.h"

#define WINDOW_CLASS    TEXT("_BerksWin2kAutorunApp_")

//////////////////////////////////////////////////////////////////////////
// Global Data
//////////////////////////////////////////////////////////////////////////

bool    g_bTaskRunning = false;     // true when we have a running task open
int     g_iSelectedItem = -1;       // 
WNDPROC g_fnBtnProc = NULL;         // the window proc for a button.

//////////////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////////////

LONG_PTR CALLBACK ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//////////////////////////////////////////////////////////////////////////
// Metrics
// Our metrics are constants that never change.  All sizes are in pixels (as per the spec):
//////////////////////////////////////////////////////////////////////////

#define c_cyLogoImage                   87  // height of the branding image.
#define c_cyFadeBar                     6   // height of the color fade bar
#define c_cyBranding                    (c_cyLogoImage+c_cyFadeBar) // height of top region that contains our branding images and the fade bar
#define c_cxCheckTextLeftEdge           29  // width from left edge for checkbox text label

#define c_cxMenuItemPadding             10  // width from left of menu item to left of text and right of text to right of menu item
#define c_cyMenuItemPadding             5   // height from top of menu item to top of text and bottom of text to bottom of menu item
#define c_cyMenuItemSpacing             1   // gap from top of one menu item to bottom of next item

#define c_cyBarToTitlePadding           12  // vertical padding from botton of fade bar to top of title text
#define c_cyTitleToBodyPadding          6   // vertical padding from bottom of title text to top of body text
#define c_cyBodyToBottomPadding         53  // vertical padding from body of body text to bottom of client area
#define c_cxRightPanelPadding           16  // generic horizontal padding used on both edges of the right pane

// Code to ensure only one instance of a particular window is running
HANDLE CheckForOtherInstance(HINSTANCE hInstance)
{
    TCHAR   szCaption[128];
    HANDLE  hMutex;

    LoadString(hInstance, IDS_TITLE, szCaption, 128);

    // We don't want to launch autorun when winnt32 is running.  The standard way
    // to check for this is the following mutex, which winnt32 creates:

    hMutex = OpenMutex( MUTEX_ALL_ACCESS, FALSE, TEXT("Winnt32 Is Running") );

    if ( hMutex )
    {
        // The mutex exists, this means winnt32 is running so we shouldn't.
        // REVIEW: Should we try to findwindow and activate winnt32?
        CloseHandle( hMutex );
        return 0;
    }

    // We create a named mutex with our window caption just as a way to check
    // if we are already running autorun.exe.  Only if we are the first to
    // create the mutex do we continue.

    hMutex = CreateMutex (NULL, FALSE, szCaption);

    if ( !hMutex )
    {
        // failed to create the mutex
        return 0;
    }
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Mutex created but by someone else, activate that window
        HWND hwnd = FindWindow( WINDOW_CLASS, szCaption );
        SetForegroundWindow(hwnd);
        CloseHandle(hMutex);
        return 0;
    }

    // we are the first
    return hMutex;
}


/**
*  This function is the main entry point into our application.
*
*  @return     int     Exit code.
*/

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLin, int nShowCmd )
{
    HANDLE hMutex = CheckForOtherInstance(hInstance);

    if ( hMutex )
    {
        CDlgApp dlgapp;
        dlgapp.Register(hInstance);
        if ( dlgapp.InitializeData() )
        {
            dlgapp.Create(nShowCmd);
            dlgapp.MessageLoop();
        }

        CloseHandle(hMutex);
    }
    return 0;
}

typedef DWORD (WINAPI *PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (WINAPI *PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout

/**
*  This function gets the DC layout.
*
*  @return     DWORD     DC layout.
*/
DWORD Mirror_GetLayout( HDC hdc )
{
    DWORD dwRet=0;
    static PFNGETLAYOUT pfnGetLayout=NULL;
    static BOOL bTriedToLoadBefore = FALSE;

    if( (NULL == pfnGetLayout) && !bTriedToLoadBefore)
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnGetLayout = (PFNGETLAYOUT)GetProcAddress(hmod, "GetLayout");

        bTriedToLoadBefore = TRUE;    
    }

    if( pfnGetLayout )
        dwRet = pfnGetLayout( hdc );

    return dwRet;
}


/**
*  This function sets the DC layout.
*
*  @return     DWORD     old DC layout.
*/
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout )
{
    DWORD dwRet=0;
    static PFNSETLAYOUT pfnSetLayout=NULL;
    static BOOL bTriedToLoadBefore = FALSE;

    if( (NULL == pfnSetLayout) && !bTriedToLoadBefore)
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnSetLayout = (PFNSETLAYOUT)GetProcAddress(hmod, "SetLayout");

        bTriedToLoadBefore = TRUE;            
    }

    if( pfnSetLayout )
        dwRet = pfnSetLayout( hdc , dwLayout );

    return dwRet;
}


/**
*  This method is our contstructor for our class. It initialize all
*  of the instance data.
*/
CDlgApp::CDlgApp()
{
    m_hInstance     = NULL;
    m_hwnd          = NULL;

    m_bHighContrast = false;

    m_hfontTitle = NULL;
    m_hfontMenu  = NULL;
    m_hfontBody  = NULL;

    m_hbrMenuItem   = NULL;
    m_hbrMenuBorder = NULL;
    m_hbrRightPanel = NULL;

    m_szDefTitle[0] = NULL;
    m_szDefBody[0] = NULL;

    // In theory, all of these metrics could be adjusted to resize the window.  Resizing wouldn't
    // effect the paddings and spacings so these are defined above as constants.  In the real
    // world we are only resizing vertically to adjust for oversized content.  These are more to
    // allow future expansion.
    m_cxClient = 478;       // width of the client area
    m_cyClient = 322;       // This is currently the only metirc we actually adjust.
    m_cxLeftPanel = 179;    // width of the panel that contains the menu items.
    m_hdcTop = NULL;
    m_hcurHand = NULL;

    m_bLowColor = false;
    m_iColors = -1;
    m_hpal = NULL;
}

CDlgApp::~CDlgApp()
{
    DeleteObject(m_hfontTitle);
    DeleteObject(m_hfontMenu);
    DeleteObject(m_hfontBody);

    DeleteObject(m_hbrMenuItem);
    DeleteObject(m_hbrMenuBorder);
    DeleteObject(m_hbrRightPanel);

    DeleteDC(m_hdcTop);
}

/**
*  This method will register our window class for the application.
*
*  @param  hInstance   The application instance handle.
*
*  @return             No return value.
*/
void CDlgApp::Register(HINSTANCE hInstance)
{
    WNDCLASS  wndclass;

    m_hInstance = hInstance;
    
    wndclass.style          = CS_OWNDC;
    wndclass.lpfnWndProc    = WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WEBAPP));
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = NULL;
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = WINDOW_CLASS;

    RegisterClass(&wndclass);
}

/**
*  This method will initialize the data object.
*
*  @return         No return value.
*/
bool CDlgApp::InitializeData()
{
    // Determine if we should use Direct Animaiton to display our intro graphics.
    // We don't use DA on slow machines, machines with less than 256 color displays,
    // and hydra terminals.  For everything else we use DA.
    HWND hwnd = GetDesktopWindow();
    HDC hdc = GetDC( hwnd );
    m_iColors = GetDeviceCaps( hdc, NUMCOLORS );
    m_bLowColor = ((m_iColors != -1) && (m_iColors <= 256));
    if ( m_bLowColor )
    {
        m_hpal = CreateHalftonePalette(hdc);
    }
    ReleaseDC( hwnd, hdc );

    // Initialize the items from the INI file.
    if ( !m_DataSrc.Init() )
    {
        // this is a sign from the data source that we should exit
        return false;
    }

    // Are we in accesibility mode?  This call won't work on NT 4.0 because this flag wasn't known.
    HIGHCONTRAST hc;
    hc.cbSize = sizeof(HIGHCONTRAST);
    hc.dwFlags = 0; // avoid random result should SPI fail
    if ( SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hc, 0 ) )
    {
        m_bHighContrast = ( hc.dwFlags & HCF_HIGHCONTRASTON );
    }
    else
    {
        // we must be on NT 4.0 or below.  Just assume we aren't in high contrast mode.
        ASSERT( false == m_bHighContrast );
    }

    // Set the color table based on our HighContrast mode setting.
    SetColorTable();

    // create the fonts that we need to use.
    CreateWelcomeFonts(hdc);

    // create the image for the top region
    CreateBrandingBanner();

    // we pre load the background images so they draw more quickly.
    LoadBkgndImages();

    // load the resource strings that we always need
    LoadString( m_hInstance, IDS_DEFTITLE, m_szDefTitle, ARRAYSIZE(m_szDefTitle) );
    LoadString( m_hInstance, IDS_DEFBODY, m_szDefBody, ARRAYSIZE(m_szDefBody) );

    m_hcurHand = LoadCursor( m_hInstance, MAKEINTRESOURCE(IDC_BRHAND) );

    return true;
}

BOOL CDlgApp::SetColorTable()
{
    if ( m_bHighContrast )
    {
        // set to high contrast values
        m_hbrMenuItem   = (HBRUSH)(COLOR_BTNFACE+1);
        m_hbrMenuBorder = (HBRUSH)(COLOR_BTNSHADOW+1);
        m_hbrRightPanel = (HBRUSH)(COLOR_WINDOW+1);

        m_crMenuText    = GetSysColor(COLOR_BTNTEXT);
        m_crNormalText  = GetSysColor(COLOR_WINDOWTEXT);
        m_crTitleText   = m_crNormalText;
        m_crSelectedText= GetSysColor(COLOR_GRAYTEXT);
    }
    else
    {
        m_crMenuText    = RGB(0,0,0);
        m_crNormalText  = RGB(0,0,0);
        m_crSelectedText= RGB(0x80, 0x80, 0x80);    // default value for COLOR_GRAYTEXTs
        m_crTitleText   = RGB(51,102,153);

        m_hbrRightPanel = (HBRUSH)GetStockObject( WHITE_BRUSH );

        if ( m_bLowColor )
        {
            if (m_iColors <= 16)
            {
                // Set to colors that work well in 16 color mode.
                HBITMAP hbmp;
                hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_16MENU), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
                if (hbmp)
                {
                    m_hbrMenuItem = CreatePatternBrush(hbmp);
                    DeleteObject(hbmp);
                }
                else
                    m_hbrMenuItem = (HBRUSH)(COLOR_BTNFACE+1);

                hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_16BORDER), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
                if (hbmp)
                {
                    m_hbrMenuBorder = CreatePatternBrush( hbmp );
                    DeleteObject(hbmp);
                }
                else
                    m_hbrMenuBorder = (HBRUSH)(COLOR_BTNSHADOW+1);
//
//                if ( WeAreRunningOnWin95 )
//                    m_crMenuText    = RGB(255,255,255);
            }
            else
            {
                // Set to colors that work well in 256 color mode.  Use colors from the halftone palette.
                HBITMAP hbmp;
                hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_256MENU), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
                if (hbmp)
                {
                    m_hbrMenuItem   = CreatePatternBrush(hbmp);
                    DeleteObject(hbmp);
                }
                else
                    m_hbrMenuItem = (HBRUSH)(COLOR_BTNFACE+1);

                hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_256BORDER), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
                if (hbmp)
                {
                    m_hbrMenuBorder = CreatePatternBrush( hbmp );
                    DeleteObject(hbmp);
                }
                else
                    m_hbrMenuBorder = (HBRUSH)(COLOR_BTNSHADOW+1);
            }
        }
        else
        {
            m_hbrMenuItem   = CreateSolidBrush( RGB(166,202,240) );
            m_hbrMenuBorder = CreateSolidBrush( m_crTitleText );
        }
    }

    return TRUE;
}


BOOL CDlgApp::CreateWelcomeFonts(HDC hdc)
{
    LOGFONT lf;
    CHARSETINFO csInfo;
    TCHAR szFontSize[6];

    memset(&lf,0,sizeof(lf));
    lf.lfWeight = FW_BOLD;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH|FF_SWISS;
    LoadString( m_hInstance, IDS_FONTFACE, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName) );

    // Set charset
    if (TranslateCharsetInfo((DWORD*)IntToPtr(GetACP()), &csInfo, TCI_SRCCODEPAGE) == 0)
    {
        csInfo.ciCharset = 0;
    }
    lf.lfCharSet = (BYTE)csInfo.ciCharset;

    // TODO:  If user has accesibility large fonts turned on then scale the font sizes.

    LoadString( m_hInstance, IDS_CYTITLEFONT, szFontSize, ARRAYSIZE(szFontSize) );
    lf.lfHeight  = -_ttoi(szFontSize);
    m_hfontTitle = CreateFontIndirect(&lf);

    LoadString( m_hInstance, IDS_CYMENUITEMFONT, szFontSize, ARRAYSIZE(szFontSize) );
    lf.lfHeight  = -_ttoi(szFontSize);
    m_hfontMenu  = CreateFontIndirect(&lf);

    lf.lfWeight = FW_NORMAL;
    LoadString( m_hInstance, IDS_CYBODYFONT, szFontSize, ARRAYSIZE(szFontSize) );
    lf.lfHeight  = -_ttoi(szFontSize);
    m_hfontBody  = CreateFontIndirect(&lf);

    return TRUE;
}

BOOL CDlgApp::CreateBrandingBanner()
{
    HBITMAP hbm;
    int iBitmap;
    m_hdcTop = CreateCompatibleDC(NULL);
    if ( m_bLowColor && (m_iColors <= 16) )
    {
        iBitmap = IDB_BANNER16;
    }
    else
    {
        iBitmap = IDB_BANNER;
    }

    hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(iBitmap), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
    SelectObject( m_hdcTop, hbm );

    return TRUE;
}

BOOL CDlgApp::LoadBkgndImages()
{
    BITMAP bm;

    for (int i=0; i<4; i++)
    {
        m_aBkgnd[i].hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_BKGND0+i), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
        // REVIEW: are all these the same size?  If yes, skip this part and use a constant:
        GetObject(m_aBkgnd[i].hbm,sizeof(bm),&bm);
        m_aBkgnd[i].cx = bm.bmWidth;
        m_aBkgnd[i].cy = bm.bmHeight;
    }

    return TRUE;
}

BOOL CDlgApp::AdjustToFitFonts()
{
    RECT rect;
    int cyLowestBodyPoint = 0;
    HDC hdc = GetDC(m_hwnd);

    // now based on the users prefered font size we allow these sizes to adjust slightly

    HFONT hfontOld = (HFONT)SelectObject(hdc,m_hfontTitle);
    int iMenuItemTop = c_cyBranding;
    for (int i=0; i<m_DataSrc.m_iItems; i++ )
    {
        rect.left = m_cxLeftPanel+c_cxRightPanelPadding;
        rect.top = c_cyBranding + c_cyBarToTitlePadding;
        rect.right = m_cxClient-c_cxRightPanelPadding;
        SelectObject(hdc,m_hfontTitle);
        TCHAR* pszTitle = m_DataSrc[i].GetTitle();
        DrawText(hdc,pszTitle,-1,&rect,DT_CALCRECT|DT_WORDBREAK); // this computes rcLargestTitle.bottom

        rect.left = m_cxLeftPanel+c_cxRightPanelPadding;
        rect.top = rect.bottom + c_cyTitleToBodyPadding;
        rect.right = m_cxClient-c_cxRightPanelPadding;
        SelectObject(hdc,m_hfontBody);
        DrawText(hdc,m_DataSrc[i].GetDescription(),-1,&rect,DT_CALCRECT|DT_WORDBREAK); // this computes rcLargestBody.bottom
        if ( rect.bottom > cyLowestBodyPoint )
            cyLowestBodyPoint = rect.bottom;

        rect.left = c_cxMenuItemPadding;
        rect.top = iMenuItemTop+c_cyMenuItemPadding;
        rect.right = m_cxLeftPanel-c_cxMenuItemPadding;
        SelectObject(hdc,m_hfontMenu);
        DrawText(hdc,m_DataSrc[i].GetMenuName(),-1,&rect,DT_CALCRECT|DT_WORDBREAK);

        HWND hwnd;
        hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM1+i);
        SetWindowPos(
                hwnd,
                NULL,
                0,
                iMenuItemTop,
                m_cxLeftPanel,
                rect.bottom + c_cyMenuItemPadding + 1 + c_cyMenuItemSpacing - iMenuItemTop,   // +1 to improve centering (due to drop letters)
                SWP_NOZORDER );

        iMenuItemTop = rect.bottom + c_cyMenuItemPadding + 1 + c_cyMenuItemSpacing;
    }

    // store the bottom most menu point.  Needed for drawing the background rect later.
    m_cyBottomOfMenuItems = iMenuItemTop;

    // restore the DC to its original value
    SelectObject(hdc,hfontOld);

    return TRUE;
}

/**
*  This method will create the application window.
*
*  @return         No return value.
*/
void CDlgApp::Create(int nCmdShow)
{
    //
    //  load the window title from the resource.
    //
    TCHAR szTitle[MAX_PATH];
#ifdef BUILD_OPK_VERSION
    LoadString(m_hInstance, IDS_TITLE_OPK, szTitle, MAX_PATH);
 
#else
    LoadString(m_hInstance, IDS_TITLE, szTitle, MAX_PATH);   
#endif

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_CLIPCHILDREN;
    
    m_hwnd = CreateWindowEx(
            WS_EX_CONTROLPARENT,
            WINDOW_CLASS,
            szTitle,
            dwStyle,
            0,
            0,
            0,
            0,
            NULL,
            NULL,
            m_hInstance,
            this);

    //  set the client area to a fixed size and center the window on screen
    RECT rect;
    rect.left = 0;
    rect.top = 0;
    rect.right = m_cxClient;
    rect.bottom = m_cyClient;

    AdjustWindowRect( &rect, dwStyle, FALSE );
    rect.right -= rect.left;
    rect.bottom -= rect.top;

    RECT rcDesktop;
    SystemParametersInfo(SPI_GETWORKAREA,0, &rcDesktop, FALSE);
    rect.left = (rcDesktop.left+rcDesktop.right-rect.right)/2;
    rect.top = (rcDesktop.top+rcDesktop.bottom-rect.bottom)/2;

    SetWindowPos(m_hwnd, HWND_TOP, rect.left, rect.top, rect.right, rect.bottom, 0);

    ShowWindow(m_hwnd, nCmdShow);

    m_DataSrc.ShowSplashScreen( m_hwnd );

    InvalidateRect(m_hwnd, NULL, TRUE);
    UpdateWindow(m_hwnd);
}

/**
*  This method is our application message loop.
*
*  @return         No return value.
*/
void CDlgApp::MessageLoop()
{
    MSG msg;
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // IsDialogMessage cannot understand the concept of ownerdraw default pushbuttons.  It treats
        // these attributes as mutually exclusive.  As a result, we handle this ourselves.  We want
        // whatever control has focus to act as the default pushbutton.
        if ( (WM_KEYDOWN == msg.message) && (VK_RETURN == msg.wParam) )
        {
            HWND hwndFocus = GetFocus();
            if ( hwndFocus )
            {
                SendMessage(m_hwnd, WM_COMMAND, MAKELONG(GetDlgCtrlID(hwndFocus), BN_CLICKED), (LPARAM)hwndFocus);
            }
            continue;
        }

        if ( IsDialogMessage(m_hwnd, &msg) )
            continue;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

/**
*  This is the window procedure for the container application. It is used
*  to deal with all messages to our window.
*
*  @param      hwnd        Window handle.
*  @param      msg         The window message.
*  @param      wParam      Window Parameter.
*  @param      lParam      Window Parameter.
*
*  @return     LRESULT
*/
LRESULT CALLBACK CDlgApp::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *web = (CDlgApp *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(msg)
    {
    case WM_NCCREATE:
        web = (CDlgApp *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LRESULT)web);
        break;

    case WM_CREATE:
        return web->OnCreate(hwnd);

    case WM_DESTROY:
        return web->OnDestroy();

    case WM_ACTIVATE:
        return web->OnActivate(wParam);

    case WM_PAINT:
        return web->OnPaint((HDC)wParam);

    case WM_ERASEBKGND:
        return web->OnEraseBkgnd((HDC)wParam);

    case WM_MOUSEMOVE:
        return web->OnMouseMove(LOWORD(lParam), HIWORD(lParam), (DWORD)wParam);

    case WM_SETCURSOR:
        return web->OnSetCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_COMMAND:
    case WM_SYSCOMMAND:
        if ( web->OnCommand(LOWORD(wParam)) )
            return 0;
        break;

    case WM_DRAWITEM:
        return web->OnDrawItem((UINT)wParam, (LPDRAWITEMSTRUCT)lParam);

    case WM_QUERYNEWPALETTE:
        return web->OnQueryNewPalette();

    case WM_PALETTECHANGED:
        return web->OnPaletteChanged((HWND)wParam);

    case ARM_CHANGESCREEN:
        return web->_OnChangeScreen();
    }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/**
*  This method is called on WM_CREATE.
*
*  @param  hwnd    Window handle for the application.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    _CreateMenu();
    return 0;
}

void CDlgApp::_CreateMenu()
{
    // Create one window for each button.  These windows will get resized and moved
    // after we call AdjustToFitFonts.
    m_iItems = m_DataSrc.m_iItems;
    for (int i=0; i<m_iItems; i++)
    {
        HWND hwnd = CreateWindowEx(
                0,
                TEXT("BUTTON"),
                m_DataSrc.m_data[i].GetMenuName(),
                WS_CHILD|WS_VISIBLE|WS_TABSTOP|BS_PUSHBUTTON|BS_MULTILINE|BS_OWNERDRAW,
                0,0,0,0,
                m_hwnd,
                NULL,
                m_hInstance,
                NULL );

        if ( hwnd )
        {
            SetWindowLongPtr(hwnd, GWLP_ID, IDM_MENUITEM1 + i);
            SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfontMenu, 0);
            g_fnBtnProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)ButtonWndProc);
            SetFocus(GetDlgItem(m_hwnd,IDM_MENUITEM1+i));
        }
    }

    // We created the window with zero size, now we adjust that size to take into
    // acount the selected font size, etc.
    AdjustToFitFonts();
    
    // Create two static text controls, one for the title and one for the body.  The
    // only purpose these serve is to allow screen readers to read the correct text.
}

void CDlgApp::_DestroyMenu()
{
    for (int i=0; i<m_iItems; i++)
    {
        DestroyWindow(GetDlgItem(m_hwnd, IDM_MENUITEM1+i));
    }
    m_iItems = 0;
}

/**
*  This method handles the WM_DESTROY message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnDestroy()
{
    // Shutdown the data source.
    m_DataSrc.Uninit(0);

    // ensure this is the last message we care about
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
    
    PostQuitMessage(0);

    return 0;
}

LRESULT CDlgApp::OnActivate(WPARAM wParam)
{
    // Note: we are actually checking two things, the HIWORD(wParam) must be zero (i.e. window not minimized)
    // and the LOWORD(wParam) must be one of the following two values (i.e. window being activated):
    if ( WA_ACTIVE == wParam || WA_CLICKACTIVE == wParam)
    {
        HWND hwnd;
        hwnd = GetDlgItem(m_hwnd,IDM_MENUITEM4);
        SetFocus(hwnd);
    }
    return 0;
}

/**
*  This method handles the WM_PAINT message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnPaint(HDC hdc)
{
    PAINTSTRUCT ps;
    BeginPaint(m_hwnd,&ps);
    EndPaint(m_hwnd,&ps);

    return 0;
}

// winver 0x0500 definition
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP            (DWORD)0x80000000
#endif // NOMIRRORBITMAP
#ifndef LAYOUT_RTL
#define LAYOUT_RTL                              0x00000001 // Right to left
#endif // LAYOUT_RTL
/**
*  This method handles the WM_ERASEBKGND message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnEraseBkgnd(HDC hdc)
{
    RECT rect;
    HPALETTE hpalOld = NULL;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(hdc, m_hpal, FALSE);
        RealizePalette(hdc);
    }

    SetMapMode(hdc, MM_TEXT);
    SetBkMode(hdc, TRANSPARENT);

    // Draw the branding area:
    DWORD dwRop  = SRCCOPY;
    if(Mirror_GetLayout(hdc) & LAYOUT_RTL)
    {
        dwRop |= NOMIRRORBITMAP;
    }
    BitBlt( hdc,0,0,m_cxClient,c_cyBranding, m_hdcTop,0,0, dwRop );

    // Draw the left pane:
    // fill rect for background below menu items
    rect.left = 0;
    rect.top = m_cyBottomOfMenuItems;
    rect.right = m_cxLeftPanel;
    rect.bottom = m_cyClient;
    FillRect(hdc, &rect, m_hbrMenuItem);

    // Draw the right pane:
    // fill right pane's background
    rect.left = m_cxLeftPanel;
    rect.top = c_cyBranding;
    rect.right = m_cxClient;
    rect.bottom = m_cyClient;
    FillRect(hdc, &rect, m_hbrRightPanel);

    // draw background image
    if ( !m_bHighContrast )
    {
        int iImgIndex;

        if ( -1 == g_iSelectedItem )
        {
            iImgIndex = 0;
        }
        else
        {
            iImgIndex = m_DataSrc.m_data[g_iSelectedItem].GetImgIndex();
        }

        HDC hdcBkgnd = CreateCompatibleDC(hdc);
        if (hdcBkgnd)
        {
            Mirror_SetLayout(hdcBkgnd, 0);        
            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcBkgnd, m_aBkgnd[iImgIndex].hbm);
            BitBlt( hdc,
                    m_cxClient-m_aBkgnd[iImgIndex].cx,
                    m_cyClient-m_aBkgnd[iImgIndex].cy,
                    m_aBkgnd[iImgIndex].cx,
                    m_aBkgnd[iImgIndex].cy,
                    hdcBkgnd,0,0, SRCCOPY );
            SelectObject(hdcBkgnd,hbmOld);
            DeleteDC(hdcBkgnd);
        }
    }

    // draw title text
    rect.top = c_cyBranding + c_cyBarToTitlePadding;
    rect.left = m_cxLeftPanel + c_cxRightPanelPadding;
    rect.right = m_cxClient - c_cxRightPanelPadding;
    rect.bottom = m_cyClient;
    HFONT hfontOld = (HFONT)SelectObject(hdc,m_hfontTitle);
    SetTextColor(hdc,m_crTitleText);
    rect.top += c_cyTitleToBodyPadding +
        DrawText(hdc,((-1==g_iSelectedItem)?m_szDefTitle:m_DataSrc[g_iSelectedItem].GetTitle()),-1,&rect,DT_NOCLIP|DT_WORDBREAK);

    // draw body text
    SelectObject(hdc,m_hfontBody);
    SetTextColor(hdc,m_crNormalText);
    DrawText(hdc,((-1==g_iSelectedItem)?m_szDefBody:m_DataSrc[g_iSelectedItem].GetDescription()),-1,&rect,DT_NOCLIP|DT_WORDBREAK);

    // restore the DC to its original value
    SelectObject(hdc,hfontOld);
    if(hpalOld)
        SelectPalette(hdc, hpalOld, FALSE);

    return TRUE;
}

LRESULT CDlgApp::OnMouseMove(int x, int y, DWORD fwKeys)
{
    // if a task is running then we leave the menu item for that task selected until that
    // task finishes running instead of doing the following logic.
    if ( !g_bTaskRunning )
    {
        // Didn't move over one of our menu items, select the default text.
        if (-1 != g_iSelectedItem)
        {
            g_iSelectedItem = -1;
            HWND hwnd = GetDlgItem(m_hwnd,IDM_MENUITEM4);
            SetFocus(hwnd);

            InvalidateRect(m_hwnd, NULL, TRUE);
        }
    }

    return 0;
}

LRESULT CDlgApp::OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg)
{
    if ( !g_bTaskRunning )
    {
        if ( hwnd != m_hwnd )
        {
            SetCursor(m_hcurHand);
            return TRUE;
        }
    }

    SetCursor(LoadCursor(NULL,IDC_ARROW));
    return TRUE;
}

LRESULT CDlgApp::_OnChangeScreen()
{
    _DestroyMenu();
    _CreateMenu();
    InvalidateRect(m_hwnd, NULL, TRUE);
    return TRUE;
}

LRESULT CDlgApp::OnCommand(int wID)
{
    int iNewSelectedItem = g_iSelectedItem;
    bool bRun = false;

    switch(wID)
    {
    case IDM_MENUITEM1:
    case IDM_MENUITEM2:
    case IDM_MENUITEM3:
    case IDM_MENUITEM4:
    case IDM_MENUITEM5:
    case IDM_MENUITEM6:
    case IDM_MENUITEM7:
        bRun = true;
        g_iSelectedItem = wID - IDM_MENUITEM1;
        // g_iSelectedItem should be a real menu item now, but just to make sure:
        ASSERT( (g_iSelectedItem < m_DataSrc.m_iItems) && (g_iSelectedItem >= 0) );
        break;

    default:
        // When we hit this then this isn't a message we care about.  We return FALSE which
        // tells our WndProc to call DefWndProc which makes everything happy.
        return FALSE;
    }

    if ( !g_bTaskRunning )
    {
        if ( iNewSelectedItem != g_iSelectedItem )
        {
            InvalidateRect(m_hwnd, NULL, TRUE);
        }

        if ( bRun )
        {
            g_bTaskRunning = TRUE;
            m_DataSrc.Invoke( g_iSelectedItem, m_hwnd );
            g_bTaskRunning = FALSE;
        }
    }
    else
    {
        // currently the only commands that are valid while another task is running are
        // IDM_SHOWCHECK and anything that goes to the default handler above.  Everything
        // else will come to here and cause a message beep
        MessageBeep(0);
    }

    return TRUE;
}

LRESULT CDlgApp::OnQueryNewPalette()
{
    if ( m_hpal )
    {
        HDC hdc = GetDC(m_hwnd);
        HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
        UnrealizeObject(m_hpal);
        RealizePalette(hdc);
        InvalidateRect(m_hwnd, NULL, TRUE);
        UpdateWindow(m_hwnd);
        if(hpalOld)
            SelectPalette(hdc, hpalOld, FALSE);
        ReleaseDC(m_hwnd, hdc);
        return TRUE;
    }
    return FALSE;
}

LRESULT CDlgApp::OnPaletteChanged(HWND hwnd)
{
    if ( m_hpal && (m_hwnd != hwnd) )
    {
        HDC hdc = GetDC(m_hwnd);
        HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
        RealizePalette(hdc);
        UpdateColors(hdc);
        if (hpalOld)
            SelectPalette(hdc, hpalOld, FALSE);
        ReleaseDC(m_hwnd, hdc);
    }
    return TRUE;
}

LRESULT CDlgApp::OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis)
{
    RECT rect = pdis->rcItem;
    int i = iCtlID - IDM_MENUITEM1;
    HPALETTE hpalOld = NULL;

    ASSERT( (i < m_DataSrc.m_iItems) && (i >= 0) );

    if ( m_hpal )
    {
        hpalOld = SelectPalette(pdis->hDC, m_hpal, FALSE);
        RealizePalette(pdis->hDC);
    }

    rect.bottom -= c_cyMenuItemSpacing;

    FillRect( pdis->hDC, &rect, (pdis->itemState & ODS_FOCUS)?m_hbrRightPanel:m_hbrMenuItem );
    
    rect.top = rect.bottom;
    rect.bottom += c_cyMenuItemSpacing;
    FillRect( pdis->hDC, &rect, m_hbrMenuBorder );

    rect.top = pdis->rcItem.top;

    // draw menu item text
    rect.left += c_cxMenuItemPadding;
    rect.top += c_cyMenuItemPadding;
    rect.right -= c_cxMenuItemPadding;

    SetBkMode(pdis->hDC, TRANSPARENT);
    SetTextColor(
            pdis->hDC,
            ((m_DataSrc[i].m_dwFlags&WF_ALTERNATECOLOR)?m_crSelectedText:
            ((pdis->itemState & ODS_FOCUS)?m_crNormalText:m_crMenuText)));

    DrawText(pdis->hDC,m_DataSrc[i].GetMenuName(),-1,&rect,DT_NOCLIP|DT_WORDBREAK);

    if ( pdis->itemState & ODS_FOCUS )
    {
        if ( m_bHighContrast )
        {
            rect.left -= 1;
            rect.top -= 2;
            rect.right += 1;
            rect.bottom -= 2;
            DrawFocusRect(pdis->hDC,&rect);
        }
    }

    if ( hpalOld )
    {
        SelectPalette(pdis->hDC, hpalOld, FALSE);
    }

    return TRUE;
}

LONG_PTR CALLBACK ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *web = (CDlgApp *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_MOUSEMOVE:
        if ( !g_bTaskRunning )
        {
            int iID = ((int)GetWindowLongPtr(hwnd, GWLP_ID)) - IDM_MENUITEM1;
            
            if ( iID != g_iSelectedItem )
            {
                SetFocus(hwnd);
            }
        }
        break;

    case WM_SETFOCUS:
        if ( !g_bTaskRunning )
        {
            int iID = ((int)GetWindowLongPtr(hwnd, GWLP_ID)) - IDM_MENUITEM1;
            
            if ( iID != g_iSelectedItem )
            {
                g_iSelectedItem = iID;

                InvalidateRect(GetParent(hwnd), NULL, TRUE);

                ASSERT( (g_iSelectedItem < 7) && (g_iSelectedItem >= 0) );
            }
        }
        break;
    }

    return CallWindowProc(g_fnBtnProc, hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\dlgapp.h ===
//////////////////////////////////////////////////////////////////////////
//
//  dlgapp.h
//
//      This file contains the specification of the DlgApp class.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#pragma once

#include "autorun.h"

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

class CDlgApp
{
    private:
        HINSTANCE       m_hInstance;        // application instance
        HWND            m_hwnd;             // window handle
        CDataSource     m_DataSrc;          // info from ini and registry about display items

        HFONT           m_hfontTitle;       // Font used to draw the title
        HFONT           m_hfontMenu;        // Font used to draw the menu items
        HFONT           m_hfontBody;        // Font used to draw the body

        HBRUSH          m_hbrMenuItem;      // Brush used to draw background of menu items
        HBRUSH          m_hbrMenuBorder;    // Brush used to draw the dark area behind the menu items
        HBRUSH          m_hbrRightPanel;    // Brush used to draw the background of the right panel

        COLORREF        m_crMenuText;       // Color of text on non-selected menu items (ususally the same as m_crNormalText)
        COLORREF        m_crNormalText;     // Color of text in right panel body and selected menu items
        COLORREF        m_crTitleText;      // Color of the title text
        COLORREF        m_crSelectedText;   // Color of menu items that have been previouly launched.
        
        HCURSOR         m_hcurHand;

        int             m_cxClient;
        int             m_cyClient;
        int             m_cxLeftPanel;
        int             m_cyBottomOfMenuItems;

        int             m_iItems;

        HDC             m_hdcTop;           // Memory DC used for storing and painting the top image

        TCHAR           m_szDefTitle[MAX_PATH];
        TCHAR           m_szDefBody[1024];
        TCHAR           m_szCheckText[MAX_PATH];

        bool            m_bHighContrast;    // true if high contrast options should be used
        bool            m_bLowColor;        // true if we are in 256 or less color mode.
        HPALETTE        m_hpal;             // palette to use if in palette mode
        int             m_iColors;          // -1, 16, or 256 depending on the color mode we are in.

        struct tagBkgndInfo {
            HBITMAP hbm;
            int     cx;
            int     cy;
        } m_aBkgnd[4];

    public:
        CDlgApp();
        ~CDlgApp();

        void Register(HINSTANCE hInstance);
        bool InitializeData();
        void Create(int nCmdShow);
        void MessageLoop();

    private:
        static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

        // Window Messages
        LRESULT OnCreate(HWND hwnd);
        LRESULT OnDestroy();
        LRESULT OnActivate(WPARAM wParam);
        LRESULT OnPaint(HDC hdc);
        LRESULT OnEraseBkgnd(HDC hdc);
        LRESULT OnLButtonDown(int x, int y, DWORD fwKeys);
        LRESULT OnMouseMove(int x, int y, DWORD fwKeys);
        LRESULT OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg);
        LRESULT OnCommand(int wID);
        LRESULT OnQueryNewPalette();
        LRESULT OnPaletteChanged(HWND hwnd);
        LRESULT OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis);
        LRESULT _OnChangeScreen();

        // helper functions
        BOOL SetColorTable();
        BOOL CreateWelcomeFonts(HDC hdc);
        BOOL CreateBrandingBanner();
        BOOL LoadBkgndImages();
        BOOL AdjustToFitFonts();
        void _CreateMenu();
        void _DestroyMenu();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\resource.h ===
//////////////////////////////////////////////////////////////////////////
//
//  resource.h
//
//      This file contains all of the resource ids used by the application.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#include <winuser.h>

//
//  icons.
//
#define IDI_WEBAPP          1

//
//  cursors.
//
#define IDC_BRHAND          1

//
//  bitmaps.
//
// The server versions always use 16 color images
#define IDB_BANNER          1
#if BUILD_SERVER_VERSION | BUILD_ADVANCED_SERVER_VERSION | BUILD_DATACENTER_VERSION
#define IDB_BANNER16        IDB_BANNER
#else
#define IDB_BANNER16        2
#endif
#define IDB_BKGND0          3
#define IDB_BKGND1          4
#define IDB_BKGND2          5
#define IDB_BKGND3          6
#define IDB_BKGND4          7
#define IDB_256MENU         8
#define IDB_256BORDER       9
#define IDB_16MENU          10
#define IDB_16BORDER        11

//
//  string table entries.
//
#define IDS_TITLE_OPK       999
#define IDS_TITLE           1000
#define IDS_CHECKTEXT       1001
#define IDS_DEFTITLE        1002
#define IDS_DEFBODY         1003
#define IDS_FONTFACE        1004

#define IDS_PSCTITLE        1005
#define IDS_PSCDESC         1006
#define IDS_PSCCONFIG       1007
#define IDS_PSCARGS         1008
#define IDS_PSCMENU         1009

#define IDS_TITLE0          1010
#define IDS_TITLE1          1011
#define IDS_TITLE2          1012
#define IDS_TITLE3          1013
#define IDS_TITLE4          1014
#define IDS_TITLE5          1015
#define IDS_TITLE6          1016
#define IDS_TITLE6          1016
#define IDS_TITLE7          1017
#define IDS_TITLE8          1018
#define IDS_TITLE9          1019

#define IDS_MENU0           1020
#define IDS_MENU1           1021
#define IDS_MENU2           1022
#define IDS_MENU3           1023
#define IDS_MENU4           1024
#define IDS_MENU5           1025
#define IDS_MENU6           1026
#define IDS_MENU7           1027
#define IDS_MENU8           1028
#define IDS_MENU9           1029

#define IDS_DESC0           1030
#define IDS_DESC1           1031
#define IDS_DESC2           1032
#define IDS_DESC3           1033
#define IDS_DESC4           1034
#define IDS_DESC5           1035
#define IDS_DESC6           1036
#define IDS_DESC7           1037
#define IDS_DESC8           1038
#define IDS_DESC9           1039

#define IDS_CONFIG0         1040
#define IDS_CONFIG1         1041
#define IDS_CONFIG2         1042
#define IDS_CONFIG3         1043
#define IDS_CONFIG4         1044
#define IDS_CONFIG5         1045
#define IDS_CONFIG6         1046
#define IDS_CONFIG7         1047
#define IDS_CONFIG8         1048
#define IDS_CONFIG9         1049

#define IDS_ARGS0           1050
#define IDS_ARGS1           1051
#define IDS_ARGS2           1052
#define IDS_ARGS3           1053
#define IDS_ARGS4           1054
#define IDS_ARGS5           1055
#define IDS_ARGS6           1056
#define IDS_ARGS7           1057
#define IDS_ARGS8           1058
#define IDS_ARGS9           1059

#define IDS_OLDCDROM        1060
#define IDS_NEWCDROM        1061

#define IDS_CYMENUITEMFONT  1200
#define IDS_CYTITLEFONT     1201
#define IDS_CYBODYFONT      1202
#define IDS_CYCHECKTEST     1203
#define IDS_WRONGOS         1204

//
//  commands.
//
#define IDM_SHOWCHECK       100
#define IDM_MENUITEM1       101
#define IDM_MENUITEM2       102
#define IDM_MENUITEM3       103
#define IDM_MENUITEM4       104
#define IDM_MENUITEM5       105
#define IDM_MENUITEM6       106
#define IDM_MENUITEM7       107

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\autorun\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT_PTR)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT_PTR)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// The next few functions must declare the structure types explicitly
// so we don't need to worry about whether <shlobj.h> and/or <comctrlp.h>
// was included before or after us.
#include <shtypes.h>

BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl);

BOOL
IsValidHDPA(
    struct _DPA *hdpa);

BOOL
IsValidHDSA(
    struct _DSA *hdsa);

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\bioslock\makefile.inc ===
$(O)\bioschk.com: bioschk.asm 
    masm386 bioschk.asm,$(O)\bioschk.obj;
    link16 /tiny $(O)\bioschk.obj,$@;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\bioslock\bioschk-compaq.asm ===
;++
;
;Copyright (c) 1995  Microsoft Corporation
;
;Module Name:
;
; bioschk.asm
;
;Abstract:
;
; The code in this "image" is responsible for checking if is appropriate
; for us to start setupldr.bin. We consider this appropriate when we pass
; BIOS checkings. Setupldr.bin is binary appended at the end of this image.
;
;Author:
;
;    	Windows 2000 OPK Development Team   16-Dec-1999
;       Alan M. Brown (Compaq Datacenter)   18-Oct-2000
;       Scott Wilmot (CTO Tools)            25-Jan-2001
;    	Windows 2000 OPK Development Team   02-Apr-2001
;
;Environment:
;
;    Real mode
;
;    Case 1:
;       Complete image has been loaded at 2000:0000 by the boot code
;       DL = INT 13h drive number we've booted from
;
;    Case 2:
;       First 512 bytes of this image has been loaded at 2000:000 by the boot code
;       BX = Starting Cluster Number of this image
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure
;
;Revision History:
;
;--
        page    ,132
        title   boot - BIOS check
        name    bioschk

.8086

CODE SEGMENT
ASSUME  CS:CODE,DS:CODE,SS:NOTHING,ES:NOTHING

ORG  0000H

_BiosChk                label       byte

BiosChkDestSeg          EQU 1000h
SetupLdrDestSeg         EQU 2000h
MaxCodeSize             EQU 0800h   ;number of paragraphs (32k)
MaxSetupLdrSize         EQU 4000h   ;number of paragraphs (256k)

StackSeg                EQU 1000h   ;stack goes from here

MAXREAD                 EQU 10000h
MAXSECTORS              EQU MAXREAD/0200h

DoubleWord      struc
        lsw                     dw      ?
        msw                     dw      ?
DoubleWord      ends

SHARED  struc
        ReadClusters            dd      ?               ; function pointer
        ReadSectors             dd      ?               ; function pointer
        SectorBase              dd      ?               ; starting sector for
                                                        ; ReadSectors callback
SHARED  ends

BPB     struc
        BytesPerSector          dw      ?
        SectorsPerCluster       db      ?
        ReservedSectors         dw      ?
        Fats                    db      ?
        DirectoryEntries        dw      ?
        Sectors                 dw      ?
        Media                   db      ?
        FatSectors              dw      ?
        SectorsPerTrack         dw      ?
        Heads                   dw      ?
        HiddenSectors           dd      ?
        SectorsLong             dd      ?
        BootDriveNumber         db      ?
BPB     ends

JMPFAR  MACRO   DestOfs,DestSeg
        db      0eah
        dw      OFFSET  DestOfs
        dw      DestSeg
        endm

START:
;
; The FAT boot sector only reads in the first 512 bytes of NTLDR.  This is
; the module that contains those 512 bytes, so we are now responsible for
; loading the rest of the file.  Other filesystems will load the whole file,
; so the default entrypoint branches around the FAT-specific code.
;
        jmp     RealStart

FatBegin:
.386
;
; If we're here, we've booted off a FAT system and we must load the rest
; of the binary image at 2000:0200 (right behind this sector). The boot
; sector passes us the following:
;       BX = Starting Cluster Number of this image
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure
;

;
; Save away the boot drive and the starting cluster number
;
        push    dx
        push    bx
;
; Blast the FAT into memory at 6000:0000 - 8000:0000
;

.386
        push    06000h
.8086
        pop     es
        xor     bx,bx                           ; (es:bx) = 6000:0000
        mov     cx,ds:[si].ReservedSectors
        mov     ds:[di].SectorBase.msw,0
        mov     ds:[di].SectorBase.lsw,cx       ; set up Sector Base

        mov     ax,ds:[si].FatSectors           ; (al) = # Sectors to read
        cmp     ax,080h
        jbe     FatLt64k

;  The FAT is > 64k, so we read the first 64k chunk, then the rest.
;  (A 16-bit FAT can't be bigger than 128k)

        push    cx
        mov     ax,080h         ; (al) = # of sectors to read
        call    ds:[di].ReadSectors
        pop     cx                      ; (cx) = previous SectorBase
.386
        push    07000h
.8086
        pop     es
        xor     bx,bx                   ; (es:bx) = 7000:0000
        mov     ax,ds:[si].FatSectors
        sub     ax,080h                 ; (ax) = # Sectors left to read
        add     cx,080h                 ; (cx) = SectorBase for next read
        mov     ds:[di].SectorBase.lsw,cx
        adc     ds:[di].SectorBase.msw,0        ; set up SectorBase

;
; (al) = # of sectors to read
;
FatLt64k:
        call    ds:[di].ReadSectors

;
; FAT is in memory, now we restore our starting cluster number
;
        pop     dx                      ; (dx) = starting cluster number
        xor     bx,bx

;
; set up FS and GS for reading the FAT
;
.386
        mov     ax,6000h
        mov     fs,ax
        mov     ax,7000h
        mov     gs,ax
.8086

;
; set up ES for reading in the rest of us
;
        push    cs
        pop     es
        mov     ah,MAXSECTORS           ; (ah) = number of sectors we can read

FatLoop:
;
; (dx) = next cluster to load
;
        push    dx
        mov     al,ds:[si].SectorsPerCluster    ; (al) = number of contiguous sectors
                                                ;        found
        sub     ah,ds:[si].SectorsPerCluster                                                    ;        can read before 64k

;
; Check to see if we've reached the end of the file
;
        cmp     dx,0ffffh
        jne     Fat10

;
; The entire file has been loaded.  Throw away the saved next cluster,
; restore the boot drive, and let NTLDR do its thing.
;
        pop     dx
        pop     dx
        jmp     RealStart

Fat10:
        mov     cx,dx
;
; (dx) = (cx) = last contiguous cluster
; (al) = # of contiguous clusters found
;

        call    NextFatEntry
;
; (dx) = cluster following last contiguous cluster

;
; Check to see if the next cluster is contiguous.  If not, go load the
; contiguous block we've found.
;
        inc     cx
        cmp     dx,cx

        jne     LncLoad

;
; Check to see if we've reached the 64k boundary.  If so, go load the
; contiguous block so far.  If not, increment the number of contiguous
; sectors and loop again.
;
        cmp     ah,0
        jne     Lnc20
        mov     ah,MAXSECTORS           ; (ah) = number of sectors until
        jmp     short LncLoad

Lnc20:
        add     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        jmp     short Fat10


LncLoad:
;
; (TOS) = first cluster to load
; (dx)  = first cluster of next group to load
; (al)  = number of contiguous sectors
;
        pop     cx
        push    dx
        mov     dx,cx
        mov     cx,10                   ; (cx) = retry count

;
; N.B.
;       This assumes that we will never have more than 255 contiguous clusters.
;       Since that would get broken up into chunks that don't cross the 64k
;       boundary, this is ok.
;
; (dx) = first cluster to load
; (al) = number of contiguous sectors
; (TOS) = first cluster of next group to load
; (es:bx) = address where clusters should be loaded
;
FatRetry:
        push    bx
        push    ax
        push    dx
        push    cx
        call    [di].ReadClusters
        jnc     ReadOk
;
; error in the read, reset the drive and try again
;
        mov     ax,01h
        mov     al,ds:[si].BootDriveNumber
        int     13h
        xor     ax,ax
        mov     al,ds:[si].BootDriveNumber
        int     13h

;
; pause for a while
;
        xor     ax,ax
FatPause:
        dec     ax
        jnz     FatPause

        pop     cx
        pop     dx
        pop     ax
        pop     bx

        dec     cx
        jnz     FatRetry

;
; we have re-tried ten times, it still doesn't work, so punt.
;
        push    cs
        pop     ds
        mov     si,offset FAT_ERROR
FatErrPrint:
        lodsb
        or      al,al
        jz      FatErrDone
        mov     ah,14           ; write teletype
        mov     bx,7            ; attribute
        int     10h             ; print it
        jmp     FatErrPrint

FatErrDone:
        jmp     $
        ; BUGBUG this should be replaced by a mechanism to get a pointer
        ; passed to us in the param block. since the boot sector msg itself
        ; is properly localized but this one isn't.
FAT_ERROR       db      13,10,"Disk I/O error",0dh,0ah,0


ReadOk:
        pop     cx
        pop     dx
        pop     ax
        pop     bx
        pop     dx                      ; (dx) = first cluster of next group
                                        ;        to load.

.386
;
; Convert # of sectors into # of bytes.
;
        mov     cl,al
        xor     ch,ch
        shl     cx,9
.8086
        add     bx,cx
        jz      FatLoopDone
        jmp     FatLoop

FatLoopDone:
;
; (bx) = 0
;   This means we've just ended on a 64k boundary, so we have to
;   increment ES to continue reading the file.  We are guaranteed to
;   always end on a 64k boundary and never cross it, because we
;   will reduce the number of contiguous clusters to read
;   to ensure that the last cluster read will end on the 64k boundary.
;   Since we start reading at 0, and ClusterSize will always be a power
;   of two, a cluster will never cross a 64k boundary.
;
        mov     ax,es
        add     ax,01000h
        mov     es,ax
        mov     ah,MAXSECTORS
        jmp     FatLoop

;++
;
; NextFatEntry - This procedure returns the next cluster in the FAT chain.
;                It will deal with both 12-bit and 16-bit FATs.  It assumes
;                that the entire FAT has been loaded into memory.
;
; Arguments:
;    (dx)   = current cluster number
;    (fs:0) = start of FAT in memory
;    (gs:0) = start of second 64k of FAT in memory
;
; Returns:
;    (dx)   = next cluster number in FAT chain
;    (dx)   = 0ffffh if there are no more clusters in the chain
;
;--
NextFatEntry    proc    near
        push    bx

;
; Check to see if this is a 12-bit or 16-bit FAT.  The biggest FAT we can
; have for a 12-bit FAT is 4080 clusters.  This is 6120 bytes, or just under
; 12 sectors.
;
; A 16-bit FAT that's 12 sectors long would only hold 3072 clusters.  Thus,
; we compare the number of FAT sectors to 12.  If it's greater than 12, we
; have a 16-bit FAT.  If it's less than or equal to 12, we have a 12-bit FAT.
;
        call    IsFat12
        jnc     Next16Fat

Next12Fat:
        mov     bx,dx                   ; (fs:bx) => temporary index
        shr     dx,1                    ; (dx) = offset/2
                                        ; (CY) = 1  need to shift
        pushf                           ;      = 0  don't need to shift
        add     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        popf
        jc      shift                   ; carry flag tells us whether to
        and     dx,0fffh                ; mask
        jmp     short N12Tail
shift:
.386
        shr     dx,4                    ; or shift
.8086

N12Tail:
;
; Check for end of file
;
        cmp     dx,0ff8h                ; If we're at the end of the file,
        jb      NfeDone                 ; convert to canonical EOF.
        mov     dx,0ffffh
        jmp     short NfeDone

Next16Fat:
        add     dx,dx                   ; (dx) = offset
        jc      N16high

        mov     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        jmp     short N16Tail

N16high:
        mov     bx,dx
.386
        mov     dx,gs:[bx]
.8086

N16Tail:
        cmp     dx,0fff8h
        jb      NfeDone
        mov     dx,0ffffh               ; If we're at the end of the file
                                        ; convert to canonical EOF.

NfeDone:
        pop     bx
        ret
NextFatEntry    endp

;++
;
; IsFat12 - This function determines whether the BPB describes a 12-bit
;           or 16-bit FAT.
;
; Arguments - ds:si supplies pointer to BPB
;
; Returns
;       CY set -   12-bit FAT
;       CY clear - 16-bit FAT
;
;--
IsFat12 proc    near

.386
        push    eax
        push    ebx
        push    ecx
        push    edx

        movzx   ecx, ds:[si].Sectors
        or      cx,cx
        jnz     if10
        mov     ecx, ds:[si].SectorsLong
if10:
;
; (ecx) = number of sectors
;
        movzx   ebx, byte ptr ds:[si].Fats
        movzx   eax, word ptr ds:[si].FatSectors
        mul     ebx
        sub     ecx,eax

;
; (ecx) = (#sectors)-(sectors in FATs)
;
        movzx   eax, word ptr ds:[si].DirectoryEntries
        shl     eax, 5
;
; (eax) = #bytes in root dir
;
        mov     edx,eax
        and     edx,0ffff0000h
        div     word ptr ds:[si].BytesPerSector
        sub     ecx,eax

;
; (ecx) = (#sectors) - (sectors in fat) - (sectors in root dir)
;
        movzx   eax, word ptr ds:[si].ReservedSectors
        sub     ecx, eax
        mov     eax, ecx
        movzx   ecx, byte ptr ds:[si].SectorsPerCluster
        xor     edx,edx
        div     ecx

        cmp     eax, 4087
        jae     if20
        stc
        jmp     short if30
if20:
        clc
if30:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        ret
.8086
IsFat12 endp


Free    EQU     512-($-Start)
if Free lt 0
        %out FATAL PROBLEM: FAT-specific startup code is greater than
        %out 512 bytes.  Fix it!
        .err
endif

RealStart:

;
; we are completely done with the boot sector, we can party on it's memory as we like.
; set up the stack
;
        mov     ax,StackSeg
        mov     ss,ax
        xor     sp,sp

        mov     ax,cs
        mov     ds,ax
        mov     es,ax

;
; save setupldr data
;
        mov     Preserve, dl

; move ourselves from 2000:0000 to 1000:0000, one paragraph at a time.

        mov     ax, BiosChkDestSeg
        mov     es, ax
        mov     dx, MaxCodeSize
        cld
Again1:
        xor     di, di
        xor     si, si
        mov     cx, 10h
        rep     movsb
        mov     ax, ds
        inc     ax
        mov     ds, ax
        mov     ax, es
        inc     ax
        mov     es, ax
        dec     dx
        jnz     Again1
        mov     ax, BiosChkDestSeg
        mov     ds, ax
        mov     es, ax
        JMPFAR  Continue1, BiosChkDestSeg

Continue1:


; Go to System specific check
        jmp 	short IDCheck1

IdString1    	db 'COMPAQ'
SYSID1          EQU 'C '
SYSID2          EQU '3L'
SYSID3          EQU '08'

NoMatchUS       db "This system is not a supported platform.",13,10,"$"
TestString      db 7 dup (0)

IDCheck1:
        push    ds
        push    si
        mov     ax,0f000h
        push    ax
        pop     ds
        mov     ax,0ffeah
        push    ax
        pop     si
        mov     di,OFFSET TestString
        mov     cx,6
        rep     movsb
        pop     si
        pop     ds
        mov     si,OFFSET IdString1
        mov     di,OFFSET TestString
        mov     cx,6
        repe 	cmpsb
        jne	    IDCheckFailed
        
IDCheck2:
;
        push    es
;
    	mov     ax, 0f000h              ; look in the ROM area for our system name id string search
    	mov     es, ax                  ; load segment into ROM area
    	xor     di, di                  ; begin indexing ROM area at 0
    	mov     dx, 8000h               ; total area to search
Loop2:	
        cmp     di, dx                  ; Q: have we exhausted our search?
        je      short IDCheckFailed     ; Y:  unable to find string
        mov     si, di                  ; save off the data
        inc     di                      ; increment 1-byte for next loop
        mov     ax, word ptr es:[si]    ; read 2-bytes
        cmp     ax, offset SYSID1       ; Q: match?
    	jne     short Loop2             ; N:  start again
    	mov     ax, word ptr es:[si+2]  ; read next 2-bytes
    	cmp     ax, offset SYSID2       ; Q: match?
    	jne     short Loop2             ; N:  start again
    	mov     ax, word ptr es:[si+4]  ; read next 2-bytes
    	cmp     ax, offset SYSID3       ; Q: match?
    	jne     short Loop2             ; N:  start again
;
        pop     es
;
        jmp     short MoveSetupLdr      ; Y:  Join the party...

;	    
; The System specific check failed...this system is not supported.
;
IDCheckFailed:
;
        pop     es
;       
        push    dx
        push    cx
        push    bx
        push    ax
        push    bp
        mov     ax,1301h
        mov     bx,0007h
        mov     cx,42
        mov     dx,0A00h
        mov     bp, OFFSET NoMatchUS
        int     10h
        pop     bp
        pop     ax
        pop     bx
        pop     cx
        pop     dx
        jmp     Continue2


MoveSetupLdr:
; move Setupldr code from 2000+MaxCodeSize:0000 to 2000:0000, one paragraph at a time.

        push    ds
        push    es
        mov     ax, SetupLdrDestSeg
        mov     es, ax
        add     ax, MaxCodeSize
        mov     ds, ax
        mov     dx, MaxSetupLdrSize
        cld
Again2:
        xor     di, di
        xor     si, si
        mov     cx, 10h
        rep     movsb
        mov     ax, ds
        inc     ax
        mov     ds, ax
        mov     ax, es
        inc     ax
        mov     es, ax
        dec     dx
        jnz     Again2
        pop     es
        pop     ds

Continue2:
        mov     dl, Preserve
        JMPFAR  0,SetupLdrDestSeg

;
;EXPECTS DS:SI - MESSAGE ADDR
;
PrintMsg proc    near
        push    ax
        push    bx
PrintMsgLoop:
        lodsb
        cmp     al,0
        je      PrintMsgEnd
        mov     ah,0eh
        mov     bx,0007h
        int     10h
        jmp     PrintMsgLoop
PrintMsgEnd:
        pop     bx
        pop     ax
        ret
PrintMsg endp

Preserve                db      ?
MsgPressKey             db      0dh, 0ah, "Press any key to continue..."
                        db      0

.errnz  ($-_BiosChk) GT (MaxCodeSize*16 - 2)    ;FATAL: BiosChk code is too large

        org     MaxCodeSize*16 - 2
        db      55h,0aah


CODE ENDS
END  START
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\bioslock\bioschk.asm ===
;++
;
;Copyright (c) 1995  Microsoft Corporation
;
;Module Name:
;
; bioschk.asm
;
;Abstract:
;
; The code in this "image" is responsible for checking if is appropriate
; for us to start setupldr.bin. We consider this appropriate when we pass
; BIOS checkings. Setupldr.bin is binary appended at the end of this image.
;
;Author:
;
;    Calin Negreanu (calinn) 16-Dec-1999
;
;Environment:
;
;    Real mode
;
;    Case 1:
;       Complete image has been loaded at 2000:0000 by the boot code
;       DL = INT 13h drive number we've booted from
;
;    Case 2:
;       First 512 bytes of this image has been loaded at 2000:000 by the boot code
;       BX = Starting Cluster Number of this image
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure
;
;Revision History:
;
;--
        page    ,132
        title   boot - BIOS check
        name    bioschk

.8086

CODE SEGMENT
ASSUME  CS:CODE,DS:CODE,SS:NOTHING,ES:NOTHING

ORG  0000H

_BiosChk                label       byte

BiosChkDestSeg          EQU 1000h
SetupLdrDestSeg         EQU 2000h
MaxCodeSize             EQU 0800h   ;number of paragraphs (32k)
MaxSetupLdrSize         EQU 4000h   ;number of paragraphs (256k)

StackSeg                EQU 1000h   ;stack goes from here

MAXREAD                 EQU 10000h
MAXSECTORS              EQU MAXREAD/0200h

DoubleWord      struc
        lsw                     dw      ?
        msw                     dw      ?
DoubleWord      ends

SHARED  struc
        ReadClusters            dd      ?               ; function pointer
        ReadSectors             dd      ?               ; function pointer
        SectorBase              dd      ?               ; starting sector for
                                                        ; ReadSectors callback
SHARED  ends

BPB     struc
        BytesPerSector          dw      ?
        SectorsPerCluster       db      ?
        ReservedSectors         dw      ?
        Fats                    db      ?
        DirectoryEntries        dw      ?
        Sectors                 dw      ?
        Media                   db      ?
        FatSectors              dw      ?
        SectorsPerTrack         dw      ?
        Heads                   dw      ?
        HiddenSectors           dd      ?
        SectorsLong             dd      ?
        BootDriveNumber         db      ?
BPB     ends

JMPFAR  MACRO   DestOfs,DestSeg
        db      0eah
        dw      OFFSET  DestOfs
        dw      DestSeg
        endm

START:
;
; The FAT boot sector only reads in the first 512 bytes of NTLDR.  This is
; the module that contains those 512 bytes, so we are now responsible for
; loading the rest of the file.  Other filesystems will load the whole file,
; so the default entrypoint branches around the FAT-specific code.
;
        jmp     RealStart

FatBegin:
.386
;
; If we're here, we've booted off a FAT system and we must load the rest
; of the binary image at 2000:0200 (right behind this sector). The boot
; sector passes us the following:
;       BX = Starting Cluster Number of this image
;       DL = INT 13h drive number we've booted from
;       DS:SI -> boot media's BPB
;       DS:DI -> argument structure
;

;
; Save away the boot drive and the starting cluster number
;
        push    dx
        push    bx
;
; Blast the FAT into memory at 6000:0000 - 8000:0000
;

.386
        push    06000h
.8086
        pop     es
        xor     bx,bx                           ; (es:bx) = 6000:0000
        mov     cx,ds:[si].ReservedSectors
        mov     ds:[di].SectorBase.msw,0
        mov     ds:[di].SectorBase.lsw,cx       ; set up Sector Base

        mov     ax,ds:[si].FatSectors           ; (al) = # Sectors to read
        cmp     ax,080h
        jbe     FatLt64k

;  The FAT is > 64k, so we read the first 64k chunk, then the rest.
;  (A 16-bit FAT can't be bigger than 128k)

        push    cx
        mov     ax,080h         ; (al) = # of sectors to read
        call    ds:[di].ReadSectors
        pop     cx                      ; (cx) = previous SectorBase
.386
        push    07000h
.8086
        pop     es
        xor     bx,bx                   ; (es:bx) = 7000:0000
        mov     ax,ds:[si].FatSectors
        sub     ax,080h                 ; (ax) = # Sectors left to read
        add     cx,080h                 ; (cx) = SectorBase for next read
        mov     ds:[di].SectorBase.lsw,cx
        adc     ds:[di].SectorBase.msw,0        ; set up SectorBase

;
; (al) = # of sectors to read
;
FatLt64k:
        call    ds:[di].ReadSectors

;
; FAT is in memory, now we restore our starting cluster number
;
        pop     dx                      ; (dx) = starting cluster number
        xor     bx,bx

;
; set up FS and GS for reading the FAT
;
.386
        mov     ax,6000h
        mov     fs,ax
        mov     ax,7000h
        mov     gs,ax
.8086

;
; set up ES for reading in the rest of us
;
        push    cs
        pop     es
        mov     ah,MAXSECTORS           ; (ah) = number of sectors we can read

FatLoop:
;
; (dx) = next cluster to load
;
        push    dx
        mov     al,ds:[si].SectorsPerCluster    ; (al) = number of contiguous sectors
                                                ;        found
        sub     ah,ds:[si].SectorsPerCluster                                                    ;        can read before 64k

;
; Check to see if we've reached the end of the file
;
        cmp     dx,0ffffh
        jne     Fat10

;
; The entire file has been loaded.  Throw away the saved next cluster,
; restore the boot drive, and let NTLDR do its thing.
;
        pop     dx
        pop     dx
        jmp     RealStart

Fat10:
        mov     cx,dx
;
; (dx) = (cx) = last contiguous cluster
; (al) = # of contiguous clusters found
;

        call    NextFatEntry
;
; (dx) = cluster following last contiguous cluster

;
; Check to see if the next cluster is contiguous.  If not, go load the
; contiguous block we've found.
;
        inc     cx
        cmp     dx,cx

        jne     LncLoad

;
; Check to see if we've reached the 64k boundary.  If so, go load the
; contiguous block so far.  If not, increment the number of contiguous
; sectors and loop again.
;
        cmp     ah,0
        jne     Lnc20
        mov     ah,MAXSECTORS           ; (ah) = number of sectors until
        jmp     short LncLoad

Lnc20:
        add     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        jmp     short Fat10


LncLoad:
;
; (TOS) = first cluster to load
; (dx)  = first cluster of next group to load
; (al)  = number of contiguous sectors
;
        pop     cx
        push    dx
        mov     dx,cx
        mov     cx,10                   ; (cx) = retry count

;
; N.B.
;       This assumes that we will never have more than 255 contiguous clusters.
;       Since that would get broken up into chunks that don't cross the 64k
;       boundary, this is ok.
;
; (dx) = first cluster to load
; (al) = number of contiguous sectors
; (TOS) = first cluster of next group to load
; (es:bx) = address where clusters should be loaded
;
FatRetry:
        push    bx
        push    ax
        push    dx
        push    cx
        call    [di].ReadClusters
        jnc     ReadOk
;
; error in the read, reset the drive and try again
;
        mov     ax,01h
        mov     al,ds:[si].BootDriveNumber
        int     13h
        xor     ax,ax
        mov     al,ds:[si].BootDriveNumber
        int     13h

;
; pause for a while
;
        xor     ax,ax
FatPause:
        dec     ax
        jnz     FatPause

        pop     cx
        pop     dx
        pop     ax
        pop     bx

        dec     cx
        jnz     FatRetry

;
; we have re-tried ten times, it still doesn't work, so punt.
;
        push    cs
        pop     ds
        mov     si,offset FAT_ERROR
FatErrPrint:
        lodsb
        or      al,al
        jz      FatErrDone
        mov     ah,14           ; write teletype
        mov     bx,7            ; attribute
        int     10h             ; print it
        jmp     FatErrPrint

FatErrDone:
        jmp     $
        ; BUGBUG this should be replaced by a mechanism to get a pointer
        ; passed to us in the param block. since the boot sector msg itself
        ; is properly localized but this one isn't.
FAT_ERROR       db      13,10,"Disk I/O error",0dh,0ah,0


ReadOk:
        pop     cx
        pop     dx
        pop     ax
        pop     bx
        pop     dx                      ; (dx) = first cluster of next group
                                        ;        to load.

.386
;
; Convert # of sectors into # of bytes.
;
        mov     cl,al
        xor     ch,ch
        shl     cx,9
.8086
        add     bx,cx
        jz      FatLoopDone
        jmp     FatLoop

FatLoopDone:
;
; (bx) = 0
;   This means we've just ended on a 64k boundary, so we have to
;   increment ES to continue reading the file.  We are guaranteed to
;   always end on a 64k boundary and never cross it, because we
;   will reduce the number of contiguous clusters to read
;   to ensure that the last cluster read will end on the 64k boundary.
;   Since we start reading at 0, and ClusterSize will always be a power
;   of two, a cluster will never cross a 64k boundary.
;
        mov     ax,es
        add     ax,01000h
        mov     es,ax
        mov     ah,MAXSECTORS
        jmp     FatLoop

;++
;
; NextFatEntry - This procedure returns the next cluster in the FAT chain.
;                It will deal with both 12-bit and 16-bit FATs.  It assumes
;                that the entire FAT has been loaded into memory.
;
; Arguments:
;    (dx)   = current cluster number
;    (fs:0) = start of FAT in memory
;    (gs:0) = start of second 64k of FAT in memory
;
; Returns:
;    (dx)   = next cluster number in FAT chain
;    (dx)   = 0ffffh if there are no more clusters in the chain
;
;--
NextFatEntry    proc    near
        push    bx

;
; Check to see if this is a 12-bit or 16-bit FAT.  The biggest FAT we can
; have for a 12-bit FAT is 4080 clusters.  This is 6120 bytes, or just under
; 12 sectors.
;
; A 16-bit FAT that's 12 sectors long would only hold 3072 clusters.  Thus,
; we compare the number of FAT sectors to 12.  If it's greater than 12, we
; have a 16-bit FAT.  If it's less than or equal to 12, we have a 12-bit FAT.
;
        call    IsFat12
        jnc     Next16Fat

Next12Fat:
        mov     bx,dx                   ; (fs:bx) => temporary index
        shr     dx,1                    ; (dx) = offset/2
                                        ; (CY) = 1  need to shift
        pushf                           ;      = 0  don't need to shift
        add     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        popf
        jc      shift                   ; carry flag tells us whether to
        and     dx,0fffh                ; mask
        jmp     short N12Tail
shift:
.386
        shr     dx,4                    ; or shift
.8086

N12Tail:
;
; Check for end of file
;
        cmp     dx,0ff8h                ; If we're at the end of the file,
        jb      NfeDone                 ; convert to canonical EOF.
        mov     dx,0ffffh
        jmp     short NfeDone

Next16Fat:
        add     dx,dx                   ; (dx) = offset
        jc      N16high

        mov     bx,dx                   ; (fs:bx) => next cluster number
.386
        mov     dx,fs:[bx]              ; (dx) = next cluster number
.8086
        jmp     short N16Tail

N16high:
        mov     bx,dx
.386
        mov     dx,gs:[bx]
.8086

N16Tail:
        cmp     dx,0fff8h
        jb      NfeDone
        mov     dx,0ffffh               ; If we're at the end of the file
                                        ; convert to canonical EOF.

NfeDone:
        pop     bx
        ret
NextFatEntry    endp

;++
;
; IsFat12 - This function determines whether the BPB describes a 12-bit
;           or 16-bit FAT.
;
; Arguments - ds:si supplies pointer to BPB
;
; Returns
;       CY set -   12-bit FAT
;       CY clear - 16-bit FAT
;
;--
IsFat12 proc    near

.386
        push    eax
        push    ebx
        push    ecx
        push    edx

        movzx   ecx, ds:[si].Sectors
        or      cx,cx
        jnz     if10
        mov     ecx, ds:[si].SectorsLong
if10:
;
; (ecx) = number of sectors
;
        movzx   ebx, byte ptr ds:[si].Fats
        movzx   eax, word ptr ds:[si].FatSectors
        mul     ebx
        sub     ecx,eax

;
; (ecx) = (#sectors)-(sectors in FATs)
;
        movzx   eax, word ptr ds:[si].DirectoryEntries
        shl     eax, 5
;
; (eax) = #bytes in root dir
;
        mov     edx,eax
        and     edx,0ffff0000h
        div     word ptr ds:[si].BytesPerSector
        sub     ecx,eax

;
; (ecx) = (#sectors) - (sectors in fat) - (sectors in root dir)
;
        movzx   eax, word ptr ds:[si].ReservedSectors
        sub     ecx, eax
        mov     eax, ecx
        movzx   ecx, byte ptr ds:[si].SectorsPerCluster
        xor     edx,edx
        div     ecx

        cmp     eax, 4087
        jae     if20
        stc
        jmp     short if30
if20:
        clc
if30:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        ret
.8086
IsFat12 endp


Free    EQU     512-($-Start)
if Free lt 0
        %out FATAL PROBLEM: FAT-specific startup code is greater than
        %out 512 bytes.  Fix it!
        .err
endif

RealStart:

;
; we are completely done with the boot sector, we can party on it's memory as we like.
; set up the stack
;
        mov     ax,StackSeg
        mov     ss,ax
        xor     sp,sp

        mov     ax,cs
        mov     ds,ax
        mov     es,ax

;
; save setupldr data
;
        mov     Preserve, dl

; move ourselves from 2000:0000 to 1000:0000, one paragraph at a time.

        mov     ax, BiosChkDestSeg
        mov     es, ax
        mov     dx, MaxCodeSize
        cld
Again1:
        xor     di, di
        xor     si, si
        mov     cx, 10h
        rep     movsb
        mov     ax, ds
        inc     ax
        mov     ds, ax
        mov     ax, es
        inc     ax
        mov     es, ax
        dec     dx
        jnz     Again1
        mov     ax, BiosChkDestSeg
        mov     ds, ax
        mov     es, ax
        JMPFAR  Continue1, BiosChkDestSeg

Continue1:

; insert your BIOS check code here
; for now we will just display a message and wait for the user to press a key
        mov     si,OFFSET MsgPressKey
        call    PrintMsg
QueueEmpty:
        mov     ah, 01h
        int     16h
        jz      QueueEmpty

; instead of a real BIOS check we will check if the user holds down CTRL.
; If yes, we will behave like BIOS check failed

;        mov     ah,02h
;        int     16h
;        and     al,00000100b
;        jz      MoveSetupLdr

; at this point, the BIOS check failed. You can add whatever code you want here
; to give a message or to make the computer crash. If you don't do anything, the
; code will jump to 2000:0000 so an infinite loop is going to happen.
;        jmp     Continue2

MoveSetupLdr:
; move Setupldr code from 2000+MaxCodeSize:0000 to 2000:0000, one paragraph at a time.

        push    ds
        push    es
        mov     ax, SetupLdrDestSeg
        mov     es, ax
        add     ax, MaxCodeSize
        mov     ds, ax
        mov     dx, MaxSetupLdrSize
        cld
Again2:
        xor     di, di
        xor     si, si
        mov     cx, 10h
        rep     movsb
        mov     ax, ds
        inc     ax
        mov     ds, ax
        mov     ax, es
        inc     ax
        mov     es, ax
        dec     dx
        jnz     Again2
        pop     es
        pop     ds

Continue2:
        mov     dl, Preserve
        JMPFAR  0,SetupLdrDestSeg

;
;EXPECTS DS:SI - MESSAGE ADDR
;
PrintMsg proc    near
        push    ax
        push    bx
PrintMsgLoop:
        lodsb
        cmp     al,0
        je      PrintMsgEnd
        mov     ah,0eh
        mov     bx,0007h
        int     10h
        jmp     PrintMsgLoop
PrintMsgEnd:
        pop     bx
        pop     ax
        ret
PrintMsg endp

Preserve                db      ?
MsgPressKey             db      0dh, 0ah, "Press any key to continue..."
                        db      0

.errnz  ($-_BiosChk) GT (MaxCodeSize*16 - 2)    ;FATAL: BiosChk code is too large

        org     MaxCodeSize*16 - 2
        db      55h,0aah


CODE ENDS
END  START
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\buildhive.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    buildhive.cpp

Abstract:

    Builds the hive from the specified inf files.
    The inf files follow the same syntax as used
    by setup.
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)
    
--*/


#include <new.h>
#include "buildhive.h"
#include "File.h"
#include "Data.h"

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR   Message[4096];

//
// Define a function to be called if new fails to allocate memory.
//

int __cdecl MyNewHandler( size_t size )
{
    
    _putws(GetFormattedMessage( ThisModule,
                                FALSE,
                                Message,
                                sizeof(Message)/sizeof(Message[0]),
                                MSG_MEMORY_ALLOC_FAILED) );
    // Exit program
    //
    ExitProcess(errOUT_OF_MEMORY);
}

//
// main() entry point
//
int 
_cdecl 
wmain(
    int Argc,
    wchar_t *Argv[]
    ) 
{
    DWORD ErrorCode = 0;
    HANDLE hToken;

    ThisModule = GetModuleHandle(NULL);

    _set_new_handler( MyNewHandler );

    try {
        if (Argc < 2) {
            return ShowProgramUsage();
        }

        std::wstring InputFile = Argv[1];

        if ((InputFile == L"/?") ||
            (InputFile == L"?") ||
            (InputFile == L"-?") ||
            (InputFile == L"-h")) {
            return ShowProgramUsage();          
        }           

        RegUnLoadKey(HKEY_USERS, L"dummy");

        //
        // Set privileges needed to load and save registry keys.
        //
        OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken);
        SetPrivilege(hToken,SE_BACKUP_NAME,TRUE);
        SetPrivilege(hToken,SE_RESTORE_NAME,TRUE);

        ErrorCode = GetLastError();

        if (ErrorCode != ERROR_SUCCESS) {
            throw new W32Error(ErrorCode);
        }

        std::cout << InputFile << std::endl;

        //
        // load the configuration file
        //
        File ConfigFile(InputFile.c_str(), false);

        //
        // look for the sections defining the target files and .inf files
        //

        //
        // get the target directory
        //
        ConfigFile.AddInfSection(InputFile.c_str(), 
                        L"Directory",
                        L"SetDirectory");

        //
        // set the directory
        //
        ConfigFile.ProcessSections();

        //
        // NOTE: The sections are processed in the order of addition
        //
        ConfigFile.AddInfSection(InputFile.c_str(), 
                        L"Add Registry New",
                        L"AddRegNew");

        //                          
        // do the actual conversion from .inf to hive files since
        // we may need them for adding existing entries
        //
        ConfigFile.ProcessSections();
        
        //
        // process the localization specific registry sections
        //
        ConfigFile.ProcessNlsRegistryEntries();        

        //
        // process modify/delete entries 
        //
        ConfigFile.AddInfSection(InputFile.c_str(), 
                        L"Add Registry Existing",
                        L"AddRegExisting");            
                                               
        
        ConfigFile.AddInfSection(InputFile.c_str(), 
                        L"Delete Registry Existing",
                        L"DelRegExisting");
        
        //                          
        // do the actual conversion from .inf to hive file
        //
        ConfigFile.ProcessSections();
        
        //
        // save the hive files and clean out the registry
        //
        ConfigFile.Cleanup();
    } catch (DWORD x) {
        ErrorCode = x;
        std::cout << GetFormattedMessage( ThisModule,
                                          FALSE,
                                          Message,
                                          sizeof(Message)/sizeof(Message[0]),
                                          MSG_ERROR_ABNORMAL_PGM_TERMINATION);
        
        switch (x) {
            case errFILE_LOCKED:
                std::cout << GetFormattedMessage(ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_ERROR_FILE_LOCKED);
                break;
                
            case errBAD_FLAGS:
                std::cout << GetFormattedMessage(ThisModule,
                                                  FALSE,
                                                  Message,
                                                  sizeof(Message)/sizeof(Message[0]),
                                                  MSG_ERROR_BAD_FLAGS);
                break;
                
            case errFILE_NOT_FOUND:
                std::cout << GetFormattedMessage(ThisModule,
                                                  FALSE,
                                                  Message,
                                                  sizeof(Message)/sizeof(Message[0]),
                                                  MSG_ERROR_FILE_NOT_FOUND);
                break;
                
            case errGENERAL_ERROR:
                std::cout << GetFormattedMessage(ThisModule,
                                                  FALSE,
                                                  Message,
                                                  sizeof(Message)/sizeof(Message[0]),
                                                  MSG_ERROR_GENERAL_ERROR);
                break;
                
            default:
                std::cout << GetFormattedMessage(ThisModule,
                                                  FALSE,
                                                  Message,
                                                  sizeof(Message)/sizeof(Message[0]),
                                                  MSG_ERROR_ERROR_CODE,
                                                  x);
        }
    }           
    catch(W32Error *Error) {
        if (Error) {
            Error->Dump(std::cout);
            ErrorCode = Error->ErrorCode; 
            delete Error;
        } else {
            ErrorCode = 1;
        }            
    }
    catch(...) {
        ErrorCode = 1;    // unknown error
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_ERROR_ABNORMAL_PGM_TERMINATION) );
    }

    RegUnLoadKey(HKEY_USERS, L"dummy");
    
    _putws( GetFormattedMessage(ThisModule,
                                FALSE,
                                Message,
                                sizeof(Message)/sizeof(Message[0]),
                                MSG_COMPLETED) );

    return ErrorCode;
}


BOOL SetPrivilege(
    IN HANDLE  hToken,
    IN LPCTSTR lpszPrivilege,
    IN BOOL    bEnablePrivilege
    ) 
/*++

Routine Description:

    Sets privileges for the current process.  Used to get permission 
    to save and loadregistry keys

Arguments :

    hToken : Handle to the token whose priviledge has to be modified
                        
    lpszPrivilege : Priviledge name
    
    bEnablePrivilege : Enable or disable the priviledge

Return Value :

    TRUE if successful, otherwise FALSE.
    
--*/
{
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (!LookupPrivilegeValue(NULL, lpszPrivilege, &luid)){
        return FALSE; 
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;

    if (bEnablePrivilege) {
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    } else {
        tp.Privileges[0].Attributes = 0;
    }        

    //
    // Enable the privilege or disable all privileges.
    //
    AdjustTokenPrivileges(hToken, 
                          FALSE, 
                          &tp, 
                          sizeof(TOKEN_PRIVILEGES), 
                          (PTOKEN_PRIVILEGES) NULL, 
                          (PDWORD) NULL); 

    //
    // Call GetLastError to determine whether the function succeeded.
    //
    return (GetLastError() != ERROR_SUCCESS) ? FALSE : TRUE;
}


INT
ShowProgramUsage(
      VOID   
    )
/*++

Routine Description:

    Shows show help message on how to use the program.

Arguments:

    None.

Return Value:

    0 if successful other non-zero value
    
--*/
{
    //
    // TBD : Need to localize this message in future
    // based on the need for localized WinPE build
    // tools
    //

    _putws( GetFormattedMessage(ThisModule,
                                FALSE,
                                Message,
                                sizeof(Message)/sizeof(Message[0]),
                                MSG_PGM_USAGE) );
    
    return 0;                
}

//
// Returns a TCHAR string explaining the last win32 error code
//
PCTSTR
Error(
    VOID
    ) 
{
    static TCHAR MessageBuffer[4096];

    MessageBuffer[0] = UNICODE_NULL;
    
    FormatMessage( 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        MessageBuffer,
        sizeof(MessageBuffer)/sizeof(TCHAR),
        NULL);
        
    return MessageBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\bioslock\bioschk-old.asm ===
;++
;
;Copyright (c) 1995  Microsoft Corporation
;
;Module Name:
;
; bioschk.asm
;
;Abstract:
;
; The code in this "image" is responsible for checking if is appropriate
; for us to start setupldr.bin. We consider this appropriate when we pass
; BIOS checkings. Setupldr.bin is binary appended at the end of this image.
;
;Author:
;
;    Calin Negreanu (calinn) 16-Dec-1999
;
;Environment:
;
;    Real mode
;    Case 1:
;       Complete image has been loaded at 2000:0000 by the boot code
;       DL = meaningfull data
;    Case 2:
;       First 512 bytes of this image has been loaded at 2000:000 by the boot code
;       BX = meaningfull data
;       DL = meaningfull data
;       DS:SI -> points to a structure containing meaningfull data
;       DS:DI -> points to a structure containing meaningfull data
;
;Revision History:
;
;--
        page    ,132
        title   boot - BIOS check
        name    bioschk

.8086

CODE SEGMENT
ASSUME  CS:CODE,DS:CODE,SS:NOTHING,ES:NOTHING

ORG  0000H

_BiosChk                label       byte

BiosChkDestSeg          EQU 1000h
SetupLdrDestSeg         EQU 2000h
MaxCodeSize             EQU 0800h   ;number of paragraphs (32k)
MaxSetupLdrSize         EQU 4000h   ;number of paragraphs (256k)

StackSeg                EQU 1000h   ;stack goes from here

MAXREAD                 EQU 10000h
MAXSECTORS              EQU MAXREAD/0200h

DoubleWord      struc
        lsw                     dw      ?
        msw                     dw      ?
DoubleWord      ends

SHARED  struc
        ReadClusters            dd      ?
        ReadSectors             dd      ?
        SectorBase              dd      ?
SHARED  ends

BPB     struc
        BytesPerSector          dw      ?
        SectorsPerCluster       db      ?
        ReservedSectors         dw      ?
        Fats                    db      ?
        DirectoryEntries        dw      ?
        Sectors                 dw      ?
        Media                   db      ?
        FatSectors              dw      ?
        SectorsPerTrack         dw      ?
        Heads                   dw      ?
        HiddenSectors           dd      ?
        SectorsLong             dd      ?
        BootDriveNumber         db      ?
BPB     ends

JMPFAR  MACRO   DestOfs,DestSeg
        db      0eah
        dw      OFFSET  DestOfs
        dw      DestSeg
        endm

START:
; If we boot from FAT drives, the next instruction is not executed.
        jmp     RealStart

FatBegin:
.386
;
; If we're here, we've booted off a FAT system and we must load the rest
; of the binary image at 2000:0200 (right behind this sector).
;

;
; Save away meaningfull data
;
        push    dx
        push    bx

.386
        push    06000h
.8086
        pop     es
        xor     bx,bx
        mov     cx,ds:[si].ReservedSectors
        mov     ds:[di].SectorBase.msw,0
        mov     ds:[di].SectorBase.lsw,cx

        mov     ax,ds:[si].FatSectors
        cmp     ax,080h
        jbe     FatLt64k
        push    cx
        mov     ax,080h
        call    ds:[di].ReadSectors
        pop     cx
.386
        push    07000h
.8086
        pop     es
        xor     bx,bx
        mov     ax,ds:[si].FatSectors
        sub     ax,080h
        add     cx,080h
        mov     ds:[di].SectorBase.lsw,cx
        adc     ds:[di].SectorBase.msw,0
FatLt64k:
        call    ds:[di].ReadSectors
        pop     dx
        xor     bx,bx
.386
        mov     ax,6000h
        mov     fs,ax
        mov     ax,7000h
        mov     gs,ax
.8086
        push    cs
        pop     es
        mov     ah,MAXSECTORS
FatLoop:
        push    dx
        mov     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        cmp     dx,0ffffh
        jne     Fat10
        pop     dx
        pop     dx
        jmp     RealStart
Fat10:
        mov     cx,dx
        call    NextFatEntry
        inc     cx
        cmp     dx,cx
        jne     LncLoad
        cmp     ah,0
        jne     Lnc20
        mov     ah,MAXSECTORS
        jmp     short LncLoad
Lnc20:
        add     al,ds:[si].SectorsPerCluster
        sub     ah,ds:[si].SectorsPerCluster
        jmp     short Fat10
LncLoad:
        pop     cx
        push    dx
        mov     dx,cx
        mov     cx,10
FatRetry:
        push    bx
        push    ax
        push    dx
        push    cx
        call    [di].ReadClusters
        jnc     ReadOk
        mov     ax,01h
        mov     al,ds:[si].BootDriveNumber
        int     13h
        xor     ax,ax
        mov     al,ds:[si].BootDriveNumber
        int     13h
        xor     ax,ax
FatPause:
        dec     ax
        jnz     FatPause

        pop     cx
        pop     dx
        pop     ax
        pop     bx

        dec     cx
        jnz     FatRetry
        push    cs
        pop     ds
        mov     si,offset FAT_ERROR
FatErrPrint:
        lodsb
        or      al,al
        jz      FatErrDone
        mov     ah,14
        mov     bx,7
        int     10h
        jmp     FatErrPrint
FatErrDone:
        jmp     $

FAT_ERROR       db      13,10,"Disk I/O error",0dh,0ah,0

ReadOk:
        pop     cx
        pop     dx
        pop     ax
        pop     bx
        pop     dx
.386
        mov     cl,al
        xor     ch,ch
        shl     cx,9
.8086
        add     bx,cx
        jz      FatLoopDone
        jmp     FatLoop
FatLoopDone:
        mov     ax,es
        add     ax,01000h
        mov     es,ax
        mov     ah,MAXSECTORS
        jmp     FatLoop

NextFatEntry    proc    near
        push    bx
        call    IsFat12
        jnc     Next16Fat
Next12Fat:
        mov     bx,dx
        shr     dx,1
        pushf
        add     bx,dx
.386
        mov     dx,fs:[bx]
.8086
        popf
        jc      shift
        and     dx,0fffh
        jmp     short N12Tail
shift:
.386
        shr     dx,4
.8086
N12Tail:
        cmp     dx,0ff8h
        jb      NfeDone
        mov     dx,0ffffh
        jmp     short NfeDone
Next16Fat:
        add     dx,dx
        jc      N16high
        mov     bx,dx
.386
        mov     dx,fs:[bx]
.8086
        jmp     short N16Tail
N16high:
        mov     bx,dx
.386
        mov     dx,gs:[bx]
.8086
N16Tail:
        cmp     dx,0fff8h
        jb      NfeDone
        mov     dx,0ffffh
NfeDone:
        pop     bx
        ret
NextFatEntry    endp

IsFat12 proc    near
.386
        push    eax
        push    ebx
        push    ecx
        push    edx

        movzx   ecx, ds:[si].Sectors
        or      cx,cx
        jnz     if10
        mov     ecx, ds:[si].SectorsLong
if10:
        movzx   ebx, byte ptr ds:[si].Fats
        movzx   eax, word ptr ds:[si].FatSectors
        mul     ebx
        sub     ecx,eax
        movzx   eax, word ptr ds:[si].DirectoryEntries
        shl     eax, 5
        mov     edx,eax
        and     edx,0ffff0000h
        div     word ptr ds:[si].BytesPerSector
        sub     ecx,eax
        movzx   eax, word ptr ds:[si].ReservedSectors
        sub     ecx, eax
        mov     eax, ecx
        movzx   ecx, byte ptr ds:[si].SectorsPerCluster
        xor     edx,edx
        div     ecx
        cmp     eax, 4087
        jae     if20
        stc
        jmp     short if30
if20:
        clc
if30:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        ret
.8086
IsFat12 endp

Free    EQU     512-($-Start)
if Free lt 0
        %out FATAL PROBLEM: FAT-specific startup code is greater than
        %out 512 bytes.  Fix it!
        .err
endif



RealStart:
;
; we are completely done with the boot sector, we can party on it's memory as we like.
; set up the stack
;
        mov     ax,StackSeg
        mov     ss,ax
        xor     sp,sp

        mov     ax,cs
        mov     ds,ax
        mov     es,ax

;
; save setupldr data
;
        mov     Preserve, dl

; move ourselves from 2000:0000 to 1000:0000, one paragraph at a time.

        mov     ax, BiosChkDestSeg
        mov     es, ax
        mov     dx, MaxCodeSize
        cld
Again1:
        xor     di, di
        xor     si, si
        mov     cx, 10h
        rep     movsb
        mov     ax, ds
        inc     ax
        mov     ds, ax
        mov     ax, es
        inc     ax
        mov     es, ax
        dec     dx
        jnz     Again1
        mov     ax, BiosChkDestSeg
        mov     ds, ax
        mov     es, ax
        JMPFAR  Continue1, BiosChkDestSeg

Continue1:

; insert your BIOS check code here
; instead of a real BIOS check we will check if the user holds down CTRL.
; If yes, we will behave like BIOS check failed

        mov     ah,02h
        int     16h
        and     al,00000100b
        jz      MoveSetupLdr

; at this point, the BIOS check failed. You can add whatever code you want here
; to give a message or to make the computer crash. If you don't do anything, the
; code will jump to 2000:0000 so an infinite loop is going to happen.
        jmp     Continue2

MoveSetupLdr:
; move Setupldr code from 2000+MaxCodeSize:0000 to 2000:0000, one paragraph at a time.

        push    ds
        push    es
        mov     ax, SetupLdrDestSeg
        mov     es, ax
        add     ax, MaxCodeSize
        mov     ds, ax
        mov     dx, MaxSetupLdrSize
        cld
Again2:
        xor     di, di
        xor     si, si
        mov     cx, 10h
        rep     movsb
        mov     ax, ds
        inc     ax
        mov     ds, ax
        mov     ax, es
        inc     ax
        mov     es, ax
        dec     dx
        jnz     Again2
        pop     es
        pop     ds

Continue2:
        mov     dl, Preserve
        JMPFAR  0,SetupLdrDestSeg

Preserve                db      ?

.errnz  ($-_BiosChk) GT (MaxCodeSize*16 - 2)    ;FATAL: BiosChk code is too large

        org     MaxCodeSize*16 - 2
        db      55h,0aah


CODE ENDS
END  START
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\data.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    data.cpp

Abstract:

    Contains registry "Data" abstraction
    implementation
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)
    
--*/


#include "Data.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//
// this class basically converts these variable types to a BYTE pointer
// so the info can be stored in the registry
// 
// Arguments:
//  b - data in BYTE stream.  OPTIONAL
//  d - data as a DWORD.  OPTIONAL
//  t - data in TCHAR stream.  OPTIONAL
//  flag - which data type is valid?
//  bSize - if data is in BYTE stream this must have the length of the stream.
//
Data::Data(
    IN PBYTE b, 
    IN DWORD d, 
    IN PCTSTR t, 
    IN DWORD flag, 
    IN int bSize)
{
	DWORD fourthbyte = 4278190080;
	DWORD thirdbyte = 16711680;
	DWORD secondbyte = 65280;
	DWORD firstbyte = 255;
	PCTSTR ptr;

	pByte = b;
	dword = d;
	pTchar = t;
	nFlags = flag;
	size = -1;

	switch (nFlags) {
    	case (1):
    		size = bSize;
    		break;

    	case (2):
    		if ( pByte = new BYTE[4] ){
    		    size = 4;
    		    pByte[3] = (BYTE)((dword & fourthbyte) >> 24);
    		    pByte[2] = (BYTE)((dword & thirdbyte) >> 16);
    		    pByte[1] = (BYTE)((dword & secondbyte) >> 8);
    		    pByte[0] = (BYTE)(dword & firstbyte);
            }
    		break;
    	
        case (4):
    		size = wcslen(t)+1;
    		ptr = t+size;
    		
    		while(*ptr!='\0') {
    			size += wcslen(ptr)+1;
    			ptr = t+size;
    		}
    		
    		size *= 2;
    		size += 2;

    	case (3):
    		if (size == -1) {
    		    size = (wcslen(t)*2)+2;
            }    		    
            
            if ( pByte = new BYTE[size] ) {
    		    for (int x=0;x<((size/2)-1);x++) {
    			    pByte[x*2] = (BYTE)(pTchar[x] & firstbyte);
    			    pByte[1+(x*2)] = (BYTE)((pTchar[x] & secondbyte) >> 8);
    		    }
    		    
    		    pByte[size-1] = pByte[size-2] = '\0';
            }
    		break;

        default:    		
            break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\buildhive.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    buildhive.h

Abstract:

    Contains macros, type and function declarations
    used by buildhive.cpp
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)

    
--*/


#pragma once

#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <iostream>
#include <list>
#include <tchar.h>
#include <string>
#include <setupapi.hpp>

//
// Macros
//
#define ELEMENT_COUNT(x) (sizeof(x)/sizeof((x)[0]))

//
// forward declarations
//
class File;

//
// Types
//
typedef std::list<PCTSTR> StringList;
typedef std::list<File*>  FileList;
typedef std::list<HINF>   HandleList;

//
// constants
//
const DWORD errFILE_LOCKED	 =	10000001;
const DWORD errBAD_FLAGS	 =	10000002;
const DWORD errFILE_NOT_FOUND=	10000003;
const DWORD errGENERAL_ERROR =	10000004;
const DWORD errOUT_OF_MEMORY =  10000005;

//
// Prototypes
//
PCTSTR
Error(
    VOID
    );
    
BOOL
SetPrivilege(
    IN HANDLE hToken,
    IN LPCTSTR PriviledgeName,
    IN BOOL Set);

INT
ShowProgramUsage(
    VOID
    );
    

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\data.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    data.h

Abstract:

    Contains registry "Data" abstraction
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)

    
--*/

#pragma once

#include <windows.h>

//
// Registry data abstraction
//
class Data{
public:
    //
    // member functions
    //
	Data(PBYTE b,DWORD d, PCTSTR t, DWORD flag, int bSize);
	virtual ~Data(){}

	PBYTE GetData() { return pByte; }
	int Sizeof() const { return size; }

private:
    //
    // data members
    //
	PBYTE   pByte;
	DWORD   dword;
	PCTSTR  pTchar;
	DWORD   nFlags;
	int     size;	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\msginc.h ===
//
// Global variables required to format message using GetFormattedMessage(..)
// from libmsg.lib
//
extern HMODULE ThisModule;
extern WCHAR Message[4096];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\regwriter.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    RegWriter.h

Abstract:

    Contains the registry writer abstraction
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)
    
--*/

#pragma once

#include <windows.h>
#include <stdio.h>
#include "Data.h"

//
// Registry writer abstraction
//
class RegWriter{
public:
	RegWriter(){}
	~RegWriter();

    //
    // member functions
    //
	DWORD Init(int LUID, PCTSTR target);
	DWORD Load(PCTSTR Key, PCTSTR fileName);
	DWORD Save(PCTSTR Key, PCTSTR fileName);	
	DWORD Write(PCTSTR Root, PCTSTR Key, PCTSTR Value, DWORD flag, Data* data);

	DWORD Delete(
	    PCTSTR Root, 
	    PCTSTR Key, 
	    PCTSTR Value);
	
private:	    
    //
    // data members
    //
	TCHAR root[MAX_PATH];
	HKEY key;
	int luid;

    //
    // static data members
    //
	static int    ctr;
    static TCHAR  Namespace[64];    // to hold a GUID
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\regwriter.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    RegWriter.h

Abstract:

    Contains the registry writer abstraction
    implementation
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)
    
--*/

#include "RegWriter.h"
#include "buildhive.h"
#include "Data.h"
#include <shlwapi.h>
#include "msginc.h"
#include <libmsg.h>
#include "msg.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//
// Macro definitions
//
#define AS(x) ( sizeof( (x) ) / sizeof( (x[0]) ) )

//
// static data initilization
//
int RegWriter::ctr = 0;
TCHAR RegWriter::Namespace[64] = {0};

//
// Initializes a new subkey for this regwriter
//
// Arguments:
//  LUID is the name of the subkey, all LUID's must be unique
//  target is the name of the hive file to load into the key.  
//  If it is null an empty key is created
//
DWORD RegWriter::Init(
    IN int LUID,
    PCTSTR target
    ) 
{
    DWORD dwRet;
    TCHAR buf[10];

    //
    // initialize the namespace, if needed
    //
    if (0 == Namespace[0]) {
        GUID  guid = {0};
        
        if (CoCreateGuid(&guid) != S_OK) {
            return ERROR_FUNCTION_FAILED;
        }

        swprintf(Namespace, 
            L"bldhives.exe{%08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X}\\",
            guid.Data1,
            guid.Data2,
            guid.Data3,
            guid.Data4[0],
            guid.Data4[1],
            guid.Data4[2],
            guid.Data4[3],
            guid.Data4[4],
            guid.Data4[5],
            guid.Data4[6],
            guid.Data4[7]);
    }

    wcscpy(root, Namespace);

    luid = LUID;

    //
    // if this is the first time, load the root key
    //
    if (!ctr) {
        dwRet = RegLoadKey(HKEY_USERS, root, L".\\nothing");
        
        if (dwRet !=ERROR_SUCCESS) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_ERROR_LOADING_EMPTY_KEY,
                                        dwRet) );
        }           
    }

    //
    // create root key for this regwriter (subkey of dummy) if it is for a new file
    //
    if (!target) {
            wcscat(root, _itow(luid,buf,10));

            dwRet = RegCreateKeyEx(HKEY_USERS, root, 0, 0, 0, KEY_ALL_ACCESS, 0, &key, 0); 

            if (dwRet !=ERROR_SUCCESS) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_ERROR_LOADING_ROOT_KEY,
                                            dwRet) );
            }

            RegCloseKey(key);
    } else {
            //
            // otherwise load existing hive into subkey of dummy
            //
            wcscat(root, _itow(luid,buf,10));
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_LOADING_HIVE,
                                        target) );

            dwRet = Load(L"", target);

            if (dwRet !=ERROR_SUCCESS) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_ERROR_LOADING_ROOT_KEY,
                                            dwRet) );
            }           
    }

    ctr++;

    return ERROR_SUCCESS;
}


RegWriter::~RegWriter()
{
    DWORD dwRet;

    ctr--;

    if (!ctr) {
        //
        // unload everything from the registry
        //
        dwRet = RegUnLoadKey(HKEY_USERS, Namespace);

        if (dwRet !=ERROR_SUCCESS) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_DECONSTRUCTOR_UNLOAD,
                                        dwRet) );
        }                       

        //
        // delete the files created when we made the empty root key
        //
        HANDLE Handle = CreateFile(L".\\nothing",
                            DELETE,
                            FILE_SHARE_DELETE,
                            0,
                            OPEN_EXISTING,
                            0,
                            0);
                            
        if (Handle !=INVALID_HANDLE_VALUE) { 
            DeleteFile(L".\\nothing"); 
            CloseHandle(Handle); 
        } else {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_EMPTY_HIVE_DELETE_FAILED) );
        }

        Handle = CreateFile(L".\\nothing.LOG",
                    DELETE,
                    FILE_SHARE_DELETE,
                    0,
                    OPEN_EXISTING,
                    0,
                    0);
                    
        if (Handle !=INVALID_HANDLE_VALUE) { 
            DeleteFile(L".\\nothing.LOG"); 
            CloseHandle(Handle);
        } else {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_EMPTY_HIVE_LOG_DELETE_FAILED) );
        }            
    }
}

//
// Writes data to a subkey of this regwriter's root
//
// Arguments:
//  Root - ignored
//  Key - the subkey to store the data in
//  Value - the value to store the data in
//  flag - registry flag describing the data - REG_SZ, REG_DWORD, etc..
//  data - a data object containing the information to be written to the subkey
//
DWORD RegWriter::Write(
    IN PCTSTR Root,
    IN PCTSTR Key,
    IN PCTSTR Value,
    IN DWORD flag,
    IN Data* data) 
{
    HKEY key;
    DWORD dwRet;
    TCHAR full[1024] = {0};
    
    wcsncpy(full, root, AS(full) - 1);
    wcsncpy(full + wcslen(full), Key, AS(full) - wcslen(full) - 1);

    //
    // open a key and set its value
    //
    dwRet = RegCreateKeyEx(HKEY_USERS, full, 0, 0, 0, KEY_WRITE, 0, &key, 0);
    
    if (dwRet !=ERROR_SUCCESS) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_CREATE_KEY,
                                    dwRet) );
        return dwRet;
    }
    
    if ((data) && (data->GetData())) {
        dwRet = RegSetValueEx(key, Value, 0, flag,data->GetData(), data->Sizeof());

        if (dwRet != ERROR_SUCCESS) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_SET_KEY,
                                        dwRet) );
            RegCloseKey(key);
            
            return dwRet;
        }
    } else if (Value) {
        dwRet = RegSetValueEx(key, Value, 0, flag, 0, 0);   
        
        if (dwRet !=ERROR_SUCCESS) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_SET_KEY2,
                                        dwRet) );
            RegCloseKey(key);
            
            return dwRet;
        }
    }
    
    RegCloseKey(key);

    return ERROR_SUCCESS;
}

//
// Saves a subkey to disk
//
// Arguments:
//  Key - the subkey to be saved
//  fileName - the file to save the information to.
//
DWORD RegWriter::Save(
    PCTSTR Key,
    PCTSTR fileName
    ) 
{
    DWORD dwRet = 0;
    HKEY key;
    TCHAR full[1024] = {0};

    wcsncpy(full, root, AS(full) - 1);
    wcsncpy(full + wcslen(full), Key, AS(full) - wcslen(full) - 1);

    //
    // save a key to file
    //
    dwRet = RegCreateKeyEx(HKEY_USERS,full,0,0,0,KEY_READ,0,&key,0);

    if (dwRet != ERROR_SUCCESS) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_CREATE_KEY,
                                    dwRet) );

        return dwRet;
    }

    dwRet = RegSaveKey(key,fileName,0);

    if (dwRet != ERROR_SUCCESS) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_SAVE_KEY,
                                    dwRet) );
        RegCloseKey(key);

        return dwRet;
    }

    RegCloseKey(key);

    return dwRet;
}

//
// Loads information from a hive file to a subkey.
// 
// Arguments :
//  Key - subkey to write the information to
//  fileName - full path and file name of the hive file to be loaded.
//
DWORD RegWriter::Load(PCTSTR Key, PCTSTR fileName) {
    DWORD dwRet = 0;
    TCHAR full[1024] = {0};
    
    wcsncpy(full, root, AS(full) - 1);
    wcsncpy(full + wcslen(full), Key, AS(full) - wcslen(full) - 1);

    //
    // load data in from a hive
    //
    dwRet = RegCreateKeyEx(HKEY_USERS,full,0,0,0,KEY_ALL_ACCESS,0,&key,0);
    
    if (dwRet != ERROR_SUCCESS) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_ERROR_CREATE_KEY,
                                    dwRet,
                                    root,
                                    full,
                                    fileName) );
        
        return dwRet;
    }

    dwRet = RegRestoreKey(key,fileName,0);
    
    if (dwRet != ERROR_SUCCESS) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_ERROR_RESTORE_KEY,
                                    dwRet,
                                    root,
                                    full,
                                    fileName) );
        RegCloseKey(key);
        
        return dwRet;
    }

    dwRet = RegFlushKey(key);
    
    if (dwRet != ERROR_SUCCESS) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_ERROR_FLUSH_KEY,
                                    dwRet,
                                    root,
                                    full,
                                    fileName) );
        RegCloseKey(key);
        
        return dwRet;
    }

    RegCloseKey(key);

    return dwRet;
}   

DWORD 
RegWriter::Delete(
    PCTSTR CurrentRoot, 
    PCTSTR Key, 
    PCTSTR Value OPTIONAL
    )
/*++

Routine Description:

    Deletes the given key / value underneath the key

Arguments:

    CurrentRoot - The Root key (ignored for the time being)

    Key - The key to delete or key containing the value to delete

    Value - The value to delete

Return Value:

    Appropriate WIN32 error code

--*/    
{
    DWORD Result = ERROR_INVALID_PARAMETER;

    if (CurrentRoot && Key) {
        DWORD BufferLength = (_tcslen(root) + _tcslen(Key) + _tcslen(root));
        PTSTR Buffer;

        if (Value) {
            BufferLength += _tcslen(Value);;            
        }

        BufferLength += sizeof(TCHAR);  // for null
        BufferLength = sizeof(TCHAR) * BufferLength;

        Buffer = new TCHAR[BufferLength];

        if (Buffer) {
            _tcscpy(Buffer, root);
            _tcscat(Buffer, Key);

            if (Value) {
                Result = SHDeleteValue(HKEY_USERS, 
                            Buffer,
                            Value);
            } else {
                Result = SHDeleteKey(HKEY_USERS,
                            Buffer);
            }

            delete []Buffer;
        } else {
            Result = ERROR_OUTOFMEMORY;
        }            
    }   

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\file.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    file.cpp

Abstract:

    Contains the input file abstraction
    implementation
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)
    
--*/

#include <stdio.h>
#include "File.h"
#include "msginc.h"

//
// static data member initialization
//
TCHAR File::targetDirectory[1024] = {0};
FileList File::files;
int File::ctr = 0;

//
// constant strings
//
const std::wstring INTL_INF_FILENAME = TEXT("intl.inf");
const std::wstring FONT_INF_FILENAME = TEXT("font.inf");
const std::wstring REGIONAL_SECTION_NAME = TEXT("regionalsettings");
const std::wstring LANGUAGE_GROUP_KEY = TEXT("languagegroup");
const std::wstring LANGUAGE_KEY = TEXT("language");
const std::wstring REGMAPPER_SECTION_NAME = TEXT("registrymapper");
const std::wstring LANGGROUP_SECTION_PREFIX = TEXT("lg_install_");
const std::wstring DEFAULT_LANGGROUP_NAME = TEXT("lg_install_1");
const std::wstring ADDREG_KEY = TEXT("addreg");
const std::wstring LOCALES_SECTION_NAME = TEXT("locales");
const std::wstring FONT_CP_REGSECTION_FMT_STR = TEXT("font.cp%s.%d");
const std::wstring CCS_SOURCE_KEY = TEXT("currentcontrolset");
const std::wstring CCS_TARGET_KEY = TEXT("ControlSet001");

//
// other constant values
//
const DWORD LANG_GROUP1_INDEX = 2;
const DWORD OEM_CP_INDEX = 1;
const DWORD DEFAULT_FONT_SIZE = 96;

//
// Set the target file and intialize the registry writer
// The luid makes sure each file gets a different registry key
//
// Arguments:
//  pszTargetfile - file name (without path) that this File will be saved to.
//  bModify - T - load the targetfile and modify it.  F - create new file
//
File::File(
    IN PCTSTR pszTargetFile, 
    IN bool bModify
    )
{
    luid = ctr;
    ctr++;

    targetFile = pszTargetFile;
    modify = bModify;

    wcscpy(wKey,L"\\");

    if (!modify) {
        regWriter.Init(luid,0);
    } else {
        wstring full = targetDirectory;

        full += targetFile;
        regWriter.Init(luid, full.c_str());
    }

    //
    // by default no registry mapping
    //
    SetRegistryMapper(NULL);
}

//
// Destructor
//
File::~File()
{
    // TBD : clean up the memory allocated    
}

//
// Add a section from an .inf file into the 'to do' list 
//
// Arguments:
//  fileName - path and name of the .inf file 
//  section - name of the section in the .inf to be added
//  action - What to do with the section - Add, Delete, Etc.. (see process sections for list)
//
void File::AddInfSection(
    IN PCTSTR fileName, 
    IN PCTSTR section, 
    IN PCTSTR action,
    IN bool Prepend 
    ) 
{
    hFile = SetupOpenInfFile(fileName, 0, INF_STYLE_WIN4, 0);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        throw new W32Error();
    }       

    if (Prepend) {
        handleList.push_front(hFile);
        infList.push_front(action);
        infList.push_front(section);
    } else {
        handleList.push_back(hFile);

        //
        // NOTE the order of addition
        //
        infList.push_back(section);
        infList.push_back(action);
    }   
}


//
// Sets the directory the target file will be stored in
//
// Arguments:
//  section - section in the .inf containing the directory
//  h - handle to the .inf file with the directory
//
DWORD File::SetDirectory(
    IN PCTSTR section,
    HINF h) 
{
    INFCONTEXT ic,ic2;

    if (!(SetupFindFirstLine(h, section, 0, &ic))) {
        throw new W32Error();
    }
    
    memcpy(&ic2, &ic, sizeof(ic));

    ic2.Line = 0;
    
    if (!(SetupGetStringField(&ic2, 1, targetDirectory, ELEMENT_COUNT(targetDirectory), 0))) {
        throw new W32Error();
    }

    int len = wcslen(targetDirectory);
    
    if (len && targetDirectory[len - 1] != L'\\') {
        targetDirectory[len] = L'\\';
        targetDirectory[len + 1] = UNICODE_NULL;
    }

    return ERROR_SUCCESS;
}

//
// Save information from the registry to file and 
// delete the registry keys (happens in the regwriter deconstructor)
//
DWORD File::Cleanup() {
    FileList::iterator i;

    File::SaveAll();

    while(files.size()!=0) {
        i = files.begin();
        delete (*i);
        files.pop_front();
    }
    
    return ERROR_SUCCESS;
}

//
// Load existing registry hive into the registry, then add new keys to it
//
// Arguments:
//  section - section containing the keys to be added
//  h - handle to the .inf containing section
//
DWORD File::AddRegExisting(
    IN PCTSTR lpszSection,
    HINF h) 
{
    INFCONTEXT ic,ic2;
    int fields,lines,curLine,curField;
    File* curFile;

    if (!(SetupFindFirstLine(h, lpszSection, 0, &ic))) {
        return ERROR_SUCCESS;
    }
    
    memcpy(&ic2,&ic,sizeof(ic));

    lines = SetupGetLineCount(h, lpszSection);
    
    if (lines != -1) {
        for (curLine=0;curLine<lines;curLine++) {
            ic2.Line = curLine;
            fields = SetupGetFieldCount(&ic2);

            if (fields == 0) {
                continue;
            }               

            TCHAR *target = new TCHAR[1024];

            SetupGetStringField(&ic2, 0, target, 1024, 0);
            curFile = GetFile(target, true);
            
            for(curField=1; curField < fields; curField += 2) {
                TCHAR *section = new TCHAR[1024],*inf = new TCHAR[1024];
                
                SetupGetStringField(&ic2, curField, inf, 1024, 0);
                SetupGetStringField(&ic2, curField + 1, section, 1024, 0);
                curFile->AddInfSection(inf, section, L"AddReg");
            }

                if (curFile->ProcessSections()) {
                        _putws(GetFormattedMessage( ThisModule,
                                                    FALSE,
                                                    Message,
                                                    sizeof(Message)/sizeof(Message[0]),
                                                    MSG_ERROR_IN_LINE,
                                                    target) );
                }
        }
    }

    return ERROR_SUCCESS;
}

//
// Load existing registry hive into the registry, then delete new keys from it
//
// Arguments:
//  section - section containing the keys to be deleted
//  h - handle to the .inf containing section
//
DWORD 
File::DelRegExisting(
    PCTSTR lpszSection,
    HINF h) 
{
    INFCONTEXT ic,ic2;
    int fields,lines,curLine,curField;
    File* curFile;

    if (!(SetupFindFirstLine(h,lpszSection,0,&ic))) {
        return ERROR_SUCCESS;
    }
    
    memcpy(&ic2, &ic, sizeof(ic));

    lines = SetupGetLineCount(h, lpszSection);
    
    if (lines!=-1) {
        for (curLine=0;curLine<lines;curLine++) {
            ic2.Line = curLine;
            fields = SetupGetFieldCount(&ic2);

            if (fields == 0) {
                continue;
            }                               

            TCHAR *target = new TCHAR[1024];
            SetupGetStringField(&ic2,0,target,1024,0);

            //
            // got the target file, now do it
            //
            curFile = GetFile(target,true);
            
            for(curField=1;curField<fields;curField+=2) {
                TCHAR *section = new TCHAR[1024],*inf = new TCHAR[1024];
                SetupGetStringField(&ic2,curField,inf,1024,0);
                SetupGetStringField(&ic2,curField+1,section,1024,0);
                curFile->AddInfSection(inf,section,L"DelReg");
            }

            if (curFile->ProcessSections()) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_ERROR_IN_LINE,
                                            target) );
            }
        }
    }

    return 0;
}

//
// Load information from a .inf file into the registry
//
// Arguments:
//   section - section containing the keys to be added
//   h - handle to the .inf containing section
//
DWORD File::AddRegNew(
    PCTSTR lpszSection,
    HINF h) 
{
    INFCONTEXT ic,ic2;
    int fields,lines,curLine,curField;
    File* curFile;

    if (!(SetupFindFirstLine(h, lpszSection, 0, &ic))) {
        return ERROR_SUCCESS;
    }
    
    memcpy(&ic2, &ic, sizeof(ic));

    lines = SetupGetLineCount(h,lpszSection);
    
    if (lines!=-1) {
        for (curLine=0;curLine<lines;curLine++) {
            ic2.Line = curLine;
            fields = SetupGetFieldCount(&ic2);
            if (fields==0) continue;

            TCHAR *target = new TCHAR[1024];
            SetupGetStringField(&ic2,0,target,1024,0);

            //
            // got the target file, now do it
            //
            curFile = GetFile(target,false);
            
            for(curField=1;curField<fields;curField+=2) {
                TCHAR *section = new TCHAR[1024],*inf = new TCHAR[1024];

                SetupGetStringField(&ic2, curField, inf, 1024, 0);
                SetupGetStringField(&ic2, curField + 1, section, 1024, 0);
                
                curFile->AddInfSection(inf,section,L"AddReg");
            }

            if (curFile->ProcessSections()) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_ERROR_IN_PROCESS_SECTIONS) );
            }
        }
    }

    return ERROR_SUCCESS;
}


//
// Adds an .inf section (probably [AddReg]) to the registry
//
// Arguments:
//  pszSection - section containing the keys to be added
//  hInfFile - handle to the .inf containing section
//
DWORD
File::AddSection(
    PCTSTR pszSection,
    HINF hInfFile
    ) 
{
    INFCONTEXT ic,ic2;
    int nRet = 0;
    long nLines,curLine;
    TCHAR Buffer[1024],Root[1024],Subkey[1024],Value[1024],SubkeyFinal[1024];
    DWORD flags = 0,dwCount;
    BYTE* b;TCHAR* t;DWORD d,f;
    int bSize = 0;

    // cout << "AddSection : " << pszSection << endl;

    nLines = SetupGetLineCount(hInfFile,pszSection);

    if (!nLines) {
        //
        // there are no lines in the section
        //
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_EMPTY_ADDREG_SECTION,
                                    pszSection) );
        return ERROR_SUCCESS;
    }
    
    if (!(SetupFindFirstLine(hInfFile,pszSection,0,&ic))) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_FIND_FIRST_LINE_FAILED,
                                    pszSection,
                                    Error()) );
        throw errGENERAL_ERROR;
    }
    
    memcpy(&ic2, &ic, sizeof(ic));

    //
    // get all the parameters, key, value, type, flags
    //
    for (curLine=0;curLine<nLines;curLine++) {
        bool IsSystemHive = false;
        
        ic2.Line = curLine;
        dwCount = SetupGetFieldCount(&ic2);

        b = 0;
        t = 0;
        d = f = 0;
        bSize = 0;
        
        if (dwCount > 3) {
            if (!(SetupGetStringField(&ic2, 4, Buffer, ELEMENT_COUNT(Buffer), 0))) {
                _putws( GetFormattedMessage( ThisModule,
                                             FALSE,
                                             Message,
                                             sizeof(Message)/sizeof(Message[0]),
                                             MSG_SETUPGETSTRINGFIELD_FAILED,
                                             pszSection,
                                             Error()) );
                    
                throw errGENERAL_ERROR;
            }
            
            if ((flags = GetFlags(Buffer)) == errBAD_FLAGS) {
                if (!(SetupGetStringField(&ic2, 2, Subkey, ELEMENT_COUNT(Subkey), 0))) {                    
                        _putws( GetFormattedMessage(ThisModule,
                                                    FALSE,
                                                    Message,
                                                    sizeof(Message)/sizeof(Message[0]),
                                                    MSG_SETUPGETSTRINGFIELD_FAILED,
                                                    pszSection,
                                                    Error()) );

                        throw errGENERAL_ERROR;
                }
                
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_BAD_REG_FLAGS,
                                            pszSection,
                                            Subkey) );
                    
                throw errBAD_FLAGS;
            }
            
            if (flags == FLG_ADDREG_KEYONLY) {
                dwCount = 2;
            }               

            if (dwCount > 4) { 
                if (!(flags ^ REG_BINARY)) {
                    SetupGetBinaryField(&ic2,5,0,0,&f);
                    b = new BYTE[f];
                    bSize = f;
                    SetupGetBinaryField(&ic2,5,b,f,0);
                    f = 1;      
                } else if (!(flags ^ REG_DWORD)) {
                    SetupGetIntField(&ic2,5,(int*)&d);
                    f = 2;
                } else if (flags ^ FLG_ADDREG_KEYONLY) {
                    DWORD length;
                    SetupGetStringField(&ic2,5,0,0,&length);
                    t = new TCHAR[2048];
                    SetupGetStringField(&ic2,5,t,length,0);
                    
                    if (flags==REG_MULTI_SZ) { 
                        for (int field = 6;field<=dwCount;field++) {
                            t[length-1] = '\0';
                            SetupGetStringField(&ic2,field,0,0,&f);
                            SetupGetStringField(&ic2,field,t+length,f,&f);
                            length += f;
                        }
                        
                        t[length-1] = '\0';
                        t[length] = '\0';
                        f = 4;
                    } else {
                        f = 3;
                    }                       
                }
            }
        }
        
        if (dwCount > 2) {
            if (!(SetupGetStringField(&ic2, 3, Value, ELEMENT_COUNT(Value), 0))) {
                _putws(GetFormattedMessage( ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_SETUPGETSTRINGFIELD_FAILED,
                                            pszSection,
                                            Error()) );
                throw errGENERAL_ERROR;
            }
        }
        
        if (dwCount > 1) {
            if (!(SetupGetStringField(&ic2, 2, Subkey, ELEMENT_COUNT(Subkey), 0))) {
                _putws(GetFormattedMessage( ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_SETUPGETSTRINGFIELD_FAILED,
                                            pszSection,
                                            Error()) );
                throw errGENERAL_ERROR;
            }
        }

        RegWriter *CurrRegWriter = &regWriter;
        
        if (dwCount > 0) {
            if (!(SetupGetStringField(&ic2, 1, Root, ELEMENT_COUNT(Root), 0))) {
                _putws(GetFormattedMessage( ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_SETUPGETSTRINGFIELD_FAILED,
                                            pszSection,
                                            Error()) );
                throw errGENERAL_ERROR;
            }

            std::wstring RegFileSubKey = Subkey;

            //
            // Map the registry if needed
            //
            RegistryMapper *RegMapper = GetRegistryMapper();

            if (RegMapper && RegFileSubKey.length()) {
                std::wstring::size_type SlashPos = RegFileSubKey.find(L'\\');

                if (SlashPos != RegFileSubKey.npos) {
                    std::wstring KeyName = Root;
                    KeyName += TEXT("\\") + RegFileSubKey.substr(0, SlashPos);

                    _wcslwr((PWSTR)KeyName.c_str());

                    std::wstring RegistryName;

                    //
                    // get the file that this registry entry is mapped to
                    // and get its regwriter to flush the current registry
                    // entry
                    //
                    if (RegMapper->GetMappedRegistry(KeyName, RegistryName)) {
                        File *CurrFile = GetFile(RegistryName.c_str(), true);

                        if (CurrFile) {
                            //std::cout << "Mapping to " << RegistryName << std::endl;
                            CurrRegWriter = &(CurrFile->GetRegWriter());
                        }                       
                    }
                }
            }
            
            //
            // Adjust Subkey if necessary:
            // HKCR is a link to Software\Classes.
            // Anything stored in Software or System shouldn't have SOFTWARE or SYSTEM 
            // as part of the subkey.
            //
            if (!wcscmp(Root, L"HKCR")) {
                TCHAR temp[1024];
                
                wcscpy(temp, L"Classes\\");
                wcscat(temp, Subkey);
                wcscpy(Subkey, temp);
            }
            
            if (!wcscmp(Root, L"HKLM")) {
                TCHAR temp[1024];
                
                if (Subkey[8] == '\\') {
                    wcscpy(temp, Subkey);
                    temp[8] = '\0';
                    
                    if (!_wcsicmp(temp, L"SOFTWARE")) {
                        wcscpy(Subkey, temp+9);
                    }                                                
                } else if (Subkey[6]=='\\') {
                    wcscpy(temp, Subkey);
                    temp[6] = '\0';
                    
                    if (!_wcsicmp(temp, L"SYSTEM")) {
                        wcscpy(Subkey, temp+7);
                        IsSystemHive = true;
                    }                        
                }
            }
        }

        wcscpy(SubkeyFinal, wKey);
        wcscat(SubkeyFinal, Subkey);

        //
        // Do we need to map CCS to CCS01 ?
        //
        // NOTE : Might want to extend this to generically map
        // any subkey.
        //
        if (IsSystemHive) {
            std::wstring CCSKey = SubkeyFinal;
            
            _wcslwr((PWSTR)CCSKey.c_str());

            PWSTR CurrentControlSet = wcsstr((PWSTR)CCSKey.c_str(),
                                        (PWSTR)CCS_SOURCE_KEY.c_str());

            if (CurrentControlSet) {
                PWSTR RemainingPart = CurrentControlSet + CCS_SOURCE_KEY.length();              
                size_t CharsToSkip = CurrentControlSet - CCSKey.c_str();

                wcscpy(SubkeyFinal + CharsToSkip, (PWSTR)CCS_TARGET_KEY.c_str());
                wcscat(SubkeyFinal, RemainingPart);

                //std::cout << SubkeyFinal << std::endl;
            }
        }
            
        //
        // if there's a value
        //
        if (dwCount > 2) {
            CurrRegWriter->Write(Root, SubkeyFinal, Value, flags, new Data(b,d,t,f,bSize));
        } else {
            CurrRegWriter->Write(Root,SubkeyFinal, 0, 0, 0);
        }                    
    }
    
    return ERROR_SUCCESS;
}

DWORD 
File::DelSection(
    PCTSTR pszSection,
    HINF hInfFile
    ) 
{
    INFCONTEXT ic,ic2;
    long nLines,curLine;
    TCHAR Buffer[1024],Root[1024],Subkey[1024],Value[1024],SubkeyFinal[1024];
    DWORD LastError = ERROR_SUCCESS, Result;

    //
    // get the section's first line context
    //
    if (!(SetupFindFirstLine(hInfFile,pszSection,0,&ic))) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_FIND_FIRST_LINE_FAILED,
                                    pszSection,
                                    Error()) );
        throw errGENERAL_ERROR;
    }

    //
    // replicate the context
    //
    memcpy(&ic2, &ic, sizeof(ic));

    //
    // How many lines are there in the section which we need to process ?
    //
    if (!(nLines = SetupGetLineCount(hInfFile,pszSection))) {
        _putws(GetFormattedMessage( ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_SETUPGETLINECOUNT_ERROR,
                                    pszSection,
                                    Error()) );
        throw errGENERAL_ERROR;
    }

    //
    // get all the parameters key & value
    //
    for (curLine=0;curLine<nLines;curLine++) {
        DWORD dwCount;
    
        ic2.Line = curLine;
        dwCount = SetupGetFieldCount(&ic2);     
        Value[0] = NULL;

        //
        // if value field is present then get it
        //
        if (dwCount > 2) {
            if (!(SetupGetStringField(&ic2, 3, Value, ELEMENT_COUNT(Value), 0))) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_SETUPGETSTRINGFIELD_FAILED,
                                            pszSection,
                                            Error()) );

                throw errGENERAL_ERROR;
            }
        }

        //
        // if key is present then get it
        //
        if (dwCount > 1) {
            if (!(SetupGetStringField(&ic2, 2, Subkey, ELEMENT_COUNT(Subkey), 0))) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_SETUPGETSTRINGFIELD_FAILED,
                                            pszSection,
                                            Error()) );

                throw errGENERAL_ERROR;
            }

            //
            // get the root key
            //
            if (!(SetupGetStringField(&ic2, 1, Root, ELEMENT_COUNT(Root), 0))) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_SETUPGETSTRINGFIELD_FAILED,
                                            pszSection,
                                            Error()) );

                throw errGENERAL_ERROR;
            }

            //
            // Adjust Subkey if necessary:
            // HKCR is a link to Software\Classes.
            // Anything stored in Software or System shouldn't have SOFTWARE or SYSTEM 
            // as part of the subkey.
            //
            if (!wcscmp(Root, L"HKCR")) {
                TCHAR temp[1024];
                
                wcscpy(temp, L"Classes\\");
                wcscat(temp, Subkey);
                wcscpy(Subkey, temp);
            }

            if (!wcscmp(Root, L"HKLM")) {
                TCHAR temp[1024];
                
                if (Subkey[8] == '\\') {
                    wcscpy(temp, Subkey);
                    temp[8] = '\0';

                    if (!_wcsicmp(temp, L"SOFTWARE")) {
                        wcscpy(Subkey, temp+9);
                    }                                                
                } else if (Subkey[6]=='\\') {
                    wcscpy(temp, Subkey);
                    temp[6] = '\0';

                    if (!_wcsicmp(temp, L"SYSTEM")) {
                        wcscpy(Subkey, temp+7);
                    }                        
                }
            }

            wcscpy(SubkeyFinal, wKey);
            wcscat(SubkeyFinal, Subkey);

            //
            // delete the entry
            //
            Result = regWriter.Delete(Root, SubkeyFinal, (Value[0] ? Value : NULL));

            if (ERROR_SUCCESS != Result) {
                LastError = Result;
            }
        }            
    }

    return LastError;
}


//
// Save the keys to files
//
DWORD File::SaveAll() {
    DWORD dwRet;
    FileList::iterator i = files.begin();
    TCHAR fullPath[1024];
    
    for (i = files.begin(); i!=files.end(); i++) {
        wcscpy(fullPath, targetDirectory);
        wcscat(fullPath, (*i)->targetFile.c_str());
        DeleteFile(fullPath);
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_SAVING_KEYS,
                                    fullPath) );
        
        if (dwRet = (*i)->regWriter.Save((*i)->wKey,fullPath)) {
            throw dwRet;
        }           
    }

    return ERROR_SUCCESS;
}

//
// Process the 'to do' list for this file
// This function goes through all the sections that have been 
// added to this file and calls the appropriate function to 
// deal with each one
//
DWORD File::ProcessSections() {
    DWORD dwRet = 0;
    StringList::iterator sSection,sAction;
    HandleList::iterator h = handleList.begin();
    StringList::iterator PrevSectionIter;
    HandleList::iterator PrevHandleIter;
    StringList::iterator PrevActionIter;

    sSection = sAction = infList.begin(); 
    sAction++;

    for (sSection = infList.begin();sSection!=infList.end();) {
        bool SectionProcessed = true;       

        if (!(wcscmp(L"AddReg", *sAction))) {
            if (dwRet = AddSection(*sSection, *h)) {
                throw dwRet;
            }
        } else if (!(wcscmp(L"DelReg", *sAction))) {
            if (dwRet = DelSection(*sSection, *h)) {
                throw dwRet;
            }
        } else if (!(wcscmp(L"AddRegNew", *sAction))) {
            if (dwRet = AddRegNew(*sSection, *h)) {
                throw dwRet;
            }
        } else if (!(wcscmp(L"AddRegExisting", *sAction))) {
            if (dwRet = AddRegExisting(*sSection, *h)) {
                throw dwRet;
            }
        } else if (!(wcscmp(L"DelRegExisting", *sAction))) {
            if (dwRet = DelRegExisting(*sSection, *h)) {
                throw dwRet;
            }
        } else if (!(wcscmp(L"SetDirectory", *sAction))) {
            if (dwRet = SetDirectory(*sSection, *h)) {
                throw dwRet;
            }
        } else {
            SectionProcessed = false;
        }

        //
        // remember current element so that we can delete it
        //
        if (SectionProcessed) {
            PrevSectionIter = sSection;
            PrevHandleIter = h;
            PrevActionIter = sAction;
        }            

        //
        // get hold of the next entry to process
        //
        sSection++;
        sSection++;
        sAction++;
        sAction++;
        h++;

        //
        // remove processed elements
        //
        if (SectionProcessed) {            
            infList.erase(PrevSectionIter);
            infList.erase(PrevActionIter);
            handleList.erase(PrevHandleIter);
        }            
    }

    return ERROR_SUCCESS;
}

DWORD 
File::GetFlags(
    PCTSTR FlagStr
    ) 
/*++

Routine Description:

    Converts the given string representation of flags into proper
    registery DWORD format

Arguments:

    FlagStr : The flag represented in string format..

Return Value:

    Appropriate registry DWORD type if successful, otherwise REG_NONE

--*/

{
    DWORD Flags = REG_NONE;
    
    if (FlagStr) {    
        //
        // Check if the type if specified through string
        //
        if (!wcscmp(FlagStr, TEXT("REG_EXPAND_SZ"))) {
            Flags = REG_EXPAND_SZ; 
        } else if (!wcscmp(FlagStr, TEXT("REG_DWORD"))) {
            Flags = REG_DWORD; 
        } else if (!wcscmp(FlagStr, TEXT("REG_BINARY"))) {
            Flags = REG_BINARY;
        } else if (!wcscmp(FlagStr, TEXT("REG_MULTI_SZ"))) {
            Flags = REG_MULTI_SZ;
        } else if (!wcscmp(FlagStr, TEXT("REG_SZ"))) {
            Flags = REG_SZ;
        } else if (!wcscmp(FlagStr, TEXT(""))) {
            Flags = REG_SZ;
        } 

        //
        // if still the flags were not found then convert the flags
        // into a DWORD and then interpret it
        //
        if (Flags == REG_NONE) {
            PTSTR EndChar = NULL;
            DWORD FlagsValue = _tcstoul(FlagStr, &EndChar, 0);

            if (!errno) {                
                if ((FlagsValue & FLG_ADDREG_KEYONLY) == FLG_ADDREG_KEYONLY) {
                    Flags = FLG_ADDREG_KEYONLY;
                } else if (HIWORD(FlagsValue) == REG_BINARY) {
                    Flags = REG_BINARY;
                } else if ((FlagsValue & FLG_ADDREG_TYPE_EXPAND_SZ) == FLG_ADDREG_TYPE_EXPAND_SZ) {
                    Flags = REG_EXPAND_SZ;
                } else if ((FlagsValue & FLG_ADDREG_TYPE_DWORD) == FLG_ADDREG_TYPE_DWORD) {
                    Flags = REG_DWORD;
                } else if ((FlagsValue & FLG_ADDREG_TYPE_BINARY) == FLG_ADDREG_TYPE_BINARY) {
                    Flags = REG_BINARY;
                } else if ((FlagsValue & FLG_ADDREG_TYPE_MULTI_SZ) == FLG_ADDREG_TYPE_MULTI_SZ) {
                    Flags = REG_MULTI_SZ;
                } else if ((FlagsValue & FLG_ADDREG_TYPE_SZ) == FLG_ADDREG_TYPE_SZ) {
                    Flags = REG_SZ;
                }                        
            }                
        }            
    }
    
    return Flags;
}

// 
// Either get pointer to existing file object or create new one
//
// Arguments:
//  fileName - name (w/o path) of target file
//  modify - T - load and modify an existing hive.  F - Create new hive
//
File* File::GetFile(
    PCTSTR fileName,
    bool modify) 
{
    FileList::iterator i;

    for (i = files.begin(); i!=files.end(); i++) {
        if (!(wcscmp(fileName, (*i)->GetTarget()))) {
            return *i;
        }           
    }

    files.insert(files.begin(), new File(fileName, modify));

    return (*(files.begin()));
}


void
File::ProcessNlsRegistryEntriesForSection(
    IN InfFileW &ConfigInf,
    IN InfFileW &IntlInf,
    IN InfFileW &FontInf,
    IN const std::wstring &SectionName
    )
/*++

Routine Description:

    Given the configuration inf, intl.inf & font.inf files
    processes the given section name entries for registry
    changes.

Arguments:

    ConfigInf - reference to config.inf InfFile object

    IntlInf - reference to intl.inf InfFile object

    FontInf - reference to font.inf InfFile object

    SectionName - name of the section to process

Return Value:

    None, throws appropriate exception.

--*/
{
    //std::cout << "Processing : " << SectionName << std::endl;
    
    //
    // iterate through all the addreg sections calling
    // AddSection(...) 
    //
    std::wstring LangSectionName = SectionName;

    _wcslwr((PWSTR)LangSectionName.c_str());

    //
    // Is the section present in intl.inf ?
    //
    Section<WCHAR> *LangSection = IntlInf.GetSection(LangSectionName);
    bool InFontInf = false;

    if (!LangSection) {
        //
        // Is the section present in font.inf ?
        //
        LangSection = FontInf.GetSection(LangSectionName);        
        InFontInf = true;
    }

    if (!LangSection) {
        throw new InvalidInfSection<WCHAR>(LangSectionName,
                        IntlInf.GetName());           
    }

    Section<WCHAR>::Iterator Iter = LangSection->begin();
    SectionValues<WCHAR> *CurrValue;
    Section<WCHAR> *AddRegSection = NULL;

    //
    // go through each addreg section entry in the multivalue list
    // and process each section.
    //

    while (!Iter.end()) {
        CurrValue = *Iter;
        
        if (CurrValue) {
            //std::cout << CurrValue->GetName() << std::endl;

            if (_wcsicmp(CurrValue->GetName().c_str(),
                    ADDREG_KEY.c_str()) == 0) {
                DWORD ValueCount = CurrValue->Count();

                for (DWORD Index = 0; Index < ValueCount; Index++) {
                    std::wstring Value = CurrValue->GetValue(Index);
                    HINF InfHandle = NULL;

                    _wcslwr((PWSTR)Value.c_str());

                    if (!InFontInf) {
                        InfHandle = (HINF)IntlInf.GetInfHandle();
                        AddRegSection = IntlInf.GetSection(Value);
                    }                        

                    if (!AddRegSection || InFontInf) {
                        InfHandle = (HINF)FontInf.GetInfHandle();
                        AddRegSection = FontInf.GetSection(Value);                        
                    }

                    if (!AddRegSection || (InfHandle == NULL)) {
                        throw new InvalidInfSection<WCHAR>(Value,
                                        IntlInf.GetName());
                    }

                    //
                    // process the AddReg section entries
                    //
                    // std::cout << "Processing AddReg : " << Value << std::endl;

                    DWORD Result = AddSection(Value.c_str(),
                                        InfHandle);

                    if (ERROR_SUCCESS != Result) {
                        throw new W32Error(Result);
                    }
                }
            }                    
        }        
        
        Iter++;
    }
}


void
File::ProcessNlsRegistryEntriesForLanguage(
    IN InfFileW &ConfigInf,
    IN InfFileW &IntlInf,
    IN InfFileW &FontInf,
    IN const std::wstring &Language
    )
/*++

Routine Description:

    Processes the registry sections for the given Language (locale Id)

Arguments:

    ConfigInf - reference to config.inf InfFile object

    IntlInf - reference to intl.inf InfFile object

    FontInf - reference to font.inf InfFile object

    Language - locale ID of the language to process (e.g 0x411 for JPN)

Return Value:

    None, throws appropriate exception.

--*/
{
    //
    // get the language section
    //
    WCHAR   LanguageIdStr[64];
    PWSTR   EndPtr;
    DWORD   LanguageId;

    LanguageId = wcstoul(Language.c_str(), &EndPtr, 16);
    swprintf(LanguageIdStr, L"%08x", LanguageId);
    _wcslwr(LanguageIdStr);

    std::wstring LangSectionName = LanguageIdStr;        

    ProcessNlsRegistryEntriesForSection(ConfigInf,
            IntlInf,
            FontInf,
            LangSectionName);    
}


void
File::ProcessNlsRegistryEntriesForLangGroup(
    IN InfFileW &ConfigInf,
    IN InfFileW &IntlInf,
    IN InfFileW &FontInf,
    IN const std::wstring &LangGroupIndex
    )
/*++

/*++

Routine Description:

    Processes the registry sections for the given Language group

Arguments:

    ConfigInf - reference to config.inf InfFile object

    IntlInf - reference to intl.inf InfFile object

    FontInf - reference to font.inf InfFile object

    LangGroupIndex - language group index (like 1, 7, 9 etc)

Return Value:

    None, throws appropriate exception.

--*/
{
    //
    // get the language group section
    //
    std::wstring LangGroupName = LANGGROUP_SECTION_PREFIX + LangGroupIndex;
    
    //
    // iterate through all the addreg sections calling
    // AddSection(...) 
    //
    _wcslwr((PWSTR)LangGroupName.c_str());

    ProcessNlsRegistryEntriesForSection(ConfigInf,
            IntlInf,
            FontInf,
            LangGroupName);    
}

void
File::ProcessNlsRegistryEntries(
    void
    )
/*++

Routine Description:

    Top level method which munges intl.inf, font.inf and
    config.inf to do the required registry modifications 
    to install a language.

    config.inf's regionalsettings section controls the
    behavior of this function for e.g. 

    [regionalsettings]
    languagegroup=9
    language=0x411

    will do the necessary registry processing for language 
    group 9 and language group 7 (since 0x411 belongs to
    language group 7). After processing the language
    groups it sets the registry to make the requested
    lanaguage active (0x411 in this case). Also processes
    the font.inf for appropriate language group & language
    font entries.

Arguments:

    None.

Return Value:

    None, throws appropriate exception.

--*/
{
    DWORD Result = ERROR_CAN_NOT_COMPLETE;

    try {
        std::wstring    IntlInfName = TEXT(".\\") + INTL_INF_FILENAME;
        std::wstring    FontInfName = TEXT(".\\") + FONT_INF_FILENAME;

        //
        // open the required inf files
        //
        InfFileW    ConfigInf(targetFile);
        InfFileW    IntlInf(IntlInfName);
        InfFileW    FontInf(FontInfName);

        //
        // get hold of [regionalsettings] section
        //
        Section<WCHAR>  *RegionalSection = ConfigInf.GetSection(REGIONAL_SECTION_NAME);
        
        if (!RegionalSection) {
            throw new InvalidInfSection<WCHAR>(REGIONAL_SECTION_NAME,
                            targetFile);
        }

        //
        // get hold of the [registrymapper] section
        //
        Section<WCHAR>  *RegMapperSection = ConfigInf.GetSection(REGMAPPER_SECTION_NAME);
        
        if (!RegMapperSection) {
            throw new InvalidInfSection<WCHAR>(REGMAPPER_SECTION_NAME,
                            targetFile);
        }

        //
        // if [languagegroup] section is present the get hold of it also
        //
        SectionValues<WCHAR> *LangGroups;

        try {
            LangGroups = &(RegionalSection->GetValue(LANGUAGE_GROUP_KEY));                
        } catch (...) {
            LangGroups = NULL;
        }

        //
        // get hold of the active languauge 
        //
        SectionValues<WCHAR> &Language = RegionalSection->GetValue(LANGUAGE_KEY);
        ULONG LangGroupCount = LangGroups ? LangGroups->Count() : 0;                

        RegistryMapper RegMapper;
        RegistryMapper *OldMapper;

        //
        // initialize the registry mapper map table
        //
        RegMapper.AddSection(*RegMapperSection);

        //std::cout << RegMapper;

        //
        // make our registry mapper active
        //
        OldMapper = SetRegistryMapper(&RegMapper);

        std::map< std::wstring, std::wstring > RegSectionsToProcess;


        //
        // process each language group specified
        //
        for (ULONG Index = 0; Index < LangGroupCount; Index++) {
            //
            // get the language group section
            //
            std::wstring LangGroupName = LANGGROUP_SECTION_PREFIX;

            LangGroupName += LangGroups->GetValue(Index);

            // std::cout << LangGroupName << std::endl;
            
            _wcslwr((PWSTR)LangGroupName.c_str());

            //
            // if the section is not present then add it
            //
            if (RegSectionsToProcess.find(LangGroupName) == RegSectionsToProcess.end()) {
                // std::cout << "Adding : " << LangGroupName << std::endl;
                RegSectionsToProcess[LangGroupName] = LangGroupName;
            }            
        }

        //
        // get the language section
        //
        WCHAR   LanguageIdStr[64];
        PWSTR   EndPtr;
        DWORD   LanguageId;

        LanguageId = wcstoul(Language.GetValue(0).c_str(), &EndPtr, 16);
        swprintf(LanguageIdStr, L"%08x", LanguageId);
        _wcslwr(LanguageIdStr);

        std::wstring LangSectionName = LanguageIdStr;        

        RegSectionsToProcess[LangSectionName] = LangSectionName;

        //
        // make sure the required language groups for this
        // language are also processed
        //
        Section<WCHAR> *LocaleSection = IntlInf.GetSection(LOCALES_SECTION_NAME);

        if (!LocaleSection) {
            throw new InvalidInfSection<WCHAR>(LOCALES_SECTION_NAME,
                            IntlInf.GetName());
        }

        SectionValues<WCHAR> &LocaleValues = LocaleSection->GetValue(LangSectionName);            
        
        std::wstring NeededLangGroup = LANGGROUP_SECTION_PREFIX + LocaleValues.GetValue(LANG_GROUP1_INDEX);

        RegSectionsToProcess[NeededLangGroup] = NeededLangGroup;

        //
        // add the font registry entries also
        //
        WCHAR   FontSectionName[MAX_PATH];

        swprintf(FontSectionName, 
            FONT_CP_REGSECTION_FMT_STR.c_str(), 
            LocaleValues.GetValue(OEM_CP_INDEX).c_str(),
            DEFAULT_FONT_SIZE);

        RegSectionsToProcess[FontSectionName] = FontSectionName;

        //
        // we always process lg_install_1 language group section
        //
        std::map< std::wstring, std::wstring >::iterator Iter = RegSectionsToProcess.find(DEFAULT_LANGGROUP_NAME);

        if (Iter == RegSectionsToProcess.end()) {
            RegSectionsToProcess[DEFAULT_LANGGROUP_NAME] = DEFAULT_LANGGROUP_NAME;
        }


        //
        // process each language group
        //
        Iter = RegSectionsToProcess.begin();

        while (Iter != RegSectionsToProcess.end()) {
            ProcessNlsRegistryEntriesForSection(ConfigInf,
                IntlInf,
                FontInf,
                (*Iter).first);
                
            Iter++;
        }

        //
        // reset the old registry mapper
        //
        SetRegistryMapper(OldMapper);

        Result = ERROR_SUCCESS;
    }
    catch (W32Exception<WCHAR> *Exp) {
        if (Exp) {
            Result = Exp->GetErrorCode();
            Exp->Dump(std::cout);
            delete Exp;
        }
    }
    catch (BaseException<WCHAR> *BaseExp) {
        if (BaseExp) {
            BaseExp->Dump(std::cout);
            delete BaseExp;
        }                
    }
    catch(...) {
    }
    
    if (ERROR_SUCCESS != Result) {
        throw new W32Error(Result);
    }
}


//
// RegistryMapper abstraction implementation
//
std::ostream& 
operator<<(
    std::ostream &os,
    RegistryMapper &rhs
    )
/*++

Routine Description:

    Helper method to dump registry mapper instance state

Arguments:

    os - reference to ostream instance 

    rhs - reference to registry mapper whose state needs to be dumped

Return Value:

    ostream reference for insertion of other outputs.

--*/
{
    std::map< std::wstring, std::wstring >::iterator Iter = rhs.KeyToRegistryMap.begin();

    while (Iter != rhs.KeyToRegistryMap.end()) {
        os << (*Iter).first << "=>" << (*Iter).second << std::endl;
        Iter++;
    }

    return os;
}

void
RegistryMapper::AddWorker(
    SectionValues<WCHAR> &Values,
    PVOID ContextData
    )
/*++

Routine Description:

    The worker routine which processes the section entries
    and adds them to the map table.

Arguments:

    Values - The section value entries which need to be processed

    ContextData - receives RegistryMapper instance pointer in disguise.

Return Value:

    None.

--*/
{
    RegistryMapper  *RegMap = (RegistryMapper *)ContextData;
    std::wstring Key = Values.GetName();
    std::wstring Value = Values.GetValue(0);

    _wcslwr((PWSTR)Key.c_str());
    RegMap->AddEntry(Key, Value);
}

void 
RegistryMapper::AddSection(
    Section<WCHAR> &MapSection
    )
/*++

Routine Description:

    Adds the given section entries to the internal map data structure

Arguments:

    MapSection - reference to Section object that needs to be processed    

Return Value:

    None.

--*/
{    
    MapSection.DoForEach(RegistryMapper::AddWorker,
                    this);

}

void
RegistryMapper::AddEntry(
        const std::wstring &Key,
        const std::wstring &Value
        )
/*++

Routine Description:

    Given a key and value adds it to the map maintained by
    the registry mapper.

Arguments:

    Key - The key i.e. fully qualified registry path name

    Value - The file that has the backing storage for this 
            key.

Return Value:

    None.

--*/
{
    KeyToRegistryMap[Key] = Value;
}

bool
RegistryMapper::GetMappedRegistry(
    const std::wstring &Key,
    std::wstring &Registry
    )
/*++

Routine Description:

    Given a Key returns the mapped backing store file name for
    it.

Arguments:

    Key - The key i.e. fully qualified registry path name

    Value - Place holder to receive the file that has the backing 
        storage for this key.

Return Value:

    true if a mapping exists otherwise false.

--*/
{
    bool Result = false;

    //std::cout << "GetMappedRegistry(" << Key << ")" << std::endl;

    std::wstring KeyLower = Key;
    _wcslwr((PWSTR)KeyLower.c_str());

    std::map< std::wstring, std::wstring >::iterator Iter = KeyToRegistryMap.find(KeyLower);

    if (Iter != KeyToRegistryMap.end()) {
        Registry = (*Iter).second;
        Result = true;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\buildhive\file.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    file.h

Abstract:

    Contains the input file abstraction
    
Author:

    Mike Cirello
    Vijay Jayaseelan (vijayj) 

Revision History:

    03 March 2001 :
    Rewamp the whole source to make it more maintainable
    (particularly readable)

    
--*/

#pragma once

#include "BuildHive.h"
#include "RegWriter.h"
#include <setupapi.hpp>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include "msg.h"
#include <libmsg.h>


using namespace std;

//
// Registry Mapper
//
class RegistryMapper {
public:
    //
    // member functions
    //
    void AddEntry(const std::wstring &Key, const std::wstring &Value);
    void AddSection(Section<WCHAR> &MapSection);    
    bool GetMappedRegistry(const std::wstring &Key, std::wstring &Registry);    
    static void AddWorker(SectionValues<WCHAR> &Values, PVOID ContextData);

    friend std::ostream& operator<<(std::ostream& os, RegistryMapper &rhs);

protected:
    //
    // data members
    //
    std::map< std::wstring, std::wstring >  KeyToRegistryMap;    
};

//
// Input file abstraction
//
class File {
public: 
    //
    // constructor & destructor
    //
	File(PCTSTR pszTargetFile, bool bModify);
	virtual ~File();

	//
	// member functions
	//
	void AddInfSection(PCTSTR fileName, PCTSTR section, PCTSTR action, bool Prepend = false);	
	void ProcessNlsRegistryEntries(void);
	DWORD ProcessSections();
	static DWORD SaveAll();
	DWORD Cleanup();

    //
    // inline methods
    //
	RegWriter& GetRegWriter() { return regWriter; }
	PCTSTR GetTarget() { return targetFile.c_str(); }

    RegistryMapper* SetRegistryMapper(RegistryMapper *RegMapper) {
        RegistryMapper *OldMapper = CurrentRegMapper;

        CurrentRegMapper = RegMapper;

        return OldMapper;
    }        

    RegistryMapper* GetRegistryMapper() { return CurrentRegMapper; }            

private:
    //
    // data members
    //
    wstring targetFile;
	bool modify;
	int luid;
	TCHAR wKey[1024];
	StringList infList;
	HandleList handleList;
	HINF hFile;
	SP_INF_INFORMATION infInfo;
	RegWriter regWriter;
	RegistryMapper *CurrentRegMapper;

    //
    // static data
    //
	static TCHAR targetDirectory[1024];
	static FileList files;	
	static int ctr;	

    //
    // methods
    //
	File*   GetFile(PCTSTR fileName,bool modify);
	DWORD   AddRegNew(PCTSTR section,HINF h);
	DWORD   AddRegExisting(PCTSTR section,HINF h);
	DWORD   DelRegExisting(PCTSTR section,HINF h);
	DWORD   AddSection(PCTSTR pszSection,HINF hInfFile);
	DWORD   DelSection(PCTSTR SectionName, HINF InfHandle);
	DWORD   SetDirectory(PCTSTR pszSection,HINF hInfFile);
	DWORD   GetFlags(PCTSTR buffer);

    void ProcessNlsRegistryEntriesForSection(InfFileW &ConfigInf, InfFileW &IntlInf,
                    InfFileW &FontInf,const std::wstring &SectionName);
    void ProcessNlsRegistryEntriesForLanguage(InfFileW &ConfigInf, InfFileW &IntlInf,
                    InfFileW &FontInf,const std::wstring &Language);
    void ProcessNlsRegistryEntriesForLangGroup(InfFileW &ConfigInf, InfFileW &IntlInf,
                    InfFileW &FontInf,const std::wstring &LanguageGroup);
};


//
// Determines if the given file (or directory) is present
//
template <class T>
bool
IsFilePresent(const std::basic_string<T> &FileName) {
    bool Result = false;

    if (sizeof(T) == sizeof(CHAR)) {
        Result = (::_access((PCSTR)FileName.c_str(), 0) == 0);
    } else {
        Result = (::_waccess((PCWSTR)FileName.c_str(), 0) == 0);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\cvtarea\cvtarea.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cvtarea.c

Abstract:

    Creates file on a volume of specified size (bytes, kb, mb, gb, %free, %dis) at 
    specified/random location contig/noncontig
    
Author:

    Raja Sivagaminathan  [sivaraja] 01/12/2000

Revision History:

--*/

#include "CVTAREA.H"


int _cdecl main(int argc, char *argv[])
{

	FILE *file;

	// Global initializations
	gpHeadNode = NULL;
	gpFATNodeCount = 0;
	
	if (!ProcessCommandLine(argc, argv))
	{
		return 1;
	}

	//
	// check how file name is supplied
	//
	if (gsFileParam[1] != ':')
	{
		gcDrive = GetCurrentDrive();
		if (!gcDrive)
		{
			Mes("Unable to get current drive\n");
			return 1;
		}
		if (gsFileParam[0] != '\\')
		{
			strcpy(gsFileName, "\\");
			if (!GetCurrentDirectory(gcDrive, gsCurrentDir))
			{
				Mes("Unable to get current directory.\n");
				return 1;
			}
			if (gsCurrentDir[0] != 0) // may be root directory
			{
				strcat(gsFileName, gsCurrentDir);
				if (gsCurrentDir[strlen(gsCurrentDir) - 1] != '\\')
				{
					strcat(gsFileName, "\\");
				}
			}
		}
		else
		{
			// so that the next strcat works fine
			gsFileName[0] = 0; 
		}
		strcat(gsFileName, gsFileParam);
	}
	else
	{
		gcDrive = gsFileParam[0];
		gcDrive = (BYTE) toupper((int) gcDrive);
		if (gcDrive < 'A' || gcDrive > 'Z')
		{
			Mes("Invalid drive name.\n");
			return 1;
		}
		if (gsFileParam[2] == '\\')
		{
			strcpy(gsFileName, gsFileParam+2);
		}
		else
		{
			strcpy(gsFileName, "\\");
			if (!GetCurrentDirectory(gcDrive, gsCurrentDir))
			{
				Mes("Unable to get current directory.\n");
				return 1;
			}
			if (gsCurrentDir[0] != 0) // may be root directory
			{
				strcat(gsFileName, gsCurrentDir);
				if (gsCurrentDir[strlen(gsCurrentDir) - 1] != '\\')
				{
					strcat(gsFileName, "\\");
				}
			}
			strcat(gsFileName, gsFileParam+2);
		}
	}

	if (gnDumpMode)
	{
		if (!LockVolume(gcDrive, READONLYLOCK))
		{
			Mes("Unable to lock volume\n");
			return 1;
		}
	
		if (!BuildDriveInfo(gcDrive, &gsDrvInfo))
		{
			return 1;
		}
		GetAllInfoOfFile(&gsDrvInfo, gsFileName, &gsFileLoc, &gsFileInfo);
		
		printf("Cluster allocation for %s\n\n", gsFileName);
		printf("Starting at:\tNumber of Clusters:\n\n");
		gnClusterFrom = gsFileLoc.StartCluster;
		gnClusterProgress = gnClusterFrom;		
		gnClustersCounted = 0;
		while(1)
		{
			gnClusterProgressPrev = gnClusterProgress;
			gnClusterProgress = FindNextCluster(&gsDrvInfo, gnClusterProgress);
			gnClustersCounted++;
			//
			// contigous ?
			//
			if (gnClusterProgress != gnClusterProgressPrev+1)
			{
				printf("%lu\t\t%lu\n", gnClusterFrom, gnClustersCounted);
				gnClustersCounted = 0;
				gnClusterFrom = gnClusterProgress;
			}
				
			if (gnClusterProgress >= GetFATEOF(&gsDrvInfo) - 7)
			{
				printf("EndOfFile\n");
				break;
			}
			if (gnClusterProgress > gsDrvInfo.TotalClusters || gnClusterProgress < 2)
			{
				Mes("FATAL ERROR : FAT is corrupt.\n");
				break;
			}
		}
		//
		// All done, unlock volume
		//
		if (!UnlockVolume(gcDrive))
		{                         
			Mes("WARNING : Unable to unlock volume\n");
			//return 1;
		}
	}
	else
	{
		if (gnFreeSpaceDumpMode)
		{
			if (!LockVolume(gcDrive, READONLYLOCK))
			{
				Mes("Unable to lock volume\n");
				return 1;
			}
		
			if (!BuildDriveInfo(gcDrive, &gsDrvInfo))
			{
				return 1;
			}

			printf("Free Clusters on Drive %c:\n\n", gcDrive);
			gnClustersCounted = 0;
			//
                        // locate first free cluster
			//
			gnClusterProgress = FindFreeCluster(&gsDrvInfo);
			if (!gnClusterProgress)
			{
				Mes("No free clusters found.\n");
				return 0;
			}
			printf("Starting at:\tNumber of Clusters:\n\n");
			for (;gnClusterProgress <= gsDrvInfo.TotalClusters; gnClusterProgress++)
			{       
				if (FindNextCluster(&gsDrvInfo, gnClusterProgress) == 0)
				{
					// if this is 0 then gnClusterFrom needs to be updated
					if (gnClustersCounted == 0)
					{
						gnClusterFrom = gnClusterProgress;
					}
					gnClustersCounted++;
				}
				else
				{
					if (gnClustersCounted)
					{
						printf("%lu\t\t%lu\n", gnClusterFrom, gnClustersCounted);
						gnClustersCounted = 0;
					}
				}
			}
			//
			// do we still have something to print?
			//
			if (gnClustersCounted)
			{
				printf("%lu\t\t%lu\n", gnClusterFrom, gnClustersCounted);
			}
			
			//
			// All done, unlock volume
			//
			if (!UnlockVolume(gcDrive))
			{                         
				Mes("WARNING : Unable to unlock volume\n");
				//return 1;
			}
		}
		else
		{			
			//
			// let DOS create a 0 length file
			//
			file = fopen(gsFileParam, "w+");
			if (!file)
			{
				Mes("Error creating file\n");
				return 1;
			}
			else
			{
				fclose(file);
			}
		
		
			if (!LockVolume(gcDrive, READWRITELOCK))
			{
				Mes("Unable to lock volume\n");
				return 1;
			}
		
			if (!BuildDriveInfo(gcDrive, &gsDrvInfo))
			{
				return 1;
			}
		
			GetAllInfoOfFile(&gsDrvInfo, gsFileName, &gsFileLoc, &gsFileInfo);
			if (gsFileLoc.Found != 1)
			{   
				Mes("FATAL ERROR : Unable to locate created file\n");
				return 1;
			}

			//
			// Do all the operations requested in command line parameters
			//
			
			if (gbValidateFirstClusterParam)
			{
				gnFirstCluster = ConvertClusterUnit(&gsDrvInfo);
				if (!gnFirstCluster)
				{
					DisplayUsage();
					return 0;
				}
			}
			
			Mes("Computing cluster requirement...\n");
			gnClustersRequired = GetClustersRequired(&gsDrvInfo);
			printf("Clusters Required : %lu\n", gnClustersRequired);
			
			//
			// Check if the file size will exceed DWORD (4GB)
			//
			
			if ((FOURGB / (gsDrvInfo.BytesPerSector * gsDrvInfo.SectorsPerCluster)) < gnClustersRequired)
			{
				Mes("*** WARNING: Clusters required exceed FAT32 file system limit. ***\n");
				gnClustersRequired = FOURGB / (gsDrvInfo.BytesPerSector * gsDrvInfo.SectorsPerCluster);
				printf("%lu clusters (= 4GB) will be allocated.\n", gnClustersRequired);
			}
			
			
			//
			// if Contigous clusters required make sure they are available
			//
			if (gnContig)
			{
				Mes("Finding contigous clusters...\n");
				gnClusterStart = GetContigousStart(&gsDrvInfo, gnClustersRequired);
                if (gnClusterStart == 0)
				{
					Mes("Unable to find contigous clusters\n");
					return 0;
				}
			}
			else
			{
				gnClusterStart = gnFirstCluster;
			}
			
			if (gnStrictLocation && gnClusterStart != gnFirstCluster)
			{
				Mes("Unable to allocate clusters at/from the requested location\n");
				return 1;
			}
			
			//
			// Ready to allocate clusters and set file information
			//
			Mes("Allocating clusters...\n");
            gnAllocated = OccupyClusters(&gsDrvInfo, gnClusterStart, gnClustersRequired);
            printf("%lu clusters allocated.\n", gnAllocated);
            Mes("Committing FAT Sectors...\n");
			CcCommitFATSectors(&gsDrvInfo);
			//
			// Now set file information
			//
			Mes("Setting file information...\n");
			gsFileInfo.StartCluster = gnClusterStart;
			if (gnSizeUnit)
			{
                gsFileInfo.Size = gnAllocated * gsDrvInfo.SectorsPerCluster * gsDrvInfo.BytesPerSector;
			}
			else
			{
                if (gnAllocated != gnClustersRequired)
                {
                    gsFileInfo.Size = gnAllocated * gsDrvInfo.SectorsPerCluster * gsDrvInfo.BytesPerSector;
                }
                else
                {
                    gsFileInfo.Size = gnSize;
                }
			}
			if (!SetFileInfo(&gsDrvInfo, &gsFileLoc, &gsFileInfo))
			{
				Mes("FATAL ERROR : Error setting file information\n");
				return 1;
			}
			CcCommitFATSectors(&gsDrvInfo);
			//
			// All done, unlock volume
			//
			if (!UnlockVolume(gcDrive))
			{                         
				Mes("WARNING : Unable to unlock volume\n");
				//return 1;
			}
//			DeallocateLRUMRUList();
//			DeallocateFATCacheTree(gpHeadNode);
			DeallocateFATCacheList();
			Mes("File created successfully.\n");
		}
	}
    return 0;
}

UINT16 ProcessCommandLine(int argc, char *argv[])
{   
	UINT16 ti, tn;
	char sStr[50];
	
	if (argc < 3)
	{
		DisplayUsage();
		return 0;
	}
	
	//
	// Get FileName
	//
	strcpy(gsFileParam, argv[1]);
	tn = strlen(gsFileParam);
	//
	// Do simple validation
	//
	for (ti = 0; ti < tn; ti++)
	{
		if (gsFileParam[ti] == '*' || gsFileParam[ti] == '?')
		{
			DisplayUsage();
			return 0;
		}
	}
	
	gnDumpMode = 0;
	gnFreeSpaceDumpMode = 0;
	
	//
	// Get Size
	//
	strcpy(sStr, argv[2]);
	if (stricmp(sStr, "/info") == 0)
	{
		gnDumpMode = 1;
		//
		// dont accept anyother parameter if /info is entered
		//
		if (argc > 3)
		{
			DisplayUsage();
			return 0;
		}
		else
		{
			return 1;
		}
	}
	else
	{
		if (stricmp(sStr, "/freespace") == 0)
		{
			gnFreeSpaceDumpMode = 1;
			if (argc > 3)
			{
				DisplayUsage();
				return 0;
			}
			else
			{
				if (strlen(gsFileParam) > 2 ||
					toupper(gsFileParam[0]) < 'A' || 
					toupper(gsFileParam[0]) > 'Z' || 
					gsFileParam[1] != ':')
				{
					DisplayUsage();
					return 0;
				}
				return 1;
			}
		}
	}
	if (!PureNumber(sStr))
	{
		DisplayUsage();
		return 0;
	}
	gnSize = (UINT32) atol(sStr);
	if (gnSize == 0)
	{
		DisplayUsage();
		return 0;
	}
	
	gnContig = 0;
	gnStrictLocation = 0;	
	gnSizeUnit = 0;
	gnClusterUnit = 0;
	gnFirstCluster = 0;
	gnClusterStart = 0;
	gbValidateFirstClusterParam = 0;
	for (ti = 3; ti < (UINT16) argc; ti++)
	{
		strcpy(sStr, argv[ti]);
		
		//
		// Check each argument if it qualifies and remember them in global variables
		//
		
		if (ti == 3)
		{
			if (stricmp(sStr, "KB") == 0)
			{
				gnSizeUnit = 1;
				continue;
			}
			else
			{
				if (stricmp(sStr, "MB") == 0)
				{
					gnSizeUnit = 2;
					continue;
				}
				else
				{
					if (stricmp(sStr, "GB") == 0)
					{
						gnSizeUnit = 3;
						continue;
					}
					else
					{
						if (stricmp(sStr, "%free") == 0)
						{
							gnSizeUnit = 4;
							continue;
						}
						else
						{
							if (stricmp(sStr, "%disk") == 0)
							{
								gnSizeUnit = 5;
								continue;
							}
						}
					}
				}
			}
		}

		if (stricmp(sStr, "/contig") == 0)
		{
			gnContig = 1;
			continue;
		}
		
		if (stricmp(sStr, "/firstcluster") == 0)
		{
			if ((UINT16) argc <= ti)
			{
				DisplayUsage();
				return 0;
			}
			else
			{
				// this parm must be a number
				strcpy(sStr, argv[ti+1]);
				if (!PureNumber(sStr))
				{
					DisplayUsage();
					return 0;
				}
				gnFirstCluster = atol(sStr);
				if (gnFirstCluster == 0)
				{
					DisplayUsage();
					return 0;
				}
				else
				{        
					gbValidateFirstClusterParam = 1;
					//
					// look for optional unit
					//
					if ((UINT16) argc > ti + 1)
					{
						strcpy(sStr, argv[ti+2]);
						if (stricmp(sStr, "KB") == 0 || 
								stricmp(sStr, "MB") == 0 || 
								stricmp(sStr, "GB") == 0 ||
								stricmp(sStr, "/strictlocation") == 0)
						{
							if (stricmp(sStr, "KB") == 0)
							{
								gnClusterUnit = 1;
							}
							else
							{
								if (stricmp(sStr, "MB") == 0)
								{
									gnClusterUnit = 2;
								}
								else
								{
									if (stricmp(sStr, "GB") == 0)
									{
										Mes("gnClusterUnit is 3\n");
										gnClusterUnit = 3;
									}
									else
									{
										if (stricmp(sStr, "/strictlocation") == 0)
										{
											gnStrictLocation = 1;
										}
									}
								}
							}

							// if cluster unit AND /strictlocation specified
							if (!gnStrictLocation && (UINT16) argc > ti + 2)
							{
								strcpy(sStr, argv[ti+3]);
								if (stricmp(sStr, "/strictlocation") == 0)
								{
									gnStrictLocation = 1;
									ti+=3;
									continue;
								}
							}
							ti+=2;
							continue;
						}
					}
					ti++;
					continue;
				}
			}
		}
		
		// if it got here the command line is not recognized (junk parameter)
		DisplayUsage();
		return 0;		
	}
	
	return 1;
}

UINT16 PureNumber(char *sNumStr)
{
	UINT16 ti, tn;
	tn = strlen(sNumStr);
	for (ti = 0; ti < tn; ti++)
	{
		if (sNumStr[ti] < 48 || sNumStr[ti] > 57)
		{
			return 0;
		}
	}
	return 1;
}

void DisplayUsage(void)
{
	Mes("Invalid parameters\n");
	Mes("USAGE:\n\n");
	Mes("CVTAREA <filename> <size> (<units>) (/contig) \n\t\t(/firstcluster <cluster> (clusunits) (/strictlocation))\n\n");
	Mes("\t<filename> - is a filename.\n");
	Mes("\t<size> - is a 32 bit integer.\n");
	Mes("\t<units> - is a modifier for <size> valid options are \n\t\tKB, MB, GB, ");
	putchar(37);
	// if we dont seperate this, stupid thing comes up with unrecognized escape sequence
	Mes("disk and ");
	putchar(37);
	// if we dont seperate this, stupid thing comes up with floating point error because of %f
	Mes("free\n");
	Mes("\t/contig - the file must be created contiguously on disk.\n");
	Mes("\t/firstcluster - the first cluster at which the file shall be located.\n\n\n");
	Mes("CVTAREA <filename> </info>\n\n");
	Mes("\t<filename> - is a filename.\n");
	Mes("\t/info - dumps cluster numbers allocated for a given file\n\n\n");
	Mes("CVTAREA <drivename> </freespace>\n\n");
	Mes("\tdrivename - is a drive letter followed by : example C:\n");
	Mes("\t/freespace - dumps free space chunks\n");
	
}
void Mes(char *pMessage)
{
	printf(pMessage);
}

//
// Sector related functions
//

UINT16 LockVolume(BYTE nDrive, BYTE nMode)
{
	union _REGS inregs;
	union _REGS outregs;
	struct _SREGS segregs;

	// Lock volume
	outregs.x.cflag = 1;
	inregs.x.ax = 0x440d;
	inregs.h.bh = nMode;
	inregs.h.bl = nDrive - 64;
	inregs.h.ch = 8;
	inregs.h.cl = 0x4a;
	inregs.x.dx = 0;
	int86x(0x21, &inregs, &outregs, &segregs);
	if (outregs.x.cflag & 1)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}                                      

UINT16 UnlockVolume(BYTE nDrive)
{
	union _REGS inregs;
	union _REGS outregs;
	struct _SREGS segregs;

	// Lock volume
	outregs.x.cflag = 1;
	inregs.x.ax = 0x440d;
	inregs.h.bl = nDrive - 64;
	inregs.h.ch = 8;
	inregs.h.cl = 0x6a;
	int86x(0x21, &inregs, &outregs, &segregs);
	if (outregs.x.cflag & 1)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}

BYTE GetCurrentDrive(void)
{
	union _REGS inregs;
	union _REGS outregs;
	
	inregs.h.ah = 0x19;
	int86(0x21, &inregs, &outregs);
	if (outregs.x.cflag & 1)
	{
		return 0;
	}
	
    return outregs.h.al + 65;
}

BYTE GetCurrentDirectory(BYTE nDrive, BYTE *pBuffer)
{
	union _REGS inregs;
	union _REGS outregs;
	struct _SREGS segregs;
	
	outregs.x.cflag = 1;
	inregs.x.ax = 0x7147; // get current directory
	inregs.h.dl = nDrive - 64;
	segregs.ds = FP_SEG(pBuffer);
	inregs.x.si = FP_OFF(pBuffer);
	int86x(0x21, &inregs, &outregs, &segregs);
	if (outregs.x.cflag & 1)
	{
		// Try old method
		inregs.h.ah = 0x47;
		int86x(0x21, &inregs, &outregs, &segregs);
		if (outregs.x.cflag & 1)
		{
			return 0;
		}
	}
	return 1;
}

UINT16 ReadSector(BYTE nDrive, UINT32 nStartSector, UINT16 nCount, BYTE *pBuffer)
{
	BYTE DriveNum;
	union _REGS inregs;
	union _REGS outregs;
	struct _SREGS segregs;
	ABSPACKET AbsPacket, *pAbs;

	// Try int 21h 7305 first
	
    pAbs = &AbsPacket;
    
	// A: = 1, B: = 2, .....
	DriveNum = nDrive - 65;

	Tx.e.evx = 0;
	Tx.e.evx = nStartSector;

	AbsPacket.SectorLow = Tx.x.vx;
	AbsPacket.SectorHigh = Tx.x.xvx;
	AbsPacket.SectorCount = nCount;
	AbsPacket.BufferOffset = FP_OFF(pBuffer);
	AbsPacket.BufferSegment = FP_SEG(pBuffer);
	
	segregs.ds = FP_SEG(pAbs);
	segregs.es = FP_SEG(pAbs);
	inregs.x.bx = FP_OFF(pAbs);
	inregs.x.cx = 0xffff;
	inregs.h.dl = nDrive-64;
	inregs.x.ax = 0x7305;
	//
	// Read mode SI = 0
	//
	inregs.x.si = 0; 
	outregs.x.ax = 0;
	outregs.x.cflag = 0;
	int86x(0x21, &inregs, &outregs, &segregs);

	if (outregs.x.cflag & 0x1)
	{
		goto ErrorRead;
	}
	return 1;
ErrorRead:
	return 0;
}

UINT16 WriteSector(BYTE nDrive, UINT32 nStartSector, UINT16 nCount, BYTE *pBuffer)
{
	BYTE DriveNum;
	union _REGS inregs;
	union _REGS outregs;
	struct _SREGS segregs;
	ABSPACKET AbsPacket, *pAbs;

	// Try int 21h 7305 first
	
    pAbs = &AbsPacket;
    
	// A: = 1, B: = 2, .....
	DriveNum = nDrive - 65;

	Tx.e.evx = 0;
	Tx.e.evx = nStartSector;

	AbsPacket.SectorLow = Tx.x.vx;
	AbsPacket.SectorHigh = Tx.x.xvx;
	AbsPacket.SectorCount = nCount;
	AbsPacket.BufferOffset = FP_OFF(pBuffer);
	AbsPacket.BufferSegment = FP_SEG(pBuffer);
	
	segregs.ds = FP_SEG(pAbs);
	segregs.es = FP_SEG(pAbs);
	inregs.x.bx = FP_OFF(pAbs);
	inregs.x.cx = 0xffff;
	inregs.h.dl = nDrive-64;
	inregs.x.ax = 0x7305;
	//
	// Write mode SI != 0 (bit 1 set)
	//
	inregs.x.si = 1; 
	outregs.x.ax = 0;
	outregs.x.cflag = 0;
	int86x(0x21, &inregs, &outregs, &segregs);
	if (outregs.x.cflag & 0x1)
	{
		goto ErrorWrite;
	}
	return 1;
ErrorWrite:
	return 0;
}


//
// Boot related functions
//

UINT16 BuildDriveInfo(BYTE Drive, BPBINFO *pDrvInfo)
{
	BYTE *pSector;
        pSector = (BYTE *) malloc(1024);

	if (!pSector)
	{
		Mes("Memory allocation error\n");
		return 0;
	}

	//
	// Although FAT32 boot sector spans two sectors BPB is contained in the first sector
	// So we only read one sector
	//
	if (!ReadSector(Drive, 0, 1, pSector))
	{
		Mes("Unable to read boot sector\n");
		return 0;
	}

	if ((strncmp(pSector+54, "FAT16   ", 8) == 0) || strncmp(pSector+54, "FAT12   ", 8) == 0)
	{
		GetFATBPBInfo(pSector, pDrvInfo);
	}
	else
	{
		if (strncmp(pSector+82, "FAT32   ", 8) == 0)
		{
			GetFAT32BPBInfo(pSector, pDrvInfo);
		}
		else
		{
			Mes("Unsupported file system\n");
			return 0;
		}
	}

	free(pSector);	
	if (!pDrvInfo->ReliableInfo)
	{
		Mes("Drive is either corrupted or unable to get BPB Info\n");
		
	}
	pDrvInfo->Drive = Drive;
	return 1;
}

UINT16 GetFATBPBInfo(BYTE *pBootSector, BPBINFO *pDrvInfo)
{
	pDrvInfo->ReliableInfo = 0;
	if (pBootSector[510] != 0x55 || pBootSector[511] != 0xAA)
	{
		Mes("Invalid boot sector\n");
		return 0;
	}
	else
	{
		pDrvInfo->BytesPerSector = (pBootSector[0x0c] << 8) | pBootSector[0x0b];
		if (pDrvInfo->BytesPerSector == 0)		// Just be safe
		{
			Mes("Invalid boot sector\n");
			return 0;
		}
		pDrvInfo->SectorsPerCluster = pBootSector[0x0d];
		if (pDrvInfo->SectorsPerCluster == 0)	// Just be safe
		{
			Mes("Invalid boot sector\n");
			return 0;
		}
		pDrvInfo->ReservedBeforeFAT = (pBootSector[0x0f] << 8) | pBootSector[0x0e];
		pDrvInfo->FATCount = pBootSector[0x10];
		if (pDrvInfo->FATCount == 0)			// Just be safe
		{
			Mes("Invalid boot sector\n");
			return 0;
		}
		pDrvInfo->MaxRootDirEntries = (pBootSector[0x12] << 8) | pBootSector[0x11];
		pDrvInfo->TotalSectors = (pBootSector[0x14] << 8) | pBootSector[0x13];
		pDrvInfo->MediaID = pBootSector[0x15];
		pDrvInfo->SectorsPerFAT = (pBootSector[0x17] << 8) | pBootSector[0x16];
		if (pDrvInfo->SectorsPerFAT == 0)		// Just be safe
		{
			Mes("Invalid boot sector\n");
			return 0;
		}
		pDrvInfo->SectorsPerTrack = (pBootSector[0x19] << 8) | pBootSector[0x18];
		pDrvInfo->Heads = (pBootSector[0x1b] << 8) | pBootSector[0x1a];
		pDrvInfo->HiddenSectors = (pBootSector[0x1d] << 8) | pBootSector[0x1c];
		Rx.h.vl = pBootSector[0x20]; Rx.h.vh = pBootSector[0x21]; Rx.h.xvl = pBootSector[0x22];Rx.h.xvh = pBootSector[0x23];
		pDrvInfo->BigTotalSectors = Rx.e.evx;
		pDrvInfo->RootDirCluster = 0;

		//
		// The following informations are useful and are not directly from Boot sector
		//
		pDrvInfo->TotalRootDirSectors = ((pDrvInfo->MaxRootDirEntries * 32) / 512) + 1;
		if (((pDrvInfo->MaxRootDirEntries * 32) % 512) == 0)
		{
			pDrvInfo->TotalRootDirSectors--;
		}
		pDrvInfo->TotalSystemSectors = (UINT32)pDrvInfo->ReservedBeforeFAT + (UINT32)pDrvInfo->FATCount * (UINT32)pDrvInfo->SectorsPerFAT + (UINT32) pDrvInfo->TotalRootDirSectors;

		pDrvInfo->FirstRootDirSector = (UINT32)((UINT32)pDrvInfo->ReservedBeforeFAT + (UINT32)pDrvInfo->FATCount * (UINT32)pDrvInfo->SectorsPerFAT);

		//
		// If TotalSectors is zero then the actual total sectors value is in BigTotalSectors
		// and it means the drive is BIGDOS (> 32MB).
		//
		if (pDrvInfo->TotalSectors == 0) 
		{
			pDrvInfo->TotalClusters = ((pDrvInfo->BigTotalSectors - pDrvInfo->TotalSystemSectors) / pDrvInfo->SectorsPerCluster) + 2 - 1; // +2 Because clusters starts from 2
		}
		else
		{
			pDrvInfo->TotalClusters = ((pDrvInfo->TotalSectors - pDrvInfo->TotalSystemSectors) / pDrvInfo->SectorsPerCluster) + 2 - 1; // +2 because clusters starts from 2
		}
		//
		// Determine the fat type
		//
		if (pDrvInfo->TotalClusters <= 4096)
		{
			pDrvInfo->FATType = 12;
		}
		else
		{
			pDrvInfo->FATType = 16;
		}
	}
	
	//
	// Validate all the info above
	//
	if (pDrvInfo->FATCount == 2 && pDrvInfo->SectorsPerFAT != 0 &&
		pDrvInfo->SectorsPerCluster != 0 && pDrvInfo->BytesPerSector == 512 &&
		(pDrvInfo->TotalSectors != 0 || pDrvInfo->BigTotalSectors != 0) &&
		pDrvInfo->ReservedBeforeFAT != 0)
	{
		pDrvInfo->ReliableInfo = 1;
	}
	return 1;
}

UINT16 GetFAT32BPBInfo(BYTE *pBootSector, BPBINFO *pDrvInfo)
{
	pDrvInfo->ReliableInfo = 0;
	if (pBootSector[510] != 0x55 || pBootSector[511] != 0xAA)
	{
		Mes("Invalid boot sector\n");
		return 0;
	}
	else
	{
		//
		// Build the drive information now
		//
		pDrvInfo->BytesPerSector = (pBootSector[0x0c] << 8) | pBootSector[0x0b];
		pDrvInfo->SectorsPerCluster = pBootSector[0x0d];
		pDrvInfo->ReservedBeforeFAT = (pBootSector[0x0f] << 8) | pBootSector[0x0e];
		pDrvInfo->FATCount = pBootSector[0x10];
		pDrvInfo->MaxRootDirEntries = (pBootSector[0x12] << 8) | pBootSector[0x11];
		pDrvInfo->TotalSectors = 0;
		pDrvInfo->MediaID = pBootSector[0x15];
		pDrvInfo->SectorsPerTrack = (pBootSector[0x19] << 8) | pBootSector[0x18];
		pDrvInfo->Heads = (pBootSector[0x1b] << 8) | pBootSector[0x1a];
		Rx.h.vl = pBootSector[0x1c]; Rx.h.vh = pBootSector[0x1d]; Rx.h.xvl = pBootSector[0x1e];Rx.h.xvh = pBootSector[0x1f];
		pDrvInfo->HiddenSectors = Rx.e.evx;
		Rx.h.vl = pBootSector[0x20]; Rx.h.vh = pBootSector[0x21]; Rx.h.xvl = pBootSector[0x22];Rx.h.xvh = pBootSector[0x23];
		pDrvInfo->BigTotalSectors = Rx.e.evx;
		Rx.h.vl = pBootSector[0x24]; Rx.h.vh = pBootSector[0x25]; Rx.h.xvl = pBootSector[0x26];Rx.h.xvh = pBootSector[0x27];
		pDrvInfo->SectorsPerFAT = Rx.e.evx;
		Rx.h.vl = pBootSector[0x2c]; Rx.h.vh = pBootSector[0x2d]; Rx.h.xvl = pBootSector[0x2e];Rx.h.xvh = pBootSector[0x2f];
		pDrvInfo->RootDirCluster = Rx.e.evx;

		//
		// The following informations are useful and are not directly from the Boot sector
		//
		pDrvInfo->TotalSystemSectors = (UINT32)((UINT32)pDrvInfo->ReservedBeforeFAT + (UINT32)pDrvInfo->FATCount * (UINT32) pDrvInfo->SectorsPerFAT);
		pDrvInfo->FirstRootDirSector = (UINT32)((UINT32)pDrvInfo->TotalSystemSectors + (UINT32)(pDrvInfo->RootDirCluster - 2) * (UINT32)pDrvInfo->SectorsPerCluster + 1);
		pDrvInfo->TotalClusters = ((pDrvInfo->BigTotalSectors - pDrvInfo->TotalSystemSectors) / pDrvInfo->SectorsPerCluster) + 2 - 1; // +2 Because clusters starts from 2
		pDrvInfo->FATType = 32;
		//
		// Validate all the info above
		//
		if (pDrvInfo->FATCount == 2 && pDrvInfo->SectorsPerFAT != 0 &&
			pDrvInfo->SectorsPerCluster != 0 && pDrvInfo->BytesPerSector == 512 &&
			(pDrvInfo->TotalSectors != 0 || pDrvInfo->BigTotalSectors != 0) &&
			pDrvInfo->ReservedBeforeFAT != 0)
		{
			pDrvInfo->ReliableInfo = 1;
		}
	}
	return 1;
}


UINT16 AddNode(PNODE pNode)
{
	if (!pNode)
	{
		return 1;
	}
	if (!gpHeadNode)
	{
		gpHeadNode = pNode;
		gpTailNode = pNode;
		pNode->Back = NULL;
		pNode->Next = NULL;
	}
	else
	{
		pNode->Next = gpHeadNode;
		pNode->Back = NULL;
                gpHeadNode->Back = pNode;
		gpHeadNode = pNode;
	}
	return 1;
}

PNODE FindNode(UINT32 nSector)
{
	PNODE pNode;
	if (!gpHeadNode)
	{
		return NULL;
	}
	pNode = gpHeadNode;
	while (pNode)
	{
		if (pNode->Sector == nSector)
		{
			break;
		}
		pNode = pNode->Next;
	}
	return pNode;
}

PNODE RemoveNode(void)
{
	// Removes last node

	PNODE pNode;
	
	if (!gpTailNode)
	{
		return NULL;
	}
	
	pNode = gpTailNode;
	gpTailNode = pNode->Back;
	pNode->Back = NULL;
	if (gpTailNode)
	{
		gpTailNode->Next = NULL;
	}
	return pNode;
}


void DeallocateFATCacheList(void)
{
	PNODE pNode;
	
	while (gpHeadNode)
	{
		pNode = gpHeadNode;
		gpHeadNode = gpHeadNode->Next;
		free(pNode->Buffer);
		free(pNode);
	}
}
		

//
// Functions related to FAT caching
//

BYTE *CcReadFATSector(BPBINFO *pDrvInfo, UINT32 nFATSector)
{   
	// Locate nFATSector in the cache
	PNODE pNode;

	pNode = FindNode(nFATSector);
	if (!pNode)
	{
		//
		// If MAXCACHE reached use LRU MRU scheme
		//
		if (gpFATNodeCount < MAXCACHE)
		{
			pNode = malloc(sizeof(NODE)+5);
			if (!pNode)
			{
				return NULL;
			}
                        pNode->Buffer = malloc(512);
			if (!pNode->Buffer)
			{
				return NULL;
			}
			ReadSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + nFATSector, 1, pNode->Buffer);
			pNode->Sector = nFATSector;
			pNode->Dirty = 0;
			AddNode(pNode);
			gpFATNodeCount++;
		}
		else
		{
//          RemoveLRUMakeMRU(gpLRU->Node);
//			pNode = gpMRU->Node;
			pNode = RemoveNode();
			if (pNode->Dirty)
			{
				WriteSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + pNode->Sector, 1, pNode->Buffer);
				WriteSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + pDrvInfo->SectorsPerFAT + pNode->Sector, 1, pNode->Buffer);
			}
			pNode->Sector = nFATSector;
			ReadSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + nFATSector, 1, pNode->Buffer);
			AddNode(pNode);
		}
	}

	return pNode->Buffer;
}

UINT16 CcWriteFATSector(BPBINFO *pDrvInfo, UINT32 nFATSector)
{
	PNODE pNode;
	pNode = FindNode(nFATSector);
	if (!pNode)
	{
		// must be found, because every FAT node we write must gone thru CcReadFATSector first
		return 0;
	}
	else
	{
		pNode->Dirty = 1;
	}
}

void CcCommitFATSectors(BPBINFO *pDrvInfo)
{   
	PNODE pNode;
	if (!gpHeadNode)
	{
		return;
	}
	pNode = gpHeadNode;
	
	while (pNode)
	{
		if (pNode->Dirty)
		{
			// 1st FAT copy
			WriteSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + pNode->Sector, 1, pNode->Buffer);
			// 2nd FAT copy
			WriteSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + pDrvInfo->SectorsPerFAT + pNode->Sector, 1, pNode->Buffer);
			pNode->Dirty = 0;
		}
		pNode = pNode->Next;
	}
	return;
}
	
// 
// FAT related functions
//

UINT32 FindNextCluster(BPBINFO *pDrvInfo,UINT32 CurrentCluster)
{
	UINT32 ToRead;
	UINT32 SeekOffset;
	BYTE JustAByte;
	Rx.e.evx = 0;
	
	switch (pDrvInfo->FATType)
	{
	case 12:
		ToRead = (CurrentCluster*3/2)/512;
		PettyFATSector = CcReadFATSector(pDrvInfo, ToRead);
		//**ReadSector(DrvInfo->Drive, DrvInfo->ReservedBeforeFAT + ToRead, 1, (BYTE *) PettyFATSector);
		//
		// Go to that cluster location
		//
		SeekOffset = (CurrentCluster*3/2) % 512;
		if ((CurrentCluster % 2) == 0)  // if even
		{
			JustAByte = (BYTE) (PettyFATSector[SeekOffset+1] & 0x0f);
			Rx.h.vl = PettyFATSector[SeekOffset]; Rx.h.vh = JustAByte;
		}
		else // if cluster number is odd the calculation is different
		{
			JustAByte = (BYTE) (PettyFATSector[SeekOffset] & 0xf0);
			Rx.h.vl = JustAByte; Rx.h.vh = PettyFATSector[SeekOffset+1];
			Rx.x.vx >>= 4;
		}
		Rx.h.xvl = 0; Rx.h.xvh = 0;
		break;
	case 16:
		ToRead = CurrentCluster/256;    // 256 cells in a 16 bit FAT sector
		PettyFATSector = CcReadFATSector(pDrvInfo, ToRead);
		//**ReadSector(DrvInfo->Drive, DrvInfo->ReservedBeforeFAT + ToRead, 1, (BYTE *)PettyFATSector);
		//
		// Go to that Cluster location
		//
		SeekOffset = (CurrentCluster - (ToRead * 256)) * 2;
		Rx.h.vl = PettyFATSector[SeekOffset]; Rx.h.vh = PettyFATSector[SeekOffset+1];
		Rx.h.xvl = 0; Rx.h.xvh = 0;
		break;
	case 32:
		ToRead = CurrentCluster/128;    // 128 cells in a 32 bit FAT sector
		PettyFATSector = CcReadFATSector(pDrvInfo, ToRead);
		//**ReadSector(DrvInfo->Drive, DrvInfo->ReservedBeforeFAT + ToRead, 1, (BYTE *)PettyFATSector);
		//
		// Go to that Cluster location
		//
		SeekOffset = (CurrentCluster - (ToRead * 128)) * 4;
		Rx.h.vl = PettyFATSector[SeekOffset]; Rx.h.vh = PettyFATSector[SeekOffset+1];
		Rx.h.xvl = PettyFATSector[SeekOffset+2]; Rx.h.xvh = PettyFATSector[SeekOffset+3];
		break;
	default:
		Rx.e.evx = 0;
		break;
	}
	return Rx.e.evx;
}

UINT16 UpdateFATLocation(BPBINFO *pDrvInfo, UINT32 CurrentCluster,UINT32 PointingValue)
{
	UINT32 ToRead;
	UINT32 SeekOffset;

	if (CurrentCluster == 0 || CurrentCluster == 1 || CurrentCluster >= (GetFATEOF(pDrvInfo)-7)) 
	{
		return 0;
	}

	switch (pDrvInfo->FATType)
	{
	case 12:
		ToRead = (CurrentCluster*3/2)/512;
		PettyFATSector = CcReadFATSector(pDrvInfo, ToRead);
		//**ReadSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + ToRead, 1, PettyFATSector);

		//
		// Go to that location
		//
		SeekOffset = (CurrentCluster*3/2) % 512;			
		if ((CurrentCluster % 2) == 0) // if even
		{
			Rx.e.evx = 0;
			Rx.x.vx = (UINT16) PointingValue;
			PettyFATSector[SeekOffset+1] = (BYTE) (PettyFATSector[SeekOffset+1] & 0xf0);
			Rx.h.vh = (BYTE) (Rx.h.vh & 0x0f);
			PettyFATSector[SeekOffset+1] = PettyFATSector[SeekOffset+1] | Rx.h.vh;
			PettyFATSector[SeekOffset] = Rx.h.vl;
		}
		else // if cluster number is odd the calculation is different
		{
			Rx.e.evx = 0;
			Rx.x.vx = (UINT16) PointingValue;
			PettyFATSector[SeekOffset] = (BYTE)(PettyFATSector[SeekOffset] & 0x0f);
			Rx.h.vl = (BYTE) (Rx.h.vl & 0xf0);
			PettyFATSector[SeekOffset] = PettyFATSector[SeekOffset] | Rx.h.vl;
			PettyFATSector[SeekOffset+1] = Rx.h.vh;
		}
		break;
	case 16:
		ToRead = CurrentCluster/256;    // 256 cells in a 16 bit FAT sector
		PettyFATSector = CcReadFATSector(pDrvInfo, ToRead);
		//**ReadSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + ToRead, 1, PettyFATSector);
		//
		// Go to that location
		//
		SeekOffset = (CurrentCluster % 256) * 2;
		Rx.e.evx = 0;
		Rx.x.vx = (UINT16) PointingValue;
		PettyFATSector[SeekOffset] = Rx.h.vl;PettyFATSector[SeekOffset+1] = Rx.h.vh;
		break;
	case 32:
		ToRead = CurrentCluster/128;    // 128 cells in a 32 bit FAT sector
		PettyFATSector = CcReadFATSector(pDrvInfo, ToRead);
		//**ReadSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + ToRead, 1, PettyFATSector);
		//
		// Go to that location
		//
		SeekOffset = (CurrentCluster % 128) * 4;
		Rx.e.evx = 0;
		Rx.e.evx = PointingValue;
		PettyFATSector[SeekOffset] = Rx.h.vl; PettyFATSector[SeekOffset+1] = Rx.h.vh;
		PettyFATSector[SeekOffset+2] = Rx.h.xvl; PettyFATSector[SeekOffset+3] = Rx.h.xvh;
		break;
	default:
		return 0;
	}
	CcWriteFATSector(pDrvInfo, ToRead);
	//**Update FAT 1st Copy
	//WriteSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + ToRead, 1, PettyFATSector);
	// Update FAT 2nd Copy
	//**WriteSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + pDrvInfo->SectorsPerFAT + ToRead, 1, PettyFATSector);
	return 1;
}

UINT32 FindFreeCluster(BPBINFO *pDrvInfo)
{
	UINT32 ti, tj;
	UINT32 FreeCluster;
	UINT32 SeekOffset;
	
	if (pDrvInfo->FATType == 12)
	{ 
		//
		// Instead of messing up with FAT16 and FAT32's smooth operation use the slow method
		//
		for (ti = 2; ti <= pDrvInfo->TotalClusters; ti++)
		{
			//
			// this just aint gonna slow down things on a huge 2MB FAT12 partition
			//
			if (FindNextCluster(pDrvInfo, ti) == 0)
			{
				LastClusterAllocated = ti;
				return ti;
			}
		}
		return 0;
	}
	else
	{
		// ** this part was developed before FAT caching was implemented... and the purpose was
		// for better performance
		// But with FAT caching it is even better or no difference at all, so this part is left alone.


		//
		// Start looking from Cluster 2
		//
		FreeCluster = 2;
		for (ti = 1; ti <= pDrvInfo->SectorsPerFAT; ti++)
		{
			//**if (!ReadSector(pDrvInfo->Drive, pDrvInfo->ReservedBeforeFAT + ti-1, 1, PettyFATSector))
			PettyFATSector = CcReadFATSector(pDrvInfo, ti-1);
			if (!PettyFATSector)
			{
				return 0;
			}
			tj = 0;
			while (tj < 512)
			{
				switch (pDrvInfo->FATType)
				{
					case 16:
						SeekOffset = (FreeCluster * 2) % (UINT32) 512;
						if (PettyFATSector[SeekOffset] == 0 && PettyFATSector[SeekOffset+1] == 0)
						{
							LastClusterAllocated = FreeCluster;
							return FreeCluster;
						}
						tj += 2;
						break;
					case 32:
						SeekOffset = (FreeCluster * 4) % (UINT32) 512;
						if (PettyFATSector[SeekOffset] == 0 && PettyFATSector[SeekOffset+1] == 0
						   && PettyFATSector[SeekOffset+2] == 0 && PettyFATSector[SeekOffset+3] == 0)
						{
							LastClusterAllocated = FreeCluster;
							return FreeCluster;
						}
						tj += 4;
						break;
					default:
						return 0;
				}
				FreeCluster++;
				if (FreeCluster > pDrvInfo->TotalClusters)
				{
					return 0;
				}
			}
		}
		return 0;	
	}
}

UINT32 QFindFreeCluster(BPBINFO *pDrvInfo)
{
	// LastClusterAllocated is critical for this function to work fast.
	// It starts from LastClusterAllocated+1 to find a free cluster and calls
	// the regular FindFreeCluster if did not find a free cluster between
	// LastClusterAllocated+1 and TotalClusters
	UINT32 ti;
	UINT32 FreeCluster;
	FreeCluster = 0;
	for (ti = LastClusterAllocated+1; ti <= pDrvInfo->TotalClusters; ti++)
	{
		if (FindNextCluster(pDrvInfo, ti) == 0)
		{
			LastClusterAllocated = ti;
			return ti;
		}
	}
	if (FreeCluster == 0)
	{
		FreeCluster = FindFreeCluster(pDrvInfo);
	}
	return FreeCluster;
}


UINT32 GetFATEOF(BPBINFO *pDrvInfo)
{
	UINT32 FATEOF;
	switch (pDrvInfo->FATType)
	{
		case 12:
			FATEOF = 0x0fff;
			break;
		case 16:
			FATEOF = 0xffff;
			break;
		case 32:
			FATEOF = 0x0fffffff;
			break;
	}
	return FATEOF;
}

UINT32 GetFreeClusters(BPBINFO *pDrvInfo)
{
	UINT32 nCount;
	UINT32 ti;
	
	nCount = 0;
	for (ti = 2; ti <= pDrvInfo->TotalClusters; ti++)
	{
		if (FindNextCluster(pDrvInfo, ti) == 0)
		{
			nCount++;
		}
	}
	return nCount;
}

UINT32 ConvertClusterUnit(BPBINFO *pDrvInfo)
{
	//
	// one KB = 2 sectors, we use 2 to avoid get thru overflow as much as possible (although we have overflow check)
	// when gnClusterUnit is not 0, it means a start location from the beginning of the disk BY SIZE.
	// for example, if "/firstcluster 1 GB" is specified, it means start from a cluster after (skipping) 
	// 1 GB space from the beginning of the disk
	//

	UINT32 nFirstCluster;
	
	nFirstCluster = gnFirstCluster;
	
	switch (gnClusterUnit)
	{
	case 0:
		// do nothing
		break;
	case 1: // Start Cluster unit specified in KB
		if (nFirstCluster < 0x80000000) // overflow check
		{
			nFirstCluster = ((nFirstCluster * 2) / pDrvInfo->SectorsPerCluster) + 2;
		}
		else
		{
			nFirstCluster = 0;
		}
		break;
	case 2: // Start Cluster unit specified in MB
		if (nFirstCluster < 0x200000) // overflow check
		{
			nFirstCluster = ((nFirstCluster * 2 * 1024) / pDrvInfo->SectorsPerCluster) + 2;
		}
		else
		{
			nFirstCluster = 0;
		}
		break;
	case 3: // Start Cluster unit specified in GB
		if (nFirstCluster < 0x800) // overflow check
		{
			nFirstCluster = ((nFirstCluster * 2 * 1024 * 1024) / pDrvInfo->SectorsPerCluster) + 2;
		}
		else
		{
			nFirstCluster = 0;
		}
		break;
	default:
		// do nothing
		break;
	}
	if ((nFirstCluster > pDrvInfo->TotalClusters) || (nFirstCluster < 2))
	{
		nFirstCluster = 0;
	}
	return nFirstCluster;
}

UINT32 GetClustersRequired(BPBINFO *pDrvInfo)
{
	UINT32 nClustersRequired;
	UINT32 nDriveClusterSize;
	UINT32 tnSize;
	
	nDriveClusterSize = (UINT32) pDrvInfo->SectorsPerCluster * (UINT32) pDrvInfo->BytesPerSector;
	
	tnSize = gnSize;

	//
	// calcs looks vague, but we try to avoid as much overflow as possible
	//
	switch (gnSizeUnit)
	{
	case 0: //bytes
		nClustersRequired = tnSize / nDriveClusterSize;
		if (tnSize % nDriveClusterSize)
		{
			nClustersRequired++;
		}
		break;
	case 1: //KB
		if (nDriveClusterSize >= 1024)
		{
			nClustersRequired = tnSize / (nDriveClusterSize / 1024);
			if (tnSize % (nDriveClusterSize / 1024))
			{
				nClustersRequired++;
			}
		}
		else
		{
			// Here we go by sectors, still trying to avoid overflow
			tnSize = tnSize * 2; // sectors
			nClustersRequired = tnSize / pDrvInfo->SectorsPerCluster;
			if (tnSize % pDrvInfo->SectorsPerCluster)
			{
				nClustersRequired++;
			}
		}
		break;
	case 2: // MB
		if (nDriveClusterSize >= 1024)
		{
			tnSize = tnSize * 1024;
			nClustersRequired = tnSize / (nDriveClusterSize / 1024);
			if (tnSize % (nDriveClusterSize / 1024))
			{
				nClustersRequired++;
			}
		}
		else
		{
			tnSize = tnSize * 2 * 1024; //sectors
			nClustersRequired = tnSize / pDrvInfo->SectorsPerCluster;
			if (tnSize % pDrvInfo->SectorsPerCluster)
			{
				nClustersRequired++;
			}
		}			
		break;
	case 3: // GB
		if (nDriveClusterSize >= 1024)
		{
			tnSize = tnSize * 1024 * 1024;
			nClustersRequired = tnSize / (nDriveClusterSize / 1024);
			if (tnSize % (nDriveClusterSize / 1024))
			{
				nClustersRequired++;
			}
		}
		else
		{
			tnSize = tnSize * 2 * 1024 * 1024; //sectors
			nClustersRequired = tnSize / pDrvInfo->SectorsPerCluster;
			if (tnSize % pDrvInfo->SectorsPerCluster)
			{
				nClustersRequired++;
			}
		}
		break;
	case 4:
		// based on percentage free	
		nClustersRequired = GetFreeClusters(pDrvInfo);
		nClustersRequired = nClustersRequired / 100;
		nClustersRequired = nClustersRequired * gnSize;
		break;
	case 5:
		// based on percentage disk size
		nClustersRequired = pDrvInfo->TotalClusters;
		nClustersRequired = nClustersRequired / 100;
		nClustersRequired = nClustersRequired * gnSize;
		break;
	}
	
	return nClustersRequired;
}

UINT32 GetContigousStart(BPBINFO *pDrvInfo, UINT32 nClustersRequired)
{
	UINT32 ti;
	UINT32 nContigousStart;
	
	if (gnFirstCluster == 0)
	{
		nContigousStart = 2;
	}
	else
	{
		nContigousStart = gnFirstCluster;
	}
	
	//
	// -2 is adjustment value, because cluster value starts at 2
	//
	while ((nContigousStart-2+nClustersRequired) < pDrvInfo->TotalClusters)
	{
		for (ti = 0; ti < nClustersRequired; ti++)
		{
			if (FindNextCluster(pDrvInfo, nContigousStart+ti) != 0)
			{
				break;
			}
		}
		
		if (ti == nClustersRequired)
		{
			return nContigousStart;
		}
		else
		{
			nContigousStart = nContigousStart+ti+1;
		}
			
	}
	return 0;
}

UINT32 OccupyClusters(BPBINFO *pDrvInfo, UINT32 nStartCluster, UINT32 nTotalClusters)
{

	UINT32 ti, nCurrent, nPrevious;
	
	if (!gnContig)
	{
		if (nStartCluster == 0)
		{
			nStartCluster = 2;
		}
		 
		nCurrent = nStartCluster;
		nPrevious = nStartCluster;
		
		//    
		// First locate a free cluster
		//
        while (nCurrent <= pDrvInfo->TotalClusters)
		{
			if (FindNextCluster(pDrvInfo, nCurrent) == 0)
			{
				break;
			}
			nCurrent++;
		}
		nPrevious = nCurrent;
		gnClusterStart = nCurrent;
		nCurrent++;
		// one cluster almost allocated, set ti to 2
		ti = 2;
        while (ti <= nTotalClusters && nCurrent <= pDrvInfo->TotalClusters)
		{
			if (FindNextCluster(pDrvInfo, nCurrent) == 0)
			{
				//
				// occupy this cluster
				//
				UpdateFATLocation(pDrvInfo, nPrevious, nCurrent);
				nPrevious = nCurrent;
				ti++;
			}
			nCurrent++;
		}
		UpdateFATLocation(pDrvInfo, nPrevious, GetFATEOF(pDrvInfo));
        if (ti < nTotalClusters)
        {
            Mes("*** WARNING: Disk full, fewer than required clusters allocated.***\n");
        }
        return ti-1;
	}
	else
	{
		//
		// This is a dangerous area. It trusts nStartCluster and nTotalClusters and
		// allocates a contigous chain.
		//
		ti = 1;
		nCurrent = nStartCluster;
        while (ti < nTotalClusters)
		{
			nPrevious = nCurrent;
			nCurrent++;
			UpdateFATLocation(pDrvInfo, nPrevious, nCurrent);
			ti++;
		}
		UpdateFATLocation(pDrvInfo, nCurrent, GetFATEOF(pDrvInfo));
        return nTotalClusters;
	}
}

//
// Directory related functions
//

UINT16 ReadRootDirSector(BPBINFO *DrvInfo, BYTE *pRootDirBuffer, UINT32 NthSector)
{
	// !#! ReadRootDirSector is requested to return 1 sector. But two consiquitive
	// sectors are returned so that it helps routine which process the file
	// info when an LFN crosses sector boundary

	UINT32	SeekSector;
	UINT16  NthInChain;// Nth cluster 'order' in the root directory FAT chain
	UINT16  ti;
	UINT32	NextCluster;
	BYTE	RetVal;
	UINT16  NthInCluster;
	
	RetVal = 1;	
	switch (DrvInfo->FATType)
	{
		case 12:
		case 16:
			if (NthSector > DrvInfo->TotalRootDirSectors)
			{
				RetVal = 2;
				break;
			}
			SeekSector = (UINT32) DrvInfo->FirstRootDirSector + NthSector - 1;
			RetVal = (BYTE) ReadSector(DrvInfo->Drive, SeekSector, 2, pRootDirBuffer);
			break;
		case 32:
			//
			// Reading a FAT32 root directory sector is handled in a different way. 
			// Find out where the requested sector should be residing in the chain
			//
			NthInChain = (UINT16) (NthSector / (UINT32) DrvInfo->SectorsPerCluster);
			NthInCluster = (UINT16) (NthSector - ((UINT32)NthInChain * (UINT32)DrvInfo->SectorsPerCluster));
			if (!NthInCluster)
			{
				NthInChain--;
				NthInCluster = DrvInfo->SectorsPerCluster;
			}
			// Find the cluster at this order in the FAT chain
			NextCluster = DrvInfo->RootDirCluster;
			ti = 0;
			while (ti < NthInChain)
			{
				if (NextCluster >= (0x0fffffff-7))
				{
					RetVal = 2;
					break;
				}
				NextCluster = FindNextCluster(DrvInfo, NextCluster);
				ti++;
			}
			if (RetVal != 2)
			{
				SeekSector = (UINT32) DrvInfo->ReservedBeforeFAT + 
							DrvInfo->SectorsPerFAT * 
							(UINT32)DrvInfo->FATCount + 
							(UINT32) (NextCluster - 2) * 
							(UINT32) DrvInfo->SectorsPerCluster + 
							NthInCluster-1;
				ReadSector(DrvInfo->Drive, SeekSector, 2, pRootDirBuffer);
				// if this is the last sector OF the cluster get next cluster and 
				// get the first sector
				if (NthInCluster == DrvInfo->SectorsPerCluster)
				{
					NthInCluster = 1;
					NextCluster = FindNextCluster(DrvInfo, NextCluster);
					if (NextCluster < (0x0fffffff-7))
					{
						SeekSector = (UINT32) DrvInfo->ReservedBeforeFAT + 
								DrvInfo->SectorsPerFAT * 
								(UINT32)DrvInfo->FATCount + 
								(UINT32) (NextCluster - 2) * 
								(UINT32) DrvInfo->SectorsPerCluster + 
								NthInCluster-1;
						ReadSector(DrvInfo->Drive, SeekSector, 1, pRootDirBuffer+512); // note the 512 here
					}
					else
					{
						for (ti = 512; ti < 1024; ti++)
						{
							pRootDirBuffer[ti] = 0; // undo the second sector read
						}
					}
				}
			}
			break;
	}
	return RetVal;
}

UINT16 WriteRootDirSector(BPBINFO *DrvInfo, BYTE *pRootDirBuffer, UINT32 NthSector)
{
	UINT32	SeekSector;
	UINT16  NthInChain; // Nth cluster 'order' in the root directory FAT chain
	UINT16	ti;
	UINT32	NextCluster;
	BYTE	RetVal;
	UINT16  NthInCluster;
	
	RetVal = 1;	
	switch (DrvInfo->FATType)
	{
		case 12:	// FAT12 and FAT32 are handled the same way
		case 16:
			if (NthSector > DrvInfo->TotalRootDirSectors)
			{
				RetVal = 2;
				break;
			}
			SeekSector = (UINT32) DrvInfo->FirstRootDirSector + NthSector-1;
			RetVal = (BYTE) WriteSector(DrvInfo->Drive, SeekSector, 1, pRootDirBuffer);
			break;
		case 32:
			
			// Find out where the requested sector should be going in the chain
			NthInChain = (UINT16) (NthSector / (UINT32) DrvInfo->SectorsPerCluster);
			NthInCluster = (UINT16) (NthSector - ((UINT32)NthInChain * (UINT32)DrvInfo->SectorsPerCluster));
			if (!NthInCluster)
			{
				NthInChain--;
				NthInCluster = DrvInfo->SectorsPerCluster;
			}
			// Find the cluster at this order in the FAT chain
			NextCluster = DrvInfo->RootDirCluster;
			ti = 0;
			while (ti < NthInChain)
			{
				if (NextCluster == 0x0fffffff)
				{
					RetVal = 2;
					break;
				}
				NextCluster = FindNextCluster(DrvInfo, NextCluster);
				ti++;
			}
			if (RetVal != 2)
			{
				SeekSector = (UINT32) DrvInfo->ReservedBeforeFAT + 
							DrvInfo->SectorsPerFAT * (UINT32)DrvInfo->FATCount + 
							(UINT32) (NextCluster - 2) * 
							(UINT32) DrvInfo->SectorsPerCluster + NthInCluster-1;
				WriteSector(DrvInfo->Drive, SeekSector, 1, pRootDirBuffer);
			}
			break;
	}
	return RetVal;
}

//
// File related functions
// 
void FindFileLocation(BPBINFO *DrvInfo, BYTE *TraversePath, FILELOC *FileLocation)
{
	// Parameter TraversePath must be a file name(or dir name) with full path
	// The first character must be "\". If the function fails 0 is returned
	// in FILELOC->Found. eg. You can pass \Windows\System32\Program Files 
	// to get "Program Files" location

	FILEINFO FileInfo;
	BYTE Found;
	UINT16 RetVal;
	BYTE DirInfo[300];
	BYTE CheckInfo[300];
	UINT16 ti,tj,n,TraverseCount, Offset;
	BYTE i;
	UINT32 NthRootDirSector, NextCluster, SectorToRead;
	BYTE SectorBuffer[1024];

	Found = 0;
	ti = strlen(TraversePath);
	if (ti < 2)
	{
		FileLocation->Found = 0;
		return;
	}
	TraverseCount = 0;
	// start from next character as the first char is "\" and i value should not change inside while loop
	ti = 1;		
	while (TraversePath[ti] != 0)
	{
		tj = 0;
		for (n = 0; n < 300; n++) DirInfo[n] = 0;
		if (TraverseCount != 0)
		{
			ti++;	// increment only after traversing root directory.
		}
		while (TraversePath[ti] != '\\' && TraversePath[ti] != 0)
		{
			DirInfo[tj] = TraversePath[ti];
			tj++; ti++;
		}
		DirInfo[tj] = 0;
		TraverseCount++;
		if (TraverseCount == 1)	
		{
			//
			// We are in root directory entry if TraverseCount equals 1
			//
			Found = 0;
			NthRootDirSector = 1;
			Offset = 0;
			while (!Found)
			{
				RetVal = ReadRootDirSector(DrvInfo, SectorBuffer, NthRootDirSector);
				if (RetVal == 0 || RetVal == 2)
				{
					break;
				}
				else
				{
					while (SectorBuffer[Offset] != 0)
					{
						if (SectorBuffer[Offset] == 0xe5)
						{
							Offset+=32;
						}
						else
						{
							GetFileInfo(DrvInfo, SectorBuffer, Offset, &FileInfo);
							strcpy(CheckInfo, (char *)FileInfo.LFName);
							if (strcmpi(CheckInfo, DirInfo) == 0)
							{
								FileLocation->InCluster = 1;
								FileLocation->StartCluster = FileInfo.StartCluster;
								FileLocation->NthSector = NthRootDirSector;
								FileLocation->NthEntry = Offset/32 + 1;
								FileLocation->EntriesTakenUp = FileInfo.EntriesTakenUp;
								FileLocation->Size = FileInfo.Size;
								FileLocation->Attribute = FileInfo.Attribute;
								Found = 1;
								break;
							}
							Offset = Offset + FileInfo.EntriesTakenUp * 32;
						}
						if (Offset > 511)
						{
							break;
						}
					}
				}
				if (SectorBuffer[Offset] == 0 || Found)
				{
					break;
				}
				//
				// do not set it to 0 directly
				//
				Offset = Offset - 512;	
				NthRootDirSector++;
			}
			if (!Found)
			{
				FileLocation->Found = 0;
				return;
			}
		}
		else
		{
			NextCluster = FileLocation->StartCluster;
			Offset = 0;
			Found = 0;
			while (NextCluster < (GetFATEOF(DrvInfo) - 7))
			{
				for (i = 0; i < DrvInfo->SectorsPerCluster; i++)
				{
					SectorToRead = (UINT32) ((UINT32)DrvInfo->TotalSystemSectors + (NextCluster - 2) * (UINT32)DrvInfo->SectorsPerCluster + i);
					ReadSector(DrvInfo->Drive, SectorToRead, 2, SectorBuffer);
					if (i == DrvInfo->SectorsPerCluster-1)
					{	
						if (FindNextCluster(DrvInfo, NextCluster) < (GetFATEOF(DrvInfo) - 7))
						{	// Note the +512 carefully
							SectorToRead = (UINT32) ((UINT32)DrvInfo->TotalSystemSectors + 
										(FindNextCluster(DrvInfo, NextCluster) - 2) * 
										(UINT32)DrvInfo->SectorsPerCluster);
							ReadSector(DrvInfo->Drive, SectorToRead, 1, SectorBuffer+512);
						}
					}
					while (1)
					{
						if (Offset > 511 || SectorBuffer[Offset] == 0)
						{
							break;
						}
						if (SectorBuffer[Offset] == 0xe5)
						{
							Offset+=32;
							continue;
						}
						GetFileInfo(DrvInfo, SectorBuffer, Offset, &FileInfo);
						//
						// Refer to GetFileInfo if confused 
						//
						strcpy(CheckInfo, FileInfo.LFName);	
						if (strcmpi(CheckInfo, DirInfo) == 0)
						{
							FileLocation->InCluster = NextCluster;
							FileLocation->StartCluster = FileInfo.StartCluster;
							FileLocation->NthSector = (UINT32) i+1;
							FileLocation->NthEntry = Offset/32 + 1;
							FileLocation->EntriesTakenUp = FileInfo.EntriesTakenUp;
							FileLocation->Size = FileInfo.Size;
							FileLocation->Attribute = FileInfo.Attribute;
							Found = 1;
							break;
						}
						Offset = Offset + FileInfo.EntriesTakenUp * 32;
					}
					if (Found)
					{
						break;
					}
					Offset = Offset - 512; // Should not simply set it to 0
				}
				if (Found)
				{
					break;
				}
				NextCluster = FindNextCluster(DrvInfo, NextCluster);
			}
		}
	}
	FileLocation->Found = Found;
}

void GetFileInfo(BPBINFO *DrvInfo, BYTE *DirBuffer, UINT16 Offset, FILEINFO *FileInfo)
{
	// GetFileInfo gets the file information from DirBuffer at Offset and
	// It supports long file names. Also it stores the number of 
	// entries that are occupied by this file name in FileInfo->EntriesTakenUp
	// !#! If the entry is not a long file name a proper file name is stored
	// in LFName with a dot in between primary and ext names to help routines
	// which compare file names
	UINT16 ti,tj;
	UINT16 TimeDateWord;
	BYTE StrCompare[7];
	UINT32 Temp;
	
	FileInfo->LFName[0] = '\0';
	FileInfo->LFNOrphaned = 0;
	FileInfo->TrashedEntry = 0;
	// Get file attribute
	FileInfo->Attribute = DirBuffer[Offset+11];	
	if ((FileInfo->Attribute & 0x0f) == 0x0f)
	{
		if (DirBuffer[Offset] >= 'A' && DirBuffer[Offset] <= 'T')
		{ // Count of minimum and maximum entries to be an LFN
			FileInfo->EntriesTakenUp = (DirBuffer[Offset] & 0x3f) + 1;
			// Get the real attribute if it is a long file name. EntriesTakenUp > 1 is a long file name
			FileInfo->Attribute = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+11];
		}
		else
		{
			FileInfo->TrashedEntry = 1;
			FileInfo->LFNOrphaned = 1; // Could be
			return;
		}
	}
	else
	{
		FileInfo->EntriesTakenUp = 1;
	}
	// Get Primary name
	for (ti = 0; ti < 8; ti++)
	{
		FileInfo->DOSName[ti] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+ti];
	}
	// Get extension
	FileInfo->DOSExt[0] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+8];
	FileInfo->DOSExt[1] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+9];
	FileInfo->DOSExt[2] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+10];

	Rx.e.evx = 0;
	Rx.h.vl = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1c]; 
	Rx.h.vh = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1d]; 
	Rx.h.xvl = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1e]; 
	Rx.h.xvh = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1f];
	FileInfo->Size = Rx.e.evx;
	
	switch (DrvInfo->FATType)
	{
		case 12:
		case 16:
			// Starting Cluster
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1a]; Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1b];
			FileInfo->StartCluster = (UINT32) Rx.x.vx;
			// Get File time
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x16]; Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x17];
			TimeDateWord = Rx.x.vx;
			FileInfo->Second = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Minute = (BYTE) ((TimeDateWord & 0x07e0) >> 5);
			FileInfo->Hour   = (BYTE) ((TimeDateWord & 0xf800) >> 11);
			// Get File date
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x18]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x19];
			TimeDateWord = Rx.x.vx;
			FileInfo->Day    = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Month  = (BYTE) ((TimeDateWord & 0x01e0) >> 5);
			FileInfo->Year   = ((TimeDateWord & 0xfe00) >> 9) + 1980;
			break;
		case 32:
			// Starting Cluster
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1a]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1b]; 
			Rx.h.xvl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x14]; 
			Rx.h.xvh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x15];
			FileInfo->StartCluster = Rx.e.evx;
			// Get File time
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x16]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x17];
			TimeDateWord = Rx.x.vx;
			FileInfo->Second = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Minute = (BYTE) ((TimeDateWord & 0x07e0) >> 5);
			FileInfo->Hour   = (BYTE) ((TimeDateWord & 0xf800) >> 11);
			// Get File date
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x18]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x19];
			TimeDateWord = Rx.x.vx;
			FileInfo->Day    = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Month  = (BYTE) ((TimeDateWord & 0x01e0) >> 5);
			FileInfo->Year   = ((TimeDateWord & 0xfe00) >> 9) + 1980;
			break;
		default:
			break;
	}
	if (FileInfo->EntriesTakenUp < 2)	// copy DOSName and DOSExt as proper file name to LFName
	{
		ti = 0; tj = 0;
		while(1)
		{
			if (FileInfo->DOSName[ti] == ' ' || ti == 8)
			{
				break;
			}
			FileInfo->LFName[tj] = FileInfo->DOSName[ti];
			tj++; ti++;
		}
		if (ti != 0 && FileInfo->DOSExt[0] != ' ') // Avoid empty names and . in case of no extension
		{
			FileInfo->LFName[tj] = '.';
			ti = 0; tj++;
			while (1)
			{
				if (FileInfo->DOSExt[ti] == ' ' || ti == 3)
				{
					break;
				}
				FileInfo->LFName[tj] = FileInfo->DOSExt[ti];
				tj++; ti++;
			}
		}
		FileInfo->LFName[tj] = 0;	// Terminate with NULL Character
	}
	else
	{	// Fetch the Long file name
		ti = 0; tj = FileInfo->EntriesTakenUp - 1;
		while( tj > 0)
		{
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 1];  ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 3];  ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 5];  ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 7];  ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 9];  ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 14]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 16]; ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 18]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 20]; ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 22]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 24]; ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 28]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 30]; ti++;
			tj--;
		}
		FileInfo->LFName[ti] = 0;
	}
	// Check for orphaned LFN
	if (FileInfo->EntriesTakenUp > 1)
	{ // it is a long file name
		// Get the strings from the LFN without space for comparison purpose
		// Example - if LFN is "Very Long name" the corresponding
		// DOS file name would be "VERYLO~?". We extract VeryLo and check
		// against VERYLO.
		ti = 0; tj = 0;
		while (ti < 8 && FileInfo->LFName[tj] != 0 && FileInfo->LFName[tj] != '.')
		{
			if (FileInfo->LFName[tj] != 32 && FileInfo->LFName[tj] != '.')
			{
				StrCompare[ti] = FileInfo->LFName[tj];
				ti++;
			}
			tj++;
		}
		StrCompare[tj] = 0;
		// But when there are to many file starting with name "Very Long name"
		// the dos file name need not be "VERYLO~?" in all the cases. It could
		// be "VERYL~??" or "VERY~???" and so on...
		tj = 0;
		while (FileInfo->DOSName[tj] != '~' && FileInfo->DOSName[tj] != ' ' && tj < 8)
		{
			tj++;
		}
		// *******  This if condition is not efficient
		// it is only modified to avoid false LFN errors.
		// replace the one with tj after getting more info about CRC values
		// *******
		if (strnicmp(StrCompare, FileInfo->DOSName, 1) != 0)
		{
			FileInfo->LFNOrphaned = 1;
		}
	}
	// Check if this file is a trashed entry
	if (DrvInfo->BigTotalSectors)
	{
		Temp = DrvInfo->BigTotalSectors;
	}
	else
	{
		Temp = DrvInfo->TotalSectors;
	}
	if (FileInfo->Year < 1981 || FileInfo->Day > 31 || FileInfo->Month < 1 ||
		FileInfo->Month > 12 || 	FileInfo->Second > 30 || 
		FileInfo->Minute > 60 || FileInfo->Hour > 23 ||
		FileInfo->StartCluster > DrvInfo->TotalClusters ||
		FileInfo->Size/512 > Temp)
	{
		FileInfo->TrashedEntry = 1;
	}
}

BYTE GetAllInfoOfFile(BPBINFO *pDrvInfo, BYTE *FileName, FILELOC *pFileLoc, FILEINFO *pFileInfo)
{
	UINT16	Offset;
	UINT32	SectorToRead;
	BYTE	Sector[1024];
	
	FindFileLocation(pDrvInfo, FileName, pFileLoc);
	if (!pFileLoc->Found)
	{	// need not proceed to find FileInfo
		return 0;
	}
	Offset = (pFileLoc->NthEntry-1) * 32;
	if (pFileLoc->InCluster == 1)
	{	// file in root directory
		ReadRootDirSector(pDrvInfo, Sector, pFileLoc->NthSector);
	}
	else
	{
		SectorToRead = (UINT32) ((UINT32)pDrvInfo->TotalSystemSectors + (pFileLoc->InCluster - 2) * (UINT32)pDrvInfo->SectorsPerCluster + pFileLoc->NthSector-1);
		ReadSector(pDrvInfo->Drive, SectorToRead, 1, Sector);
	}
	GetFileInfo(pDrvInfo, Sector, Offset, pFileInfo);
	return 1;
}


UINT16 SetFileInfo(BPBINFO *pDrvInfo, FILELOC *pFileLoc, FILEINFO *pFileInfo)
{
	// This function loads the entry of a file from its directory sector
	// specified in FileLocation and updates it with the new File Info in FILEINFO
	// At present this function only changes StartCluster, Size

	UINT32	SectorToRead, EmergencySectorToRead;
	UINT16	Offset, Temp;
	BYTE	SectorBuffer[1024];
	
	Offset = (pFileLoc->NthEntry-1)*32;

	if (pFileLoc->InCluster == 1)
	{	// the file is in root directory. Refer to FindFileLocation function for more info
		if (ReadRootDirSector(pDrvInfo, SectorBuffer, pFileLoc->NthSector) != 1)
		{ // The return value of the above function is either 0 or 1 or 2. We only want return value 1
			return 0;
		}
	}
	else
	{
		SectorToRead = (UINT32) ((UINT32)pDrvInfo->TotalSystemSectors + (pFileLoc->InCluster - 2) * (UINT32)pDrvInfo->SectorsPerCluster + pFileLoc->NthSector-1);
		EmergencySectorToRead = SectorToRead + 1;
		if (!ReadSector(pDrvInfo->Drive, SectorToRead, 2, SectorBuffer))
		{
			return 0;
		}
		if (pFileLoc->NthSector == pDrvInfo->SectorsPerCluster)
		{	
			if (FindNextCluster(pDrvInfo, pFileLoc->InCluster) < (GetFATEOF(pDrvInfo) - 7)) // EOF can be FFF8 to FFFF
			{	// Note the +512 carefully
				EmergencySectorToRead = (UINT32) ((UINT32)pDrvInfo->TotalSystemSectors + (FindNextCluster(pDrvInfo, pFileLoc->InCluster) - 2) * (UINT32)pDrvInfo->SectorsPerCluster);
				if (!ReadSector(pDrvInfo->Drive, EmergencySectorToRead, 1, SectorBuffer+512))
				{
					return 0;
				}
			}
		}
	}

	//
	// We have the file entry in SectorBuffer
	// Now update the file info located in the SHORTNAME area
	//

	Temp = (pFileInfo->EntriesTakenUp-1)*32;
    //
	// Change Cluster value
	//
	Rx.e.evx = 0;
	Rx.e.evx = (UINT32) pFileInfo->StartCluster;
	if (pDrvInfo->FATType == 32)
	{
		SectorBuffer[Offset+Temp+0x1a] = Rx.h.vl;
		SectorBuffer[Offset+Temp+0x1b] = Rx.h.vh;
		SectorBuffer[Offset+Temp+0x14] = Rx.h.xvl;
		SectorBuffer[Offset+Temp+0x15] = Rx.h.xvh;
	}
	else
	{
		SectorBuffer[Offset+Temp+0x1a] = Rx.h.vl;
		SectorBuffer[Offset+Temp+0x1b] = Rx.h.vh;
	}

	// Change Size
	Rx.e.evx = pFileInfo->Size;
	SectorBuffer[Offset+Temp+0x1c] = Rx.h.vl; SectorBuffer[Offset+Temp+0x1d] = Rx.h.vh;
	SectorBuffer[Offset+Temp+0x1e] = Rx.h.xvl; SectorBuffer[Offset+Temp+0x1f] = Rx.h.xvh;
	
	if (pFileLoc->InCluster == 1)
	{
		WriteRootDirSector(pDrvInfo, SectorBuffer, pFileLoc->NthSector);
		if (Offset + pFileLoc->EntriesTakenUp * 32 > 512) // Did it cross sector boundary
		{
			WriteRootDirSector(pDrvInfo, SectorBuffer+512, pFileLoc->NthSector+1);
		}
	}
	else
	{
		WriteSector(pDrvInfo->Drive, SectorToRead, 1, SectorBuffer);
		if (Offset + pFileLoc->EntriesTakenUp * 32 > 512) // Did it cross sector boundary
		{
			WriteSector(pDrvInfo->Drive, EmergencySectorToRead, 1, SectorBuffer+512);
		}
	}
	// File entry updated
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\cvtarea\cvtarea.h ===
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "dos.h"
#include "fcntl.h"
#include "process.h"

#ifndef UINT16
#define UINT16 unsigned short
#endif

#ifndef UINT32
#define UINT32 unsigned long
#endif

#ifndef BYTE
#define BYTE unsigned char
#endif

// this one needs to be investigated.
#define READONLYLOCK 0 
#define READWRITELOCK 0

#define MAXCACHE 600

#define FOURGB 4294967295

//
// struct and type declarations
//

struct hlike
{
	BYTE vl;
	BYTE vh;
	BYTE xvl;
	BYTE xvh;
};
struct xlike
{
	UINT16 vx;
	UINT16 xvx;
};

struct elike
{
	UINT32 evx;
};
union Conversion
{
	struct hlike h;
	struct xlike x;
	struct elike e;
};

struct _BPBINFO
{
	BYTE	ReliableInfo;			// if this value is 1 all other info are reliable
	BYTE	Drive;
	UINT16	BytesPerSector;
	BYTE	SectorsPerCluster;
	UINT16	ReservedBeforeFAT;
	BYTE	FATCount;
	BYTE	FATType;
	UINT16	MaxRootDirEntries;
	UINT16	TotalRootDirSectors;	// FAT16 specific
	UINT16	TotalSectors;
	UINT32	TotalSystemSectors;
	BYTE	MediaID;
	UINT32	SectorsPerFAT;
	UINT16	SectorsPerTrack;
	UINT16	Heads;
	UINT32	TotalClusters;
	UINT32	HiddenSectors;
	UINT32	BigTotalSectors;
	UINT32	RootDirCluster;			// FAT32 specific
	UINT32	FirstRootDirSector;
	BYTE	DriveType;
	BYTE	ImproperShutDown;
};
typedef struct _BPBINFO BPBINFO;

struct _FILEINFO
{
	BYTE	LFName[260];
	BYTE	DOSName[8];
	BYTE	DOSExt[3];
	BYTE	Attribute;
	UINT32	HiSize;
	UINT32	Size;
	UINT32	StartCluster;
	UINT32	ParentCluster;
	UINT32	TotalClusters;
	BYTE	EntriesTakenUp;	//Entries occupied by this file in directory sector, vital for LFN processing
	BYTE	LFNOrphaned;
	BYTE	TrashedEntry;
	BYTE	Second;
	BYTE	Minute;
	BYTE	Hour;
	BYTE	Day;
	BYTE	Month;
	UINT16	Year;
};
typedef struct _FILEINFO FILEINFO;

struct _FILELOC
{
	UINT32	InCluster;	// value 1 means root directory is the where the entry was found
	UINT32	StartCluster;
	UINT32	NthSector;		// Sector position in parentcluster
	UINT16	NthEntry;		// Nth Entry in the sector
	UINT16	EntriesTakenUp;	// Total entries taken up by this file
	UINT32	Size;			// Size of the file
	BYTE	Found;			// Set to 1 if the file was found
	BYTE	Attribute;	// File attribute
};
typedef struct _FILELOC FILELOC;

struct _ABSRW
{
	UINT32 StartSector;
	UINT16 Count;
	UINT32 Buffer;
};
typedef struct _ABSRW ABSRW;

struct _ABSPACKET
{
	UINT16 SectorLow;
	UINT16 SectorHigh;
	UINT16 SectorCount;
	UINT16 BufferOffset;
	UINT16 BufferSegment;
};
typedef struct _ABSPACKET ABSPACKET;

struct _TREENODE
{
	UINT32 Sector;
	struct _TREENODE *LChild;
	struct _TREENODE *RChild;
	struct _TREENODE *Parent;
	BYTE *Buffer;
	char Dirty;
};
typedef struct _TREENODE BNODE, *PBNODE;

struct _NODE
{
        UINT32 Sector;
        struct _NODE *Back;
        struct _NODE *Next;
        BYTE *Buffer;
        char Dirty;
};
typedef struct _NODE NODE, *PNODE;

struct _LMRU
{
	PNODE Node;
	struct _LMRU *Next;
};
typedef struct _LMRU LMRU, *PLMRU;


//
// function declarations
//
UINT16 ProcessCommandLine(int argc, char *argv[]);
UINT16 PureNumber(char *sNumStr);
void   DisplayUsage(void);
void   Mes(char *pMessage);
UINT16 LockVolume(BYTE nDrive, BYTE nMode);
UINT16 UnlockVolume(BYTE nDrive);
BYTE   GetCurrentDrive(void);
BYTE   GetCurrentDirectory(BYTE nDrive, BYTE *pBuffer);
UINT16 ReadSector(BYTE nDrive, UINT32 nStartSector, UINT16 nCount, BYTE *pBuffer);
UINT16 WriteSector(BYTE Drive, UINT32 nStartSector, UINT16 nCount, BYTE *pBuffer);
UINT16 BuildDriveInfo(BYTE Drive, BPBINFO *pDrvInfo);
UINT16 GetFATBPBInfo(BYTE *pBootSector, BPBINFO *pDrvInfo);
UINT16 GetFAT32BPBInfo(BYTE *pBootSector, BPBINFO *pDrvInfo);
void   AddToMRU(PNODE pNode);
void   RemoveLRUMakeMRU(PNODE pNode);
UINT16 AddNode(PNODE pNode);
PNODE  FindNode(UINT32 nSector);
PNODE  RemoveNode(void);
void   DeallocateLRUMRUList(void);
void   DeallocateFATCacheTree(PNODE pNode);
void   DeallocateFATCacheList(void);
BYTE   *CcReadFATSector(BPBINFO *pDrvInfo, UINT32 nFATSector);
UINT16 CcWriteFATSector(BPBINFO *pDrvInfo, UINT32 nFATSector);
void   CcCommitFATSectors(BPBINFO *pDrvInfo);
UINT32 FindNextCluster(BPBINFO *DrvInfo,UINT32 CurrentCluster);
UINT16 UpdateFATLocation(BPBINFO *DrvInfo, UINT32 CurrentCluster,UINT32 PointingValue);
UINT32 FindFreeCluster(BPBINFO *pDrvInfo);
UINT32 QFindFreeCluster(BPBINFO *pDrvInfo);
UINT32 GetFATEOF(BPBINFO *pDrvInfo);
UINT32 GetFreeClusters(BPBINFO *pDrvInfo);
UINT32 ConvertClusterUnit(BPBINFO *pDrvInfo);
UINT32 GetClustersRequired(BPBINFO *pDrvInfo);
UINT32 GetContigousStart(BPBINFO *pDrvInfo, UINT32 nClustersRequired);
UINT32 OccupyClusters(BPBINFO *pDrvInof, UINT32 nStartCluster, UINT32 nTotalClusters);
UINT16 ReadRootDirSector(BPBINFO *pDrvInfo, BYTE *pRootDirBuffer, UINT32 NthSector);
UINT16 WriteRootDirSector(BPBINFO *pDrvInfo, BYTE *pRootDirBuffer, UINT32 NthSector);
void   FindFileLocation(BPBINFO *pDrvInfo, BYTE *TraversePath, FILELOC *FileLocation);
void   GetFileInfo(BPBINFO *pDrvInfo, BYTE *DirBuffer, UINT16 Offset, FILEINFO *FileInfo);
BYTE   GetAllInfoOfFile(BPBINFO *pDrvInfo, BYTE *FileName, FILELOC *pFileLoc, FILEINFO *pFileInfo);
UINT16 SetFileInfo(BPBINFO *pDrvInfo, FILELOC *pFileLoc, FILEINFO *pFileInfo);

//
// Variable declarations, we declare some variables global to avoid hogging stack
// if a function (like ReadSector) is called at high frequency
//

BPBINFO gsDrvInfo;
FILELOC gsFileLoc;
FILEINFO gsFileInfo;
union 	Conversion Rx;
union	Conversion Tx;
BYTE	*PettyFATSector;
UINT32 	LastClusterAllocated;
BYTE 	gsFileParam[300];
BYTE 	gsFileName[300];
UINT32	gnSize;
UINT32  gnSizeInBytes;
BYTE	gnSizeUnit;
BYTE	gnContig;
UINT32	gnFirstCluster;
BYTE	gbValidateFirstClusterParam;
BYTE	gnStrictLocation;
BYTE	gnClusterUnit;
BYTE	gcDrive;
UINT32	gnClustersRequired;
UINT32  gnAllocated;
UINT32  gnClusterStart;
BYTE	gsCurrentDir[300];
BYTE	gnFreeSpaceDumpMode;
BYTE	gnDumpMode;
UINT32	gnClusterFrom;
UINT32	gnClustersCounted;
UINT32	gnClusterProgress;
UINT32	gnClusterProgressPrev;
PNODE	gpHeadNode;
PNODE	gpTailNode;
UINT16	gpFATNodeCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\cvtarea\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by OKF.RC
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\depend.h ===
//
// Include files for messages.
// msg.h is the file generated by the message compiler.
// libmsg.h is the message library header file.
//
#include "msg.h"
#include <libmsg.h>

#define DWORD unsigned long
#define errBAD_ARGUMENTS 1
#define errFILE_NOT_FOUND 2
#define errFILE_LOCKED 3
#define errMISSING_DEPENDENCY 4
#define errOUT_OF_MEMORY 5

#define delete if(false) delete

void GetPath(TCHAR *,TCHAR *);
bool ParseCommandLine(int,TCHAR*[]);
bool SearchPath(TCHAR*,TCHAR*);
File* CreateFile(TCHAR* pszFileName);

extern List* pQueue;
extern List* pDependQueue;
extern List* pSearchPath;
extern List* pMissingFiles;
extern bool bNoisy;
extern DWORD dwERROR;
extern bool bListDependencies;

//
// Global variables required to format message using GetFormattedMessage(..)
// from libmsg.lib
//
extern HMODULE ThisModule;
extern WCHAR Message[4096];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\depend.cpp ===
#include <string.h>
#include <iostream>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#include <new.h>
#include "List.h"
#include "File.h"
#include "File32.h"
#include "File64.h"
#include "Object.h"
#include "depend.h"

List* pQueue;
List* pDependQueue;
List* pSearchPath;
List* pMissingFiles;
bool bNoisy;
bool bListDependencies;
DWORD dwERROR;

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR   Message[4096];

// Define a function to be called if new fails to allocate memory.
//
int __cdecl MyNewHandler( size_t size )
{
    
    _putws( GetFormattedMessage( ThisModule,
                                 FALSE,
                                 Message,
                                 sizeof(Message)/sizeof(Message[0]),
                                 MSG_MEM_ALLOC_FAILED) );
    // Exit program
    //
    ExitProcess(errOUT_OF_MEMORY);
}



/*
  usage: depend [/s] [/l] /f:filespec;filespec;... [/d:directory;directory;..]
  If directories are not specififed the Windows search path will be used to look for dependencies
  /s Specifies silent mode.
  filespec - file path and name. Can include wildcards.
*/
DWORD _cdecl wmain(int argc,wchar_t *argv[]) {

    // Set the failure handler for new operator.  
    //
    _set_new_handler( MyNewHandler );

    TCHAR *pszFileName = new TCHAR[256];
    File* pTempFile,*pCurrentFile;
    StringNode* pCurFile; 
    char buf[256];

    dwERROR = 0;
    pSearchPath = 0;
    bNoisy = true;
    bListDependencies = false;
    pQueue = new List();
    pDependQueue = new List();
    pMissingFiles = new List();

    ThisModule = GetModuleHandle(NULL);
    
    //Load the initial files into the queue and load the search path
    if (!ParseCommandLine(argc,argv)) goto CLEANUP;

    pCurFile = (StringNode*)pQueue->tail;

    //while the queue isn't empty
    while (pCurFile!=0) {
        WideCharToMultiByte(CP_ACP,0,pCurFile->Data(),-1,buf,256,0,0);
        
        //get a file pointer for the current file
        if (!(pCurrentFile = CreateFile(pCurFile->Data()))) {
            
            if (bListDependencies) {
                StringNode* s;
                if (s = (StringNode*)pDependQueue->Find(pCurFile->Data())) {
                    pDependQueue->Remove(pCurFile->Data());
                }
            }

            //if there was an error and we are running in silent mode, quit
            if (!bNoisy) goto CLEANUP;
        } 
        else {  //if we got a file pointer, proceed

            if (bListDependencies) {
                StringNode* s;
                if (s = (StringNode*)pDependQueue->Find(pCurFile->Data())) {
                    pDependQueue->Remove(pCurFile->Data());
                    pDependQueue->Add(pCurrentFile);
                }
            }

            //Check this files dependencies
            pCurrentFile->CheckDependencies();

            if ((dwERROR)&&(!bNoisy)) goto CLEANUP;

            //Close the file
            pCurrentFile->CloseFile();
        }

        //next file
        pCurFile = (StringNode*)pCurFile->prev;
    }
    StringNode* s;
    //if list dependencies is set, print out all dependencies
    if (bListDependencies) {
        pCurrentFile = (File*)pDependQueue->head;

        //while the queue isn't empty
        while (pCurrentFile!=0) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_DEPENDENCY_HEAD,
                                        pCurrentFile->Data()) );
            s = (StringNode*)pCurrentFile->dependencies->head;
            while(s) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_FILE_NAME,
                                            s->Data()) );
                s = (StringNode*)s->next;
            }
            pCurrentFile = (File*)pCurrentFile->next;       
        }
    }

    //print out list of broken files
    pTempFile = (File*)pMissingFiles->head;
    while (pTempFile) {
        if(bNoisy){
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_LIST_OF_BROKEN_FILES,
                                        pTempFile->Data()) );
        }
        s = (StringNode*)pTempFile->owners->head;
        while(s) {
            if(bNoisy) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_FILE_NAME,
                                            s->Data()) );
            }
            s = (StringNode*)s->next;
        }
        pTempFile = (File*)pTempFile->next;
    }

    //Done.  Clean up and go home.
    if(bNoisy) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_COMPLETED) );
    }
CLEANUP:

    delete [] pszFileName;
    delete pQueue;
    pszFileName = 0;pQueue = 0;

    return dwERROR;
}

//Given path and filename in 'pathname', fill 'path' with just the path
void GetPath(TCHAR * pathname,TCHAR* path) {

    TCHAR* end,t;
    path[0] = '\0';
    
    //find last \ in the filename
    end = wcsrchr(pathname,'\\');
    if (!end) return;

    //copy just the path
    t = end[1];
    end[1] = '\0';
    wcscpy(path,pathname);
    end[1] = t;

    return;
}

/*Fill queue with the files in the command line and fill searchpath with directories in command line
  usage: depend [/s] /f:filespec;filespec;... [/d:directory;directory;..]
  If directories are not specififed the Windows search path will be used to look for dependencies
  /s Specifies silent mode.
  filespec - file path and name. Can include wildcards.
*/
bool ParseCommandLine(int argc,wchar_t* argv[]){
    HANDLE handle;
    int nArg,nFile = 0;
    TCHAR *pszDirectory = new TCHAR[256],*pszFileName = new TCHAR[256],*ptr;
    WIN32_FIND_DATA fileData;
    bool bReturn;

    if (argc==1) {
    //if there are no arguments, display some kind of help
        if(bNoisy) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_PGM_USAGE) );
        }
        bReturn = false;
        dwERROR = errBAD_ARGUMENTS;
        goto CLEANUP;
    }

    for (nArg=1;nArg<argc;nArg++) {
        
        if (argv[nArg][0] == '/') {
            //if this is the files argument
            if (argv[nArg][1] == 'f') {

                do {
                    ptr = wcschr(argv[nArg]+3,';');
                    if (ptr) {
                        *ptr = '\0';
                        wcscpy(pszFileName,ptr+1);
                    } else wcscpy(pszFileName,argv[nArg]+3);

                    //get the first file, put the path in pszDirectory
                    handle = FindFirstFile(pszFileName,&fileData);
                    GetPath(pszFileName,pszDirectory);
                    if (*pszDirectory=='\0') {
                        GetCurrentDirectory(256,pszDirectory);
                        pszDirectory[wcslen(pszDirectory)+1] = '\0';
                        pszDirectory[wcslen(pszDirectory)] = '\\';
                    }


                    //if the file wasn't found, error and quit
                    if (handle == INVALID_HANDLE_VALUE) {
                        if(bNoisy) {
                            _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_ARG_NOT_FOUND,
                                    argv[nArg]) );
                        }
                        dwERROR = errFILE_NOT_FOUND;
                        bReturn = false;
                        goto CLEANUP;
                    }
                     
                    //put each file into the queue
                    nFile = 1;
                    while (nFile) {
                        //standardize the name:  full path, all lowercase
                        wcscpy(pszFileName,pszDirectory);
                        wcscat(pszFileName,fileData.cFileName);
                        _wcslwr(pszFileName);

                        //add the file to the queue if it's not already there
                        if (!pQueue->Find(pszFileName)) pQueue->Add(new StringNode(pszFileName));

                        //if list all dependencies is set, add to dependQueue
                        if (bListDependencies) 
                            if (!pDependQueue->Find(pszFileName)) 
                                pDependQueue->Add(new StringNode(pszFileName));

                        nFile = FindNextFile(handle,&fileData);
                    }//end while files
                } while (ptr);          
            
            } else if (argv[nArg][1] == 'd') {

                //load directories
                pSearchPath = new List();

                do {
                    ptr = wcschr(argv[nArg]+3,';');
                    if (ptr) {
                        *ptr = '\0';
                        wcscpy(pszDirectory,ptr+1);
                    } else wcscpy(pszDirectory,argv[nArg]+3);
                    if (pszDirectory[wcslen(pszDirectory)-1]!='\\') {
                        pszDirectory[wcslen(pszDirectory)+1] = '\0';
                        pszDirectory[wcslen(pszDirectory)] = '\\';
                    }
                    pSearchPath->Add(new StringNode(pszDirectory));
                } while (ptr);
                
            } else 
                //if silent mode, turn off noisy flag
                if (argv[nArg][1] == 's') bNoisy = false;
              
            else 
                //if you want to list the dependencies of all files
                //turn on this flag
                if (argv[nArg][1] == 'l') bListDependencies = true;
            else 
            {
                //unrecognized flag
                if(bNoisy) {
                    _putws( GetFormattedMessage(ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_BAD_ARGUMENT,
                                                argv[nArg]) );
                }
                dwERROR = errBAD_ARGUMENTS;
                bReturn = false;
                goto CLEANUP;
            }
        } else {
            //didn't start with a /
            if(bNoisy) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_BAD_ARGUMENT,
                                            argv[nArg]) );
            }
            dwERROR = errBAD_ARGUMENTS;
            bReturn = false;
            goto CLEANUP;
        }

    }//end for arguments

    bReturn = true;

CLEANUP:

    delete[] pszFileName;
    delete[] pszDirectory;
    pszFileName = pszDirectory = 0;
    
    return bReturn;
}

//Search for the given file in the given path
//Arguments:
//pszFileName - file to look for
//pszPathName - path to look for it in
bool SearchPath(TCHAR* pszFileName,TCHAR* pszPathName) {
    StringNode* s;
    WIN32_FIND_DATA buf;

    if (!pSearchPath) return false;

    s = (StringNode*)pSearchPath->head;

    while (s) {
        wcscpy(pszPathName,s->Data());
        wcscat(pszPathName,pszFileName);
        if (FindFirstFile(pszPathName,&buf)!=INVALID_HANDLE_VALUE) return true;
        s = (StringNode*)s->next;
    }

    pszPathName = 0;
    return false;
}

//Determine what type of file was passed in (16 bit,32,64) and create the appropriate file ptr.
//pszFileName - file to be loaded
    File* CreateFile(TCHAR* pszFileName) {

    try {
        return new File32(pszFileName);
        
    } catch(int x) {
        if (x == errFILE_LOCKED) return 0;
        try {
            return new File64(pszFileName);
        } catch(int x) {
            if (x == errFILE_LOCKED) return 0;
            if (bNoisy) {
                _putws( GetFormattedMessage(ThisModule,
                        FALSE,
                        Message,
                        sizeof(Message)/sizeof(Message[0]),
                        MSG_ERROR_UNRECOGNIZED_FILE_TYPE,
                        pszFileName) );
            }
            return 0;
        }
    }


    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\file.cpp ===
// File.cpp: implementation of the File class.
//
//////////////////////////////////////////////////////////////////////

#include "File.h"
#include <string.h>
#include <stdio.h>
#include "list.h"
#include "String.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

File::File(TCHAR * f) : Object()
{
	fileName = new TCHAR[wcslen(f)+1];
	if (f && fileName) wcscpy(fileName,f);
	owners = new List();
	dependencies = new List();

}

File::~File()
{
	delete [] fileName; fileName = 0;
	delete owners;owners = 0;
	delete dependencies;dependencies = 0;
}

//s - the filename of the dependant to be added
void File::AddDependant(StringNode *s) {
	//if it's already there, return
	if (owners->Find(s)!=0) {
		delete s;
		s = 0;
		return;
	}

	//else add it.
	owners->Add(s);

	return;
}

TCHAR* File::Data() {
	return fileName;	
}

void File::CheckDependencies() {

}

void File::CloseFile() {
	if (hFile!=INVALID_HANDLE_VALUE) CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\file.h ===
// File.h: interface for the File class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILE_H__708EE68D_A6EE_453B_AA09_C93CB05A626A__INCLUDED_)
#define AFX_FILE_H__708EE68D_A6EE_453B_AA09_C93CB05A626A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include "Object.h"
#include "List.h"
#include "StringNode.h"

class File : public Object
{
public:
	TCHAR* fileName;
	List* owners;
	List* dependencies;
	HANDLE hFile;
	
	File(TCHAR * f);
	virtual ~File();

	void AddDependant(StringNode * s);
	TCHAR* Data();
	virtual void CheckDependencies();
	void CloseFile();
};

#endif // !defined(AFX_FILE_H__708EE68D_A6EE_453B_AA09_C93CB05A626A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\file32.h ===
// File32.h: interface for the File32 class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILE32_H__228703A1_5E6A_4EE0_9A1F_35385C633FCF__INCLUDED_)
#define AFX_FILE32_H__228703A1_5E6A_4EE0_9A1F_35385C633FCF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "File.h"
#include "List.h"

class File32 : public File
{
public:
	PIMAGE_NT_HEADERS pNthdr;
	void *pImageBase;

	File32(TCHAR *pszFileName);
	virtual ~File32();

	void CheckDependencies();
};

#endif // !defined(AFX_FILE32_H__228703A1_5E6A_4EE0_9A1F_35385C633FCF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\file64.h ===
// File64.h: interface for the File64 class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILE64_H__A4393119_C187_4044_89A5_FA837C35AB44__INCLUDED_)
#define AFX_FILE64_H__A4393119_C187_4044_89A5_FA837C35AB44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "File.h"
#include "List.h"

class File64 : public File
{
public:
	PIMAGE_NT_HEADERS pNthdr;
	PIMAGE_NT_HEADERS64 pNthdr64;
	void *pImageBase;

	File64(TCHAR *pszFileName);
	virtual ~File64();

	void CheckDependencies();
};

#endif // !defined(AFX_FILE64_H__A4393119_C187_4044_89A5_FA837C35AB44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\file64.cpp ===
// File64.cpp: implementation of the File64 class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include "File64.h"
#include "depend.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//pszFileName - file to be loaded, including path
File64::File64(TCHAR *pszFileName) : File(pszFileName)
{
    HANDLE hFileMap;

    //open the file
    if ((hFile = CreateFile(pszFileName,GENERIC_READ,0,0,OPEN_EXISTING,0,0)) == INVALID_HANDLE_VALUE) {
        if(bNoisy) {
            _putws( GetFormattedMessage( ThisModule,
                                         FALSE,
                                         Message,
                                         sizeof(Message)/sizeof(Message[0]),
                                         MSG_ERROR_FILE_OPEN,
                                         pszFileName) );
        }
    	dwERROR = errFILE_LOCKED;
    	throw errFILE_LOCKED;
    }

    //create a memory map
    hFileMap = CreateFileMapping(hFile,0,PAGE_READONLY,0,0,0);
    pImageBase = MapViewOfFile(hFileMap,FILE_MAP_READ,0,0,0);


    //try to create an NTHeader structure to give file information
    if (pNthdr = ImageNtHeader(pImageBase)) {
    	if ((pNthdr->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) ||
            (pNthdr->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64)) {
    		pNthdr64 = (PIMAGE_NT_HEADERS64)pNthdr;
    		return;
    	}
    	 else { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
    } else { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
		 
}

File64::~File64()
{
	delete pImageBase;
	pImageBase = 0;
}

//Checks the dependencies of this file, and adds the dependencies to the queue so 
//their dependencies can be checked later
//If a file comes up missing add it to the MissingFiles queue. Add the file that was looking for it to the missing files'
//list of broken files.

//This function has logic in it to handle the special case of 'ntoskrnl.exe'.  If a file is 
//looking for 'ntoskrnl.exe' and it is missing then the function also looks for 'ntkrnlmp.exe'
void File64::CheckDependencies() {
	char *pszDllName = new char[256];
	TCHAR*pwsDllName = new TCHAR[256],*pszBuf = new TCHAR[256],*pszBufName;
	int temp = 0;
	File* pTempFile;
	DWORD dwOffset;
	
	DWORD dwVA = pNthdr64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	PIMAGE_SECTION_HEADER pSectHdr = IMAGE_FIRST_SECTION( pNthdr64 ),pImportHdr = 0;
	PIMAGE_IMPORT_DESCRIPTOR pImportDir;

	//figure out which section the imports table is in
	for ( unsigned i = 0; i < pNthdr64->FileHeader.NumberOfSections; i++, pSectHdr++ ) {
		DWORD cbMaxOnDisk = min( pSectHdr->Misc.VirtualSize, pSectHdr->SizeOfRawData );

		DWORD startSectRVA = pSectHdr->VirtualAddress;
		DWORD endSectRVA = startSectRVA + cbMaxOnDisk;
 
		if ( (dwVA >= startSectRVA) && (dwVA < endSectRVA) ) {
			dwOffset =  pSectHdr->PointerToRawData + (dwVA - startSectRVA);
			pImportHdr = pSectHdr;
			i = pNthdr64->FileHeader.NumberOfSections;
		}
	}

	//if we found the imports table, create a pointer to it
	if (pImportHdr) {
		pImportDir = (PIMAGE_IMPORT_DESCRIPTOR) (((PBYTE)pImageBase) + (DWORD)dwOffset);

		//go through each import, try and find it, and add it to the queue
		while ((DWORD)(pImportDir->Name)!=0) {
			strcpy(pszDllName,(char*)(pImportDir->Name + ((PBYTE)pImageBase) - pImportHdr->VirtualAddress + pImportHdr->PointerToRawData));
			_strlwr(pszDllName);

			//if the ListDependencies flag is set, add this file to the dependencies list
			if (bListDependencies) {
				MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (!dependencies->Find(pwsDllName)) dependencies->Add(new StringNode(pwsDllName));	
			}

			if (strcmp(pszDllName,"ntoskrnl.exe")) {
				//if the file is already known to be missing
				temp = MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (pTempFile = (File*)pMissingFiles->Find(pwsDllName)) {
					dwERROR = errMISSING_DEPENDENCY;
					//add this file to the list of broken files
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( ((!pSearchPath)&&(!(SearchPath(0,pwsDllName,0,256,pszBuf,&pszBufName))))|| ((pSearchPath)&&(!SearchPath(pwsDllName,pszBuf))) ) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(pwsDllName));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));	
					}
				}	
			} else {
				//if the file is already known to be missing
				if ((pTempFile = (File*)pMissingFiles->Find(L"ntoskrnl.exe"))) {
					dwERROR = errMISSING_DEPENDENCY;
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( (((!pSearchPath)&&(!(SearchPath(0,L"ntoskrnl.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntoskrnl.exe",pszBuf)))) 
						&&(((!pSearchPath)&&(!(SearchPath(0,L"ntkrnlmp.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntkrnlmp.exe",pszBuf))))) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(L"ntoskrnl.exe"));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));
					}
				}						
			}
			pImportDir++;
		}
	}

CLEANUP:

	delete [] pszDllName;
	delete [] pszBuf;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\list.cpp ===
// List.cpp: implementation of the List class.
//
//////////////////////////////////////////////////////////////////////

#include "List.h"
#include "Object.h"
#include <string.h>
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

List::List()
{
	head = tail = 0;
	length = 0;
}

List::~List()
{
	Object* o,*p;
	o = head;
	if (o) p = o->next;
	while (o) {
		delete o; 
		o = p;
		if (o) p = o->next;
	}

}

void List::Add(Object* o) {
	if (o==0) return;

	if (head==0) {
		head = tail = o;
		length = 1;
		return;
	}

	o->next = head;
	head->prev = o;
	head = o;
	length++;

}

void List::Remove(TCHAR* s) {
	if (s==0) return;
	
	Object* ptr = head;
	while(ptr) {
		if (!wcscmp(s,ptr->Data())) {
			if (ptr->prev) ptr->prev->next = ptr->next;
			if (ptr->next) ptr->next->prev = ptr->prev;
			length--;
			if (ptr==head) head = ptr->next;
		}
		ptr = ptr->next;
	}

}

Object* List::Find(TCHAR* s) {
	Object* ptr = head;

	if (s==0) return 0;

	while (ptr!=0) {
		if (wcscmp(ptr->Data(),s)==0) return ptr;
		ptr = ptr->next;
	}

	return 0;
}

Object* List::Find(Object* o) {
	Object* ptr = head;

	if (o==0) return 0;

	while (ptr!=0) {
		if (wcscmp(ptr->Data(),o->Data())==0) return ptr;
		ptr = ptr->next;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\list.h ===
// List.h: interface for the List class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LIST_H__8579C184_3703_4719_8FCB_5A91A9CA7E4E__INCLUDED_)
#define AFX_LIST_H__8579C184_3703_4719_8FCB_5A91A9CA7E4E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Object.h"
class List  
{
public:
	Object* head,*tail;
	int length;

	List();
	virtual ~List();

	void Add(Object* o);
	void Remove(TCHAR* s);

	Object* Find(Object* o);
	Object* Find(TCHAR* s);

};

#endif // !defined(AFX_LIST_H__8579C184_3703_4719_8FCB_5A91A9CA7E4E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\file32.cpp ===
// File32.cpp: implementation of the File32 class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include "File32.h"
#include "depend.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//pszFileName - file to be loaded, including path
File32::File32(TCHAR *pszFileName) : File(pszFileName)
{
    HANDLE hFileMap;

    //open the file
    if ((hFile = CreateFile(pszFileName,GENERIC_READ,0,0,OPEN_EXISTING,0,0)) == INVALID_HANDLE_VALUE) {
        if(bNoisy) {
            _putws( GetFormattedMessage( ThisModule,
                                         FALSE,
                                         Message,
                                         sizeof(Message)/sizeof(Message[0]),
                                         MSG_ERROR_FILE_OPEN,
                                         pszFileName) );
        }
    	dwERROR = errFILE_LOCKED;
    	throw errFILE_LOCKED;
    }

    //create a memory map
    hFileMap = CreateFileMapping(hFile,0,PAGE_READONLY,0,0,0);
    pImageBase = MapViewOfFile(hFileMap,FILE_MAP_READ,0,0,0);


    //try to create an NTHeader structure to give file information
    if (pNthdr = ImageNtHeader(pImageBase)) {
    	 if (pNthdr->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) return;
    	 else { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
    } else { 
    	CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
    	 
}

File32::~File32()
{
	delete pImageBase;
	pImageBase = 0;
}

//Checks the dependencies of this file, and adds the dependencies to the queue so 
//their dependencies can be checked later
//If a file comes up missing add it to the MissingFiles queue. Add the file that was looking for it to the missing files'
//list of broken files.

//This function has logic in it to handle the special case of 'ntoskrnl.exe'.  If a file is 
//looking for 'ntoskrnl.exe' and it is missing then the function also looks for 'ntkrnlmp.exe'
void File32::CheckDependencies() {
	char *pszDllName = new char[256];
	TCHAR*pwsDllName = new TCHAR[256],*pszBuf = new TCHAR[256],*pszBufName;
	int temp = 0;
	File* pTempFile;
	DWORD dwOffset;
	
	DWORD dwVA = pNthdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	PIMAGE_SECTION_HEADER pSectHdr = IMAGE_FIRST_SECTION( pNthdr ),pImportHdr = 0;
	PIMAGE_IMPORT_DESCRIPTOR pImportDir;

	//figure out which section the imports table is in
	for ( unsigned i = 0; i < pNthdr->FileHeader.NumberOfSections; i++, pSectHdr++ ) {
		DWORD cbMaxOnDisk = min( pSectHdr->Misc.VirtualSize, pSectHdr->SizeOfRawData );

		DWORD startSectRVA = pSectHdr->VirtualAddress;
		DWORD endSectRVA = startSectRVA + cbMaxOnDisk;
 
		if ( (dwVA >= startSectRVA) && (dwVA < endSectRVA) ) {
			dwOffset =  pSectHdr->PointerToRawData + (dwVA - startSectRVA);
			pImportHdr = pSectHdr;
			i = pNthdr->FileHeader.NumberOfSections;
		}
	}

	//if we found the imports table, create a pointer to it
	if (pImportHdr) {
		pImportDir = (PIMAGE_IMPORT_DESCRIPTOR) (((PBYTE)pImageBase) + (DWORD)dwOffset);

		//go through each import, try and find it, and add it to the queue
		while ((DWORD)(pImportDir->Name)!=0) {
			strcpy(pszDllName,(char*)(pImportDir->Name + ((PBYTE)pImageBase) - pImportHdr->VirtualAddress + pImportHdr->PointerToRawData));
			_strlwr(pszDllName);

			//if the ListDependencies flag is set, add this file to the dependencies list
			if (bListDependencies) {
				MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (!dependencies->Find(pwsDllName)) dependencies->Add(new StringNode(pwsDllName));	
			}

			//if this isn't ntoskrnl.exe
			if (strcmp(pszDllName,"ntoskrnl.exe")) {
				//if the file is already known to be missing
				temp = MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (pTempFile = (File*)pMissingFiles->Find(pwsDllName)) {
					dwERROR = errMISSING_DEPENDENCY;
					//add this file to the list of broken files
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( ((!pSearchPath)&&(!(SearchPath(0,pwsDllName,0,256,pszBuf,&pszBufName))))|| ((pSearchPath)&&(!SearchPath(pwsDllName,pszBuf))) ) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(pwsDllName));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));	
					}
				}	
			} else {
				//if the file is already known to be missing
				if ((pTempFile = (File*)pMissingFiles->Find(L"ntoskrnl.exe"))) {
					dwERROR = errMISSING_DEPENDENCY;
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( (((!pSearchPath)&&(!(SearchPath(0,L"ntoskrnl.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntoskrnl.exe",pszBuf)))) 
						&&(((!pSearchPath)&&(!(SearchPath(0,L"ntkrnlmp.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntkrnlmp.exe",pszBuf))))) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(L"ntoskrnl.exe"));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));
					}
				}						
			}
			pImportDir++;
		}
	}

CLEANUP:

	delete [] pszDllName;
	delete [] pszBuf;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\object.h ===
// Object.h: interface for the Object class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_OBJECT_H__21BA586D_FABE_44C0_AED8_D3175686C1F1__INCLUDED_)
#define AFX_OBJECT_H__21BA586D_FABE_44C0_AED8_D3175686C1F1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
class Object  
{
public:
	Object* next,*prev;

	Object();

	virtual TCHAR* Data();

};

#endif // !defined(AFX_OBJECT_H__21BA586D_FABE_44C0_AED8_D3175686C1F1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\object.cpp ===
// Object.cpp: implementation of the Object class.
//
//////////////////////////////////////////////////////////////////////

#include "Object.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Object::Object()
{
	next = prev = 0;
}

TCHAR* Object::Data() { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\stringnode.cpp ===
// String.cpp: implementation of the String class.
//
//////////////////////////////////////////////////////////////////////

#include "StringNode.h"
#include <string.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

StringNode::StringNode(TCHAR* s) : Object()
{
	str = new TCHAR[wcslen(s)+1];
	
    if ( str ) wcscpy(str,s);
}

TCHAR* StringNode::Data() {
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\depend\stringnode.h ===
// String.h: interface for the String class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRING_H__A4E3AB51_211E_4A38_827E_E54BC1C30803__INCLUDED_)
#define AFX_STRING_H__A4E3AB51_211E_4A38_827E_E54BC1C30803__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Object.h"

class StringNode : public Object
{
public:
	TCHAR * str;

	StringNode(TCHAR* s);

	TCHAR* Data();

};

#endif // !defined(AFX_STRING_H__A4E3AB51_211E_4A38_827E_E54BC1C30803__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\efinvram\efinvram.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    efinvram.cpp

Abstract:

    Tool that allows you to edit/view EFI
    nvram entries.

Author:

    Vijay Jayaseelan (vijayj) 02-Feb-2001

Revision History:

    None

--*/

extern "C" {
#include <efisbent.h>
#include <setupapi.h>
}

#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <tchar.h>
#include <locale>
#include "msg.h"
#include <libmsg.h>

#define MSFT_PREFIX     L"Microsoft "
#define DEFAULT_NAME    L"Windows"
#define DEFAULT_TIMEOUT 30

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR Message[4096];

//
// function prototypes
//
NTSTATUS
QueryCanonicalName(
    IN  PCWSTR  Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    );

VOID
GetFriendlyName(
    IN const std::wstring &InfFileName,
    OUT std::wstring &Buffer
    );
    
//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, (PWSTR)str.c_str());
    return os;
}

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, WCHAR *Str) {
    std::wstring WStr = Str;
    os << WStr;
    
    return os;
}

PWSTR GetOptionKey(ULONG MsgId) {
    Message[0] = TEXT('\0');
    
    GetFormattedMessage(ThisModule,
        FALSE,
        Message,
        sizeof(Message)/sizeof(Message[0]),
        MsgId);

    return Message;
}

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};
          

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;
        if (GetFormattedMessage(ThisModule,
                                TRUE,
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(MsgBuffer[0]),
                                ErrorCode)){                  
            std::wstring Msg(MsgBuffer);
            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {

    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
       
        os << PrgUsage << std::endl;
    }
};

//
// Program Arguments abstraction
//
struct ProgramArguments {
    bool ShowUsage;
    bool ListEntries;
    bool AddNewEntry;
    bool DeleteBootEntry;
    bool QuiteMode;
    bool SetActive;
    bool SetOsLoadOptions;
    bool SetTimeout;
    
    std::wstring    LoaderVolumeName;
    std::wstring    LoaderPath;
    std::wstring    BootVolumeName;
    std::wstring    BootPath;
    std::wstring    LoadOptions;
    std::wstring    FriendlyName;
    std::wstring    OsLoadOptions;

    std::wstring    AddOptionKey;
    std::wstring    DeleteOptionKey;
    std::wstring    ListOptionKey;
    std::wstring    OptionsOptionKey;
    std::wstring    SetActiveOptionKey;
    std::wstring    TimeoutOptionKey;
    
    ULONG           Timeout;
    ULONG           EntryId;
    
    
    ProgramArguments(INT Argc, WCHAR *Argv[]) {
        ShowUsage = false;        
        QuiteMode = false;
        ListEntries = AddNewEntry = DeleteBootEntry = false;
        SetActive = false;
        EntryId = -1;
        Timeout = DEFAULT_TIMEOUT;
        SetTimeout = false;

        //
        // get all the options
        //
        ListOptionKey = GetOptionKey(MSG_LIST_OPTION);
        AddOptionKey = GetOptionKey(MSG_ADD_OPTION);
        DeleteOptionKey = GetOptionKey(MSG_DELETE_OPTION);
        OptionsOptionKey = GetOptionKey(MSG_OPTIONS_OPTION);
        SetActiveOptionKey = GetOptionKey(MSG_SETACTIVE_OPTION);
        TimeoutOptionKey = GetOptionKey(MSG_TIMEOUT_OPTION);
        
        //
        // parse the arguments
        //
        for (ULONG Index=1; !ShowUsage && (Index < Argc); Index++) {            
            if (!_wcsicmp(Argv[Index], L"/q")) {
                QuiteMode = true;                
            } else if (!_wcsicmp(Argv[Index], AddOptionKey.c_str())) {               
                std::wstring  LoaderName;
                std::wstring  BootVolName;
                
                AddNewEntry = true;
                ShowUsage = true;

                if (Argc > 3) {
                    Index++;
                    LoaderName = Argv[Index++];
                    BootVolName = Argv[Index++];                    
                    ShowUsage = false;

                    for ( ; (Index < Argc) && (false == ShowUsage); Index++) {
                        if (!_wcsicmp(Argv[Index], SetActiveOptionKey.c_str())) {
                            SetActive = true;
                        } else if (!_wcsicmp(Argv[Index], OptionsOptionKey.c_str())) {
                            SetOsLoadOptions = true;
                            Index++;

                            if (Index < Argc) {
                                OsLoadOptions = Argv[Index];
                            } else {
                                ShowUsage = true;
                            }
                        } else if (!_wcsicmp(Argv[Index], TimeoutOptionKey.c_str())) {
                            SetTimeout = true;
                            Index++;

                            if (Index < Argc) {
                                PWSTR EndChar = NULL;
                                
                                Timeout = wcstoul(Argv[Index], &EndChar, 10);
                                
                                if (errno) {
                                    ShowUsage = true;
                                }
                            }
                        } else {
                            ShowUsage = true;
                        }
                    }
                    
                    //
                    // Verify the arguments
                    //
                    if (!ShowUsage) {                                            
                        if (_waccess(LoaderName.c_str(), 0) || 
                            _waccess(BootVolName.c_str(), 0)) {
                            throw new W32Error(::GetLastError());
                        }        
                
                        //
                        // Get the fully qualified NT name for
                        // the the loader volume and boot volume
                        // name
                        //  
                        WCHAR           CanonicalName[MAX_PATH];                        
                        NTSTATUS        Status;                        
                        std::wstring    NtName;
                        std::wstring    DosDevices = L"\\DosDevices\\";
                        std::wstring::size_type LoaderColonPos = LoaderName.find(L':');
                        std::wstring::size_type BootColonPos = BootVolName.find(L':');
                        
                        if (LoaderColonPos != LoaderName.npos) {
                            NtName = DosDevices + LoaderName.substr(0, LoaderColonPos + 1);

                            Status = QueryCanonicalName(NtName.c_str(),
                                        -1,
                                        CanonicalName,
                                        sizeof(CanonicalName));

                            if (NT_SUCCESS(Status)) {
                                LoaderVolumeName = CanonicalName;
                                LoaderPath = LoaderName.substr(LoaderColonPos + 1);
                            } else {
                                throw new W32Error(RtlNtStatusToDosError(Status));
                            }
                        } else {
                            throw new W32Error(ERROR_PATH_NOT_FOUND);
                        }                        
                        
                        if (BootColonPos != BootVolName.npos) {
                            NtName = DosDevices + BootVolName.substr(0, BootColonPos + 1);

                            Status = QueryCanonicalName(NtName.c_str(),
                                        -1,
                                        CanonicalName,
                                        sizeof(CanonicalName));

                            if (NT_SUCCESS(Status)) {
                                BootVolumeName = CanonicalName;
                                BootPath = BootVolName.substr(BootColonPos + 1);
                            } else {
                                throw new W32Error(RtlNtStatusToDosError(Status));
                            }
                        } else {
                            throw new W32Error(ERROR_PATH_NOT_FOUND);
                        }                                                

                        if (BootVolName[BootVolName.length() - 1] != L'\\') {
                            BootVolName += L"\\";
                        }

                        std::wstring LayoutInf = BootVolName + L"inf\\layout.inf";
                                                
                        //
                        // Verify the inf file path
                        //                    
                        if (_waccess(LayoutInf.c_str(), 0)) {
                            throw new W32Error(::GetLastError());
                        }

                        //
                        // Extract the product friendly name for the inf file
                        //
                        GetFriendlyName(LayoutInf, FriendlyName);
                    }
                }

                break;                
            } else if (!_wcsicmp(Argv[Index], ListOptionKey.c_str())) {
                ListEntries = true;
                break;
            } else if (!_wcsicmp(Argv[Index], DeleteOptionKey.c_str())) {                
                DeleteBootEntry = true;
                Index++;
                
                if (Index < Argc) {
                    PWSTR EndChar = NULL;
                    
                    EntryId = wcstoul(Argv[Index], &EndChar, 10);
                } 
                
                break;
            } else if (!_wcsicmp(Argv[Index], L"/?") ||
               !_wcsicmp(Argv[Index], L"-?") ||
               !_wcsicmp(Argv[Index], L"?") ||
               !_wcsicmp(Argv[Index], L"/h") ||
               !_wcsicmp(Argv[Index], L"-h")) {
                    ShowUsage = true;                       
            } else if (!_wcsicmp(Argv[Index], OptionsOptionKey.c_str())) {
                Index++;
                SetOsLoadOptions = true;
                
                if (Index < Argc) {
                    OsLoadOptions = Argv[Index];
                    Index++;

                    if (Index < Argc) {
                        PWSTR EndChar = NULL;
                        
                        EntryId = wcstoul(Argv[Index], &EndChar, 10);
                    }
                }

                break;
            } else if (!_wcsicmp(Argv[Index], SetActiveOptionKey.c_str())) {
                Index++;
                SetActive = true;
                
                if (Index < Argc) {
                    PWSTR EndChar = NULL;
                    
                    EntryId = wcstoul(Argv[Index], &EndChar, 10);

                    if (errno) {
                        ShowUsage = true;
                    }
                } else {
                    ShowUsage = true;
                }
                
                break;
            } else if (!_wcsicmp(Argv[Index], TimeoutOptionKey.c_str())) {
                Index++;
                SetTimeout = true;
                
                if (Index < Argc) {
                    PWSTR EndChar = NULL;
                    
                    Timeout = wcstoul(Argv[Index], &EndChar, 10);

                    if (errno) {
                        ShowUsage = true;
                    }
                } else {
                    ShowUsage = true;
                }
            } else {
                ShowUsage = true;
            }
        }            

        if (!ShowUsage) {
            ShowUsage = (!ListEntries && !AddNewEntry && !SetActive &&
                         !DeleteBootEntry && !SetOsLoadOptions && !SetTimeout);
        }                         

        if (ShowUsage) {
            throw new ProgramUsage(GetFormattedMessage( ThisModule,
                                                        FALSE,
                                                        Message,
                                                        sizeof(Message)/sizeof(Message[0]),
                                                        MSG_PGM_USAGE));
        }                        
    }

    friend std::ostream& operator<<(std::ostream &os, ProgramArguments &Args) {
        os << "List Entries : " << Args.ListEntries << std::endl;
        os << "Add Entry    : " << Args.AddNewEntry << std::endl;
        os << "Delete Entry : " << Args.DeleteBootEntry << std::endl;
        os << "QuiteMode    : " << Args.QuiteMode << std::endl;
        os << "Loader Vol   : " << Args.LoaderVolumeName << std::endl;
        os << "Loader Path  : " << Args.LoaderPath << std::endl;
        os << "Boot Vol     : " << Args.BootVolumeName << std::endl;
        os << "Boot Path    : " << Args.BootPath << std::endl;
        os << "Friendly Name: " << Args.FriendlyName << std::endl;
        os << "Load Options : " << Args.OsLoadOptions << std::endl;
        os << "Timeout      : " << std::dec << Args.Timeout << " Secs" << std::endl;
        
        return os;
    }
};


VOID
DumpOsBootEntry(
    IN  POS_BOOT_ENTRY  Entry
    )
{
    if (Entry) {
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_BOOT_ENTRY,
                                        OSBEGetId(Entry),
                                        OSBEGetFriendlyName(Entry),
                                        OSBEGetOsLoaderVolumeName(Entry),
                                        OSBEGetOsLoaderPath(Entry),
                                        OSBEGetBootVolumeName(Entry),
                                        OSBEGetBootPath(Entry),
                                        OSBEGetOsLoadOptions(Entry)));
    }
}

VOID
DumpOsBootOptions(
    IN  POS_BOOT_OPTIONS Options
    )
{
    if (Options) {
        ULONG   Index;
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_TIMEOUT_AND_BOOT_ORDER, 
                                        OSBOGetTimeOut(Options)));

        for (Index=0; 
            Index < OSBOGetOrderedBootEntryCount(Options);
            Index++) {
            wprintf(GetFormattedMessage(    ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_ORDERED_BOOT_ENTRIES,
                                            OSBOGetBootEntryIdByOrder(Options, Index)));
        }                                            
            
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_BOOT_ENTRIES));

        POS_BOOT_ENTRY  Entry = OSBOGetFirstBootEntry(Options, &Index);
        
        while (Entry) {
            DumpOsBootEntry(Entry);
            Entry = OSBOGetNextBootEntry(Options, &Index);
        }
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_ACTIVE_ENTRY));

        DumpOsBootEntry(OSBOGetActiveBootEntry(Options));
    }
}


DWORD
ListEntries(
    IN POS_BOOT_OPTIONS OsOptions 
    )
{
    DWORD Result = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        DumpOsBootOptions(OsOptions);
        Result = ERROR_SUCCESS;
    }

    return Result;
}

DWORD
AddNewEntry(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args
    )
{
    DWORD Result = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        POS_BOOT_ENTRY NewEntry;
        BOOLEAN Status = TRUE;
        
        NewEntry = OSBOAddNewBootEntry(OsOptions,
                        Args.FriendlyName.c_str(),
                        Args.LoaderVolumeName.c_str(),
                        Args.LoaderPath.c_str(),
                        Args.BootVolumeName.c_str(),
                        Args.BootPath.c_str(),
                        Args.OsLoadOptions.c_str());

        if (NewEntry) {            
            if (Args.SetActive) {
                Status = (OSBOSetActiveBootEntry(OsOptions,
                                NewEntry) != NULL);
            }
            
            if (Status && Args.SetTimeout) {
                OSBOSetTimeOut(OsOptions, Args.Timeout);
            }

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }
        } else {
            Status = FALSE;
        }            

        if (Status) {
            Result = ERROR_SUCCESS;
        } else {
            Result = ERROR_CAN_NOT_COMPLETE;
        }            
    }

    return Result;
}

DWORD
SetBootEntryOptions(
    IN POS_BOOT_OPTIONS OsOptions,
    IN const ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        POS_BOOT_ENTRY  BootEntry;
        BOOLEAN Status = FALSE;

        if (Args.EntryId != -1) {
            BootEntry = OSBOFindBootEntry(OsOptions,
                            Args.EntryId);
        } else {
            BootEntry = OSBOGetActiveBootEntry(OsOptions);
        }            

        if (BootEntry) {
            Status = (OSBESetOsLoadOptions(BootEntry, 
                            Args.OsLoadOptions.c_str()) != NULL);

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }                
        }                

        if (Status) {
            ErrorCode = ERROR_SUCCESS;
        } else {
            ErrorCode = ERROR_CAN_NOT_COMPLETE;
        }            
    }

    return ErrorCode;
}

DWORD
SetBootEntryActive(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions && (Args.EntryId != -1)) {
        POS_BOOT_ENTRY  BootEntry;
        BOOLEAN Status = FALSE;

        BootEntry = OSBOFindBootEntry(OsOptions,
                        Args.EntryId);

        if (BootEntry) {
            Status = (OSBOSetActiveBootEntry(OsOptions,
                            BootEntry) != NULL);

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }                
        }                

        if (Status) {
            ErrorCode = ERROR_SUCCESS;
        } else {
            ErrorCode = ERROR_CAN_NOT_COMPLETE;
        }            
    }
    
    return ErrorCode;
}

DWORD
DeleteBootEntry(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        POS_BOOT_ENTRY  BootEntry;
        BOOLEAN Status = FALSE;

        if (Args.EntryId != -1) {
            BootEntry = OSBOFindBootEntry(OsOptions,
                            Args.EntryId);
        } else {
            BootEntry = OSBOGetActiveBootEntry(OsOptions);
        }            

        if (BootEntry) {
            Status = OSBODeleteBootEntry(OsOptions, BootEntry);

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }                
        }                

        if (Status) {
            ErrorCode = ERROR_SUCCESS;
        } else {
            ErrorCode = ERROR_CAN_NOT_COMPLETE;
        }            
    }
    
    return ErrorCode;
}

DWORD
SetTimeout(
    IN POS_BOOT_OPTIONS OsOptions,
    IN const ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions && Args.SetTimeout) {
        OSBOSetTimeOut(OsOptions, Args.Timeout);
        ErrorCode = OSBOFlush(OsOptions) ? ERROR_SUCCESS : ERROR_CAN_NOT_COMPLETE;
    }
    
    return ErrorCode;
}

    
//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    ThisModule = GetModuleHandle(NULL);
    
    try {    
        DWORD ErrorCode = ERROR_INVALID_PARAMETER;
        ProgramArguments    Args(Argc, Argv);        
        POS_BOOT_OPTIONS    BootOptions = NULL;

        //
        // Initialize the library
        //
        if (OSBOLibraryInit((SBEMemAllocateRoutine)malloc, (SBEMemFreeRoutine)free)) {
            BootOptions = EFIOSBOCreate();
        }            

        if (!BootOptions) {
            std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_ERROR_READING_BOOT_ENTRIES) << std::endl;
            Result = 1;
        } else {
            if (Args.ListEntries) {
                ErrorCode = ListEntries(BootOptions);
            } else if (Args.AddNewEntry) {
                ErrorCode = AddNewEntry(BootOptions, Args);                                
            } else if (Args.DeleteBootEntry) {
                ErrorCode = DeleteBootEntry(BootOptions, Args);
            } else if (Args.SetOsLoadOptions) {
                ErrorCode = SetBootEntryOptions(BootOptions, Args);
            } else if (Args.SetActive) {
                ErrorCode = SetBootEntryActive(BootOptions, Args);
            } else if (Args.SetTimeout) {
                ErrorCode = SetTimeout(BootOptions, Args);
            }

            OSBODelete(BootOptions);
        }            

        if (ErrorCode != ERROR_SUCCESS) {
            throw new W32Error(ErrorCode);
        }        
    }
    catch(ProgramArguments *pArgs) {
        Result = 1;
        std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_PGM_USAGE) << std::endl;

        if (pArgs) {
            delete pArgs;
        }
    }
    catch(W32Error  *W32Err) {
        if (W32Err) {   // to make prefix happy :(
            W32Err->Dump(std::cout);
            std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_PGM_USAGE) << std::endl;
            delete W32Err;
        }   

        Result = 1;
    }
    catch(ProgramException *PrgExp) {
        Result = 1;
        PrgExp->Dump(std::cout);
        delete PrgExp;
    } catch (exception *Exp) {
        Result = 1;
        std::cout << Exp->what() << std::endl;
    }

    return Result;
}


NTSTATUS
QueryCanonicalName(
    IN  PCWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    )
/*++

Routine Description:

    Resolves the symbolic name to the specified depth. To resolve
    a symbolic name completely specify the MaxDepth as -1

Arguments:

    Name        -   Symbolic name to be resolved
    
    MaxDepth    -   The depth till which the resolution needs to
                    be carried out

    CanonicalName   -   The fully resolved name

    SizeOfBufferInBytes -   The size of the CanonicalName buffer in
                            bytes                           

Return Value:

    Appropriate NT status code

--*/    
{
    UNICODE_STRING      name, canonName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    ULONG               CurrentDepth;

    RtlInitUnicodeString(&name, Name);

    canonName.MaximumLength = (USHORT) (SizeOfBufferInBytes - sizeof(WCHAR));
    canonName.Length = 0;
    canonName.Buffer = CanonicalName;

    if (name.Length >= canonName.MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(canonName.Buffer, name.Buffer, name.Length);
    canonName.Length = name.Length;
    canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;

    for (CurrentDepth = 0; CurrentDepth < MaxDepth; CurrentDepth++) {

        InitializeObjectAttributes(&oa, &canonName, OBJ_CASE_INSENSITIVE, 0, 0);

        status = NtOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);
        if (!NT_SUCCESS(status)) {
            break;
        }

        status = NtQuerySymbolicLinkObject(handle, &canonName, NULL);
        NtClose(handle);

        if (!NT_SUCCESS(status)) {
            return status;
        }
        
        canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;
    }

    return STATUS_SUCCESS;
}


#define PRODUCT_NAME_KEY  TEXT("productname")

VOID
GetFriendlyName(
    IN const std::wstring &InfFileName,
    OUT std::wstring &FriendlyName
    )
{
    UINT    ErrorLine = 0;
    BOOL    Status = FALSE;
    HINF    InfHandle = ::SetupOpenInfFile(InfFileName.c_str(),
                            NULL,
                            INF_STYLE_WIN4,
                            &ErrorLine);

    if (InfHandle != INVALID_HANDLE_VALUE) {
        INFCONTEXT  InfContext = {0};
        WCHAR       Buffer[MAX_PATH] = {0};

        //
        // get the key
        //
        Status = SetupFindFirstLine(InfHandle,
                            TEXT("Strings"),
                            PRODUCT_NAME_KEY,
                            &InfContext);

        if (Status) {            
            //
            // If we found the key extract the description
            //
            Status = SetupGetStringField(&InfContext,
                        1,
                        Buffer,
                        ARRAY_SIZE(Buffer),
                        NULL);

            if (Status) {               
                FriendlyName = Buffer;
            }
        }
        
        SetupCloseInfFile(InfHandle);
    }        

    //
    // If we didn't find the description use default description
    //
    if (!Status) {        
        FriendlyName = DEFAULT_NAME;
    }

    FriendlyName = MSFT_PREFIX + FriendlyName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\dskimage\dskimage.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dskimage.cpp

Abstract:

    Tool to create images of floppy disks.

    NOTE: Currently used by WinPE image creation
    script for IA64 ISO CD image

Author:

    Vijay Jayaseelan (vijayj)   12 March 2001

Revision History:

    None.
    
--*/

#include <iostream>
#include <string>
#include <windows.h>
#include "msg.h"
#include <libmsg.h>

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR Message[4096];

//
// Helper dump operators
//
inline
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fputws(str.c_str(), OutStream);
    return os;
}

inline
std::ostream& operator<<(std::ostream &os, PCTSTR str) {
    return os << std::wstring(str);
}

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;
        if (GetFormattedMessage(ThisModule,
                                FALSE,
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(MsgBuffer[0]),
                                ErrorCode)){
            std::wstring Msg(MsgBuffer);
            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {
    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
        
        os << PrgUsage << std::endl;
        
    }
};


//
// Argument cracker
//
struct ProgramArguments {
    std::wstring    DriveLetter;
    std::wstring    ImageName;

    ProgramArguments(int Argc, wchar_t *Argv[]) {
        bool ValidArgs = false;
        bool ShowUsage = false;

        for (ULONG Index = 1; !ShowUsage && (Index < Argc); Index++) {
            ShowUsage = !_wcsicmp(Argv[Index], TEXT("/?"));
        }
        
        if (!ShowUsage && (Argc > 2)) {
            DriveLetter = Argv[1];
            ImageName = Argv[2];

            ValidArgs = ((DriveLetter.length() == 2) &&
                         (DriveLetter[1] == TEXT(':')));
        }            

        if (!ValidArgs) {
            throw new ProgramUsage(GetFormattedMessage( ThisModule,
                                                        FALSE,
                                                        Message,
                                                        sizeof(Message)/sizeof(Message[0]),
                                                        MSG_PGM_USAGE));
        }

        DriveLetter = TEXT("\\\\.\\") + DriveLetter;
    }

    friend std::ostream& operator<<(std::ostream &os, const ProgramArguments &Args) {
        os << GetFormattedMessage(  ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_DRVLETTER_AND_IMGNAME,
                                    Args.DriveLetter,
                                    Args.ImageName) << std::endl;
        return os;
    }
};

//
// Prototypes
//
VOID
CreateImage(
    IN const ProgramArguments &Args
    )
{
    DWORD Error = ERROR_SUCCESS;

    //
    // Open the source file
    //
    HANDLE  SourceHandle = CreateFile(Args.DriveLetter.c_str(),
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);


    if (SourceHandle == INVALID_HANDLE_VALUE) {
        throw new W32Error();
    }

    //
    // Open the destination file
    //
    HANDLE  DestHandle = CreateFile(Args.ImageName.c_str(),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (DestHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();

        CloseHandle(SourceHandle);
        throw new W32Error(Error);
    }

    //
    // Read contents of the source and write it to destination
    //
    LPBYTE   lpBuffer = NULL;
    DWORD    BufferSize = 64 * 1024;
    DWORD    BytesRead = 0, BytesWritten = 0;
    LONGLONG TotalBytesWritten = 0;

    lpBuffer = (LPBYTE) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, BufferSize );
    if ( lpBuffer )
    {
        while (ReadFile(SourceHandle, lpBuffer, BufferSize, &BytesRead, NULL) &&
               BytesRead &&
               WriteFile(DestHandle, lpBuffer, BytesRead, &BytesWritten, NULL) &&
               (BytesRead == BytesWritten)) 
        {
            TotalBytesWritten += BytesWritten;           
            BytesRead = BytesWritten = 0;
        }

        HeapFree( GetProcessHeap(), 0, lpBuffer);
    }

    //
    // Cleanup
    //
    Error = GetLastError();
    CloseHandle(SourceHandle);
    CloseHandle(DestHandle);

    //
    // Check, if the operation was successful ?
    //
    if (!TotalBytesWritten || (BytesRead != BytesWritten)) {
        throw new W32Error(Error);
    }
}

//
// Main entry point
//
INT
__cdecl
wmain(
    IN INT  Argc, 
    IN WCHAR *Argv[]
    )
{
    INT Result = 0;
    ThisModule = GetModuleHandle(NULL);
    
    try {
        ProgramArguments    Args(Argc, Argv);

        CreateImage(Args);
    }
    catch(W32Error *Error) {
        if (Error) {
            Result = (INT)(Error->ErrorCode);
            Error->Dump(std::cout);
            delete Error;
        }                
    }
    catch(ProgramException *Exp) {
        if (Exp) {
            Exp->Dump(std::cout);
            delete Exp;
        }            
    }
    catch(...) {
        Result = 1;
    } 

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\factory\autologon.c ===
#include "factoryp.h"
#include <regstr.h>

// [ComputerSettings]
// AuditAdminAutoLogon=Yes
// AutoLogon=Yes
//
#define REGSTR_PATH_WINNTLOGON  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEFAULT_PWD             TEXT("")
#define DEFAULT_VALUE           TEXT("1")

BOOL AutoLogon(LPSTATEDATA lpStateData)
{
    HKEY    hKey;
    BOOL    fReturn = FALSE;

    // Check the winbom to make sure they want the auto logon set.
    //
    if ( !DisplayAutoLogon(lpStateData) )
    {
        return TRUE;
    }

    // Now open the key and set the required values (see KB article Q253370).
    //
    if ( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_WINNTLOGON, &hKey) )
    {
        LPTSTR lpszUserName = AllocateString(NULL, ( GetSkuType() == VER_SUITE_PERSONAL ) ? IDS_OWNER : IDS_ADMIN);

        // The following three keys sets the auto admin logon after reboot.  If the
        // password is empty string the AutoAdminLogon will be reset after reboot.
        //
        // 
        if ( ( lpszUserName ) &&
             ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("DefaultUserName"), 0, REG_SZ, (LPBYTE) lpszUserName, (lstrlen(lpszUserName)  + 1) * sizeof(TCHAR)) ) &&
             ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("DefaultPassword"), 0, REG_SZ, (LPBYTE) DEFAULT_PWD,  (lstrlen(DEFAULT_PWD)   + 1) * sizeof(TCHAR)) ) &&
             ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("AutoAdminLogon"),  0, REG_SZ, (LPBYTE) DEFAULT_VALUE,(lstrlen(DEFAULT_VALUE) + 1) * sizeof(TCHAR)) ) &&
             ( ERROR_SUCCESS == RegDeleteValue(hKey, TEXT("AutoLogonCount")) ) )
        {
            fReturn = TRUE;
        }

        // Force so subsequent reboots won't reset AutoAdminLogon because of empty password.
        //
        // We don't need to force autologon for every reboot since the [ComputerSettings] section will be processed for
        // every boot.
        //
        //   ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("ForceAutoLogon"),  0, REG_SZ, (LPBYTE) DEFAULT_VALUE, (lstrlen(DEFAULT_VALUE) + 1) * sizeof(TCHAR)) )

        // Free the allocated user name (macro checks for NULL).
        //
        FREE(lpszUserName);

        // Close the registry key.
        //
        RegCloseKey(hKey);
    }

    return fReturn;
}

BOOL DisplayAutoLogon(LPSTATEDATA lpStateData)
{
    return ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_AUTOLOGON_OLD, INI_VAL_WBOM_YES) ||
             IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_AUTOLOGON, INI_VAL_WBOM_YES) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\factory\extpart.c ===
/****************************************************************************\

    EXTPART.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the extend partition state
    functions.

    05/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for extending the system
        partition.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// Internal Define(s):
//

#define ENV_SYSTEMDRIVE     _T("%SystemDrive%")


//
// External Function(s):
//

BOOL ExtendPart(LPSTATEDATA lpStateData)
{
    BOOL    bRet = TRUE;
    LPTSTR  lpszDrive;
    ULONG   uSize;

    // Only need to do anything if the key exists.
    //
    if ( DisplayExtendPart(lpStateData) )
    {
        // At this point, if anything doesn't work we
        // should return FALSE.
        //
        bRet = FALSE;

        // Get the size to use for the partition.  If it is one, then just pass
        // zero so it uses all the free space.  We also need to know the drive
        // to extend.
        //
        uSize = (ULONG) GetPrivateProfileInt(INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_EXTENDPART, 0, lpStateData->lpszWinBOMPath);
        if ( ( uSize > 0 ) &&
             ( lpszDrive = AllocateExpand(ENV_SYSTEMDRIVE) ) )
        {
            bRet = SetupExtendPartition(*lpszDrive, (1 == uSize) ? 0 : uSize);
            FREE(lpszDrive);
        }
    }

    return bRet;
}

BOOL DisplayExtendPart(LPSTATEDATA lpStateData)
{
    return ( GetPrivateProfileInt(INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_EXTENDPART, 0, lpStateData->lpszWinBOMPath) > 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\factory\factory.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    factory.c

Abstract:

    Factory Pre-install application.  This application will be used to perform
    pre-installation task in an OEM factory, or system builder (SB) setting.

    The task performed will be:
        Minimal boot (minimal device and services loaded)
        WinBOM processing
            Download updated device drivers from NET
            Process OOBE info
            Process User/Customer specific settings
            Process OEM user specific customization
            Process Application pre-installations
        PnPDevice enumeration
        Exit to Windows for Audit mode work.

Author:

    Donald McNamara (donaldm) 2/8/2000

Revision History:

--*/


//
// Include File(s):
//

#include "factoryp.h"
#include "shlobj.h"
#include "states.h" // should only ever be included by one c file.


//
// Defined Value(s):
//

#define FILE_WINBOM             _T("winbom")
#define FILE_OOBE               _T("oobe")
#define FILE_BAT                _T(".bat")
#define FILE_CMD                _T(".cmd")

#define REG_VAL_FIRSTPNP        _T("PnPDetection")
#define PNP_INSTALL_TIMEOUT     600000  // 10 minutes

#define SZ_ENV_RESOURCE         _T("ResourceDir")
#define SZ_ENV_RESOURCEL        _T("ResourceDirL")


//
// Defined Macro(s):
//

#define CHECK_PARAM(lpCmdLine, lpOption)    ( LSTRCMPI(lpCmdLine, lpOption) == 0 )


//
// Type Definition(s):
//


//
// External Global Variable(s):
//

// UI stuff...
//
HINSTANCE   g_hInstance                 = NULL;

// Global factory flags.
DWORD       g_dwFactoryFlags            = 0;


// Debug Level - used for logging.
// 
#ifdef DBG
    DWORD   g_dwDebugLevel              = LOG_DEBUG;
#else   
    DWORD   g_dwDebugLevel              = 0;
#endif


// Path to the WinBOM file.
//
TCHAR       g_szWinBOMPath[MAX_PATH]    = NULLSTR;

// Path to the WinBOM log file.
//
TCHAR       g_szLogFile[MAX_PATH]       = NULLSTR;

// Path to FACTORY.EXE.
//
TCHAR       g_szFactoryPath[MAX_PATH]   = NULLSTR;

// Path to the sysprep directory (where factory.exe must be located).
//
TCHAR       g_szSysprepDir[MAX_PATH]    = NULLSTR;


//
// Internal Golbal Variable(s):
//

// This determines the mode that factory will run in and is set based on
// the command line parameters.
//
FACTMODE    g_fm = modeUnknown;


//
// Internal Function Prototype(s):
//

static BOOL ParseCmdLine();
static BOOL IsUserAdmin();
static BOOL RunBatchFile(LPTSTR lpszSysprepFolder, LPTSTR lpszBaseFileName);
static BOOL CheckSetEnv(LPCTSTR lpName, LPCTSTR lpValue);
static void SetupFactoryEnvironment();


/*++
===============================================================================
Routine Description:

    This routine is the main entry point for the program.

    We do a bit of error checking, then, if all goes well, we update the
    registry to enable execution of our second half.

===============================================================================
--*/

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine,
                     int nCmdShow)
{
    HANDLE      hMutex;

    LPTSTR      lpFilePart  = NULL,
                lpMode      = NULL,
                lpBatchFile = NULL;
    DWORD       dwLocate,
                cbStates    = 0;
    LPSTATES    lpStates    = NULL;
    BOOL        bBadCmdLine,
                bOldVersion = FALSE;
                

    // Save the instance handle globally.
    //
    g_hInstance = hInstance;

    // This causes the system not to display the critical-error-handler
    // message box.  Instead, the system sends the error to the calling
    // process.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);    

    // We need the path to factory.exe and where it is located.
    //
    if ( GetModuleFileName(NULL, g_szFactoryPath, AS ( g_szFactoryPath ) ) && 
            GetFullPathName(g_szFactoryPath, AS(g_szSysprepDir), g_szSysprepDir, &lpFilePart) && g_szSysprepDir[0] && lpFilePart )
    {
        // Chop off the file name.
        //
        *lpFilePart = NULLCHR;
    }

    // If either of those file, we must quit (can't imagine that every happening).
    //
    // ISSUE-2002/02/25-acosma,robertko - why are we checking for g_szFactoryPath here when we already used it above?
    //
    if ( ( g_szFactoryPath[0] == NULLCHR ) || ( g_szSysprepDir[0] == NULLCHR ) )
    {
        // Can we log this failure?
        //
        return 0;
    }

    // This will setup special factory environment variables.
    //
    SetupFactoryEnvironment();

    //
    // Check to see if we are allowed to run on this build of the OS.
    //
    if ( !OpklibCheckVersion( VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE ) )
    {
        bOldVersion = TRUE;
    }

#ifdef DBG
    // In debug builds, lets always try to log right away.  In
    // the retail case we want to wait until after we locate the
    // winbom before we start our logging.
    //
    InitLogging(NULL);
    FacLogFileStr(3, _T("DEBUG: Starting factory (%s)."), GetCommandLine());
#endif

    // Check the command line for options (but don't error
    // till we have the log file up).
    //
    bBadCmdLine = ( !ParseCmdLine() || ( g_fm == modeUnknown ) );

    // Need to find the mode stuff: string, flags, and states.
    //
    dwLocate = LOCATE_NORMAL;
    switch ( g_fm )
    {
        case modeLogon:
            dwLocate = LOCATE_AGAIN;
            SET_FLAG(g_dwFactoryFlags, FLAG_LOGGEDON);
            lpStates = &g_FactoryStates[0];
            cbStates = AS(g_FactoryStates);
            lpMode = INI_VAL_WBOM_TYPE_FACTORY;
            break;

        case modeSetup:
            lpStates = &g_FactoryStates[0];
            cbStates = AS(g_FactoryStates);
            lpMode = INI_VAL_WBOM_TYPE_FACTORY;
            lpBatchFile = FILE_WINBOM;
            break;

        case modeWinPe:
            lpStates = &g_MiniNtStates[0];
            cbStates = AS(g_MiniNtStates);
            // Fall through...
        case modeMiniNt:
            lpMode = INI_VAL_WBOM_TYPE_WINPE;
            break;

        case modeOobe:
            dwLocate = LOCATE_NONET;
            SET_FLAG(g_dwFactoryFlags, FLAG_NOUI);
            SET_FLAG(g_dwFactoryFlags, FLAG_OOBE);
            lpStates = &g_OobeStates[0];
            cbStates = AS(g_OobeStates);
            lpMode = INI_VAL_WBOM_TYPE_OOBE;
            lpBatchFile = FILE_OOBE;
            break;

        default:
            lpMode = NULL;
    }

    // If the mode isn't setup, then pnp is already started.
    // Otherwise if this is the first run of factory, wait
    // for pnp before all else.
    //
    if ( modeSetup != g_fm )
    {
        SET_FLAG(g_dwFactoryFlags, FLAG_PNP_STARTED);
    }
    else if ( !bBadCmdLine && !bOldVersion && !RegCheck(HKLM, REG_FACTORY_STATE, REG_VAL_FIRSTPNP) )
    {
        // Kick off pnp this first time so we can get the winbom
        // off the floppy or cd-rom.
        //
        if ( StartPnP() )
        {
            WaitForPnp(PNP_INSTALL_TIMEOUT);
        }

        // Make sure we don't do this every boot.
        //
        // ISSUE-2002/02/25-acosma,robertko - We should only set this if PNP successfully started. Move into above block?
        //
        RegSetString(HKLM, REG_FACTORY_STATE, REG_VAL_FIRSTPNP, _T("1"));
    }

    // Run the batch file if we are running from the setup key.
    //
    if ( !bBadCmdLine && !bOldVersion && lpBatchFile )
    {
        RunBatchFile(g_szSysprepDir, lpBatchFile);
    }

    // Find the WinBOM (just use the one previously found if we
    // are in the logon mode).
    //
    LocateWinBom(g_szWinBOMPath, AS(g_szWinBOMPath), g_szSysprepDir, lpMode, dwLocate);

    // Find out if we're running on IA64.
    //
    if ( IsIA64() )
        SET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE);

    // Try to enable logging. This checks the WinBOM.
    //
    // ISSUE-2002/02/25-acosma,robertko - in debug mode we have already done this.  We end up doing this twice. Make sure this is ok.
    //
    InitLogging(g_szWinBOMPath);
    
    // Only let one of this guy run.
    //
    hMutex = CreateMutex(NULL,FALSE,TEXT("FactoryPre Is Running"));
    if ( hMutex == NULL )
    {
        FacLogFile(0 | LOG_ERR, MSG_OUT_OF_MEMORY);
        return 0;
    }

    // Make sure we are the only process with a handle to our named mutex.
    //
    if ( GetLastError() == ERROR_ALREADY_EXISTS )
    {
        FacLogFile(0 | LOG_ERR, MSG_ALREADY_RUNNING);

        // Destroy the mutex and bail.
        //
        CloseHandle(hMutex);
        return 0;
    }

    // Now we can log and return if there was a
    // bad command line passed to factory.
    //
    if ( bBadCmdLine )
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_INVALIDCMDLINE);

        // Destroy the mutex and bail.
        //
        CloseHandle(hMutex);
        return 0;
    }
    
    // 
    // Now we can log and put up an error message if necessary in case the version of tool is too old.
    //
    if ( bOldVersion )
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_NOT_ALLOWED);
        
        CloseHandle(hMutex);
        return 0;
    }
    
    // Make sure we have a WinBOM file.
    //
    if ( g_szWinBOMPath[0] == NULLCHR )
        FacLogFile(( g_fm == modeLogon ) ? (2 | LOG_ERR) : (0 | LOG_ERR), IDS_ERR_MISSINGWINBOM);
    else
        FacLogFile(( g_fm == modeLogon ) ? 2 : 0, IDS_LOG_WINBOMLOCATION, g_szWinBOMPath);

    // Ensure that the user is in the admin group.
    //
    if ( ( g_fm != modeMiniNt ) && ( g_fm != modeWinPe ) && ( !IsUserAdmin() ) )
    {
        FacLogFile(0 | LOG_ERR, MSG_NOT_AN_ADMINISTRATOR);

        // Destroy the mutex and bail.
        //
        CloseHandle(hMutex);
        return 0;
    }

    // We don't do the state thing in MiniNT mode right now (but we could).
    // The modeMiniNt mode is only temporary the real mode in modeWinPe.
    //
    if ( g_fm == modeMiniNt )
    {
        // ISSUE-2002/02/25-acosma,robertko - This function does not check if we are running on WinPE, so users can just run factory -mini on any 
        // machine.
        // 
        if ( !SetupMiniNT() )
        {
            FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to install network adapter -- check WINBOM");
        }
    }
    else
    {
        // Make sure factory will always run.
        //
        if ( modeWinPe == g_fm )
        {
            HKEY  hKey;
            
            // Make sure that if we are in "-winpe" mode we only run under WinPE
            //
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\MiniNT"), 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
            {
                RegCloseKey(hKey);
            }
            else 
            {
                FacLogFile(0 | LOG_ERR, IDS_ERR_NOT_WINPE);
                
                // Destroy the mutex and bail.
                CloseHandle(hMutex);
                return 0;
            }
        }
        else if ( modeOobe != g_fm )
        {
            HKEY hKey;

            // Open the key, and set the proper SetupType value.
            //
            // Very important not to ever change this value in OOBE
            // mode!
            //
            if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\Setup"), 0, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS )
            {
                DWORD dwValue = SETUPTYPE_NOREBOOT;
                RegSetValueEx(hKey, TEXT("SetupType"), 0, REG_DWORD, (CONST LPBYTE) &dwValue, sizeof(DWORD));
            }
        }

        // Now process the winbom.ini file.
        //
        if ( lpStates && cbStates )
        {
            ProcessWinBOM(g_szWinBOMPath, lpStates, cbStates);
        }
#ifdef DBG
        else
        {
            FacLogFileStr(3, _T("DEBUG: ProcessWinBOM() error... lpStates or cbStates not set."));
        }
#endif
    }

    // Close the Mutex.
    //
    CloseHandle(hMutex);

    return 0;
}


//
// Internal Function(s):
//

static BOOL ParseCmdLine()
{
    DWORD   dwArgs;
    LPTSTR  *lpArgs;
    BOOL    bError = FALSE;


    // ISSUE-2002/02/25-acosma,robertko - this is really contorted, we seem to have our own implementation of CommandLineToArgvW inside this 
    // GetCommandLineArgs() function.  Just use the Win32 function.  Should be safer.
    //
    if ( (dwArgs = GetCommandLineArgs(&lpArgs) ) && lpArgs )
    {
        LPTSTR  lpArg;
        DWORD   dwArg;

        // We want to skip over the first argument (it is the path
        // to the command being executed.
        //
        if ( dwArgs > 1 )
        {
            dwArg = 1;
            lpArg = *(lpArgs + dwArg);
        }
        else
            lpArg = NULL;

        // Loop through all the arguments.
        //
        while ( lpArg && !bError )
        {
            // Now we check to see if the first char is a dash or not.
            //
            if ( *lpArg == _T('-') )
            {
                LPTSTR lpOption = CharNext(lpArg);

                // This is where you add command line options that start with a dash (-).
                //
                // ISSUE-2002/02/25-acosma,robertko - We don't validate correct combinations of arguments.  I can run
                // "factory -setup -logon -winpe -oobe" and the last argument would be the one that is
                // picked up.  We should fix this and make it smarter.
                //
                if ( CHECK_PARAM(lpOption, _T("setup")) )
                    g_fm = modeSetup;
                else if ( CHECK_PARAM(lpOption, _T("logon")) )
                    g_fm = modeLogon;
                else if ( CHECK_PARAM(lpOption, _T("minint")) )
                    g_fm = modeMiniNt;
                else if ( CHECK_PARAM(lpOption, _T("winpe")) ) 
                    g_fm = modeWinPe;
                else if ( CHECK_PARAM(lpOption, _T("oobe")) ) 
                    g_fm = modeOobe;
                else
                    bError = TRUE;
            }
            else if ( *lpArg )
            {
                bError = TRUE;
            }

            // Setup the pointer to the next argument in the command line.
            //
            if ( ++dwArg < dwArgs )
                lpArg = *(lpArgs + dwArg);
            else
                lpArg = NULL;
        }

        // Make sure to free the two buffers allocated by the GetCommandLineArgs() function.
        //
        FREE(*lpArgs);
        FREE(lpArgs);
    }

    return !bError;
}

/*++ 

Routine Description: 
    This routine returns TRUE if the caller's process is a 
    member of the Administrators local group. Caller is NOT 
    expected to be impersonating anyone and is expected to 
    be able to open their own process and process token. 

Arguments: 

    None. 

Return Value: 
   
   TRUE - Caller has Administrators local group. 
   FALSE - Caller does not have Administrators local group. --
*/ 

static BOOL IsUserAdmin(VOID) 
{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup; 
    
    b = AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &AdministratorsGroup); 
    
    if(b) 
    {
        if (!CheckTokenMembership( NULL, AdministratorsGroup, &b)) 
        {
             b = FALSE;
        } 
        FreeSid(AdministratorsGroup); 
    }
    
    return(b);
}

/*++

Routine Description:

    This routine ckecks WinBOM setting for logging.  Logging 
    is enabled by default if nothing is specified in the 
    WinBOM.  Disables logging by setting g_szLogFile = NULL.
    
Arguments:

    None.

Return Value:

    None.

--*/

VOID InitLogging(LPTSTR lpszWinBOMPath)
{
    TCHAR   szScratch[MAX_PATH] = NULLSTR;
    LPTSTR  lpszScratch;
    BOOL    bWinbom = ( lpszWinBOMPath && *lpszWinBOMPath );

    // First check if logging is disabled in the WinBOM.
    //
    if ( ( bWinbom ) &&
         ( GetPrivateProfileString(WBOM_FACTORY_SECTION, WBOM_FACTORY_LOGGING, _T("YES"), szScratch, AS(szScratch), lpszWinBOMPath) ) &&
         ( LSTRCMPI(szScratch, _T("NO")) == 0 ) )
    {
        g_szLogFile[0] = NULLCHR;
    }
    else
    {
        // All these checks can only be done if we have a winbom.
        //
        if ( bWinbom )
        {
            // Check for quiet mode.  If we are in quiet mode don't display any MessageBoxes. 
            // This only works for WinPE mode.
            //
            if ( (GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_QUIET, NULLSTR, szScratch, AS(szScratch), lpszWinBOMPath) ) &&
                 (0 == LSTRCMPI(szScratch, WBOM_YES))
               )
            {
                SET_FLAG(g_dwFactoryFlags, FLAG_QUIET_MODE);
            }

            // See if they want to turn on perf logging.
            //
            szScratch[0] = NULLCHR;
            if ( ( GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_LOGPERF, NULLSTR, szScratch, AS(szScratch), lpszWinBOMPath) ) &&
                 ( 0 == LSTRCMPI(szScratch, WBOM_YES) ) )
            {
                SET_FLAG(g_dwFactoryFlags, FLAG_LOG_PERF);
            }
        
            // Set the logging level.
            //
            g_dwDebugLevel = (DWORD) GetPrivateProfileInt(WBOM_FACTORY_SECTION, INI_KEY_WBOM_LOGLEVEL, (DWORD) g_dwDebugLevel, lpszWinBOMPath);
        }

        //
        // In non-debug builds we do not want the log level to be set at LOG_DEBUG.  Force it
        // to drop down by one level if set at LOG_DEBUG or higher.
        //
#ifndef DBG
        if ( g_dwDebugLevel >= LOG_DEBUG )
            g_dwDebugLevel = LOG_DEBUG - 1;
#endif
        
        // Check to see if they have a custom log file they want to use.
        //
        if ( ( bWinbom ) &&
             ( lpszScratch = IniGetExpand(lpszWinBOMPath, INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_FACTORY_LOGFILE, NULL) ) )
        {
            TCHAR   szFullPath[MAX_PATH]    = NULLSTR;
            LPTSTR  lpFind                  = NULL;

            // Turn the ini key into a full path.
            //
            lstrcpyn( g_szLogFile, lpszScratch, AS( g_szLogFile ) );
            if (GetFullPathName(g_szLogFile, AS(szFullPath), szFullPath, &lpFind) && szFullPath[0] && lpFind)
            {
                // Copy the full path into the global.
                //
                lstrcpyn(g_szLogFile, szFullPath, AS(g_szLogFile));

                // Chop off the file part so we can create the
                // path if it doesn't exist.
                //
                *lpFind = NULLCHR;

                // If the directory cannot be created or doesn't exist turn off logging.
                //
                if (!CreatePath(szFullPath))
                    g_szLogFile[0] = NULLCHR;
            }

            // Free the original path buffer from the ini file.
            //
            FREE(lpszScratch);
        }
        else  // default case
        {
            // Create it in the current directory (g_szSysprepDir)
            //
            lstrcpyn(g_szLogFile, g_szSysprepDir, AS ( g_szLogFile ) );
            AddPathN(g_szLogFile, WINBOM_LOGFILE, AS ( g_szLogFile ));
        }

        // Check to see if we have write access to the logfile. If we don't, turn off logging.
        // If we're running in WinPE we'll call this function again once the drive becomes
        // writable.
        //
        // Write an FFFE header to the file to identify this as a Unicode text file.
        //
        if ( g_szLogFile[0] )
        {
            HANDLE hFile;
            DWORD dwWritten = 0;
            WCHAR cHeader =  0xFEFF;
     
            SetLastError(ERROR_SUCCESS);
   
            if ( INVALID_HANDLE_VALUE != (hFile = CreateFile(g_szLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
            {   
                // BUBBUG: This should check for an existing header in the file.  There could be an empty
                // file with no header.
                //
                if ( ERROR_ALREADY_EXISTS != GetLastError() )
                    WriteFile(hFile, &cHeader, sizeof(cHeader), &dwWritten, NULL);
                CloseHandle(hFile);
            }
            else
            {   // There was a problem opening the file.  Most of the time this means that the media is not writable.
                // Disable logging in that case.
                //
                g_szLogFile[0] = NULLCHR;
            }
        }
    }
}

static BOOL RunBatchFile(LPTSTR lpszSysprepFolder, LPTSTR lpszBaseFileName)
{
    BOOL    bRet                    = FALSE;
    TCHAR   szCmdLine[]             = NULLSTR,
            szWinbomBat[MAX_PATH];
    LPTSTR  lpExtension;
    DWORD   dwExitCode;

    // First make the fullpath to where the batch file should be.
    //
    lstrcpyn(szWinbomBat, lpszSysprepFolder, AS(szWinbomBat));
    AddPathN(szWinbomBat, lpszBaseFileName, AS(szWinbomBat) );
    lpExtension = szWinbomBat + lstrlen(szWinbomBat);

    // Make sure there is still enough room for the extension.
    //
    if ( ((lpExtension + 4) - szWinbomBat ) >= AS(szWinbomBat) )
    {
        return FALSE;
    }

    // First try winbom.cmd.
    //
    lstrcpyn(lpExtension, FILE_CMD, AS ( szWinbomBat )  - lstrlen ( szWinbomBat ) );
    if ( FileExists(szWinbomBat) )
    {
        bRet = InvokeExternalApplicationEx(szWinbomBat, szCmdLine, &dwExitCode, INFINITE, GET_FLAG(g_dwFactoryFlags, FLAG_NOUI));
    }
    else
    {
        // Also try winbom.bat if that one didn't exist.
        //
        lstrcpyn(lpExtension, FILE_BAT, AS ( szWinbomBat ) - lstrlen ( szWinbomBat ) );
        if ( FileExists(szWinbomBat) )
        {
            bRet = InvokeExternalApplicationEx(szWinbomBat, szCmdLine, &dwExitCode, INFINITE, GET_FLAG(g_dwFactoryFlags, FLAG_NOUI));
        }
    }

    return bRet;
}

static BOOL CheckSetEnv(LPCTSTR lpName, LPCTSTR lpValue)
{
    if ( 0 == GetEnvironmentVariable(lpName, NULL, 0) )
    {
        SetEnvironmentVariable(lpName, lpValue);
        return TRUE;
    }
    return FALSE;
}

static void SetupFactoryEnvironment()
{
    TCHAR szPath[MAX_PATH];

    szPath[0] = NULLCHR;
    if ( SHGetSpecialFolderPath(NULL, szPath, CSIDL_RESOURCES, 0) && szPath[0] )
    {
        CheckSetEnv(SZ_ENV_RESOURCE, szPath);
    }

    szPath[0] = NULLCHR;
    if ( SHGetSpecialFolderPath(NULL, szPath, CSIDL_RESOURCES_LOCALIZED, 0) && szPath[0] )
    {
        CheckSetEnv(SZ_ENV_RESOURCEL, szPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\factory\factoryp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    factoryp.h

Abstract:

    Private top-level header file for Factory Pre-install module.

Author:

    Donald McNamara (donaldm) 2/8/2000

Revision History:

    - Added exported prototypes from preinstall.c: Jason Lawrence (t-jasonl) 6/7/2000
    - Added DeleteTree() prototype: Jason Lawrence (t-jasonl) 6/7/2000
    - Added additional prototypes from misc.c and log.c: Jason Lawrence (t-jasonl) 6/14/2000

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpoapi.h>
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <commctrl.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <lmuse.h>
#include <msi.h>
#include <msiquery.h>
#include <regstr.h>
#include <limits.h>
#include <powrprof.h>
#include <syssetup.h>
#include <opklib.h>            // OPK common functions
#include <strsafe.h>
#include <ntverp.h>

#include "msg.h"
#include "res.h"
#include "winbom.h"
#include "status.h"

//
// Defined Value(s):
//

// Flags for Logging
//
// Some of these flags are also defined in opklib.h. ( Planning to use opklib for all logging in the future. )  
// 


#define LOG_DEBUG               0x00000003    // Only log in debug builds if this is specified. (Debug Level for logging.)
#define LOG_LEVEL_MASK          0x0000000F    // Mask to only show the log level bits
#define LOG_MSG_BOX             0x00000010    // Display the message boxes if this is enabled.
#define LOG_ERR                 0x00000020    // Prefix the logged string with "Error:" if the message is level 0,
                                              // or "WARNx" if the message is at level x > 0.
#define LOG_TIME                0x00000040    // Display time if this is enabled
#define LOG_NO_NL               0x00000080    // Don't add new Line to the end of log string if this is set.

// Other factory flags
//
#define FLAG_STOP_ON_ERROR      0x00000001    // Stop on error.  We should not really use this.
#define FLAG_QUIET_MODE         0x00000002    // Quiet mode: do not display any message boxes.
#define FLAG_IA64_MODE          0x00000004    // Set if factory is running on an Itanium machine.
#define FLAG_LOG_PERF           0x00000008    // If set, log how long each state takes to run.
#define FLAG_PNP_DONE           0x00000010    // If set, we know for sure that pnp is done.
#define FLAG_PNP_STARTED        0x00000020    // If set, we have already started pnp.
#define FLAG_LOGGEDON           0x00000040    // Only set when we are logged in.
#define FLAG_NOUI               0x00000080    // Set if we don't want to show any UI in factory.
#define FLAG_OOBE               0x00000100    // Set if we are launched from OOBE.

// Flags for the STATE structure.
//
#define FLAG_STATE_NONE         0x00000000
#define FLAG_STATE_ONETIME      0x00000001  // Set if this state should only be executed once, not for every boot.
#define FLAG_STATE_NOTONSERVER  0x00000002  // Set if this state should not run on server SKUs.
#define FLAG_STATE_QUITONERR    0x00000004  // Set if no other states should run if this state fails.
#define FLAG_STATE_DISPLAYED    0x00000008  // Set only at run time, and only if the item is displayed in the status window.

#define ALWAYS                  DisplayAlways
#define NEVER                   NULL

// Log files.
//
#define WINBOM_LOGFILE          _T("WINBOM.LOG")

// Registry strings.
//
#define REG_FACTORY_STATE       _T("SOFTWARE\\Microsoft\\Factory\\State")   // Registry path for the factory states.

// Extra debug Logging.
//
#ifdef DBG
#define DBGLOG                  FacLogFileStr
#else // DBG
#define DBGLOG           
#endif // DBG

//
// Defined Macro(s):
//


//
// Type Definition(s):
//

typedef enum _FACTMODE
{
    modeUnknown,
    modeSetup,
    modeMiniNt,
    modeWinPe,
    modeLogon,
    modeOobe,
} FACTMODE, *PFACTMODE, *LPFACTMODE;

typedef enum _STATE
{
    stateUnknown,
    stateStart,
    stateComputerName,
    stateSetupNetwork,
    stateUpdateDrivers,
    stateInstallDrivers,
    stateNormalPnP,
    stateWaitPnP,
    stateWaitPnP2,
    stateSetDisplay,
    stateSetDisplay2,
    stateOptShell,
    stateAutoLogon,
    stateLogon,
    stateUserIdent,
    stateInfInstall,
    statePidPopulate,
    stateOCManager,
    stateOemRunOnce,
    stateOemRun,
    stateReseal,
    statePartitionFormat,
    stateCopyFiles,
    stateStartMenuMFU,
    stateSetDefaultApps,
    stateOemData,
    stateSetPowerOptions,
    stateSetFontOptions,
    stateShellSettings,
    stateShellSettings2,
    stateHomeNet,
    stateExtendPart,
    stateResetSource,
    stateTestCert,
    stateSlpFiles,
    stateWinpeReboot,
    stateWinpeNet,
    stateCreatePageFile,
    stateFinish,
} STATE;

typedef struct _STATEDATA
{
    LPTSTR  lpszWinBOMPath;
    STATE   state;
    BOOL    bQuit;
} STATEDATA, *PSTATEDATA, *LPSTATEDATA;

typedef BOOL (WINAPI *STATEFUNC)(LPSTATEDATA);

typedef struct _STATES
{
    STATE       state;          // State number.
    STATEFUNC   statefunc;      // Function to call for this state.
    STATEFUNC   displayfunc;    // Function that decides if this state is displayed or not.
    INT         nFriendlyName;  // Resource ID of the name to be displayed in the log and UI for this state.
    DWORD       dwFlags;        // Any flags for the state.
} STATES, *PSTATES, *LPSTATES;


//
// Function Prototype(s):
//

BOOL    CheckParams(LPSTR lpCmdLine);
INT_PTR FactoryPreinstallDlgProc(HWND, UINT, WPARAM, LPARAM);

// In WINBOM.C:
//
BOOL ProcessWinBOM(LPTSTR lpszWinBOMPath, LPSTATES lpStates, DWORD cbStates);
BOOL DisplayAlways(LPSTATEDATA lpStateData);

// From MISC.C
TCHAR GetDriveLetter(UINT uDriveType);
BOOL ComputerName(LPSTATEDATA lpStateData);
BOOL DisplayComputerName(LPSTATEDATA lpStateData);
BOOL Reseal(LPSTATEDATA lpStateData);
BOOL DisplayReseal(LPSTATEDATA lpStateData);

// From PNPDRIVERS.C:
//
BOOL StartPnP();
BOOL WaitForPnp(DWORD dwTimeOut);
BOOL UpdateDrivers(LPSTATEDATA lpStateData);
BOOL DisplayUpdateDrivers(LPSTATEDATA lpStateData);
BOOL InstallDrivers(LPSTATEDATA lpStateData);
BOOL DisplayInstallDrivers(LPSTATEDATA lpStateData);
BOOL NormalPnP(LPSTATEDATA lpStateData);
BOOL DisplayWaitPnP(LPSTATEDATA lpStateData);
BOOL WaitPnP(LPSTATEDATA lpStateData);
BOOL SetDisplay(LPSTATEDATA lpStateData);

// From Net.c
BOOL InstallNetworkCard(PWSTR pszWinBOMPath, BOOL bForceIDScan);
BOOL SetupNetwork(LPSTATEDATA lpStateData);

// From mini.c
BOOL SetupMiniNT(VOID);
BOOL PartitionFormat(LPSTATEDATA lpStateData);
BOOL DisplayPartitionFormat(LPSTATEDATA lpStateData);
BOOL CopyFiles(LPSTATEDATA lpStateData);
BOOL DisplayCopyFiles(LPSTATEDATA lpStateData);
BOOL WinpeReboot(LPSTATEDATA lpStateData);

BOOL 
IsRemoteBoot(
    VOID
    );

// From autologon.c
BOOL AutoLogon(LPSTATEDATA lpStateData);
BOOL DisplayAutoLogon(LPSTATEDATA lpStateData);

// From ident.c
BOOL UserIdent(LPSTATEDATA lpStateData);
BOOL DisplayUserIdent(LPSTATEDATA lpStateData);

// From inf.c
BOOL ProcessInfSection(LPTSTR, LPTSTR);
BOOL InfInstall(LPSTATEDATA lpStateData);
BOOL DisplayInfInstall(LPSTATEDATA lpStateData);

// From factory.c
VOID InitLogging(LPTSTR lpszWinBOMPath);

// From log.c
DWORD FacLogFileStr(DWORD dwLogOpt, LPTSTR lpFormat, ...);
DWORD FacLogFile(DWORD dwLogOpt, UINT uFormat, ...);

// From StartMenuMfu.c
BOOL StartMenuMFU(LPSTATEDATA lpStateData);
BOOL DisplayStartMenuMFU(LPSTATEDATA lpStateData);

BOOL SetDefaultApps(LPSTATEDATA lpStateData);


// From OemFolder.c
BOOL OemData(LPSTATEDATA lpStateData);
BOOL DisplayOemData(LPSTATEDATA lpStateData);
void NotifyStartMenu(UINT code);
#define TMFACTORY_OEMLINK       0
#define TMFACTORY_MFU           1

// From oemrun.c
BOOL OemRun(LPSTATEDATA lpStateData);
BOOL DisplayOemRun(LPSTATEDATA lpStateData);
BOOL OemRunOnce(LPSTATEDATA lpStateData);
BOOL DisplayOemRunOnce(LPSTATEDATA lpStateData);

// From winpenet.c
BOOL ConfigureNetwork(LPTSTR lpszWinBOMPath);
BOOL WinpeNet(LPSTATEDATA lpStateData);
BOOL DisplayWinpeNet(LPSTATEDATA lpStateData);
DWORD WaitForServiceStartName(LPTSTR lpszServiceName);
DWORD StartMyService(LPTSTR lpszServiceName, SC_HANDLE schSCManager);

// From power.c
BOOL SetPowerOptions(LPSTATEDATA lpStateData);
BOOL DisplaySetPowerOptions(LPSTATEDATA lpStateData);

// From FONT.C:
//
BOOL SetFontOptions(LPSTATEDATA lpStateData);
BOOL DisplaySetFontOptions(LPSTATEDATA lpStateData);

// From HOMENET.C:
//
BOOL HomeNet(LPSTATEDATA lpStateData);
BOOL DisplayHomeNet(LPSTATEDATA lpStateData);

// From SRCPATH.C:
//
BOOL ResetSource(LPSTATEDATA lpStateData);
BOOL DisplayResetSource(LPSTATEDATA lpStateData);

// From EXTPART.C:
//
BOOL ExtendPart(LPSTATEDATA lpStateData);
BOOL DisplayExtendPart(LPSTATEDATA lpStateData);

// From TESTCERT.C:
//
BOOL TestCert(LPSTATEDATA lpStateData);
BOOL DisplayTestCert(LPSTATEDATA lpStateData);

// From SHELL.C:
//
BOOL OptimizeShell(LPSTATEDATA lpStateData);
BOOL DisplayOptimizeShell(LPSTATEDATA lpStateData);

// From SETSHELL.C:
//
BOOL ShellSettings(LPSTATEDATA lpStateData);
BOOL ShellSettings2(LPSTATEDATA lpStateData);
BOOL DisplayShellSettings(LPSTATEDATA lpStateData);

// From pagefile.c
//
BOOL CreatePageFile(LPSTATEDATA lpStateData);
BOOL DisplayCreatePageFile(LPSTATEDATA lpStateData);

// From OCMGR.C:
//
BOOL OCManager(LPSTATEDATA lpStateData);
BOOL DisplayOCManager(LPSTATEDATA lpStateData);

// From SLPFILES.C:
//
BOOL SlpFiles(LPSTATEDATA lpStateData);
BOOL DisplaySlpFiles(LPSTATEDATA lpStateData);

// From PID.C
//
BOOL PidPopulate(LPSTATEDATA lpStateData);

// External functions
extern BOOL IsUserAdmin(VOID);
//extern BOOL CheckOSVersion(VOID);
//extern BOOL IsDomainMember(VOID);
//extern BOOL IsUserAdmin(VOID);
extern BOOL DoesUserHavePrivilege(PCTSTR);


// ============================================================================
// Global Variables
// ============================================================================
extern HINSTANCE    g_hInstance;
extern DWORD        g_dwFactoryFlags;
extern DWORD        g_dwDebugLevel;
extern TCHAR        g_szWinBOMPath[];
extern TCHAR        g_szLogFile[MAX_PATH];
extern TCHAR        g_szFactoryPath[MAX_PATH];
extern TCHAR        g_szSysprepDir[MAX_PATH];

// ============================================================================
// Global Constants
// ============================================================================
#define MAX_MESSAGE 4096

#define FACTORY_MESSAGE_TYPE_ERROR      1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\factory\font.c ===
/****************************************************************************\

    FONT.C / Factory / WinBOM (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    State code for customizing the font smoothing and cleartype settings.

    WINBOM.INI
    [ComputerSettings]
    FontSmoothing = ; Default is 'Standard'.

        Standard |  ; Will determine, based on the system speed, if font
                    ; smoothing is turned on or not.

        On |        ; Forces font smoothing on.  Should only be used if the
                    ; performance of the video card is known to give an
                    ; acceptable user experience with this option enabled.

        Off |       ; Forces font smoothing off.

        ClearType   ; Turns clear type and font smoothing on.  Should only be
                    ; used if the monitor is known to be an LCD screen and
                    ; that the system performance is known to be acceptable
                    ; with this option enabled.

    04/2001 - Jason Cohen (JCOHEN)
        Added source file for the state that customizes the font and 
        cleartype settings.

\****************************************************************************/


//
// Includes
//

#include "factoryp.h"


//
// Internal Defined Value(s):
//

#define REG_KEY_FONTSMOOTHING       _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects\\FontSmoothing")
#define REG_VAL_DEFAULTBYFONTTEST   _T("DefaultByFontTest")
#define REG_VAL_DEFAULTVALUE        _T("DefaultValue")

#define REG_KEY_CLEARTYPE           _T("Control Panel\\Desktop")
#define REG_VAL_FONTSMOOTHING       _T("FontSmoothing")
#define REG_VAL_FONTSMOOTHINGTYPE   _T("FontSmoothingType")

#define REG_KEY_HORRID_CLASSES      _T("_Classes")
#define REG_KEY_HORRID_CLASSES_LEN  ( AS(REG_KEY_HORRID_CLASSES) - 1 )


//
// Internal Function Prototype(s):
//

static BOOL RegSetAllUsers(LPTSTR lpszSubKey, LPTSTR lpszValue, LPBYTE lpData, DWORD dwType);


//
// Exported Function(s):
//

BOOL SetFontOptions(LPSTATEDATA lpStateData)
{
    LPTSTR  lpszWinBOMPath          = lpStateData->lpszWinBOMPath;
    TCHAR   szFontSmoothing[256]    = NULLSTR,
            szFontSmoothingData[]   = _T("_");
    DWORD   dwDefaultByFontTest,
            dwDefaultValue,
            dwFontSmoothingType;
    BOOL    bRet                    = TRUE;

    // Get the option from the winbom.
    //
    GetPrivateProfileString(INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_FONTSMOOTHING, NULLSTR, szFontSmoothing, AS(szFontSmoothing), lpszWinBOMPath);

    // Figure out what values to write based on the value in the winbom.
    //
    if ( NULLCHR == szFontSmoothing[0] )
    {
        // No key, do nothing and do not touch whatever options already set.
        //
        return TRUE;
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_ON) == 0 )
    {
        // Force font smoothing on.
        //
        dwDefaultByFontTest    = 0;
        dwDefaultValue         = 1;
        dwFontSmoothingType    = 1;
        szFontSmoothingData[0] = _T('2');
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_OFF) == 0 )
    {
        // Force font smoothing off.
        //
        dwDefaultByFontTest    = 0;
        dwDefaultValue         = 0;
        dwFontSmoothingType    = 0;
        szFontSmoothingData[0] = _T('0');
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_CLEARTYPE) == 0 )
    {
        // Force font smoothing and cleartype on.
        //
        dwDefaultByFontTest    = 0;
        dwDefaultValue         = 1;
        dwFontSmoothingType    = 2;
        szFontSmoothingData[0] = _T('2');
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_DEFAULT) == 0 )
    {
        // Let system decide if font smoothing should be on or not.
        //
        dwDefaultByFontTest    = 1;
        dwDefaultValue         = 0;
        dwFontSmoothingType    = 0;
        szFontSmoothingData[0] = _T('0');
    }
    else
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_FONTSMOOTHING, szFontSmoothing);
        bRet = FALSE;
    }

    // Now save the settings if valid option passed in.
    //
    if ( bRet )
    {
        if ( !RegSetDword(HKLM, REG_KEY_FONTSMOOTHING, REG_VAL_DEFAULTBYFONTTEST, dwDefaultByFontTest) )
        {
            bRet = FALSE;
        }
        if ( !RegSetDword(HKLM, REG_KEY_FONTSMOOTHING, REG_VAL_DEFAULTVALUE, dwDefaultValue) )
        {
            bRet = FALSE;
        }
        if ( !RegSetAllUsers(REG_KEY_CLEARTYPE, REG_VAL_FONTSMOOTHINGTYPE, (LPBYTE) &dwFontSmoothingType, REG_DWORD) )
        {
            bRet = FALSE;
        }
        if ( !RegSetAllUsers(REG_KEY_CLEARTYPE, REG_VAL_FONTSMOOTHING, (LPBYTE) szFontSmoothingData, REG_SZ) )
        {
            bRet = FALSE;
        }
        //
        // ISSUE-2002/02/25-acosma,robertko - this is a duplicate of the REG_VAL_FONTSMOOTHINGTYPE set above - should be removed.
        //
        if ( !RegSetAllUsers(REG_KEY_CLEARTYPE, REG_VAL_FONTSMOOTHINGTYPE, (LPBYTE) &dwFontSmoothingType, REG_DWORD) )
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL DisplaySetFontOptions(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_FONTSMOOTHING, NULL);
}


//
// Internal Function(s):
//

static BOOL RegSetAllUsers(LPTSTR lpszSubKey, LPTSTR lpszValue, LPBYTE lpData, DWORD dwType)
{
    BOOL    bRet = TRUE,
            bErr;
    LPTSTR  lpszKeyName;
    HKEY    hkeyEnum,
            hkeySub;
    DWORD   dwIndex     = 0,
            dwSize,
            dwDis,
            dwMaxSize;
    int     iLen;

    // Figure out the max length of any sub key and allocate a buffer for it.
    //
    if ( ( ERROR_SUCCESS == RegQueryInfoKey(HKEY_USERS,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &dwMaxSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL) ) &&

         ( lpszKeyName = (LPTSTR) MALLOC((++dwMaxSize) * sizeof(TCHAR)) ) )
    {
        // Now enumerate all the sub keys.
        //
        dwSize = dwMaxSize;
        while ( ERROR_SUCCESS == RegEnumKeyEx(HKEY_USERS,
                                              dwIndex++,
                                              lpszKeyName,
                                              &dwSize,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL) )
        {
            // Iterate over all users ignoring the keys with the "_Classes" suffix
            //
            if ( ( dwSize < REG_KEY_HORRID_CLASSES_LEN ) ||
                 ( 0 != LSTRCMPI(lpszKeyName + (dwSize - REG_KEY_HORRID_CLASSES_LEN), REG_KEY_HORRID_CLASSES) ) )
            {
                // Open up the sub key.
                //
                if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS,
                                                   lpszKeyName,
                                                   0,
                                                   KEY_ALL_ACCESS,
                                                   &hkeyEnum) )
                {
                    // Set the value that was passed in.
                    //
                    switch ( dwType )
                    {
                        case REG_DWORD:
                            bErr = !RegSetDword(hkeyEnum, lpszSubKey, lpszValue, *((LPDWORD) lpData));
                            break;

                        case REG_SZ:
                            bErr = !RegSetString(hkeyEnum, lpszSubKey, lpszValue, (LPTSTR) lpData);
                            break;

                        default:
                            bErr = TRUE;
                            break;
                    }

                    // If anything fails, we keep going but return an error.
                    //
                    if ( bErr )
                    {
                        bRet = FALSE;
                    }

                    // Close the sub key that we enumerated.
                    //
                    RegCloseKey(hkeyEnum);
                }
            }

            // Reset the size for the next call to RegEnumKeyEx().
            //
            dwSize = dwMaxSize;
        }

        // Free the buffer we allocated.
        //
        FREE(lpszKeyName);
    }
    else
    {
        bRet = FALSE;
    }

    // Return TRUE if everything worked okay.
    //
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\factory\homenet.c ===
/****************************************************************************\

    HOMENET.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the home net state functions.

    05/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for configuring the home
        networking settings.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// Internal Define(s):
//

#define FILE_HOMENET_DLL    _T("HNETCFG.DLL")
#define FUNC_HOMENET        "WinBomConfigureHomeNet"


//
// Internal Type Definition(s):
//

/****************************************************************************\

BOOL                        // Returns TRUE if the settings were successfully
                            // read and saved to the system.  Otherwise
                            // returns FALSE to indicate something failed.
 

WinBomConfigureHomeNet(     // Reads home networking settings from the
                            // specified unattend file and saves those in
                            // current system that is already setup and
                            // running.

    LPCWSTR lpszUnattend,   // Points to a string buffer which contains the
                            // full path to the unattend file (winbom.ini in
                            // this case) with all the home network settings.

    LPCWSTR lpszSection     // Points to a string buffer which contains the
                            // name of the section which contains all the home
                            // network settings in the unattend file specified
                            // above.

);

\****************************************************************************/

typedef BOOL (WINAPI * WINBOMCONFIGUREHOMENET)
(
    LPCWSTR lpszUnattend,
    LPCWSTR lpszSection
);


//
// Internal Global(s):
//


//
// Internal Function Prototype(s):
//


//
// External Function(s):
//

BOOL HomeNet(LPSTATEDATA lpStateData)
{
    BOOL                    bRet = FALSE;
    HINSTANCE               hDll;
    WINBOMCONFIGUREHOMENET  pFunc;
    HRESULT                 hr;

    // Load the function from the external dll and call it.
    //
    if ( hDll = LoadLibrary(FILE_HOMENET_DLL) )
    {
        // Need to init the COM library.
        //
        hr = CoInitialize(NULL);
        if ( SUCCEEDED(hr) )
        {
            // Now call the function.
            //
            if ( pFunc = (WINBOMCONFIGUREHOMENET) GetProcAddress(hDll, FUNC_HOMENET) )
            {
                bRet = pFunc(lpStateData->lpszWinBOMPath, INI_SEC_HOMENET);
            }
#ifdef DBG
            else
            {
                FacLogFileStr(3, _T("DEBUG: GetProcAddress(\"WinBomConfigureHomeNet\") failed.  GLE=%d"), GetLastError());
            }
#endif
            CoUninitialize();
        }
#ifdef DBG
        else
        {
            FacLogFileStr(3, _T("DEBUG: HomeNet()::CoInitialize() failed.  HR=%8.8X"), hr);
        }
#endif
        FreeLibrary(hDll);
    }
#ifdef DBG
    else
    {
        FacLogFileStr(3, _T("DEBUG: LoadLibrary(\"%s\") failed.  GLE=%d"), FILE_HOMENET_DLL, GetLastError());
    }
#endif

    return bRet;
}

BOOL DisplayHomeNet(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_HOMENET, NULL, NULL);
}


//
// Internal Function(s):
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\factory\log.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    log.c

Abstract:

    This module contains the implementation of factory specific logging functions.

  Author:

    Adrian Cosma (acosma) - 2/14/2001

Revision History:


Details:

  There are 3 logging functions:

    1) DWORD FacLogFile(DWORD dwLogOpt, UINT uFormat, ...)
        - This takes a variable list of arguments and a resource ID for the error message, followed by 
        strings to fill in any fields specified int the resource string.  The format sepcifiers are the
        standard C printf() format specifiers.

    2) DWORD FacLogFileStr(DWORD dwLogOpt, LPTSTR lpFormat, ...)
        - This takes a variable list of arguments and a string for the error message followed by a variable
        number of strings to fill in any fields specified in the error string.  The format sepcifiers are the
        standard C printf() format specifiers.


    3) DWORD FacLogFileLst(LPCTSTR lpFileName, DWORD dwLogOpt, LPTSTR lpFormat, va_list lpArgs)
        - This takes a variable list of arguments as a va_list. Normally you should not call this function directly.



    Logging options in dwLogOpt - these flags are defined in factoryp.h.

        #define LOG_DEBUG               0x00000003    // Only log in debug builds if this is specified. (Debug Level for logging.)
        #define LOG_MSG_BOX             0x00000010    // Also display a message box with the error message if this is enabled.
        #define LOG_ERR                 0x00000020    // Prefix the logged string with "Error:" if the message is level 0,
                                                      // or "WARNx" if the message is at level x > 0.
        #define LOG_TIME                0x00000040    // Log time if this is enabled
        #define LOG_NO_NL               0x00000080    // Don't add new Line to the end of log string if this is set. 
                                                         ( A '\n' is appended by default to all strings logged if there is no
                                                         terminating '\n'.)

    The LogLevel can be set through the winbom through LogLevel=N in the [Factory] section. The default LogLevel in free builds is 0, and the default LogLevel in 
    checked builds is LOG_DEBUG (3).  The maximum log level in free builds is 2. Any message at MessageLogLevel <= LogLevel 
    will be logged.   

    Return value: DWORD - number of bytes written to the log file (this is twice the number of chars in case of UNICODE).

    Examples:  
    
      FacLogFileStr(3 | LOG_TIME, _T("Starting to format %c:."), pCur->cDriveLetter);
         - Only log this in Debug builds (3), log the time along with the error message.


      FacLogFile(0 | LOG_ERR, IDS_ERR_HUGE_ERROR, dwErrorCode);
         - Always log this error.  IDS_ERR_HUGE_ERROR must be defined as a resource in this image.
           IDS_ERR_HUGE_ERROR should look something like this: "Huge Error! Error code: %d".  Note the %d is
           for the dwErrorCode.

--*/

//
// Includes
//

#include "factoryp.h"


//
// Defines
//

#ifdef CHR_NEWLINE
#undef CHR_NEWLINE
#endif // CHR_NEWLINE
#define CHR_NEWLINE              _T('\n')


#ifdef CHR_CR
#undef CHR_CR
#endif // CHR_CR
#define CHR_CR                   _T('\r')


//
// NTRAID#NTBUG9-549770-2002/02/26-acosma - Buffer overruns everywhere in this code.  lstrcpy, lstrcat, wsprintf, etc.
//

//
// Function Implementations
//

DWORD FacLogFileLst(LPCTSTR lpFileName, DWORD dwLogOpt, LPTSTR lpFormat, va_list lpArgs)
{
    LPTSTR lpAppName            = NULL;
    LPTSTR lpPreOut             = NULL;
    LPTSTR lpOut                = NULL;
    DWORD  dwSize               = 1024;
    TCHAR  szPreLog[MAX_PATH]   = NULLSTR;
    HANDLE hFile;
    DWORD  dwWritten            = 0;
    DWORD  cbAppName            = 0;
    DWORD  dwLogLevel           = (DWORD) (dwLogOpt & LOG_LEVEL_MASK);
    
    
    if ( ( dwLogLevel <