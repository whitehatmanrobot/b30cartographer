                        // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  }
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
    },
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMute[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute, PropertiesMute);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMux[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMux, PropertiesMux);

//=============================================================================
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
  // KSNODE_TOPO_WAVEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_WAVE_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_WAVE_MUTE   // Name
  },

  // KSNODE_TOPO_SYNTHOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_SYNTHOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_MIDI_MUTE   // Name
  },

  // KSNODE_TOPO_MIC_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIC_VOLUME  // Name
  },

  // KSNODE_TOPO_SYNTHIN_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_LINEOUT_MIX
  {
    0,                      // Flags
    NULL,                   // AutomationTable
    &KSNODETYPE_SUM,        // Type
    NULL                    // Name
  },

  // KSNODE_TOPO_LINEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MASTER_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEIN_MUX
  {
    0,                      // Flags
    &AutomationMux,         // AutomationTable
    &KSNODETYPE_MUX,        // Type
    &KSAUDFNAME_RECORDING_SOURCE // Name
  },
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
  //  FromNode,                     FromPin,                        ToNode,                      ToPin
  {   PCFILTER_NODE,                KSPIN_TOPO_WAVEOUT_SOURCE,      KSNODE_TOPO_WAVEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_WAVEOUT_VOLUME,   0,                              KSNODE_TOPO_WAVEOUT_MUTE,    1 },
  {   KSNODE_TOPO_WAVEOUT_MUTE,     0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHOUT_SOURCE,     KSNODE_TOPO_SYNTHOUT_VOLUME, 1 },
  {   KSNODE_TOPO_SYNTHOUT_VOLUME,  0,                              KSNODE_TOPO_SYNTHOUT_MUTE,   1 },
  {   KSNODE_TOPO_SYNTHOUT_MUTE,    0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHIN_SOURCE,      KSNODE_TOPO_SYNTHIN_VOLUME,  1 },
  {   KSNODE_TOPO_SYNTHIN_VOLUME,   0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   PCFILTER_NODE,                KSPIN_TOPO_MIC_SOURCE,          KSNODE_TOPO_MIC_VOLUME,      1 },
  {   KSNODE_TOPO_MIC_VOLUME,       0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   KSNODE_TOPO_LINEOUT_MIX,      0,                              KSNODE_TOPO_LINEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_LINEOUT_VOLUME,   0,                              PCFILTER_NODE,               KSPIN_TOPO_LINEOUT_DEST },

  {   KSNODE_TOPO_WAVEIN_MUX,       0,                              PCFILTER_NODE,               KSPIN_TOPO_WAVEIN_DEST }
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
  0,                                  // Version
  NULL,                               // AutomationTable
  sizeof(PCPIN_DESCRIPTOR),           // PinSize
  SIZEOF_ARRAY(MiniportPins),         // PinCount
  MiniportPins,                       // Pins
  sizeof(PCNODE_DESCRIPTOR),          // NodeSize
  SIZEOF_ARRAY(TopologyNodes),        // NodeCount
  TopologyNodes,                      // Nodes
  SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
  MiniportConnections,                // Connections
  0,                                  // CategoryCount
  NULL                                // Categories
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ac3\mintopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    mintopo.cpp

Abstract:

    Implementation of topology miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "ac3.h"
#include "minwave.h"
#include "mintopo.h"
#include "toptable.h"


/*********************************************************************
* Topology/Wave bridge connection                                    *
*                                                                    *
*              +------+    +------+                                  *
*              | Wave |    | Topo |                                  *
*              |      |    |      |                                  *
*  Capture <---|0    1|<===|4    1|<--- Synth                        *
*              |      |    |      |                                  *
*  Render  --->|2    3|===>|0     |                                  *
*              |      |    |      |                                  *
*  AC3 Render >|4    5|    |      |                                  *
*              |      |    |     2|<--- Mic                          *
*              +------+    |      |                                  *
*                          |     3|---> Line Out                     *
*                          +------+                                  *
*********************************************************************/
PHYSICALCONNECTIONTABLE TopologyPhysicalConnections =
{
    KSPIN_TOPO_WAVEOUT_SOURCE,  // TopologyIn
    KSPIN_TOPO_WAVEIN_DEST,     // TopologyOut
    KSPIN_WAVE_CAPTURE_SOURCE,  // WaveIn
    KSPIN_WAVE_RENDER_SOURCE    // WaveOut
};

#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

    Creates a new topology miniport.

Arguments:

  Unknown - 

  RefclsId -

  UnknownOuter -

  PoolType - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopology, Unknown, UnknownOuter, PoolType);
} // CreateMiniportTopologyMSVAD

//=============================================================================
CMiniportTopology::~CMiniportTopology
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopology::~CMiniportTopology]"));
} // ~CMiniportTopology

//=============================================================================
NTSTATUS
CMiniportTopology::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request. 

  MyDataRange - Pin's data range to be compared with client's data range. 

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter. 

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned. 

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::DataRangeIntersection
        (
            PinId,
            ClientDataRange,
            MyDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP
CMiniportTopology::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportTopology::Init
( 
    IN PUNKNOWN                 UnknownAdapter,
    IN PRESOURCELIST            ResourceList,
    IN PPORTTOPOLOGY            Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopology::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        CMiniportTopologyMSVAD::Init
        (
            UnknownAdapter,
            Port_
        );

    if (NT_SUCCESS(ntStatus))
    {
        m_FilterDescriptor = &MiniportFilterDescriptor;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP
CMiniportTopology::NonDelegatingQueryInterface
( 
    IN  REFIID                  Interface,
    OUT PVOID                   * Object 
)
/*++

Routine Description:

  QueryInterface for MiniportTopology

Arguments:

  Interface - GUID of the interface

  Object - interface object to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.
        PUNKNOWN(*Object)->AddRef();
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
PropertyHandler_Topology
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Topology]"));

    return ((PCMiniportTopology)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Topology

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmmult\minwave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.h

Abstract:

    Definition of wavecyclic miniport class.

--*/

#ifndef _MSVAD_MINWAVE_H_
#define _MSVAD_MINWAVE_H_

#include "basewave.h"

//=============================================================================
// Referenced Forward
//=============================================================================
class CMiniportWaveCyclicStream;
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclic 
//   

class CMiniportWaveCyclic : 
    public CMiniportWaveCyclicMSVAD,
    public IMiniportWaveCyclic,
    public CUnknown
{
private:
    PCMiniportWaveCyclicStream  m_pStream[MAX_INPUT_STREAMS];
    BOOL                        m_fCaptureAllocated;

    PDRMPORT                    m_pDrmPort;

    DRMRIGHTS                   m_MixDrmRights;
    ULONG                       m_ulMixDrmContentId;

protected:
    NTSTATUS                    UpdateDrmRights
    (
        void
    );

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclic);
    ~CMiniportWaveCyclic();

    IMP_IMiniportWaveCyclic;

    // Friends
    friend class                CMiniportWaveCyclicStream;
    friend class                CMiniportTopologySimple;
};
typedef CMiniportWaveCyclic *PCMiniportWaveCyclic;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStream 
//   

class CMiniportWaveCyclicStream : 
    public IDrmAudioStream,
    public CMiniportWaveCyclicStreamMSVAD,
    public CUnknown
{
protected:  
    PCMiniportWaveCyclic        m_pMiniportLocal;

    ULONG                       m_ulContentId;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStream);
    ~CMiniportWaveCyclicStream();

    IMP_IDrmAudioStream;

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclic Miniport,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class                CMiniportWaveCyclic;
};
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmmult\wavtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    wavtable.h

Abstract:

    Declaration of wave miniport tables.

--*/

#ifndef _MSVAD_WAVTABLE_H_
#define _MSVAD_WAVTABLE_H_

//=============================================================================
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_PCM,           
        MIN_BITS_PER_SAMPLE_PCM,    
        MAX_BITS_PER_SAMPLE_PCM,    
        MIN_SAMPLE_RATE,            
        MAX_SAMPLE_RATE             
    },
};

static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }
};

static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    // Wave In Streaming Pin (Capture) KSPIN_WAVE_CAPTURE_SINK
    {
        MAX_OUTPUT_STREAMS,
        MAX_OUTPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_RECORDING_CONTROL,  
            0
        }
    },
    
    // Wave In Bridge Pin (Capture - From Topology) KSPIN_WAVE_CAPTURE_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
  
    // Wave Out Streaming Pin (Renderer) KSPIN_WAVE_RENDER_SINK
    {
        MAX_INPUT_STREAMS,
        MAX_INPUT_STREAMS, 
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_VOLUME_CONTROL,
            0
        }
    },
  
    // Wave Out Bridge Pin (Renderer) KSPIN_WAVE_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
};

//=============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // KSNODE_WAVE_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_DAC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};


//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,        KSPIN_WAVE_CAPTURE_SOURCE,  KSNODE_WAVE_ADC,     1 },    
    { KSNODE_WAVE_ADC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_CAPTURE_SINK },    

    { PCFILTER_NODE,        KSPIN_WAVE_RENDER_SINK,     KSNODE_WAVE_DAC,     1 },    
    { KSNODE_WAVE_DAC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_RENDER_SOURCE },    
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories - NULL->use defaults (AUDIO RENDER CAPTURE)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmmult\mintopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    mintopo.cpp

Abstract:

    Implementation of topology miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "drmmult.h"
#include "minwave.h"
#include "mintopo.h"
#include "toptable.h"


/*********************************************************************
* Topology/Wave bridge connection                                    *
*                                                                    *
*              +------+    +------+                                  *
*              | Wave |    | Topo |                                  *
*              |      |    |      |                                  *
*  Capture <---|0    1|<===|4    1|<--- Synth                        *
*              |      |    |      |                                  *
*   Render --->|2    3|===>|0     |                                  *
*              +------+    |      |                                  *
*                          |     2|<--- Mic                          *
*                          |      |                                  *
*                          |     3|---> Line Out                     *
*                          +------+                                  *
*********************************************************************/
PHYSICALCONNECTIONTABLE TopologyPhysicalConnections =
{
    KSPIN_TOPO_WAVEOUT_SOURCE,  // TopologyIn
    KSPIN_TOPO_WAVEIN_DEST,     // TopologyOut
    KSPIN_WAVE_CAPTURE_SOURCE,  // WaveIn
    KSPIN_WAVE_RENDER_SOURCE    // WaveOut
};

#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

    Creates a new topology miniport.

Arguments:

  Unknown - 

  RefclsId -

  UnknownOuter -

  PoolType - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopology, Unknown, UnknownOuter, PoolType);
} // CreateMiniportTopologyMSVAD

//=============================================================================
CMiniportTopology::~CMiniportTopology
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopology::~CMiniportTopology]"));
} // ~CMiniportTopology

//=============================================================================
NTSTATUS
CMiniportTopology::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request. 

  MyDataRange - Pin's data range to be compared with client's data range. 

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter. 

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned. 

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::DataRangeIntersection
        (
            PinId,
            ClientDataRange,
            MyDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP
CMiniportTopology::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportTopology::Init
( 
    IN PUNKNOWN                 UnknownAdapter,
    IN PRESOURCELIST            ResourceList,
    IN PPORTTOPOLOGY            Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopology::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        CMiniportTopologyMSVAD::Init
        (
            UnknownAdapter,
            Port_
        );

    if (NT_SUCCESS(ntStatus))
    {
        m_FilterDescriptor = &MiniportFilterDescriptor;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP
CMiniportTopology::NonDelegatingQueryInterface
( 
    IN  REFIID                  Interface,
    OUT PVOID                   * Object 
)
/*++

Routine Description:

  QueryInterface for MiniportTopology

Arguments:

  Interface - GUID of the interface

  Object - interface object to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.
        PUNKNOWN(*Object)->AddRef();
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
PropertyHandler_Topology
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Topology]"));

    return ((PCMiniportTopology)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Topology

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmmult\toptable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    toptable.h

Abstract:

    Declaration of topology tables.

--*/

#ifndef _MSVAD_TOPTABLE_H_
#define _MSVAD_TOPTABLE_H_

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
 {
   sizeof(KSDATARANGE),
   0,
   0,
   0,
   STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
   STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
   STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
 }
};

//=============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
  &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
  // KSPIN_TOPO_WAVEOUT_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHOUT_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHIN_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_MIC_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_MICROPHONE,                       // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_LINEOUT_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SPEAKER,                          // Category
      &KSAUDFNAME_VOLUME_CONTROL,                   // Name (this name shows up as
                                                    // the playback panel name in SoundVol)
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_WAVEIN_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  }
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
    },
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMute[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute, PropertiesMute);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMux[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMux, PropertiesMux);

//=============================================================================
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
  // KSNODE_TOPO_WAVEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_WAVE_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_WAVE_MUTE   // Name
  },

  // KSNODE_TOPO_SYNTHOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_SYNTHOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_MIDI_MUTE   // Name
  },

  // KSNODE_TOPO_MIC_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIC_VOLUME  // Name
  },

  // KSNODE_TOPO_SYNTHIN_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_LINEOUT_MIX
  {
    0,                      // Flags
    NULL,                   // AutomationTable
    &KSNODETYPE_SUM,        // Type
    NULL                    // Name
  },

  // KSNODE_TOPO_LINEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MASTER_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEIN_MUX
  {
    0,                      // Flags
    &AutomationMux,         // AutomationTable
    &KSNODETYPE_MUX,        // Type
    &KSAUDFNAME_RECORDING_SOURCE // Name
  },
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
  //  FromNode,                     FromPin,                        ToNode,                      ToPin
  {   PCFILTER_NODE,                KSPIN_TOPO_WAVEOUT_SOURCE,      KSNODE_TOPO_WAVEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_WAVEOUT_VOLUME,   0,                              KSNODE_TOPO_WAVEOUT_MUTE,    1 },
  {   KSNODE_TOPO_WAVEOUT_MUTE,     0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHOUT_SOURCE,     KSNODE_TOPO_SYNTHOUT_VOLUME, 1 },
  {   KSNODE_TOPO_SYNTHOUT_VOLUME,  0,                              KSNODE_TOPO_SYNTHOUT_MUTE,   1 },
  {   KSNODE_TOPO_SYNTHOUT_MUTE,    0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHIN_SOURCE,      KSNODE_TOPO_SYNTHIN_VOLUME,  1 },
  {   KSNODE_TOPO_SYNTHIN_VOLUME,   0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   PCFILTER_NODE,                KSPIN_TOPO_MIC_SOURCE,          KSNODE_TOPO_MIC_VOLUME,      1 },
  {   KSNODE_TOPO_MIC_VOLUME,       0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   KSNODE_TOPO_LINEOUT_MIX,      0,                              KSNODE_TOPO_LINEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_LINEOUT_VOLUME,   0,                              PCFILTER_NODE,               KSPIN_TOPO_LINEOUT_DEST },

  {   KSNODE_TOPO_WAVEIN_MUX,       0,                              PCFILTER_NODE,               KSPIN_TOPO_WAVEIN_DEST }
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
  0,                                  // Version
  NULL,                               // AutomationTable
  sizeof(PCPIN_DESCRIPTOR),           // PinSize
  SIZEOF_ARRAY(MiniportPins),         // PinCount
  MiniportPins,                       // Pins
  sizeof(PCNODE_DESCRIPTOR),          // NodeSize
  SIZEOF_ARRAY(TopologyNodes),        // NodeCount
  TopologyNodes,                      // Nodes
  SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
  MiniportConnections,                // Connections
  0,                                  // CategoryCount
  NULL                                // Categories
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmmult\minwave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "drmmult.h"
#include "minwave.h"
#include "wavtable.h"

#pragma code_seg("PAGE")

//=============================================================================
// CMiniportWaveCyclic
//=============================================================================

//=============================================================================
NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Create the wavecyclic miniport.

Arguments:

  Unknown - 

  RefClsId -

  UnknownOuter -

  PoolType -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportWaveCyclic, Unknown, UnknownOuter, PoolType);
}

//=============================================================================
CMiniportWaveCyclic::~CMiniportWaveCyclic
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    if (m_pDrmPort)
    {
        m_pDrmPort->Release();
    }

    DPF_ENTER(("[CMiniportWaveCyclic::~CMiniportWaveCyclic]"));
} // ~CMiniportWaveCyclic


//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::DataRangeIntersection
( 
    IN  ULONG                       PinId,
    IN  PKSDATARANGE                ClientDataRange,
    IN  PKSDATARANGE                MyDataRange,
    IN  ULONG                       OutputBufferLength,
    OUT PVOID                       ResultantFormat,
    OUT PULONG                      ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId -           Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data 
                    range submitted by client in the data range intersection 
                    property request. 

  MyDataRange -         Pin's data range to be compared with client's data 
                        range. In this case we actually ignore our own data 
                        range, because we know that we only support one range.

  OutputBufferLength -  Size of the buffer pointed to by the resultant format 
                        parameter. 

  ResultantFormat -     Pointer to value where the resultant format should be 
                        returned. 

  ResultantFormatLength -   Actual length of the resultant format placed in 
                            ResultantFormat. This should be less than or equal 
                            to OutputBufferLength. 

  Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    // This driver only supports PCM formats.
    // Portcls will handle the request for us.
    //

    return STATUS_NOT_IMPLEMENTED;
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    return 
        CMiniportWaveCyclicMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    NTSTATUS                    ntStatus;

    DPF_ENTER(("[CMiniportWaveCyclic::Init]"));

    m_MaxOutputStreams      = MAX_OUTPUT_STREAMS;
    m_MaxInputStreams       = MAX_INPUT_STREAMS;
    m_MaxTotalStreams       = MAX_TOTAL_STREAMS;

    m_MinChannels           = MIN_CHANNELS;
    m_MaxChannelsPcm        = MAX_CHANNELS_PCM;

    m_MinBitsPerSamplePcm   = MIN_BITS_PER_SAMPLE_PCM;
    m_MaxBitsPerSamplePcm   = MAX_BITS_PER_SAMPLE_PCM;
    m_MinSampleRatePcm      = MIN_SAMPLE_RATE;
    m_MaxSampleRatePcm      = MAX_SAMPLE_RATE;

    m_ulMixDrmContentId     = 0;
    RtlZeroMemory(&m_MixDrmRights, sizeof(m_MixDrmRights));

    ntStatus =
        CMiniportWaveCyclicMSVAD::Init
        (
            UnknownAdapter_,
            ResourceList_,
            Port_
        );
    if (NT_SUCCESS(ntStatus))
    {
        // Set filter descriptor.
        m_FilterDescriptor = &MiniportFilterDescriptor;

        m_fCaptureAllocated = FALSE;
        RtlZeroMemory
        (
            m_pStream, 
            MAX_INPUT_STREAMS * sizeof(PCMiniportWaveCyclicStream)
        );

        if (!NT_SUCCESS(
            Port_->QueryInterface(IID_IDrmPort, (PVOID *) &m_pDrmPort)))
        {
            m_pDrmPort = NULL;
        }
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NewStream
( 
    OUT PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  ULONG                   Pin,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL *           OutDmaChannel,
    OUT PSERVICEGROUP *         OutServiceGroup 
)
/*++

Routine Description:

  The NewStream function creates a new instance of a logical stream 
  associated with a specified physical channel. Callers of NewStream should 
  run at IRQL PASSIVE_LEVEL.

Arguments:

  OutStream -

  OuterUnknown -

  PoolType - 

  Pin - 

  Capture - 

  DataFormat -

  OutDmaChannel -

  OutServiceGroup -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    DPF_ENTER(("[CMiniportWaveCyclic::NewStream]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PCMiniportWaveCyclicStream  stream = NULL;
    ULONG                       streamIndex;

    // MSVAD supports one capture stream.
    //
    if (Capture)
    {
        if (m_fCaptureAllocated)
        {
            DPF(D_TERSE, ("[Only one capture stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    // This version supports multiple playback streams.
    //
    else
    {
        for (streamIndex = 0; streamIndex < m_MaxInputStreams; streamIndex++)
        {
            if (!m_pStream[streamIndex])
            {
                break;
            }
        }
        if (streamIndex == m_MaxInputStreams)
        {
            DPF(D_TERSE, ("[All render streams are in use]"));            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    // Instantiate a stream. Stream must be in
    // NonPagedPool because of file saving.
    //
    if (NT_SUCCESS(ntStatus))
    {
        stream = new (NonPagedPool, MSVAD_POOLTAG) 
            CMiniportWaveCyclicStream(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus = 
                stream->Init
                ( 
                    this,
                    Pin,
                    Capture,
                    DataFormat
                );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (Capture)
        {
            m_fCaptureAllocated = TRUE;
        }
        else
        {
            m_pStream[streamIndex] = stream;
        }

        *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
        (*OutStream)->AddRef();
        
        *OutDmaChannel = PDMACHANNEL(stream);
        (*OutDmaChannel)->AddRef();

        *OutServiceGroup = m_ServiceGroup;
        (*OutServiceGroup)->AddRef();

        // The stream, the DMA channel, and the service group have
        // references now for the caller.  The caller expects these
        // references to be there.
    }

    // This is our private reference to the stream.  The caller has
    // its own, so we can release in any case.
    //
    if (stream)
    {
        stream->Release();
    }
    
    return ntStatus;
} // NewStream

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.

        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
CMiniportWaveCyclic::UpdateDrmRights
(
    void
)
/*++

Routine Description:

  Updates the mixed DrmRights. This is done by creating an array of existing
  content ids and asking DrmPort to create a new contend id with a mixed
  DrmRights structure.
  The new DrmRights structure should be enforced, if everything goes well.

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::UpdateDrmRights]"));
    
    NTSTATUS                    ntStatus;
    ULONG                       ulContentIndex = 0;
    ULONG                       ulContentIds[MAX_INPUT_STREAMS];
    ULONG                       ulMixDrmContentId = 0;
    BOOL                        fCreatedContentId = FALSE;
    DRMRIGHTS                   MixDrmRights = {FALSE, 0, FALSE};

    // This function only runs if IID_DrmPort is implemented in Wave port.
    //
    if (!m_pDrmPort)
    {
        return STATUS_UNSUCCESSFUL;
    }

    // Create an array of all StreamIds.
    //
    for (ULONG i = 0; i < MAX_INPUT_STREAMS; i++)
    {
        if (m_pStream[i])
        {
            ulContentIds[ulContentIndex] = m_pStream[i]->m_ulContentId;
            ulContentIndex++;
        }
    }

    // Create the new contentId.
    //
    if (ulContentIndex)
    {
        ntStatus = 
            m_pDrmPort->CreateContentMixed
            (
                ulContentIds,
                ulContentIndex,
                &ulMixDrmContentId
            );
        if (NT_SUCCESS(ntStatus))
        {
            fCreatedContentId = TRUE;
            ntStatus = 
                m_pDrmPort->GetContentRights
                (
                    ulMixDrmContentId, 
                    &MixDrmRights
                );
        }
    }

    // If successful, destroy the old ContentId and update global rights.
    //
    if (NT_SUCCESS(ntStatus))
    {
        m_pDrmPort->DestroyContent(m_ulMixDrmContentId);
        m_ulMixDrmContentId = ulMixDrmContentId;
        RtlCopyMemory(&m_MixDrmRights, &MixDrmRights, sizeof(m_MixDrmRights));

        // At this point the driver should enforce the new DrmRights.
        // MSVAD does not have loopback capture caps and does not support
        // S/PDIF out, therefore the new MixedRights is ignored.

        // MSVAD handles DrmRights per stream basis, and stops writing 
        // the stream to disk, if CopyProtect = TRUE.
        //
    } 

    // Cleanup if failed
    // 
    if (!NT_SUCCESS(ntStatus) && fCreatedContentId)
    {
        m_pDrmPort->DestroyContent(ulMixDrmContentId);
    }

    return ntStatus;
} // UpdateDrmRights

//=============================================================================
// CMiniportWaveStreamCyclicSimple
//=============================================================================

//=============================================================================
CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclicstream 

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream]"));

    if (NULL != m_pMiniportLocal)
    {
        // Tell the Miniport that the slot is freed now.
        //
        if (m_fCapture)
        {
            m_pMiniportLocal->m_fCaptureAllocated = FALSE;
        }
        else
        {
            for (ULONG i = 0; i < m_pMiniportLocal->m_MaxInputStreams; i++)
            {
                if (this == m_pMiniportLocal->m_pStream[i])
                {
                    m_pMiniportLocal->m_pStream[i] = NULL;
                    break;
                }
            }

            // Tell the wave miniport to update mixed drm rights.
            //
            m_pMiniportLocal->UpdateDrmRights();
        }
    }
} // ~CMiniportWaveCyclicStream

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStream::Init
( 
    IN PCMiniportWaveCyclic         Miniport_,
    IN ULONG                        Pin_,
    IN BOOLEAN                      Capture_,
    IN PKSDATAFORMAT                DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ -

  Pin_ -

  Capture_ -

  DataFormat -

  DmaChannel_ -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    m_pMiniportLocal = Miniport_;
    m_ulContentId = 0;

    return 
        CMiniportWaveCyclicStreamMSVAD::Init
        (
            Miniport_,
            Pin_,
            Capture_,
            DataFormat_
        );
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStream::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNEL(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDrmAudioStream))
    {
        *Object = (PVOID)(PDRMAUDIOSTREAM)this;
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
STDMETHODIMP_(NTSTATUS) 
CMiniportWaveCyclicStream::SetContentId
(
    IN  ULONG                   contentId,
    IN  PCDRMRIGHTS             drmRights
)
/*++

Routine Description:

  Sets DRM content Id for this stream. Also updates the Mixed content Id.

Arguments:

  contentId - new content id

  drmRights - rights for this stream.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::SetContentId]"));

    NTSTATUS    ntStatus;
    ULONG       ulOldContentId = contentId;

    m_ulContentId = contentId;

    // Miniport should create a mixed DrmRights.
    //
    ntStatus = m_pMiniportLocal->UpdateDrmRights();

    // Restore the old content Id.
    //
    if (!NT_SUCCESS(ntStatus))
    {
        m_ulContentId = ulOldContentId;
    }

    // MSVAD rights each stream seperately to disk. If the rights for this
    // stream indicates that the stream is CopyProtected, stop writing to disk.
    //
    m_SaveData.Disable(drmRights->CopyProtect);
    
    return ntStatus;
} // SetContentId

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmmult\drmmult.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    multi.h

Abstract:

    Node and Pin numbers for multiple sample.

Revision History:

    Alper Selcuk        06/21/2000      Revised.

--*/

#ifndef _MSVAD_MULTI_H_
#define _MSVAD_MULTI_H_

// Pin properties.
#define MAX_OUTPUT_STREAMS          1       // Number of capture streams.
#define MAX_INPUT_STREAMS           8       // Number of render streams.
#define MAX_TOTAL_STREAMS           MAX_OUTPUT_STREAMS + MAX_INPUT_STREAMS                      

// PCM Info
#define MIN_CHANNELS                1       // Min Channels.
#define MAX_CHANNELS_PCM            2       // Max Channels.
#define MIN_BITS_PER_SAMPLE_PCM     8       // Min Bits Per Sample
#define MAX_BITS_PER_SAMPLE_PCM     16      // Max Bits Per Sample
#define MIN_SAMPLE_RATE             4000    // Min Sample Rate
#define MAX_SAMPLE_RATE             64000   // Max Sample Rate

// Wave pins
enum 
{
    KSPIN_WAVE_CAPTURE_SINK = 0,
    KSPIN_WAVE_CAPTURE_SOURCE,
    KSPIN_WAVE_RENDER_SINK, 
    KSPIN_WAVE_RENDER_SOURCE
};

// Wave Topology nodes.
enum 
{
    KSNODE_WAVE_ADC = 0,
    KSNODE_WAVE_DAC
};

// topology pins.
enum
{
    KSPIN_TOPO_WAVEOUT_SOURCE = 0,
    KSPIN_TOPO_SYNTHOUT_SOURCE,
    KSPIN_TOPO_SYNTHIN_SOURCE,
    KSPIN_TOPO_MIC_SOURCE,
    KSPIN_TOPO_LINEOUT_DEST,
    KSPIN_TOPO_WAVEIN_DEST
};

// topology nodes.
enum
{
    KSNODE_TOPO_WAVEOUT_VOLUME = 0,
    KSNODE_TOPO_WAVEOUT_MUTE,
    KSNODE_TOPO_SYNTHOUT_VOLUME,
    KSNODE_TOPO_SYNTHOUT_MUTE,
    KSNODE_TOPO_MIC_VOLUME,
    KSNODE_TOPO_SYNTHIN_VOLUME,
    KSNODE_TOPO_LINEOUT_MIX,
    KSNODE_TOPO_LINEOUT_VOLUME,
    KSNODE_TOPO_WAVEIN_MUX
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmsimp\mintopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minitopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_MINTOPO_H_
#define _MSVAD_MINTOPO_H_

#include "basetopo.h"

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopology 
//   

class CMiniportTopology : 
    public CMiniportTopologyMSVAD,
    public IMiniportTopology,
    public CUnknown
{
  public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopology);
    ~CMiniportTopology();

    IMP_IMiniportTopology;
};
typedef CMiniportTopology *PCMiniportTopology;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmsimp\wavtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    wavtable.h

Abstract:

    Declaration of wave miniport tables.

--*/

#ifndef _MSVAD_WAVTABLE_H_
#define _MSVAD_WAVTABLE_H_

//=============================================================================
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_PCM,           
        MIN_BITS_PER_SAMPLE_PCM,    
        MAX_BITS_PER_SAMPLE_PCM,    
        MIN_SAMPLE_RATE,            
        MAX_SAMPLE_RATE             
    },
};

static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }
};

static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    // Wave In Streaming Pin (Capture) KSPIN_WAVE_CAPTURE_SINK
    {
        MAX_OUTPUT_STREAMS,
        MAX_OUTPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_RECORDING_CONTROL,  
            0
        }
    },
    
    // Wave In Bridge Pin (Capture - From Topology) KSPIN_WAVE_CAPTURE_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
  
    // Wave Out Streaming Pin (Renderer) KSPIN_WAVE_RENDER_SINK
    {
        MAX_INPUT_STREAMS,
        MAX_INPUT_STREAMS, 
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_VOLUME_CONTROL,
            0
        }
    },
  
    // Wave Out Bridge Pin (Renderer) KSPIN_WAVE_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
};

//=============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // KSNODE_WAVE_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_DAC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};


//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,        KSPIN_WAVE_CAPTURE_SOURCE,  KSNODE_WAVE_ADC,     1 },    
    { KSNODE_WAVE_ADC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_CAPTURE_SINK },    

    { PCFILTER_NODE,        KSPIN_WAVE_RENDER_SINK,     KSNODE_WAVE_DAC,     1 },    
    { KSNODE_WAVE_DAC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_RENDER_SOURCE },    
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories - NULL->use defaults (AUDIO RENDER CAPTURE)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ds2dhw\mintopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minitopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_MINTOPO_H_
#define _MSVAD_MINTOPO_H_

#include "basetopo.h"

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopology 
//   

class CMiniportTopology : 
    public CMiniportTopologyMSVAD,
    public IMiniportTopology,
    public CUnknown
{
  public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopology);
    ~CMiniportTopology();

    IMP_IMiniportTopology;
};
typedef CMiniportTopology *PCMiniportTopology;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmsimp\drmsimp.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    drmsimp.h

Abstract:

    Node and Pin numbers for simple drm sample.

--*/

#ifndef _MSVAD_DRMSIMP_H_
#define _MSVAD_DRMSIMP_H_

// Pin properties.
#define MAX_OUTPUT_STREAMS          1       // Number of capture streams.
#define MAX_INPUT_STREAMS           1       // Number of render streams.
#define MAX_TOTAL_STREAMS           MAX_OUTPUT_STREAMS + MAX_INPUT_STREAMS                      

// PCM Info
#define MIN_CHANNELS                1       // Min Channels.
#define MAX_CHANNELS_PCM            2       // Max Channels.
#define MIN_BITS_PER_SAMPLE_PCM     8       // Min Bits Per Sample
#define MAX_BITS_PER_SAMPLE_PCM     16      // Max Bits Per Sample
#define MIN_SAMPLE_RATE             4000    // Min Sample Rate
#define MAX_SAMPLE_RATE             64000   // Max Sample Rate

// Wave pins
enum 
{
    KSPIN_WAVE_CAPTURE_SINK = 0,
    KSPIN_WAVE_CAPTURE_SOURCE,
    KSPIN_WAVE_RENDER_SINK, 
    KSPIN_WAVE_RENDER_SOURCE
};

// Wave Topology nodes.
enum 
{
    KSNODE_WAVE_ADC = 0,
    KSNODE_WAVE_DAC
};

// topology pins.
enum
{
    KSPIN_TOPO_WAVEOUT_SOURCE = 0,
    KSPIN_TOPO_SYNTHOUT_SOURCE,
    KSPIN_TOPO_SYNTHIN_SOURCE,
    KSPIN_TOPO_MIC_SOURCE,
    KSPIN_TOPO_LINEOUT_DEST,
    KSPIN_TOPO_WAVEIN_DEST
};

// topology nodes.
enum
{
    KSNODE_TOPO_WAVEOUT_VOLUME = 0,
    KSNODE_TOPO_WAVEOUT_MUTE,
    KSNODE_TOPO_SYNTHOUT_VOLUME,
    KSNODE_TOPO_SYNTHOUT_MUTE,
    KSNODE_TOPO_MIC_VOLUME,
    KSNODE_TOPO_SYNTHIN_VOLUME,
    KSNODE_TOPO_LINEOUT_MIX,
    KSNODE_TOPO_LINEOUT_VOLUME,
    KSNODE_TOPO_WAVEIN_MUX
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmsimp\mintopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    mintopo.cpp

Abstract:

    Implementation of topology miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "drmsimp.h"
#include "minwave.h"
#include "mintopo.h"
#include "toptable.h"


/*********************************************************************
* Topology/Wave bridge connection                                    *
*                                                                    *
*              +------+    +------+                                  *
*              | Wave |    | Topo |                                  *
*              |      |    |      |                                  *
*  Capture <---|0    1|<===|4    1|<--- Synth                        *
*              |      |    |      |                                  *
*   Render --->|2    3|===>|0     |                                  *
*              +------+    |      |                                  *
*                          |     2|<--- Mic                          *
*                          |      |                                  *
*                          |     3|---> Line Out                     *
*                          +------+                                  *
*********************************************************************/
PHYSICALCONNECTIONTABLE TopologyPhysicalConnections =
{
    KSPIN_TOPO_WAVEOUT_SOURCE,  // TopologyIn
    KSPIN_TOPO_WAVEIN_DEST,     // TopologyOut
    KSPIN_WAVE_CAPTURE_SOURCE,  // WaveIn
    KSPIN_WAVE_RENDER_SOURCE    // WaveOut
};

#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

    Creates a new topology miniport.

Arguments:

  Unknown - 

  RefclsId -

  UnknownOuter -

  PoolType - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopology, Unknown, UnknownOuter, PoolType);
} // CreateMiniportTopologyMSVAD

//=============================================================================
CMiniportTopology::~CMiniportTopology
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopology::~CMiniportTopology]"));
} // ~CMiniportTopology

//=============================================================================
NTSTATUS
CMiniportTopology::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request. 

  MyDataRange - Pin's data range to be compared with client's data range. 

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter. 

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned. 

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::DataRangeIntersection
        (
            PinId,
            ClientDataRange,
            MyDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP
CMiniportTopology::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportTopology::Init
( 
    IN PUNKNOWN                 UnknownAdapter,
    IN PRESOURCELIST            ResourceList,
    IN PPORTTOPOLOGY            Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopology::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        CMiniportTopologyMSVAD::Init
        (
            UnknownAdapter,
            Port_
        );

    if (NT_SUCCESS(ntStatus))
    {
        m_FilterDescriptor = &MiniportFilterDescriptor;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP
CMiniportTopology::NonDelegatingQueryInterface
( 
    IN  REFIID                  Interface,
    OUT PVOID                   * Object 
)
/*++

Routine Description:

  QueryInterface for MiniportTopology

Arguments:

  Interface - GUID of the interface

  Object - interface object to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.
        PUNKNOWN(*Object)->AddRef();
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
PropertyHandler_Topology
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Topology]"));

    return ((PCMiniportTopology)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Topology

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ds2dhw\mintopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    mintopo.cpp

Abstract:

    Implementation of topology miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "ds2dhw.h"
#include "minwave.h"
#include "mintopo.h"
#include "toptable.h"


/*********************************************************************
* Topology/Wave bridge connection                                    *
*                                                                    *
*              +------+    +------+                                  *
*              | Wave |    | Topo |                                  *
*              |      |    |      |                                  *
*  Capture <---|0    1|<===|4    1|<--- Synth                        *
*              |      |    |      |                                  *
*   Render --->|2    3|===>|0     |                                  *
*              +------+    |      |                                  *
*                          |     2|<--- Mic                          *
*                          |      |                                  *
*                          |     3|---> Line Out                     *
*                          +------+                                  *
*********************************************************************/
PHYSICALCONNECTIONTABLE TopologyPhysicalConnections =
{
    KSPIN_TOPO_WAVEOUT_SOURCE,  // TopologyIn
    KSPIN_TOPO_WAVEIN_DEST,     // TopologyOut
    KSPIN_WAVE_CAPTURE_SOURCE,  // WaveIn
    KSPIN_WAVE_RENDER_SOURCE    // WaveOut
};

#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

    Creates a new topology miniport.

Arguments:

  Unknown - 

  RefclsId -

  UnknownOuter -

  PoolType - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopology, Unknown, UnknownOuter, PoolType);
} // CreateMiniportTopologyMSVAD

//=============================================================================
CMiniportTopology::~CMiniportTopology
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopology::~CMiniportTopology]"));
} // ~CMiniportTopology

//=============================================================================
NTSTATUS
CMiniportTopology::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request. 

  MyDataRange - Pin's data range to be compared with client's data range. 

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter. 

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned. 

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::DataRangeIntersection
        (
            PinId,
            ClientDataRange,
            MyDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP
CMiniportTopology::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportTopology::Init
( 
    IN PUNKNOWN                 UnknownAdapter,
    IN PRESOURCELIST            ResourceList,
    IN PPORTTOPOLOGY            Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopology::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        CMiniportTopologyMSVAD::Init
        (
            UnknownAdapter,
            Port_
        );

    if (NT_SUCCESS(ntStatus))
    {
        m_FilterDescriptor = &MiniportFilterDescriptor;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP
CMiniportTopology::NonDelegatingQueryInterface
( 
    IN  REFIID                  Interface,
    OUT PVOID                   * Object 
)
/*++

Routine Description:

  QueryInterface for MiniportTopology

Arguments:

  Interface - GUID of the interface

  Object - interface object to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.
        PUNKNOWN(*Object)->AddRef();
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
PropertyHandler_Topology
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Topology]"));

    return ((PCMiniportTopology)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Topology

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmsimp\toptable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    toptable.h

Abstract:

    Declaration of topology tables.

--*/

#ifndef _MSVAD_TOPTABLE_H_
#define _MSVAD_TOPTABLE_H_

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
 {
   sizeof(KSDATARANGE),
   0,
   0,
   0,
   STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
   STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
   STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
 }
};

//=============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
  &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
  // KSPIN_TOPO_WAVEOUT_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHOUT_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHIN_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_MIC_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_MICROPHONE,                       // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_LINEOUT_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SPEAKER,                          // Category
      &KSAUDFNAME_VOLUME_CONTROL,                   // Name (this name shows up as
                                                    // the playback panel name in SoundVol)
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_WAVEIN_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  }
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
    },
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMute[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute, PropertiesMute);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMux[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMux, PropertiesMux);

//=============================================================================
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
  // KSNODE_TOPO_WAVEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_WAVE_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_WAVE_MUTE   // Name
  },

  // KSNODE_TOPO_SYNTHOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_SYNTHOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_MIDI_MUTE   // Name
  },

  // KSNODE_TOPO_MIC_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIC_VOLUME  // Name
  },

  // KSNODE_TOPO_SYNTHIN_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_LINEOUT_MIX
  {
    0,                      // Flags
    NULL,                   // AutomationTable
    &KSNODETYPE_SUM,        // Type
    NULL                    // Name
  },

  // KSNODE_TOPO_LINEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MASTER_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEIN_MUX
  {
    0,                      // Flags
    &AutomationMux,         // AutomationTable
    &KSNODETYPE_MUX,        // Type
    &KSAUDFNAME_RECORDING_SOURCE // Name
  },
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
  //  FromNode,                     FromPin,                        ToNode,                      ToPin
  {   PCFILTER_NODE,                KSPIN_TOPO_WAVEOUT_SOURCE,      KSNODE_TOPO_WAVEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_WAVEOUT_VOLUME,   0,                              KSNODE_TOPO_WAVEOUT_MUTE,    1 },
  {   KSNODE_TOPO_WAVEOUT_MUTE,     0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHOUT_SOURCE,     KSNODE_TOPO_SYNTHOUT_VOLUME, 1 },
  {   KSNODE_TOPO_SYNTHOUT_VOLUME,  0,                              KSNODE_TOPO_SYNTHOUT_MUTE,   1 },
  {   KSNODE_TOPO_SYNTHOUT_MUTE,    0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHIN_SOURCE,      KSNODE_TOPO_SYNTHIN_VOLUME,  1 },
  {   KSNODE_TOPO_SYNTHIN_VOLUME,   0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   PCFILTER_NODE,                KSPIN_TOPO_MIC_SOURCE,          KSNODE_TOPO_MIC_VOLUME,      1 },
  {   KSNODE_TOPO_MIC_VOLUME,       0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   KSNODE_TOPO_LINEOUT_MIX,      0,                              KSNODE_TOPO_LINEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_LINEOUT_VOLUME,   0,                              PCFILTER_NODE,               KSPIN_TOPO_LINEOUT_DEST },

  {   KSNODE_TOPO_WAVEIN_MUX,       0,                              PCFILTER_NODE,               KSPIN_TOPO_WAVEIN_DEST }
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
  0,                                  // Version
  NULL,                               // AutomationTable
  sizeof(PCPIN_DESCRIPTOR),           // PinSize
  SIZEOF_ARRAY(MiniportPins),         // PinCount
  MiniportPins,                       // Pins
  sizeof(PCNODE_DESCRIPTOR),          // NodeSize
  SIZEOF_ARRAY(TopologyNodes),        // NodeCount
  TopologyNodes,                      // Nodes
  SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
  MiniportConnections,                // Connections
  0,                                  // CategoryCount
  NULL                                // Categories
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmsimp\minwave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "drmsimp.h"
#include "minwave.h"
#include "wavtable.h"

#pragma code_seg("PAGE")

//=============================================================================
// CMiniportWaveCyclic
//=============================================================================

//=============================================================================
NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Create the wavecyclic miniport.

Arguments:

  Unknown - 

  RefClsId -

  UnknownOuter -

  PoolType -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportWaveCyclic, Unknown, UnknownOuter, PoolType);
}

//=============================================================================
CMiniportWaveCyclic::~CMiniportWaveCyclic
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::~CMiniportWaveCyclic]"));
} // ~CMiniportWaveCyclic


//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::DataRangeIntersection
( 
    IN  ULONG                       PinId,
    IN  PKSDATARANGE                ClientDataRange,
    IN  PKSDATARANGE                MyDataRange,
    IN  ULONG                       OutputBufferLength,
    OUT PVOID                       ResultantFormat,
    OUT PULONG                      ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId -           Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data 
                    range submitted by client in the data range intersection 
                    property request. 

  MyDataRange -         Pin's data range to be compared with client's data 
                        range. In this case we actually ignore our own data 
                        range, because we know that we only support one range.

  OutputBufferLength -  Size of the buffer pointed to by the resultant format 
                        parameter. 

  ResultantFormat -     Pointer to value where the resultant format should be 
                        returned. 

  ResultantFormatLength -   Actual length of the resultant format placed in 
                            ResultantFormat. This should be less than or equal 
                            to OutputBufferLength. 

  Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    // This driver only supports PCM formats.
    // Portcls will handle the request for us.
    //

    return STATUS_NOT_IMPLEMENTED;
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    return 
        CMiniportWaveCyclicMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    NTSTATUS                    ntStatus;

    DPF_ENTER(("[CMiniportWaveCyclic::Init]"));

    m_MaxOutputStreams      = MAX_OUTPUT_STREAMS;
    m_MaxInputStreams       = MAX_INPUT_STREAMS;
    m_MaxTotalStreams       = MAX_TOTAL_STREAMS;

    m_MinChannels           = MIN_CHANNELS;
    m_MaxChannelsPcm        = MAX_CHANNELS_PCM;

    m_MinBitsPerSamplePcm   = MIN_BITS_PER_SAMPLE_PCM;
    m_MaxBitsPerSamplePcm   = MAX_BITS_PER_SAMPLE_PCM;
    m_MinSampleRatePcm      = MIN_SAMPLE_RATE;
    m_MaxSampleRatePcm      = MAX_SAMPLE_RATE;
    
    ntStatus =
        CMiniportWaveCyclicMSVAD::Init
        (
            UnknownAdapter_,
            ResourceList_,
            Port_
        );
    if (NT_SUCCESS(ntStatus))
    {
        // Set filter descriptor.
        m_FilterDescriptor = &MiniportFilterDescriptor;

        m_fCaptureAllocated = FALSE;
        m_fRenderAllocated = FALSE;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NewStream
( 
    OUT PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  ULONG                   Pin,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL *           OutDmaChannel,
    OUT PSERVICEGROUP *         OutServiceGroup 
)
/*++

Routine Description:

  The NewStream function creates a new instance of a logical stream 
  associated with a specified physical channel. Callers of NewStream should 
  run at IRQL PASSIVE_LEVEL.

Arguments:

  OutStream -

  OuterUnknown -

  PoolType - 

  Pin - 

  Capture - 

  DataFormat -

  OutDmaChannel -

  OutServiceGroup -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    DPF_ENTER(("[CMiniportWaveCyclic::NewStream]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PCMiniportWaveCyclicStream  stream = NULL;

    // Check if we have enough streams.
    if (Capture)
    {
        if (m_fCaptureAllocated)
        {
            DPF(D_TERSE, ("[Only one capture stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        if (m_fRenderAllocated)
        {
            DPF(D_TERSE, ("[Only one render stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    // Instantiate a stream. Stream must be in
    // NonPagedPool because of file saving.
    //
    if (NT_SUCCESS(ntStatus))
    {
        stream = new (NonPagedPool, MSVAD_POOLTAG) 
            CMiniportWaveCyclicStream(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus = 
                stream->Init
                ( 
                    this,
                    Pin,
                    Capture,
                    DataFormat
                );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (Capture)
        {
            m_fCaptureAllocated = TRUE;
        }
        else
        {
            m_fRenderAllocated = TRUE;
        }

        *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
        (*OutStream)->AddRef();
        
        *OutDmaChannel = PDMACHANNEL(stream);
        (*OutDmaChannel)->AddRef();

        *OutServiceGroup = m_ServiceGroup;
        (*OutServiceGroup)->AddRef();

        // The stream, the DMA channel, and the service group have
        // references now for the caller.  The caller expects these
        // references to be there.
    }

    // This is our private reference to the stream.  The caller has
    // its own, so we can release in any case.
    //
    if (stream)
    {
        stream->Release();
    }
    
    return ntStatus;
} // NewStream

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.

        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
// CMiniportWaveStreamCyclicSimple
//=============================================================================

//=============================================================================
CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclicstream 

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream]"));

    if (NULL != m_pMiniportLocal)
    {
        if (m_fCapture)
        {
            m_pMiniportLocal->m_fCaptureAllocated = FALSE;
        }
        else
        {
            m_pMiniportLocal->m_fRenderAllocated = FALSE;
        }
    }
} // ~CMiniportWaveCyclicStream

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStream::Init
( 
    IN PCMiniportWaveCyclic         Miniport_,
    IN ULONG                        Pin_,
    IN BOOLEAN                      Capture_,
    IN PKSDATAFORMAT                DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ -

  Pin_ -

  Capture_ -

  DataFormat -

  DmaChannel_ -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    m_pMiniportLocal = Miniport_;

    return 
        CMiniportWaveCyclicStreamMSVAD::Init
        (
            Miniport_,
            Pin_,
            Capture_,
            DataFormat_
        );
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStream::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNEL(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDrmAudioStream))
    {
        *Object = (PVOID)(PDRMAUDIOSTREAM)this;
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
STDMETHODIMP_(NTSTATUS) 
CMiniportWaveCyclicStream::SetContentId
(
    IN  ULONG                   contentId,
    IN  PCDRMRIGHTS             drmRights
)
/*++

Routine Description:

  Sets DRM content Id for this stream. Also updates the Mixed content Id.

Arguments:

  contentId - new content id

  drmRights - rights for this stream.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::SetContentId]"));

    // if (drmRights.CopyProtect==TRUE)
    // Stop writing this stream to disk
    // 
    // if (drmRights.DigitalOutputDisable == TRUE)
    // Mute S/PDIF out. 
    // MSVAD does not support S/PDIF out. 
    //
    // To learn more about managing multiple streams, please look at MSVAD\drmmult
    //
    m_SaveData.Disable(drmRights->CopyProtect);
    
    return STATUS_SUCCESS;
} // SetContentId

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmsimp\minwave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.h

Abstract:

    Definition of wavecyclic miniport class.

--*/

#ifndef _MSVAD_MINWAVE_H_
#define _MSVAD_MINWAVE_H_

#include "basewave.h"

//=============================================================================
// Referenced Forward
//=============================================================================
class CMiniportWaveCyclicStream;
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclic 
//   

class CMiniportWaveCyclic : 
    public CMiniportWaveCyclicMSVAD,
    public IMiniportWaveCyclic,
    public CUnknown
{
private:
    BOOL                        m_fCaptureAllocated;
    BOOL                        m_fRenderAllocated;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclic);
    ~CMiniportWaveCyclic();

    IMP_IMiniportWaveCyclic;

    // Friends
    friend class                CMiniportWaveCyclicStream;
    friend class                CMiniportTopologySimple;
};
typedef CMiniportWaveCyclic *PCMiniportWaveCyclic;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStream 
//   

class CMiniportWaveCyclicStream : 
    public IDrmAudioStream,
    public CMiniportWaveCyclicStreamMSVAD,
    public CUnknown
{
protected:
    PCMiniportWaveCyclic        m_pMiniportLocal;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStream);
    ~CMiniportWaveCyclicStream();

    IMP_IDrmAudioStream;

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclic Miniport,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class                CMiniportWaveCyclic;
};
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ds2dhw\ds2dhw.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    ds2dhw.h

Abstract:

    Node and Pin numbers for DirectSound 2D HW sample

Revision History:

    Alper Selcuk        08/01/2000      Revised.

--*/

#ifndef _MSVAD_MULTI_H_
#define _MSVAD_MULTI_H_

// Pin properties.
#define MAX_OUTPUT_STREAMS          1       // Number of capture streams.
#define MAX_INPUT_STREAMS           8       // Number of render streams.
#define MAX_TOTAL_STREAMS           MAX_OUTPUT_STREAMS + MAX_INPUT_STREAMS                      

// PCM Info
#define MIN_CHANNELS                1       // Min Channels.
#define MAX_CHANNELS_PCM            2       // Max Channels.
#define MIN_BITS_PER_SAMPLE_PCM     8       // Min Bits Per Sample
#define MAX_BITS_PER_SAMPLE_PCM     16      // Max Bits Per Sample
#define MIN_SAMPLE_RATE             4000    // Min Sample Rate
#define MAX_SAMPLE_RATE             64000   // Max Sample Rate

// Wave pins
enum 
{
    KSPIN_WAVE_CAPTURE_SINK = 0,
    KSPIN_WAVE_CAPTURE_SOURCE,
    KSPIN_WAVE_RENDER_SINK, 
    KSPIN_WAVE_RENDER_SOURCE
};

// Wave Topology nodes.
enum 
{
    KSNODE_WAVE_ADC = 0,
    KSNODE_WAVE_DAC,
    KSNODE_WAVE_VOLUME1,
    KSNODE_WAVE_SUPERMIX,
    KSNODE_WAVE_VOLUME2,
    KSNODE_WAVE_SRC,
    KSNODE_WAVE_SUM
};

// topology pins.
enum
{
    KSPIN_TOPO_WAVEOUT_SOURCE = 0,
    KSPIN_TOPO_SYNTHOUT_SOURCE,
    KSPIN_TOPO_SYNTHIN_SOURCE,
    KSPIN_TOPO_MIC_SOURCE,
    KSPIN_TOPO_LINEOUT_DEST,
    KSPIN_TOPO_WAVEIN_DEST
};

// topology nodes.
enum
{
    KSNODE_TOPO_WAVEOUT_VOLUME = 0,
    KSNODE_TOPO_WAVEOUT_MUTE,
    KSNODE_TOPO_SYNTHOUT_VOLUME,
    KSNODE_TOPO_SYNTHOUT_MUTE,
    KSNODE_TOPO_MIC_VOLUME,
    KSNODE_TOPO_SYNTHIN_VOLUME,
    KSNODE_TOPO_LINEOUT_MIX,
    KSNODE_TOPO_LINEOUT_VOLUME,
    KSNODE_TOPO_WAVEIN_MUX
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\multstr\mintopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minitopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_MINTOPO_H_
#define _MSVAD_MINTOPO_H_

#include "basetopo.h"

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopology 
//   

class CMiniportTopology : 
    public CMiniportTopologyMSVAD,
    public IMiniportTopology,
    public CUnknown
{
  public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopology);
    ~CMiniportTopology();

    IMP_IMiniportTopology;
};
typedef CMiniportTopology *PCMiniportTopology;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\multstr\multi.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    multi.h

Abstract:

    Node and Pin numbers for multiple sample.

Revision History:

    Alper Selcuk        06/21/2000      Revised.

--*/

#ifndef _MSVAD_MULTI_H_
#define _MSVAD_MULTI_H_

// Pin properties.
#define MAX_OUTPUT_STREAMS          1       // Number of capture streams.
#define MAX_INPUT_STREAMS           8       // Number of render streams.
#define MAX_TOTAL_STREAMS           MAX_OUTPUT_STREAMS + MAX_INPUT_STREAMS                      

// PCM Info
#define MIN_CHANNELS                1       // Min Channels.
#define MAX_CHANNELS_PCM            2       // Max Channels.
#define MIN_BITS_PER_SAMPLE_PCM     8       // Min Bits Per Sample
#define MAX_BITS_PER_SAMPLE_PCM     16      // Max Bits Per Sample
#define MIN_SAMPLE_RATE             4000    // Min Sample Rate
#define MAX_SAMPLE_RATE             64000   // Max Sample Rate

// Wave pins
enum 
{
    KSPIN_WAVE_CAPTURE_SINK = 0,
    KSPIN_WAVE_CAPTURE_SOURCE,
    KSPIN_WAVE_RENDER_SINK, 
    KSPIN_WAVE_RENDER_SOURCE
};

// Wave Topology nodes.
enum 
{
    KSNODE_WAVE_ADC = 0,
    KSNODE_WAVE_DAC
};

// topology pins.
enum
{
    KSPIN_TOPO_WAVEOUT_SOURCE = 0,
    KSPIN_TOPO_SYNTHOUT_SOURCE,
    KSPIN_TOPO_SYNTHIN_SOURCE,
    KSPIN_TOPO_MIC_SOURCE,
    KSPIN_TOPO_LINEOUT_DEST,
    KSPIN_TOPO_WAVEIN_DEST
};

// topology nodes.
enum
{
    KSNODE_TOPO_WAVEOUT_VOLUME = 0,
    KSNODE_TOPO_WAVEOUT_MUTE,
    KSNODE_TOPO_SYNTHOUT_VOLUME,
    KSNODE_TOPO_SYNTHOUT_MUTE,
    KSNODE_TOPO_MIC_VOLUME,
    KSNODE_TOPO_SYNTHIN_VOLUME,
    KSNODE_TOPO_LINEOUT_MIX,
    KSNODE_TOPO_LINEOUT_VOLUME,
    KSNODE_TOPO_WAVEIN_MUX
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ds2dhw\toptable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    toptable.h

Abstract:

    Declaration of topology tables.

--*/

#ifndef _MSVAD_TOPTABLE_H_
#define _MSVAD_TOPTABLE_H_

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
 {
   sizeof(KSDATARANGE),
   0,
   0,
   0,
   STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
   STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
   STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
 }
};

//=============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
  &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
  // KSPIN_TOPO_WAVEOUT_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHOUT_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHIN_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_MIC_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_MICROPHONE,                       // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_LINEOUT_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SPEAKER,                          // Category
      &KSAUDFNAME_VOLUME_CONTROL,                   // Name (this name shows up as
                                                    // the playback panel name in SoundVol)
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_WAVEIN_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  }
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMute[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute, PropertiesMute);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMux[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMux, PropertiesMux);

//=============================================================================
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
  // KSNODE_TOPO_WAVEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_WAVE_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_WAVE_MUTE   // Name
  },

  // KSNODE_TOPO_SYNTHOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_SYNTHOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_MIDI_MUTE   // Name
  },

  // KSNODE_TOPO_MIC_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIC_VOLUME  // Name
  },

  // KSNODE_TOPO_SYNTHIN_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_LINEOUT_MIX
  {
    0,                      // Flags
    NULL,                   // AutomationTable
    &KSNODETYPE_SUM,        // Type
    NULL                    // Name
  },

  // KSNODE_TOPO_LINEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MASTER_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEIN_MUX
  {
    0,                      // Flags
    &AutomationMux,         // AutomationTable
    &KSNODETYPE_MUX,        // Type
    &KSAUDFNAME_RECORDING_SOURCE // Name
  },
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
  //  FromNode,                     FromPin,                        ToNode,                      ToPin
  {   PCFILTER_NODE,                KSPIN_TOPO_WAVEOUT_SOURCE,      KSNODE_TOPO_WAVEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_WAVEOUT_VOLUME,   0,                              KSNODE_TOPO_WAVEOUT_MUTE,    1 },
  {   KSNODE_TOPO_WAVEOUT_MUTE,     0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHOUT_SOURCE,     KSNODE_TOPO_SYNTHOUT_VOLUME, 1 },
  {   KSNODE_TOPO_SYNTHOUT_VOLUME,  0,                              KSNODE_TOPO_SYNTHOUT_MUTE,   1 },
  {   KSNODE_TOPO_SYNTHOUT_MUTE,    0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHIN_SOURCE,      KSNODE_TOPO_SYNTHIN_VOLUME,  1 },
  {   KSNODE_TOPO_SYNTHIN_VOLUME,   0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   PCFILTER_NODE,                KSPIN_TOPO_MIC_SOURCE,          KSNODE_TOPO_MIC_VOLUME,      1 },
  {   KSNODE_TOPO_MIC_VOLUME,       0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   KSNODE_TOPO_LINEOUT_MIX,      0,                              KSNODE_TOPO_LINEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_LINEOUT_VOLUME,   0,                              PCFILTER_NODE,               KSPIN_TOPO_LINEOUT_DEST },

  {   KSNODE_TOPO_WAVEIN_MUX,       0,                              PCFILTER_NODE,               KSPIN_TOPO_WAVEIN_DEST }
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
  0,                                  // Version
  NULL,                               // AutomationTable
  sizeof(PCPIN_DESCRIPTOR),           // PinSize
  SIZEOF_ARRAY(MiniportPins),         // PinCount
  MiniportPins,                       // Pins
  sizeof(PCNODE_DESCRIPTOR),          // NodeSize
  SIZEOF_ARRAY(TopologyNodes),        // NodeCount
  TopologyNodes,                      // Nodes
  SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
  MiniportConnections,                // Connections
  0,                                  // CategoryCount
  NULL                                // Categories
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ds2dhw\minwave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.h

Abstract:

    Definition of wavecyclic miniport class.

--*/

#ifndef _MSVAD_MINWAVE_H_
#define _MSVAD_MINWAVE_H_

#include "basewave.h"

//=============================================================================
// Referenced Forward
//=============================================================================
class CMiniportWaveCyclicStream;
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclic 
//   

class CMiniportWaveCyclic : 
    public CMiniportWaveCyclicMSVAD,
    public IMiniportWaveCyclic,
    public CUnknown
{
private:
    PCMiniportWaveCyclicStream  m_pStream[MAX_INPUT_STREAMS];
    BOOL                        m_fCaptureAllocated;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclic);
    ~CMiniportWaveCyclic();

    IMP_IMiniportWaveCyclic;

    NTSTATUS                    PropertyHandlerGeneric
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    NTSTATUS                    PropertyHandlerSamplingRate
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    // Friends
    friend class                CMiniportWaveCyclicStream;
    friend class                CMiniportTopologySimple;
};
typedef CMiniportWaveCyclic *PCMiniportWaveCyclic;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStream 
//   

class CMiniportWaveCyclicStream : 
    public CMiniportWaveCyclicStreamMSVAD,
    public CUnknown
{
protected:  
    PCMiniportWaveCyclic        m_pMiniportLocal;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStream);
    ~CMiniportWaveCyclicStream();

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclic Miniport,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class                CMiniportWaveCyclic;
};
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\multstr\wavtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    wavtable.h

Abstract:

    Declaration of wave miniport tables.

--*/

#ifndef _MSVAD_WAVTABLE_H_
#define _MSVAD_WAVTABLE_H_

//=============================================================================
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_PCM,           
        MIN_BITS_PER_SAMPLE_PCM,    
        MAX_BITS_PER_SAMPLE_PCM,    
        MIN_SAMPLE_RATE,            
        MAX_SAMPLE_RATE             
    },
};

static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }
};

static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    // Wave In Streaming Pin (Capture) KSPIN_WAVE_CAPTURE_SINK
    {
        MAX_OUTPUT_STREAMS,
        MAX_OUTPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_RECORDING_CONTROL,  
            0
        }
    },
    
    // Wave In Bridge Pin (Capture - From Topology) KSPIN_WAVE_CAPTURE_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
  
    // Wave Out Streaming Pin (Renderer) KSPIN_WAVE_RENDER_SINK
    {
        MAX_INPUT_STREAMS,
        MAX_INPUT_STREAMS, 
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_VOLUME_CONTROL,
            0
        }
    },
  
    // Wave Out Bridge Pin (Renderer) KSPIN_WAVE_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
};

//=============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // KSNODE_WAVE_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_DAC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};


//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,        KSPIN_WAVE_CAPTURE_SOURCE,  KSNODE_WAVE_ADC,     1 },    
    { KSNODE_WAVE_ADC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_CAPTURE_SINK },    

    { PCFILTER_NODE,        KSPIN_WAVE_RENDER_SINK,     KSNODE_WAVE_DAC,     1 },    
    { KSNODE_WAVE_DAC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_RENDER_SOURCE },    
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories - NULL->use defaults (AUDIO RENDER CAPTURE)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ds2dhw\minwave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "ds2dhw.h"
#include "minwave.h"
#include "wavtable.h"

#pragma code_seg("PAGE")

//=============================================================================
// CMiniportWaveCyclic
//=============================================================================

//=============================================================================
NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Create the wavecyclic miniport.

Arguments:

  Unknown - 

  RefClsId -

  UnknownOuter -

  PoolType -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportWaveCyclic, Unknown, UnknownOuter, PoolType);
}

//=============================================================================
CMiniportWaveCyclic::~CMiniportWaveCyclic
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::~CMiniportWaveCyclic]"));
} // ~CMiniportWaveCyclic


//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::DataRangeIntersection
( 
    IN  ULONG                       PinId,
    IN  PKSDATARANGE                ClientDataRange,
    IN  PKSDATARANGE                MyDataRange,
    IN  ULONG                       OutputBufferLength,
    OUT PVOID                       ResultantFormat,
    OUT PULONG                      ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId -           Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data 
                    range submitted by client in the data range intersection 
                    property request. 

  MyDataRange -         Pin's data range to be compared with client's data 
                        range. In this case we actually ignore our own data 
                        range, because we know that we only support one range.

  OutputBufferLength -  Size of the buffer pointed to by the resultant format 
                        parameter. 

  ResultantFormat -     Pointer to value where the resultant format should be 
                        returned. 

  ResultantFormatLength -   Actual length of the resultant format placed in 
                            ResultantFormat. This should be less than or equal 
                            to OutputBufferLength. 

  Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    // This driver only supports PCM formats.
    // Portcls will handle the request for us.
    //

    return STATUS_NOT_IMPLEMENTED;
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    return 
        CMiniportWaveCyclicMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    NTSTATUS                    ntStatus;

    DPF_ENTER(("[CMiniportWaveCyclic::Init]"));

    m_MaxOutputStreams      = MAX_OUTPUT_STREAMS;
    m_MaxInputStreams       = MAX_INPUT_STREAMS;
    m_MaxTotalStreams       = MAX_TOTAL_STREAMS;

    m_MinChannels           = MIN_CHANNELS;
    m_MaxChannelsPcm        = MAX_CHANNELS_PCM;

    m_MinBitsPerSamplePcm   = MIN_BITS_PER_SAMPLE_PCM;
    m_MaxBitsPerSamplePcm   = MAX_BITS_PER_SAMPLE_PCM;
    m_MinSampleRatePcm      = MIN_SAMPLE_RATE;
    m_MaxSampleRatePcm      = MAX_SAMPLE_RATE;

    ntStatus =
        CMiniportWaveCyclicMSVAD::Init
        (
            UnknownAdapter_,
            ResourceList_,
            Port_
        );
    if (NT_SUCCESS(ntStatus))
    {
        // Set filter descriptor.
        m_FilterDescriptor = &MiniportFilterDescriptor;

        m_fCaptureAllocated = FALSE;
        RtlZeroMemory
        (
            m_pStream, 
            MAX_INPUT_STREAMS * sizeof(PCMiniportWaveCyclicStream)
        );
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NewStream
( 
    OUT PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  ULONG                   Pin,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL *           OutDmaChannel,
    OUT PSERVICEGROUP *         OutServiceGroup 
)
/*++

Routine Description:

  The NewStream function creates a new instance of a logical stream 
  associated with a specified physical channel. Callers of NewStream should 
  run at IRQL PASSIVE_LEVEL.

Arguments:

  OutStream -

  OuterUnknown -

  PoolType - 

  Pin - 

  Capture - 

  DataFormat -

  OutDmaChannel -

  OutServiceGroup -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    DPF_ENTER(("[CMiniportWaveCyclic::NewStream]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PCMiniportWaveCyclicStream  stream = NULL;
    ULONG                       streamIndex;

    // MSVAD supports one capture stream.
    //
    if (Capture)
    {
        if (m_fCaptureAllocated)
        {
            DPF(D_TERSE, ("[Only one capture stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    // This version supports multiple playback streams.
    //
    else
    {
        for (streamIndex = 0; streamIndex < m_MaxInputStreams; streamIndex++)
        {
            if (!m_pStream[streamIndex])
            {
                break;
            }
        }
        if (streamIndex == m_MaxInputStreams)
        {
            DPF(D_TERSE, ("[All render streams are in use]"));            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    // Instantiate a stream. Stream must be in
    // NonPagedPool because of file saving.
    //
    if (NT_SUCCESS(ntStatus))
    {
        stream = new (NonPagedPool, MSVAD_POOLTAG) 
            CMiniportWaveCyclicStream(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus = 
                stream->Init
                ( 
                    this,
                    Pin,
                    Capture,
                    DataFormat
                );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (Capture)
        {
            m_fCaptureAllocated = TRUE;
        }
        else
        {
            m_pStream[streamIndex] = stream;
        }

        *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
        (*OutStream)->AddRef();
        
        *OutDmaChannel = PDMACHANNEL(stream);
        (*OutDmaChannel)->AddRef();

        *OutServiceGroup = m_ServiceGroup;
        (*OutServiceGroup)->AddRef();

        // The stream, the DMA channel, and the service group have
        // references now for the caller.  The caller expects these
        // references to be there.
    }

    // This is our private reference to the stream.  The caller has
    // its own, so we can release in any case.
    //
    if (stream)
    {
        stream->Release();
    }
    
    return ntStatus;
} // NewStream

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.

        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS                            
CMiniportWaveCyclic::PropertyHandlerGeneric
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
/*++

Routine Description:

  Handles all properties for this miniport.

Arguments:

  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);
    ASSERT(PropertyRequest->PropertyItem);

    NTSTATUS    ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    switch (PropertyRequest->PropertyItem->Id)
    {
        case KSPROPERTY_AUDIO_SAMPLING_RATE:
            ntStatus = PropertyHandlerSamplingRate(PropertyRequest);
            break;
    
        default:
            ntStatus = 
                CMiniportWaveCyclicMSVAD::PropertyHandlerGeneric
                (
                    PropertyRequest
                );
    }

    return ntStatus;
} // PropertyHandlerGeneric

//=============================================================================
NTSTATUS                    
CMiniportWaveCyclic::PropertyHandlerSamplingRate
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
{
    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    DPF_ENTER(("[CMiniportWaveCyclic::PropertyHandlerSamplingRate]"));

    if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
    {
        ntStatus = ValidatePropertyParams(PropertyRequest, sizeof(LONG), 0);
        if (NT_SUCCESS(ntStatus))
        {
            *(PULONG(PropertyRequest->Value)) = m_SamplingFrequency;
            PropertyRequest->ValueSize = sizeof(LONG);
        }
    }
    else if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
    {
        ntStatus = ValidatePropertyParams(PropertyRequest, sizeof(LONG), 0);
        if (NT_SUCCESS(ntStatus))
        {
            ULONG ulSamplingRate = *(PULONG(PropertyRequest->Value));

            // Check if the sample rate is available.
            //
            if (ulSamplingRate >= m_MinSampleRatePcm && 
                ulSamplingRate <= m_MaxSampleRatePcm)
            {
                m_SamplingFrequency = ulSamplingRate;
            }
            else
            {
                DPF(D_TERSE, ("[SampleRate not supported]"));
                ntStatus = STATUS_INVALID_PARAMETER;
            }
        }
    }
    else if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = 
            PropertyHandler_BasicSupport
            (
                PropertyRequest, 
                KSPROPERTY_TYPE_ALL,
                VT_I4
            );
    }

    return ntStatus;
} // PropertyHandlerSamplingRate

//=============================================================================
// CMiniportWaveStreamCyclicSimple
//=============================================================================

//=============================================================================
CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclicstream 

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream]"));

    // Tell the Miniport that the slot is freed now.
    //
    if (NULL != m_pMiniportLocal)
    {
        if (m_fCapture)
        {
            m_pMiniportLocal->m_fCaptureAllocated = FALSE;
        }
        else
        {
            for (ULONG i = 0; i < m_pMiniportLocal->m_MaxInputStreams; i++)
            {
                if (this == m_pMiniportLocal->m_pStream[i])
                {
                    m_pMiniportLocal->m_pStream[i] = NULL;
                    break;
                }
            }
        }
    }
} // ~CMiniportWaveCyclicStream

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStream::Init
( 
    IN PCMiniportWaveCyclic         Miniport_,
    IN ULONG                        Pin_,
    IN BOOLEAN                      Capture_,
    IN PKSDATAFORMAT                DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ -

  Pin_ -

  Capture_ -

  DataFormat -

  DmaChannel_ -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    m_pMiniportLocal = Miniport_;

    return 
        CMiniportWaveCyclicStreamMSVAD::Init
        (
            Miniport_,
            Pin_,
            Capture_,
            DataFormat_
        );
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStream::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNEL(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface
#pragma code_seg()

#pragma code_seg("PAGE")
//=============================================================================
NTSTATUS
PropertyHandler_Wave
( 
    IN  PPCPROPERTY_REQUEST     PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Wave]"));

    return ((PCMiniportWaveCyclic)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Wave
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\pcmex\mintopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minitopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_MINTOPO_H_
#define _MSVAD_MINTOPO_H_

#include "basetopo.h"

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopology 
//   

class CMiniportTopology : 
    public CMiniportTopologyMSVAD,
    public IMiniportTopology,
    public CUnknown
{
  public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopology);
    ~CMiniportTopology();

    IMP_IMiniportTopology;
};
typedef CMiniportTopology *PCMiniportTopology;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\multstr\minwave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.h

Abstract:

    Definition of wavecyclic miniport class.

--*/

#ifndef _MSVAD_MINWAVE_H_
#define _MSVAD_MINWAVE_H_

#include "basewave.h"

//=============================================================================
// Referenced Forward
//=============================================================================
class CMiniportWaveCyclicStream;
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclic 
//   

class CMiniportWaveCyclic : 
    public CMiniportWaveCyclicMSVAD,
    public IMiniportWaveCyclic,
    public IPinCount,
    public CUnknown
{
private:
    PCMiniportWaveCyclicStream  m_pStream[MAX_INPUT_STREAMS];
    BOOL                        m_fCaptureAllocated;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclic);
    ~CMiniportWaveCyclic();

    IMP_IMiniportWaveCyclic;

    /*************************************************************************
     * IPinCount methods
     */
    IMP_IPinCount;

    // Friends
    friend class                CMiniportWaveCyclicStream;
    friend class                CMiniportTopologySimple;
};
typedef CMiniportWaveCyclic *PCMiniportWaveCyclic;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStream 
//   

class CMiniportWaveCyclicStream : 
    public CMiniportWaveCyclicStreamMSVAD,
    public CUnknown
{
protected:  
    PCMiniportWaveCyclic        m_pMiniportLocal;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStream);
    ~CMiniportWaveCyclicStream();

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclic Miniport,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class                CMiniportWaveCyclic;
};
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ds2dhw\wavtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    wavtable.h

Abstract:

    Declaration of wave miniport tables.

--*/

#ifndef _MSVAD_WAVTABLE_H_
#define _MSVAD_WAVTABLE_H_

//=============================================================================
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_PCM,           
        MIN_BITS_PER_SAMPLE_PCM,    
        MAX_BITS_PER_SAMPLE_PCM,    
        MIN_SAMPLE_RATE,            
        MAX_SAMPLE_RATE             
    },
};

static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }
};

static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    // Wave In Streaming Pin (Capture) KSPIN_WAVE_CAPTURE_SINK
    {
        MAX_OUTPUT_STREAMS,
        MAX_OUTPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_RECORDING_CONTROL,  
            0
        }
    },
    
    // Wave In Bridge Pin (Capture - From Topology) KSPIN_WAVE_CAPTURE_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
  
    // Wave Out Streaming Pin (Renderer) KSPIN_WAVE_RENDER_SINK
    {
        MAX_INPUT_STREAMS,
        MAX_INPUT_STREAMS, 
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_VOLUME_CONTROL,
            0
        }
    },
  
    // Wave Out Bridge Pin (Renderer) KSPIN_WAVE_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Wave
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Wave
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
// TODO This needs more properties.

static
PCPROPERTY_ITEM PropertiesSuperMix[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Wave
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSuperMix, PropertiesSuperMix);

//=============================================================================
// TODO This needs more properties.

static
PCPROPERTY_ITEM PropertiesSrc[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_SAMPLING_RATE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Wave
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Wave
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSrc, PropertiesSrc);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesSum[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Wave
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSum, PropertiesSum);


//=============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // KSNODE_WAVE_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_DAC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_VOLUME1
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_SUPERMIX
    {
        0,                      // Flags
        &AutomationSuperMix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_VOLUME2
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_SRC
    {
        0,                      // Flags
        &AutomationSrc,         // AutomationTable
        &KSNODETYPE_SRC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_SUM
    {
        0,                      // Flags
        &AutomationSum,         // AutomationTable
        &KSNODETYPE_SUM,        // Type
        NULL                    // Name
    },
};


//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,        KSPIN_WAVE_CAPTURE_SOURCE,  KSNODE_WAVE_ADC,     1 },    
    { KSNODE_WAVE_ADC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_CAPTURE_SINK },    

    { PCFILTER_NODE,        KSPIN_WAVE_RENDER_SINK,     KSNODE_WAVE_VOLUME1, 1 },
    { KSNODE_WAVE_VOLUME1,  0,                          KSNODE_WAVE_SUPERMIX,1 },
    { KSNODE_WAVE_SUPERMIX, 0,                          KSNODE_WAVE_VOLUME2, 1 },
    { KSNODE_WAVE_VOLUME2,  0,                          KSNODE_WAVE_SRC,     1 },
    { KSNODE_WAVE_SRC,      0,                          KSNODE_WAVE_SUM,     1 },
    { KSNODE_WAVE_SUM,      0,                          KSNODE_WAVE_DAC,     1 },    
    { KSNODE_WAVE_DAC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_RENDER_SOURCE },    
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories - NULL->use defaults (AUDIO RENDER CAPTURE)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\multstr\mintopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    mintopo.cpp

Abstract:

    Implementation of topology miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "multi.h"
#include "minwave.h"
#include "mintopo.h"
#include "toptable.h"


/*********************************************************************
* Topology/Wave bridge connection                                    *
*                                                                    *
*              +------+    +------+                                  *
*              | Wave |    | Topo |                                  *
*              |      |    |      |                                  *
*  Capture <---|0    1|<===|4    1|<--- Synth                        *
*              |      |    |      |                                  *
*   Render --->|2    3|===>|0     |                                  *
*              +------+    |      |                                  *
*                          |     2|<--- Mic                          *
*                          |      |                                  *
*                          |     3|---> Line Out                     *
*                          +------+                                  *
*********************************************************************/
PHYSICALCONNECTIONTABLE TopologyPhysicalConnections =
{
    KSPIN_TOPO_WAVEOUT_SOURCE,  // TopologyIn
    KSPIN_TOPO_WAVEIN_DEST,     // TopologyOut
    KSPIN_WAVE_CAPTURE_SOURCE,  // WaveIn
    KSPIN_WAVE_RENDER_SOURCE    // WaveOut
};

#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

    Creates a new topology miniport.

Arguments:

  Unknown - 

  RefclsId -

  UnknownOuter -

  PoolType - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopology, Unknown, UnknownOuter, PoolType);
} // CreateMiniportTopologyMSVAD

//=============================================================================
CMiniportTopology::~CMiniportTopology
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopology::~CMiniportTopology]"));
} // ~CMiniportTopology

//=============================================================================
NTSTATUS
CMiniportTopology::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request. 

  MyDataRange - Pin's data range to be compared with client's data range. 

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter. 

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned. 

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::DataRangeIntersection
        (
            PinId,
            ClientDataRange,
            MyDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP
CMiniportTopology::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportTopology::Init
( 
    IN PUNKNOWN                 UnknownAdapter,
    IN PRESOURCELIST            ResourceList,
    IN PPORTTOPOLOGY            Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopology::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        CMiniportTopologyMSVAD::Init
        (
            UnknownAdapter,
            Port_
        );

    if (NT_SUCCESS(ntStatus))
    {
        m_FilterDescriptor = &MiniportFilterDescriptor;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP
CMiniportTopology::NonDelegatingQueryInterface
( 
    IN  REFIID                  Interface,
    OUT PVOID                   * Object 
)
/*++

Routine Description:

  QueryInterface for MiniportTopology

Arguments:

  Interface - GUID of the interface

  Object - interface object to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.
        PUNKNOWN(*Object)->AddRef();
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
PropertyHandler_Topology
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Topology]"));

    return ((PCMiniportTopology)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Topology

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\multstr\toptable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    toptable.h

Abstract:

    Declaration of topology tables.

--*/

#ifndef _MSVAD_TOPTABLE_H_
#define _MSVAD_TOPTABLE_H_

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
 {
   sizeof(KSDATARANGE),
   0,
   0,
   0,
   STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
   STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
   STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
 }
};

//=============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
  &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
  // KSPIN_TOPO_WAVEOUT_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHOUT_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHIN_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_MIC_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_MICROPHONE,                       // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_LINEOUT_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SPEAKER,                          // Category
      &KSAUDFNAME_VOLUME_CONTROL,                   // Name (this name shows up as
                                                    // the playback panel name in SoundVol)
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_WAVEIN_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  }
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
    },
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMute[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute, PropertiesMute);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMux[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMux, PropertiesMux);

//=============================================================================
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
  // KSNODE_TOPO_WAVEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_WAVE_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_WAVE_MUTE   // Name
  },

  // KSNODE_TOPO_SYNTHOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_SYNTHOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_MIDI_MUTE   // Name
  },

  // KSNODE_TOPO_MIC_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIC_VOLUME  // Name
  },

  // KSNODE_TOPO_SYNTHIN_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_LINEOUT_MIX
  {
    0,                      // Flags
    NULL,                   // AutomationTable
    &KSNODETYPE_SUM,        // Type
    NULL                    // Name
  },

  // KSNODE_TOPO_LINEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MASTER_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEIN_MUX
  {
    0,                      // Flags
    &AutomationMux,         // AutomationTable
    &KSNODETYPE_MUX,        // Type
    &KSAUDFNAME_RECORDING_SOURCE // Name
  },
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
  //  FromNode,                     FromPin,                        ToNode,                      ToPin
  {   PCFILTER_NODE,                KSPIN_TOPO_WAVEOUT_SOURCE,      KSNODE_TOPO_WAVEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_WAVEOUT_VOLUME,   0,                              KSNODE_TOPO_WAVEOUT_MUTE,    1 },
  {   KSNODE_TOPO_WAVEOUT_MUTE,     0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHOUT_SOURCE,     KSNODE_TOPO_SYNTHOUT_VOLUME, 1 },
  {   KSNODE_TOPO_SYNTHOUT_VOLUME,  0,                              KSNODE_TOPO_SYNTHOUT_MUTE,   1 },
  {   KSNODE_TOPO_SYNTHOUT_MUTE,    0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHIN_SOURCE,      KSNODE_TOPO_SYNTHIN_VOLUME,  1 },
  {   KSNODE_TOPO_SYNTHIN_VOLUME,   0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   PCFILTER_NODE,                KSPIN_TOPO_MIC_SOURCE,          KSNODE_TOPO_MIC_VOLUME,      1 },
  {   KSNODE_TOPO_MIC_VOLUME,       0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   KSNODE_TOPO_LINEOUT_MIX,      0,                              KSNODE_TOPO_LINEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_LINEOUT_VOLUME,   0,                              PCFILTER_NODE,               KSPIN_TOPO_LINEOUT_DEST },

  {   KSNODE_TOPO_WAVEIN_MUX,       0,                              PCFILTER_NODE,               KSPIN_TOPO_WAVEIN_DEST }
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
  0,                                  // Version
  NULL,                               // AutomationTable
  sizeof(PCPIN_DESCRIPTOR),           // PinSize
  SIZEOF_ARRAY(MiniportPins),         // PinCount
  MiniportPins,                       // Pins
  sizeof(PCNODE_DESCRIPTOR),          // NodeSize
  SIZEOF_ARRAY(TopologyNodes),        // NodeCount
  TopologyNodes,                      // Nodes
  SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
  MiniportConnections,                // Connections
  0,                                  // CategoryCount
  NULL                                // Categories
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\pcmex\wavtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    wavtable.h

Abstract:

    Declaration of wave miniport tables.

--*/

#ifndef _MSVAD_WAVTABLE_H_
#define _MSVAD_WAVTABLE_H_

//=============================================================================
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_PCM,           
        MIN_BITS_PER_SAMPLE_PCM,    
        MAX_BITS_PER_SAMPLE_PCM,    
        MIN_SAMPLE_RATE,            
        MAX_SAMPLE_RATE             
    },
};

static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }
};

static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    // Wave In Streaming Pin (Capture) KSPIN_WAVE_CAPTURE_SINK
    {
        MAX_OUTPUT_STREAMS,
        MAX_OUTPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_RECORDING_CONTROL,  
            0
        }
    },
    
    // Wave In Bridge Pin (Capture - From Topology) KSPIN_WAVE_CAPTURE_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
  
    // Wave Out Streaming Pin (Renderer) KSPIN_WAVE_RENDER_SINK
    {
        MAX_INPUT_STREAMS,
        MAX_INPUT_STREAMS, 
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_VOLUME_CONTROL,
            0
        }
    },
  
    // Wave Out Bridge Pin (Renderer) KSPIN_WAVE_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
};

//=============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // KSNODE_WAVE_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_DAC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};


//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,        KSPIN_WAVE_CAPTURE_SOURCE,  KSNODE_WAVE_ADC,     1 },    
    { KSNODE_WAVE_ADC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_CAPTURE_SINK },    

    { PCFILTER_NODE,        KSPIN_WAVE_RENDER_SINK,     KSNODE_WAVE_DAC,     1 },    
    { KSNODE_WAVE_DAC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_RENDER_SOURCE },    
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories - NULL->use defaults (AUDIO RENDER CAPTURE)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\simple\mintopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minitopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_MINTOPO_H_
#define _MSVAD_MINTOPO_H_

#include "basetopo.h"

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopology 
//   

class CMiniportTopology : 
    public CMiniportTopologyMSVAD,
    public IMiniportTopology,
    public CUnknown
{
  public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopology);
    ~CMiniportTopology();

    IMP_IMiniportTopology;
};
typedef CMiniportTopology *PCMiniportTopology;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\multstr\minwave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "multi.h"
#include "minwave.h"
#include "wavtable.h"

#pragma code_seg("PAGE")

//=============================================================================
// CMiniportWaveCyclic
//=============================================================================

//=============================================================================
NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Create the wavecyclic miniport.

Arguments:

  Unknown - 

  RefClsId -

  UnknownOuter -

  PoolType -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY_(CMiniportWaveCyclic, Unknown, UnknownOuter, PoolType,PMINIPORTWAVECYCLIC);
}

//=============================================================================
CMiniportWaveCyclic::~CMiniportWaveCyclic
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::~CMiniportWaveCyclic]"));
} // ~CMiniportWaveCyclic


//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::DataRangeIntersection
( 
    IN  ULONG                       PinId,
    IN  PKSDATARANGE                ClientDataRange,
    IN  PKSDATARANGE                MyDataRange,
    IN  ULONG                       OutputBufferLength,
    OUT PVOID                       ResultantFormat,
    OUT PULONG                      ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId -           Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data 
                    range submitted by client in the data range intersection 
                    property request. 

  MyDataRange -         Pin's data range to be compared with client's data 
                        range. In this case we actually ignore our own data 
                        range, because we know that we only support one range.

  OutputBufferLength -  Size of the buffer pointed to by the resultant format 
                        parameter. 

  ResultantFormat -     Pointer to value where the resultant format should be 
                        returned. 

  ResultantFormatLength -   Actual length of the resultant format placed in 
                            ResultantFormat. This should be less than or equal 
                            to OutputBufferLength. 

  Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    // This driver only supports PCM formats.
    // Portcls will handle the request for us.
    //

    return STATUS_NOT_IMPLEMENTED;
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    return 
        CMiniportWaveCyclicMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    NTSTATUS                    ntStatus;

    DPF_ENTER(("[CMiniportWaveCyclic::Init]"));

    m_MaxOutputStreams      = MAX_OUTPUT_STREAMS;
    m_MaxInputStreams       = MAX_INPUT_STREAMS;
    m_MaxTotalStreams       = MAX_TOTAL_STREAMS;

    m_MinChannels           = MIN_CHANNELS;
    m_MaxChannelsPcm        = MAX_CHANNELS_PCM;

    m_MinBitsPerSamplePcm   = MIN_BITS_PER_SAMPLE_PCM;
    m_MaxBitsPerSamplePcm   = MAX_BITS_PER_SAMPLE_PCM;
    m_MinSampleRatePcm      = MIN_SAMPLE_RATE;
    m_MaxSampleRatePcm      = MAX_SAMPLE_RATE;

    ntStatus =
        CMiniportWaveCyclicMSVAD::Init
        (
            UnknownAdapter_,
            ResourceList_,
            Port_
        );
    if (NT_SUCCESS(ntStatus))
    {
        // Set filter descriptor.
        m_FilterDescriptor = &MiniportFilterDescriptor;

        m_fCaptureAllocated = FALSE;
        RtlZeroMemory
        (
            m_pStream, 
            MAX_INPUT_STREAMS * sizeof(PCMiniportWaveCyclicStream)
        );
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NewStream
( 
    OUT PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  ULONG                   Pin,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL *           OutDmaChannel,
    OUT PSERVICEGROUP *         OutServiceGroup 
)
/*++

Routine Description:

  The NewStream function creates a new instance of a logical stream 
  associated with a specified physical channel. Callers of NewStream should 
  run at IRQL PASSIVE_LEVEL.

Arguments:

  OutStream -

  OuterUnknown -

  PoolType - 

  Pin - 

  Capture - 

  DataFormat -

  OutDmaChannel -

  OutServiceGroup -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    DPF_ENTER(("[CMiniportWaveCyclic::NewStream]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PCMiniportWaveCyclicStream  stream = NULL;
    ULONG                       streamIndex;

    // MSVAD supports one capture stream.
    //
    if (Capture)
    {
        if (m_fCaptureAllocated)
        {
            DPF(D_TERSE, ("[Only one capture stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    // This version supports multiple playback streams.
    //
    else
    {
        for (streamIndex = 0; streamIndex < m_MaxInputStreams; streamIndex++)
        {
            if (!m_pStream[streamIndex])
            {
                break;
            }
        }
        if (streamIndex == m_MaxInputStreams)
        {
            DPF(D_TERSE, ("[All render streams are in use]"));            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    // Instantiate a stream. Stream must be in
    // NonPagedPool because of file saving.
    //
    if (NT_SUCCESS(ntStatus))
    {
        stream = new (NonPagedPool, MSVAD_POOLTAG) 
            CMiniportWaveCyclicStream(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus = 
                stream->Init
                ( 
                    this,
                    Pin,
                    Capture,
                    DataFormat
                );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (Capture)
        {
            m_fCaptureAllocated = TRUE;
        }
        else
        {
            m_pStream[streamIndex] = stream;
        }

        *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
        (*OutStream)->AddRef();
        
        *OutDmaChannel = PDMACHANNEL(stream);
        (*OutDmaChannel)->AddRef();

        *OutServiceGroup = m_ServiceGroup;
        (*OutServiceGroup)->AddRef();

        // The stream, the DMA channel, and the service group have
        // references now for the caller.  The caller expects these
        // references to be there.
    }

    // This is our private reference to the stream.  The caller has
    // its own, so we can release in any case.
    //
    if (stream)
    {
        stream->Release();
    }
    
    return ntStatus;
} // NewStream

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IPinCount))
    {
        *Object = PVOID(PPINCOUNT(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.

        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
STDMETHODIMP_(void)
CMiniportWaveCyclic::PinCount
(
    IN      ULONG   PinId,
    IN  OUT PULONG  FilterNecessary,
    IN  OUT PULONG  FilterCurrent,
    IN  OUT PULONG  FilterPossible,
    IN  OUT PULONG  GlobalCurrent,
    IN  OUT PULONG  GlobalPossible
)
/*++

Routine Description:

  Provide a way for the miniport to modify the pin counts for this miniport. 

Arguments:

  PinId - KS pin number being referenced

  FilterNecessary - number of pins required on this pin factory
  FilterCurrent   - number of pins opened on this pin factory
  FilterPossible  - number of pins possible on this pin factory
  GlobalCurrent   - total number of pins opened, across all pin instances on this filter
  GlobalPossible  - total number of pins possible, across all pin factories on this filter

Return Value:

  OUT parameters for the five pin counts.

--*/
{
    PAGED_CODE();
    
    _DbgPrintF( DEBUGLVL_VERBOSE, 
                ("PinCount PID:0x%08x FN(0x%08x):%d FC(0x%08x):%d FP(0x%08x):%d GC(0x%08x):%d GP(0x%08x):%d",
                  PinId,
                  FilterNecessary,*FilterNecessary,
                  FilterCurrent,  *FilterCurrent,
                  FilterPossible, *FilterPossible, 
                  GlobalCurrent,  *GlobalCurrent,
                  GlobalPossible, *GlobalPossible ) );

    //
    // Something like the following:
    //
//    if (0 == PinId)
//    {
//        *FilterPossible += 1;
//    }

} // PinCount

//=============================================================================
// CMiniportWaveStreamCyclicSimple
//=============================================================================

//=============================================================================
CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclicstream 

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream]"));

    if (NULL != m_pMiniportLocal)
    {
        // Tell the Miniport that the slot is freed now.
        //
        if (m_fCapture)
        {
            m_pMiniportLocal->m_fCaptureAllocated = FALSE;
        }
        else
        {
            for (ULONG i = 0; i < m_pMiniportLocal->m_MaxInputStreams; i++)
            {
                if (this == m_pMiniportLocal->m_pStream[i])
                {
                    m_pMiniportLocal->m_pStream[i] = NULL;
                    break;
                }
            }
        }
    }
} // ~CMiniportWaveCyclicStream

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStream::Init
( 
    IN PCMiniportWaveCyclic         Miniport_,
    IN ULONG                        Pin_,
    IN BOOLEAN                      Capture_,
    IN PKSDATAFORMAT                DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ -

  Pin_ -

  Capture_ -

  DataFormat -

  DmaChannel_ -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    m_pMiniportLocal = Miniport_;

    return 
        CMiniportWaveCyclicStreamMSVAD::Init
        (
            Miniport_,
            Pin_,
            Capture_,
            DataFormat_
        );
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStream::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNEL(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\pcmex\minwave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "pcmex.h"
#include "minwave.h"
#include "wavtable.h"

#pragma code_seg("PAGE")

//=============================================================================
// CMiniportWaveCyclic
//=============================================================================

//=============================================================================
NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Create the wavecyclic miniport.

Arguments:

  Unknown - 

  RefClsId -

  UnknownOuter -

  PoolType -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportWaveCyclic, Unknown, UnknownOuter, PoolType);
}

//=============================================================================
CMiniportWaveCyclic::~CMiniportWaveCyclic
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::~CMiniportWaveCyclic]"));
} // ~CMiniportWaveCyclic


//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::DataRangeIntersection
( 
    IN  ULONG                       PinId,
    IN  PKSDATARANGE                ClientDataRange,
    IN  PKSDATARANGE                MyDataRange,
    IN  ULONG                       OutputBufferLength,
    OUT PVOID                       ResultantFormat,
    OUT PULONG                      ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId -           Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data 
                    range submitted by client in the data range intersection 
                    property request. 

  MyDataRange -         Pin's data range to be compared with client's data 
                        range. In this case we actually ignore our own data 
                        range, because we know that we only support one range.

  OutputBufferLength -  Size of the buffer pointed to by the resultant format 
                        parameter. 

  ResultantFormat -     Pointer to value where the resultant format should be 
                        returned. 

  ResultantFormatLength -   Actual length of the resultant format placed in 
                            ResultantFormat. This should be less than or equal 
                            to OutputBufferLength. 

  Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    // This code is the same as AC97 sample intersection handler.
    //

    // Check the size of output buffer. Note that we are returning
    // WAVEFORMATPCMEX.
    //
    if (!OutputBufferLength) 
    {
        *ResultantFormatLength = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
        return STATUS_BUFFER_OVERFLOW;
    } 
    
    if (OutputBufferLength < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX))) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Fill in the structure the datarange structure.
    //
    RtlCopyMemory(ResultantFormat, MyDataRange, sizeof(KSDATAFORMAT));

    // Modify the size of the data format structure to fit the WAVEFORMATPCMEX
    // structure.
    //
    ((PKSDATAFORMAT)ResultantFormat)->FormatSize =
        sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);

    // Append the WAVEFORMATPCMEX structure
    //
    PWAVEFORMATPCMEX pWfxExt = 
        (PWAVEFORMATPCMEX)((PKSDATAFORMAT)ResultantFormat + 1);

    pWfxExt->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
    pWfxExt->Format.nChannels = 
        (WORD)((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumChannels;
    pWfxExt->Format.nSamplesPerSec = 
        ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumSampleFrequency;
    pWfxExt->Format.wBitsPerSample = (WORD)
        ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumBitsPerSample;
    pWfxExt->Format.nBlockAlign = 
        (pWfxExt->Format.wBitsPerSample * pWfxExt->Format.nChannels) / 8;
    pWfxExt->Format.nAvgBytesPerSec = 
        pWfxExt->Format.nSamplesPerSec * pWfxExt->Format.nBlockAlign;
    pWfxExt->Format.cbSize = 22;
    pWfxExt->Samples.wValidBitsPerSample = pWfxExt->Format.wBitsPerSample;
    pWfxExt->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;

    // This should be set to wave port's channel config
    // MSVAD ds3dhw implements this properly.
    //
    pWfxExt->dwChannelMask = KSAUDIO_SPEAKER_STEREO;

    // Now overwrite also the sample size in the ksdataformat structure.
    ((PKSDATAFORMAT)ResultantFormat)->SampleSize = pWfxExt->Format.nBlockAlign;
    
    // That we will return.
    //
    *ResultantFormatLength = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    
    return STATUS_SUCCESS;
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    return 
        CMiniportWaveCyclicMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    NTSTATUS                    ntStatus;

    DPF_ENTER(("[CMiniportWaveCyclic::Init]"));

    m_MaxOutputStreams      = MAX_OUTPUT_STREAMS;
    m_MaxInputStreams       = MAX_INPUT_STREAMS;
    m_MaxTotalStreams       = MAX_TOTAL_STREAMS;

    m_MinChannels           = MIN_CHANNELS;
    m_MaxChannelsPcm        = MAX_CHANNELS_PCM;

    m_MinBitsPerSamplePcm   = MIN_BITS_PER_SAMPLE_PCM;
    m_MaxBitsPerSamplePcm   = MAX_BITS_PER_SAMPLE_PCM;
    m_MinSampleRatePcm      = MIN_SAMPLE_RATE;
    m_MaxSampleRatePcm      = MAX_SAMPLE_RATE;
    
    ntStatus =
        CMiniportWaveCyclicMSVAD::Init
        (
            UnknownAdapter_,
            ResourceList_,
            Port_
        );
    if (NT_SUCCESS(ntStatus))
    {
        // Set filter descriptor.
        m_FilterDescriptor = &MiniportFilterDescriptor;

        m_fCaptureAllocated = FALSE;
        m_fRenderAllocated = FALSE;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NewStream
( 
    OUT PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  ULONG                   Pin,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL *           OutDmaChannel,
    OUT PSERVICEGROUP *         OutServiceGroup 
)
/*++

Routine Description:

  The NewStream function creates a new instance of a logical stream 
  associated with a specified physical channel. Callers of NewStream should 
  run at IRQL PASSIVE_LEVEL.

Arguments:

  OutStream -

  OuterUnknown -

  PoolType - 

  Pin - 

  Capture - 

  DataFormat -

  OutDmaChannel -

  OutServiceGroup -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    DPF_ENTER(("[CMiniportWaveCyclic::NewStream]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PCMiniportWaveCyclicStream  stream = NULL;

    // Check if we have enough streams.
    if (Capture)
    {
        if (m_fCaptureAllocated)
        {
            DPF(D_TERSE, ("[Only one capture stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        if (m_fRenderAllocated)
        {
            DPF(D_TERSE, ("[Only one render stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    // Instantiate a stream. Stream must be in
    // NonPagedPool because of file saving.
    //
    if (NT_SUCCESS(ntStatus))
    {
        stream = new (NonPagedPool, MSVAD_POOLTAG) 
            CMiniportWaveCyclicStream(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus = 
                stream->Init
                ( 
                    this,
                    Pin,
                    Capture,
                    DataFormat
                );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (Capture)
        {
            m_fCaptureAllocated = TRUE;
        }
        else
        {
            m_fRenderAllocated = TRUE;
        }

        *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
        (*OutStream)->AddRef();
        
        *OutDmaChannel = PDMACHANNEL(stream);
        (*OutDmaChannel)->AddRef();

        *OutServiceGroup = m_ServiceGroup;
        (*OutServiceGroup)->AddRef();

        // The stream, the DMA channel, and the service group have
        // references now for the caller.  The caller expects these
        // references to be there.
    }

    // This is our private reference to the stream.  The caller has
    // its own, so we can release in any case.
    //
    if (stream)
    {
        stream->Release();
    }
    
    return ntStatus;
} // NewStream

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.

        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
CMiniportWaveCyclic::ValidateFormat
( 
    IN	PKSDATAFORMAT           pDataFormat 
)
/*++

Routine Description:

  Validates that the given dataformat is valid. This is for supporting 
  WAVEFORMATEXTENSIBLE.

Arguments:

  pDataFormat - The dataformat for validation.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(pDataFormat);

    DPF_ENTER(("[CMiniportWaveCyclicMSVAD::ValidateFormat]"));

    NTSTATUS                    ntStatus;
    PWAVEFORMATEX               pwfx;

    // Let the default Validator handle the request.
    //
    ntStatus = CMiniportWaveCyclicMSVAD::ValidateFormat(pDataFormat);
    if (NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    // If the format is not known check for WAVEFORMATEXTENSIBLE.
    //
    pwfx = GetWaveFormatEx(pDataFormat);
    if (pwfx)
    {
        if (IS_VALID_WAVEFORMATEX_GUID(&pDataFormat->SubFormat))
        {
            USHORT wfxID = EXTRACT_WAVEFORMATEX_ID(&pDataFormat->SubFormat);

            switch (wfxID)
            {
                // This is for WAVE_FORMAT_EXTENSIBLE support.
                //
                case WAVE_FORMAT_EXTENSIBLE:
                {
                    PWAVEFORMATEXTENSIBLE   pwfxExt = 
                        (PWAVEFORMATEXTENSIBLE) pwfx;

                    ntStatus = ValidateWfxExt(pwfxExt);
                    break;
                }
                

                default:
                    DPF(D_TERSE, ("Invalid format EXTRACT_WAVEFORMATEX_ID!"));
                    break;
            }
        }
        else
        {
            DPF(D_TERSE, ("Invalid pDataFormat->SubFormat!") );
        }
    }

    return ntStatus;
} // ValidateFormat

//=============================================================================
NTSTATUS
CMiniportWaveCyclic::ValidateWfxExt
(
    IN  PWAVEFORMATEXTENSIBLE   pWfxExt
)
/*++

Routine Description:

  Given a waveformatextensible, verifies that the format is in device
  datarange.

Arguments:

  pWfxExt - wave format extensible structure

Return Value:
    
    NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::ValidateWfxExtPcm]"));

    // First verify that the subformat is OK
    //
    if (pWfxExt)
    {
        if(IsEqualGUIDAligned(pWfxExt->SubFormat, KSDATAFORMAT_SUBTYPE_PCM))
        {
            PWAVEFORMATEX           pWfx = (PWAVEFORMATEX) pWfxExt;

            if 
            (
                pWfx->cbSize == 
                sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)
            )
            {
                // Do any channel specific stuff here.
                //
                
                return CMiniportWaveCyclicMSVAD::ValidatePcm(pWfx);
            }
        }
    }

    DPF(D_TERSE, ("Invalid PCM format"));

    return STATUS_INVALID_PARAMETER;
} // ValidateWfxExtPcm

//=============================================================================
// CMiniportWaveStreamCyclicSimple
//=============================================================================

//=============================================================================
CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclicstream 

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream]"));

    if (NULL != m_pMiniportLocal)
    {
        if (m_fCapture)
        {
            m_pMiniportLocal->m_fCaptureAllocated = FALSE;
        }
        else
        {
            m_pMiniportLocal->m_fRenderAllocated = FALSE;
        }
    }
} // ~CMiniportWaveCyclicStream

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStream::Init
( 
    IN PCMiniportWaveCyclic         Miniport_,
    IN ULONG                        Pin_,
    IN BOOLEAN                      Capture_,
    IN PKSDATAFORMAT                DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ -

  Pin_ -

  Capture_ -

  DataFormat -

  DmaChannel_ -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    m_pMiniportLocal = Miniport_;

    return 
        CMiniportWaveCyclicStreamMSVAD::Init
        (
            Miniport_,
            Pin_,
            Capture_,
            DataFormat_
        );
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStream::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNEL(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\pcmex\minwave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.h

Abstract:

    Definition of wavecyclic miniport class.

--*/

#ifndef _MSVAD_MINWAVE_H_
#define _MSVAD_MINWAVE_H_

#include "basewave.h"

//=============================================================================
// Referenced Forward
//=============================================================================
class CMiniportWaveCyclicStream;
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclic 
//   

class CMiniportWaveCyclic : 
    public CMiniportWaveCyclicMSVAD,
    public IMiniportWaveCyclic,
    public CUnknown
{
private:
    BOOL                        m_fCaptureAllocated;
    BOOL                        m_fRenderAllocated;

protected:
    NTSTATUS                    ValidateFormat
    ( 
        IN	PKSDATAFORMAT       pDataFormat 
    );

    NTSTATUS                    ValidateWfxExt
    (
        IN  PWAVEFORMATEXTENSIBLE   pWfxExt
    );


public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclic);
    ~CMiniportWaveCyclic();

    IMP_IMiniportWaveCyclic;

    // Friends
    friend class                CMiniportWaveCyclicStream;
    friend class                CMiniportTopologySimple;
};
typedef CMiniportWaveCyclic *PCMiniportWaveCyclic;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStream 
//   

class CMiniportWaveCyclicStream : 
    public CMiniportWaveCyclicStreamMSVAD,
    public CUnknown
{
protected:
    PCMiniportWaveCyclic        m_pMiniportLocal;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStream);
    ~CMiniportWaveCyclicStream();

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclic Miniport,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class                CMiniportWaveCyclic;
};
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\pcmex\pcmex.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    pcmex.h

Abstract:

    Node and Pin numbers for WAVEFORMATEXTENSIBLE format

--*/

#ifndef _MSVAD_PCMEX_H_
#define _MSVAD_PCMEX_H_

// Pin properties.
#define MAX_OUTPUT_STREAMS          1       // Number of capture streams.
#define MAX_INPUT_STREAMS           1       // Number of render streams.
#define MAX_TOTAL_STREAMS           MAX_OUTPUT_STREAMS + MAX_INPUT_STREAMS                      

// PCM Info
#define MIN_CHANNELS                1       // Min Channels.
#define MAX_CHANNELS_PCM            2       // Max Channels.
#define MIN_BITS_PER_SAMPLE_PCM     8       // Min Bits Per Sample
#define MAX_BITS_PER_SAMPLE_PCM     16      // Max Bits Per Sample
#define MIN_SAMPLE_RATE             4000    // Min Sample Rate
#define MAX_SAMPLE_RATE             64000   // Max Sample Rate

// Wave pins
enum 
{
    KSPIN_WAVE_CAPTURE_SINK = 0,
    KSPIN_WAVE_CAPTURE_SOURCE,
    KSPIN_WAVE_RENDER_SINK, 
    KSPIN_WAVE_RENDER_SOURCE
};

// Wave Topology nodes.
enum 
{
    KSNODE_WAVE_ADC = 0,
    KSNODE_WAVE_DAC
};

// topology pins.
enum
{
    KSPIN_TOPO_WAVEOUT_SOURCE = 0,
    KSPIN_TOPO_SYNTHOUT_SOURCE,
    KSPIN_TOPO_SYNTHIN_SOURCE,
    KSPIN_TOPO_MIC_SOURCE,
    KSPIN_TOPO_LINEOUT_DEST,
    KSPIN_TOPO_WAVEIN_DEST
};

// topology nodes.
enum
{
    KSNODE_TOPO_WAVEOUT_VOLUME = 0,
    KSNODE_TOPO_WAVEOUT_MUTE,
    KSNODE_TOPO_SYNTHOUT_VOLUME,
    KSNODE_TOPO_SYNTHOUT_MUTE,
    KSNODE_TOPO_MIC_VOLUME,
    KSNODE_TOPO_SYNTHIN_VOLUME,
    KSNODE_TOPO_LINEOUT_MIX,
    KSNODE_TOPO_LINEOUT_VOLUME,
    KSNODE_TOPO_WAVEIN_MUX
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\pcmex\mintopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    mintopo.cpp

Abstract:

    Implementation of topology miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "pcmex.h"
#include "minwave.h"
#include "mintopo.h"
#include "toptable.h"


/*********************************************************************
* Topology/Wave bridge connection                                    *
*                                                                    *
*              +------+    +------+                                  *
*              | Wave |    | Topo |                                  *
*              |      |    |      |                                  *
*  Capture <---|0    1|<===|4    1|<--- Synth                        *
*              |      |    |      |                                  *
*   Render --->|2    3|===>|0     |                                  *
*              +------+    |      |                                  *
*                          |     2|<--- Mic                          *
*                          |      |                                  *
*                          |     3|---> Line Out                     *
*                          +------+                                  *
*********************************************************************/
PHYSICALCONNECTIONTABLE TopologyPhysicalConnections =
{
    KSPIN_TOPO_WAVEOUT_SOURCE,  // TopologyIn
    KSPIN_TOPO_WAVEIN_DEST,     // TopologyOut
    KSPIN_WAVE_CAPTURE_SOURCE,  // WaveIn
    KSPIN_WAVE_RENDER_SOURCE    // WaveOut
};

#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

    Creates a new topology miniport.

Arguments:

  Unknown - 

  RefclsId -

  UnknownOuter -

  PoolType - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopology, Unknown, UnknownOuter, PoolType);
} // CreateMiniportTopologyMSVAD

//=============================================================================
CMiniportTopology::~CMiniportTopology
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopology::~CMiniportTopology]"));
} // ~CMiniportTopology

//=============================================================================
NTSTATUS
CMiniportTopology::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request. 

  MyDataRange - Pin's data range to be compared with client's data range. 

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter. 

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned. 

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::DataRangeIntersection
        (
            PinId,
            ClientDataRange,
            MyDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP
CMiniportTopology::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportTopology::Init
( 
    IN PUNKNOWN                 UnknownAdapter,
    IN PRESOURCELIST            ResourceList,
    IN PPORTTOPOLOGY            Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopology::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        CMiniportTopologyMSVAD::Init
        (
            UnknownAdapter,
            Port_
        );

    if (NT_SUCCESS(ntStatus))
    {
        m_FilterDescriptor = &MiniportFilterDescriptor;
        m_AdapterCommon->MixerMuxWrite(KSPIN_TOPO_MIC_SOURCE);
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP
CMiniportTopology::NonDelegatingQueryInterface
( 
    IN  REFIID                  Interface,
    OUT PVOID                   * Object 
)
/*++

Routine Description:

  QueryInterface for MiniportTopology

Arguments:

  Interface - GUID of the interface

  Object - interface object to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.
        PUNKNOWN(*Object)->AddRef();
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
PropertyHandler_Topology
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Topology]"));

    return ((PCMiniportTopology)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Topology

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\pcmex\toptable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    toptable.h

Abstract:

    Declaration of topology tables.

--*/

#ifndef _MSVAD_TOPTABLE_H_
#define _MSVAD_TOPTABLE_H_

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
 {
   sizeof(KSDATARANGE),
   0,
   0,
   0,
   STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
   STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
   STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
 }
};

//=============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
  &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
  // KSPIN_TOPO_WAVEOUT_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHOUT_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHIN_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_MIC_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_MICROPHONE,                       // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_LINEOUT_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SPEAKER,                          // Category
      &KSAUDFNAME_VOLUME_CONTROL,                   // Name (this name shows up as
                                                    // the playback panel name in SoundVol)
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_WAVEIN_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  }
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
    },
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMute[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute, PropertiesMute);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMux[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMux, PropertiesMux);

//=============================================================================
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
  // KSNODE_TOPO_WAVEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_WAVE_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_WAVE_MUTE   // Name
  },

  // KSNODE_TOPO_SYNTHOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_SYNTHOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_MIDI_MUTE   // Name
  },

  // KSNODE_TOPO_MIC_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIC_VOLUME  // Name
  },

  // KSNODE_TOPO_SYNTHIN_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_LINEOUT_MIX
  {
    0,                      // Flags
    NULL,                   // AutomationTable
    &KSNODETYPE_SUM,        // Type
    NULL                    // Name
  },

  // KSNODE_TOPO_LINEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MASTER_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEIN_MUX
  {
    0,                      // Flags
    &AutomationMux,         // AutomationTable
    &KSNODETYPE_MUX,        // Type
    &KSAUDFNAME_RECORDING_SOURCE // Name
  },
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
  //  FromNode,                     FromPin,                        ToNode,                      ToPin
  {   PCFILTER_NODE,                KSPIN_TOPO_WAVEOUT_SOURCE,      KSNODE_TOPO_WAVEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_WAVEOUT_VOLUME,   0,                              KSNODE_TOPO_WAVEOUT_MUTE,    1 },
  {   KSNODE_TOPO_WAVEOUT_MUTE,     0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHOUT_SOURCE,     KSNODE_TOPO_SYNTHOUT_VOLUME, 1 },
  {   KSNODE_TOPO_SYNTHOUT_VOLUME,  0,                              KSNODE_TOPO_SYNTHOUT_MUTE,   1 },
  {   KSNODE_TOPO_SYNTHOUT_MUTE,    0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHIN_SOURCE,      KSNODE_TOPO_SYNTHIN_VOLUME,  1 },
  {   KSNODE_TOPO_SYNTHIN_VOLUME,   0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   PCFILTER_NODE,                KSPIN_TOPO_MIC_SOURCE,          KSNODE_TOPO_MIC_VOLUME,      1 },
  {   KSNODE_TOPO_MIC_VOLUME,       0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   KSNODE_TOPO_LINEOUT_MIX,      0,                              KSNODE_TOPO_LINEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_LINEOUT_VOLUME,   0,                              PCFILTER_NODE,               KSPIN_TOPO_LINEOUT_DEST },

  {   KSNODE_TOPO_WAVEIN_MUX,       0,                              PCFILTER_NODE,               KSPIN_TOPO_WAVEIN_DEST }
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
  0,                                  // Version
  NULL,                               // AutomationTable
  sizeof(PCPIN_DESCRIPTOR),           // PinSize
  SIZEOF_ARRAY(MiniportPins),         // PinCount
  MiniportPins,                       // Pins
  sizeof(PCNODE_DESCRIPTOR),          // NodeSize
  SIZEOF_ARRAY(TopologyNodes),        // NodeCount
  TopologyNodes,                      // Nodes
  SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
  MiniportConnections,                // Connections
  0,                                  // CategoryCount
  NULL                                // Categories
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\simple\mintopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    mintopo.cpp

Abstract:

    Implementation of topology miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "simple.h"
#include "minwave.h"
#include "mintopo.h"
#include "toptable.h"


/*********************************************************************
* Topology/Wave bridge connection                                    *
*                                                                    *
*              +------+    +------+                                  *
*              | Wave |    | Topo |                                  *
*              |      |    |      |                                  *
*  Capture <---|0    1|<===|4    1|<--- Synth                        *
*              |      |    |      |                                  *
*   Render --->|2    3|===>|0     |                                  *
*              +------+    |      |                                  *
*                          |     2|<--- Mic                          *
*                          |      |                                  *
*                          |     3|---> Line Out                     *
*                          +------+                                  *
*********************************************************************/
PHYSICALCONNECTIONTABLE TopologyPhysicalConnections =
{
    KSPIN_TOPO_WAVEOUT_SOURCE,  // TopologyIn
    KSPIN_TOPO_WAVEIN_DEST,     // TopologyOut
    KSPIN_WAVE_CAPTURE_SOURCE,  // WaveIn
    KSPIN_WAVE_RENDER_SOURCE    // WaveOut
};

#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

    Creates a new topology miniport.

Arguments:

  Unknown - 

  RefclsId -

  UnknownOuter -

  PoolType - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopology, Unknown, UnknownOuter, PoolType);
} // CreateMiniportTopologyMSVAD

//=============================================================================
CMiniportTopology::~CMiniportTopology
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopology::~CMiniportTopology]"));
} // ~CMiniportTopology

//=============================================================================
NTSTATUS
CMiniportTopology::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request. 

  MyDataRange - Pin's data range to be compared with client's data range. 

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter. 

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned. 

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::DataRangeIntersection
        (
            PinId,
            ClientDataRange,
            MyDataRange,
            OutputBufferLength,
            ResultantFormat,
            ResultantFormatLength
        );
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP
CMiniportTopology::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    return 
        CMiniportTopologyMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportTopology::Init
( 
    IN PUNKNOWN                 UnknownAdapter,
    IN PRESOURCELIST            ResourceList,
    IN PPORTTOPOLOGY            Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopology::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        CMiniportTopologyMSVAD::Init
        (
            UnknownAdapter,
            Port_
        );

    if (NT_SUCCESS(ntStatus))
    {
        m_FilterDescriptor = &MiniportFilterDescriptor;
        m_AdapterCommon->MixerMuxWrite(KSPIN_TOPO_MIC_SOURCE);
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP
CMiniportTopology::NonDelegatingQueryInterface
( 
    IN  REFIID                  Interface,
    OUT PVOID                   * Object 
)
/*++

Routine Description:

  QueryInterface for MiniportTopology

Arguments:

  Interface - GUID of the interface

  Object - interface object to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.
        PUNKNOWN(*Object)->AddRef();
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
PropertyHandler_Topology
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[PropertyHandler_Topology]"));

    // PropertryRequest structure is filled by portcls. 
    // MajorTarget is a pointer to miniport object for miniports.
    //
    return 
        ((PCMiniportTopology)
        (PropertyRequest->MajorTarget))->PropertyHandlerGeneric
        (
            PropertyRequest
        );
} // PropertyHandler_Topology

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\simple\minwave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.h

Abstract:

    Definition of wavecyclic miniport class.

--*/

#ifndef _MSVAD_MINWAVE_H_
#define _MSVAD_MINWAVE_H_

#include "basewave.h"

//=============================================================================
// Referenced Forward
//=============================================================================
class CMiniportWaveCyclicStream;
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclic 
//   

class CMiniportWaveCyclic : 
    public CMiniportWaveCyclicMSVAD,
    public IMiniportWaveCyclic,
    public CUnknown
{
private:
    BOOL                        m_fCaptureAllocated;
    BOOL                        m_fRenderAllocated;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclic);
    ~CMiniportWaveCyclic();

    IMP_IMiniportWaveCyclic;

    NTSTATUS                    PropertyHandlerComponentId
    (
        IN PPCPROPERTY_REQUEST  PropertyRequest
    );

    // Friends
    friend class                CMiniportWaveCyclicStream;
    friend class                CMiniportTopologySimple;
};
typedef CMiniportWaveCyclic *PCMiniportWaveCyclic;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStream 
//   

class CMiniportWaveCyclicStream : 
    public CMiniportWaveCyclicStreamMSVAD,
    public CUnknown
{
protected:
    PCMiniportWaveCyclic        m_pMiniportLocal;  

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStream);
    ~CMiniportWaveCyclicStream();

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclic Miniport,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class                CMiniportWaveCyclic;
};
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\simple\toptable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    toptable.h

Abstract:

    Declaration of topology tables.

--*/

#ifndef _MSVAD_TOPTABLE_H_
#define _MSVAD_TOPTABLE_H_

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
 {
   sizeof(KSDATARANGE),
   0,
   0,
   0,
   STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
   STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
   STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
 }
};

//=============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
  &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
  // KSPIN_TOPO_WAVEOUT_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHOUT_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHIN_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_MIC_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_MICROPHONE,                       // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_LINEOUT_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SPEAKER,                          // Category
      &KSAUDFNAME_VOLUME_CONTROL,                   // Name (this name shows up as
                                                    // the playback panel name in SoundVol)
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_WAVEIN_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  }
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
    },
    {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume, PropertiesVolume);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMute[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute, PropertiesMute);

//=============================================================================
static
PCPROPERTY_ITEM PropertiesMux[] =
{
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  },
  {
    &KSPROPSETID_Audio,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_Topology
  }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMux, PropertiesMux);

//=============================================================================
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
  // KSNODE_TOPO_WAVEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_WAVE_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_WAVE_MUTE   // Name
  },

  // KSNODE_TOPO_SYNTHOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_SYNTHOUT_MUTE
  {
    0,                      // Flags
    &AutomationMute,        // AutomationTable
    &KSNODETYPE_MUTE,       // Type
    &KSAUDFNAME_MIDI_MUTE   // Name
  },

  // KSNODE_TOPO_MIC_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIC_VOLUME  // Name
  },

  // KSNODE_TOPO_SYNTHIN_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MIDI_VOLUME // Name
  },

  // KSNODE_TOPO_LINEOUT_MIX
  {
    0,                      // Flags
    NULL,                   // AutomationTable
    &KSNODETYPE_SUM,        // Type
    NULL                    // Name
  },

  // KSNODE_TOPO_LINEOUT_VOLUME
  {
    0,                      // Flags
    &AutomationVolume,      // AutomationTable
    &KSNODETYPE_VOLUME,     // Type
    &KSAUDFNAME_MASTER_VOLUME // Name
  },

  // KSNODE_TOPO_WAVEIN_MUX
  {
    0,                      // Flags
    &AutomationMux,         // AutomationTable
    &KSNODETYPE_MUX,        // Type
    &KSAUDFNAME_RECORDING_SOURCE // Name
  },
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
  //  FromNode,                     FromPin,                        ToNode,                      ToPin
  {   PCFILTER_NODE,                KSPIN_TOPO_WAVEOUT_SOURCE,      KSNODE_TOPO_WAVEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_WAVEOUT_VOLUME,   0,                              KSNODE_TOPO_WAVEOUT_MUTE,    1 },
  {   KSNODE_TOPO_WAVEOUT_MUTE,     0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHOUT_SOURCE,     KSNODE_TOPO_SYNTHOUT_VOLUME, 1 },
  {   KSNODE_TOPO_SYNTHOUT_VOLUME,  0,                              KSNODE_TOPO_SYNTHOUT_MUTE,   1 },
  {   KSNODE_TOPO_SYNTHOUT_MUTE,    0,                              KSNODE_TOPO_LINEOUT_MIX,     1 },

  {   PCFILTER_NODE,                KSPIN_TOPO_SYNTHIN_SOURCE,      KSNODE_TOPO_SYNTHIN_VOLUME,  1 },
  {   KSNODE_TOPO_SYNTHIN_VOLUME,   0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   PCFILTER_NODE,                KSPIN_TOPO_MIC_SOURCE,          KSNODE_TOPO_MIC_VOLUME,      1 },
  {   KSNODE_TOPO_MIC_VOLUME,       0,                              KSNODE_TOPO_WAVEIN_MUX,      4 },

  {   KSNODE_TOPO_LINEOUT_MIX,      0,                              KSNODE_TOPO_LINEOUT_VOLUME,  1 },
  {   KSNODE_TOPO_LINEOUT_VOLUME,   0,                              PCFILTER_NODE,               KSPIN_TOPO_LINEOUT_DEST },

  {   KSNODE_TOPO_WAVEIN_MUX,       0,                              PCFILTER_NODE,               KSPIN_TOPO_WAVEIN_DEST }
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
  0,                                  // Version
  NULL,                               // AutomationTable
  sizeof(PCPIN_DESCRIPTOR),           // PinSize
  SIZEOF_ARRAY(MiniportPins),         // PinCount
  MiniportPins,                       // Pins
  sizeof(PCNODE_DESCRIPTOR),          // NodeSize
  SIZEOF_ARRAY(TopologyNodes),        // NodeCount
  TopologyNodes,                      // Nodes
  SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
  MiniportConnections,                // Connections
  0,                                  // CategoryCount
  NULL                                // Categories
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\simple\simple.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    simple.h

Abstract:

    Node and Pin numbers for simple sample.

--*/

#ifndef _MSVAD_SIMPLE_H_
#define _MSVAD_SIMPLE_H_

// Name Guid
// {946A7B1A-EBBC-422a-A81F-F07C8D40D3B4}
#define STATIC_NAME_MSVAD_SIMPLE\
    0x946a7b1a, 0xebbc, 0x422a, 0xa8, 0x1f, 0xf0, 0x7c, 0x8d, 0x40, 0xd3, 0xb4
DEFINE_GUIDSTRUCT("946A7B1A-EBBC-422a-A81F-F07C8D40D3B4", NAME_MSVAD_SIMPLE);
#define NAME_MSVAD_SIMPLE DEFINE_GUIDNAMED(NAME_MSVAD_SIMPLE)

// Pin properties.
#define MAX_OUTPUT_STREAMS          1       // Number of capture streams.
#define MAX_INPUT_STREAMS           1       // Number of render streams.
#define MAX_TOTAL_STREAMS           MAX_OUTPUT_STREAMS + MAX_INPUT_STREAMS                      

// PCM Info
#define MIN_CHANNELS                1       // Min Channels.
#define MAX_CHANNELS_PCM            2       // Max Channels.
#define MIN_BITS_PER_SAMPLE_PCM     8       // Min Bits Per Sample
#define MAX_BITS_PER_SAMPLE_PCM     16      // Max Bits Per Sample
#define MIN_SAMPLE_RATE             4000    // Min Sample Rate
#define MAX_SAMPLE_RATE             64000   // Max Sample Rate

// Wave pins
enum 
{
    KSPIN_WAVE_CAPTURE_SINK = 0,
    KSPIN_WAVE_CAPTURE_SOURCE,
    KSPIN_WAVE_RENDER_SINK, 
    KSPIN_WAVE_RENDER_SOURCE
};

// Wave Topology nodes.
enum 
{
    KSNODE_WAVE_ADC = 0,
    KSNODE_WAVE_DAC
};

// topology pins.
enum
{
    KSPIN_TOPO_WAVEOUT_SOURCE = 0,
    KSPIN_TOPO_SYNTHOUT_SOURCE,
    KSPIN_TOPO_SYNTHIN_SOURCE,
    KSPIN_TOPO_MIC_SOURCE,
    KSPIN_TOPO_LINEOUT_DEST,
    KSPIN_TOPO_WAVEIN_DEST
};

// topology nodes.
enum
{
    KSNODE_TOPO_WAVEOUT_VOLUME = 0,
    KSNODE_TOPO_WAVEOUT_MUTE,
    KSNODE_TOPO_SYNTHOUT_VOLUME,
    KSNODE_TOPO_SYNTHOUT_MUTE,
    KSNODE_TOPO_MIC_VOLUME,
    KSNODE_TOPO_SYNTHIN_VOLUME,
    KSNODE_TOPO_LINEOUT_MIX,
    KSNODE_TOPO_LINEOUT_VOLUME,
    KSNODE_TOPO_WAVEIN_MUX
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\simple\minwave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "simple.h"
#include "minwave.h"
#include "wavtable.h"

#pragma code_seg("PAGE")

//=============================================================================
// CMiniportWaveCyclic
//=============================================================================

//=============================================================================
NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Create the wavecyclic miniport.

Arguments:

  Unknown - 

  RefClsId -

  UnknownOuter -

  PoolType -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportWaveCyclic, Unknown, UnknownOuter, PoolType);
}

//=============================================================================
CMiniportWaveCyclic::~CMiniportWaveCyclic
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::~CMiniportWaveCyclic]"));
} // ~CMiniportWaveCyclic


//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::DataRangeIntersection
( 
    IN  ULONG                       PinId,
    IN  PKSDATARANGE                ClientDataRange,
    IN  PKSDATARANGE                MyDataRange,
    IN  ULONG                       OutputBufferLength,
    OUT PVOID                       ResultantFormat,
    OUT PULONG                      ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId -           Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data 
                    range submitted by client in the data range intersection 
                    property request. 

  MyDataRange -         Pin's data range to be compared with client's data 
                        range. In this case we actually ignore our own data 
                        range, because we know that we only support one range.

  OutputBufferLength -  Size of the buffer pointed to by the resultant format 
                        parameter. 

  ResultantFormat -     Pointer to value where the resultant format should be 
                        returned. 

  ResultantFormatLength -   Actual length of the resultant format placed in 
                            ResultantFormat. This should be less than or equal 
                            to OutputBufferLength. 

  Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    // This driver only supports PCM formats.
    // Portcls will handle the request for us.
    //

    return STATUS_NOT_IMPLEMENTED;
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    return 
        CMiniportWaveCyclicMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    NTSTATUS                    ntStatus;

    DPF_ENTER(("[CMiniportWaveCyclic::Init]"));

    m_MaxOutputStreams      = MAX_OUTPUT_STREAMS;
    m_MaxInputStreams       = MAX_INPUT_STREAMS;
    m_MaxTotalStreams       = MAX_TOTAL_STREAMS;

    m_MinChannels           = MIN_CHANNELS;
    m_MaxChannelsPcm        = MAX_CHANNELS_PCM;

    m_MinBitsPerSamplePcm   = MIN_BITS_PER_SAMPLE_PCM;
    m_MaxBitsPerSamplePcm   = MAX_BITS_PER_SAMPLE_PCM;
    m_MinSampleRatePcm      = MIN_SAMPLE_RATE;
    m_MaxSampleRatePcm      = MAX_SAMPLE_RATE;

    ntStatus =
        CMiniportWaveCyclicMSVAD::Init
        (
            UnknownAdapter_,
            ResourceList_,
            Port_
        );
    if (NT_SUCCESS(ntStatus))
    {
        // Set filter descriptor.
        m_FilterDescriptor = &MiniportFilterDescriptor;

        m_fCaptureAllocated = FALSE;
        m_fRenderAllocated = FALSE;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NewStream
( 
    OUT PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  ULONG                   Pin,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL *           OutDmaChannel,
    OUT PSERVICEGROUP *         OutServiceGroup 
)
/*++

Routine Description:

  The NewStream function creates a new instance of a logical stream 
  associated with a specified physical channel. Callers of NewStream should 
  run at IRQL PASSIVE_LEVEL.

Arguments:

  OutStream -

  OuterUnknown -

  PoolType - 

  Pin - 

  Capture - 

  DataFormat -

  OutDmaChannel -

  OutServiceGroup -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    DPF_ENTER(("[CMiniportWaveCyclic::NewStream]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PCMiniportWaveCyclicStream  stream = NULL;

    // Check if we have enough streams.
    if (Capture)
    {
        if (m_fCaptureAllocated)
        {
            DPF(D_TERSE, ("[Only one capture stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        if (m_fRenderAllocated)
        {
            DPF(D_TERSE, ("[Only one render stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    // Instantiate a stream. Stream must be in
    // NonPagedPool because of file saving.
    //
    if (NT_SUCCESS(ntStatus))
    {
        stream = new (NonPagedPool, MSVAD_POOLTAG) 
            CMiniportWaveCyclicStream(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus = 
                stream->Init
                ( 
                    this,
                    Pin,
                    Capture,
                    DataFormat
                );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (Capture)
        {
            m_fCaptureAllocated = TRUE;
        }
        else
        {
            m_fRenderAllocated = TRUE;
        }

        *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
        (*OutStream)->AddRef();
        
        *OutDmaChannel = PDMACHANNEL(stream);
        (*OutDmaChannel)->AddRef();

        *OutServiceGroup = m_ServiceGroup;
        (*OutServiceGroup)->AddRef();

        // The stream, the DMA channel, and the service group have
        // references now for the caller.  The caller expects these
        // references to be there.
    }

    // This is our private reference to the stream.  The caller has
    // its own, so we can release in any case.
    //
    if (stream)
    {
        stream->Release();
    }
    
    return ntStatus;
} // NewStream

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.

        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS
CMiniportWaveCyclic::PropertyHandlerComponentId
(
    IN PPCPROPERTY_REQUEST      PropertyRequest
)
/*++

Routine Description:

  Handles KSPROPERTY_GENERAL_COMPONENTID

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[PropertyHandlerComponentId]"));

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = 
            PropertyHandler_BasicSupport
            (
                PropertyRequest,
                KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_GET,
                VT_ILLEGAL
            );
    }
    else
    {
        ntStatus = 
            ValidatePropertyParams
            (
                PropertyRequest, 
                sizeof(KSCOMPONENTID), 
                0
            );
        if (NT_SUCCESS(ntStatus))
        {
            if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                PKSCOMPONENTID pComponentId = (PKSCOMPONENTID)
                    PropertyRequest->Value;

                INIT_MMREG_MID(&pComponentId->Manufacturer, MM_MICROSOFT);
                pComponentId->Product   = PID_MSVAD;
                pComponentId->Name      = NAME_MSVAD_SIMPLE;
                pComponentId->Component = GUID_NULL; // Not used for extended caps.
                pComponentId->Version   = MSVAD_VERSION;
                pComponentId->Revision  = MSVAD_REVISION;

                PropertyRequest->ValueSize = sizeof(KSCOMPONENTID);
                ntStatus = STATUS_SUCCESS;
            }
        }
        else
        {
            DPF(D_TERSE, ("[PropertyHandlerComponentId - Invalid parameter]"));
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    }

    return ntStatus;
} // PropertyHandlerComponentId

//=============================================================================
NTSTATUS
PropertyHandler_WaveFilter
( 
    IN PPCPROPERTY_REQUEST      PropertyRequest 
)
/*++

Routine Description:

  Redirects general property request to miniport object

Arguments:

  PropertyRequest - 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PCMiniportWaveCyclic        pWave = 
        (PCMiniportWaveCyclic) PropertyRequest->MajorTarget;

    switch (PropertyRequest->PropertyItem->Id)
    {
        case KSPROPERTY_GENERAL_COMPONENTID:
            ntStatus = 
                pWave->PropertyHandlerComponentId
                (
                    PropertyRequest
                );
            break;
        
        default:
            DPF(D_TERSE, ("[PropertyHandler_WaveFilter: Invalid Device Request]"));
    }

    return ntStatus;
} // PropertyHandler_WaveFilter

//=============================================================================
// CMiniportWaveStreamCyclicSimple
//=============================================================================

//=============================================================================
CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclicstream 

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream]"));

    if (NULL != m_pMiniportLocal)
    {
        if (m_fCapture)
        {
            m_pMiniportLocal->m_fCaptureAllocated = FALSE;
        }
        else
        {
            m_pMiniportLocal->m_fRenderAllocated = FALSE;
        }
    }
} // ~CMiniportWaveCyclicStream

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStream::Init
( 
    IN PCMiniportWaveCyclic         Miniport_,
    IN ULONG                        Pin_,
    IN BOOLEAN                      Capture_,
    IN PKSDATAFORMAT                DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ -

  Pin_ -

  Capture_ -

  DataFormat -

  DmaChannel_ -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    m_pMiniportLocal = Miniport_;

    return 
        CMiniportWaveCyclicStreamMSVAD::Init
        (
            Miniport_,
            Pin_,
            Capture_,
            DataFormat_
        );
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStream::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNEL(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\simple\wavtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    wavtable.h

Abstract:

    Declaration of wave miniport tables.

--*/

#ifndef _MSVAD_WAVTABLE_H_
#define _MSVAD_WAVTABLE_H_

//=============================================================================
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_PCM,           
        MIN_BITS_PER_SAMPLE_PCM,    
        MAX_BITS_PER_SAMPLE_PCM,    
        MIN_SAMPLE_RATE,            
        MAX_SAMPLE_RATE             
    },
};

static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }
};

static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    // Wave In Streaming Pin (Capture) KSPIN_WAVE_CAPTURE_SINK
    {
        MAX_OUTPUT_STREAMS,
        MAX_OUTPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_RECORDING_CONTROL,  
            0
        }
    },
    
    // Wave In Bridge Pin (Capture - From Topology) KSPIN_WAVE_CAPTURE_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
  
    // Wave Out Streaming Pin (Renderer) KSPIN_WAVE_RENDER_SINK
    {
        MAX_INPUT_STREAMS,
        MAX_INPUT_STREAMS, 
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_VOLUME_CONTROL,
            0
        }
    },
  
    // Wave Out Bridge Pin (Renderer) KSPIN_WAVE_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
};

//=============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // KSNODE_WAVE_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_DAC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};

//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,        KSPIN_WAVE_CAPTURE_SOURCE,  KSNODE_WAVE_ADC,     1 },    
    { KSNODE_WAVE_ADC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_CAPTURE_SINK },    

    { PCFILTER_NODE,        KSPIN_WAVE_RENDER_SINK,     KSNODE_WAVE_DAC,     1 },    
    { KSNODE_WAVE_DAC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_RENDER_SOURCE },    
};

//=============================================================================
static
PCPROPERTY_ITEM PropertiesWaveFilter[] =
{
  {
    &KSPROPSETID_General,
    KSPROPERTY_GENERAL_COMPONENTID,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_WaveFilter
  },
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationWaveFilter, PropertiesWaveFilter);

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    &AutomationWaveFilter,              // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories  - use defaults (audio, render, capture)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\common.cpp ===
/*****************************************************************************
 * common.cpp - Common code used by all the sb16 miniports.
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 *
 * Implmentation of the common code object.  This class deals with interrupts
 * for the device, and is a collection of common code used by all the
 * miniports.
 */

#include "common.h"

#define STR_MODULENAME "sb16Adapter: "




/*****************************************************************************
 * CAdapterCommon
 
 *****************************************************************************
 * Adapter common object.
 */
class CAdapterCommon
:   public IAdapterCommon,
    public IAdapterPowerManagement,
    public CUnknown
    
{
private:
    PINTERRUPTSYNC          m_pInterruptSync;
    PUCHAR                  m_pWaveBase;
    PWAVEMINIPORTSB16       m_WaveMiniportSB16;
#ifdef EVENT_SUPPORT
    PTOPOMINIPORTSB16       m_TopoMiniportSB16;     // Topology miniport of SB16.
#endif
    PDEVICE_OBJECT          m_pDeviceObject;
    DEVICE_POWER_STATE      m_PowerState;
    BYTE                    MixerSettings[DSP_MIX_MAXREGS];

    void AcknowledgeIRQ
    (   void
    );

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CAdapterCommon);
    ~CAdapterCommon();

    /*****************************************************************************
     * IAdapterCommon methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PRESOURCELIST   ResourceList,
        IN      PDEVICE_OBJECT  DeviceObject
    );
    STDMETHODIMP_(PINTERRUPTSYNC) GetInterruptSync
    (   void
    );
    STDMETHODIMP_(void) SetWaveMiniport (IN PWAVEMINIPORTSB16 Miniport)
    {
        m_WaveMiniportSB16 = Miniport;
    }
    STDMETHODIMP_(BYTE) ReadController
    (   void
    );
    STDMETHODIMP_(BOOLEAN) WriteController
    (
        IN      BYTE    Value
    );
    STDMETHODIMP_(NTSTATUS) ResetController
    (   void
    );
    STDMETHODIMP_(void) MixerRegWrite
    (
        IN      BYTE    Index,
        IN      BYTE    Value
    );
    STDMETHODIMP_(BYTE) MixerRegRead
    (
        IN      BYTE    Index
    );
    STDMETHODIMP_(void) MixerReset
    (   void
    );
    STDMETHODIMP RestoreMixerSettingsFromRegistry
    (   void
    );
    STDMETHODIMP SaveMixerSettingsToRegistry
    (   void
    );
#ifdef EVENT_SUPPORT
    //
    // The topology miniport needs to tell us the pointer to the Event-interface.
    //
    STDMETHODIMP_(void) SetTopologyMiniport (IN PTOPOMINIPORTSB16 Miniport)
    {
        m_TopoMiniportSB16 = Miniport;
    };
#endif
    
    /*************************************************************************
     * IAdapterPowerManagement implementation
     *
     * This macro is from PORTCLS.H.  It lists all the interface's functions.
     */
    IMP_IAdapterPowerManagement;

    friend
    NTSTATUS
    InterruptServiceRoutine
    (
        IN      PINTERRUPTSYNC  InterruptSync,
        IN      PVOID           DynamicContext
    );
};

static
MIXERSETTING DefaultMixerSettings[] =
{
    { L"LeftMasterVol",   DSP_MIX_MASTERVOLIDX_L,     0xD8 },
    { L"RightMasterVol",  DSP_MIX_MASTERVOLIDX_R,     0xD8 },
    { L"LeftWaveVol",     DSP_MIX_VOICEVOLIDX_L,      0xD8 },
    { L"RightWaveVol",    DSP_MIX_VOICEVOLIDX_R,      0xD8 },
    { L"LeftMidiVol",     DSP_MIX_FMVOLIDX_L,         0xD8 },
    { L"RightMidiVol",    DSP_MIX_FMVOLIDX_R,         0xD8 },
    { L"LeftCDVol",       DSP_MIX_CDVOLIDX_L,         0xD8 },
    { L"RightCDVol",      DSP_MIX_CDVOLIDX_R,         0xD8 },
    { L"LeftLineInVol",   DSP_MIX_LINEVOLIDX_L,       0xD8 },
    { L"RightLineInVol",  DSP_MIX_LINEVOLIDX_R,       0xD8 },
    { L"MicVol",          DSP_MIX_MICVOLIDX,          0xD8 },
    { L"PcSpkrVol",       DSP_MIX_SPKRVOLIDX,         0x00 },
    { L"OutputMixer",     DSP_MIX_OUTMIXIDX,          0x1E },
    { L"LeftInputMixer",  DSP_MIX_ADCMIXIDX_L,        0x55 },
    { L"RightInputMixer", DSP_MIX_ADCMIXIDX_R,        0x2B },
    { L"LeftInputGain",   DSP_MIX_INGAINIDX_L,        0x00 },
    { L"RightInputGain",  DSP_MIX_INGAINIDX_R,        0x00 },
    { L"LeftOutputGain",  DSP_MIX_OUTGAINIDX_L,       0x80 },
    { L"RightOutputGain", DSP_MIX_OUTGAINIDX_R,       0x80 },
    { L"MicAGC",          DSP_MIX_AGCIDX,             0x01 },
    { L"LeftTreble",      DSP_MIX_TREBLEIDX_L,        0x80 },
    { L"RightTreble",     DSP_MIX_TREBLEIDX_R,        0x80 },
    { L"LeftBass",        DSP_MIX_BASSIDX_L,          0x80 },
    { L"RightBass",       DSP_MIX_BASSIDX_R,          0x80 },
};



#pragma code_seg("PAGE")

/*****************************************************************************
 * NewAdapterCommon()
 *****************************************************************************
 * Create a new adapter common object.
 */
NTSTATUS
NewAdapterCommon
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY_
    (
        CAdapterCommon,
        Unknown,
        UnknownOuter,
        PoolType,
        PADAPTERCOMMON
    );
}   


/*****************************************************************************
 * CAdapterCommon::Init()
 *****************************************************************************
 * Initialize an adapter common object.
 */
NTSTATUS
CAdapterCommon::
Init
(
    IN      PRESOURCELIST   ResourceList,
    IN      PDEVICE_OBJECT  DeviceObject
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    ASSERT(DeviceObject);

    //
    // Make sure we have the resources we expect
    //
    if ((ResourceList->NumberOfPorts() < 1) ||
        (ResourceList->NumberOfInterrupts() != 1))
    {
        _DbgPrintF (DEBUGLVL_TERSE, ("unknown configuration; check your code!"));
        // Bail out.
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    m_pDeviceObject = DeviceObject;
    m_WaveMiniportSB16 = NULL;
#ifdef EVENT_SUPPORT
    m_TopoMiniportSB16 = NULL;
#endif

    //
    // Get the base address for the wave device.
    //
    ASSERT(ResourceList->FindTranslatedPort(0));
    m_pWaveBase = (PUCHAR)(ResourceList->FindTranslatedPort(0)->u.Port.Start.QuadPart);

    //
    // Set initial device power state
    //
    m_PowerState = PowerDeviceD0;

    //
    // Reset the hardware.
    //
    NTSTATUS ntStatus = ResetController();

    if(NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("ResetController Succeeded"));
        AcknowledgeIRQ();
    
        //
        // Hook up the interrupt.
        //
        ntStatus = PcNewInterruptSync(                              // See portcls.h
                                        &m_pInterruptSync,          // Save object ptr
                                        NULL,                       // OuterUnknown(optional).
                                        ResourceList,               // He gets IRQ from ResourceList.
                                        0,                          // Resource Index
                                        InterruptSyncModeNormal     // Run ISRs once until we get SUCCESS
                                     );
        if (NT_SUCCESS(ntStatus) && m_pInterruptSync)
        {                                                                       //  run this ISR first
            ntStatus = m_pInterruptSync->RegisterServiceRoutine(InterruptServiceRoutine,PVOID(this),FALSE);
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->Connect();
            }

            // if we could not connect or register the ISR, release the object.
            if (!NT_SUCCESS (ntStatus))
            {
                m_pInterruptSync->Release();
                m_pInterruptSync = NULL;
            }
        }
    } else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("ResetController Failure"));
    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::~CAdapterCommon()
 *****************************************************************************
 * Destructor.
 */
CAdapterCommon::
~CAdapterCommon
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CAdapterCommon::~CAdapterCommon]"));

    if (m_pInterruptSync)
    {
        m_pInterruptSync->Disconnect();
        m_pInterruptSync->Release();
        m_pInterruptSync = NULL;
    }
}

/*****************************************************************************
 * CAdapterCommon::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP
CAdapterCommon::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PADAPTERCOMMON(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IAdapterCommon))
    {
        *Object = PVOID(PADAPTERCOMMON(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IAdapterPowerManagement))
    {
        *Object = PVOID(PADAPTERPOWERMANAGEMENT(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CAdapterCommon::GetInterruptSync()
 *****************************************************************************
 * Get a pointer to the interrupt synchronization object.
 */
STDMETHODIMP_(PINTERRUPTSYNC)
CAdapterCommon::
GetInterruptSync
(   void
)
{
    PAGED_CODE();

    return m_pInterruptSync;
}

#pragma code_seg()

/*****************************************************************************
 * CAdapterCommon::ReadController()
 *****************************************************************************
 * Read a byte from the controller.
 */
STDMETHODIMP_(BYTE)
CAdapterCommon::
ReadController
(   void
)
{
    BYTE returnValue = BYTE(-1);

    ASSERT(m_pWaveBase);

    ULONGLONG startTime = PcGetTimeInterval(0);

    do {
        if (READ_PORT_UCHAR (m_pWaveBase + DSP_REG_DATAAVAIL) & 0x80)
        {
            returnValue = READ_PORT_UCHAR (m_pWaveBase + DSP_REG_READ);
        }
    } while ((PcGetTimeInterval(startTime) < GTI_MILLISECONDS(100)) &&
             (BYTE(-1) == returnValue));


    ASSERT((BYTE(-1) != returnValue) || !"ReadController timeout!");

    return returnValue;
}

/*****************************************************************************
 * CAdapterCommon::WriteController()
 *****************************************************************************
 * Write a byte to the controller.
 */
STDMETHODIMP_(BOOLEAN)
CAdapterCommon::
WriteController
(
    IN      BYTE    Value
)
{
    ASSERT(m_pWaveBase);

    BOOLEAN     returnValue = FALSE;
    ULONGLONG   startTime   = PcGetTimeInterval(0);

    do
    {
        BYTE status = READ_PORT_UCHAR (m_pWaveBase + DSP_REG_WRITE);

        if ((status & 0x80) == 0)
        {
            WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_WRITE, Value);

            returnValue = TRUE;
        }
    } while ((PcGetTimeInterval(startTime) < GTI_MILLISECONDS(100)) &&
              ! returnValue);

    ASSERT(returnValue || !"WriteController timeout");

    return returnValue;
}

/*****************************************************************************
 * CAdapterCommon::MixerRegWrite()
 *****************************************************************************
 * Writes a mixer register.
 */
STDMETHODIMP_(void)
CAdapterCommon::
MixerRegWrite
(
    IN      BYTE    Index,
    IN      BYTE    Value
)
{
    ASSERT( m_pWaveBase );
    BYTE actualIndex;

    // only hit the hardware if we're in an acceptable power state
    if( m_PowerState <= PowerDeviceD1 )
    {
        actualIndex = (BYTE) ((Index < 0x80) ? (Index + DSP_MIX_BASEIDX) : Index);
    
        WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXREG, actualIndex);
    
        WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXDATA, Value);
    }

    if(Index < DSP_MIX_MAXREGS)
    {
        MixerSettings[Index] = Value;
    }
}

/*****************************************************************************
 * CAdapterCommon::MixerRegRead()
 *****************************************************************************
 * Reads a mixer register.
 */
STDMETHODIMP_(BYTE)
CAdapterCommon::
MixerRegRead
(
    IN      BYTE    Index
)
{
    if(Index < DSP_MIX_MAXREGS)
    {
        return MixerSettings[Index];
    }

    //
    // Not in the cache? Read from HW directly.
    //
    // We need to make sure that we can access the HW directly for
    // the volumes that can change externally.
    // This is done here with passing an index outside of the cache.
    // Since the an index=0 is actually DSP_MIX_BASEIDX which is less
    // than the cache size (DSP_MIX_MAXREGS), you can access any volume
    // directly with passing DSP_MIX_BASEIDX + index.
    // You could also pass a flag - but we want to keep the changes
    // minimal - or create a new function like MixerRegReadDirect().
    //
    WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXREG, Index);
    return READ_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXDATA);
}

/*****************************************************************************
 * CAdapterCommon::MixerReset()
 *****************************************************************************
 * Resets the mixer
 */
STDMETHODIMP_(void)
CAdapterCommon::
MixerReset
(   void
)
{
    ASSERT(m_pWaveBase);

    WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXREG, DSP_MIX_DATARESETIDX);

    WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXDATA, 0);

    RestoreMixerSettingsFromRegistry();
}

/*****************************************************************************
 * CAdapterCommon::AcknowledgeIRQ()
 *****************************************************************************
 * Acknowledge interrupt request.
 */
void
CAdapterCommon::
AcknowledgeIRQ
(   void
)
{
    ASSERT(m_pWaveBase);
    READ_PORT_UCHAR (m_pWaveBase + DSP_REG_ACK16BIT);
    READ_PORT_UCHAR (m_pWaveBase + DSP_REG_ACK8BIT);
}

/*****************************************************************************
 * CAdapterCommon::ResetController()
 *****************************************************************************
 * Resets the controller.
 */
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::
ResetController(void)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // write a 1 to the reset bit
    WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_RESET,1);

    // wait for  at least 3 microseconds
    KeStallExecutionProcessor (5L);    // okay, 5us

    // write a 0 to the reset bit
    WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_RESET,0);

    // hang out for 100us
    KeStallExecutionProcessor (100L);
    
    // read the controller
    BYTE ReadVal = ReadController ();

    // check return value
    if( ReadVal == BYTE(0xAA) )
    {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::RestoreMixerSettingsFromRegistry()
 *****************************************************************************
 * Restores the mixer settings based on settings stored in the registry.
 */
STDMETHODIMP
CAdapterCommon::
RestoreMixerSettingsFromRegistry
(   void
)
{
    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[RestoreMixerSettingsFromRegistry]"));
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey( &DriverKey,               // IRegistryKey
                                          NULL,                     // OuterUnknown
                                          DriverRegistryKey,        // Registry key type
                                          KEY_ALL_ACCESS,           // Access flags
                                          m_pDeviceObject,          // Device object
                                          NULL,                     // Subdevice
                                          NULL,                     // ObjectAttributes
                                          0,                        // Create options
                                          NULL );                   // Disposition
    if(NT_SUCCESS(ntStatus))
    {
        UNICODE_STRING  KeyName;
        ULONG           Disposition;
        
        // make a unicode strong for the subkey name
        RtlInitUnicodeString( &KeyName, L"Settings" );



        // open the settings subkey
        ntStatus = DriverKey->NewSubKey( &SettingsKey,              // Subkey
                                         NULL,                      // OuterUnknown
                                         KEY_ALL_ACCESS,            // Access flags
                                         &KeyName,                  // Subkey name
                                         REG_OPTION_NON_VOLATILE,   // Create options
                                         &Disposition );
        if(NT_SUCCESS(ntStatus))
        {
            ULONG   ResultLength;

            if(Disposition == REG_CREATED_NEW_KEY)
            {
                // copy default settings
                for(ULONG i = 0; i < SIZEOF_ARRAY(DefaultMixerSettings); i++)
                {
                    MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                   DefaultMixerSettings[i].RegisterSetting );
                }
            } else
            {
                // allocate data to hold key info
                PVOID KeyInfo = ExAllocatePool(PagedPool, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD));
                if(NULL != KeyInfo)
                {
                    // loop through all mixer settings
                    for(UINT i = 0; i < SIZEOF_ARRAY(DefaultMixerSettings); i++)
                    {
                        // init key name
                        RtlInitUnicodeString( &KeyName, DefaultMixerSettings[i].KeyName );
        
                        // query the value key
                        ntStatus = SettingsKey->QueryValueKey( &KeyName,
                                                               KeyValuePartialInformation,
                                                               KeyInfo,
                                                               sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                                               &ResultLength );
                        if(NT_SUCCESS(ntStatus))
                        {
                            PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = PKEY_VALUE_PARTIAL_INFORMATION(KeyInfo);
    
                            if(PartialInfo->DataLength == sizeof(DWORD))
                            {
                                // set mixer register to registry value
                                MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                               BYTE(*(PDWORD(PartialInfo->Data))) );
                            }
                        } else
                        {
                            // if key access failed, set to default
                            MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                           DefaultMixerSettings[i].RegisterSetting );
                        }
                    }
    
                    // free the key info
                    ExFreePool(KeyInfo);
                } else
                {
                    // copy default settings
                    for(ULONG i = 0; i < SIZEOF_ARRAY(DefaultMixerSettings); i++)
                    {
                        MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                       DefaultMixerSettings[i].RegisterSetting );
                    }

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            // release the settings key
            SettingsKey->Release();
        }

        // release the driver key
        DriverKey->Release();

    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::SaveMixerSettingsToRegistry()
 *****************************************************************************
 * Saves the mixer settings to the registry.
 */
STDMETHODIMP
CAdapterCommon::
SaveMixerSettingsToRegistry
(   void
)
{
    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[SaveMixerSettingsToRegistry]"));
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey( &DriverKey,               // IRegistryKey
                                          NULL,                     // OuterUnknown
                                          DriverRegistryKey,        // Registry key type
                                          KEY_ALL_ACCESS,           // Access flags
                                          m_pDeviceObject,          // Device object
                                          NULL,                     // Subdevice
                                          NULL,                     // ObjectAttributes
                                          0,                        // Create options
                                          NULL );                   // Disposition
    if(NT_SUCCESS(ntStatus))
    {
        UNICODE_STRING  KeyName;
        
        // make a unicode strong for the subkey name
        RtlInitUnicodeString( &KeyName, L"Settings" );

        // open the settings subkey
        ntStatus = DriverKey->NewSubKey( &SettingsKey,              // Subkey
                                         NULL,                      // OuterUnknown
                                         KEY_ALL_ACCESS,            // Access flags
                                         &KeyName,                  // Subkey name
                                         REG_OPTION_NON_VOLATILE,   // Create options
                                         NULL );
        if(NT_SUCCESS(ntStatus))
        {
            // loop through all mixer settings
            for(UINT i = 0; i < SIZEOF_ARRAY(MixerSettings); i++)
            {
                // init key name
                RtlInitUnicodeString( &KeyName, DefaultMixerSettings[i].KeyName );

                // set the key
                DWORD KeyValue = DWORD(MixerSettings[DefaultMixerSettings[i].RegisterIndex]);
                ntStatus = SettingsKey->SetValueKey( &KeyName,                 // Key name
                                                     REG_DWORD,                // Key type
                                                     PVOID(&KeyValue),
                                                     sizeof(DWORD) );
                if(!NT_SUCCESS(ntStatus))
                {
                    break;
                }
            }

            // release the settings key
            SettingsKey->Release();
        }

        // release the driver key
        DriverKey->Release();

    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::PowerChangeState()
 *****************************************************************************
 * Change power state for the device.
 */
STDMETHODIMP_(void)
CAdapterCommon::
PowerChangeState
(
    IN      POWER_STATE     NewState
)
{
    UINT i;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CAdapterCommon::PowerChangeState]"));

    // Is this actually a state change?
    if( NewState.DeviceState != m_PowerState )
    {
        // switch on new state
        switch( NewState.DeviceState )
        {
            case PowerDeviceD0:
                // Insert your code here for entering the full power state (D0).
                // This code may be a function of the current power state.  Note that
                // property accesses such as volume and mute changes may occur when
                // the device is in a sleep state (D1-D3) and should be cached in the
                // driver to be restored upon entering D0.  However, it should also be
                // noted that new miniport and new streams will only be attempted at
                // D0 -- PortCls will place the device in D0 prior to the NewStream call.

                // Save the new state.  This local value is used to determine when to cache
                // property accesses and when to permit the driver from accessing the hardware.
                m_PowerState = NewState.DeviceState;

                // restore mixer settings
                for(i = 0; i < DSP_MIX_MAXREGS - 1; i++)
                {
                    if( i != DSP_MIX_MICVOLIDX )
                    {
                        MixerRegWrite( BYTE(i), MixerSettings[i] );
                    }
                }

                if (m_WaveMiniportSB16)
                {
                    m_WaveMiniportSB16->RestoreSampleRate();
                }
                break;

            case PowerDeviceD1:
                // This sleep state is the lowest latency sleep state with respect to the
                // latency time required to return to D0.  The driver can still access
                // the hardware in this state if desired.  If the driver is not being used
                // an inactivity timer in PortCls will place the driver in this state after
                // a timeout period controllable via the registry.
                
            case PowerDeviceD2:
                // This is a medium latency sleep state.  In this state the device driver
                // cannot assume that it can touch the hardware so any accesses need to be
                // cached and the hardware restored upon entering D0 (or D1 conceivably).
                
            case PowerDeviceD3:
                // This is a full hibernation state and is the longest latency sleep state.
                // The driver cannot access the hardware in this state and must cache any
                // hardware accesses and restore the hardware upon returning to D0 (or D1).
                
                // Save the new state.
                m_PowerState = NewState.DeviceState;

                _DbgPrintF(DEBUGLVL_VERBOSE,("  Entering D%d",ULONG(m_PowerState)-ULONG(PowerDeviceD0)));
                break;
    
            default:
                _DbgPrintF(DEBUGLVL_VERBOSE,("  Unknown Device Power State"));
                break;
        }
    }
}

/*****************************************************************************
 * CAdapterCommon::QueryPowerChangeState()
 *****************************************************************************
 * Query to see if the device can
 * change to this power state
 */
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::
QueryPowerChangeState
(
    IN      POWER_STATE     NewStateQuery
)
{
    _DbgPrintF( DEBUGLVL_TERSE, ("[CAdapterCommon::QueryPowerChangeState]"));

    // Check here to see of a legitimate state is being requested
    // based on the device state and fail the call if the device/driver
    // cannot support the change requested.  Otherwise, return STATUS_SUCCESS.
    // Note: A QueryPowerChangeState() call is not guaranteed to always preceed
    // a PowerChangeState() call.

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CAdapterCommon::QueryDeviceCapabilities()
 *****************************************************************************
 * Called at startup to get the caps for the device.  This structure provides
 * the system with the mappings between system power state and device power
 * state.  This typically will not need modification by the driver.
 * 
 */
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::
QueryDeviceCapabilities
(
    IN      PDEVICE_CAPABILITIES    PowerDeviceCaps
)
{
    _DbgPrintF( DEBUGLVL_TERSE, ("[CAdapterCommon::QueryDeviceCapabilities]"));

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * InterruptServiceRoutine()
 *****************************************************************************
 * ISR.
 */
NTSTATUS
InterruptServiceRoutine
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    ASSERT(InterruptSync);
    ASSERT(DynamicContext);

    CAdapterCommon *that = (CAdapterCommon *) DynamicContext;

    //
    // We are here because the MPU tried and failed, so
    // must be a wave interrupt.
    //
    ASSERT(that->m_pWaveBase);

    //
    // Read the Interrupt status register.
    //
    BYTE IntrStatus = that->MixerRegRead (0x82);

    //
    // In case we really read the interrupt status register, we should
    // also USE it and make sure that we really have a wave interrupt
    // and not something else!
    //
    if (IntrStatus & 0x03)      // Voice8 or Voice16 Interrupt
    {
        //
        // Make sure there is a wave miniport.
        //
        if (that->m_WaveMiniportSB16)
        {
            //
            // Tell it it needs to do some work.
            //
            that->m_WaveMiniportSB16->ServiceWaveISR ();
        }
    
        //
        // ACK the ISR.
        //
        that->AcknowledgeIRQ();
    }
    
#ifdef EVENT_SUPPORT
    //
    // This code will fire a volume event in case the HW volume has changed.
    //
    else if (IntrStatus & 0x10)      // Volume interrupt on C16X-mixers
    {
        //
        // Ack vol interrupt
        //
        IntrStatus &= ~0x10;
        that->MixerRegWrite (0x82, IntrStatus);

        //
        // Generate an event for the master volume (as an example)
        //
        if (that->m_TopoMiniportSB16)
        {
            that->m_TopoMiniportSB16->ServiceEvent ();
        }
    }
#endif
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\adapter.cpp ===
/*****************************************************************************
 * adapter.cpp - SB16 adapter driver implementation.
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 *
 * This files does setup and resource allocation/verification for the SB16
 * card. It controls which miniports are started and which resources are
 * given to each miniport. It also deals with interrupt sharing between
 * miniports by hooking the interrupt and calling the correct DPC.
 */

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "sb16Adapter: "

#include "common.h"





/*****************************************************************************
 * Defines
 */
#define MAX_MINIPORTS 5

#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif





/*****************************************************************************
 * Externals
 */
NTSTATUS
CreateMiniportWaveCyclicSB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);
NTSTATUS
CreateMiniportTopologySB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);





/*****************************************************************************
 * Referenced forward
 */
extern "C"
NTSTATUS
AddDevice
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
);

NTSTATUS
StartDevice
(
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object.
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
);

NTSTATUS
AssignResources
(
    IN  PRESOURCELIST   ResourceList,           // All resources.
    OUT PRESOURCELIST * ResourceListWave,       // Wave resources.
    OUT PRESOURCELIST * ResourceListWaveTable,  // Wave table resources.
    OUT PRESOURCELIST * ResourceListFmSynth,    // FM synth resources.
    OUT PRESOURCELIST * ResourceListUart,       // UART resources.
    OUT PRESOURCELIST * ResourceListAdapter     // a copy needed by the adapter
);

#ifdef DO_RESOURCE_FILTERING
extern "C"
NTSTATUS
AdapterDispatchPnp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
);
#endif

DWORD DeterminePlatform(PPORTTOPOLOGY Port);


#pragma code_seg("INIT")

/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
)
{
    PAGED_CODE();

    //
    // Tell the class driver to initialize the driver.
    //
    NTSTATUS ntStatus = PcInitializeAdapterDriver( DriverObject,
                                                   RegistryPathName,
                                                   AddDevice );

#ifdef DO_RESOURCE_FILTERING
    //
    // We want to do resource filtering, so we'll install our own PnP IRP handler.
    //
    if(NT_SUCCESS(ntStatus))
    {
        DriverObject->MajorFunction[IRP_MJ_PNP] = AdapterDispatchPnp;
    }
#endif

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
AddDevice
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
)
{
    PAGED_CODE();

    //
    // Tell the class driver to add the device.
    //
    return PcAddAdapterDevice( DriverObject,
                               PhysicalDeviceObject,
                               PCPFNSTARTDEVICE( StartDevice ),
                               MAX_MINIPORTS,
                               0 );
}

/*****************************************************************************
 * InstallSubdevice()
 *****************************************************************************
 * This function creates and registers a subdevice consisting of a port
 * driver, a minport driver and a set of resources bound together.  It will
 * also optionally place a pointer to an interface on the port driver in a
 * specified location before initializing the port driver.  This is done so
 * that a common ISR can have access to the port driver during initialization,
 * when the ISR might fire.
 */
NTSTATUS
InstallSubdevice
(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    IN      PWCHAR              Name,
    IN      REFGUID             PortClassId,
    IN      REFGUID             MiniportClassId,
    IN      PFNCREATEINSTANCE   MiniportCreate      OPTIONAL,
    IN      PUNKNOWN            UnknownAdapter      OPTIONAL,
    IN      PRESOURCELIST       ResourceList,
    IN      REFGUID             PortInterfaceId,
    OUT     PUNKNOWN *          OutPortInterface    OPTIONAL,
    OUT     PUNKNOWN *          OutPortUnknown      OPTIONAL
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("InstallSubdevice"));

    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Name);

    //
    // Create the port driver object
    //
    PPORT       port;
    NTSTATUS    ntStatus = PcNewPort(&port,PortClassId);

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Deposit the port somewhere if it's needed.
        //
        if (OutPortInterface)
        {
            //
            //  Failure here doesn't cause the entire routine to fail.
            //
            (void) port->QueryInterface
            (
                PortInterfaceId,
                (PVOID *) OutPortInterface
            );
        }

        PUNKNOWN miniport;
        //
        // Create the miniport object
        //
        if (MiniportCreate)
        {
            ntStatus = MiniportCreate
            (
                &miniport,
                MiniportClassId,
                NULL,
                NonPagedPool
            );
        }
        else
        {
            ntStatus = PcNewMiniport((PMINIPORT*) &miniport,MiniportClassId);
        }

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Init the port driver and miniport in one go.
            //
            ntStatus = port->Init( DeviceObject,
                                   Irp,
                                   miniport,
                                   UnknownAdapter,
                                   ResourceList );

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Register the subdevice (port/miniport combination).
                //
                ntStatus = PcRegisterSubdevice( DeviceObject,
                                                Name,
                                                port );
                if (!(NT_SUCCESS(ntStatus)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: PcRegisterSubdevice failed"));
                }
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: port->Init failed"));
            }

            //
            // We don't need the miniport any more.  Either the port has it,
            // or we've failed, and it should be deleted.
            //
            miniport->Release();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewMiniport failed"));
        }

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Deposit the port as an unknown if it's needed.
            //
            if (OutPortUnknown)
            {
                //
                //  Failure here doesn't cause the entire routine to fail.
                //
                (void) port->QueryInterface
                (
                    IID_IUnknown,
                    (PVOID *) OutPortUnknown
                );
            }
        }
        else
        {
            //
            // Retract previously delivered port interface.
            //
            if (OutPortInterface && (*OutPortInterface))
            {
                (*OutPortInterface)->Release();
                *OutPortInterface = NULL;
            }
        }

        //
        // Release the reference which existed when PcNewPort() gave us the
        // pointer in the first place.  This is the right thing to do
        // regardless of the outcome.
        //
        port->Release();
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewPort failed"));
    }

    return ntStatus;
}

/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is started.
 * It is responsible for starting the miniports.  This code is specific to
 * the adapter because it calls out miniports for functions that are specific
 * to the adapter.
 */
NTSTATUS
StartDevice
(
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object.
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE();


    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ResourceList);

    //
    // These are the sub-lists of resources that will be handed to the
    // miniports.
    //
    PRESOURCELIST   resourceListWave        = NULL;
    PRESOURCELIST   resourceListWaveTable   = NULL;
    PRESOURCELIST   resourceListFmSynth     = NULL;
    PRESOURCELIST   resourceListUart        = NULL;
    PRESOURCELIST   resourceListAdapter     = NULL;

    //
    // These are the port driver pointers we are keeping around for registering
    // physical connections.
    //
    PUNKNOWN    unknownTopology   = NULL;
    PUNKNOWN    unknownWave       = NULL;
    PUNKNOWN    unknownWaveTable  = NULL;
    PUNKNOWN    unknownFmSynth    = NULL;

    //
    // Assign resources to individual miniports.  Each sub-list is a copy
    // of the resources from the master list. Each sublist must be released.
    //
    NTSTATUS ntStatus = AssignResources( ResourceList,
                                         &resourceListWave,
                                         &resourceListWaveTable,
                                         &resourceListFmSynth,
                                         &resourceListUart,
                                         &resourceListAdapter );

    //
    // if AssignResources succeeded...
    //
    if(NT_SUCCESS(ntStatus))
    {
        //
        // If the adapter has resources...
        //
        PADAPTERCOMMON pAdapterCommon = NULL;
        if (resourceListAdapter)
        {
            PUNKNOWN pUnknownCommon;

            // create a new adapter common object
            ntStatus = NewAdapterCommon( &pUnknownCommon,
                                         IID_IAdapterCommon,
                                         NULL,
                                         NonPagedPool );
            if (NT_SUCCESS(ntStatus))
            {
                ASSERT( pUnknownCommon );

                // query for the IAdapterCommon interface
                ntStatus = pUnknownCommon->QueryInterface( IID_IAdapterCommon,
                                                           (PVOID *)&pAdapterCommon );
                if (NT_SUCCESS(ntStatus))
                {
                    // Initialize the object
                    ntStatus = pAdapterCommon->Init( resourceListAdapter,
                                                     DeviceObject );
                    if (NT_SUCCESS(ntStatus))
                    {
                        // register with PortCls for power-management services
                        ntStatus = PcRegisterAdapterPowerManagement( (PUNKNOWN)pAdapterCommon,
                                                                     DeviceObject );
                    }
                }

                // release the IUnknown on adapter common
                pUnknownCommon->Release();
            }

            // release the adapter common resource list
            resourceListAdapter->Release();
        }

        //
        // Start the topology miniport.
        //
        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = InstallSubdevice( DeviceObject,
                                         Irp,
                                         L"Topology",
                                         CLSID_PortTopology,
                                         CLSID_PortTopology, // not used
                                         CreateMiniportTopologySB16,
                                         pAdapterCommon,
                                         NULL,
                                         GUID_NULL,
                                         NULL,
                                         &unknownTopology );
        }

        //
        // Start the SB wave miniport if it exists.
        //
        if (resourceListWave)
        {
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = InstallSubdevice( DeviceObject,
                                             Irp,
                                             L"Wave",
                                             CLSID_PortWaveCyclic,
                                             CLSID_PortWaveCyclic,   // not used
                                             CreateMiniportWaveCyclicSB16,
                                             pAdapterCommon,
                                             resourceListWave,
                                             IID_IPortWaveCyclic,
                                             NULL,
                                             &unknownWave );
            }

            // release the wave resource list
            resourceListWave->Release();
        }

        // Start the wave table miniport if it exists.
        if (resourceListWaveTable)
        {
            //
            // NOTE: The wavetable is not currently supported in this sample driver.
            //

            // release the wavetable resource list
            resourceListWaveTable->Release();
        }

        //
        // Start the FM synth miniport if it exists.
        //
        if (resourceListFmSynth)
        {
            //
            // Synth not working yet.
            //

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Failure here is not fatal.
                //
                InstallSubdevice( DeviceObject,
                                  Irp,
                                  L"FMSynth",
                                  CLSID_PortMidi,
                                  CLSID_MiniportDriverFmSynth,
                                  NULL,
                                  pAdapterCommon,
                                  resourceListFmSynth,
                                  GUID_NULL,
                                  NULL,
                                  &unknownFmSynth );
            }

            // release the FM synth resource list
            resourceListFmSynth->Release();
        }

        //
        // Start the UART miniport if it exists.
        //
        if (resourceListUart)
        {
            if (NT_SUCCESS(ntStatus))
            {
                //
                // Failure here is not fatal.
                //
                InstallSubdevice( DeviceObject,
                                  Irp,
                                  L"Uart",
                                  CLSID_PortDMus,
                                  CLSID_MiniportDriverDMusUART,
                                  NULL,
                                  pAdapterCommon->GetInterruptSync(),
                                  resourceListUart,
                                  IID_IPortDMus,
                                  NULL,     //  interface to port not needed
                                  NULL );   //  not physically connected to anything
            }

            resourceListUart->Release();
        }

        //
        // Establish physical connections between filters as shown.
        //
        //              +------+    +------+
        //              | Wave |    | Topo |
        //  Capture <---|0    1|<===|6    2|<--- CD
        //              |      |    |      |
        //   Render --->|2    3|===>|0    3|<--- Line In
        //              +------+    |      |
        //              +------+    |     4|<--- Mic
        //              |  FM  |    |      |
        //     MIDI --->|0    1|===>|1    5|---> Line Out
        //              +------+    +------+
        //
        if (unknownTopology)
        {
            DWORD version = DeterminePlatform((PPORTTOPOLOGY)unknownTopology);
            _DbgPrintF(DEBUGLVL_VERBOSE,("Detected platform version 0x%02X",version));

            if (unknownWave)
            {
                // register wave <=> topology connections
                PcRegisterPhysicalConnection( (PDEVICE_OBJECT)DeviceObject,
                                            unknownTopology,
                                            6,
                                            unknownWave,
                                            1 );
                PcRegisterPhysicalConnection( (PDEVICE_OBJECT)DeviceObject,
                                            unknownWave,
                                            3,
                                            unknownTopology,
                                            0 );
            }

            if (unknownFmSynth)
            {
                // register fmsynth <=> topology connection
                PcRegisterPhysicalConnection( (PDEVICE_OBJECT)DeviceObject,
                                            unknownFmSynth,
                                            1,
                                            unknownTopology,
                                            1 );
            }
        }

        //
        // Release the adapter common object.  It either has other references,
        // or we need to delete it anyway.
        //
        if (pAdapterCommon)
        {
            pAdapterCommon->Release();
        }

        //
        // Release the unknowns.
        //
        if (unknownTopology)
        {
            unknownTopology->Release();
        }
        if (unknownWave)
        {
            unknownWave->Release();
        }
        if (unknownWaveTable)
        {
            unknownWaveTable->Release();
        }
        if (unknownFmSynth)
        {
            unknownFmSynth->Release();
        }

    }

    return ntStatus;
}

/*****************************************************************************
 * AssignResources()
 *****************************************************************************
 * This function assigns the list of resources to the various functions on
 * the card.  This code is specific to the adapter.  All the non-NULL resource
 * lists handed back must be released by the caller.
 */
NTSTATUS
AssignResources
(
    IN      PRESOURCELIST   ResourceList,           // All resources.
    OUT     PRESOURCELIST * ResourceListWave,       // Wave resources.
    OUT     PRESOURCELIST * ResourceListWaveTable,  // Wave table resources.
    OUT     PRESOURCELIST * ResourceListFmSynth,    // FM synth resources.
    OUT     PRESOURCELIST * ResourceListUart,       // Uart resources.
    OUT     PRESOURCELIST * ResourceListAdapter     // For the adapter
)
{
    PAGED_CODE();

    BOOLEAN     detectedWaveTable   = FALSE;
    BOOLEAN     detectedUart        = FALSE;
    BOOLEAN     detectedFmSynth     = FALSE;

    //
    // Get counts for the types of resources.
    //
    ULONG countIO  = ResourceList->NumberOfPorts();
    ULONG countIRQ = ResourceList->NumberOfInterrupts();
    ULONG countDMA = ResourceList->NumberOfDmas();

    //
    // Determine the type of card based on port resources.
    // TODO:  Detect wave table.
    //
    NTSTATUS ntStatus = STATUS_SUCCESS;

    switch (countIO)
    {
    case 1:
        //
        // No FM synth or UART.
        //
        if  (   (ResourceList->FindTranslatedPort(0)->u.Port.Length < 16)
            ||  (countIRQ < 1)
            ||  (countDMA < 1)
            )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        break;

    case 2:
        //
        // MPU-401 or FM synth, not both.
        //
        if  (   (ResourceList->FindTranslatedPort(0)->u.Port.Length < 16)
            ||  (countIRQ < 1)
            ||  (countDMA < 1)
            )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            //
            // Length of second port indicates which function.
            //
            switch (ResourceList->FindTranslatedPort(1)->u.Port.Length)
            {
            case 2:
                detectedUart = TRUE;
                break;

            case 4:
                detectedFmSynth = TRUE;
                break;

            default:
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                break;
            }
        }
        break;

    case 3:
        //
        // Both MPU-401 and FM synth.
        //
        if  (   (ResourceList->FindTranslatedPort(0)->u.Port.Length < 16)
            ||  (ResourceList->FindTranslatedPort(1)->u.Port.Length != 2)
            ||  (ResourceList->FindTranslatedPort(2)->u.Port.Length != 4)
            ||  (countIRQ < 1)
            ||  (countDMA < 1)
            )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            detectedUart    = TRUE;
            detectedFmSynth = TRUE;
        }
        break;

    default:
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        break;
    }

    //
    // Build the resource list for the SB wave I/O.
    //
    *ResourceListWave = NULL;
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListWave,
                NULL,
                PagedPool,
                ResourceList,
                countDMA + countIRQ + 1
            );

        if (NT_SUCCESS(ntStatus))
        {
            ULONG i;

            //
            // Add the base address
            //
            ntStatus = (*ResourceListWave)->
                AddPortFromParent(ResourceList,0);

            //
            // Add the DMA channel(s).
            //
            if (NT_SUCCESS(ntStatus))
            {
                for (i = 0; i < countDMA; i++)
                {
                    ntStatus = (*ResourceListWave)->
                        AddDmaFromParent(ResourceList,i);
                }
            }

            //
            // Add the IRQ lines.
            //
            if (NT_SUCCESS(ntStatus))
            {
                for (i = 0; i < countIRQ; i++)
                {
                    SUCCEEDS((*ResourceListWave)->
                        AddInterruptFromParent(ResourceList,i));
                }
            }
        }
    }

    //
    // Build list of resources for wave table.
    //
    *ResourceListWaveTable = NULL;
    if (NT_SUCCESS(ntStatus) && detectedWaveTable)
    {
        //
        // TODO:  Assign wave table resources.
        //
    }

    //
    // Build list of resources for UART.
    //
    *ResourceListUart = NULL;
    if (NT_SUCCESS(ntStatus) && detectedUart)
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListUart,
                NULL,
                PagedPool,
                ResourceList,
                2
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = (*ResourceListUart)->
                AddPortFromParent(ResourceList,1);
            
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = (*ResourceListUart)->
                    AddInterruptFromParent(ResourceList,0);
            }
        }
    }

    //
    // Build list of resources for FM synth.
    //
    *ResourceListFmSynth = NULL;
    if (NT_SUCCESS(ntStatus) && detectedFmSynth)
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListFmSynth,
                NULL,
                PagedPool,
                ResourceList,
                1
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = (*ResourceListFmSynth)->
                AddPortFromParent(ResourceList,detectedUart ? 2 : 1);
        }
    }

    //
    // Build list of resources for the adapter.
    //
    *ResourceListAdapter = NULL;
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListAdapter,
                NULL,
                PagedPool,
                ResourceList,
                3
            );

        if (NT_SUCCESS(ntStatus))
        {
            //
            // The interrupt to share.
            //
            ntStatus = (*ResourceListAdapter)->
                AddInterruptFromParent(ResourceList,0);

            //
            // The base IO port (to tell who's interrupt it is)
            //
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = (*ResourceListAdapter)->
                    AddPortFromParent(ResourceList,0);
            }

            if (detectedUart && NT_SUCCESS(ntStatus))
            {
                //
                // The Uart port
                //
                ntStatus = (*ResourceListAdapter)->
                    AddPortFromParent(ResourceList,1);
            }
        }
    }

    //
    // Clean up if failure occurred.
    //
    if (! NT_SUCCESS(ntStatus))
    {
        if (*ResourceListWave)
        {
            (*ResourceListWave)->Release();
            *ResourceListWave = NULL;
        }
        if (*ResourceListWaveTable)
        {
            (*ResourceListWaveTable)->Release();
            *ResourceListWaveTable = NULL;
        }
        if (*ResourceListUart)
        {
            (*ResourceListUart)->Release();
            *ResourceListUart = NULL;
        }
        if (*ResourceListFmSynth)
        {
            (*ResourceListFmSynth)->Release();
            *ResourceListFmSynth = NULL;
        }
        if(*ResourceListAdapter)
        {
            (*ResourceListAdapter)->Release();
            *ResourceListAdapter = NULL;
        }
    }


    return ntStatus;
}

#ifdef DO_RESOURCE_FILTERING

/*****************************************************************************
 * AdapterDispatchPnp()
 *****************************************************************************
 * Supplying your PnP resource filtering needs.
 */
extern "C"
NTSTATUS
AdapterDispatchPnp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PIO_STACK_LOCATION pIrpStack =
        IoGetCurrentIrpStackLocation(pIrp);

    if( pIrpStack->MinorFunction == IRP_MN_FILTER_RESOURCE_REQUIREMENTS )
    {
        //
        // Do your resource requirements filtering here!!
        //
        _DbgPrintF(DEBUGLVL_VERBOSE,("[AdapterDispatchPnp] - IRP_MN_FILTER_RESOURCE_REQUIREMENTS"));

        // set the return status
        pIrp->IoStatus.Status = ntStatus;

    }

    //
    // Pass the IRPs on to PortCls
    //
    ntStatus = PcDispatchIrp( pDeviceObject,
                              pIrp );

    return ntStatus;
}

#endif


/*****************************************************************************
 * DeterminePlatform()
 *****************************************************************************
 * Figure out which WDM platform we are currently running on.
 * Note: the Port parameter could be WAVECYCLIC, WAVEPCI, DMUS or MIDI instead.
 *
 * TODO: Make this work on old DDK.
 *
 */
DWORD DeterminePlatform(PPORTTOPOLOGY Port)
{
    PAGED_CODE();
    ASSERT(Port);

    //
    // The generally accepted way of determining audio stack vintage:
    //
    PPORTCLSVERSION pPortClsVersion;
    PDRMPORT        pDrmPort;
    PPORTEVENTS     pPortEvents;
    DWORD           dwVersion;

    (void) Port->QueryInterface( IID_IPortClsVersion, (PVOID *) &pPortClsVersion);
    (void) Port->QueryInterface( IID_IDrmPort,        (PVOID *) &pDrmPort);
    (void) Port->QueryInterface( IID_IPortEvents,     (PVOID *) &pPortEvents);

    //
    //  Try for the exact release (Win98SE QFE3, WinME QFE, Win2KSP2, WinXP, or later).
    //
    if (pPortClsVersion)
    {
        dwVersion = pPortClsVersion->GetVersion();
        pPortClsVersion->Release();
    }
    //
    //  Try for WinME
    //
    else if (pDrmPort)
    {
        dwVersion = kVersionWinME;
        ASSERT(IoIsWdmVersionAvailable(0x01,0x05));
        //
        //  TODO: Look for registry entries that denote WinME QFEs
        //  HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\Updates\..., etc.
        //
    }
    //
    //  Try for Win2K family.
    //  Note that SP1 contains no real audio stack changes, 
    //  while SP2 contains non-PCM support and other fixes.
    //
    else if (IoIsWdmVersionAvailable(0x01,0x10))
    {
        dwVersion = kVersionWin2K;
        //
        //  TODO: Detect whether SP1 or earlier.
        //
    }
    //
    //  Must be Win98 or Win98SE.  
    //  IPortEvents was new in Win98SE.
    //
    else if (pPortEvents)
    {
        dwVersion = kVersionWin98SE; // or older QFEs
        //
        //  TODO: Look for registry entries that denote older Win98SE QFEs
        //  HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\Updates\W98.SE\UPD\269601, etc.
        //
    }
    //
    //  Process of elimination tells us it is Win98.
    //
    else
    {
        dwVersion = kVersionWin98;
        //
        //  TODO: Look for registry entries that denote older Win98 QFEs
        //  HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\Updates\..., etc.
        // 
    }
    // dwVersion contains enum with version of audio stack

    return dwVersion;
}

#pragma code_seg()

/*****************************************************************************
 * _purecall()
 *****************************************************************************
 * The C++ compiler loves me.
 * TODO: Figure out how to put this into portcls.sys
 */
int __cdecl
_purecall( void )
{
    ASSERT( !"Pure virutal function called" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\common.h ===
/*****************************************************************************
 * common.h - Common code used by all the sb16 miniports.
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 * A combination of random functions that are used by all the miniports.
 * This class also handles all the interrupts for the card.
 *
 */

/*
 * THIS IS A BIT BROKEN FOR NOW.  IT USES A SINGLETON OBJECT FOR WHICH THERE
 * IS ONLY ONE INSTANCE PER DRIVER.  THIS MEANS THERE CAN ONLY ONE CARD
 * SUPPORTED IN ANY GIVEN MACHINE.  THIS WILL BE FIXED.
 */

#ifndef _COMMON_H_
#define _COMMON_H_

#include "stdunk.h"
#include "portcls.h"
#include "DMusicKS.h"
#include "ksdebug.h"
#include "kcom.h"




/*****************************************************************************
 * Constants
 */

//
// Definitions for extended caps information.
//
#define STATIC_PID_MSSB16\
    0x1c2dfaf4, 0xad9b, 0x45b7, 0xa9, 0x6f, 0xf5, 0xdf, 0x7b, 0x7e, 0x46, 0x20
DEFINE_GUIDSTRUCT("1C2DFAF4-AD9B-45b7-A96F-F5DF7B7E4620", PID_MSSB16);
#define PID_MSSB16 DEFINE_GUIDNAMED(PID_MSSB16)

// This should match with the GUID in the inf. (ComponentId.GuidName)
#define STATIC_NAME_MSSB16\
    0x9a601f1c, 0x1b41, 0x4981, 0x99, 0x14, 0xac, 0x68, 0xa3, 0xa9, 0xb0, 0x7
DEFINE_GUIDSTRUCT("9A601F1C-1B41-4981-9914-AC68A3A9B007", NAME_MSSB16);
#define NAME_MSSB16 DEFINE_GUIDNAMED(NAME_MSSB16)

#define MSSB16_VERSION          0x1
#define MSSB16_REVISION         0x0

//
// DSP/DMA constants
// 
#define MAXLEN_DMA_BUFFER       0x4000

#define DSP_REG_CMSD0           0x00
#define DSP_REG_CMSR0           0x01
#define DSP_REG_CMSD1           0x02
#define DSP_REG_CMSR1           0x03
#define DSP_REG_MIXREG          0x04
#define DSP_REG_MIXDATA         0x05
#define DSP_REG_RESET           0x06
#define DSP_REG_FMD0            0x08
#define DSP_REG_FMR0            0x09
#define DSP_REG_READ            0x0A
#define DSP_REG_WRITE           0x0C
#define DSP_REG_DATAAVAIL       0x0E

#define DSP_REG_ACK8BIT         0x0E
#define DSP_REG_ACK16BIT        0x0F

//
// controller commands
//
#define DSP_CMD_WAVEWRPIO       0x10  // wave output (programmed I/O)
#define DSP_CMD_WAVEWR          0x14  // interrupt-driven 8 bit linear wave output
#define DSP_CMD_WAVEWRA         0x1C  // auto mode 8 bit out
#define DSP_CMD_WAVERD          0x24  // interrupt-driven 8 bit linear wave input
#define DSP_CMD_WAVERDA         0x2C  // auto mode 8 bit in
#define DSP_CMD_WAVEWRHS        0x90  // high speed mode write
#define DSP_CMD_WAVERDHS        0x98  // high speed mode read
#define DSP_CMD_SETSAMPRATE     0x40  // set sample rate
#define DSP_CMD_SETBLCKSIZE     0x48  // set block size
#define DSP_CMD_SPKRON          0xD1  // speaker on
#define DSP_CMD_SPKROFF         0xD3  // speaker off
#define DSP_CMD_SPKRSTATUS      0xD8  // speaker status (0=off, FF=on)
#define DSP_CMD_PAUSEDMA        0xD0  // pause DMA
#define DSP_CMD_CONTDMA         0xD4  // continue DMA
#define DSP_CMD_HALTAUTODMA     0xDA  // stop DMA autoinit mode
#define DSP_CMD_INVERTER        0xE0  // byte inverter
#define DSP_CMD_GETDSPVER       0xE1  // get dsp version
#define DSP_CMD_GENERATEINT     0xF2  // cause sndblst to generate an interrupt.

//
// SB-16 support
//
#define DSP_CMD_SETDACRATE      0x41  // set SBPro-16 DAC rate
#define DSP_CMD_SETADCRATE      0x42  // set SBPro-16 ADC rate
#define DSP_CMD_STARTDAC16      0xB6  // start 16-bit DAC
#define DSP_CMD_STARTADC16      0xBE  // start 16-bit ADC
#define DSP_CMD_STARTDAC8       0xC6  // start 8-bit DAC
#define DSP_CMD_STARTADC8       0xCE  // start 8-bit ADC
#define DSP_CMD_PAUSEDMA16      0xD5  // pause 16-bit DMA
#define DSP_CMD_CONTDMA16       0xD6  // continue 16-bit DMA
#define DSP_CMD_HALTAUTODMA16   0xD9  // halt 16-bit DMA

//
// Indexed mixer registers
//
#define DSP_MIX_DATARESETIDX    0x00

#define DSP_MIX_MASTERVOLIDX_L  0x00
#define DSP_MIX_MASTERVOLIDX_R  0x01
#define DSP_MIX_VOICEVOLIDX_L   0x02
#define DSP_MIX_VOICEVOLIDX_R   0x03
#define DSP_MIX_FMVOLIDX_L      0x04
#define DSP_MIX_FMVOLIDX_R      0x05
#define DSP_MIX_CDVOLIDX_L      0x06
#define DSP_MIX_CDVOLIDX_R      0x07
#define DSP_MIX_LINEVOLIDX_L    0x08
#define DSP_MIX_LINEVOLIDX_R    0x09
#define DSP_MIX_MICVOLIDX       0x0A
#define DSP_MIX_SPKRVOLIDX      0x0B
#define DSP_MIX_OUTMIXIDX       0x0C
#define DSP_MIX_ADCMIXIDX_L     0x0D
#define DSP_MIX_ADCMIXIDX_R     0x0E
#define DSP_MIX_INGAINIDX_L     0x0F
#define DSP_MIX_INGAINIDX_R     0x10
#define DSP_MIX_OUTGAINIDX_L    0x11
#define DSP_MIX_OUTGAINIDX_R    0x12
#define DSP_MIX_AGCIDX          0x13
#define DSP_MIX_TREBLEIDX_L     0x14
#define DSP_MIX_TREBLEIDX_R     0x15
#define DSP_MIX_BASSIDX_L       0x16
#define DSP_MIX_BASSIDX_R       0x17

#define DSP_MIX_BASEIDX         0x30
#define DSP_MIX_MAXREGS         (DSP_MIX_BASSIDX_R + 1)

#define DSP_MIX_IRQCONFIG       0x80
#define DSP_MIX_DMACONFIG       0x81

//
// Bit layout for DSP_MIX_OUTMIXIDX.
//
#define MIXBIT_MIC_LINEOUT      0
#define MIXBIT_CD_LINEOUT_R     1
#define MIXBIT_CD_LINEOUT_L     2
#define MIXBIT_LINEIN_LINEOUT_R 3
#define MIXBIT_LINEIN_LINEOUT_L 4

//
// Bit layout for DSP_MIX_ADCMIXIDX_L and DSP_MIX_ADCMIXIDX_R.
//
#define MIXBIT_MIC_WAVEIN       0
#define MIXBIT_CD_WAVEIN_R      1
#define MIXBIT_CD_WAVEIN_L      2
#define MIXBIT_LINEIN_WAVEIN_R  3
#define MIXBIT_LINEIN_WAVEIN_L  4
#define MIXBIT_SYNTH_WAVEIN_R   5
#define MIXBIT_SYNTH_WAVEIN_L   6

//
// Bit layout for MIXREG_MIC_AGC
//
#define MIXBIT_MIC_AGC          0

//
// MPU401 ports
//
#define MPU401_REG_STATUS   0x01    // Status register
#define MPU401_DRR          0x40    // Output ready (for command or data)
#define MPU401_DSR          0x80    // Input ready (for data)

#define MPU401_REG_DATA     0x00    // Data in
#define MPU401_REG_COMMAND  0x01    // Commands
#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mod

typedef struct
{
    PWCHAR   KeyName;
    BYTE     RegisterIndex;
    BYTE     RegisterSetting;
} MIXERSETTING,*PMIXERSETTING;

// {9B564276-A9B8-49a9-8456-3341CF46F9FC}
DEFINE_GUID(IID_IWaveMiniportSB16, 
0x9b564276, 0xa9b8, 0x49a9, 0x84, 0x56, 0x33, 0x41, 0xcf, 0x46, 0xf9, 0xfc);

/*****************************************************************************
 * IWaveMiniportSB16
 *****************************************************************************
 * Interface for wave miniport.
 */
DECLARE_INTERFACE_(IWaveMiniportSB16, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    STDMETHOD_(void,RestoreSampleRate)
    (   THIS
    )   PURE;
    STDMETHOD_(void,ServiceWaveISR)
    (   THIS
    )   PURE;
};

typedef IWaveMiniportSB16 *PWAVEMINIPORTSB16;


#ifdef EVENT_SUPPORT
// {885D00D1-E5E1-44c2-834B-64C4E1A79093}
DEFINE_GUID(IID_ITopoMiniportSB16, 
0x885d00d1, 0xe5e1, 0x44c2, 0x83, 0x4b, 0x64, 0xc4, 0xe1, 0xa7, 0x90, 0x93);

/*****************************************************************************
 * ITopoMiniportSB16
 *****************************************************************************
 * Interface for topology miniport.
 */
DECLARE_INTERFACE_(ITopoMiniportSB16, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    STDMETHOD_(void,ServiceEvent)
    (   THIS
    )   PURE;
};

typedef ITopoMiniportSB16 *PTOPOMINIPORTSB16;
#endif

DEFINE_GUID(IID_IAdapterCommon,
0x7eda2950, 0xbf9f, 0x11d0, 0x87, 0x1f, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

/*****************************************************************************
 * IAdapterCommon
 *****************************************************************************
 * Interface for adapter common object.
 */
DECLARE_INTERFACE_(IAdapterCommon,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PRESOURCELIST   ResourceList,
        IN      PDEVICE_OBJECT  DeviceObject
    )   PURE;
    
    STDMETHOD_(PINTERRUPTSYNC,GetInterruptSync)
    (   THIS
    )   PURE;

    STDMETHOD_(void,SetWaveMiniport)
    (   THIS_
        IN      PWAVEMINIPORTSB16   Miniport
    )   PURE;

    STDMETHOD_(BYTE,ReadController)
    (   THIS
    )   PURE;

    STDMETHOD_(BOOLEAN,WriteController)
    (   THIS_
        IN      BYTE    Value
    )   PURE;

    STDMETHOD_(NTSTATUS,ResetController)
    (   THIS
    )   PURE;

    STDMETHOD_(void,MixerRegWrite)
    (   THIS_
        IN      BYTE    Index,
        IN      BYTE    Value
    )   PURE;
    
    STDMETHOD_(BYTE,MixerRegRead)
    (   THIS_
        IN      BYTE    Index
    )   PURE;

    STDMETHOD_(void,MixerReset)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,RestoreMixerSettingsFromRegistry)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,SaveMixerSettingsToRegistry)
    (   THIS
    )   PURE;

#ifdef EVENT_SUPPORT
    STDMETHOD_(void,SetTopologyMiniport)
    (   THIS_
        IN      PTOPOMINIPORTSB16   Miniport
    )   PURE;
#endif
};

typedef IAdapterCommon *PADAPTERCOMMON;


/*****************************************************************************
 * NewAdapterCommon()
 *****************************************************************************
 * Create a new adapter common object.
 */
NTSTATUS
NewAdapterCommon
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * PropertyHandler_ComponentId
 *****************************************************************************
 * This is the propertyhandler for KSPROPERTY_GENERAL_COMPONENTID
 */
NTSTATUS
PropertyHandler_ComponentId
(
    IN      PPCPROPERTY_REQUEST PropertyRequest
);

/*****************************************************************************
 * AutomationFilter
 *****************************************************************************
 * This is the automation table for miniport filter.
 */
static
PCPROPERTY_ITEM PropertiesFilter[] =
{
  {
    &KSPROPSETID_General,
    KSPROPERTY_GENERAL_COMPONENTID,
    KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
    PropertyHandler_ComponentId
  },
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationFilter, PropertiesFilter);


#endif  //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\minwave.cpp ===
/*****************************************************************************
 * miniport.cpp - SB16 wave miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "minwave.h"

#define STR_MODULENAME "sb16wave: "



#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateMiniportWaveCyclicSB16()
 *****************************************************************************
 * Creates a cyclic wave miniport object for the SB16 adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportWaveCyclicSB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY_(CMiniportWaveCyclicSB16,Unknown,UnknownOuter,PoolType,PMINIPORTWAVECYCLIC);
}

/*****************************************************************************
 * MapUsingTable()
 *****************************************************************************
 * Performs a table-based mapping, returning the table index of the indicated
 * value.  -1 is returned if the value is not found.
 */
int
MapUsingTable
(
    IN      ULONG   Value,
    IN      PULONG  Map,
    IN      ULONG   MapSize
)
{
    PAGED_CODE();

    ASSERT(Map);

    for (int result = 0; result < int(MapSize); result++)
    {
        if (*Map++ == Value)
        {
            return result;
        }
    }

    return -1;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::ConfigureDevice()
 *****************************************************************************
 * Configures the hardware to use the indicated interrupt and DMA channels.
 * Returns FALSE iff the configuration is invalid.
 */
BOOLEAN
CMiniportWaveCyclicSB16::
ConfigureDevice
(
    IN      ULONG   Interrupt,
    IN      ULONG   Dma8Bit,
    IN      ULONG   Dma16Bit
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::ConfigureDevice]"));

    //
    // Tables mapping DMA and IRQ values to register bit offsets.
    //
    static ULONG validDma[] = { 0, 1, ULONG(-1), 3, ULONG(-1), 5, 6, 7 } ;
    static ULONG validIrq[] = { 9, 5, 7, 10 } ;

    //
    // Make sure we are using the right DMA channels.
    //
    if (Dma8Bit > 3)
    {
        return FALSE;
    }
    if (Dma16Bit < 5)
    {
        return FALSE;
    }

    //
    // Generate the register value for interrupts.
    //
    int bit = MapUsingTable(Interrupt,validIrq,SIZEOF_ARRAY(validIrq));
    if (bit == -1)
    {
        return FALSE;
    }

    BYTE irqConfig = BYTE(1 << bit);

    //
    // Generate the register value for DMA.
    //
    bit = MapUsingTable(Dma8Bit,validDma,SIZEOF_ARRAY(validDma));
    if (bit == -1)
    {
        return FALSE;
    }

    BYTE dmaConfig = BYTE(1 << bit);

    if (Dma16Bit != ULONG(-1))
    {
        bit = MapUsingTable(Dma16Bit,validDma,SIZEOF_ARRAY(validDma));
        if (bit == -1)
        {
            return FALSE;
        }

        dmaConfig |= BYTE(1 << bit);
    }

    //
    // Inform the hardware.
    //
    AdapterCommon->MixerRegWrite(DSP_MIX_IRQCONFIG,irqConfig);
    AdapterCommon->MixerRegWrite(DSP_MIX_DMACONFIG,dmaConfig);

    return TRUE;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::ProcessResources()
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 */
NTSTATUS
CMiniportWaveCyclicSB16::
ProcessResources
(
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(ResourceList);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::ProcessResources]"));

    ULONG   intNumber   = ULONG(-1);
    ULONG   dma8Bit     = ULONG(-1);
    ULONG   dma16Bit    = ULONG(-1);

    //
    // Get counts for the types of resources.
    //
    ULONG   countIO     = ResourceList->NumberOfPorts();
    ULONG   countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG   countDMA    = ResourceList->NumberOfDmas();

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting SB16 wave on IRQ 0x%X",
        ResourceList->FindUntranslatedInterrupt(0)->u.Interrupt.Level) );

    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting SB16 wave on Port 0x%X",
        ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart) );

    for (ULONG i = 0; i < countDMA; i++)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Starting SB16 wave on DMA 0x%X",
            ResourceList->FindUntranslatedDma(i)->u.Dma.Channel) );
    }
#endif

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ < 1)
        ||  (countDMA < 1)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("unknown configuraton; check your code!"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Instantiate a DMA channel for 8-bit transfers.
        //
        ntStatus =
            Port->NewSlaveDmaChannel
            (
                &DmaChannel8,
                NULL,
                ResourceList,
                0,
                MAXLEN_DMA_BUFFER,
                FALSE,      // DemandMode
                Compatible
            );

        //
        // Allocate the buffer for 8-bit transfers.
        //
        if (NT_SUCCESS(ntStatus))
        {
            ULONG  lDMABufferLength = MAXLEN_DMA_BUFFER;
            
            do {
              ntStatus = DmaChannel8->AllocateBuffer(lDMABufferLength,NULL);
              lDMABufferLength >>= 1;
            } while (!NT_SUCCESS(ntStatus) && (lDMABufferLength > (PAGE_SIZE / 2)));
        }

        if (NT_SUCCESS(ntStatus))
        {
            dma8Bit = ResourceList->FindUntranslatedDma(0)->u.Dma.Channel;

            if (countDMA > 1)
            {
                //
                // Instantiate a DMA channel for 16-bit transfers.
                //
                ntStatus =
                    Port->NewSlaveDmaChannel
                    (
                        &DmaChannel16,
                        NULL,
                        ResourceList,
                        1,
                        MAXLEN_DMA_BUFFER,
                        FALSE,
                        Compatible
                    );

                //
                // Allocate the buffer for 16-bit transfers.
                //
                if (NT_SUCCESS(ntStatus))
                {
                    ULONG  lDMABufferLength = MAXLEN_DMA_BUFFER;
                     
                    do {
                        ntStatus = DmaChannel16->AllocateBuffer(lDMABufferLength,NULL);
                        lDMABufferLength >>= 1;
                    } while (!NT_SUCCESS(ntStatus) && (lDMABufferLength > (PAGE_SIZE / 2)));
                }

                if (NT_SUCCESS(ntStatus))
                {
                    dma16Bit =
                        ResourceList->FindUntranslatedDma(1)->u.Dma.Channel;
                }
            }

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Get the interrupt number and configure the device.
                //
                intNumber =
                    ResourceList->
                        FindUntranslatedInterrupt(0)->u.Interrupt.Level;

                if  (!  ConfigureDevice(intNumber,dma8Bit,dma16Bit))
                {
                    _DbgPrintF(DEBUGLVL_TERSE,("ConfigureDevice Failure"));
                    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                }
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE,("NewSlaveDmaChannel 2 Failure %X", ntStatus ));
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewSlaveDmaChannel 1 Failure %X", ntStatus ));
        }
    }

    //
    // In case of failure object gets destroyed and cleans up.
    //

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::ValidateFormat()
 *****************************************************************************
 * Validates a wave format.
 */
NTSTATUS
CMiniportWaveCyclicSB16::
ValidateFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::ValidateFormat]"));

    NTSTATUS ntStatus;

    //
    // A WAVEFORMATEX structure should appear after the generic KSDATAFORMAT
    // if the GUIDs turn out as we expect.
    //
    PWAVEFORMATEX waveFormat = PWAVEFORMATEX(Format + 1);

    //
    // KSDATAFORMAT contains three GUIDs to support extensible format.  The
    // first two GUIDs identify the type of data.  The third indicates the
    // type of specifier used to indicate format specifics.  We are only
    // supporting PCM audio formats that use WAVEFORMATEX.
    //
    if  (   (Format->FormatSize >= sizeof(KSDATAFORMAT_WAVEFORMATEX))
        &&  IsEqualGUIDAligned(Format->MajorFormat,KSDATAFORMAT_TYPE_AUDIO)
        &&  IsEqualGUIDAligned(Format->SubFormat,KSDATAFORMAT_SUBTYPE_PCM)
        &&  IsEqualGUIDAligned(Format->Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        &&  (waveFormat->wFormatTag == WAVE_FORMAT_PCM)
        &&  ((waveFormat->wBitsPerSample == 8) ||  (waveFormat->wBitsPerSample == 16))
        &&  ((waveFormat->nChannels == 1) ||  (waveFormat->nChannels == 2))
        &&  ((waveFormat->nSamplesPerSec >= 5000) &&  (waveFormat->nSamplesPerSec <= 44100))
        )
    {
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
NonDelegatingQueryInterface
(
    IN      REFIID  Interface,
    OUT     PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::NonDelegatingQueryInterface]"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::~CMiniportWaveCyclicSB16()
 *****************************************************************************
 * Destructor.
 */
CMiniportWaveCyclicSB16::
~CMiniportWaveCyclicSB16
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::~CMiniportWaveCyclicSB16]"));

    if (AdapterCommon)
    {
        AdapterCommon->SetWaveMiniport (NULL);
        AdapterCommon->Release();
        AdapterCommon = NULL;
    }
    if (Port)
    {
        Port->Release();
        Port = NULL;
    }
    if (DmaChannel8)
    {
        DmaChannel8->Release();
        DmaChannel8 = NULL;
    }
    if (DmaChannel16)
    {
        DmaChannel16->Release();
        DmaChannel16 = NULL;
    }
    if (ServiceGroup)
    {
        ServiceGroup->Release();
        ServiceGroup = NULL;
    }
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
Init
(
    IN      PUNKNOWN        UnknownAdapter,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTWAVECYCLIC Port_
)
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(ResourceList);
    ASSERT(Port_);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::init]"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    Port = Port_;
    Port->AddRef();
    
    //
    // Initialize the member variables.
    //
    ServiceGroup = NULL;
    DmaChannel8 = NULL;
    DmaChannel16 = NULL;

    //
    // We want the IAdapterCommon interface on the adapter common object,
    // which is given to us as a IUnknown.  The QueryInterface call gives us
    // an AddRefed pointer to the interface we want.
    //
    NTSTATUS ntStatus =
        UnknownAdapter->QueryInterface
        (
            IID_IAdapterCommon,
            (PVOID *) &AdapterCommon
        );

    //
    // We need a service group for notifications.  We will bind all the
    // streams that are created to this single service group.  All interrupt
    // notifications ask for service on this group, so all streams will get
    // serviced.  The PcNewServiceGroup() call returns an AddRefed pointer.
    // The adapter needs a copy of the service group since it is doing the
    // ISR.
    //
    if (NT_SUCCESS(ntStatus))
    {
        KeInitializeMutex(&SampleRateSync,1);
        ntStatus = PcNewServiceGroup(&ServiceGroup,NULL);
    }

    if (NT_SUCCESS(ntStatus))
    {
        AdapterCommon->SetWaveMiniport ((PWAVEMINIPORTSB16)this);
        ntStatus = ProcessResources(ResourceList);
    }

    //
    // In case of failure object gets destroyed and destructor cleans up.
    //

    return ntStatus;
}

/*****************************************************************************
 * PinDataRangesStream
 *****************************************************************************
 * Structures indicating range of valid format values for streaming pins.
 */
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        2,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        16,     // Maximum number of bits per channel.
        5000,   // Minimum rate.
        44100   // Maximum rate.
    }
};

/*****************************************************************************
 * PinDataRangePointersStream
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for streaming pins.
 */
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR 
MiniportPins[] =
{
    // Wave In Streaming Pin (Capture)
    {
        1,1,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            (GUID *) &PINNAME_CAPTURE,
            &KSAUDFNAME_RECORDING_CONTROL,  // this name shows up as the recording panel name in SoundVol.
            0
        }
    },
    // Wave In Bridge Pin (Capture - From Topology)
    {
        0,0,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            (GUID *) &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
    // Wave Out Streaming Pin (Renderer)
    {
        1,1,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            (GUID *) &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
    // Wave Out Bridge Pin (Renderer)
    {
        0,0,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            (GUID *) &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    }
};

/*****************************************************************************
 * TopologyNodes
 *****************************************************************************
 * List of nodes.
 */
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * List of connections.
 */
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,  1,  0,                1 },    // Bridge in to ADC.
    { 0,              0,  PCFILTER_NODE,    0 },    // ADC to stream pin (capture).
    { PCFILTER_NODE,  2,  1,                1 },    // Stream in to DAC.
    { 1,              0,  PCFILTER_NODE,    3 }     // DAC to Bridge.
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 */
static
PCFILTER_DESCRIPTOR 
MiniportFilterDescriptor =
{
    0,                                  // Version
    &AutomationFilter,                  // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories  - use the default categories (audio, render, capture)
};

/*****************************************************************************
 * CMiniportWaveCyclicSB16::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::GetDescription]"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::DataRangeIntersection()
 *****************************************************************************
 * Tests a data range intersection.
 */
STDMETHODIMP 
CMiniportWaveCyclicSB16::
DataRangeIntersection
(   
    IN      ULONG           PinId,
    IN      PKSDATARANGE    ClientDataRange,
    IN      PKSDATARANGE    MyDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat,
    OUT     PULONG          ResultantFormatLength
)
{
    PAGED_CODE();

    BOOLEAN                         DigitalAudio;
    NTSTATUS                        Status;
    ULONG                           RequiredSize;
    ULONG                           SampleFrequency;
    USHORT                          BitsPerSample;
    
    //
    // Let's do the complete work here.
    //
    if (!IsEqualGUIDAligned(ClientDataRange->Specifier,KSDATAFORMAT_SPECIFIER_NONE)) 
    {
        //
        // The miniport did not resolve this format.  If the dataformat
        // is not PCM audio and requires a specifier, bail out.
        //
        if ( !IsEqualGUIDAligned(ClientDataRange->MajorFormat, KSDATAFORMAT_TYPE_AUDIO ) 
          || !IsEqualGUIDAligned(ClientDataRange->SubFormat, KSDATAFORMAT_SUBTYPE_PCM )) 
        {
            return STATUS_INVALID_PARAMETER;
        }
        DigitalAudio = TRUE;
        
        //
        // weird enough, the specifier here does not define the format of ClientDataRange
        // but the format that is expected to be returned in ResultantFormat.
        //
        if (IsEqualGUIDAligned(ClientDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND)) 
        {
            RequiredSize = sizeof(KSDATAFORMAT_DSOUND);
        } 
        else 
        {
            RequiredSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }            
    } 
    else 
    {
        DigitalAudio = FALSE;
        RequiredSize = sizeof(KSDATAFORMAT);
    }
            
    //
    // Validate return buffer size, if the request is only for the
    // size of the resultant structure, return it now.
    //
    if (!OutputBufferLength) 
    {
        *ResultantFormatLength = RequiredSize;
        return STATUS_BUFFER_OVERFLOW;
    } 
    else if (OutputBufferLength < RequiredSize) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    // There was a specifier ...
    if (DigitalAudio) 
    {     
        PKSDATARANGE_AUDIO  AudioRange;
        PWAVEFORMATEX       WaveFormatEx;
        
        AudioRange = (PKSDATARANGE_AUDIO) MyDataRange;
        
        // Fill the structure
        if (IsEqualGUIDAligned(ClientDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND)) 
        {
            PKSDATAFORMAT_DSOUND    DSoundFormat;
            
            DSoundFormat = (PKSDATAFORMAT_DSOUND) ResultantFormat;
            
            _DbgPrintF(DEBUGLVL_VERBOSE,("returning KSDATAFORMAT_DSOUND format intersection"));
            
            DSoundFormat->BufferDesc.Flags = 0 ;
            DSoundFormat->BufferDesc.Control = 0 ;
            DSoundFormat->DataFormat = *ClientDataRange;
            DSoundFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;
            DSoundFormat->DataFormat.FormatSize = RequiredSize;
            WaveFormatEx = &DSoundFormat->BufferDesc.WaveFormatEx;
            *ResultantFormatLength = RequiredSize;
        } 
        else 
        {
            PKSDATAFORMAT_WAVEFORMATEX  WaveFormat;
        
            WaveFormat = (PKSDATAFORMAT_WAVEFORMATEX) ResultantFormat;
            
            _DbgPrintF(DEBUGLVL_VERBOSE,("returning KSDATAFORMAT_WAVEFORMATEX format intersection") );
        
            WaveFormat->DataFormat = *ClientDataRange;
            WaveFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
            WaveFormat->DataFormat.FormatSize = RequiredSize;
            WaveFormatEx = &WaveFormat->WaveFormatEx;
            *ResultantFormatLength = RequiredSize;
        }
        
        //
        // Return a format that intersects the given audio range, 
        // using our maximum support as the "best" format.
        // 
        
        WaveFormatEx->wFormatTag = WAVE_FORMAT_PCM;
        WaveFormatEx->nChannels = 
            (USHORT) min( AudioRange->MaximumChannels, 
                          ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumChannels );
        
        //
        // Check if the pin is still free
        //
        if (!PinId)
        {
            if (AllocatedCapture)
            {
                return STATUS_NO_MATCH;
            }
        }
        else
        {
            if (AllocatedRender)
            {
                return STATUS_NO_MATCH;
            }
        }

        //
        // Check if one pin is in use -> use same sample frequency.
        //
        if (AllocatedCapture || AllocatedRender)
        {
            SampleFrequency = SamplingFrequency;
            if ( (SampleFrequency > ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumSampleFrequency) 
              || (SampleFrequency < ((PKSDATARANGE_AUDIO) ClientDataRange)->MinimumSampleFrequency))
            {
                return STATUS_NO_MATCH;
            }
        }
        else
        {
            SampleFrequency = 
                min( AudioRange->MaximumSampleFrequency,
                     ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumSampleFrequency );

        }

        WaveFormatEx->nSamplesPerSec = SampleFrequency;

        //
        // Check if one pin is in use -> use other bits per sample.
        //
        if (AllocatedCapture || AllocatedRender)
        {
            if (Allocated8Bit)
            {
                BitsPerSample = 16;
            }
            else
            {
                BitsPerSample = 8;
            }

            if ((BitsPerSample > ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumBitsPerSample) ||
                (BitsPerSample < ((PKSDATARANGE_AUDIO) ClientDataRange)->MinimumBitsPerSample))
            {
                return STATUS_NO_MATCH;
            }
        }
        else
        {
            BitsPerSample = 
                (USHORT) min( AudioRange->MaximumBitsPerSample,
                              ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumBitsPerSample );
        }

        WaveFormatEx->wBitsPerSample = BitsPerSample;
        WaveFormatEx->nBlockAlign = (WaveFormatEx->wBitsPerSample * WaveFormatEx->nChannels) / 8;
        WaveFormatEx->nAvgBytesPerSec = (WaveFormatEx->nSamplesPerSec * WaveFormatEx->nBlockAlign);
        WaveFormatEx->cbSize = 0;
        ((PKSDATAFORMAT) ResultantFormat)->SampleSize = WaveFormatEx->nBlockAlign;
        
        _DbgPrintF(DEBUGLVL_VERBOSE,("Channels = %d", WaveFormatEx->nChannels) );
        _DbgPrintF(DEBUGLVL_VERBOSE,("Samples/sec = %d", WaveFormatEx->nSamplesPerSec) );
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bits/sample = %d", WaveFormatEx->wBitsPerSample) );
        
    } 
    else 
    {    
        // There was no specifier. Return only the KSDATAFORMAT structure.
        //
        // Copy the data format structure.
        //
        _DbgPrintF(DEBUGLVL_VERBOSE,("returning default format intersection") );
            
        RtlCopyMemory(ResultantFormat, ClientDataRange, sizeof( KSDATAFORMAT ) );
        *ResultantFormatLength = sizeof( KSDATAFORMAT );
    }
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::NewStream()
 *****************************************************************************
 * Creates a new stream.  This function is called when a streaming pin is
 * created.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
NewStream
(
    OUT     PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN      PUNKNOWN                    OuterUnknown,
    IN      POOL_TYPE                   PoolType,
    IN      ULONG                       Channel,
    IN      BOOLEAN                     Capture,
    IN      PKSDATAFORMAT               DataFormat,
    OUT     PDMACHANNEL *               OutDmaChannel,
    OUT     PSERVICEGROUP *             OutServiceGroup
)
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::NewStream]"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure the hardware is not already in use.
    //
    if (Capture)
    {
        if (AllocatedCapture)
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    }
    else
    {
        if (AllocatedRender)
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    //
    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    if(NT_SUCCESS(ntStatus))
    {
        // if we're trying to start a full-duplex stream.
        if(AllocatedCapture || AllocatedRender)
        {
            // make sure the requested sampling rate is the
            // same as the currently running one...
            PWAVEFORMATEX waveFormat = PWAVEFORMATEX(DataFormat + 1);
            if( SamplingFrequency != waveFormat->nSamplesPerSec )
            {
                // Bad format....
                ntStatus = STATUS_INVALID_PARAMETER;
            }
        }
    }

    PDMACHANNELSLAVE    dmaChannel = NULL;
    PWAVEFORMATEX       waveFormat = PWAVEFORMATEX(DataFormat + 1);

    //
    // Get the required DMA channel if it's not already in use.
    //
    if (NT_SUCCESS(ntStatus))
    {
        if (waveFormat->wBitsPerSample == 8)
        {
            if (! Allocated8Bit)
            {
                dmaChannel = DmaChannel8;
            }
        }
        else
        {
            if (! Allocated16Bit)
            {
                dmaChannel = DmaChannel16;
            }
        }
    }

    if (! dmaChannel)
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        //
        // Instantiate a stream.
        //
        CMiniportWaveCyclicStreamSB16 *stream =
            new(PoolType) CMiniportWaveCyclicStreamSB16(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus =
                stream->Init
                (
                    this,
                    Channel,
                    Capture,
                    DataFormat,
                    dmaChannel
                );

            if (NT_SUCCESS(ntStatus))
            {
                if (Capture)
                {
                    AllocatedCapture = TRUE;
                }
                else
                {
                    AllocatedRender = TRUE;
                }

                if (waveFormat->wBitsPerSample == 8)
                {
                    Allocated8Bit = TRUE;
                }
                else
                {
                    Allocated16Bit = TRUE;
                }

                *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
                stream->AddRef();

#if OVERRIDE_DMA_CHANNEL
                *OutDmaChannel = PDMACHANNEL(stream);
                stream->AddRef();
#else // OVERRIDE_DMA_CHANNEL
                *OutDmaChannel = dmaChannel;
                dmaChannel->AddRef();
#endif // OVERRIDE_DMA_CHANNEL

                *OutServiceGroup = ServiceGroup;
                ServiceGroup->AddRef();

                //
                // The stream, the DMA channel, and the service group have
                // references now for the caller.  The caller expects these
                // references to be there.
                //
            }

            //
            // This is our private reference to the stream.  The caller has
            // its own, so we can release in any case.
            //
            stream->Release();
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclic::RestoreSampleRate()
 *****************************************************************************
 * Restores the sample rate.
 */
STDMETHODIMP_(void) CMiniportWaveCyclicSB16::RestoreSampleRate (void)
{
    if (AllocatedCapture)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Restoring Capture Sample Rate"));
        AdapterCommon->WriteController(DSP_CMD_SETADCRATE);
        AdapterCommon->WriteController((BYTE)(SamplingFrequency >> 8));
        AdapterCommon->WriteController((BYTE) SamplingFrequency);
    }
    if (AllocatedRender)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Restoring Render Sample Rate"));
        AdapterCommon->WriteController(DSP_CMD_SETDACRATE);
        AdapterCommon->WriteController((BYTE)(SamplingFrequency >> 8));
        AdapterCommon->WriteController((BYTE) SamplingFrequency);
    }
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
NonDelegatingQueryInterface
(
    IN      REFIID  Interface,
    OUT     PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::NonDelegatingQueryInterface]"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else 
    if (IsEqualGUIDAligned (Interface, IID_IDrmAudioStream))
    {
        *Object = (PVOID)(PDRMAUDIOSTREAM(this));
    }
#if OVERRIDE_DMA_CHANNEL
    else 
    if (IsEqualGUIDAligned (Interface, IID_IDmaChannel))
    {
        *Object = (PVOID)(PDMACHANNEL(this));
    }
#endif // OVERRIDE_DMA_CHANNEL
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::~CMiniportWaveCyclicStreamSB16()
 *****************************************************************************
 * Destructor.
 */
CMiniportWaveCyclicStreamSB16::
~CMiniportWaveCyclicStreamSB16
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::~CMiniportWaveCyclicStreamSB16]"));

    if (DmaChannel)
    {
        DmaChannel->Release();
    }

    if (Miniport)
    {
        //
        // Clear allocation flags in the miniport.
        //
        if (Capture)
        {
            Miniport->AllocatedCapture = FALSE;
        }
        else
        {
            Miniport->AllocatedRender = FALSE;
        }

        if (Format16Bit)
        {
            Miniport->Allocated16Bit = FALSE;
        }
        else
        {
            Miniport->Allocated8Bit = FALSE;
        }

        Miniport->AdapterCommon->SaveMixerSettingsToRegistry();
        Miniport->Release();
    }
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::Init()
 *****************************************************************************
 * Initializes a stream.
 */
NTSTATUS
CMiniportWaveCyclicStreamSB16::
Init
(
    IN      CMiniportWaveCyclicSB16 *   Miniport_,
    IN      ULONG                       Channel_,
    IN      BOOLEAN                     Capture_,
    IN      PKSDATAFORMAT               DataFormat,
    IN      PDMACHANNELSLAVE            DmaChannel_
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::Init]"));

    ASSERT(Miniport_);
    ASSERT(DataFormat);
    ASSERT(NT_SUCCESS(Miniport_->ValidateFormat(DataFormat)));
    ASSERT(DmaChannel_);

    PWAVEFORMATEX waveFormat = PWAVEFORMATEX(DataFormat + 1);

    //
    // We must add references because the caller will not do it for us.
    //
    Miniport = Miniport_;
    Miniport->AddRef();

    DmaChannel = DmaChannel_;
    DmaChannel->AddRef();

    Channel         = Channel_;
    Capture         = Capture_;
    FormatStereo    = (waveFormat->nChannels == 2);
    Format16Bit     = (waveFormat->wBitsPerSample == 16);
    State           = KSSTATE_STOP;

    RestoreInputMixer = FALSE;

    KeWaitForSingleObject
    (
        &Miniport->SampleRateSync,
        Executive,
        KernelMode,
        FALSE,
        NULL
    );
    Miniport->SamplingFrequency = waveFormat->nSamplesPerSec;
    KeReleaseMutex(&Miniport->SampleRateSync,FALSE);
    
    return SetFormat( DataFormat );
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetNotificationFreq()
 *****************************************************************************
 * Sets the notification frequency.
 */
STDMETHODIMP_(ULONG)
CMiniportWaveCyclicStreamSB16::
SetNotificationFreq
(
    IN      ULONG   Interval,
    OUT     PULONG  FramingSize    
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::SetNotificationFreq]"));

    Miniport->NotificationInterval = Interval;
    //
    //  This value needs to be sample block aligned for DMA to work correctly.
    //
    *FramingSize = 
        (1 << (FormatStereo + Format16Bit)) * 
            (Miniport->SamplingFrequency * Interval / 1000);

    return Miniport->NotificationInterval;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetFormat()
 *****************************************************************************
 * Sets the wave format.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
SetFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::SetFormat]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if(State != KSSTATE_RUN)
    {
        ntStatus = Miniport->ValidateFormat(Format);
    
        PWAVEFORMATEX waveFormat = PWAVEFORMATEX(Format + 1);

        KeWaitForSingleObject
        (
            &Miniport->SampleRateSync,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );
    
        // check for full-duplex stuff
        if( NT_SUCCESS(ntStatus)
            && Miniport->AllocatedCapture
            && Miniport->AllocatedRender
        )
        {
            // no new formats.... bad...
            if( Miniport->SamplingFrequency != waveFormat->nSamplesPerSec )
            {
                // Bad format....
                ntStatus = STATUS_INVALID_PARAMETER;
            }
        }
    
        // TODO:  Validate sample size.
    
        if (NT_SUCCESS(ntStatus))
        {
            Miniport->SamplingFrequency = waveFormat->nSamplesPerSec;
    
            BYTE command =
                (   Capture
                ?   DSP_CMD_SETADCRATE
                :   DSP_CMD_SETDACRATE
                );
    
            Miniport->AdapterCommon->WriteController
            (
                command
            );
    
            Miniport->AdapterCommon->WriteController
            (
                (BYTE)(waveFormat->nSamplesPerSec >> 8)
            );
    
            Miniport->AdapterCommon->WriteController
            (
                (BYTE) waveFormat->nSamplesPerSec
            );

            _DbgPrintF(DEBUGLVL_VERBOSE,("  SampleRate: %d",waveFormat->nSamplesPerSec));
        }

        KeReleaseMutex(&Miniport->SampleRateSync,FALSE);
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetState()
 *****************************************************************************
 * Sets the state of the channel.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::SetState %x]", NewState));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // The acquire state is not distinguishable from the pause state for our
    // purposes.
    //
    if (NewState == KSSTATE_ACQUIRE)
    {
        NewState = KSSTATE_PAUSE;
    }

    if (State != NewState)
    {
        switch (NewState)
        {
        case KSSTATE_PAUSE:
            if (State == KSSTATE_RUN)
            {
                if (Capture)
                {
                    // restore if previously setup for mono recording
                    // (this should really be done via the topology miniport)
                    if(RestoreInputMixer)
                    {
                        Miniport->AdapterCommon->MixerRegWrite( DSP_MIX_ADCMIXIDX_L,
                                                                InputMixerLeft );
                        RestoreInputMixer = FALSE;
                    }
                }
                // TODO:  Wait for DMA to complete

                if (Format16Bit)
                {
                    Miniport->AdapterCommon->WriteController(DSP_CMD_HALTAUTODMA16);
                    // TODO:  wait...
                    Miniport->AdapterCommon->WriteController(DSP_CMD_PAUSEDMA16);
                }
                else
                {
                    Miniport->AdapterCommon->WriteController(DSP_CMD_HALTAUTODMA);
                    // TODO:  wait...
                    Miniport->AdapterCommon->WriteController(DSP_CMD_PAUSEDMA);
                }

                Miniport->AdapterCommon->WriteController(DSP_CMD_SPKROFF);

                DmaChannel->Stop();
            }
            break;

        case KSSTATE_RUN:
            {
                BYTE mode;

                if (Capture)
                {
                    // setup for mono recording
                    // (this should really be done via the topology miniport)
                    if(! FormatStereo)
                    {
                        InputMixerLeft  = Miniport->AdapterCommon->MixerRegRead( DSP_MIX_ADCMIXIDX_L );
                        UCHAR InputMixerRight = Miniport->AdapterCommon->MixerRegRead( DSP_MIX_ADCMIXIDX_R );
                        
                        UCHAR TempMixerValue = InputMixerLeft | (InputMixerRight & 0x2A);

                        Miniport->AdapterCommon->MixerRegWrite( DSP_MIX_ADCMIXIDX_L,
                                                                TempMixerValue );
                        
                        RestoreInputMixer = TRUE;
                    }

                    //
                    // Turn on capture.
                    //
                    Miniport->AdapterCommon->WriteController(DSP_CMD_SPKROFF);

                    if (Format16Bit)
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTADC16);
                        mode = 0x10;
                    }
                    else
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTADC8);
                        mode = 0x00;
                    }
                }
                else
                {
                    Miniport->AdapterCommon->WriteController(DSP_CMD_SPKRON);

                    if (Format16Bit)
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTDAC16);
                        mode = 0x10;
                    }
                    else
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTDAC8);
                        mode = 0x00;
                    }
                }

                if (FormatStereo)
                {
                    mode |= 0x20;
                }

                //
                // Start DMA.
                //
                DmaChannel->Start(DmaChannel->BufferSize(),!Capture);

                Miniport->AdapterCommon->WriteController(mode) ;

                //
                // Calculate sample count for interrupts.
                //
                ULONG bufferSizeInFrames = DmaChannel->BufferSize();
                if( Format16Bit )
                {
                    bufferSizeInFrames /= 2;
                }
                if( FormatStereo )
                {
                    bufferSizeInFrames /= 2;
                }

                ULONG frameCount =
                    ((Miniport->SamplingFrequency * Miniport->NotificationInterval) / 1000);

                if (frameCount > bufferSizeInFrames)
                {
                    frameCount = bufferSizeInFrames;
                }

                frameCount--;

                _DbgPrintF( DEBUGLVL_VERBOSE, ("Run. Setting frame count to %X",frameCount));
                Miniport->AdapterCommon->WriteController((BYTE) frameCount) ;
                Miniport->AdapterCommon->WriteController((BYTE) (frameCount >> 8));
            }
            break;

        case KSSTATE_STOP:
            break;
        }

        State = NewState;
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetContentId
 *****************************************************************************
 * This routine gets called by drmk.sys to pass the content to the driver.
 * The driver has to enforce the rights passed.
 */
STDMETHODIMP_(NTSTATUS) 
CMiniportWaveCyclicStreamSB16::SetContentId
(
    IN  ULONG       contentId,
    IN  PCDRMRIGHTS drmRights
)
{
    PAGED_CODE ();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::SetContentId]"));

    //
    // if (drmRights.CopyProtect==TRUE)
    // Mute waveout capture. 
    // Sb16 does not have waveout capture path. Therefore
    // the sample driver is not using this attribute.
    // Also if the driver is writing data to other types of media (disk, etc), it
    // should stop doing it.
    //  (MSVAD\simple stops writing to disk).
    //  (AC97 disables waveout capture)
    //
    // if (drmRights.DigitalOutputDisable == TRUE)
    // Mute S/PDIF out. 
    // If the device cannot mute S/PDIF out properly, it should return an error 
    // code.
    // Sb16 does not have S/PDIF out. Therefore the sample driver is not using
    // this attribute.
    // 

    //
    // To learn more about enforcing rights, please look at AC97 sample.
    // 
    // To learn more about managing multiple streams, please look at MSVAD.
    //
    
    return STATUS_SUCCESS;
}

#pragma code_seg()

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::GetPosition()
 *****************************************************************************
 * Gets the current position.  May be called at dispatch level.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
GetPosition
(
    OUT     PULONG  Position
)
{
    ASSERT(Position);

    ULONG transferCount = DmaChannel->TransferCount();

    if (DmaChannel && transferCount)
    {
        *Position = DmaChannel->ReadCounter();

        ASSERT(*Position <= transferCount);

        if (*Position != 0)
        {
            *Position = transferCount - *Position;
        }
    }
    else
    {
        *Position = 0;
    }

   return STATUS_SUCCESS;
}

STDMETHODIMP
CMiniportWaveCyclicStreamSB16::NormalizePhysicalPosition(
    IN OUT PLONGLONG PhysicalPosition
)

/*++

Routine Description:
    Given a physical position based on the actual number of bytes transferred,
    this function converts the position to a time-based value of 100ns units.

Arguments:
    IN OUT PLONGLONG PhysicalPosition -
        value to convert.

Return:
    STATUS_SUCCESS or an appropriate error code.

--*/

{                           
    *PhysicalPosition =
            (_100NS_UNITS_PER_SECOND / 
                (1 << (FormatStereo + Format16Bit)) * *PhysicalPosition) / 
                    Miniport->SamplingFrequency;
    return STATUS_SUCCESS;
}
    
/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::Silence()
 *****************************************************************************
 * Fills a buffer with silence.
 */
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamSB16::
Silence
(
    IN      PVOID   Buffer,
    IN      ULONG   ByteCount
)
{
    RtlFillMemory(Buffer,ByteCount,Format16Bit ? 0 : 0x80);
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::ServiceWaveISR()
 *****************************************************************************
 * Service the ISR - notify the port.
 */
STDMETHODIMP_(void) CMiniportWaveCyclicSB16::ServiceWaveISR (void)
{
    if (Port && ServiceGroup)
    {
        Port->Notify (ServiceGroup);
    }
}


#if OVERRIDE_DMA_CHANNEL

#pragma code_seg("PAGE")

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::AllocateBuffer()
 *****************************************************************************
 * Allocate a buffer for this DMA channel.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::AllocateBuffer
(   
    IN      ULONG               BufferSize,
    IN      PPHYSICAL_ADDRESS   PhysicalAddressConstraint   OPTIONAL
)
{
    PAGED_CODE();

    return DmaChannel->AllocateBuffer(BufferSize,PhysicalAddressConstraint);
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::FreeBuffer()
 *****************************************************************************
 * Free the buffer for this DMA channel.
 */
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamSB16::FreeBuffer(void)
{
    PAGED_CODE();

    DmaChannel->FreeBuffer();
}


#pragma code_seg()

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::TransferCount()
 *****************************************************************************
 * Return the amount of data to be transfered via DMA.
 */
STDMETHODIMP_(ULONG) 
CMiniportWaveCyclicStreamSB16::TransferCount(void)
{
    return DmaChannel->TransferCount();
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::MaximumBufferSize()
 *****************************************************************************
 * Return the maximum size that can be allocated to this DMA buffer.
 */
STDMETHODIMP_(ULONG) 
CMiniportWaveCyclicStreamSB16::MaximumBufferSize(void)
{
    return DmaChannel->MaximumBufferSize();
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::AllocatedBufferSize()
 *****************************************************************************
 * Return the original size allocated to this DMA buffer -- the maximum value
 * that can be sent to SetBufferSize().
 */
STDMETHODIMP_(ULONG) 
CMiniportWaveCyclicStreamSB16::AllocatedBufferSize(void)
{
    return DmaChannel->AllocatedBufferSize();
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::BufferSize()
 *****************************************************************************
 * Return the current size of the DMA buffer.
 */
STDMETHODIMP_(ULONG) 
CMiniportWaveCyclicStreamSB16::BufferSize(void)
{  
    return DmaChannel->BufferSize();
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetBufferSize()
 *****************************************************************************
 * Change the size of the DMA buffer.  This cannot exceed the initial 
 * buffer size returned by AllocatedBufferSize().
 */
STDMETHODIMP_(void) 
CMiniportWaveCyclicStreamSB16::SetBufferSize(IN ULONG BufferSize)
{
    DmaChannel->SetBufferSize(BufferSize);
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SystemAddress()
 *****************************************************************************
 * Return the virtual address of this DMA buffer.
 */
STDMETHODIMP_(PVOID) 
CMiniportWaveCyclicStreamSB16::SystemAddress(void)
{
    return DmaChannel->SystemAddress();
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::PhysicalAddress()
 *****************************************************************************
 * Return the actual physical address of this DMA buffer.
 */
STDMETHODIMP_(PHYSICAL_ADDRESS) 
CMiniportWaveCyclicStreamSB16::PhysicalAddress(void)
{
   return DmaChannel->PhysicalAddress();
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::GetAdapterObject()
 *****************************************************************************
 * Return the DMA adapter object (defined in wdm.h).
 */
STDMETHODIMP_(PADAPTER_OBJECT) 
CMiniportWaveCyclicStreamSB16::GetAdapterObject(void)
{
   return DmaChannel->GetAdapterObject();
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::CopyTo()
 *****************************************************************************
 * Copy data into the DMA buffer.  If you need to modify data on render
 * (playback), modify this routine to taste.
 */
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamSB16::CopyTo
(   
    IN      PVOID   Destination,
    IN      PVOID   Source,
    IN      ULONG   ByteCount
)
{
   DmaChannel->CopyTo(Destination, Source, ByteCount);
}


/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::CopyFrom()
 *****************************************************************************
 * Copy data out of the DMA buffer.  If you need to modify data on capture 
 * (recording), modify this routine to taste.
 */
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamSB16::CopyFrom
(
    IN      PVOID   Destination,
    IN      PVOID   Source,
    IN      ULONG   ByteCount
)
{
   DmaChannel->CopyFrom(Destination, Source, ByteCount);
}

#endif // OVERRIDE_DMA_CHANNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\mintopo.cpp ===
/*****************************************************************************
 * mintopo.cpp - SB16 topology miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation. All Rights Reserved.
 */

#include "limits.h"
#include "mintopo.h"

#define STR_MODULENAME "sb16topo: "

#define CHAN_LEFT       0
#define CHAN_RIGHT      1
#define CHAN_MASTER     (-1)


#pragma code_seg("PAGE")


/*****************************************************************************
 * CreateMiniportTopologySB16()
 *****************************************************************************
 * Creates a topology miniport object for the SB16 adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportTopologySB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY_(CMiniportTopologySB16,Unknown,UnknownOuter,PoolType,PMINIPORTTOPOLOGY);
}

/*****************************************************************************
 * CMiniportTopologySB16::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportTopologySB16::
NonDelegatingQueryInterface
(
    IN      REFIID  Interface,
    OUT     PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::NonDelegatingQueryInterface]"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTTOPOLOGY(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportTopologySB16::~CMiniportTopologySB16()
 *****************************************************************************
 * Destructor.
 */
CMiniportTopologySB16::
~CMiniportTopologySB16
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::~CMiniportTopologySB16]"));

    if (AdapterCommon)
    {
#ifdef EVENT_SUPPORT
        AdapterCommon->SetTopologyMiniport (NULL);
#endif
        AdapterCommon->SaveMixerSettingsToRegistry();
        AdapterCommon->Release();
    }
#ifdef EVENT_SUPPORT
    if (PortEvents)
    {
        PortEvents->Release ();
        PortEvents = NULL;
    }
#endif
}

/*****************************************************************************
 * CMiniportTopologySB16::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP
CMiniportTopologySB16::
Init
(
    IN      PUNKNOWN        UnknownAdapter,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTTOPOLOGY   Port
)
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(Port);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::Init]"));

    NTSTATUS ntStatus =
        UnknownAdapter->QueryInterface
        (
            IID_IAdapterCommon,
            (PVOID *) &AdapterCommon
        );

    if (NT_SUCCESS(ntStatus))
    {
#ifdef EVENT_SUPPORT
        //
        // Get the port event interface.
        //
        NTSTATUS ntStatus2 = Port->QueryInterface (IID_IPortEvents, (PVOID *)&PortEvents);
        if (NT_SUCCESS(ntStatus2))
        {
            //
            // We need to notify AdapterCommon of the miniport interface.
            // AdapterCommon needs this in his ISR to fire the event.
            //
            AdapterCommon->SetTopologyMiniport ((PTOPOMINIPORTSB16)this);
        
            //
            // Enable external volume control interrupt.
            //
            BYTE bIntrMask = AdapterCommon->MixerRegRead (0x83);
            bIntrMask |= 0x10;
            AdapterCommon->MixerRegWrite (0x83, bIntrMask);
         }
#endif    

        AdapterCommon->MixerReset();
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologySB16::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP
CMiniportTopologySB16::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::GetDescription]"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PropertyHandler_OnOff()
 *****************************************************************************
 * Accesses a KSAUDIO_ONOFF value property.
 */
static
NTSTATUS
PropertyHandler_OnOff
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PropertyHandler_OnOff]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) ((PMINIPORTTOPOLOGY) PropertyRequest->MajorTarget);

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    BYTE            data;
    LONG            channel;

    // validate node
    if (PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // validate and get the output parameter
                if (PropertyRequest->ValueSize >= sizeof(BOOL))
                {
                    PBOOL OnOff = PBOOL(PropertyRequest->Value);
    
                    // switch on node id
                    switch(PropertyRequest->Node)
                    {
                        case MIC_AGC:   // Microphone AGC Control (mono)
                            // check if AGC property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_AGC ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                data = that->ReadBitsFromMixer( DSP_MIX_AGCIDX,
                                                          1,
                                                          MIXBIT_MIC_AGC );
                                *OnOff = data ? FALSE : TRUE;
                                PropertyRequest->ValueSize = sizeof(BOOL);
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
    
                        case MIC_LINEOUT_MUTE:  // Microphone Lineout Mute Control (mono)
                            // check if MUTE property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_MUTE ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                data = that->ReadBitsFromMixer( DSP_MIX_OUTMIXIDX,
                                                          1,
                                                          MIXBIT_MIC_LINEOUT );
                                *OnOff = data ? FALSE : TRUE;
                                PropertyRequest->ValueSize = sizeof(BOOL);
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
                    }
                }
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));
                
                // validate and get the input parameter
                if (PropertyRequest->ValueSize == sizeof(BOOL))
                {
                    BYTE value = *(PBOOL(PropertyRequest->Value)) ? 0 : 1;
    
                    // switch on the node id
                    switch(PropertyRequest->Node)
                    {
                        case MIC_AGC:   // Microphone AGC Control (mono)
                            // check if AGC property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_AGC ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                that->WriteBitsToMixer( DSP_MIX_AGCIDX,
                                                  1,
                                                  MIXBIT_MIC_AGC,
                                                  value );
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
    
                        case MIC_LINEOUT_MUTE:  // Microphone Lineout Mute Control (mono)
                            // check if MUTE property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_MUTE ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                that->WriteBitsToMixer( DSP_MIX_OUTMIXIDX,
                                                  1,
                                                  MIXBIT_MIC_LINEOUT,
                                                  value );
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
                    }
                }
            }
        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if ( ( (PropertyRequest->Node == MIC_AGC) && (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_AGC) ) ||
                 ( (PropertyRequest->Node == MIC_LINEOUT_MUTE) && (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_MUTE) ) )
            {
                if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
                {
                    // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                    PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

                    PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                                  KSPROPERTY_TYPE_GET |
                                                  KSPROPERTY_TYPE_SET;
                    PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                    PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                    PropDesc->PropTypeSet.Id    = VT_BOOL;
                    PropDesc->PropTypeSet.Flags = 0;
                    PropDesc->MembersListCount  = 0;
                    PropDesc->Reserved          = 0;

                    // set the return value size
                    PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                    ntStatus = STATUS_SUCCESS;
                } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
                {
                    // if return buffer can hold a ULONG, return the access flags
                    PULONG AccessFlags = PULONG(PropertyRequest->Value);
            
                    *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                   KSPROPERTY_TYPE_GET |
                                   KSPROPERTY_TYPE_SET;
            
                    // set the return value size
                    PropertyRequest->ValueSize = sizeof(ULONG);
                    ntStatus = STATUS_SUCCESS;                    
                }
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * BasicSupportHandler()
 *****************************************************************************
 * Assists in BASICSUPPORT accesses on level properties
 */
static
NTSTATUS
BasicSupportHandler
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[BasicSupportHandler]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
    {
        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

        PropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                KSPROPERTY_TYPE_GET |
                                KSPROPERTY_TYPE_SET;
        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG);
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = VT_I4;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 1;
        PropDesc->Reserved          = 0;

        // if return buffer cn also hold a range description, return it too
        if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG)))
        {
            // fill in the members header
            PKSPROPERTY_MEMBERSHEADER Members = PKSPROPERTY_MEMBERSHEADER(PropDesc + 1);

            Members->MembersFlags   = KSPROPERTY_MEMBER_STEPPEDRANGES;
            Members->MembersSize    = sizeof(KSPROPERTY_STEPPING_LONG);
            Members->MembersCount   = 1;
            Members->Flags          = 0;

            // fill in the stepped range
            PKSPROPERTY_STEPPING_LONG Range = PKSPROPERTY_STEPPING_LONG(Members + 1);

            switch(PropertyRequest->Node)
            {
                case WAVEOUT_VOLUME:
                case SYNTH_VOLUME:
                case CD_VOLUME:
                case LINEIN_VOLUME:
                case MIC_VOLUME:
                case LINEOUT_VOL:
                    Range->Bounds.SignedMaximum = 0;            // 0   (dB) * 0x10000
                    Range->Bounds.SignedMinimum = 0xFFC20000;   // -62 (dB) * 0x10000
                    Range->SteppingDelta        = 0x20000;      // 2   (dB) * 0x10000
                    break;

                case LINEOUT_GAIN:
                case WAVEIN_GAIN:
                    Range->Bounds.SignedMaximum = 0x120000;     // 18  (dB) * 0x10000
                    Range->Bounds.SignedMinimum = 0;            // 0   (dB) * 0x10000
                    Range->SteppingDelta        = 0x60000;      // 6   (dB) * 0x10000
                    break;

                case LINEOUT_BASS:
                case LINEOUT_TREBLE:
                    Range->Bounds.SignedMaximum = 0xE0000;      // 14  (dB) * 0x10000
                    Range->Bounds.SignedMinimum = 0xFFF20000;   // -14 (dB) * 0x10000
                    Range->SteppingDelta        = 0x20000;      // 2   (dB) * 0x10000
                    break;

            }
            Range->Reserved         = 0;

            _DbgPrintF(DEBUGLVL_BLAB, ("---Node: %d  Max: 0x%X  Min: 0x%X  Step: 0x%X",PropertyRequest->Node,
                                                                                       Range->Bounds.SignedMaximum,
                                                                                       Range->Bounds.SignedMinimum,
                                                                                       Range->SteppingDelta));

            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION) +
                                         sizeof(KSPROPERTY_MEMBERSHEADER) +
                                         sizeof(KSPROPERTY_STEPPING_LONG);
        } else
        {
            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        }
        ntStatus = STATUS_SUCCESS;

    } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        PULONG AccessFlags = PULONG(PropertyRequest->Value);

        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                       KSPROPERTY_TYPE_GET |
                       KSPROPERTY_TYPE_SET;

        // set the return value size
        PropertyRequest->ValueSize = sizeof(ULONG);
        ntStatus = STATUS_SUCCESS;

    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_Level()
 *****************************************************************************
 * Accesses a KSAUDIO_LEVEL property.
 */
static
NTSTATUS
PropertyHandler_Level
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PropertyHandler_Level]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) ((PMINIPORTTOPOLOGY) PropertyRequest->MajorTarget);

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    ULONG           count;
    LONG            channel;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left (0) or right (1) channels
                if ( (channel == CHAN_LEFT) || (channel == CHAN_RIGHT) )
                {
                    // validate and get the output parameter
                    if (PropertyRequest->ValueSize >= sizeof(LONG))
                    {
                        PLONG Level = (PLONG)PropertyRequest->Value;

                        // switch on node if
                        switch(PropertyRequest->Node)
                        {
                            case WAVEOUT_VOLUME:
                            case SYNTH_VOLUME:
                            case CD_VOLUME:
                            case LINEIN_VOLUME:
                            case MIC_VOLUME:
                            case LINEOUT_VOL:
                                // check if volume property request
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {
                                    // bail out if a right channel request on the mono mic volume
                                    if( (PropertyRequest->Node == MIC_VOLUME) && (channel != CHAN_LEFT) )
                                    {
                                        break;
                                    }
                                    *Level = ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel ];

#ifdef EVENT_SUPPORT
                                    //
                                    // see if there is a volume changed, update if neccessary.
                                    //
                                    BYTE data = that->ReadBitsFromMixer (
                                            BYTE(AccessParams[PropertyRequest->Node].BaseRegister
                                                 +channel+DSP_MIX_BASEIDX),
                                            5, 3);

                                    //
                                    // Convert the dB value into a register value. No boundary check.
                                    // Register is 0 - 31 representing -62dB - 0dB.
                                    //
                                    if (data != ((*Level >> 17) + 31))
                                    {
                                        //
                                        // Convert the register into dB value.
                                        // Register is 0 - 31 representing -62dB - 0dB.
                                        //
                                        *Level = (data - 31) << 17;
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel] = *Level;
                                    }
#endif

                                    PropertyRequest->ValueSize = sizeof(LONG);
                                    ntStatus = STATUS_SUCCESS;
                                }
                                break;
        
                            case LINEOUT_GAIN:
                            case WAVEIN_GAIN:
                                // check if volume property request
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {
                                    *Level = ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel ];
                                    PropertyRequest->ValueSize = sizeof(LONG);
                                    ntStatus = STATUS_SUCCESS;
                                }
                                break;

                            case LINEOUT_BASS:
                            case LINEOUT_TREBLE:
                                if( ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_BASS) &&
                                      (PropertyRequest->Node == LINEOUT_BASS) ) ||
                                    ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_TREBLE) &&
                                      (PropertyRequest->Node == LINEOUT_TREBLE) ) )
                                {
                                    *Level = ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel ];
                                    PropertyRequest->ValueSize = sizeof(LONG);
                                    ntStatus = STATUS_SUCCESS;
                                }
                                break;
                        }
                    }
                }
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support set requests on either mono/left (0), right (1), or master (-1) channels
                if ( (channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
                {
                    // validate and get the input parameter
                    if (PropertyRequest->ValueSize == sizeof(LONG))
                    {
                        PLONG Level = (PLONG)PropertyRequest->Value;

                        // switch on the node id
                        switch(PropertyRequest->Node)
                        {
                            case WAVEOUT_VOLUME:
                            case SYNTH_VOLUME:
                            case CD_VOLUME:
                            case LINEIN_VOLUME:
                            case MIC_VOLUME:
                            case LINEOUT_VOL:
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {
                                    // convert the level to register bits
                                    if(*Level <= (-62 << 16))
                                    {
                                        count = 0;
                                    } else if(*Level >= 0)
                                    {
                                        count = 0x1F;
                                    } else
                                    {
                                        count = ((*Level >> 17) + 31) & 0x1F;
                                    }

                                    // set right channel if channel requested is right or master
                                    // and node is not mic volume (mono)
                                    if ( ( (channel == CHAN_RIGHT) || (channel == CHAN_MASTER) ) &&
                                         ( PropertyRequest->Node != MIC_VOLUME ) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_RIGHT ] = *Level;

                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister+1,
                                                          5,
                                                          3,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                    // set the left channel if channel requested is left or master
                                    if ( (channel == CHAN_LEFT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_LEFT ] = *Level;
                                        
                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister,
                                                          5,
                                                          3,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                }
                                break;
        
                            case LINEOUT_GAIN:
                            case WAVEIN_GAIN:
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {                                                                        
                                    // determine register bits
                                    if(*Level >= (18 << 16))
                                    {
                                        count = 0x3;
                                    } else if(*Level <= 0)
                                    {
                                        count = 0;
                                    } else
                                    {
                                        count = (*Level >> 17) / 3;
                                    }
    
                                    // set right channel if channel requested is right or master
                                    if ( (channel == CHAN_RIGHT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_RIGHT ] = *Level;

                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister+1,
                                                          2,
                                                          6,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                    // set the left channel if channel requested is left or master
                                    if ( (channel == CHAN_LEFT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_LEFT ] = *Level;

                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister,
                                                          2,
                                                          6,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                }
                                break;
        
                            case LINEOUT_BASS:
                            case LINEOUT_TREBLE:
                                if( ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_BASS) &&
                                      (PropertyRequest->Node == LINEOUT_BASS) ) ||
                                    ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_TREBLE) &&
                                      (PropertyRequest->Node == LINEOUT_TREBLE) ) )
                                {
                                    // determine register bits
                                    if(*Level <= (-14 << 16))
                                    {
                                        count = 0;
                                    } else if(*Level >= (14 << 16))
                                    {
                                        count = 0xF;
                                    } else
                                    {
                                        count = ((*Level >> 16) + 14) >> 1;
                                    }

                                    // set right channel if channel requested is right or master
                                    if ( (channel == CHAN_RIGHT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_RIGHT ] = *Level;
        
                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister + 1,
                                                          4,
                                                          4,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                    // set the left channel if channel requested is left or master
                                    if ( (channel == CHAN_LEFT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_LEFT ] = *Level;
                                        
                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister,
                                                          4,
                                                          4,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                }
                                break;
                        }
                    }
                }
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            // service basic support request
            switch(PropertyRequest->Node)
            {
                case WAVEOUT_VOLUME:
                case SYNTH_VOLUME:
                case CD_VOLUME:
                case LINEIN_VOLUME:
                case MIC_VOLUME:
                case LINEOUT_VOL:
                case LINEOUT_GAIN:
                case WAVEIN_GAIN:
                    if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    {
                        ntStatus = BasicSupportHandler(PropertyRequest);
                    }
                    break;

                case LINEOUT_BASS:
                case LINEOUT_TREBLE:
                    if( ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_BASS) &&
                          (PropertyRequest->Node == LINEOUT_BASS) ) ||
                        ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_TREBLE) &&
                          (PropertyRequest->Node == LINEOUT_TREBLE) ) )
                    {
                        ntStatus = BasicSupportHandler(PropertyRequest);
                    }
                    break;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_SuperMixCaps()
 *****************************************************************************
 * Handles supermixer caps accesses
 */
static
NTSTATUS
PropertyHandler_SuperMixCaps
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PropertyHandler_SuperMixCaps]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) ((PMINIPORTTOPOLOGY) PropertyRequest->MajorTarget);

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    ULONG           count;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            switch(PropertyRequest->Node)
            {
                // Full 2x2 Switches
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize == 2 * sizeof(ULONG))
                    {
                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);

                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        for(count = 0; count < 4; count++)
                        {
                            MixCaps->Capabilities[count].Mute = TRUE;
                            MixCaps->Capabilities[count].Minimum = 0;
                            MixCaps->Capabilities[count].Maximum = 0;
                            MixCaps->Capabilities[count].Reset = 0;
                        }
                        ntStatus = STATUS_SUCCESS;
                    }
                    break;

                // Limited 2x2 Switches
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize == 2 * sizeof(ULONG))
                    {
                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);

                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        for(count = 0; count < 4; count++)
                        {
                            if((count == 0) || (count == 3))
                            {
                                MixCaps->Capabilities[count].Mute = TRUE;
                                MixCaps->Capabilities[count].Minimum = 0;
                                MixCaps->Capabilities[count].Maximum = 0;
                                MixCaps->Capabilities[count].Reset = 0;
                            } else
                            {
                                MixCaps->Capabilities[count].Mute = FALSE;
                                MixCaps->Capabilities[count].Minimum = LONG_MIN;
                                MixCaps->Capabilities[count].Maximum = LONG_MIN;
                                MixCaps->Capabilities[count].Reset = LONG_MIN;
                            }
                        }
                        ntStatus = STATUS_SUCCESS;
                    }
                    break;


                // 1x2 Switch
                case MIC_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 2 * sizeof(KSAUDIO_MIX_CAPS);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize == 2 * sizeof(ULONG))
                    {
                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 1;
                        MixCaps->OutputChannels = 2;
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(ULONG) + 2 * sizeof(KSAUDIO_MIX_CAPS))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 2 * sizeof(KSAUDIO_MIX_CAPS);

                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 1;
                        MixCaps->OutputChannels = 2;
                        for(count = 0; count < 2; count++)
                        {
                            MixCaps->Capabilities[count].Mute = TRUE;
                            MixCaps->Capabilities[count].Minimum = 0;
                            MixCaps->Capabilities[count].Maximum = 0;
                            MixCaps->Capabilities[count].Reset = 0;
                        }
                        ntStatus = STATUS_SUCCESS;
                    }
                    break;
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            // service basic support request
            switch(PropertyRequest->Node)
            {
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                case MIC_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
                    {
                        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);
    
                        PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                                      KSPROPERTY_TYPE_GET;
                        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                        PropDesc->PropTypeSet.Id    = VT_ARRAY;
                        PropDesc->PropTypeSet.Flags = 0;
                        PropDesc->MembersListCount  = 0;
                        PropDesc->Reserved          = 0;
    
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
                    {
                        // if return buffer can hold a ULONG, return the access flags
                        PULONG AccessFlags = PULONG(PropertyRequest->Value);
                
                        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                       KSPROPERTY_TYPE_GET;
                
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(ULONG);
                        ntStatus = STATUS_SUCCESS;                    
                    }
                    ntStatus = STATUS_SUCCESS;
                    break;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_SuperMixTable()
 *****************************************************************************
 * Handles supermixer level accesses
 */
static
NTSTATUS
PropertyHandler_SuperMixTable
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PropertyHandler_SuperMixTable]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) ((PMINIPORTTOPOLOGY) PropertyRequest->MajorTarget);

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    BYTE            dataL,dataR;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            switch(PropertyRequest->Node)
            {
                // Full 2x2 Switches
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize >= 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);

                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_L,
                                                  2,
                                                  AccessParams[PropertyRequest->Node].BaseRegister );
                        dataR = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_R,
                                                  2,
                                                  AccessParams[PropertyRequest->Node].BaseRegister );

                        MixLevel[0].Mute = dataL & 0x2 ? FALSE : TRUE;          // left to left mute
                        MixLevel[0].Level = 0;

                        MixLevel[1].Mute = dataR & 0x2 ? FALSE : TRUE;          // left to right mute
                        MixLevel[1].Level = 0;

                        MixLevel[2].Mute = dataL & 0x1 ? FALSE : TRUE;          // right to left mute
                        MixLevel[2].Level = 0;

                        MixLevel[3].Mute = dataR & 0x1 ? FALSE : TRUE;          // right to right mute
                        MixLevel[3].Level = 0;

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;

                // Limited 2x2 Switches
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize >= 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);

                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = that->ReadBitsFromMixer( DSP_MIX_OUTMIXIDX,
                                                   2,
                                                   AccessParams[PropertyRequest->Node].BaseRegister );

                        MixLevel[0].Mute = dataL & 0x2 ? FALSE : TRUE;          // left to left mute
                        MixLevel[0].Level = 0;

                        MixLevel[1].Mute = FALSE;
                        MixLevel[1].Level = LONG_MIN;

                        MixLevel[2].Mute = FALSE;
                        MixLevel[2].Level = LONG_MIN;

                        MixLevel[3].Mute = dataL & 0x1 ? FALSE : TRUE;          // right to right mute
                        MixLevel[3].Level = 0;

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;


                // 1x2 Switch
                case MIC_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(KSAUDIO_MIXLEVEL);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(KSAUDIO_MIXLEVEL);

                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_L,
                                                  1,
                                                  MIXBIT_MIC_WAVEIN );
                        dataR = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_R,
                                                  1,
                                                  MIXBIT_MIC_WAVEIN );

                        MixLevel[0].Mute = dataL & 0x1 ? FALSE : TRUE;          // mono to left mute
                        MixLevel[0].Level = 0;

                        MixLevel[1].Mute = dataR & 0x1 ? FALSE : TRUE;          // mono to right mute
                        MixLevel[1].Level = 0;

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            switch(PropertyRequest->Node)
            {
                // Full 2x2 Switches
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize == 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = MixLevel[0].Mute ? 0x0 : 0x2;
                        dataL |= MixLevel[2].Mute ? 0x0 : 0x1;

                        dataR = MixLevel[1].Mute ? 0x0 : 0x2;
                        dataR |= MixLevel[3].Mute ? 0x0 : 0x1;


                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_L,
                                          2,
                                          AccessParams[PropertyRequest->Node].BaseRegister,
                                          dataL );

                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_R,
                                          2,
                                          AccessParams[PropertyRequest->Node].BaseRegister,
                                          dataR );

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;

                // Limited 2x2 Switches
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                    if(PropertyRequest->ValueSize == 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = MixLevel[0].Mute ? 0x0 : 0x2;
                        dataL |= MixLevel[3].Mute ? 0x0 : 0x1;

                        that->WriteBitsToMixer( DSP_MIX_OUTMIXIDX,
                                          2,
                                          AccessParams[PropertyRequest->Node].BaseRegister,
                                          dataL );

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;


                // 1x2 Switch
                case MIC_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize == 2 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = MixLevel[0].Mute ? 0x0 : 0x1;
                        dataR = MixLevel[1].Mute ? 0x0 : 0x1;

                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_L,
                                          1,
                                          MIXBIT_MIC_WAVEIN,
                                          dataL );

                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_R,
                                          1,
                                          MIXBIT_MIC_WAVEIN,
                                          dataR );

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            // service basic support request
            switch(PropertyRequest->Node)
            {
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                case MIC_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
                    {
                        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);
    
                        PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                                      KSPROPERTY_TYPE_GET |
                                                      KSPROPERTY_TYPE_SET;
                        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                        PropDesc->PropTypeSet.Id    = VT_ARRAY;
                        PropDesc->PropTypeSet.Flags = 0;
                        PropDesc->MembersListCount  = 0;
                        PropDesc->Reserved          = 0;
    
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
                    {
                        // if return buffer can hold a ULONG, return the access flags
                        PULONG AccessFlags = PULONG(PropertyRequest->Value);
                
                        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                       KSPROPERTY_TYPE_GET |
                                       KSPROPERTY_TYPE_SET;
                
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(ULONG);
                        ntStatus = STATUS_SUCCESS;                    
                    }
                    break;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_CpuResources()
 *****************************************************************************
 * Processes a KSPROPERTY_AUDIO_CPU_RESOURCES request
 */
static
NTSTATUS
PropertyHandler_CpuResources
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PropertyHandler_CpuResources]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            if(PropertyRequest->ValueSize >= sizeof(LONG))
            {
                *(PLONG(PropertyRequest->Value)) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
                PropertyRequest->ValueSize = sizeof(LONG);
                ntStatus = STATUS_SUCCESS;
            } else
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
            {
                // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

                PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                              KSPROPERTY_TYPE_GET;
                PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                PropDesc->PropTypeSet.Id    = VT_I4;
                PropDesc->PropTypeSet.Flags = 0;
                PropDesc->MembersListCount  = 0;
                PropDesc->Reserved          = 0;

                // set the return value size
                PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                ntStatus = STATUS_SUCCESS;
            } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
            {
                // if return buffer can hold a ULONG, return the access flags
                PULONG AccessFlags = PULONG(PropertyRequest->Value);
        
                *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                               KSPROPERTY_TYPE_GET |
                               KSPROPERTY_TYPE_SET;
        
                // set the return value size
                PropertyRequest->ValueSize = sizeof(ULONG);
                ntStatus = STATUS_SUCCESS;                    
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_ComponentId()
 *****************************************************************************
 * Processes a KSPROPERTY_GENERAL_COMPONENTID request
 */
NTSTATUS
PropertyHandler_ComponentId
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PropertyHandler_ComponentId]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
    {
        if(PropertyRequest->ValueSize >= sizeof(KSCOMPONENTID))
        {
            PKSCOMPONENTID pComponentId = (PKSCOMPONENTID)
                PropertyRequest->Value;

            INIT_MMREG_MID(&pComponentId->Manufacturer, MM_MICROSOFT);
            pComponentId->Product   = PID_MSSB16;
            pComponentId->Name      = NAME_MSSB16;
            pComponentId->Component = GUID_NULL; // Not used for extended caps.
            pComponentId->Version   = MSSB16_VERSION;
            pComponentId->Revision  = MSSB16_REVISION;
            
            PropertyRequest->ValueSize = sizeof(KSCOMPONENTID);
            ntStatus = STATUS_SUCCESS;
        } else if(PropertyRequest->ValueSize == 0)
        {
            PropertyRequest->ValueSize = sizeof(KSCOMPONENTID);
            ntStatus = STATUS_BUFFER_OVERFLOW;
        } else
        {
            PropertyRequest->ValueSize = 0;
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
    } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if(PropertyRequest->ValueSize >= sizeof(ULONG))
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(PropertyRequest->Value);
    
            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                           KSPROPERTY_TYPE_GET;
    
            // set the return value size
            PropertyRequest->ValueSize = sizeof(ULONG);
            ntStatus = STATUS_SUCCESS;                    
        } else
        {
            PropertyRequest->ValueSize = 0;
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * ThisManyOnes()
 *****************************************************************************
 * Returns a byte with the indicated number of ones in the low end.
 */
inline
BYTE
ThisManyOnes
(
    IN      BYTE Ones
)
{
    return ~(BYTE(0xff) << Ones);
}

/*****************************************************************************
 * CMiniportTopologySB16::ReadBitsFromMixer()
 *****************************************************************************
 * Reads specified bits from a mixer register.
 */
BYTE
CMiniportTopologySB16::
ReadBitsFromMixer
(
    BYTE Reg,
    BYTE Bits,
    BYTE Shift
)
{
    BYTE data = AdapterCommon->MixerRegRead(Reg);

    return( data >> Shift) & ThisManyOnes(Bits);
}

/*****************************************************************************
 * CMiniportTopologySB16::WriteBitsToMixer()
 *****************************************************************************
 * Writes specified bits to a mixer register.
 */
void
CMiniportTopologySB16::
WriteBitsToMixer
(
    BYTE Reg,
    BYTE Bits,
    BYTE Shift,
    BYTE Value
)
{
    BYTE mask = ThisManyOnes(Bits) << Shift;
    BYTE data = AdapterCommon->MixerRegRead(Reg);

    if(Reg < DSP_MIX_MAXREGS)
    {
        AdapterCommon->MixerRegWrite( Reg,
                                      (data & ~mask) | ( (Value << Shift) & mask));
    }
}

#ifdef EVENT_SUPPORT
/*****************************************************************************
 * CMiniportTopologySB16::EventHandler
 *****************************************************************************
 * This is the generic event handler.
 */
NTSTATUS CMiniportTopologySB16::EventHandler
(
    IN      PPCEVENT_REQUEST      EventRequest
)
{
    PAGED_CODE();

    ASSERT(EventRequest);

    _DbgPrintF (DEBUGLVL_VERBOSE, ("CMiniportTopologyICH::EventHandler"));

    // The major target is the object pointer to the topology miniport.
    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *)(PMINIPORTTOPOLOGY(EventRequest->MajorTarget));

    ASSERT (that);

    // Validate the node.
    if (EventRequest->Node != LINEOUT_VOL)
        return STATUS_INVALID_PARAMETER;

    // What is to do?
    switch (EventRequest->Verb)
    {
        // Do we support event handling?!?
        case PCEVENT_VERB_SUPPORT:
            _DbgPrintF (DEBUGLVL_VERBOSE, ("BasicSupport Query for Event."));
            break;

        // We should add the event now!
        case PCEVENT_VERB_ADD:
            _DbgPrintF (DEBUGLVL_VERBOSE, ("Adding Event."));

            // If we have the interface and EventEntry is defined ...
            if ((EventRequest->EventEntry) && (that->PortEvents))
            {
                that->PortEvents->AddEventToEventList (EventRequest->EventEntry);
            }
            else
            {
                return STATUS_UNSUCCESSFUL;
            }
            break;

        case PCEVENT_VERB_REMOVE:
            // We cannot remove the event but we can stop generating the
            // events. However, it also doesn't hurt to always generate them ...
            _DbgPrintF (DEBUGLVL_VERBOSE, ("Removing Event."));
            break;

        default:
            return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportTopologySB16::ServiceEvent()
 *****************************************************************************
 * This routine is called by the ISR to handle the event (volume) interrupt.
 */
STDMETHODIMP_(void) CMiniportTopologySB16::ServiceEvent (void)
{
    //
    // Generate an event for the master volume (as an example)
    //
    if (PortEvents)
    {
        PortEvents->GenerateEventList (NULL, KSEVENT_CONTROL_CHANGE,
                                         FALSE, ULONG(-1), TRUE,
                                         LINEOUT_VOL);
    }
}
#endif  // EVENT_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\stdunk\stdunk.cpp ===
/*****************************************************************************
 * stdunk.cpp - standard unknown implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "portcls.h"
#include "stdunk.h"





/*****************************************************************************
 * CUnknown implementation
 */

/*****************************************************************************
 * CUnknown::CUnknown()
 *****************************************************************************
 * Constructor.
 */
CUnknown::CUnknown(PUNKNOWN pUnknownOuter)
:   m_lRefCount(0)
{
    if (pUnknownOuter)
    {
        m_pUnknownOuter = pUnknownOuter;
    }
    else
    {
        m_pUnknownOuter = PUNKNOWN(dynamic_cast<PNONDELEGATINGUNKNOWN>(this));
    }
}

/*****************************************************************************
 * CUnknown::~CUnknown()
 *****************************************************************************
 * Destructor.
 */
CUnknown::~CUnknown(void)
{
}




/*****************************************************************************
 * INonDelegatingUnknown implementation
 */

/*****************************************************************************
 * CUnknown::NonDelegatingAddRef()
 *****************************************************************************
 * Register a new reference to the object without delegating to the outer
 * unknown.
 */
STDMETHODIMP_(ULONG) CUnknown::NonDelegatingAddRef(void)
{
    ASSERT(m_lRefCount >= 0);

    InterlockedIncrement(&m_lRefCount);

    return ULONG(m_lRefCount);
}

/*****************************************************************************
 * CUnknown::NonDelegatingRelease()
 *****************************************************************************
 * Release a reference to the object without delegating to the outer unknown.
 */
STDMETHODIMP_(ULONG) CUnknown::NonDelegatingRelease(void)
{
    ASSERT(m_lRefCount > 0);

    if (InterlockedDecrement(&m_lRefCount) == 0)
	{
        m_lRefCount++;
        delete this;
        return 0;
	}

    return ULONG(m_lRefCount); 
}

/*****************************************************************************
 * CUnknown::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP_(NTSTATUS) CUnknown::NonDelegatingQueryInterface
(
    REFIID  rIID,
    PVOID * ppVoid
)
{
    ASSERT(ppVoid);

    if (IsEqualGUIDAligned(rIID,IID_IUnknown))
    {
        *ppVoid = PVOID(PUNKNOWN(this));
    }
    else
    {
        *ppVoid = NULL;
    }
    
    if (*ppVoid)
    {
        PUNKNOWN(*ppVoid)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\minwave.h ===
/*****************************************************************************
 * minwave.h - SB16 wave miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SB16WAVE_PRIVATE_H_
#define _SB16WAVE_PRIVATE_H_

#if OVERRIDE_DMA_CHANNEL
#define PC_IMPLEMENTATION
#endif // OVERRIDE_DMA_CHANNEL

#include "common.h"




 
/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportWaveCyclicSB16
 *****************************************************************************
 * SB16 wave miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportWaveCyclic
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportWaveCyclicSB16
:   public IMiniportWaveCyclic,
    public IWaveMiniportSB16,
    public CUnknown
{
private:
    PADAPTERCOMMON      AdapterCommon;              // Adapter common object.
    PPORTWAVECYCLIC     Port;                       // Callback interface.

    ULONG               NotificationInterval;       // In milliseconds.
    ULONG               SamplingFrequency;          // Frames per second.

    BOOLEAN             AllocatedCapture;           // Capture in use.
    BOOLEAN             AllocatedRender;            // Render in use.
    BOOLEAN             Allocated8Bit;              // 8-bit DMA in use.
    BOOLEAN             Allocated16Bit;             // 16-bit DMA in use.

    PDMACHANNELSLAVE    DmaChannel8;                // Abstracted channel.
    PDMACHANNELSLAVE    DmaChannel16;               // Abstracted channel.

    PSERVICEGROUP       ServiceGroup;               // For notification.
    KMUTEX              SampleRateSync;             // Sync for sample rate changes.

    /*************************************************************************
     * CMiniportWaveCyclicSB16 methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */
    BOOLEAN ConfigureDevice
    (
        IN      ULONG   Interrupt,
        IN      ULONG   DMA8Bit,
        IN      ULONG   DMA16Bit
    );
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    NTSTATUS ValidateFormat
    (
        IN      PKSDATAFORMAT   Format
    );

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicSB16);

    ~CMiniportWaveCyclicSB16();

    /*************************************************************************
     * This macro is from PORTCLS.H.  It lists all the interface's functions.
     */
    IMP_IMiniportWaveCyclic;

    /*************************************************************************
     * IWaveMiniportSB16 methods
     */
    STDMETHODIMP_(void) RestoreSampleRate (void);
    STDMETHODIMP_(void) ServiceWaveISR (void);
    
    /*************************************************************************
     * Friends
     *
     * The miniport stream class is a friend because it needs to access the
     * private member variables of this class.
     */
    friend class CMiniportWaveCyclicStreamSB16;
};

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16
 *****************************************************************************
 * SB16 wave miniport stream.  This object is associated with a streaming pin
 * and is created when a pin is created on the filter.  The class inherits
 * IMiniportWaveCyclicStream so it can expose this interface and CUnknown so
 * it automatically gets reference counting and aggregation support.
 */
class CMiniportWaveCyclicStreamSB16
:   public IMiniportWaveCyclicStream,
    public IDrmAudioStream,
#if OVERRIDE_DMA_CHANNEL
    public IDmaChannel,
#endif // OVERRIDE_DMA_CHANNEL
    public CUnknown
{
private:
    CMiniportWaveCyclicSB16 *   Miniport;       // Miniport that created us.
    ULONG                       Channel;        // Index into channel list.
    BOOLEAN                     Capture;        // Capture or render.
    BOOLEAN                     Format16Bit;    // 16- or 8-bit samples.
    BOOLEAN                     FormatStereo;   // Two or one channel.
    KSSTATE                     State;          // Stop, pause, run.
    PDMACHANNELSLAVE            DmaChannel;     // DMA channel to use.
    BOOLEAN                     RestoreInputMixer;  // Restore input mixer.
    UCHAR                       InputMixerLeft; // Cache for left input mixer.

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStreamSB16);

    ~CMiniportWaveCyclicStreamSB16();
    
    NTSTATUS 
    Init
    (
        IN      CMiniportWaveCyclicSB16 *   Miniport,
        IN      ULONG                       Channel,
        IN      BOOLEAN                     Capture,
        IN      PKSDATAFORMAT               DataFormat,
        OUT     PDMACHANNELSLAVE            DmaChannel
    );

    /*************************************************************************
     * Include IMiniportWaveCyclicStream public/exported methods (portcls.h)
     */
    IMP_IMiniportWaveCyclicStream;

    /*************************************************************************
     * Include IDrmAudioStream public/exported methods (drmk.h)
     *************************************************************************
     */
    IMP_IDrmAudioStream;
    
#if OVERRIDE_DMA_CHANNEL
    /*************************************************************************
     * Include IDmaChannel public/exported methods (portcls.h)
     *************************************************************************
     */
    IMP_IDmaChannel;
#endif // OVERRIDE_DMA_CHANNEL
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\adddev.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        AddDev.c

Abstract:

        AddDevice - Create and initialize device object and attach device 
                      object to the device stack.

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this File:

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* AddDevice                                                            */
/************************************************************************/
//
// Routine Description:
//
//     Create and initialize device object and attach device 
//       object to the device stack.
//
// Arguments: 
//
//      DriverObject - pointer to Dot4Usb.sys driver object
//      Pdo          - pointer to the PDO of the device stack that
//                       we attach our device object to
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  Pdo
    )
{
    PDEVICE_OBJECT  devObj;
    NTSTATUS        status = IoCreateDevice( DriverObject,
                                             sizeof(DEVICE_EXTENSION),
                                             NULL,                    // no name
                                             FILE_DEVICE_UNKNOWN,
                                             FILE_DEVICE_SECURE_OPEN,
                                             FALSE,                   // not exclusive
                                             &devObj );

    if( NT_SUCCESS(status) ) {

        PDEVICE_OBJECT lowerDevObj = IoAttachDeviceToDeviceStack( devObj, Pdo );

        if( lowerDevObj ) {

            PDEVICE_EXTENSION devExt = (PDEVICE_EXTENSION)devObj->DeviceExtension;

            RtlZeroMemory(devExt, sizeof(DEVICE_EXTENSION));
            
            devExt->LowerDevObj = lowerDevObj;  // send IRPs to this device
            devExt->Signature1  = DOT4USBTAG;   // constant over the lifetime of object
            devExt->Signature2  = DOT4USBTAG;
            devExt->PnpState    = STATE_INITIALIZED;
            devExt->DevObj      = devObj;
            devExt->Pdo         = Pdo;
            devExt->ResetWorkItemPending=0;

            devExt->SystemPowerState = PowerSystemWorking;
            devExt->DevicePowerState = PowerDeviceD0;
            devExt->CurrentPowerIrp  = NULL;

            IoInitializeRemoveLock( &devExt->RemoveLock, 
                                    DOT4USBTAG,
                                    5,          // MaxLockedMinutes - only used on chk'd builds
                                    255 );      // HighWaterMark    - only used on chk'd builds
            
            KeInitializeSpinLock( &devExt->SpinLock );
            KeInitializeEvent( &devExt->PollIrpEvent, NotificationEvent, FALSE );
            
            devObj->Flags |= DO_DIRECT_IO;
            devObj->Flags |= ( devExt->LowerDevObj->Flags & DO_POWER_PAGABLE );
            devObj->Flags &= ~DO_DEVICE_INITIALIZING; // DO_POWER_PAGABLE must be set appropriately 
                                                      //   before clearing this bit to avoid a bugcheck

        } else {
            TR_FAIL(("AddDevice - IoAttachDeviceToDeviceStack - FAIL"));            
            status = STATUS_UNSUCCESSFUL; // for lack of a more appropriate status code
        }

    } else {
        TR_FAIL(("AddDevice - IoCreateDevice - FAIL - status= %x", status));
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\mintopo.h ===
/*****************************************************************************
 * mintopo.h - SB16 topology miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SB16TOPO_PRIVATE_H_
#define _SB16TOPO_PRIVATE_H_

#include "common.h"


/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportTopologySB16
 *****************************************************************************
 * SB16 topology miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportTopology
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportTopologySB16 
:   public IMiniportTopology, 
#ifdef EVENT_SUPPORT
    public ITopoMiniportSB16,
#endif
    public CUnknown
{
private:
    PADAPTERCOMMON      AdapterCommon;      // Adapter common object.
#ifdef EVENT_SUPPORT
    PPORTEVENTS         PortEvents;
#endif

    /*************************************************************************
     * CMiniportTopologySB16 methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    BYTE ReadBitsFromMixer
    (
        BYTE Reg,
        BYTE Bits,
        BYTE Shift
    );
    void WriteBitsToMixer
    (
        BYTE Reg,
        BYTE Bits,
        BYTE Shift,
        BYTE Value
    );

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopologySB16);

    ~CMiniportTopologySB16();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat     OPTIONAL
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportTopology methods
     */
    STDMETHODIMP Init
    (
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTTOPOLOGY   Port
    );

#ifdef EVENT_SUPPORT
    /*************************************************************************
     * ITopoMiniportSB16 methods
     */
    STDMETHODIMP_(void) ServiceEvent (void);
#endif

    /*************************************************************************
     * Friends
     */
    friend
    NTSTATUS
    PropertyHandler_OnOff
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_Level
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_SuperMixCaps
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_SuperMixTable
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_CpuResources
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    static
    NTSTATUS
    EventHandler
    (
        IN      PPCEVENT_REQUEST      EventRequest
    );
};

#include "tables.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\debug.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Debug.h

Abstract:

        Debug defines

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/


#define BREAK_ON_DRIVER_ENTRY  0x00000001
#define BREAK_ON_DRIVER_UNLOAD 0x00000002

#define TRACE_LOAD_UNLOAD      0x00000001 // DriverEntry, Unload
#define TRACE_FAIL             0x00000002 // Trace Failures/Errors
#define TRACE_FUNC_ENTER       0x00000004 // Enter Function - may include params
#define TRACE_FUNC_EXIT        0x00000008 // Exit  Function - may include return value(s)

#define TRACE_PNP1             0x00000010 // AddDevice, Start, Remove - minimal info
#define TRACE_PNP2             0x00000020
#define TRACE_PNP4             0x00000040
#define TRACE_PNP8             0x00000080 // PnP error paths

#define TRACE_USB1             0x00000100 // interface to USB
#define TRACE_USB2             0x00000200
#define TRACE_USB4             0x00000400
#define TRACE_USB8             0x00000800

#define TRACE_DOT41            0x00001000 // interface to dot4.sys loaded above us
#define TRACE_DOT42            0x00002000
#define TRACE_DOT44            0x00004000
#define TRACE_DOT48            0x00008000

#define TRACE_TMP1             0x00010000 // temp usage for development and debugging
#define TRACE_TMP2             0x00020000
#define TRACE_TMP4             0x00040000
#define TRACE_TMP8             0x00080000

#define TRACE_VERBOSE          0x80000000 // stuff that normally is too verbose

#define _DBG 1

#if _DBG
// Trace If (...condition...)
#define TR_IF(_test_, _x_) \
    if( (_test_) & gTrace ) { \
        DbgPrint("D4U: "); \
        DbgPrint _x_; \
        DbgPrint("\n"); \
    }

#define TR_LD_UNLD(_x_) TR_IF(TRACE_LOAD_UNLOAD, _x_) // DriverEntry, DriverUnload 
#define TR_FAIL(_x_)    TR_IF(TRACE_FAIL, _x_)        // Failures/Errors
#define TR_ENTER(_x_)   TR_IF(TRACE_FUNC_ENTER, _x_)
#define TR_EXIT(_x_)    TR_IF(TRACE_FUNC_EXIT, _x_)
#define TR_PNP1(_x_)    TR_IF(TRACE_PNP1, _x_)        // minimal AddDevice, Start, Remove
#define TR_PNP2(_x_)    TR_IF(TRACE_PNP2, _x_)        // verbose PnP
#define TR_PNP8(_x_)    TR_IF(TRACE_PNP8, _x_)        // error paths in PnP functions
#define TR_VERBOSE(_x_) TR_IF(TRACE_VERBOSE, _x_)     // stuff that normally is too verbose
#define TR_DOT41(_x_)   TR_IF(TRACE_DOT41, _x_)
#define TR_TMP1(_x_)    TR_IF(TRACE_TMP1, _x_)

#endif // _DBG


#define ALLOW_D4U_ASSERTS 1
#if ALLOW_D4U_ASSERTS
#define D4UAssert(_x_) ASSERT(_x_)
#else
#define D4UAssert(_x_)
#endif // ALLOW_D4U_ASSERTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\sb16\tables.h ===
/*****************************************************************************
 * tables.h - SB16 topology miniport tables
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _SB16TOPO_TABLES_H_
#define _SB16TOPO_TABLES_H_

/*****************************************************************************
 * The topology
 *****************************************************************************
 *
 *  wave>-------VOL---------------------+
 *                                      |
 * synth>-------VOL--+------------------+
 *                   |                  |
 *                   +--SWITCH_2X2--+   |
 *                                  |   |
 *    cd>-------VOL--+--SWITCH----------+
 *                   |              |   |
 *                   +--SWITCH_2X2--+   |
 *                                  |   |
 *   aux>-------VOL--+--SWITCH----------+
 *                   |              |   |
 *                   +--SWITCH_2X2--+   |
 *                                  |   |
 *   mic>--AGC--VOL--+--SWITCH----------+--VOL--BASS--TREBLE--GAIN-->lineout
 *                   |              |
 *                   +--SWITCH_1X2--+-------------------------GAIN-->wavein
 *
 */
 
/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for audio bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR 
MiniportPins[] =
{
    // WAVEOUT_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_LEGACY_AUDIO_CONNECTOR,         // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },

    // SYNTH_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_SYNTHESIZER,                    // Category
            &KSAUDFNAME_MIDI,                           // Name
            0                                           // Reserved
        }
    },

    // CD_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_CD_PLAYER,                      // Category
            &KSAUDFNAME_CD_AUDIO,                       // Name
            0                                           // Reserved
        }
    },

    // LINEIN_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_LINE_CONNECTOR,                 // Category
            &KSAUDFNAME_LINE_IN,                        // Name
            0                                           // Reserved
        }
    },

    // MIC_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_MICROPHONE,                     // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },

    // LINEOUT_DEST
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_SPEAKER,                        // Category
            &KSAUDFNAME_VOLUME_CONTROL,                 // Name (this name shows up as
                                                        // the playback panel name in SoundVol)
            0                                           // Reserved
        }
    },

    // WAVEIN_DEST
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

enum
{
    WAVEOUT_SOURCE = 0,
    SYNTH_SOURCE,
    CD_SOURCE,
    LINEIN_SOURCE,
    MIC_SOURCE,
    LINEOUT_DEST,
    WAVEIN_DEST
};

/*****************************************************************************
 * PropertiesVolume
 *****************************************************************************
 * Properties for volume controls.
 */
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationVolume
 *****************************************************************************
 * Automation table for volume controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume,PropertiesVolume);

/*****************************************************************************
 * PropertiesAgc
 *****************************************************************************
 * Properties for AGC controls.
 */
static
PCPROPERTY_ITEM PropertiesAgc[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_AGC,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_OnOff
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationAgc
 *****************************************************************************
 * Automation table for Agc controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationAgc,PropertiesAgc);

/*****************************************************************************
 * PropertiesMute
 *****************************************************************************
 * Properties for mute controls.
 */
static
PCPROPERTY_ITEM PropertiesMute[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MUTE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_OnOff
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationMute
 *****************************************************************************
 * Automation table for mute controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute,PropertiesMute);

/*****************************************************************************
 * PropertiesTone
 *****************************************************************************
 * Properties for tone controls.
 */
static
PCPROPERTY_ITEM PropertiesTone[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_BASS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_TREBLE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationTone
 *****************************************************************************
 * Automation table for tone controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationTone,PropertiesTone);

/*****************************************************************************
 * PropertiesSupermix
 *****************************************************************************
 * Properties for supermix controls.
 */
static
PCPROPERTY_ITEM PropertiesSupermix[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SuperMixCaps
    },
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SuperMixTable
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationSupermix
 *****************************************************************************
 * Automation table for supermix controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSupermix,PropertiesSupermix);

#ifdef EVENT_SUPPORT
/*****************************************************************************
 * The Event for the Master Volume (or other nodes)
 *****************************************************************************
 * Generic event for nodes.
 */
static PCEVENT_ITEM NodeEvent[] =
{
    // This is a generic event for nearly every node property.
    {
        &KSEVENTSETID_AudioControlChange,   // Something changed!
        KSEVENT_CONTROL_CHANGE,             // The only event-property defined.
        KSEVENT_TYPE_ENABLE | KSEVENT_TYPE_BASICSUPPORT,
        CMiniportTopologySB16::EventHandler
    }
};

/*****************************************************************************
 * AutomationVolumeWithEvent
 *****************************************************************************
 * This is the automation table for Volume events.
 * You can create Automation tables with event support for any type of nodes
 * (e.g. mutes) with just adding the generic event above. The automation table
 * then gets added to every node that should have event support.
 */
DEFINE_PCAUTOMATION_TABLE_PROP_EVENT (AutomationVolumeWithEvent, PropertiesVolume, NodeEvent);
#endif

/*****************************************************************************
 * TopologyNodes
 *****************************************************************************
 * List of node identifiers.
 */
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
    // WAVEOUT_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_WAVE_VOLUME // Name
    },

    // SYNTH_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_MIDI_VOLUME // Name
    },

    // SYNTH_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_MIDI_MUTE   // Name
    },

    // CD_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_CD_VOLUME   // Name
    },

    // CD_LINEOUT_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_CD_MUTE     // Name
    },

    // CD_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_CD_MUTE     // Name
    },

    // LINEIN_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_LINE_VOLUME // Name
    },

    // LINEIN_LINEOUT_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_LINE_MUTE   // Name
    },

    // LINEIN_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_LINE_MUTE   // Name
    },

    // MIC_AGC
    {
        0,                      // Flags
        &AutomationAgc,         // AutomationTable
        &KSNODETYPE_AGC,        // Type
        NULL                    // Name
    },

    // MIC_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_MIC_VOLUME  // Name
    },

    // MIC_LINEOUT_MUTE
    {
        0,                      // Flags
        &AutomationMute,        // AutomationTable
        &KSNODETYPE_MUTE,       // Type
        &KSAUDFNAME_MIC_MUTE    // Name
    },

    // MIC_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_MIC_MUTE    // Name
    },

    // LINEOUT_MIX
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_SUM,        // Type
        NULL                    // Name
    },

    // LINEOUT_VOL
    {
        0,                      // Flags
#ifdef EVENT_SUPPORT
        &AutomationVolumeWithEvent, // AutomationTable with event support
#else
        &AutomationVolume,      // AutomationTable
#endif
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_MASTER_VOLUME // Name
    },

    // LINEOUT_BASS
    {
        0,                      // Flags
        &AutomationTone,        // AutomationTable
        &KSNODETYPE_TONE,       // Type
        &KSAUDFNAME_BASS        // Name
    },

    // LINEOUT_TREBLE
    {
        0,                      // Flags
        &AutomationTone,        // AutomationTable
        &KSNODETYPE_TONE,       // Type
        &KSAUDFNAME_TREBLE      // Name
    },

    // LINEOUT_GAIN
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        NULL                    // Name
    },

    // WAVEIN_MIX
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_SUM,        // Type
        &KSAUDFNAME_RECORDING_SOURCE // Name
    },

    // WAVEIN_GAIN
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_WAVE_IN_VOLUME // Name
    }
};

/*****************************************************************************
 * ControlValueCache
 *****************************************************************************
 */
static
LONG ControlValueCache[] =
{   // Left         // Right
    0xFFF9F203,     0xFFF9F203,     // WAVEOUT_VOLUME
    0xFFF9F203,     0xFFF9F203,     // SYNTH_VOLUME
    0xFFF9F203,     0xFFF9F203,     // CD_VOLUME
    0xFFF9F203,     0xFFF9F203,     // LINEIN_VOLUME
    0xFFF9F203,     0,              // MIC_VOLUME
    0xFFF9F203,     0xFFF9F203,     // LINEOUT_VOL
    0x000242A0,     0x000242A0,     // LINEOUT_BASS
    0x000242A0,     0x000242A0,     // LINEOUT_TREBLE
    0x000C0000,     0x000C0000,     // LINEOUT_GAIN
    0x00000000,     0x00000000      // WAVEIN_GAIN
};

typedef struct
{
    BYTE    BaseRegister;           // H/W access parameter
    ULONG   CacheOffset;            // ControlValueCache offset
} ACCESS_PARM,*PACCESS_PARM;

/*****************************************************************************
 * AccessParams
 *****************************************************************************
 * Table of H/W access parameters
 */
static
ACCESS_PARM AccessParams[] =
{
    { DSP_MIX_VOICEVOLIDX_L,        0           },      // WAVEOUT_VOLUME

    { DSP_MIX_FMVOLIDX_L,           2           },      // SYNTH_VOLUME
    { MIXBIT_SYNTH_WAVEIN_R,        ULONG(-1)   },      // SYNTH_WAVEIN_SUPERMIX

    { DSP_MIX_CDVOLIDX_L,           4           },      // CD_VOLUME
    { MIXBIT_CD_LINEOUT_R,          ULONG(-1)   },      // CD_LINEOUT_SUPERMIX
    { MIXBIT_CD_WAVEIN_R,           ULONG(-1)   },      // CD_WAVEIN_SUPERMIX

    { DSP_MIX_LINEVOLIDX_L,         6           },      // LINEIN_VOLUME
    { MIXBIT_LINEIN_LINEOUT_R,      ULONG(-1)   },      // LINEIN_LINEOUT_SUPERMIX
    { MIXBIT_LINEIN_WAVEIN_R,       ULONG(-1)   },      // LINEIN_WAVEIN_SUPERMIX

    { 0,                            ULONG(-1)   },      // MIC_AGC
    { DSP_MIX_MICVOLIDX,            8           },      // MIC_VOLUME
    { 0,                            ULONG(-1)   },      // MIC_LINEOUT_MUTE
    { 0,                            ULONG(-1)   },      // MIC_WAVEIN_SUPERMIX

    { 0,                            ULONG(-1)   },      // LINEOUT_MIX
    { DSP_MIX_MASTERVOLIDX_L,       10          },      // LINEOUT_VOL
    { DSP_MIX_BASSIDX_L,            12          },      // LINEOUT_BASS
    { DSP_MIX_TREBLEIDX_L,          14          },      // LINEOUT_TREBLE
    { DSP_MIX_OUTGAINIDX_L,         16          },      // LINEOUT_GAIN

    { 0,                            ULONG(-1)   },      // WAVEIN_MIX
    { DSP_MIX_INGAINIDX_L,          18          }       // WAVEIN_GAIN
};

enum
{
    WAVEOUT_VOLUME = 0,
    SYNTH_VOLUME,
    SYNTH_WAVEIN_SUPERMIX,
    CD_VOLUME,
    CD_LINEOUT_SUPERMIX,
    CD_WAVEIN_SUPERMIX,
    LINEIN_VOLUME,
    LINEIN_LINEOUT_SUPERMIX,
    LINEIN_WAVEIN_SUPERMIX,
    MIC_AGC,
    MIC_VOLUME,
    MIC_LINEOUT_MUTE,
    MIC_WAVEIN_SUPERMIX,
    LINEOUT_MIX,
    LINEOUT_VOL,
    LINEOUT_BASS,
    LINEOUT_TREBLE,
    LINEOUT_GAIN,
    WAVEIN_MIX,
    WAVEIN_GAIN
};

/*****************************************************************************
 * ConnectionTable
 *****************************************************************************
 * Table of topology unit connections.
 *
 * Pin numbering is technically arbitrary, but the convention established here
 * is to number a solitary output pin 0 (looks like an 'o') and a solitary
 * input pin 1 (looks like an 'i').  Even destinations, which have no output,
 * have an input pin numbered 1 and no pin 0.
 *
 * Nodes are more likely to have multiple ins than multiple outs, so the more
 * general rule would be that inputs are numbered >=1.  If a node has multiple
 * outs, none of these conventions apply.
 *
 * Nodes have at most one control value.  Mixers are therefore simple summing
 * nodes with no per-pin levels.  Rather than assigning a unique pin to each
 * input to a mixer, all inputs are connected to pin 1.  This is acceptable
 * because there is no functional distinction between the inputs.
 *
 * There are no multiplexers in this topology, so there is no opportunity to
 * give an example of a multiplexer.  A multiplexer should have a single
 * output pin (0) and multiple input pins (1..n).  Its control value is an
 * integer in the range 1..n indicating which input is connected to the
 * output.
 *
 * In the case of connections to pins, as opposed to connections to nodes, the
 * node is identified as PCFILTER_NODE and the pin number identifies the
 * particular filter pin.
 */
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{   //  FromNode,               FromPin,          ToNode,                 ToPin
    {   PCFILTER_NODE,          WAVEOUT_SOURCE,   WAVEOUT_VOLUME,         1             },
    {   WAVEOUT_VOLUME,         0,                LINEOUT_MIX,            1             },

    {   PCFILTER_NODE,          SYNTH_SOURCE,     SYNTH_VOLUME,           1             },
    {   SYNTH_VOLUME,           0,                LINEOUT_MIX,            2             },
    {   SYNTH_VOLUME,           0,                SYNTH_WAVEIN_SUPERMIX,  1             },
    {   SYNTH_WAVEIN_SUPERMIX,  0,                WAVEIN_MIX,             1             },

    {   PCFILTER_NODE,          CD_SOURCE,        CD_VOLUME,              1             },
    {   CD_VOLUME,              0,                CD_LINEOUT_SUPERMIX,    1             },
    {   CD_LINEOUT_SUPERMIX,    0,                LINEOUT_MIX,            3             },
    {   CD_VOLUME,              0,                CD_WAVEIN_SUPERMIX,     1             },
    {   CD_WAVEIN_SUPERMIX,     0,                WAVEIN_MIX,             2             },

    {   PCFILTER_NODE,          LINEIN_SOURCE,    LINEIN_VOLUME,          1             },
    {   LINEIN_VOLUME,          0,                LINEIN_LINEOUT_SUPERMIX,1             },
    {   LINEIN_LINEOUT_SUPERMIX,0,                LINEOUT_MIX,            4             },
    {   LINEIN_VOLUME,          0,                LINEIN_WAVEIN_SUPERMIX, 1             },
    {   LINEIN_WAVEIN_SUPERMIX, 0,                WAVEIN_MIX,             3             },

    {   PCFILTER_NODE,          MIC_SOURCE,       MIC_AGC,                1             },
    {   MIC_AGC,                0,                MIC_VOLUME,             1             },
    {   MIC_VOLUME,             0,                MIC_LINEOUT_MUTE,       1             },
    {   MIC_LINEOUT_MUTE,       0,                LINEOUT_MIX,            5             },
    {   MIC_VOLUME,             0,                MIC_WAVEIN_SUPERMIX,    1             },
    {   MIC_WAVEIN_SUPERMIX,    0,                WAVEIN_MIX,             4             },

    {   LINEOUT_MIX,            0,                LINEOUT_VOL,            1             },
    {   LINEOUT_VOL,            0,                LINEOUT_BASS,           1             },
    {   LINEOUT_BASS,           0,                LINEOUT_TREBLE,         1             },
    {   LINEOUT_TREBLE,         0,                LINEOUT_GAIN,           1             },
    {   LINEOUT_GAIN,           0,                PCFILTER_NODE,          LINEOUT_DEST  },

    {   WAVEIN_MIX,             0,                WAVEIN_GAIN,            1             },
    {   WAVEIN_GAIN,            0,                PCFILTER_NODE,          WAVEIN_DEST   }
};

/*****************************************************************************
 * MiniportFilterDescription
 *****************************************************************************
 * Complete miniport description.
 */
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    &AutomationFilter,                  // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(TopologyNodes),        // NodeCount
    TopologyNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories: NULL->use default (audio, render, capture)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\dot4usb.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        DevExt.h

Abstract:

        Defines, Globals, Structures, Enums, and Device Extension

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#ifndef _DEVEXT_H_
#define _DEVEXT_H_

//
// Defines
//

#define arraysize(p) (sizeof(p)/sizeof((p)[0])) // number of elements in an array
#define FAILURE_TIMEOUT -(30 * 10 * 1000 * 1000)// 5 seconds (in 100ns units) - used for KeWaitForSingleObject timeout
#define DOT4USBTAG (ULONG)' u4d'                // Used as PoolTag and Device Extension Signature
#define SCRATCH_BUFFER_SIZE 512                 // buffer size for reading from Interrupt pipe

#ifdef ExAllocatePool                           // use pool tagging
#undef ExAllocatePool
#define ExAllocatePool(type, size) ExAllocatePoolWithTag((type), (size), DOT4USBTAG)
#endif



//
// Globals
//

extern UNICODE_STRING gRegistryPath;  // copy of RegistryPath passed to DriverEntry - Buffer is UNICODE_NULL terminated for flexibilty
extern ULONG          gTrace;         // events to trace - see debug.h
extern ULONG          gBreak;         // events that we should break on - see debug.h



//
// Structs (other than Device Extension)
//

typedef struct _USB_RW_CONTEXT {      // Used to pass context to IRP Completion Routine
    PURB            Urb;
    BOOLEAN IsWrite;
    PDEVICE_OBJECT  DevObj;
} USB_RW_CONTEXT, *PUSB_RW_CONTEXT;



//
// Enums
//

typedef enum _USB_REQUEST_TYPE {      // Flag used to distinguish Reads from Writes in UsbReadWrite()
    UsbReadRequest  = 1,
    UsbWriteRequest = 2
} USB_REQUEST_TYPE;

typedef enum _PNP_STATE {             // PnP Device States
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,                // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
} PNP_STATE;



//
// Device Extension
//

typedef struct _DEVICE_EXTENSION {
    ULONG                        Signature1;         // extra check that devExt looks like ours - DOT4USBTAG
    PDEVICE_OBJECT               DevObj;             // back pointer to our DeviceObject
    PDEVICE_OBJECT               Pdo;                // our PDO
    PDEVICE_OBJECT               LowerDevObj;        // Device Object returned by IoAttachDeviceToDeviceStack that we send IRPs to
    PNP_STATE                    PnpState;           // PnP device state
    BOOLEAN                      IsDLConnected;      // is our datalink connected? i.e., between PARDOT3_ CONNECT and DISCONNECT?
    UCHAR                        Spare1[3];          // pad to DWORD boundary
    PKEVENT                      Dot4Event;          // datalink event - given to us by dot4.sys to signal when device data avail
    USBD_CONFIGURATION_HANDLE    ConfigHandle;       // handle for the configuration the device is currently in
    PUSB_DEVICE_DESCRIPTOR       DeviceDescriptor;   // ptr to the USB device descriptor for this device
    PUSBD_INTERFACE_INFORMATION  Interface;          // copy of the info structure returned from select_configuration or select_interface
    PUSBD_PIPE_INFORMATION       WritePipe;          // pipe for bulk writes
    PUSBD_PIPE_INFORMATION       ReadPipe;           // pipe for bulk reads
    PUSBD_PIPE_INFORMATION       InterruptPipe;      // pipe for interrupt reads
    KSPIN_LOCK                   SpinLock;           // SpinLock to protect extension data
    PIRP                         PollIrp;            // irp used for polling device interrupt pipe for device data avail
    KSPIN_LOCK                   PollIrpSpinLock;    // SpinLock used to protect changes to Polling Irp for Interrupt Pipe
    KEVENT                       PollIrpEvent;       // used by completion routine to signal that cancel of pollIrp has been detected/handled
    UCHAR                        Spare2[3];          // pad to DWORD boundary
    DEVICE_CAPABILITIES          DeviceCapabilities; // includes a table mapping system power states to device power states.
    IO_REMOVE_LOCK               RemoveLock;         // Synch mechanism to keep us from being removed while we have IRPs active
    LONG                         ResetWorkItemPending;// flag to specify if a "reset pipe" work item is pending
    ULONG                        Signature2;         // extra check that devExt looks like ours - DOT4USBTAG
    PUSB_RW_CONTEXT              InterruptContext;   // context for read on interrupt pipe
    SYSTEM_POWER_STATE           SystemPowerState;
    DEVICE_POWER_STATE           DevicePowerState;
    PIRP                         CurrentPowerIrp;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _DOT4USB_WORKITEM_CONTEXT
{
    PIO_WORKITEM ioWorkItem;
    PDEVICE_OBJECT deviceObject;
     PUSBD_PIPE_INFORMATION pPipeInfo;
    PIRP irp;

} DOT4USB_WORKITEM_CONTEXT,*PDOT4USB_WORKITEM_CONTEXT;


#endif // _DEVEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\openclos.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        OpenClos.c

Abstract:

        Dispatch routines for IRP_MJ_CREATE and IRP_MJ_CLOSE

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchCreate                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_CREATE
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the create
//      Irp    - pointer to the create IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS          status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    TR_VERBOSE(("DispatchCreate"));

    if( NT_SUCCESS(status) ) {
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - fail CREATE
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return status;
}


/************************************************************************/
/* DispatchClose                                                        */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_CLOSE
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the close
//      Irp    - pointer to the close IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS          status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    TR_VERBOSE(("DispatchClose"));

    if( NT_SUCCESS(status) ) {
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - succeed CLOSE anyway
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\ioctl.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Ioctl.c

Abstract:

        Dispatch routines for IRP_MJ_DEVICE_CONTROL and IRP_MJ_INTERNAL_DEVICE_CONTROL

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code review

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchDeviceControl                                                */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_DEVICE_CONTROL
//       - We don't currently handle any such requests but we may do
//           so in the future. Pass any unhandled requests down the
//           stack to the device below us.
//
// Arguments: 
//
//      DevObj - pointer to DeviceObject that is the target of the request
//      Irp    - pointer to device control IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION  devExt = DevObj->DeviceExtension;
    NTSTATUS           status;
    ULONG              info = 0;

    TR_VERBOSE(("DispatchDeviceControl - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

        switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
            
        case IOCTL_PAR_QUERY_DEVICE_ID:
            // ISSUE - 000901 - DFritz - these new IOCTLs need to do parameter validation to avoid AVs
            {
                const LONG  minValidIdLength = sizeof("MFG:x;MDL:y;");
                const ULONG bufSize = 1024;
                PCHAR idBuffer = ExAllocatePool( NonPagedPool, bufSize );
                LONG idLength;
                
                if( idBuffer ) {
                    
                    RtlZeroMemory( idBuffer, bufSize );
                    
                    idLength = UsbGet1284Id( DevObj, idBuffer, bufSize-1 );
                    
                    if( idLength < minValidIdLength ) {
                        status = STATUS_UNSUCCESSFUL;
                    } else if( (ULONG)idLength >= irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        RtlZeroMemory( Irp->AssociatedIrp.SystemBuffer, idLength+1 );
                        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, idBuffer+2, idLength-2 );
                        info   = idLength - 1;
                        status = STATUS_SUCCESS;
                    }
                    
                    ExFreePool( idBuffer );
                    
                } else {
                    status = STATUS_NO_MEMORY;
                }
            }

            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = info;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

            break;
            
        case IOCTL_PAR_QUERY_RAW_DEVICE_ID:
            {
                const LONG  minValidIdLength = sizeof("MFG:x;MDL:y;");
                const ULONG bufSize = 1024;
                PCHAR idBuffer = ExAllocatePool( NonPagedPool, bufSize );
                LONG idLength;
                
                if( idBuffer ) {
                    
                    RtlZeroMemory( idBuffer, bufSize );
                    
                    idLength = UsbGet1284Id( DevObj, idBuffer, bufSize-1 );
                    
                    if( idLength < minValidIdLength ) {
                        status = STATUS_UNSUCCESSFUL;
                    } else if( (ULONG)idLength >= irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        RtlZeroMemory( Irp->AssociatedIrp.SystemBuffer, idLength+1 );
                        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, idBuffer, idLength);
                        info   = idLength + 1;
                        status = STATUS_SUCCESS;
                    }
                    
                    ExFreePool( idBuffer );
                    
                } else {
                    status = STATUS_NO_MEMORY;
                }
            }

            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = info;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

            break;
            
        case IOCTL_PAR_QUERY_DEVICE_ID_SIZE:

            {
                const LONG  minValidIdLength = sizeof("MFG:x;MDL:y;");
                const ULONG bufSize = 1024;
                PCHAR idBuffer = ExAllocatePool( NonPagedPool, bufSize );
                LONG idLength;
                
                if( idBuffer ) {
                    
                    RtlZeroMemory( idBuffer, bufSize );
                    
                    idLength = UsbGet1284Id( DevObj, idBuffer, bufSize-1 );
                    
                    if( idLength < minValidIdLength ) {
                        status = STATUS_UNSUCCESSFUL;
                    } else if( sizeof(ULONG) < irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        ++idLength; // save room for terminating NULL
                        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, &idLength, sizeof(ULONG));
                        info   = sizeof(ULONG);
                        status = STATUS_SUCCESS;
                    }
                    
                    ExFreePool( idBuffer );
                    
                } else {
                    status = STATUS_NO_MEMORY;
                }
            }

            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = info;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

            break;

        case IOCTL_PAR_QUERY_LOCATION:

            _snprintf( Irp->AssociatedIrp.SystemBuffer, 4, "USB" );
            info = 4;
            status = STATUS_SUCCESS;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

        default:

            // pass request down
            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->LowerDevObj, Irp );
            IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

        }
            
    } else {
        // unable to acquire RemoveLock - FAIL request
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}


/************************************************************************/
/* DispatchInternalDeviceControl                                        */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_INTERNAL_DEVICE_CONTROL
//       - We expect DataLink requests from dot4.sys driver above us. Any
//           request that we don't handle is simply passed down the stack
//           to the driver below us.       
//
// Arguments: 
//
//      DevObj - pointer to DeviceObject that is the target of the request
//      Irp    - pointer to device control IRP
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    NTSTATUS           status;
    PDEVICE_EXTENSION  devExt   = DevObj->DeviceExtension;

    TR_VERBOSE(("DispatchInternalDeviceControl - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {

        PIO_STACK_LOCATION irpSp        = IoGetCurrentIrpStackLocation( Irp );
        BOOLEAN            bCompleteIrp = FALSE;
        KIRQL              oldIrql;

        switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
            
        case IOCTL_INTERNAL_PARDOT3_CONNECT:
            
            //
            // Enter a "DataLink Connected" state with dot4.sys
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_CONNECT"));

            KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
            if( !devExt->IsDLConnected ) {
                devExt->IsDLConnected = TRUE;
                status = STATUS_SUCCESS;
            } else {
                // we believe that we are in a "datalink connected state" but obviously 
                //   dot4.sys doesn't agree - suggest investigating further if we hit
                //   this assert
                D4UAssert(FALSE);
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

            bCompleteIrp = TRUE;
            break;
            

        case IOCTL_INTERNAL_PARDOT3_RESET:
            
            //
            // This IOCTL is specific to parallel and is a NOOP for a USB connection.
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_RESET"));

            status = STATUS_SUCCESS;
            bCompleteIrp = TRUE;
            break;
            
        case IOCTL_INTERNAL_PARDOT3_DISCONNECT:
            
            //
            // Terminate the "DataLink Connected" state with dot4.sys and
            //   invalidate any Dot4Event since the event may be freed anytime
            //   after we complete this IRP.
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_DISCONNECT"));

            UsbStopReadInterruptPipeLoop( DevObj );

            KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
            devExt->Dot4Event = NULL; // invalidate dot4's event, if any, so we stop signalling dot4
            if( devExt->IsDLConnected ) {
                devExt->IsDLConnected = FALSE;
            } else {
                // we believe that we are NOT in a "datalink connected state" but obviously 
                //   dot4.sys doesn't agree - suggest investigating further if we hit
                //   this assert
                D4UAssert(FALSE);
            }
            KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

            status = STATUS_SUCCESS; // we always succeed this request since it is a disconnect
            bCompleteIrp = TRUE;
            break;
            
        case IOCTL_INTERNAL_PARDOT3_SIGNAL:
            
            //
            // dot4.sys is giving us a pointer to an Event that it owns and dot4 
            //   expects us to Signal this event whenever we detect that the device has 
            //   data available to be read. We continue signalling this event on device 
            //   data avail until we receive a disconnect IOCTL.
            //

            TR_VERBOSE(("DispatchInternalDeviceControl - IOCTL_INTERNAL_PARDOT3_SIGNAL"));

            KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
            if( devExt->IsDLConnected ) {
                if( !devExt->Dot4Event ) {
                    // our state indicates that it is OK to receive this request
                    if( irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PKEVENT) ) {
                        status = STATUS_INVALID_PARAMETER;                
                    } else {
                        // save the pointer to the event in our device extension
                        PKEVENT Event;
                        RtlCopyMemory(&Event, Irp->AssociatedIrp.SystemBuffer, sizeof(PKEVENT));
                        devExt->Dot4Event = Event;
                        status = STATUS_SUCCESS;
                    }
                } else {
                    // we already have an event and dot4.sys sent us another one? - bad driver - AV crash likely real soon now
                    D4UAssert(FALSE);
                    status = STATUS_INVALID_DEVICE_REQUEST;
                }
            } else {
                // we're not in a datalink connected state - this is an invalid request
                D4UAssert(FALSE);
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

            if( NT_SUCCESS(status) && devExt->InterruptPipe ) {
                status = UsbStartReadInterruptPipeLoop( DevObj );
            }

            bCompleteIrp = TRUE;
            break;
            
        default :
            
            // unhandled request - pass it down the stack
            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->LowerDevObj, Irp );
            bCompleteIrp = FALSE;
            
        }
        
        if( bCompleteIrp ) {
            // we didn't pass this request down the stack, so complete it now
            Irp->IoStatus.Status      = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
        }

        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

    } else {
        // unable to acquire RemoveLock - we're in the process of being removed - FAIL request
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\pch.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Pch.h

Abstract:

        Precompiled header

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/


#pragma warning( disable : 4115 ) // named type definition in parentheses 
#pragma warning( disable : 4127 ) // conditional expression is constant
#pragma warning( disable : 4200 ) // zero-sized array in struct/union
#pragma warning( disable : 4201 ) // nameless struct/union
#pragma warning( disable : 4214 ) // bit field types other than int
#pragma warning( disable : 4514 ) // unreferenced inline function has been removed

#include <wdm.h>

#pragma warning( disable : 4200 ) // zero-sized array in struct/union - (ntddk.h resets this to default)

#include <usbdi.h>
#include <usbdlib.h>
#include <parallel.h>
#include "d4ulog.h"
#include "dot4usb.h"
#include "funcdecl.h"
#include "debug.h"
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\funcdecl.h ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        FuncDecl.h

Abstract:

        Function Prototype Declarations

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/


//
// AddDev.c
//
NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );


//
// InitUnld.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );


//
// Ioctl.c
//
NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS
DispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );


//
// OpenClos.c
//
NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );


//
// PnP.c
//
NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
PnpDefaultHandler(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleStart(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleCancelRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleCancelStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryDeviceRelations(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleQueryCapabilities(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
PnpHandleSurpriseRemoval(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    );

NTSTATUS
VA_PnP(
    IN PDEVICE_EXTENSION devExt,
    PIRP irp
    );

NTSTATUS
GetDeviceCapabilities(
    IN PDEVICE_EXTENSION DevExt
    );


// power.c
NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
PowerComplete(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PVOID          Context
    );


//
// Registry.c
//
NTSTATUS
RegGetDword(
    IN     PCWSTR  KeyPath,
    IN     PCWSTR  ValueName,
    IN OUT PULONG  Value
    );

NTSTATUS
RegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PCWSTR          ValueName,
    IN OUT PULONG          Value
    );


//
// ReadWrit.c
//
NTSTATUS
DispatchRead(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS
DispatchWrite(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

//
// Test.c
//
VOID
TestEventLog(
    IN PDEVICE_OBJECT DevObj
    );

//
// Usb.c
//


NTSTATUS
UsbResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    );


NTSTATUS DOT4USB_ResetWorkItem(
    IN PDEVICE_OBJECT deviceObject,
    IN PVOID Context);

NTSTATUS
UsbBuildPipeList(
    IN  PDEVICE_OBJECT DeviceObject
    );

LONG
UsbGet1284Id(
    IN PDEVICE_OBJECT DevObj,
    PVOID             Buffer,
    LONG              BufferLength
    );

NTSTATUS
UsbBulkWrite(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
UsbBulkRead(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS
UsbCallUsbd(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout
    );

NTSTATUS
UsbGetDescriptor(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS
UsbConfigureDevice(
    IN PDEVICE_EXTENSION DevExt
    );

NTSTATUS
UsbSelectInterface(
    IN PDEVICE_OBJECT                DevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
UsbReadWrite(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    PUSBD_PIPE_INFORMATION  Pipe,
    USB_REQUEST_TYPE        RequestType
    );

NTSTATUS
UsbReadInterruptPipeLoopCompletionRoutine(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    devExt
    );

NTSTATUS
UsbStartReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    );

VOID
UsbStopReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    );

PURB
UsbBuildAsyncRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_PIPE_INFORMATION PipeHandle,
    IN BOOLEAN Read
    );

NTSTATUS
UsbAsyncReadWriteComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


//
// Util.c
//
NTSTATUS
DispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CallLowerDriverSync(
    IN PDEVICE_OBJECT  DevObj,
    IN PIRP            Irp
    );

NTSTATUS
CallLowerDriverSyncCompletion(
    IN PDEVICE_OBJECT  DevObjOrNULL,
    IN PIRP            Irp,
    IN PVOID           Context
    );

//
// Wmi.c
//
NTSTATUS
DispatchWmi(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\initunld.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        InitUnld.c

Abstract:

        Driver globals, initialization (DriverEntry) and Unload routines

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code review w/Joby

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


//
// Globals
//
UNICODE_STRING gRegistryPath = {0,0,0}; // yes globals are automatically initialized
ULONG          gTrace        = 0;       //   to 0's, but let's be explicit.
ULONG          gBreak        = 0;


/************************************************************************/
/* DriverEntry                                                          */
/************************************************************************/
//
// Routine Description:
//
//      - Save a copy of RegistryPath in a global gRegistryPath for use 
//          throughout the lifetime of the driver load.
//
//      - Initialize DriverObject function pointer table to point to
//          our entry points.
//
//      - Initialize Debug globals gTrace and gBreak based on registry
//          settings.
//
// Arguments: 
//
//      DriverObject - pointer to Dot4Usb.sys driver object
//      RegistryPath - pointer to RegistryPath for the driver, expected
//                       to be of the form (ControlSet may vary):
//                       \REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\dot4usb
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Save a copy of RegistryPath in global gRegistryPath for use
    //   over the lifetime of the driver load.
    //   - UNICODE_NULL terminate gRegistryPath.Buffer for added flexibility.
    //   - gRegistryPath.Buffer should be freed in DriverUnload()
    //

    { // new scope for gRegistryPath initialization - begin
        USHORT newMaxLength = (USHORT)(RegistryPath->Length + sizeof(WCHAR));
        PWSTR  p            = ExAllocatePool( PagedPool, newMaxLength );
        if( p ) {
            gRegistryPath.Length        = 0;
            gRegistryPath.MaximumLength = newMaxLength;
            gRegistryPath.Buffer        = p;
            RtlCopyUnicodeString( &gRegistryPath, RegistryPath );
            gRegistryPath.Buffer[ gRegistryPath.Length/2 ] = UNICODE_NULL;
        } else {
            TR_FAIL(("DriverEntry - exit - FAIL - no Pool for gRegistryPath.Buffer"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto targetExit;
        }
    } // new scope for gRegistryPath initialization - end



    // 
    // Initialize DriverObject function pointer table to point to our entry points.
    //
    // Start by initializing dispatch table to point to our passthrough function and 
    //   then override the entry points that we actually handle.
    //

    {// new scope for index variable - begin
        ULONG  i;
        for( i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++ ) {
            DriverObject->MajorFunction[i] = DispatchPassThrough;
        }
    } // new scope for index variable - end

    DriverObject->MajorFunction[ IRP_MJ_PNP                     ] = DispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER                   ] = DispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_CREATE                  ] = DispatchCreate;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE                   ] = DispatchClose;
    DriverObject->MajorFunction[ IRP_MJ_READ                    ] = DispatchRead;
    DriverObject->MajorFunction[ IRP_MJ_WRITE                   ] = DispatchWrite;
    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL          ] = DispatchDeviceControl;
    DriverObject->MajorFunction[ IRP_MJ_INTERNAL_DEVICE_CONTROL ] = DispatchInternalDeviceControl;

    DriverObject->DriverExtension->AddDevice                      = AddDevice;
    DriverObject->DriverUnload                                    = DriverUnload;


    //
    // Get driver debug settings (gTrace, gBreak) from registry
    //
    //   Expected Key Path is of the form (ControlSet may vary):
    //
    //   \REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\dot4usb
    //
    RegGetDword( gRegistryPath.Buffer, (PCWSTR)L"gBreak", &gBreak );
    RegGetDword( gRegistryPath.Buffer, (PCWSTR)L"gTrace", &gTrace );

    TR_LD_UNLD(("DriverEntry - RegistryPath = <%wZ>", RegistryPath));
    TR_LD_UNLD(("DriverEntry - gBreak=%x", gBreak));
    TR_LD_UNLD(("DriverEntry - gTrace=%x", gTrace));


    //
    // Check if user requested a breakpoint here. A breakpoint herew is
    //   typically used so that we can insert breakpoints on other
    //   functions or change debug settings to differ from those that we
    //   just read from the registry.
    //
    if( gBreak & BREAK_ON_DRIVER_ENTRY ) {
        DbgPrint( "D4U: Breakpoint requested via registry setting - (gBreak & BREAK_ON_DRIVER_ENTRY)\n" );
        DbgBreakPoint();
    }

targetExit:
    return status;
}


/************************************************************************/
/* DriverUnload                                                         */
/************************************************************************/
//
// Routine Description:
//
//      - Free any copy of RegistryPath that might have been saved in 
//          global gRegistryPath during DriverEntry().
//
// Arguments: 
//
//      DriverObject - pointer to Dot4Usb.sys driver object
//
// Return Value:                                          
//                                                        
//      NONE
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
    UNREFERENCED_PARAMETER( DriverObject );
    TR_LD_UNLD(("DriverUnload"));
    if( gRegistryPath.Buffer ) {
        RtlFreeUnicodeString( &gRegistryPath );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\pnp.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        PnP.c

Abstract:

        Plug and Play routines

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - function cleanup and documentation
        - code review

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"


NTSTATUS (*PnpDispatchTable[])(PDEVICE_EXTENSION,PIRP) = {
    PnpHandleStart,               // IRP_MN_START_DEVICE                 0x00
    PnpHandleQueryRemove,         // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    PnpHandleRemove,              // IRP_MN_REMOVE_DEVICE                0x02
    PnpHandleCancelRemove,        // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    PnpHandleStop,                // IRP_MN_STOP_DEVICE                  0x04
    PnpHandleQueryStop,           // IRP_MN_QUERY_STOP_DEVICE            0x05
    PnpHandleCancelStop,          // IRP_MN_CANCEL_STOP_DEVICE           0x06
    PnpHandleQueryDeviceRelations,// IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    PnpDefaultHandler,            // IRP_MN_QUERY_INTERFACE              0x08
    PnpHandleQueryCapabilities,   // IRP_MN_QUERY_CAPABILITIES           0x09
    PnpDefaultHandler,            // IRP_MN_QUERY_RESOURCES              0x0A
    PnpDefaultHandler,            // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    PnpDefaultHandler,            // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    PnpDefaultHandler,            // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    PnpDefaultHandler,            //   no defined IRP MN code            0x0E
    PnpDefaultHandler,            // IRP_MN_READ_CONFIG                  0x0F
    PnpDefaultHandler,            // IRP_MN_WRITE_CONFIG                 0x10
    PnpDefaultHandler,            // IRP_MN_EJECT                        0x11
    PnpDefaultHandler,            // IRP_MN_SET_LOCK                     0x12
    PnpDefaultHandler,            // IRP_MN_QUERY_ID                     0x13
    PnpDefaultHandler,            // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    PnpDefaultHandler,            // IRP_MN_QUERY_BUS_INFORMATION        0x15
    PnpDefaultHandler,            // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    PnpHandleSurpriseRemoval,     // IRP_MN_SURPRISE_REMOVAL             0x17
};


/************************************************************************/
/* DispatchPnp                                                          */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_PNP IRPs. Redirect IRPs to appropriate
//       handlers using the IRP_MN_* value as the key.
//
// Arguments: 
//
//     DevObj - pointer to DEVICE_OBJECT that is the target of the request
//     Irp    - pointer to IRP
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION  devExt = DevObj->DeviceExtension;
    NTSTATUS           status = IoAcquireRemoveLock( &devExt->RemoveLock , Irp );

    if( NT_SUCCESS( status ) ) {

        // Acquire RemoveLock succeeded
        PIO_STACK_LOCATION irpSp     = IoGetCurrentIrpStackLocation( Irp );
        ULONG              minorFunc = irpSp->MinorFunction;

        TR_VERBOSE(("DispatchPnp - RemoveLock acquired - DevObj= %x , Irp= %x", DevObj, Irp));

        //
        // Call appropriate handler based on PnP IRP_MN_xxx code
        //
        // note: Handler will complete the IRP
        //
        if( minorFunc >= arraysize(PnpDispatchTable) ) {
            status =  PnpDefaultHandler( devExt, Irp );
        } else {
            status =  PnpDispatchTable[ minorFunc ]( devExt, Irp );
        }

    } else {

        // Acquire RemoveLock failed
        TR_FAIL(("DispatchPnp - RemoveLock acquire FAILED - DevObj= %x , Irp= %x", DevObj, Irp));
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}


/************************************************************************/
/* PnpDefaultHandler                                                    */
/************************************************************************/
//
// Routine Description:
//
//     Default handler for PnP IRPs that this driver does not explicitly handle.
//
// Arguments: 
//
//     DevExt - pointer to DEVICE_EXTENSION of the DEVICE_OBJECT that is 
//                the target of the request
//     Irp    - pointer to IRP
//
// Return Value:                                          
//                                                        
//      NTSTATUS returned by IoCallDriver
//                                                        
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
PnpDefaultHandler(
    IN PDEVICE_EXTENSION  DevExt,
    IN PIRP               Irp
    )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation( Irp );

    TR_ENTER(("PnpDefaultHandler - IRP_MN = 0x%02x", irpSp->MinorFunction));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


/************************************************************************/
/* PnpHandleStart                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Handler for PnP IRP_MN_START_DEVICE.
//
// Arguments: 
//
//     DevExt - pointer to DEVICE_EXTENSION of the DEVICE_OBJECT that is 
//                the target of the request
//     Irp    - pointer to IRP
//
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
// Log:
//      2000-05-03 - Code Reviewed - TomGreen, JobyL, DFritz 
//                   - cleanup required - error handling incorrect, may
//                     result in driver attempting to use invalid and/or
//                     uninitialized data
//
/************************************************************************/
NTSTATUS
PnpHandleStart(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleStart"));

    DevExt->PnpState = STATE_STARTING;


    //
    // Driver stack below us must successfully start before we handle the Start IRP
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCopyCurrentIrpStackLocationToNext( Irp );
    status = CallLowerDriverSync( DevExt->DevObj, Irp );

    if( NT_SUCCESS(status) ) {

        //
        // Driver stack below us has successfully started, continue
        //

        //
        // Get a copy of the DEVICE_CAPABILITIES of the stack us and
        //   save it in our DEVICE_EXTENSION for future reference.
        //
        status = GetDeviceCapabilities( DevExt );

        if( NT_SUCCESS(status) ) {

            // get USB descriptor
            status =  UsbGetDescriptor( DevExt );
            if( !NT_SUCCESS(status) ) {
                TR_VERBOSE(("call to UsbGetDescriptor FAILED w/status = %x",status));
                status = STATUS_SUCCESS; // start anyway
            } else {
                TR_VERBOSE(("call to UsbGetDescriptor - SUCCESS"));
            }

            // Configure Device
            status =  UsbConfigureDevice( DevExt );
            if( !NT_SUCCESS(status) ) {
                TR_VERBOSE(("call to UsbConfigureDevice FAILED w/status = %x",status));
                status = STATUS_SUCCESS; // start anyway
            } else {
                TR_VERBOSE(("call to UsbConfigureDevice - SUCCESS"));
            }

            // get 1284 ID - just for kicks :-)
            {
                UCHAR Buffer[256];
                LONG  retCode;
                RtlZeroMemory(Buffer, sizeof(Buffer));
                retCode = UsbGet1284Id(DevExt->DevObj, Buffer, sizeof(Buffer)-1);
                TR_VERBOSE(("retCode = %d",retCode));
                TR_VERBOSE(("strlen  = %d", strlen((PCSTR)&Buffer[2])));
                TR_VERBOSE(("1284ID = <%s>",&Buffer[2]));
            }

            // get Pipes
            UsbBuildPipeList( DevExt->DevObj );

            // we are now STARTED
            DevExt->PnpState = STATE_STARTED;

        } else {
            DevExt->PnpState = STATE_START_FAILED;
        }
    } else {

        //
        // Driver stack below us has FAILED the Start, we fail too
        //
        DevExt->PnpState = STATE_START_FAILED;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleQueryRemove"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS status;
    KIRQL    oldIrql;

    TR_ENTER(("PnpHandleRemove"));

    DevExt->PnpState = STATE_REMOVED;

    UsbStopReadInterruptPipeLoop( DevExt->DevObj ); // stop polling Irp if any

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp);
    TR_TMP1(("PnpHandleRemove - Calling IoReleaseRemoveLockAndWait"));
    IoReleaseRemoveLockAndWait( &DevExt->RemoveLock, Irp );
    TR_TMP1(("PnpHandleRemove - Returned from IoReleaseRemoveLockAndWait"));
    IoDetachDevice( DevExt->LowerDevObj );

    // BUGBUG - verify that code in rest of driver that touches Interface
    // locks the extension while using it to prevent this function from
    // freeing the interface out from under them causing an AV
    KeAcquireSpinLock( &DevExt->SpinLock, &oldIrql );
    if( DevExt->Interface ) {
        PVOID ptr = DevExt->Interface;
        DevExt->Interface = NULL;
        KeReleaseSpinLock( &DevExt->SpinLock, oldIrql );
        ExFreePool( ptr );
    } else {
        KeReleaseSpinLock( &DevExt->SpinLock, oldIrql );
    }

    IoDeleteDevice( DevExt->DevObj );
    return status;
}


NTSTATUS
PnpHandleCancelRemove(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleCancelRemove"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleStop"));

    if( DevExt->PnpState == STATE_STARTED ) {
        DevExt->PnpState = STATE_STOPPED;
    }
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleQueryStop"));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleCancelStop(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleStop"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryDeviceRelations(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleQueryDeviceRelations"));

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleQueryCapabilities(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS           status;

    TR_ENTER(("PnpHandleQueryCapabilities"));

    IoCopyCurrentIrpStackLocationToNext( Irp );

    status = CallLowerDriverSync( DevExt->DevObj, Irp );

    if( NT_SUCCESS( status ) ) {
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
        irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
    }

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
PnpHandleSurpriseRemoval(
    IN PDEVICE_EXTENSION DevExt,
    IN PIRP              Irp
    )
{
    NTSTATUS          status;

    TR_ENTER(("PnpHandleSurpriseRemoval"));

    DevExt->PnpState = STATE_REMOVING;
    TR_TMP1(("PnpHandleSurpriseRemoval"));
    UsbStopReadInterruptPipeLoop( DevExt->DevObj ); // stop polling Irp if any
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( DevExt->LowerDevObj, Irp );
    IoReleaseRemoveLock( &DevExt->RemoveLock, Irp );
    return status;
}


NTSTATUS
GetDeviceCapabilities(
    IN PDEVICE_EXTENSION DevExt
    )
{
    NTSTATUS status;
    PIRP     irp = IoAllocateIrp(DevExt->LowerDevObj->StackSize, FALSE);

    if( irp ) {

        PIO_STACK_LOCATION irpSp = IoGetNextIrpStackLocation( irp );

        // must initialize DeviceCapabilities before sending...
        RtlZeroMemory(  &DevExt->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
        DevExt->DeviceCapabilities.Size     = sizeof(DEVICE_CAPABILITIES);
        DevExt->DeviceCapabilities.Version  = 1;
        DevExt->DeviceCapabilities.Address  = (ULONG) -1;
        DevExt->DeviceCapabilities.UINumber = (ULONG) -1;

        // set up next irp stack location...
        irpSp->MajorFunction = IRP_MJ_PNP;
        irpSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        irpSp->Parameters.DeviceCapabilities.Capabilities = &DevExt->DeviceCapabilities;

        // required initial status
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = IoAcquireRemoveLock( &DevExt->RemoveLock, irp );
        if( NT_SUCCESS(status) ) {
            status = CallLowerDriverSync( DevExt->DevObj, irp );
            IoReleaseRemoveLock( &DevExt->RemoveLock, irp );
        } else {
            TR_VERBOSE(("We're in the process of being removed - abort"));
            status = STATUS_DELETE_PENDING;
        }

        IoFreeIrp( irp );

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\power.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Power.c

Abstract:

        Power management functions

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code cleanup and documentation
        - code review

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"

VOID
SetPowerIrpCompletion(IN PDEVICE_OBJECT   DeviceObject,
                      IN UCHAR            MinorFunction,
                      IN POWER_STATE      PowerState,
                      IN PVOID            Context,
                      IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS
PowerD0Completion(IN PDEVICE_OBJECT   DeviceObject,
                  IN PIRP             Irp,
                  IN PVOID            Context);


NTSTATUS 
DispatchPower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS                status;
    POWER_STATE             powerState;
    POWER_STATE             newState;
    POWER_STATE             oldState;
    BOOLEAN                 passRequest  = TRUE;

    TR_VERBOSE(("DispatchPower, MinorFunction = %x", (ULONG)irpSp->MinorFunction));

    //
    // Acquire RemoveLock to prevent us from being Removed
    //
    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );
    if( !NT_SUCCESS(status) ) 
    {
        // couldn't aquire RemoveLock - we're in the process of being removed - abort
        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }


    powerState = irpSp->Parameters.Power.State;

    switch (irpSp->MinorFunction) 
    {

    case IRP_MN_SET_POWER:

        switch(irpSp->Parameters.Power.Type) 
        {

        case SystemPowerState:
            // save the current system state
            devExt->SystemPowerState = powerState.SystemState;

            // map the new system state to a new device state
            if(powerState.SystemState != PowerSystemWorking)
            {
                newState.DeviceState = PowerDeviceD3;
            }
            else
            {
                newState.DeviceState = PowerDeviceD0;
            }

            if(devExt->DevicePowerState != newState.DeviceState)
            {
                // save the current power Irp for sending down later
                devExt->CurrentPowerIrp = Irp;

                // send a power Irp to set new device state
                status = PoRequestPowerIrp(devExt->Pdo,
                                           IRP_MN_SET_POWER,
                                           newState,
                                           SetPowerIrpCompletion,
                                           (PVOID) devExt,
                                           NULL);
                
                // this will get passed down in the completion routine
                passRequest  = FALSE;
            }

            break;

        case DevicePowerState:

            // Update the current device state.
            oldState.DeviceState = devExt->DevicePowerState;
            devExt->DevicePowerState = powerState.DeviceState;

            // powering up
            if(oldState.DeviceState > PowerDeviceD0 &&
               powerState.DeviceState == PowerDeviceD0)
            {
                // we need to know when this completes and our device is at the proper state
                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       PowerD0Completion,
                                       devExt,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = PoCallDriver(devExt->LowerDevObj, Irp);

                // we already passed this one down
                passRequest = FALSE;

            }
            else
            {
                // powering down, jsut set a flag and pass the request down
                if(devExt->PnpState == STATE_STARTED) 
                {
                    devExt->PnpState = STATE_SUSPENDED;
                }

                passRequest = TRUE;
            }

            break;
        }
    }


    if(passRequest)
    {
        //
        // Send the IRP down the driver stack,
        //
        IoCopyCurrentIrpStackLocationToNext( Irp );

        PoStartNextPowerIrp(Irp);

        // release lock
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

        status = PoCallDriver( devExt->LowerDevObj, Irp );        
    }

    return status;
}

VOID
SetPowerIrpCompletion(IN PDEVICE_OBJECT   DeviceObject,
                      IN UCHAR            MinorFunction,
                      IN POWER_STATE      PowerState,
                      IN PVOID            Context,
                      IN PIO_STATUS_BLOCK IoStatus)
{
    PDEVICE_EXTENSION       devExt;
    PIRP                    irp;
    NTSTATUS                ntStatus;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( MinorFunction );
    UNREFERENCED_PARAMETER( PowerState );
    UNREFERENCED_PARAMETER( IoStatus );

    devExt = (PDEVICE_EXTENSION) Context;

    // get the current power irp
    irp = devExt->CurrentPowerIrp;

    devExt->CurrentPowerIrp = NULL;

    // the requested DevicePowerState Irp has completed, so send the system power Irp down
    PoStartNextPowerIrp(irp);

    IoCopyCurrentIrpStackLocationToNext(irp);

    // mark the Irp pending
    IoMarkIrpPending(irp);

    // release the lock
    IoReleaseRemoveLock( &devExt->RemoveLock, irp );

    ntStatus = PoCallDriver(devExt->LowerDevObj, irp);
}

NTSTATUS
PowerD0Completion(IN PDEVICE_OBJECT   DeviceObject,
                  IN PIRP             Irp,
                  IN PVOID            Context)
{
    PDEVICE_EXTENSION       devExt;
    NTSTATUS                ntStatus;

    UNREFERENCED_PARAMETER( DeviceObject );

    devExt = (PDEVICE_EXTENSION) Context;

    // the device is powered up, set out state
    if(devExt->PnpState == STATE_SUSPENDED) 
    {
        devExt->PnpState = STATE_STARTED;
    }


    ntStatus = Irp->IoStatus.Status;

    // release the lock
    IoReleaseRemoveLock( &devExt->RemoveLock, Irp );

    PoStartNextPowerIrp(Irp);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\readwrit.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        ReadWrit.c

Abstract:

        Dispatch routines for IRP_MJ_READ and IRP_MJ_WRITE

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - IoReleaseRemoveLock() calls need to be moved to USB completion routine
        - code review w/Joby

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchRead                                                         */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_READ - Validate parameters and forward
//       valid requests to USB handler.
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the request
//      Irp    - pointer to read request
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchRead(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    NTSTATUS                status;
    PUSBD_PIPE_INFORMATION  pipe;
    BOOLEAN                 bReleaseRemLockOnFail = FALSE;

    TR_VERBOSE(("DispatchRead - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );
    if( STATUS_SUCCESS != status ) {
        // couldn't aquire RemoveLock - FAIL request
        bReleaseRemLockOnFail = FALSE;
        goto targetFail;
    }

    bReleaseRemLockOnFail = TRUE; // We now have the RemoveLock

    if( !Irp->MdlAddress ) {
        // no MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }
    
    if( !MmGetMdlByteCount(Irp->MdlAddress) ) {
        // zero length MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }

    pipe = devExt->ReadPipe;
    if( !pipe ) {
        // we don't have a read pipe? - something is seriously wrong
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }

    if( UsbdPipeTypeBulk != pipe->PipeType ) {
        // our read pipe is not a bulk pipe?
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }


    //
    // If we got here we survived the sanity checks - continue processing
    //

    status = UsbReadWrite( DevObj, Irp, pipe, UsbReadRequest );
    //IoReleaseRemoveLock( &devExt->RemoveLock, Irp ); // Moved this to completion routine
    goto targetExit;

targetFail:
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    if( bReleaseRemLockOnFail ) {
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    }

targetExit:
    return status;
}


/************************************************************************/
/* DispatchWrite                                                        */
/************************************************************************/
//
// Routine Description:
//
//     Dispatch routine for IRP_MJ_WRITE - Validate parameters and forward
//       valid requests to USB handler.
//
// Arguments: 
//
//      DevObj - pointer to Device Object that is the target of the request
//      Irp    - pointer to write request
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
DispatchWrite(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    NTSTATUS                status;
    PUSBD_PIPE_INFORMATION  pipe;
    BOOLEAN                 bReleaseRemLockOnFail;

    TR_VERBOSE(("DispatchWrite - enter"));

    status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );
    if( STATUS_SUCCESS != status ) {
        // couldn't aquire RemoveLock - FAIL request
        bReleaseRemLockOnFail = FALSE;
        goto targetFail;
    }

    bReleaseRemLockOnFail = TRUE; // We now have the RemoveLock

    if( !Irp->MdlAddress ) {
        // no MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }
    
    if( !MmGetMdlByteCount(Irp->MdlAddress) ) {
        // zero length MDL - FAIL request
        status = STATUS_INVALID_PARAMETER;
        goto targetFail;
    }

    pipe = devExt->WritePipe;
    if( !pipe ) {
        // we don't have a write pipe? - something is seriously wrong - FAIL request
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }

    if( UsbdPipeTypeBulk != pipe->PipeType ) {
        // our write pipe is not a bulk pipe? - FAIL request
        D4UAssert(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto targetFail;
    }

    //
    // If we got here we survived the sanity checks - continue processing
    //

    status = UsbReadWrite( DevObj, Irp, pipe, UsbWriteRequest );
   // IoReleaseRemoveLock( &devExt->RemoveLock, Irp ); // moved this to completion routine
    goto targetExit;

targetFail:
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    if( bReleaseRemLockOnFail ) {
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    }

targetExit:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\test.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Test.c

Abstract:

        Test/Diagnostic/Experimentation routines - These routines are NOT
          required for the normal operation of the driver.

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


VOID
TestEventLog( 
    IN PDEVICE_OBJECT DevObj 
    )
/*
  Demonstrate Event log usage - entries are made up using unique values 
  to make it easier to determine the corresponding offsets in the event 
  log entry "Data:" section. Sample event log entry resulting from this
  call was:
  ----
    Event Type:	Information
    Event Source:	dot4usb
    Event Category:	None
    Event ID:	16
    Date:		1/17/2000
    Time:		3:04:34 PM
    User:		N/A
    Computer:	DFRITZ3DJ
    Description:
    Dot4Usb AddDevice - test event log message <ThisIsMsgForParam2> <ThisIsMsgForParam3>. 
    Data:
    0000: 00040109 00580003 00000000 40070010
    0010: 00000017 c0000022 00000005 00000000
    0020: 98762222 abcd1111 12345678 
  ----

  A recommended place to call this from is from AddDevice

*/
{
    WCHAR                msg[]  = L"ThisIsMsgForParam2\0ThisIsMsgForParam3";
    PIO_ERROR_LOG_PACKET log    = IoAllocateErrorLogEntry( DevObj, sizeof(IO_ERROR_LOG_PACKET)+sizeof(msg) );

    if( log ) {
        log->MajorFunctionCode     = (UCHAR) IRP_MJ_FLUSH_BUFFERS; // 9
        log->RetryCount            = (UCHAR) 1;
        log->DumpDataSize          = (USHORT)4;
        log->NumberOfStrings       = (USHORT)2;
        log->StringOffset          = (USHORT)sizeof(IO_ERROR_LOG_PACKET);
        log->EventCategory         = (USHORT)0;
        log->ErrorCode             = (NTSTATUS)D4U_ADDDEV; // IO_ERR_xxx - 0x40070010
        log->UniqueErrorValue      = (ULONG)0x17; // made up
        log->FinalStatus           = (NTSTATUS)STATUS_ACCESS_DENIED; // 0xC0000022 - easy to remember
        log->SequenceNumber        = (ULONG)5; // made up
        log->IoControlCode         = (ULONG)0;
        log->DeviceOffset.HighPart = 0xabcd1111;
        log->DeviceOffset.LowPart  = 0x98762222;
        log->DumpData[0]           = 0x12345678;
        RtlCopyMemory( (PCHAR)log + sizeof(IO_ERROR_LOG_PACKET), msg, sizeof(msg));
        IoWriteErrorLogEntry( log );
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\registry.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Registry.c

Abstract:

        Registry access utility functions

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Doug Fritz (DFritz)
        Joby Lafky (JobyL)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* RegGetDword                                                          */
/************************************************************************/
//
// Routine Description:
//
//      - Read a DWORD value from the registry (with caller specified 
//          default value) given an absolute KeyPath. 
// 
//      - If we are unable to read the value from the registry for any
//          reason (e.g., no ValueName entry exists) then return the
//          default value passed into the function in *Value.
//
// Arguments: 
//
//      KeyPath   - absolute path to registry key
//      ValueName - name of the value to retrieve
//      Value     - in  - points to a default value
//                - out - points to the location for returned value
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
RegGetDword(
    IN     PCWSTR  KeyPath,
    IN     PCWSTR  ValueName,
    IN OUT PULONG  Value
    )
{
    NTSTATUS                  status;
    RTL_QUERY_REGISTRY_TABLE  paramTable[2];

    D4UAssert( KeyPath && ValueName && Value );

    RtlZeroMemory( &paramTable[0], sizeof(paramTable) );
    
    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = (PWSTR)ValueName; // cast away const
    paramTable[0].EntryContext  = Value;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = Value;
    paramTable[0].DefaultLength = sizeof(ULONG);
    
    // leave paramTable[1] as all zeros - this terminates the table
    
    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     KeyPath,
                                     &paramTable[0],
                                     NULL,
                                     NULL );

    TR_VERBOSE(("registry::RegGetDword - status = %x , *Value = %x\n", status, *Value));

    return status;
}


/************************************************************************/
/* RegGetDeviceParameterDword                                           */
/************************************************************************/
//
// Routine Description:
//
//      - Read a DWORD value from the registry (with caller specified 
//          default value) given a PDO. 
// 
//      - If we are unable to read the value from the registry for any
//          reason (e.g., no ValueName entry exists) then return the
//          default value passed into the function in *Value.
//
// Arguments: 
//
//      Pdo       - PDO for which we want to read the device parameter
//      ValueName - name of the value to retrieve
//      Value     - in  - points to a default value
//                - out - points to the location for returned value
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
RegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PCWSTR          ValueName,
    IN OUT PULONG          Value
    )
{
    NTSTATUS                 status;
    HANDLE                   hKey;

    D4UAssert( Pdo && ValueName && Value );

    status = IoOpenDeviceRegistryKey( Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hKey );

    if( NT_SUCCESS(status) ) {

        RTL_QUERY_REGISTRY_TABLE queryTable[2];

        RtlZeroMemory(&queryTable, sizeof(queryTable));
        
        queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name          = (PWSTR)ValueName; // cast away const
        queryTable[0].EntryContext  = Value;
        queryTable[0].DefaultType   = REG_DWORD;
        queryTable[0].DefaultData   = Value;
        queryTable[0].DefaultLength = sizeof(ULONG);
        
        status = RtlQueryRegistryValues( RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                         hKey,
                                         queryTable,
                                         NULL,
                                         NULL );        

        ZwClose(hKey);

        TR_VERBOSE(("registry::RegGetDeviceParameterDword - status = %x , *Value = %x\n", status, *Value));
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\usb.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Usb.c

Abstract:

        Interface USB DeviceObject below us

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"


NTSTATUS
UsbBuildPipeList(
    IN  PDEVICE_OBJECT DevObj
    )
    // Parse the interface descriptor to find the pipes that we want 
    //   to use and save pointers to those pipes in our extension for 
    //   easier access
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    PUSBD_INTERFACE_INFORMATION InterfaceDescriptor;
    ULONG i;
    KIRQL oldIrql;
    NTSTATUS status = STATUS_SUCCESS;
    
    TR_VERBOSE(("UsbBuildPipeList - enter"));

    // need to lock extension to prevent Remove handler from freeing
    // Interface out from under us causing an AV
    KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
    InterfaceDescriptor = devExt->Interface;
    if( !InterfaceDescriptor ) {
        KeReleaseSpinLock( &devExt->SpinLock, oldIrql );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetExit;
    }

    for( i=0; i<InterfaceDescriptor->NumberOfPipes; i++ ) {
        TR_VERBOSE(("about to look at endpoint with address 0x%x)",InterfaceDescriptor->Pipes[i].EndpointAddress));
        if(((InterfaceDescriptor->Pipes[i].EndpointAddress)&0x80)==0) {

            // EndPointAddress bit 7 == 0 means OUT endpoint - WritePipe
            TR_VERBOSE(("Found write pipe"));
            devExt->WritePipe = &(InterfaceDescriptor->Pipes[i]);

        } else {

            // EndPointAddress bit 7 == 1 means IN endpoint - ReadPipe
            if( InterfaceDescriptor->Pipes[i].PipeType == UsbdPipeTypeBulk ) { 
                TR_VERBOSE(("Found bulk read pipe"));
                devExt->ReadPipe = &(InterfaceDescriptor->Pipes[i]);
            } else if( InterfaceDescriptor->Pipes[i].PipeType == UsbdPipeTypeInterrupt ) { 
                TR_VERBOSE(("Found interrupt read pipe"));
                devExt->InterruptPipe = &(InterfaceDescriptor->Pipes[i]);
            }
        }
    }

    KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

targetExit:
    return status;
}


LONG
UsbGet1284Id(
    IN PDEVICE_OBJECT DevObj,
    PVOID             Buffer,
    LONG              BufferLength
    )
/*++

Routine Description:
  Requests and returns Printer 1284 Device ID

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer device.
        pIoBuffer    - pointer to IO buffer from user mode
        iLen         - Length of *pIoBuffer;




Return Value:

    Success: Length of data written to *pIoBuffer (icluding lenght field in first two bytes of data)
        Failure: -1

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    LONG iReturn = -1;
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    LARGE_INTEGER   timeOut;
    KIRQL           oldIrql;

    TR_VERBOSE(("UsbGet1284Id - enter"));

    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));

    if( !urb ) {
        iReturn = -1;
        goto targetExit;
    }

    KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
    if( !devExt->Interface ) {
        KeReleaseSpinLock( &devExt->SpinLock, oldIrql );
        iReturn = -1;
        goto targetCleanup;
    }

    UsbBuildVendorRequest( urb,
                           URB_FUNCTION_CLASS_INTERFACE, //request target
                           sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), //request len
                           USBD_TRANSFER_DIRECTION_IN|USBD_SHORT_TRANSFER_OK, //flags
                           0, //reserved bits
                           0, //request code
                           0, //wValue
                           (USHORT)(devExt->Interface->InterfaceNumber<<8), //wIndex
                           Buffer, //return buffer address
                           NULL, //mdl
                           BufferLength,  //return length
                           NULL); //link param

    KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

    timeOut.QuadPart = FAILURE_TIMEOUT;
    ntStatus = UsbCallUsbd(DevObj, urb, &timeOut);
    TR_VERBOSE(("urb->Hdr.Status=%d",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));

    if( NT_SUCCESS(ntStatus) && urb->UrbControlVendorClassRequest.TransferBufferLength > 2) {
        iReturn= (LONG)(*((unsigned char *)Buffer));
        iReturn<<=8;
        iReturn+=(LONG)(*(((unsigned char *)Buffer)+1));
        if ( iReturn > 0 && iReturn < BufferLength ) {
            *(((char *)Buffer)+iReturn)='\0';
        } else {
            iReturn = -1;
        }
    } else {
        iReturn=-1;
    }

targetCleanup:
    ExFreePool(urb);

targetExit:
    TR_VERBOSE(("UsbGet1284Id - exit w/return value = decimal %d",iReturn));
    return iReturn;
}


NTSTATUS
UsbGetDescriptor(
    IN PDEVICE_EXTENSION DevExt
    )
    // get USB descriptor
{
    NTSTATUS               status = STATUS_SUCCESS;
    PURB                   urb = ExAllocatePool(NonPagedPool, sizeof(URB));
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    ULONG                  siz;
    LARGE_INTEGER          timeOut;

    TR_VERBOSE(("UsbGetDescriptor - enter"));

    if( urb ) {
        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool,siz);
        if (deviceDescriptor) {
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_DEVICE_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         deviceDescriptor,
                                         NULL,
                                         siz,
                                         NULL);
            
            timeOut.QuadPart = FAILURE_TIMEOUT;
            status = UsbCallUsbd(DevExt->DevObj, urb, &timeOut);
        }
    } else {
        TR_VERBOSE(("UsbGetDescriptor - no pool for urb"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( NT_SUCCESS(status) ) {
        TR_VERBOSE(("Device Descriptor = %x, len %x", deviceDescriptor, urb->UrbControlDescriptorRequest.TransferBufferLength));
        TR_VERBOSE(("bLength........... 0x%x", deviceDescriptor->bLength));
        TR_VERBOSE(("bDescriptorType    0x%x", deviceDescriptor->bDescriptorType));
        TR_VERBOSE(("bcdUSB             0x%x", deviceDescriptor->bcdUSB));
        TR_VERBOSE(("bDeviceClass       0x%x", deviceDescriptor->bDeviceClass));
        TR_VERBOSE(("bDeviceSubClass....0x%x", deviceDescriptor->bDeviceSubClass));
        TR_VERBOSE(("bDeviceProtocol    0x%x", deviceDescriptor->bDeviceProtocol));
        TR_VERBOSE(("bMaxPacketSize0    0x%x", deviceDescriptor->bMaxPacketSize0));
        TR_VERBOSE(("idVendor           0x%x", deviceDescriptor->idVendor));
        TR_VERBOSE(("idProduct......... 0x%x", deviceDescriptor->idProduct));
        TR_VERBOSE(("bcdDevice          0x%x", deviceDescriptor->bcdDevice));
        TR_VERBOSE(("iManufacturer      0x%x", deviceDescriptor->iManufacturer));
        TR_VERBOSE(("iProduct           0x%x", deviceDescriptor->iProduct));
        TR_VERBOSE(("iSerialNumber..... 0x%x", deviceDescriptor->iSerialNumber));
        TR_VERBOSE(("bNumConfigurations 0x%x", deviceDescriptor->bNumConfigurations));
    }

    if( urb ) {
        ExFreePool( urb );
        urb = NULL;
    }
    if( deviceDescriptor ) {
        ExFreePool( deviceDescriptor );
        deviceDescriptor = NULL;
    }

    return status;
}

NTSTATUS
UsbConfigureDevice(
    IN PDEVICE_EXTENSION DevExt
    )
{
    NTSTATUS                      status;
    PURB                          urb;
    ULONG                         siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    LARGE_INTEGER                 timeOut;

    timeOut.QuadPart = FAILURE_TIMEOUT;
    
    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    
    if (urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR)+256;
        
get_config_descriptor_retry:
        
        configurationDescriptor = ExAllocatePool(NonPagedPool,siz);
        
        if (configurationDescriptor) {
            
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         siz,
                                         NULL);
            
            status = UsbCallUsbd(DevExt->DevObj, urb, &timeOut);
            if(!NT_SUCCESS(status)) {
                TR_VERBOSE(("Get Configuration descriptor failed"));
            } else {
                //
                // if we got some data see if it was enough.
                //
                // NOTE: we may get an error in URB because of buffer overrun
                if( ( urb->UrbControlDescriptorRequest.TransferBufferLength > 0 ) &&
                    ( configurationDescriptor->wTotalLength > siz ) ) {

                    siz = configurationDescriptor->wTotalLength;
                    ExFreePool(configurationDescriptor);
                    configurationDescriptor = NULL;
                    goto get_config_descriptor_retry;
                }
            }
            
            TR_VERBOSE(("Configuration Descriptor = %x, len %x", 
                    configurationDescriptor, urb->UrbControlDescriptorRequest.TransferBufferLength));
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
                
        ExFreePool( urb );
        
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    if( configurationDescriptor ) {
        
        //
        // We have the configuration descriptor for the configuration
        // we want.
        //
        // Now we issue the select configuration command to get
        // the  pipes associated with this configuration.
        //
        if( NT_SUCCESS(status) ) {
            TR_VERBOSE(("got a configurationDescriptor - next try to select interface"));
            status = UsbSelectInterface( DevExt->DevObj, configurationDescriptor );
        }
        ExFreePool( configurationDescriptor );
    }
    
    TR_VERBOSE(("dbgUSB2 - exit w/status = %x", status));
    
    return status;
}

NTSTATUS 
UsbSelectInterface(
    IN PDEVICE_OBJECT                DevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS status;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
    PUSBD_INTERFACE_INFORMATION Interface = NULL;
    USBD_INTERFACE_LIST_ENTRY InterfaceList[2];
    LARGE_INTEGER   timeOut;

    timeOut.QuadPart = FAILURE_TIMEOUT;

    TR_VERBOSE(("dbgUSB3 - enter"));
    
    //
    // Look for a *.*.3 interface in the ConfigurationDescriptor
    //
    interfaceDescriptor = USBD_ParseConfigurationDescriptorEx( ConfigurationDescriptor,
                                                               ConfigurationDescriptor,
                                                               -1, // InterfaceNumber   - ignore 
                                                               -1, // AlternateSetting  - ignore 
                                                               -1, // InterfaceClass    - ignore 
                                                               -1, // InterfaceSubClass - ignore  
                                                                3  // InterfaceProtocol
                                                               );
    if( !interfaceDescriptor ) {
        TR_VERBOSE(("ParseConfigurationDescriptorEx FAILED"));
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
        goto targetExit;
    }

    TR_VERBOSE(("ParseConfigurationDescriptorEx SUCCESS"));

    InterfaceList[0].InterfaceDescriptor=interfaceDescriptor;
    InterfaceList[1].InterfaceDescriptor=NULL;

    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor,InterfaceList);
    if( !urb ) {
        TR_VERBOSE(("no pool for URB - dbgUSB3"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetExit;
    }

    Interface = InterfaceList[0].Interface;

    // handle larger transfers on pipes (perf requirement by scanning)
    {
        PUSBD_INTERFACE_INFORMATION myInterface = &urb->UrbSelectConfiguration.Interface;
        ULONG i;
        ULONG pipeCount = Interface->NumberOfPipes;
        ULONG newMax = 128 * 1024 - 1;
        for( i=0 ; i < pipeCount ; ++i ) {
            myInterface->Pipes[i].MaximumTransferSize = newMax;
        }
    }

    status = UsbCallUsbd(DevObj, urb, &timeOut);

    if (NT_SUCCESS(status)) {
        
        //
        // Save the configuration handle for this device
        //
        
        devExt->ConfigHandle = urb->UrbSelectConfiguration.ConfigurationHandle;

        devExt->Interface = ExAllocatePool(NonPagedPool,Interface->Length);
        
        if( devExt->Interface ) {
            ULONG j;
            //
            // save a copy of the interface information returned
            //
            RtlCopyMemory(devExt->Interface, Interface, Interface->Length);
            
            //
            // Dump the interface to the debugger
            //
            TR_VERBOSE(("NumberOfPipes             0x%x", devExt->Interface->NumberOfPipes));
            TR_VERBOSE(("Length                    0x%x", devExt->Interface->Length));
            TR_VERBOSE(("Alt Setting               0x%x", devExt->Interface->AlternateSetting));
            TR_VERBOSE(("Interface Number          0x%x", devExt->Interface->InterfaceNumber));
            TR_VERBOSE(("Class, subclass, protocol 0x%x 0x%x 0x%x", 
                    devExt->Interface->Class, devExt->Interface->SubClass, devExt->Interface->Protocol));

            // Dump the pipe info
            for( j=0; j<Interface->NumberOfPipes; ++j ) {
                PUSBD_PIPE_INFORMATION pipeInformation;
                
                pipeInformation = &devExt->Interface->Pipes[j];
                
                TR_VERBOSE(("PipeType            0x%x", pipeInformation->PipeType));
                TR_VERBOSE(("EndpointAddress     0x%x", pipeInformation->EndpointAddress));
                TR_VERBOSE(("MaxPacketSize       0x%x", pipeInformation->MaximumPacketSize));
                TR_VERBOSE(("Interval            0x%x", pipeInformation->Interval));
                TR_VERBOSE(("Handle              0x%x", pipeInformation->PipeHandle));
                TR_VERBOSE(("MaximumTransferSize 0x%x", pipeInformation->MaximumTransferSize));
            }
            
        } else {
            TR_VERBOSE(("Alloc failed in SelectInterface"));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    if( urb ) {
        ExFreePool( urb );
    }
    
 targetExit:

    TR_VERBOSE(("dbgUSB3 exit w/status = %x", status));

    return status;
}


PURB
UsbBuildAsyncRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_PIPE_INFORMATION PipeHandle,
    IN BOOLEAN Read
    )
// return an initialized async URB, or NULL on error
{
    ULONG siz;
    PURB  urb;

    UNREFERENCED_PARAMETER( DeviceObject );

    if( NULL == Irp->MdlAddress ) {
        return NULL;
    }

    siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb = ExAllocatePool( NonPagedPool, siz );

    if( urb ) {
	RtlZeroMemory(urb, siz);
	urb->UrbBulkOrInterruptTransfer.Hdr.Length    = (USHORT) siz;
	urb->UrbBulkOrInterruptTransfer.Hdr.Function  = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.PipeHandle    = PipeHandle->PipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferFlags = Read ? USBD_TRANSFER_DIRECTION_IN : 0;

	// short packet is not treated as an error.
	urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;            
		
	// no linkage for now
	urb->UrbBulkOrInterruptTransfer.UrbLink              = NULL;

	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL    = Irp->MdlAddress;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength = MmGetMdlByteCount(Irp->MdlAddress);
    }

    return urb;
}


NTSTATUS
UsbAsyncReadWriteComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the USBPRINT device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS         status    = STATUS_SUCCESS;
    PUSB_RW_CONTEXT  rwContext = Context;
    PURB             urb;
    LONG ResetPending;
    PDOT4USB_WORKITEM_CONTEXT pResetWorkItemObj;
    PDEVICE_EXTENSION deviceExtension;

        
    deviceExtension=DeviceObject->DeviceExtension;


    if (Irp->PendingReturned) {
	IoMarkIrpPending(Irp);
    }

    urb  = rwContext->Urb;
    
    TR_VERBOSE(("UsbAsyncReadWriteComplete - enter - TransferBufferLength= %d, UrbStatus= 0x%08X",
		     urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
		     urb->UrbHeader.Status));

    status=urb->UrbHeader.Status;

    // set the length based on the TransferBufferLength value in the URB
    Irp->IoStatus.Information = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

    if((!NT_SUCCESS(status))&&(status!=STATUS_CANCELLED)&&(status!=STATUS_DEVICE_NOT_CONNECTED))
    {
        ResetPending=InterlockedCompareExchange(&deviceExtension->ResetWorkItemPending,1,0);  //Check to see if ResetWorkItem is 0, if so, set it to 1, and start a Reset
        if(!ResetPending)
        {
            pResetWorkItemObj=ExAllocatePool(NonPagedPool,sizeof(DOT4USB_WORKITEM_CONTEXT));
            if(pResetWorkItemObj)
            {
                pResetWorkItemObj->ioWorkItem=IoAllocateWorkItem(DeviceObject);
                if(pResetWorkItemObj==NULL)
                {
                    TR_FAIL(("DOT4USB.SYS: Unable to allocate IoAllocateWorkItem in ReadWrite_Complete\n"));
                    ExFreePool(pResetWorkItemObj);
                    pResetWorkItemObj=NULL;
                }
            } //if ALloc RestWorkItem OK
            else
            {
              TR_FAIL(("DOT4USB.SYS: Unable to allocate WorkItemObj in ReadWrite_Complete\n"));
            }
            if(pResetWorkItemObj)
            {
               pResetWorkItemObj->irp=Irp;
               pResetWorkItemObj->deviceObject=DeviceObject;
               if(rwContext->IsWrite)
                   pResetWorkItemObj->pPipeInfo=deviceExtension->WritePipe;
               else
                   pResetWorkItemObj->pPipeInfo=deviceExtension->ReadPipe;
               IoQueueWorkItem(pResetWorkItemObj->ioWorkItem,DOT4USB_ResetWorkItem,DelayedWorkQueue,pResetWorkItemObj);
               status=STATUS_MORE_PROCESSING_REQUIRED;
            }   //end if allocs all OK

        }   //end if not already resetting
 
    }   //end if we need to reset

    IoReleaseRemoveLock( &(deviceExtension->RemoveLock), Irp );
    ExFreePool(rwContext);
    ExFreePool(urb);

    return status;
}

NTSTATUS DOT4USB_ResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context)
{   

    PDOT4USB_WORKITEM_CONTEXT pResetWorkItemObj;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    PDEVICE_OBJECT devObj;

    UNREFERENCED_PARAMETER(deviceObject);
    TR_VERBOSE(("USBPRINT.SYS: Entering USBPRINT_ResetWorkItem\n"));
    pResetWorkItemObj=(PDOT4USB_WORKITEM_CONTEXT)Context;
    DeviceExtension=pResetWorkItemObj->deviceObject->DeviceExtension;
    ntStatus=UsbResetPipe(pResetWorkItemObj->deviceObject,pResetWorkItemObj->pPipeInfo,FALSE);
    IoCompleteRequest(pResetWorkItemObj->irp,IO_NO_INCREMENT);
    IoFreeWorkItem(pResetWorkItemObj->ioWorkItem);
    
    // save off work item device object before freeing work item
    devObj = pResetWorkItemObj->deviceObject;
    ExFreePool(pResetWorkItemObj);
    InterlockedExchange(&(DeviceExtension->ResetWorkItemPending),0);
    return ntStatus;
}




NTSTATUS
UsbReadInterruptPipeLoopCompletionRoutine(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    devExt
    )
{
    PURB                urb;
    PDEVICE_OBJECT      devObj;
    PUSB_RW_CONTEXT     context;
    PCHAR               scratchBuffer;
    KIRQL               oldIrql;
    ULONG               sizeOfUrb;
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;
    BOOLEAN             queueNewRequest;

    UNREFERENCED_PARAMETER( DevObj ); // we created this Irp via IoAllocateIrp() and we didn't reserve an IO_STACK_LOCATION
                                      //   for ourselves, so we can't use this


    if(devExt->InterruptContext)
    {
        context         = devExt->InterruptContext;         
        urb             = context->Urb;
        devObj          = context->DevObj;
        scratchBuffer   = urb->UrbBulkOrInterruptTransfer.TransferBuffer;
    }
    else
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

        // must have freed up the context stuff, so just return
    KeAcquireSpinLock( &devExt->SpinLock, &oldIrql );
    if( !Irp->Cancel && devExt->Dot4Event && NT_SUCCESS(Irp->IoStatus.Status) ) {
        queueNewRequest = TRUE;
        KeSetEvent( devExt->Dot4Event, 1, FALSE ); // signal dot4.sys that peripheral has data to be read
    } else {
        TR_TMP1(("UsbReadInterruptPipeLoopCompletionRoutine - cancel, Dot4 event gone, or bad status in irp - time to clean up"));
        if( STATUS_SUCCESS != Irp->IoStatus.Status ) {
            TR_TMP1(("UsbReadInterruptPipeLoopCompletionRoutine - IoStatus.Status = %x\n",Irp->IoStatus.Status));
        }
        queueNewRequest = FALSE;
    }
    KeReleaseSpinLock( &devExt->SpinLock, oldIrql );

    if( queueNewRequest ) {
        // queue another read request in the interrupt pipe
        sizeOfUrb = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
        RtlZeroMemory( urb, sizeOfUrb );
        urb->UrbBulkOrInterruptTransfer.Hdr.Length           = (USHORT)sizeOfUrb;
        urb->UrbBulkOrInterruptTransfer.Hdr.Function         = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
        urb->UrbBulkOrInterruptTransfer.PipeHandle           = devExt->InterruptPipe->PipeHandle;
        urb->UrbBulkOrInterruptTransfer.TransferFlags        = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
        urb->UrbBulkOrInterruptTransfer.TransferBuffer       = scratchBuffer;
        urb->UrbBulkOrInterruptTransfer.TransferBufferLength = SCRATCH_BUFFER_SIZE;
        urb->UrbBulkOrInterruptTransfer.TransferBufferMDL    = NULL;
        urb->UrbBulkOrInterruptTransfer.UrbLink              = NULL;

        IoReuseIrp( Irp, STATUS_NOT_SUPPORTED );

        irpSp = IoGetNextIrpStackLocation( Irp );
        irpSp->MajorFunction                            = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
        irpSp->Parameters.Others.Argument1              = urb;

        IoSetCompletionRoutine( Irp, UsbReadInterruptPipeLoopCompletionRoutine, devExt, TRUE, TRUE, TRUE );

        status = IoCallDriver(devExt->LowerDevObj, Irp);

        if( !NT_SUCCESS( status ) ) {
            // bummer - Irp is in limbo - stop polling and mark Irp for cleanup
            D4UAssert(!"UsbReadInterruptPipeLoopCompletionRoutine - IoCallDriver failed");

            if(devExt->InterruptContext)
            {
                InterlockedExchangePointer(&devExt->InterruptContext, NULL);
                ExFreePool( urb );
                ExFreePool( context );
                ExFreePool( scratchBuffer );
                KeSetEvent( &devExt->PollIrpEvent, 0, FALSE ); // signal dispatch routine that it is safe to touch the Irp - including IoFreeIrp()
            }
        }

    } else {
        if(devExt->InterruptContext)
        {
            // clean up - either Irp was cancelled or we got a datalink disconnect IOCTL from dot4
            InterlockedExchangePointer(&devExt->InterruptContext, NULL);
            ExFreePool( urb );
            ExFreePool( context );
            ExFreePool( scratchBuffer );
            TR_TMP1(("UsbReadInterruptPipeLoopCompletionRoutine - signalling PollIrpEvent"));
            KeSetEvent( &devExt->PollIrpEvent, 0, FALSE ); // signal dispatch routine that it is safe to touch the Irp - including IoFreeIrp()
        }
    }

    return STATUS_MORE_PROCESSING_REQUIRED; // always
}


/************************************************************************/
/* UsbStopReadInterruptPipeLoop                                         */
/************************************************************************/
//
// Routine Description:
//
//      - Stop the polling of the device interrupt pipe started by
//          UsbStartReadInterruptPipeLoop and free the Irp.
//
//      - It is legal for devExt->PollIrp to be NULL on entry to this function.
//
//      - This function is called from the DataLink Disconnect IOCTL
//          handler, from the PnP Surprise Removal handler and from the
//          PnP Remove handler. It is safe to call this function multiple
//          times between PollIrp creations.
//
//      - This is the only function in the driver that should call
//          IoFreeIrp on devExt->PollIrp and it is the only function
//          that should change devExt->PollIrp from !NULL -> NULL
//
//      - This function will block until the PollIrp, if any, has
//          been cleaned up. The block should be for a very short
//          period of time unless there is a driver bug here or in
//          the USB stack below us.
//
// Arguments: 
//
//      DevObj - pointer to Dot4Usb.sys driver object
//                                                        
// Return Value:                                          
//                                                        
//      NONE
//                                                        
/************************************************************************/
VOID
UsbStopReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    )
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    KIRQL                      oldIrql;

    TR_VERBOSE(("UsbStopReadInterruptPipeLoop - enter"));

    //
    // We must hold this SpinLock in order to change devExt->PollIrp
    //
    KeAcquireSpinLock( &devExt->PollIrpSpinLock, &oldIrql );

    if( devExt->PollIrp ) {

        //
        // We have a PollIrp - Cancel the Irp so that the completion
        //   routine detects that it should take the Irp out of play and
        //   signal us when it is safe for us to touch the irp.
        //
        NTSTATUS       status;
        LARGE_INTEGER  timeOut;
        PIRP           irp;
        
        irp             = devExt->PollIrp;
        devExt->PollIrp = NULL;

        //
        // Safe to let go of the SpinLock - everything from here on is local to this function
        //
        KeReleaseSpinLock( &devExt->PollIrpSpinLock, oldIrql );

        //
        // Completion routine will detect that the Irp has been cancelled
        //
retryCancel:
        IoCancelIrp( irp );

        //
        // Completion routine will set PollIrpEvent when it has taken
        //   the Irp out of play and it is safe for us to touch the Irp
        //
        // 500ms (in 100ns units) - magic number chosen as "reasonable" timeout
        //
        timeOut.QuadPart = - 500 * 10 * 1000; 
        status = KeWaitForSingleObject( &devExt->PollIrpEvent, Executive, KernelMode, FALSE, &timeOut ); 

        if( STATUS_SUCCESS == status ) {
            //
            // Completion routine has signalled that we now own the irp - clean it up
            //
            IoFreeIrp( irp );

            //
            // This irp will no longer block a Remove
            //
            IoReleaseRemoveLock( &devExt->RemoveLock, irp );

        } else if( STATUS_TIMEOUT == status ) {
            //
            // Cancel and wait again - either we hit a timing window where our completion
            //   routine lost our cancel request, or the Irp is wedged in a driver somewhere
            //   below us.
            //
            goto retryCancel;

        } else {
            //
            // We specified that we were NOT alertable - but check for this condition anyway
            //
            D4UAssert(!"UsbStopReadInterruptPipeLoop - unexpected status from KeWaitForSingleObject?!?");            
            goto retryCancel;
        }

    } else {

        //
        // We don't have a PollIrp - nothing for us to clean up.
        //
        TR_VERBOSE(("UsbStopReadInterruptPipeLoop - NULL PollIrp"));
        KeReleaseSpinLock( &devExt->PollIrpSpinLock, oldIrql );

    }
}


/************************************************************************/
/* UsbStartReadInterruptPipeLoop                                        */
/************************************************************************/
//
// Routine Description:
//
//      - Create a read request (Irp) for the device's interrupt pipe. Save a
//          pointer to the Irp in our device extension for cleanup later by
//          UsbStopReadInterruptPipeLoop().
//
//      - This is the only function in the driver that should change
//          devExt->PollIrp from NULL -> !NULL
//
// Arguments: 
//
//      DevObj - pointer to Dot4Usb.sys driver object
//                                                        
// Return Value:                                          
//                                                        
//      NTSTATUS                                          
//                                                        
/************************************************************************/
NTSTATUS
UsbStartReadInterruptPipeLoop(
    IN PDEVICE_OBJECT DevObj
    )
{
    NTSTATUS                status; 
    PDEVICE_EXTENSION       devExt = DevObj->DeviceExtension;
    PUSBD_PIPE_INFORMATION  pipe;
    ULONG                   sizeOfUrb;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PURB                    urb;
    PUSB_RW_CONTEXT         context;
    PCHAR                   scratchBuffer;
    KIRQL                   oldIrql;
    
    TR_VERBOSE(("UsbStartReadInterruptPipeLoop - enter"));


    //
    // We must hold this SpinLock in order to change devExt->PollIrp
    //
    // BUGBUG - This SpinLock is protecting some code that doesn't need protection,
    //            which means that we are at Raised Irql when we don't need to be.
    //            Revisit this later to move the Acquire and Release of this SpinLock
    //            so that it only protects code that needs protection.
    //
    KeAcquireSpinLock( &devExt->PollIrpSpinLock, &oldIrql );


    //
    // Driver state machine check - we should never get two calls to this
    //   function without a cleanup (UsbStopReadInterruptPipeLoop) call in between.
    //
    D4UAssert( !devExt->PollIrp );


    //
    // Verify that we have an interrupt pipe
    //
    pipe = devExt->InterruptPipe;
    if( !pipe ) {
        TR_FAIL(("UsbStartReadInterruptPipeLoop - no interrupt pipe"));
        status = STATUS_INVALID_HANDLE;
        goto targetError;
    }


    //
    // Pipe type/look ok?
    //
    D4UAssert( UsbdPipeTypeInterrupt == pipe->PipeType && USBD_PIPE_DIRECTION_IN(pipe) );


    //
    // Allocate pool that we need for this request
    //
    sizeOfUrb = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb = ExAllocatePool( NonPagedPool, sizeOfUrb );
    if( !urb ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    context = ExAllocatePool( NonPagedPool, sizeof(USB_RW_CONTEXT) );
    if( !context ) {
        ExFreePool( urb );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    scratchBuffer = ExAllocatePool( NonPagedPool, SCRATCH_BUFFER_SIZE );
    if( !scratchBuffer ) {
        ExFreePool( urb );
        ExFreePool( context );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }


    //
    // Set up Context for completion routine
    //
    //   - We send down a pointer to our Device Object in context
    //       because we create this IRP via IoAllocateIrp and we don't
    //       reserve a stack location for ourselves, so the PDEVICE_OBJECT
    //       parameter that our completion routine receives is bogus
    //      (probably NULL)
    //
    context->Urb    = urb;
    context->DevObj = DevObj;


    //
    // Initialize URB for read on interrupt pipe
    //
    RtlZeroMemory( urb, sizeOfUrb );

    urb->UrbBulkOrInterruptTransfer.Hdr.Length           = (USHORT)sizeOfUrb;
    urb->UrbBulkOrInterruptTransfer.Hdr.Function         = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    urb->UrbBulkOrInterruptTransfer.PipeHandle           = pipe->PipeHandle;
    urb->UrbBulkOrInterruptTransfer.TransferFlags        = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
    urb->UrbBulkOrInterruptTransfer.TransferBuffer       = scratchBuffer;
    urb->UrbBulkOrInterruptTransfer.TransferBufferLength = SCRATCH_BUFFER_SIZE; // note - likely only one byte to read
    urb->UrbBulkOrInterruptTransfer.TransferBufferMDL    = NULL;
    urb->UrbBulkOrInterruptTransfer.UrbLink              = NULL;


    //
    // Allocate and set up the IRP, stack location, and completion routine
    //
    irp = IoAllocateIrp( devExt->LowerDevObj->StackSize, FALSE );
    if( !irp ) {
        ExFreePool( urb );
        ExFreePool( context );
        ExFreePool( scratchBuffer );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    irpSp                                           = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction                            = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    irpSp->Parameters.Others.Argument1              = urb;

    IoSetCompletionRoutine( irp, UsbReadInterruptPipeLoopCompletionRoutine, devExt, TRUE, TRUE, TRUE );


    //
    // This event will be SET by the completion routine when it is
    //   safe for a dispatch routine to touch this Irp
    //
    KeClearEvent( &devExt->PollIrpEvent ); 


    //
    // We're about to put the Irp in play - make sure that our device
    //   doesn't get removed while this Irp is in use
    //
    status = IoAcquireRemoveLock( &devExt->RemoveLock, irp );
    if( STATUS_SUCCESS != status ) {
        //
        // We're being removed - clean up and bail out
        //
        IoFreeIrp( irp );
        ExFreePool( urb );
        ExFreePool( context );
        ExFreePool( scratchBuffer );
        status = STATUS_DELETE_PENDING;
        goto targetError;
    }

    //
    // Save a pointer to this Irp in our extension so that UsbStopReadInterruptPipeLoop()
    //   can find it to IoFreeIrp() it later.
    //
    D4UAssert( !devExt->PollIrp );
    devExt->PollIrp = irp;

    // save interrupt context in device extension
    InterlockedExchangePointer(&devExt->InterruptContext, context);


    //
    // Kick off the first read. Subsequent reads will come from the
    //   completion routine as it reuses/bounces the IRP. The completion routine
    //   is responsible taking the Irp out of play when it detects either a termination 
    //   condition or request error. UsbStopReadInterruptPipeLoop() will clean up the
    //   Irp after the completion routine has taken the Irp out of play and signaled
    //   PollIrpEvent that it is safe to touch the Irp.
    //
    status = IoCallDriver( devExt->LowerDevObj, irp );

targetError:

    //
    // CURRENTLY... all paths to here hold the SpinLock - this should change after cleanup
    //
    KeReleaseSpinLock( &devExt->PollIrpSpinLock, oldIrql );


    // 
    // If the Irp is Pending then we have been successful
    //
    if( STATUS_PENDING == status ) {
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
UsbDeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Event
    )
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
    KeSetEvent( (PKEVENT)Event, 1, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
UsbCallUsbd(
    IN PDEVICE_OBJECT   DevObj,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout 
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceObject - pointer to the device object for this printer

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    PIRP irp;
    KEVENT event;
    PIO_STACK_LOCATION nextStack;

    TR_VERBOSE(("UsbCallUsbd - enter"));

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    if ( (irp = IoAllocateIrp(devExt->LowerDevObj->StackSize,
                              FALSE)) == NULL )
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    D4UAssert(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->Parameters.Others.Argument1 = Urb;

    IoSetCompletionRoutine(irp,
               UsbDeferIrpCompletion,
               &event,
               TRUE,
               TRUE,
               TRUE);
               
    ntStatus = IoCallDriver(devExt->LowerDevObj, irp);

    if ( ntStatus == STATUS_PENDING ) {
        status = KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,pTimeout);
        //
        // If the request timed out cancel the request
        // and wait for it to complete
        //
        if ( status == STATUS_TIMEOUT ) {
            TR_VERBOSE(("UsbCallUsbd: Cancelling IRP %x because of timeout", irp));
            IoCancelIrp(irp);
            KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
        }

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    TR_VERBOSE(("UsbCallUsbd - exit w/status=%x", ntStatus));

    return ntStatus;
}


NTSTATUS
UsbResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    )
/*++

Routine Description:

    Reset a given USB pipe.
    
    NOTES:

    This will reset the host to Data0 and should also reset the device
    to Data0 for Bulk and Interrupt pipes.

    For Iso pipes this will set the virgin state of pipe so that ASAP
    transfers begin with the current bus frame instead of the next frame
    after the last transfer occurred.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;


    TR_VERBOSE(("Entering UsbResetPipe; pipe # %x\n", Pipe));

    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {

    urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
    urb->UrbPipeRequest.PipeHandle =
        Pipe->PipeHandle;

    ntStatus = UsbCallUsbd(DeviceObject, urb, &timeOut);

    ExFreePool(urb);

    } else {
    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Memphis RESET_PIPE will send a Clear-Feature Endpoint Stall to
    // reset the data toggle of non-Iso pipes as part of a RESET_PIPE
    // request.  It does not do this for Iso pipes as Iso pipes do not use
    // the data toggle (all Iso packets are Data0).  However, we also use
    // the Clear-Feature Endpoint Stall request in our device firmware to
    // reset data buffer points inside the device so we explicitly send
    // this request to the device for Iso pipes if desired.
    //
    if (NT_SUCCESS(ntStatus) && IsoClearStall &&
    (Pipe->PipeType == UsbdPipeTypeIsochronous)) {
    
    urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

    if (urb) {

        UsbBuildFeatureRequest(urb,
                   URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT,
                   USB_FEATURE_ENDPOINT_STALL,
                   Pipe->EndpointAddress,
                   NULL);

        ntStatus = UsbCallUsbd(DeviceObject, urb, &timeOut);

        ExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    }

    return ntStatus;
}


NTSTATUS
UsbReadWrite(
    IN PDEVICE_OBJECT       DevObj,
    IN PIRP                 Irp,
    PUSBD_PIPE_INFORMATION  Pipe,
    USB_REQUEST_TYPE        RequestType
    )
/*
  - Caller must verify that:
    - Irp->MdlAddress != NULL
    - Pipe != NULL
    - RequestType matches Pipe->PipeType

*/
{
    PDEVICE_EXTENSION       devExt;
    PIO_STACK_LOCATION      nextIrpSp;
    PURB                    urb;
    PUSB_RW_CONTEXT         context;
    ULONG                   sizeOfUrb  = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    NTSTATUS                status     = STATUS_SUCCESS;

    TR_VERBOSE(("UsbReadWrite - enter"));

    D4UAssert( Irp->MdlAddress ); // calling routine should catch and fail this case
    D4UAssert( Pipe );            // calling routine should catch and fail this case 

    urb = ExAllocatePool( NonPagedPool, sizeOfUrb );
    if( !urb ) {
        TR_FAIL(("UsbReadWrite - no pool for URB"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    context = ExAllocatePool( NonPagedPool, sizeof(USB_RW_CONTEXT) );
    if( !context ) {
        TR_FAIL(("UsbReadWrite - no pool for context"));
        ExFreePool( urb );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetError;
    }

    context->Urb    = (PURB)urb;
    context->DevObj = DevObj;

    RtlZeroMemory(urb, sizeOfUrb);

    UsbBuildInterruptOrBulkTransferRequest( urb, 
                                            (USHORT)sizeOfUrb,
                                            Pipe->PipeHandle,
                                            NULL, // transferBuffer
                                            Irp->MdlAddress,
                                            MmGetMdlByteCount(Irp->MdlAddress),
                                            0,    // transfer Flags
                                            NULL );

    if( UsbReadRequest == RequestType ) {
        context->IsWrite=FALSE;
        TR_VERBOSE(("UsbReadWrite - requesttype is READ"))
        urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN;
        urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    } else {
        context->IsWrite=TRUE;
        TR_VERBOSE(("UsbReadWrite - requesttype is WRITE"))
    }

    nextIrpSp                                           = IoGetNextIrpStackLocation( Irp );
    nextIrpSp->MajorFunction                            = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpSp->Parameters.Others.Argument1              = urb;
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    
    IoSetCompletionRoutine( Irp, UsbAsyncReadWriteComplete, context, TRUE, TRUE, TRUE );
    
    devExt = DevObj->DeviceExtension;
    status = IoCallDriver( devExt->LowerDevObj, Irp );

    goto targetDone;

targetError:

    Irp->IoStatus.Status      = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

targetDone:

    TR_VERBOSE(("UsbReadWrite - exit - status= %x",status));
    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\dot4\dot4usb\util.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Dot4Usb.sys - Lower Filter Driver for Dot4.sys for USB connected
                        IEEE 1284.4 devices.

File Name:

        Util.c

Abstract:

        Misc. Utility functions

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        01/18/2000 : created

ToDo in this file:

        - code review and doc
        - code review w/Joby

Author(s):

        Joby Lafky (JobyL)
        Doug Fritz (DFritz)

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DispatchPassThrough                                                  */
/************************************************************************/
//
// Routine Description:
//
//     Default dispatch routine for IRP_MJ_xxx that we don't explicitly
//       handle. Pass the request down to the device object below us.
//
// Arguments:
//
//      DevObj - pointer to Device Object that is the target of the request
//      Irp    - pointer to request
//
// Return Value:
//
//      NTSTATUS
//
// Log:
//      2000-05-03 Code Reviewed - TomGreen, JobyL, DFritz
//
/************************************************************************/
NTSTATUS
DispatchPassThrough(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION   devExt = DevObj->DeviceExtension;
    NTSTATUS            status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {
        // RemoveLock acquired, continue with request
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - FAIL request
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}


/************************************************************************/
/* CallLowerDriverSync                                                  */
/************************************************************************/
//
// Routine Description:
//
//     Call the driver below us synchronously. When this routine returns
//       the calling routine once again owns the IRP.
//
//     This routine acquires and holds a RemoveLock against the IRP
//       while the IRP is in the possession of drivers below us.
//
// Arguments:
//
//      DevObj - pointer to Device Object that is issuing the request
//      Irp    - pointer to request
//
// Return Value:
//
//      NTSTATUS
//
/************************************************************************/
NTSTATUS
CallLowerDriverSync(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
)
{
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;
    NTSTATUS          status = IoAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( NT_SUCCESS(status) ) {
        KEVENT         event;
        KeInitializeEvent( &event, NotificationEvent, FALSE );
        IoSetCompletionRoutine( Irp, CallLowerDriverSyncCompletion, &event, TRUE, TRUE, TRUE );
        status = IoCallDriver( devExt->LowerDevObj, Irp );
        if( STATUS_PENDING == status ) {
            KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
            status = Irp->IoStatus.Status;
        }
        IoReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        TR_FAIL(("util::CallLowerDriverSync - Couldn't aquire RemoveLock"));
    }

    return status;
}


/************************************************************************/
/* CallLowerDriverSyncCompletion                                        */
/************************************************************************/
//
// Routine Description:
//
//     This is the completion routine for CallLowerDriverSync() that
//       simply signals the event and stops the IRP completion from
//       unwinding so that CallLowerDriverSync() can regain ownership
//       of the IRP.
//
// Arguments:
//
//      DevObjOrNULL - Usually, this is this driver's device object.
//                       However, if this driver created the IRP, then
//                       there is no stack location in the IRP for this
//                       driver; so the kernel has no place to store the
//                       device object; ** so devObj will be NULL in
//                       this case **.
//      Irp    - pointer to request
//
// Return Value:
//
//      NTSTATUS
//
/************************************************************************/
NTSTATUS
CallLowerDriverSyncCompletion(
    IN PDEVICE_OBJECT DevObjOrNULL,
    IN PIRP           Irp,
    IN PVOID          Context
)
{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DevObjOrNULL );
    UNREFERENCED_PARAMETER( Irp );

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\makefile.inc ===
mofcomp: selSusp.bmf

selSusp.bmf: selSusp.mof
        mofcomp -B:selSusp.bmf selSusp.mof
        wmimofck selSusp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\selsusp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.c

Abstract:

    This module contains code for a generic client driver that can be loaded 
    for all USB devices/child interfaces.

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSUsr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"

//
// Globals
//

GLOBALS Globals;
ULONG   DebugLevel = 3;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SS_DriverUnload)
#pragma alloc_text(PAGE, SS_DispatchCreate)
#pragma alloc_text(PAGE, SS_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //

    registryPath = &Globals.SSRegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        SSDbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SS_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = SS_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = SS_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SS_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SS_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = SS_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SS_DispatchSysCtrl;
    DriverObject->DriverUnload                         = SS_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         SS_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will clean up all resources we allocated.

Arguments:

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    SSDbgPrint(3, ("SS_DriverUnload - begins\n"));

    registryPath = &Globals.SSRegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    SSDbgPrint(3, ("SS_DriverUnload - ends\n"));

    return;
}

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    SSDbgPrint(3, ("SS_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        
        SSDbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_BUFFERED_IO;

    //
    // initialize the device state lock and set the device state
    //

    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //

    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //

    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = SSWmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("SSWmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // set the power state of the device
    //

    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    //

    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        SSWmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_GENERIC_SELECTIVE_SUSPEND, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        SSWmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // initialize DPC
    //
    KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                    DpcRoutine, 
                    deviceObject);

    //
    // initialize timer
    //
    KeInitializeTimerEx(&deviceExtension->Timer,
                        NotificationTimer);

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    SSDbgPrint(3, ("SS_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\ssdevctr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __DEV_CTRL_H
#define __DEV_CTRL_H

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\selsusp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <ntddk.h>
#include <wmilib.h>
#include "usbdi.h"
#include "usbdlib.h"

#ifndef _SUSPEND_LOCAL_H
#define _SUSPEND_LOCAL_H

#define SSTAG (ULONG) 'SleS'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, SSTAG);

#if DBG

#define SSDbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint("@#"); \
                DbgPrint _x_; \
            }

#else

#define SSDbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING SSRegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    //Bus drivers set the appropriate values in this structure in response
    //to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    //alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables
    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    KSPIN_LOCK IdleReqStateLock;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    //
    // selective suspend model uses timers, dpcs and work item.
    //
    KTIMER Timer;

    KDPC DeferredProcCall;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;



typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\ssdevctr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"

extern GLOBALS Globals;
extern ULONG   DebugLevel;

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchCreate - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    //
    // increment OpenHandleCounts
    //
    InterlockedIncrement(&deviceExtension->OpenHandleCount);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // the device is idle if it has no open handles or pending PnP Irps
    // since we just received an open handle request, cancel idle req. if any
    //
    CancelSelectSuspend(deviceExtension);

    SSDbgPrint(3, ("SS_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchClose - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    SSDbgPrint(3, ("SS_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    info = 0;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
	
    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoIncrement(deviceExtension);

    switch(code) {

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

Return Value:

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    SSDbgPrint(0, ("SubmitIdleRequest - begins\n"));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        SSDbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitRequest_Exit;
    }

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;

        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            SSDbgPrint(1, ("cannot build idle request irp\n"));

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitRequest_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension))
        {
            //
            // IRPs created using IoBuildDeviceIoControlRequest should be
            // completed by calling IoCompleteRequest and not merely 
            // deallocated.
            //
     
            SSDbgPrint(0, ("Device is not idle\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            if(irp)
            {
                irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
                irp->IoStatus.Information = 0;

                IoCompleteRequest(irp, IO_NO_INCREMENT);
            }

            goto SubmitRequest_Exit;
        }

        SSDbgPrint(3, ("Cancel the timers\n"));

        KeCancelTimer(&DeviceExtension->Timer);

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitRequest_Exit;
        }
    }
    else {

        SSDbgPrint(0, ("Memory allocation for idleCallbackInfo failed\n"));

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitRequest_Exit:

    SSDbgPrint(0, ("SubmitIdleRequest - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    SSDbgPrint(0, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        SSDbgPrint(0, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        SSDbgPrint(3, ("IdleNotificationCallback::"));
        SSIoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        if(STATUS_PENDING == ntStatus) {

            SSDbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    
    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    SSDbgPrint(0, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    LARGE_INTEGER           dueTime;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    SSDbgPrint(0, ("IdleNotificationRequestCompete - begins\n"));

    //
    // check the Irp status
    //

    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        SSDbgPrint(0, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            SSDbgPrint(0, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            SSDbgPrint(0, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            SSDbgPrint(0, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            SSDbgPrint(0, ("STATUS_DEVICE_BUSY\n"));

            break;
        }

        //
        // if in error, issue a SetD0
        //

        SSDbgPrint(3, ("IdleNotificationRequestComplete::"));
        SSIoIncrement(DeviceExtension);

        powerState.DeviceState = PowerDeviceD0;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                          DeviceExtension, 
                          NULL);

        if(!NT_SUCCESS(ntStatus)) {
    
            SSDbgPrint(1, ("PoRequestPowerIrp failed\n"));
        }

    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    DeviceExtension->PendingIdleIrp = NULL;

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    SSDbgPrint(3, ("Set the timer to fire DPCs\n"));

    dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

    KeSetTimerEx(&DeviceExtension->Timer, 
                 dueTime,
                 IDLE_INTERVAL,                              // 5000 ms
                 &DeviceExtension->DeferredProcCall);

    SSDbgPrint(0, ("IdleNotificationRequestCompete - ends\n"));

    //
    // since we allocated the irp, we need to free it.
    // return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not touch it.
    //

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    SSDbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        SSDbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(irp) {
        
        if(IoCancelIrp(irp)) {

            SSDbgPrint(0, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            SSDbgPrint(0, ("IoCancelIrp returns FALSE\n"));
        }
    }

    SSDbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //

    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        SSDbgPrint(3, ("PoIrpCompletionFunc::"));
        SSIoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("WWIrpCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\ssusr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSUsr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _SEL_SUSPEND_USER_H
#define _SEL_SUSPEND_USER_H

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_GENERIC_SELECTIVE_SUSPEND, 
0x6068eb61, 0x98e7, 0x4c98, 0x9e, 0x20, 0x1f, 0x6, 0x82, 0x95, 0x90, 0x9a);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\sspwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __POWER_H
#define __POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\sspnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __PNP_H
#define __PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReturnResources(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\sspnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"

extern ULONG DebugLevel;

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("///////////////////////////////////////////\n"));
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        CancelSelectSuspend(deviceExtension);
    }

    SSDbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::default::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    } // switch

//
// complete request 
//

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

//
// decrement count
//
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    SSDbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower drivers failed this Irp\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake outstanding flag to false.
    // and issue a wait wake.
    
    deviceExtension->FlagWWOutstanding = 0;

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);

    //
    // set timer.
    //

    dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

    KeSetTimerEx(&deviceExtension->Timer, 
                 dueTime,
                 IDLE_INTERVAL,                              // 5000 ms
                 &deviceExtension->DeferredProcCall);

    SSDbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
            			    
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            SSDbgPrint(1, ("Failed to allocate memory for deviceDescriptor"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;



    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the descriptor of the first configuration
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1,("Failed to read configuration descriptor"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    if(configurationDescriptor) {

        ExFreePool(configurationDescriptor);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION Interface;

    //
    // initialize the variables
    //

    urb = NULL;
    Interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        SSDbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        Interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<Interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            Interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        SSDbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        SSDbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        SSDbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    SSDbgPrint(3, ("CallUSBD::"));
    SSIoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    SSDbgPrint(3, ("CallUSBD::"));
    SSIoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    SSDbgPrint(3, ("HandleQueryStopDevice::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //

    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    
    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //

    ntStatus = ReturnResources(DeviceObject);

    CancelWaitWake(deviceExtension);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    ntStatus = DeconfigureDevice(DeviceObject);
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    ntStatus = CanRemoveDevice(DeviceObject, Irp);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    SSDbgPrint(3, ("HandleQueryRemoveDevice::"));
    SSIoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    CancelWaitWake(deviceExtension);

    KeCancelTimer(&deviceExtension->Timer);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }


    ReturnResources(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        CancelWaitWake(deviceExtension);

        KeCancelTimer(&deviceExtension->Timer);

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }

        ReturnResources(DeviceObject);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    SSWmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    SSDbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    SSDbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        SSDbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }
    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    SSDbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    SSDbgPrint(3, ("DpcRoutine - begins\n"));

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            SSDbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        
        SSDbgPrint(3, ("Idle event not signaled\n"));
    }

    SSDbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    SSDbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        SSDbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    SSDbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Remove and process the entries in the queue. If this routine is called
  when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
  or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
  If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
  are complete with STATUS_DELETE_PENDING

Arguments:

Return Value:

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    SSDbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY listEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    SSDbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoIncrement::%d\n", result));

    return result;
}

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReturnResources(
    IN PDEVICE_OBJECT DeviceObject
    )
/* ++
 
Routine Description:

Arguments:

Return Value:

--*/
{
   //
   // Disconnect from the interrupt and unmap any I/O ports
   //

   UNREFERENCED_PARAMETER(DeviceObject);

   return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}

NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION  deviceExtension;
    KIRQL              oldIrql;
    LIST_ENTRY         cleanupList;
    PLIST_ENTRY        thisEntry, 
                       nextEntry, 
                       listHead;
    PIRP               pendingIrp;
    PIO_STACK_LOCATION pendingIrpStack, 
                       irpStack;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    InitializeListHead(&cleanupList);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoIncrement(deviceExtension);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}


BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    SSDbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\sspwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSPwr.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"

extern GLOBALS Globals;
extern ULONG DebugLevel;

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("SS_DispatchPower::"));
    SSIoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            ntStatus = HandleSystemSetPower(DeviceObject, Irp);

            break;

        case DevicePowerState:

            ntStatus = HandleDeviceSetPower(DeviceObject, Irp);

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            ntStatus = HandleSystemQueryPower(DeviceObject, Irp);

            break;

        case DevicePowerState:

            ntStatus = HandleDeviceQueryPower(DeviceObject, Irp);

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed this Irp"));
        }

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        SSDbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        SSIoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed this Irp"));
        }
        
        SSDbgPrint(3, ("SS_DispatchPower::"));
        SSIoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    //
    // Fail a query for a power state incompatible with waking up the system
    //

    if((deviceExtension->WaitWakeEnable) &&
       (systemState > deviceExtension->DeviceCapabilities.SystemWake)) {

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("HandleSystemQueryPower::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;
    }

    //
    // if querying for a lower S-state, issue a wait-wake
    //

    if(systemState > deviceExtension->SysPower) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    SSDbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    if(deviceExtension->WaitWakeEnable &&
       deviceState > deviceExtension->DeviceCapabilities.DeviceWake) {

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("HandleDeviceQueryPower::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;
    }

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("HandleDeviceQueryPower::"));
    SSIoDecrement(deviceExtension);

    SSDbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    SSDbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("SysPoCompletionRoutine::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    SSDbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        SSDbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("SendDeviceIrp::"));
        SSIoDecrement(deviceExtension);

    }

    SSDbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    SSDbgPrint(3, ("DevPoCompletionRoutine::"));
    SSIoDecrement(deviceExtension);

    ExFreePool(powerContext);

    SSDbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    SSDbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        SSDbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        SSDbgPrint(3, ("Removing power or SetD0\n"));

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //
            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                SSDbgPrint(3, ("HandleDeviceSetPower::"));
                SSIoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }

        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    SSDbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return ntStatus;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    SSDbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("FinishDevPoUpIrp::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    SSDbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SetDeviceFunctional::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    SSDbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        SSDbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    SSDbgPrint(3, ("FinishDevPoDnIrp::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            SSDbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(0, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    SSDbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke SSIoDecrement twice: once each for the S-Irp and D-Irp.
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

  Queue the Irp in the device queue

Arguments:

Return Value:

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    SSDbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    SSDbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    SSDbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    SSDbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        return STATUS_SUCCESS;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    SSDbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP Irp;

    SSDbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    SSDbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    SSDbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    SSDbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    SSDbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        SSDbgPrint(3, ("device already powered up...\n"));

        return;
    }

    SSDbgPrint(3, ("WaitWakeCallback::"));
    SSIoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    IssueWaitWake(deviceExtension);

    SSDbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\beep\beep.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    beep.h

Abstract:

    These are the structures and defines that are used in the beep driver.

Author:

    Lee A. Smith (lees) 02-Aug-1991.

Revision History:

--*/

#ifndef _BEEP_
#define _BEEP_

#include <ntddbeep.h>

//
// Define the device extension.
//

typedef struct _DEVICE_EXTENSION {

    KTIMER Timer;
    FAST_MUTEX Mutex;
    ULONG ReferenceCount;
    LONG TimerSet;
    PVOID hPagedCode;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#endif // _BEEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\sswmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSWmi.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __WMI_H
#define __WMI_H

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SSQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\beep\dbg.c ===
#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"


#if DBG
//
// Declare the global debug flag for this driver.
//

ULONG BeepDebug = 1;

VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= BeepDebug) {
        char buffer[256];
        DbgPrint("BEEP: ");
        (VOID) vsprintf(buffer, DebugMessage, ap);
        DbgPrint(buffer);
    }

    va_end(ap);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\drivers\wdm\usb\driver\selsusp\sswmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSWmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"
#include "sSWmi.h"
#include <initguid.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_SELECT_SUSPEND_DRIVER_INFORMATION 0

DEFINE_GUID (SELECT_SUSPEND_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO SSWmiGuidList[1] = { {

        &SELECT_SUSPEND_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

extern GLOBALS Globals;
extern ULONG   DebugLevel;

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (SSWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = SSWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = SSQueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = SSQueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = SSSetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = SSSetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SSQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.SSRegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    SSDbgPrint(3, ("SSQueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            SSDbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_BUFFER_TOO_SMALL;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSQueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    SSDbgPrint(3, ("SSSetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    SSDbgPrint(3, ("SSSetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\beep\beep.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    Beep driver.

Author:

    Lee A. Smith (lees) 02-Aug-1991.

Environment:

    Kernel mode only.

Notes:


Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"
#include <ntddbeep.h>
#include "beep.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
BeepCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BeepCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#if DBG

VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

//
// Declare the global debug flag for this driver.
//

ULONG BeepDebug = 0;
#define BeepPrint(x) BeepDebugPrint x
#else
#define BeepPrint(x)
#endif

NTSTATUS
BeepDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BeepOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BeepClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BeepStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BeepTimeOut(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BeepUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//
// Coud page out the entire driver in DriverEntry, then page it in 
// upon receiving an open, and page it out during the close. This is
// the way the driver used to operate. There is a problem with this
// on multiproc machines, however. 
// The following sequence of events illustrates a possible bugcheck
// circumstance:
// The BeepTimeout routine decrements the TimerSet at the end of the
// routine. Immediately following this, on a different processor, the
// close routine pages out the DPC routine because the TimerSet variable
// is zero. At this point there is a window of two assembly instructions
// left in the BeepTimeout routine where a page-out would result in a 
// bugcheck.
//

#if 0
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGEBEEP, BeepDeviceControl)
#pragma alloc_text(PAGEBEEP, BeepOpen)
#pragma alloc_text(PAGEBEEP, BeepClose)
#pragma alloc_text(PAGEBEEP, BeepStartIo)
#pragma alloc_text(PAGEBEEP, BeepUnload)
#pragma alloc_text(PAGEBEEP, BeepCancel)
#pragma alloc_text(PAGEBEEP, BeepCleanup)
#endif
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the beep driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    BeepPrint((2,"\n\nBEEP-BeepInitialize: enter\n"));
    //
    // Create non-exclusive device object for beep device.
    //

    RtlInitUnicodeString(&unicodeString, DD_BEEP_DEVICE_NAME_U);

    status = IoCreateDevice(
                DriverObject,
                sizeof(DEVICE_EXTENSION),
                &unicodeString,
                FILE_DEVICE_BEEP,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &deviceObject
                );

    if (status != STATUS_SUCCESS) {
        BeepPrint((
            1,
            "BEEP-BeepInitialize: Could not create device object\n"
            ));
        return(status);
    }

    deviceObject->Flags |= DO_BUFFERED_IO;
    deviceExtension =
        (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    //
    // Initialize the timer DPC queue (we use the device object DPC) and
    // the timer itself.
    //

    IoInitializeDpcRequest(
            deviceObject,
            (PKDEFERRED_ROUTINE) BeepTimeOut
            );

    KeInitializeTimer(&deviceExtension->Timer);
    deviceExtension->TimerSet = 0;

    //
    // Initialize the fast mutex and set the reference count to zero.
    //
    ExInitializeFastMutex(&deviceExtension->Mutex);
    deviceExtension->ReferenceCount = 0;

    //
    // Set up the device driver entry points.
    //

    DriverObject->DriverStartIo = BeepStartIo;
    DriverObject->DriverUnload = BeepUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = BeepOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = BeepClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
                                             BeepDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = BeepCleanup;

#ifdef _PNP_POWER_
    //
    // The HAL is in charge of the beeping, it will take care
    // of the power management on the device
    //

    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

    BeepPrint((2,"BEEP-BeepInitialize: exit\n"));

    return(STATUS_SUCCESS);

}

VOID
BeepCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called from the I/O system when a request is cancelled.

    N.B.  The cancel spinlock is already held upon entry to this routine.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet to be cancelled.

Return Value:

    None.

--*/

{

    BeepPrint((2,"BEEP-BeepCancel: enter\n"));

    if (Irp == DeviceObject->CurrentIrp) {

        //
        // The current request is being cancelled.
        // Don't cancel the request since it is will be completed shortly.
        //

        IoReleaseCancelSpinLock(Irp->CancelIrql);
        return;
    } else {

        //
        // Cancel a request in the device queue.  Remove it from queue and
        // release the cancel spinlock.
        //

        if (TRUE != KeRemoveEntryDeviceQueue(
                        &DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry
                        )) {
            BeepPrint((
                1,
                "BEEP-BeepCancel: Irp 0x%x not in device queue?!?\n",
                Irp
                ));

            // It's not on the queue.  Assume it's being processed.
            IoReleaseCancelSpinLock(Irp->CancelIrql);
            return;
        }
        IoReleaseCancelSpinLock(Irp->CancelIrql);
    }

    //
    // Complete the request with STATUS_CANCELLED.
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepCancel: exit\n"));

    return;
}

NTSTATUS
BeepCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All queued beep requests are completed with STATUS_CANCELLED,
    and the speaker is stopped.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    KIRQL currentIrql;
    KIRQL cancelIrql;
    PKDEVICE_QUEUE_ENTRY packet;
    PIRP  currentIrp;

    BeepPrint((2,"BEEP-BeepCleanup: enter\n"));

    //
    // Raise IRQL to DISPATCH_LEVEL.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

    //
    // Complete all queued requests with STATUS_CANCELLED.
    // Run down the list of requests in the device queue.
    //

    IoAcquireCancelSpinLock(&cancelIrql);
    currentIrp = DeviceObject->CurrentIrp;
    DeviceObject->CurrentIrp = NULL;

    while (currentIrp != NULL) {

        //
        // Dequeue the next packet (IRP) from the device work queue.
        //

        packet = KeRemoveDeviceQueue(&DeviceObject->DeviceQueue);
        if (packet != NULL) {
            currentIrp =
                CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);
        } else {
            currentIrp = (PIRP) NULL;
        }

        if (!currentIrp) {
            break;
        }

        //
        // Remove the CurrentIrp from the cancellable state.
        //
        //

        IoSetCancelRoutine(currentIrp, NULL);

        //
        // Set Status to CANCELLED, release the cancel spinlock,
        // and complete the request.  Note that the IRQL is reset to
        // DISPATCH_LEVEL when we release the cancel spinlock.
        //

        currentIrp->IoStatus.Status = STATUS_CANCELLED;
        currentIrp->IoStatus.Information = 0;

        IoReleaseCancelSpinLock(cancelIrql);
        IoCompleteRequest(currentIrp, IO_NO_INCREMENT);

        IoAcquireCancelSpinLock(&cancelIrql);
    }

    IoReleaseCancelSpinLock(cancelIrql);

    //
    // Lower IRQL.
    //

    KeLowerIrql(currentIrql);

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    //
    // Call HalMakeBeep() to stop any outstanding beep.
    //
#if !defined(NO_LEGACY_DRIVERS)
    (VOID) HalMakeBeep(0);
#endif // NO_LEGACY_DRIVERS

    BeepPrint((2,"BEEP-BeepCleanup: exit\n"));

    return(STATUS_SUCCESS);

}

#if DBG
VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= BeepDebug) {

        char buffer[128];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

}
#endif

NTSTATUS
BeepDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.
    The IOCTL_BEEP_SET subfunction is processed and completed
    in this routine.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PBEEP_SET_PARAMETERS beepParameters;

    BeepPrint((2,"BEEP-BeepDeviceControl: enter\n"));

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Make a beep.  Validate the beep function parameters and return
        // status pending.
        //

        case IOCTL_BEEP_SET:
            beepParameters = (PBEEP_SET_PARAMETERS)
                (Irp->AssociatedIrp.SystemBuffer);
            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                   sizeof(BEEP_SET_PARAMETERS)) {
                status = STATUS_INVALID_PARAMETER;
            } else if ((beepParameters->Frequency != 0)
                        && (beepParameters->Duration == 0)) {
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_PENDING;
            }

            break;

        //
        // Unrecognized device control request.
        //

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // If status is pending, mark the packet pending and start the packet
    // in a cancellable state.  Otherwise, complete the request.
    //

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    if (status == STATUS_PENDING) {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, (PULONG)NULL, BeepCancel);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    BeepPrint((2,"BEEP-BeepDeviceControl: exit\n"));

    return(status);

}

NTSTATUS
BeepOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for create/open requests.
    Open requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PFAST_MUTEX mutex;

    BeepPrint((2,"BEEP-BeepOpenClose: enter\n"));

    //
    // Increment the reference count. If this is the first reference,
    // reset the driver paging.
    //
    deviceExtension = DeviceObject->DeviceExtension;
    mutex = &deviceExtension->Mutex;
    ExAcquireFastMutex(mutex);
    if (++deviceExtension->ReferenceCount == 1) {
        deviceExtension->hPagedCode = MmLockPagableCodeSection(BeepOpen);
    }
    ExReleaseFastMutex(mutex);

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepOpenClose: exit\n"));

    return(STATUS_SUCCESS);
}

NTSTATUS
BeepClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for close requests.
    Close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PFAST_MUTEX mutex;

    BeepPrint((2,"BEEP-BeepOpenClose: enter\n"));

    //
    // Decrement the reference count. If this is the last reference,
    // page the driver out
    //
    deviceExtension = DeviceObject->DeviceExtension;
    mutex = &deviceExtension->Mutex;
    ExAcquireFastMutex(mutex);
    if (--deviceExtension->ReferenceCount == 0) {

        //
        // If there is a timer queued, attempt to cancel it before paging out
        // the driver.  If we cannot cancel it, it may already be queued for
        // execution on another processor.  This is highly unlikely, so just
        // don't page out the entire driver if a timer has been set but cannot
        // be canceled.
        //

        MmUnlockPagableImageSection(deviceExtension->hPagedCode);
        if (deviceExtension->TimerSet &&
            KeCancelTimer(&deviceExtension->Timer)) {
            InterlockedDecrement(&deviceExtension->TimerSet);
        }

    }
    ExReleaseFastMutex(mutex);

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepOpenClose: exit\n"));

    return(STATUS_SUCCESS);
}

VOID
BeepStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the StartIo routine.  It is invoked to start a beep
    request.

    N.B.  Requests enter BeepStartIo in a cancellable state.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    KIRQL cancelIrql;
    PBEEP_SET_PARAMETERS beepParameters;
    LARGE_INTEGER time;
    NTSTATUS status;

    BeepPrint((2,"BEEP-BeepStartIo: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Acquire the cancel spinlock and verify that the CurrentIrp has not been
    // cancelled.
    //

    IoAcquireCancelSpinLock(&cancelIrql);
    if (Irp == NULL) {
        IoReleaseCancelSpinLock(cancelIrql);
        return;
    }

    //
    // Remove the request from the cancellable state and release the cancel
    // spinlock.
    //

    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(cancelIrql);

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Make a beep.  Call HalMakeBeep() to do the real work, and start
        // a timer that will fire when the beep duration is reached.  Finally,
        // complete the request.
        //

        case IOCTL_BEEP_SET:

            //
            // Get the beep parameters.
            //

            beepParameters = (PBEEP_SET_PARAMETERS)
                (Irp->AssociatedIrp.SystemBuffer);

            BeepPrint((
                3,
                "BEEP-BeepStartIo: frequency %x, duration %d\n",
                beepParameters->Frequency,
                beepParameters->Duration
                ));

            //
            // Cancel the current timer (if any).
            //

            if (deviceExtension->TimerSet) {
                if (KeCancelTimer(&deviceExtension->Timer)) {

                    //
                    // Timer successfully cancelled
                    //

                    InterlockedDecrement(&deviceExtension->TimerSet);

                } else {

                    //
                    // The timer has already expired and
                    // been queued, it will reset the
                    // TimerSet flag when it runs.
                    //

                }
            }

            //
            // Call the HAL to actually start the beep (synchronizes
            // access to the i8254 speaker.
            //
#if !defined(NO_LEGACY_DRIVERS)
            if (HalMakeBeep(beepParameters->Frequency)) {
#else
	    if (TRUE) {
#endif // NO_LEGACY_DRIVERS

                status = STATUS_SUCCESS;

                //
                // Set the timer so the beep will time out after
                // the user-specified number of milliseconds (converted
                // to 100ns resolution).
                //

                time.QuadPart = (LONGLONG)beepParameters->Duration * -10000;

                BeepPrint((
                    3,
                    "BEEP-BeepStartIo: negative duration in 100ns %x.%x\n",
                    time.HighPart,
                    time.LowPart
                    ));

                InterlockedIncrement(&deviceExtension->TimerSet);

                if (KeSetTimer(&deviceExtension->Timer, time,
                               &DeviceObject->Dpc)) {

                    InterlockedDecrement(&deviceExtension->TimerSet);
                }

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        //
        // Unrecognized device control request.
        //

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Start the next packet, and complete this request.
    //

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoStartNextPacket(DeviceObject, TRUE);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BeepPrint((2,"BEEP-BeepStartIo: exit\n"));

    return;

}

VOID
BeepTimeOut(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the driver's timeout routine.  It is called when the beep
    duration expires.  The timer is started in StartIo.

    N.B.  The request is removed from the cancellable state prior to
    the timer start, so there is no need to check the cancellation status
    here.

Arguments:

    DeviceObject - Pointer to the device object.

    Context - Unused.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    BeepPrint((2, "BEEP-BeepTimeOut: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Stop the beep.
    //
#if !defined(NO_LEGACY_DRIVERS)
    (VOID) HalMakeBeep(0);
#endif // NO_LEGACY_DRIVERS

    //
    // Clear the TimerSet flag
    //
    InterlockedDecrement(&deviceExtension->TimerSet);

    //
    // We don't have a request at this point -- it was completed in StartIo
    // when the beep was started.  So, there's no more work to do here.
    //
    
    BeepPrint((2, "BEEP-BeepTimeOut: exit\n"));
}

VOID
BeepUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the beep driver unload routine.

Arguments:

    DriverObject - Pointer to class driver object.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;



    BeepPrint((1,"BEEP-BeepUnload: enter\n"));

    deviceObject = DriverObject->DeviceObject;
    deviceExtension = deviceObject->DeviceExtension;

    //
    // Cancel the timer.
    //

    if (deviceExtension->TimerSet) {
        if (KeCancelTimer(&deviceExtension->Timer)) {

            //
            // Timer successfully cancelled
            //

            InterlockedDecrement(&deviceExtension->TimerSet);
        } else {

            //
            // The timer has already expired and
            // been queued, it will reset the
            // TimerSet flag when it runs.
            //

        }
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(deviceObject);
    BeepPrint((1,"BEEP-BeepUnload: exit\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\beep\dbg.h ===
#define BEEP_TAG         0x50454542 /* "BEEP" */

#if DBG

VOID
BeepDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define BeepPrint(x) BeepDebugPrint x
#else
#define BeepPrint(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\beep\power.c ===
#include "beep.h"
#include "dbg.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BeepPower)
#endif

VOID
BeepPowerTransitionPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
BeepPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BeepPower)
#endif

NTSTATUS
BeepPower (
    IN PDEVICE_OBJECT   DeviceObject,
    PIRP                Irp
    )
/*++
--*/
{
    PBEEP_EXTENSION     deviceExtension;
    NTSTATUS            status;
    BOOLEAN             hookit = FALSE;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;

    PAGED_CODE ();
    
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        BeepPrint((2,"Setting %s power state to %d\n",
                      ((powerType == SystemPowerState) ?  "System" : "Device"),
                      powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:

            status = Irp->IoStatus.Status = STATUS_SUCCESS;

            if (deviceExtension->DeviceState == powerState.DeviceState) {
                // Do nothing
                break;
            } else if (deviceExtension->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                PoSetPowerState (deviceExtension->Self, powerType, powerState);
                deviceExtension->DeviceState = powerState.DeviceState;
            } else {
                //
                // Powering Up
                //
                hookit = TRUE;
            }
            
            break;

        case SystemPowerState:
            if (deviceExtension->PowerQueryLock) {
                //
                // The reception of a power irp resolves the query lock.
                //
                deviceExtension->PowerQueryLock = FALSE;
            } else {
                ASSERT (deviceExtension->SystemState != powerState.SystemState);
            }

            if (deviceExtension->SystemState == powerState.SystemState) {
                status = STATUS_SUCCESS;

            } else if (deviceExtension->SystemState < powerState.SystemState) {
                //
                // Powering down
                //

                //
                // Request a D3 irp in response to this S irp.  The D3 irp must
                // completed before send this S irp down the stack.  We will send
                // the S irp down the stack when
                // BeepPowerTransitionPoRequestComplete is called.
                //

                //
                // We don't need to increment our IO count b/c we incremented it
                // at the beginning of this function and won't decrement it until
                // the S Irp completes
                // 
                IoMarkIrpPending (Irp);
                powerState.DeviceState = PowerDeviceD3;
                PoRequestPowerIrp (deviceExtension->Self,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   BeepPowerTransitionPoRequestComplete,
                                   Irp,
                                   NULL);  // no IRP
                
                return STATUS_PENDING;

            } else {
                //
                // Powering Up
                //
                
                // 
                // We must request a D irp for this S irp, but only after the S
                // irp has come back up the stack.  Hook the return of the irp
                // and request the D irp in BeepPowerComplete
                //
                hookit = TRUE;
            }
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        //
        deviceExtension->PowerQueryLock = TRUE;
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:
        break;
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    if (hookit) {
        ASSERT (STATUS_SUCCESS == status);
        IoSetCompletionRoutine (Irp,
                                BeepPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);

        PoCallDriver (deviceExtension->TopOfStack, Irp);
        return STATUS_PENDING;
    } else {
        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power
        // irp.  This can be called here, or in the completetion
        // routine, but never the less must be called.
        //
        PoStartNextPowerIrp (Irp);

        status =  PoCallDriver (deviceExtension->TopOfStack, Irp);
        
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    }

    return status;
}

VOID
BeepPowerTransitionPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  stack;
    PBEEP_EXTENSION deviceExtension;

    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (IoStatus);

    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (SystemStateIrp);

    if (DevicePowerState.DeviceState == PowerDeviceD0) {
        //
        // We are powering up (the D0 Irp just completed).  Since we sent the
        // S irp down the stack and requested the D irp on the way back up the
        // stack, just complete the S irp now
        //

        PoSetPowerState (DeviceObject,
                         stack->Parameters.Power.Type,
                         stack->Parameters.Power.State);
    
        deviceExtension->SystemState = stack->Parameters.Power.State.SystemState;

        //
        // Set the S irp's status to the status of the D irp.
        //
        SystemStateIrp->IoStatus.Status = IoStatus->Status;

        PoStartNextPowerIrp (SystemStateIrp);
        IoCompleteRequest (SystemStateIrp, IO_NO_INCREMENT);

        //
        // From BeepPower when we originally received the IRP
        //
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, SystemStateIrp);
    }
    else {
        //
        // We are powering down (the D3 Irp just completed).  Since we requested
        // the D irp before sending the S irp down the stack, we must send it 
        // down now.  We will catch the S irp on the way back up to record the 
        // S state
        //
        ASSERT (DevicePowerState.DeviceState == PowerDeviceD3);
    
        IoCopyCurrentIrpStackLocationToNext (SystemStateIrp);

        IoSetCompletionRoutine (SystemStateIrp,
                                BeepPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);
    
        PoCallDriver (deviceExtension->TopOfStack, SystemStateIrp);
    }
}

NTSTATUS
BeepPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PBEEP_EXTENSION     deviceExtension;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (Context);

    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;
    status = STATUS_SUCCESS; 

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:

            //
            // Power up complete
            //
            ASSERT (powerState.DeviceState < deviceExtension->DeviceState);
            deviceExtension->DeviceState = powerState.DeviceState;
            PoSetPowerState (deviceExtension->Self, powerType, powerState);
            break;

        case SystemPowerState:
            if (powerState.SystemState > deviceExtension->SystemState) {
                //
                // Powering Down...
                //
                // We are on the completion end of an S irp.  (The D3 power irp
                // has already been sent and completed down this stack.)  The
                // remaining thing to do is set the state in the extension, then
                // decrement the IoCount that was incremented when we first got
                // the irp (this is done at the end of this function).
                //
                deviceExtension->SystemState = powerState.SystemState;

                PoSetPowerState (deviceExtension->Self,
                                 stack->Parameters.Power.Type,
                                 stack->Parameters.Power.State);
            }
            else {
                //
                // Powering Up...
                //
                // Request a D power irp for ourself.  Do not complete this S irp
                // until the D irp has been completed.  (Completion of the S irp
                // is done in BeepPowerTransitionPoRequestComplete). 
                // Decrementing the IO count will happen in the same function.
                //
                ASSERT (powerState.SystemState < deviceExtension->SystemState);
    
                powerState.DeviceState = PowerDeviceD0;
                PoRequestPowerIrp (deviceExtension->Self,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   BeepPowerTransitionPoRequestComplete,
                                   Irp, 
                                   NULL); // no return Irp
    
                //
                // Inform the IO subsystem not to touch the irp here 
                //
                // The irp might completed by the time we get here, so call
                // PoStartNextPowerIrp in the PO irp completion function.
                //
                status = STATUS_MORE_PROCESSING_REQUIRED; 
            }
            break;
        }
        break;

    default:
        #define BEEP_UNHANDLED_MN_POWER 0x0
        ASSERT (0xBADBAD == BEEP_UNHANDLED_MN_POWER);
        #undef BEEP_UNHANDLED_MN_POWER 
        
        status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (NT_SUCCESS(status)) {
        PoStartNextPowerIrp (Irp);
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\beep\pnp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    This module contains contains the plugplay calls
    PNP / WDM BUS driver.

Author:

    Jay Senior (jsenior) 5/4/99 (ya, ya, y2k, blah)

Environment:

    Kernel mode only.

Notes:


Revision History:

    Jay Senior (jsenior) 5/4/99 - Made driver PnP

--*/

#include "beep.h"
#include "dbg.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,BeepAddDevice)
#pragma alloc_text(PAGE,BeepPnP)
#endif

NTSTATUS
BeepAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    BusPhysicalDeviceObject - Device object representing the bus.  That to which
        we attach a new FDO.

    DriverObject - This very self referenced driver.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PBEEP_EXTENSION deviceExtension;
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    
    PAGED_CODE ();

    BeepPrint((3,"Entering Add Device.\n"));
    
    RtlInitUnicodeString(&unicodeString, DD_BEEP_DEVICE_NAME_U);
    //
    // Create non-exclusive device object for beep device.
    //
    status = IoCreateDevice(
                DriverObject,
                sizeof(BEEP_EXTENSION),
                &unicodeString,
                FILE_DEVICE_BEEP,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &deviceObject
                );
    
    if (!NT_SUCCESS(status)) {
        BeepPrint((1,"Could not create device object!\n"));
        return status;
    }
    
    deviceExtension =
        (PBEEP_EXTENSION)deviceObject->DeviceExtension;
    
    //
    // Initialize the timer DPC queue (we use the device object DPC) and
    // the timer itself.
    //
    
    IoInitializeDpcRequest(
            deviceObject,
            (PKDEFERRED_ROUTINE) BeepTimeOut
            );
    
    KeInitializeTimer(&deviceExtension->Timer);
    
    //
    // Initialize the fast mutex and set the reference count to zero.
    //
    ExInitializeFastMutex(&deviceExtension->Mutex);
    deviceExtension->DeviceState = PowerDeviceD0;
    deviceExtension->SystemState = PowerSystemWorking;
    
    // Set the PDO for use with PlugPlay functions
    deviceExtension->Self = deviceObject;
    deviceExtension->UnderlyingPDO = BusPhysicalDeviceObject;
        
    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    deviceExtension->TopOfStack = IoAttachDeviceToDeviceStack (
                                    deviceObject,
                                    BusPhysicalDeviceObject);

    deviceObject->Flags |= DO_BUFFERED_IO;
    
    IoInitializeRemoveLock (&deviceExtension->RemoveLock, 
                            BEEP_TAG,
                            1,
                            5); // One for pnp, one for power, one for io

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    deviceObject->Flags |= DO_POWER_PAGABLE;

    return status;
}

NTSTATUS
BeepPnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Pirp,
    IN PVOID            Context
    );

NTSTATUS
BeepPnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    PBEEP_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    KEVENT                  event;
    ULONG                   i;

    PAGED_CODE ();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_PNP == irpStack->MajorFunction);
    deviceExtension = (PBEEP_EXTENSION) DeviceObject->DeviceExtension;
    
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //

        BeepPrint ((2,"Start Device\n"));

        if (deviceExtension->Started) {
            BeepPrint ((2,"Device already started\n"));
            status = STATUS_SUCCESS;
            break;
        }

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                BeepPnPComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (deviceExtension->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {
            deviceExtension->Started = TRUE;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //

        Irp->IoStatus.Information = 0;
        break;

    case IRP_MN_REMOVE_DEVICE:
        BeepPrint ((2, "Remove Device\n"));

        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choice but to detach and delete the device object.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //

        //
        // We will accept no new requests
        //
        ExAcquireFastMutex(&deviceExtension->Mutex);
        deviceExtension->Started = FALSE;
        ExReleaseFastMutex(&deviceExtension->Mutex);
    
        //
        // Complete any outstanding IRPs queued by the driver here.
        //
    
        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now. 
        // We don't need to check the timer, because that has been done for us
        // in close.
    
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //
        //
        // Fire and forget
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        IoCallDriver (deviceExtension->TopOfStack, Irp);

        //
        // Wait for all outstanding requests to complete
        //
        BeepPrint ((2,"Waiting for outstanding requests\n"));
        IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock,
                                   Irp);
        
        //
        // Free the associated resources
        //

        //
        // Detach from the underlying devices.
        //
        BeepPrint((3, "IoDetachDevice: 0x%x\n", deviceExtension->TopOfStack));
        IoDetachDevice (deviceExtension->TopOfStack);

        //
        // Clean up any resources here
        //
        BeepPrint((3, "IoDeleteDevice: 0x%x\n", DeviceObject));

        IoDeleteDevice(DeviceObject);

        return STATUS_SUCCESS;

    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //
        BeepPrint ((3, "PnP Default Case, minor = 0x%x.\n", irpStack->MinorFunction));

        //
        // Fire and Forget
        //
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Done, do NOT complete the IRP, it will be processed by the lower
        // device object, which will complete the IRP
        //

        status = IoCallDriver (deviceExtension->TopOfStack, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    return status;
}

NTSTATUS
BeepPnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\dummyfdo\dummyfdo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dummyfdo

Abstract

    A little driver to fool the Wise old PlugPlay system

Author:

    Kenneth Ray

Environment:

    Kernel mode only

Revision History:

--*/

#include <wdm.h>

NTSTATUS
Dummy_AddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    PDEVICE_OBJECT  device;
    IoCreateDevice (DriverObject, 0, NULL, 0, 0, FALSE, &device);
    DriverObject->DriverExtension->AddDevice = Dummy_AddDevice;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\mountmgr\kdmm\precomp.h ===
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Prevent hal.h, included in ntos.h from overriding _BUS_DATA_TYPE
// enum found in ntioapi.h, included from nt.h.
//
#define _HAL_
#include <ntos.h>

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#include "mountmgr.h"
#include "mountdev.h"
#include "mntmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\mountmgr\mntmgr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mntmgr.h

Abstract:

    This file defines the internal data structure for the MOUNTMGR driver.

Author:

    norbertk

Revision History:

--*/

#define MOUNTED_DEVICES_KEY         L"\\Registry\\Machine\\System\\MountedDevices"
#define MOUNTED_DEVICES_OFFLINE_KEY L"\\Registry\\Machine\\System\\MountedDevices\\Offline"

typedef struct _SYMBOLIC_LINK_NAME_ENTRY {
    LIST_ENTRY      ListEntry;
    UNICODE_STRING  SymbolicLinkName;
    BOOLEAN         IsInDatabase;
} SYMBOLIC_LINK_NAME_ENTRY, *PSYMBOLIC_LINK_NAME_ENTRY;

typedef struct _REPLICATED_UNIQUE_ID {
    LIST_ENTRY          ListEntry;
    PMOUNTDEV_UNIQUE_ID UniqueId;
} REPLICATED_UNIQUE_ID, *PREPLICATED_UNIQUE_ID;

struct _DEVICE_EXTENSION;
typedef struct _DEVICE_EXTENSION DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _MOUNTED_DEVICE_INFORMATION {
    LIST_ENTRY          ListEntry;
    LIST_ENTRY          SymbolicLinkNames;
    LIST_ENTRY          ReplicatedUniqueIds;
    LIST_ENTRY          MountPointsPointingHere;
    UNICODE_STRING      NotificationName;
    PMOUNTDEV_UNIQUE_ID UniqueId;
    UNICODE_STRING      DeviceName;
    BOOLEAN             KeepLinksWhenOffline;
    UCHAR               SuggestedDriveLetter;
    BOOLEAN             NotAPdo;
    BOOLEAN             IsRemovable;
    BOOLEAN             NextDriveLetterCalled;
    BOOLEAN             ReconcileOnMounts;
    BOOLEAN             HasDanglingVolumeMountPoint;
    PVOID               TargetDeviceNotificationEntry;
    PDEVICE_EXTENSION   Extension;
} MOUNTED_DEVICE_INFORMATION, *PMOUNTED_DEVICE_INFORMATION;

typedef struct _SAVED_LINKS_INFORMATION {
    LIST_ENTRY          ListEntry;
    LIST_ENTRY          SymbolicLinkNames;
    PMOUNTDEV_UNIQUE_ID UniqueId;
} SAVED_LINKS_INFORMATION, *PSAVED_LINKS_INFORMATION;

struct _DEVICE_EXTENSION {

    //
    // A pointer to our own device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // A pointer to the driver object.
    //

    PDRIVER_OBJECT DriverObject;

    //
    // A linked list mounted devices.
    //

    LIST_ENTRY MountedDeviceList;

    //
    // A linked list of unresponsive mounted devices.
    //

    LIST_ENTRY DeadMountedDeviceList;

    //
    // Notification entry.
    //

    PVOID NotificationEntry;

    //
    // For synchronization.
    //

    KSEMAPHORE Mutex;

    //
    // Synchronization for the Remote databases.
    //

    KSEMAPHORE RemoteDatabaseSemaphore;

    //
    // Specifies whether or not to automatically assign drive letters.
    //

    BOOLEAN AutomaticDriveLetterAssignment;

    //
    // Change notify list.  Protect with cancel spin lock.
    //

    LIST_ENTRY ChangeNotifyIrps;

    //
    // Change notify epic number.  Protect with 'mutex'.
    //

    ULONG EpicNumber;

    //
    // A list of saved links.
    //

    LIST_ENTRY SavedLinksList;

    //
    // Indicates whether or not the suggested drive letters have been
    // processed.
    //

    BOOLEAN SuggestedDriveLettersProcessed;

    //
    // A thread to be used for verifying remote databases.
    //

    LIST_ENTRY WorkerQueue;
    KSEMAPHORE WorkerSemaphore;
    LONG WorkerRefCount;
    KSPIN_LOCK WorkerSpinLock;

    LIST_ENTRY UniqueIdChangeNotifyList;

    //
    // System Partition Unique Id.
    //

    PMOUNTDEV_UNIQUE_ID SystemPartitionUniqueId;

};

typedef struct _MOUNTMGR_FILE_ENTRY {
    ULONG EntryLength;
    ULONG RefCount;
    USHORT VolumeNameOffset;
    USHORT VolumeNameLength;
    USHORT UniqueIdOffset;
    USHORT UniqueIdLength;
} MOUNTMGR_FILE_ENTRY, *PMOUNTMGR_FILE_ENTRY;

typedef struct _MOUNTMGR_MOUNT_POINT_ENTRY {
    LIST_ENTRY                  ListEntry;
    PMOUNTED_DEVICE_INFORMATION DeviceInfo;
    UNICODE_STRING              MountPath;
} MOUNTMGR_MOUNT_POINT_ENTRY, *PMOUNTMGR_MOUNT_POINT_ENTRY;

typedef struct _MOUNTMGR_DEVICE_ENTRY {
    LIST_ENTRY                  ListEntry;
    PMOUNTED_DEVICE_INFORMATION DeviceInfo;
} MOUNTMGR_DEVICE_ENTRY, *PMOUNTMGR_DEVICE_ENTRY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\beep\testbeep.c ===
#include "ntos.h"
#include <ntddbeep.h>

#define CANCEL


BOOLEAN test1();

int
main(
    int argc,
    char *argv[]
    )
{
    UCHAR error = FALSE;

    DbgPrint( "Test1...\n" );
    if (!test1()) {
        DbgPrint("Error:  Test 1 failed\n");
        error = TRUE;
    }
    return error;
}


VOID
BeepApc(
    PVOID BeepApcContext,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    );


BOOLEAN
test1()
{
    HANDLE FileHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatus;
    BEEP_SET_PARAMETERS BeepParameters;
#ifdef CANCEL
    IO_STATUS_BLOCK CancelStatus;
    TIME Interval;
#endif

    //
    // Open the beep device in synchronous mode.
    //

    DbgPrint( "test 1: opening beep\n");

    RtlInitString( &NameString, "\\Device\\Beep" );
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &NameString, TRUE );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - RtlAnsiStringToUnicodeString\n",Status);
        return FALSE;
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                  &UnicodeString,
                                  0,
                                  NULL,
                                  NULL
                                );
    Status = NtCreateFile( &FileHandle,
                           FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
                           &ObjectAttributes,
                           &IoStatus,
                           (PLARGE_INTEGER) NULL,
                           0L,
                           0L,
                           FILE_OPEN_IF,
                           FILE_SYNCHRONOUS_IO_ALERT,
                           (PVOID) NULL,
                           0L );

    RtlFreeUnicodeString( &UnicodeString );

    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - beep open \n",Status);
        return FALSE;
    }

    if (IoStatus.Status != STATUS_SUCCESS) {
        DbgPrint( "test 2: Wrong I/O Status value %X - beep open \n",IoStatus.Status);
        return FALSE;
    }

    if (IoStatus.Information != 0L) {
        DbgPrint( "test 1: Wrong I/O Status information value %ld - beep open \n",IoStatus.Information);
        return FALSE;
    }
    DbgPrint( "test 1: opened beep device successfully\n");

    //
    // Beep at different frequencies.
    //

    DbgPrint( "test 1: calling beep device with varying frequencies\n");

    BeepParameters.Duration = 1000;
    for (BeepParameters.Frequency = 18; BeepParameters.Frequency <= 10000;
             BeepParameters.Frequency += 100) {

        DbgPrint( "test 1: Set beep frequency %ld\n", BeepParameters.Frequency);
        Status = NtDeviceIoControlFile(FileHandle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   (PVOID) NULL,
                                   &IoStatus,
                                   IOCTL_BEEP_SET,
                                   &BeepParameters,    // input buffer
                                   sizeof(BeepParameters),
                                   NULL, // output buffer
                                   0
                                  );

        if (Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong return value %lX - beep set\n",Status);
        } else if (IoStatus.Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong I/O Status value %lX - beep set\n",IoStatus.Status);
        }

        if (IoStatus.Information != 0) {
            DbgPrint( "test 1: Wrong I/O Status information value %ld - beep set\n",IoStatus.Information);
        }

        if (BeepParameters.Duration)
            Interval.LowTime = -(BeepParameters.Duration*1000*10);
        else
            Interval.LowTime = -(10*1000*10);
        Interval.HighTime = -1;
        NtDelayExecution(FALSE, &Interval);

    } // end for
    DbgPrint("\n");

    DbgPrint( "test 1: calling beep device with varying durations\n");

    BeepParameters.Frequency = 600;
    for (BeepParameters.Duration = 0; BeepParameters.Duration <= 4000;
             BeepParameters.Duration += 100) {

        DbgPrint( "test 1: Set beep duration %ld\n", BeepParameters.Duration);
        Status = NtDeviceIoControlFile(FileHandle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   (PVOID) NULL,
                                   &IoStatus,
                                   IOCTL_BEEP_SET,
                                   &BeepParameters,    // input buffer
                                   sizeof(BeepParameters),
                                   NULL, // output buffer
                                   0
                                  );

        if (Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong return value %lX - beep set\n",Status);
        } else if (IoStatus.Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong I/O Status value %lX - beep set\n",IoStatus.Status);
        }

        if (IoStatus.Information != 0) {
            DbgPrint( "test 1: Wrong I/O Status information value %ld - beep set\n",IoStatus.Information);
        }

        if (BeepParameters.Duration)
            Interval.LowTime = -(BeepParameters.Duration*1000*10);
        else
            Interval.LowTime = -(10*1000*10);
        Interval.HighTime = -1;
        NtDelayExecution(FALSE, &Interval);

    } // end for
    DbgPrint("\n");

#ifdef CANCEL

    //
    // Now test cancellation by issuing an asynchronous beep request
    // and then cancelling the request.  Need to reopen the beep
    // device for asynchronous access.
    //

    DbgPrint("----------------- testing cancellation.\n");

    Status = NtClose( FileHandle );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %lX - beep close \n",Status);
        return FALSE;
    }

    RtlInitString( &NameString, "\\Device\\Beep" );
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &NameString, TRUE );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - RtlAnsiStringToUnicodeString\n",Status);
        return FALSE;
    }
    InitializeObjectAttributes( &ObjectAttributes,
                                  &UnicodeString,
                                  0,
                                  NULL,
                                  NULL
                                );

    Status = NtCreateFile( &FileHandle,
                           FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatus,
                           (PLARGE_INTEGER) NULL,
                           0L,
                           0L,
                           FILE_OPEN_IF,
                           0,
                           (PVOID) NULL,
                           0L );

    RtlFreeUnicodeString( &UnicodeString );

    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %X - beep asynch reopen\n",Status);
        return FALSE;
    }

    DbgPrint( "test 1: successfully reopened beep device for asynch access\n");

    BeepParameters.Frequency = 600;
    BeepParameters.Duration  = 60000;
    Status = NtDeviceIoControlFile(FileHandle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) BeepApc,
                                   (PVOID) NULL,
                                   &IoStatus,
                                   IOCTL_BEEP_SET,
                                   &BeepParameters,    // input buffer
                                   sizeof(BeepParameters),
                                   NULL, // output buffer
                                   0
                                  );

    if (Status != STATUS_PENDING) {
        DbgPrint( "test 1: Wrong return value %lX - beep set asynch\n",Status);
    }

    Status = NtCancelIoFile(FileHandle, &CancelStatus);

    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %lX - beep cancel\n",Status);
        return FALSE;
    }

    if (CancelStatus.Status != STATUS_SUCCESS) {
            DbgPrint( "test 1: Wrong I/O Status value %lX - beep cancel \n",CancelStatus.Status);
    }

    DbgPrint("Successfully cancelled a request.\n");

    //
    // Delay in an alertable state, to allow the BeepApc to fire.
    //

    Interval.HighTime = -1;
    Interval.LowTime = -(10*1000*10);
    NtDelayExecution(TRUE, &Interval);

#endif // CANCEL

    //
    // Now close the beep device
    //

    DbgPrint("test 1:  closing beep device\n");

    Status = NtClose( FileHandle );
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "test 1: Wrong return value %lX - beep close \n",Status);
        return FALSE;
    }
    return TRUE;
}

VOID
BeepApc(
    PVOID BeepApcContext,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    )
{

        if (IoStatus->Status != STATUS_CANCELLED) {
            DbgPrint( "test1 APC: Expected CANCELLED, got I/O Status value %lX - beep set\n",IoStatus->Status);
        } else {
            DbgPrint("test1 APC: Request CANCELLED.\n");
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\mountmgr\kdmm\kdmm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdmm.c

Abstract:

    Mount mgr driver KD extension - based on Vert's skeleton

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"

//
// globals
//

EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

#define TrueOrFalse( _x )  ( _x ? "True" : "False" )

/* forwards */

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    );

__inline PCHAR
ListInUse(
    PLIST_ENTRY
    );

__inline PCHAR
TrueFalse(
    BOOLEAN Value
    );

/* end forwards */

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( dumpdb )
/*
 *   dump the mount mgr database
 */
{
    PDEVICE_EXTENSION TargetExt;
    DEVICE_EXTENSION LocalExt;
    PMOUNTED_DEVICE_INFORMATION TargetDevInfo;
    PMOUNTED_DEVICE_INFORMATION LastDevInfo;
    MOUNTED_DEVICE_INFORMATION LocalDevInfo;
    MOUNTDEV_UNIQUE_ID LocalUniqueId;
    PSYMBOLIC_LINK_NAME_ENTRY TargetSymLink;
    PSYMBOLIC_LINK_NAME_ENTRY LastSymLink;
    SYMBOLIC_LINK_NAME_ENTRY LocalSymLink;
    WCHAR NameBuffer[512];
    UCHAR UniqueIdBuffer[512];
    PUCHAR pUniqueId;

    //
    // convert address of extension in target machine
    //

    TargetExt = (PDEVICE_EXTENSION)GetExpression( args );

    if ( !TargetExt ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read in extension from target machine
    //

    if ( !ReadTargetMemory((PVOID)TargetExt,
                           (PVOID)&LocalExt,
                           sizeof(DEVICE_EXTENSION))) {
        return;
    }

    TargetDevInfo = (PMOUNTED_DEVICE_INFORMATION)LocalExt.MountedDeviceList.Flink;
    LastDevInfo = (PMOUNTED_DEVICE_INFORMATION)&TargetExt->MountedDeviceList.Flink;

    while ( TargetDevInfo != LastDevInfo ) {

        if (CheckControlC()) {
            return;
        }

        if ( !ReadTargetMemory(TargetDevInfo,
                               &LocalDevInfo,
                               sizeof( MOUNTED_DEVICE_INFORMATION )))
        {
            dprintf("Problem reading mounted device info at %08X\n", TargetDevInfo );
            return;
        }

        dprintf( "Mounted Device Info @ %08X\n", TargetDevInfo );

        if ( ReadTargetMemory((PVOID)LocalDevInfo.NotificationName.Buffer,
                              (PVOID)&NameBuffer,
                              LocalDevInfo.NotificationName.Length)) {

            dprintf( "    NotificationName: %.*ws\n",
                     LocalDevInfo.NotificationName.Length/sizeof(WCHAR),
                     NameBuffer);
        } else {
            dprintf( "    NotificationName @ %08X\n", LocalDevInfo.NotificationName.Buffer );
        }

        if ( ReadTargetMemory((PVOID)LocalDevInfo.UniqueId,
                              (PVOID)&LocalUniqueId,
                              sizeof(LocalUniqueId))) {

            dprintf( "    Unique ID Length = %u bytes\n    UniqueId",
                     LocalUniqueId.UniqueIdLength);

            if ( ReadTargetMemory((PVOID)LocalDevInfo.UniqueId->UniqueId,
                                  (PVOID)UniqueIdBuffer,
                                  LocalUniqueId.UniqueIdLength)) {
                dprintf(": ");
                pUniqueId = UniqueIdBuffer;
                while ( LocalUniqueId.UniqueIdLength-- )
                    dprintf( "%02X ", *pUniqueId++ );
            } else {
                dprintf( " @ %08X", LocalDevInfo.UniqueId->UniqueId );
            }
            dprintf( "\n" );

        } else {
            dprintf( "    UniqueId @ %08X\n", LocalDevInfo.UniqueId );
        }

        if ( ReadTargetMemory((PVOID)LocalDevInfo.DeviceName.Buffer,
                              (PVOID)&NameBuffer,
                              LocalDevInfo.DeviceName.Length)) {

            dprintf( "    DeviceName: %.*ws\n",
                     LocalDevInfo.DeviceName.Length/sizeof(WCHAR),
                     NameBuffer);
        } else {
            dprintf( "    DeviceName @ %08X\n", LocalDevInfo.DeviceName.Buffer );
        }

        TargetSymLink = (PSYMBOLIC_LINK_NAME_ENTRY)LocalDevInfo.SymbolicLinkNames.Flink;
        LastSymLink = (PSYMBOLIC_LINK_NAME_ENTRY)&TargetDevInfo->SymbolicLinkNames.Flink;

        while ( TargetSymLink != LastSymLink ) {

            if (CheckControlC()) {
                return;
            }

            if ( !ReadTargetMemory(TargetSymLink,
                                   &LocalSymLink,
                                   sizeof( SYMBOLIC_LINK_NAME_ENTRY )))
            {
                dprintf("Problem reading symlink entry at %08X\n", TargetSymLink );
                return;
            }

            if ( ReadTargetMemory((PVOID)LocalSymLink.SymbolicLinkName.Buffer,
                                  (PVOID)&NameBuffer,
                                  LocalSymLink.SymbolicLinkName.Length)) {

                dprintf( "        SymbolicLinkName: %.*ws\n",
                         LocalSymLink.SymbolicLinkName.Length/sizeof(WCHAR),
                         NameBuffer);
            } else {
                dprintf( "        SymbolicLinkName @ %08X\n", LocalSymLink.SymbolicLinkName.Buffer );
            }

            dprintf( "        IsInDatabase = %s\n", LocalSymLink.IsInDatabase ? "TRUE" : "FALSE" );

            TargetSymLink = (PSYMBOLIC_LINK_NAME_ENTRY)LocalSymLink.ListEntry.Flink;
        }

        TargetDevInfo = (PMOUNTED_DEVICE_INFORMATION)LocalDevInfo.ListEntry.Flink;
    }
}

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    )
{
    BOOL success;
    ULONG BytesRead;

    success = ReadMemory((ULONG)TargetAddress, LocalBuffer, BytesToRead, &BytesRead);

    if (success) {

        if (BytesRead != BytesToRead) {

            dprintf("wrong byte count. expected=%d, read =%d\n", BytesToRead, BytesRead);
        }

    } else {
        dprintf("Problem reading memory at %08X for %u bytes\n",
                TargetAddress, BytesToRead);

        success = FALSE;
    }

    return success;
}

__inline PCHAR
ListInUse(
    PLIST_ENTRY ListToCheck
    )
{
    return ListToCheck->Flink == ListToCheck->Blink ? "(empty)" : "";
}

DECLARE_API( help )
{
    dprintf("Mountmgr kd extensions\n\n");
    dprintf("dumpdb <mntmgr dev extension addr>- dump the mount mgr database\n");
    dprintf( "      use !devobj mountpointmanager to get dev extension addr\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\mountmgr\mountmgr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mountmgr.c

Abstract:

    This driver manages the kernel mode mount table that handles the level
    of indirection between the persistent dos device name for an object and
    the non-persistent nt device name for an object.

Author:

    Norbert Kusters      20-May-1997

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#define _NTSRV_

#include <ntosp.h>
#include <zwapi.h>
#include <initguid.h>
#include <ntdddisk.h>
#include <ntddvol.h>
#include <initguid.h>
#include <wdmguid.h>
#include <mountmgr.h>
#include <mountdev.h>
#include <mntmgr.h>
#include <stdio.h>
#include <ioevent.h>

// NOTE, this structure is here because it was not defined in NTIOAPI.H.
// This should be taken out in the future.
// This is stolen from NTFS.H

typedef struct _REPARSE_INDEX_KEY {

    //
    //  The tag of the reparse point.
    //

    ULONG FileReparseTag;

    //
    //  The file record Id where the reparse point is set.
    //

    LARGE_INTEGER FileId;

} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;

#define MAX_VOLUME_PATH 100

#define IOCTL_MOUNTMGR_QUERY_POINTS_ADMIN           CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_READ_ACCESS)

#define SYMBOLIC_LINK_NAME L"\\DosDevices\\MountPointManager"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
UniqueIdChangeNotifyCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           WorkItem
    );

NTSTATUS
MountMgrChangeNotify(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    );

VOID
MountMgrNotify(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ReconcileThisDatabaseWithMaster(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    );


NTSTATUS
MountMgrMountedDeviceRemoval(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     NotificationName
    );

VOID
MountMgrUnload(
    IN PDRIVER_OBJECT DriverObject
    );

typedef struct _RECONCILE_WORK_ITEM_INFO {
    PDEVICE_EXTENSION           Extension;
    PMOUNTED_DEVICE_INFORMATION DeviceInfo;
} RECONCILE_WORK_ITEM_INFO, *PRECONCILE_WORK_ITEM_INFO;

typedef VOID (*PRECONCILE_WRKRTN) (
    IN  PVOID   WorkItem
    );

typedef struct _RECONCILE_WORK_ITEM {
    LIST_ENTRY               List;
    PIO_WORKITEM             WorkItem;
    PRECONCILE_WRKRTN        WorkerRoutine;
    PVOID                    Parameter;
    RECONCILE_WORK_ITEM_INFO WorkItemInfo;
} RECONCILE_WORK_ITEM, *PRECONCILE_WORK_ITEM;

NTSTATUS
QueueWorkItem(
    IN  PDEVICE_EXTENSION    Extension,
    IN  PRECONCILE_WORK_ITEM WorkItem,
    IN  PVOID                Parameter
    );


#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' tnM')
#endif

//
// Globals
//
PDEVICE_OBJECT gdeviceObject = NULL;
KEVENT UnloadEvent;
LONG Unloading = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, MountMgrUnload)
#endif

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif


NTSTATUS
CreateStringWithGlobal(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING StringWithGlobal
    )

{
    UNICODE_STRING  dosDevices, dosPrefix, globalReplace, newSource;

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");
    RtlInitUnicodeString(&dosPrefix, L"\\??\\");
    RtlInitUnicodeString(&globalReplace, L"\\GLOBAL??\\");

    if (RtlPrefixUnicodeString(&dosDevices, SymbolicLinkName, TRUE)) {

        newSource.Length = SymbolicLinkName->Length + globalReplace.Length -
                           dosDevices.Length;
        newSource.MaximumLength = newSource.Length + sizeof(WCHAR);
        newSource.Buffer = ExAllocatePool(PagedPool, newSource.MaximumLength);
        if (!newSource.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(newSource.Buffer, globalReplace.Buffer,
                      globalReplace.Length);
        RtlCopyMemory((PCHAR) newSource.Buffer + globalReplace.Length,
                      (PCHAR) SymbolicLinkName->Buffer + dosDevices.Length,
                      SymbolicLinkName->Length - dosDevices.Length);
        newSource.Buffer[newSource.Length/sizeof(WCHAR)] = 0;

    } else if (RtlPrefixUnicodeString(&dosPrefix, SymbolicLinkName, TRUE)) {

        newSource.Length = SymbolicLinkName->Length + globalReplace.Length -
                           dosPrefix.Length;
        newSource.MaximumLength = newSource.Length + sizeof(WCHAR);
        newSource.Buffer = ExAllocatePool(PagedPool, newSource.MaximumLength);
        if (!newSource.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(newSource.Buffer, globalReplace.Buffer,
                      globalReplace.Length);
        RtlCopyMemory((PCHAR) newSource.Buffer + globalReplace.Length,
                      (PCHAR) SymbolicLinkName->Buffer + dosPrefix.Length,
                      SymbolicLinkName->Length - dosPrefix.Length);
        newSource.Buffer[newSource.Length/sizeof(WCHAR)] = 0;

    } else {

        newSource = *SymbolicLinkName;
        newSource.Buffer = ExAllocatePool(PagedPool, newSource.MaximumLength);
        if (!newSource.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(newSource.Buffer, SymbolicLinkName->Buffer,
                      SymbolicLinkName->MaximumLength);
    }

    *StringWithGlobal = newSource;

    return STATUS_SUCCESS;
}

NTSTATUS
GlobalCreateSymbolicLink(
    IN  PUNICODE_STRING SymbolicLinkName,
    IN  PUNICODE_STRING DeviceName
    )

{
    NTSTATUS        status;
    UNICODE_STRING  newSource;

    status = CreateStringWithGlobal(SymbolicLinkName, &newSource);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = IoCreateSymbolicLink(&newSource, DeviceName);
    ExFreePool(newSource.Buffer);

    return status;
}

NTSTATUS
GlobalDeleteSymbolicLink(
    IN  PUNICODE_STRING SymbolicLinkName
    )

{
    NTSTATUS        status;
    UNICODE_STRING  newSource;

    status = CreateStringWithGlobal(SymbolicLinkName, &newSource);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = IoDeleteSymbolicLink(&newSource);
    ExFreePool(newSource.Buffer);

    return status;
}

NTSTATUS
QueryDeviceInformation(
    IN  PUNICODE_STRING         NotificationName,
    OUT PUNICODE_STRING         DeviceName,
    OUT PMOUNTDEV_UNIQUE_ID*    UniqueId,
    OUT PBOOLEAN                IsRemovable,
    OUT PBOOLEAN                IsRecognized,
    OUT PBOOLEAN                IsStable,
    OUT GUID*                   StableGuid,
    OUT PBOOLEAN                IsFT
    )

/*++

Routine Description:

    This routine queries device information.

Arguments:

    NotificationName    - Supplies the notification name.

    DeviceName          - Returns the device name.

    UniqueId            - Returns the unique id.

    IsRemovable         - Returns whether or not the device is removable.

    IsRecognized        - Returns whether or not this is a recognized partition
                            type.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                                status, status2;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;
    BOOLEAN                                 isRemovable;
    VOLUME_GET_GPT_ATTRIBUTES_INFORMATION   gptAttributesInfo;
    PARTITION_INFORMATION_EX                partInfo;
    KEVENT                                  event;
    PIRP                                    irp;
    IO_STATUS_BLOCK                         ioStatus;
    ULONG                                   outputSize;
    PMOUNTDEV_NAME                          output;
    PIO_STACK_LOCATION                      irpSp;
    STORAGE_DEVICE_NUMBER                   number;

    status = IoGetDeviceObjectPointer(NotificationName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    if (fileObject->FileName.Length) {
        ObDereferenceObject(fileObject);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if (fileObject->DeviceObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        isRemovable = TRUE;
    } else {
        isRemovable = FALSE;
    }

    if (IsRemovable) {
        *IsRemovable = isRemovable;
    }

    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    if (IsRecognized) {
        *IsRecognized = TRUE;

        if (!isRemovable) {
            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_VOLUME_GET_GPT_ATTRIBUTES, deviceObject, NULL, 0,
                    &gptAttributesInfo, sizeof(gptAttributesInfo), FALSE,
                    &event, &ioStatus);
            if (!irp) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);
                status = ioStatus.Status;
            }

            if (NT_SUCCESS(status)) {
                if (gptAttributesInfo.GptAttributes&
                    GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER) {

                    *IsRecognized = FALSE;
                }
            } else {
                status = STATUS_SUCCESS;
            }
        }
    }

    if (IsFT) {

        *IsFT = FALSE;

        if (!isRemovable) {

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_DISK_GET_PARTITION_INFO_EX, deviceObject, NULL, 0,
                    &partInfo, sizeof(partInfo), FALSE, &event, &ioStatus);
            if (!irp) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);
                status = ioStatus.Status;
            }

            if (NT_SUCCESS(status)) {
                if (partInfo.PartitionStyle == PARTITION_STYLE_MBR) {
                    if (IsFT && IsFTPartition(partInfo.Mbr.PartitionType)) {
                        *IsFT = TRUE;
                    }
                }
            } else {
                status = STATUS_SUCCESS;
            }
        }

        if (*IsFT) {

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_STORAGE_GET_DEVICE_NUMBER, deviceObject, NULL, 0,
                    &number, sizeof(number), FALSE, &event, &ioStatus);
            if (!irp) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);
                status = ioStatus.Status;
            }

            if (NT_SUCCESS(status)) {
                *IsFT = FALSE;
            } else {
                status = STATUS_SUCCESS;
            }
        }
    }

    if (DeviceName) {

        outputSize = sizeof(MOUNTDEV_NAME);
        output = ExAllocatePool(PagedPool, outputSize);
        if (!output) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_DEVICE_NAME, deviceObject, NULL, 0, output,
              outputSize, FALSE, &event, &ioStatus);
        if (!irp) {
            ExFreePool(output);
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (status == STATUS_BUFFER_OVERFLOW) {

            outputSize = sizeof(MOUNTDEV_NAME) + output->NameLength;
            ExFreePool(output);
            output = ExAllocatePool(PagedPool, outputSize);
            if (!output) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                  IOCTL_MOUNTDEV_QUERY_DEVICE_NAME, deviceObject, NULL, 0, output,
                  outputSize, FALSE, &event, &ioStatus);
            if (!irp) {
                ExFreePool(output);
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                status = ioStatus.Status;
            }
        }

        if (NT_SUCCESS(status)) {

            DeviceName->Length = output->NameLength;
            DeviceName->MaximumLength = output->NameLength + sizeof(WCHAR);
            DeviceName->Buffer = ExAllocatePool(PagedPool,
                                                DeviceName->MaximumLength);
            if (DeviceName->Buffer) {

                RtlCopyMemory(DeviceName->Buffer, output->Name,
                              output->NameLength);
                DeviceName->Buffer[DeviceName->Length/sizeof(WCHAR)] = 0;

            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        ExFreePool(output);
    }

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return status;
    }

    if (UniqueId) {

        outputSize = sizeof(MOUNTDEV_UNIQUE_ID);
        output = ExAllocatePool(PagedPool, outputSize);
        if (!output) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_UNIQUE_ID, deviceObject, NULL, 0, output,
              outputSize, FALSE, &event, &ioStatus);
        if (!irp) {
            ExFreePool(output);
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (status == STATUS_BUFFER_OVERFLOW) {

            outputSize = sizeof(MOUNTDEV_UNIQUE_ID) +
                         ((PMOUNTDEV_UNIQUE_ID) output)->UniqueIdLength;
            ExFreePool(output);
            output = ExAllocatePool(PagedPool, outputSize);
            if (!output) {
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                  IOCTL_MOUNTDEV_QUERY_UNIQUE_ID, deviceObject, NULL, 0, output,
                  outputSize, FALSE, &event, &ioStatus);
            if (!irp) {
                ExFreePool(output);
                ObDereferenceObject(deviceObject);
                ObDereferenceObject(fileObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->FileObject = fileObject;

            status = IoCallDriver(deviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                status = ioStatus.Status;
            }
        }

        if (!NT_SUCCESS(status)) {
            ExFreePool(output);
            if (DeviceName) {
                ExFreePool(DeviceName->Buffer);
            }
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return status;
        }

        *UniqueId = (PMOUNTDEV_UNIQUE_ID) output;
    }

    if (IsStable) {
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_STABLE_GUID, deviceObject, NULL, 0,
              StableGuid, sizeof(GUID), FALSE, &event, &ioStatus);
        if (!irp) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status2 = IoCallDriver(deviceObject, irp);
        if (status2 == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status2 = ioStatus.Status;
        }

        if (NT_SUCCESS(status2)) {
            *IsStable = TRUE;
        } else {
            *IsStable = FALSE;
        }
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);

    return status;
}

NTSTATUS
FindDeviceInfo(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PUNICODE_STRING                 DeviceName,
    IN  BOOLEAN                         IsCanonicalName,
    OUT PMOUNTED_DEVICE_INFORMATION*    DeviceInfo
    )

/*++

Routine Description:

    This routine finds the device information for the given device.

Arguments:

    Extension           - Supplies the device extension.

    DeviceName          - Supplies the name of the device.

    CanonicalizeName    - Supplies whether or not the name given is canonical.

    DeviceInfo          - Returns the device information.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING              targetName;
    NTSTATUS                    status;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    if (IsCanonicalName) {
        targetName = *DeviceName;
    } else {
        status = QueryDeviceInformation(DeviceName, &targetName, NULL, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (RtlEqualUnicodeString(&targetName, &deviceInfo->DeviceName,
                                  TRUE)) {
            break;
        }
    }

    if (!IsCanonicalName) {
        ExFreePool(targetName.Buffer);
    }

    if (l == &Extension->MountedDeviceList) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    *DeviceInfo = deviceInfo;

    return STATUS_SUCCESS;
}

NTSTATUS
QuerySuggestedLinkName(
    IN  PUNICODE_STRING NotificationName,
    OUT PUNICODE_STRING SuggestedLinkName,
    OUT PBOOLEAN        UseOnlyIfThereAreNoOtherLinks
    )

/*++

Routine Description:

    This routine queries the mounted device for a suggested link name.

Arguments:

    NotificationName                - Supplies the notification name.

    SuggestedLinkName               - Returns the suggested link name.

    UseOnlyIfThereAreNoOtherLinks   - Returns whether or not to use this name
                                        if there are other links to the device.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    PFILE_OBJECT                    fileObject;
    PDEVICE_OBJECT                  deviceObject;
    ULONG                           outputSize;
    PMOUNTDEV_SUGGESTED_LINK_NAME   output;
    KEVENT                          event;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;
    PIO_STACK_LOCATION              irpSp;

    status = IoGetDeviceObjectPointer(NotificationName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    outputSize = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
    output = ExAllocatePool(PagedPool, outputSize);
    if (!output) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(
          IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME, deviceObject, NULL, 0,
          output, outputSize, FALSE, &event, &ioStatus);
    if (!irp) {
        ExFreePool(output);
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (status == STATUS_BUFFER_OVERFLOW) {

        outputSize = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME) + output->NameLength;
        ExFreePool(output);
        output = ExAllocatePool(PagedPool, outputSize);
        if (!output) {
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
              IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME, deviceObject, NULL, 0,
              output, outputSize, FALSE, &event, &ioStatus);
        if (!irp) {
            ExFreePool(output);
            ObDereferenceObject(deviceObject);
            ObDereferenceObject(fileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->FileObject = fileObject;

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }
    }

    if (NT_SUCCESS(status)) {

        SuggestedLinkName->Length = output->NameLength;
        SuggestedLinkName->MaximumLength = output->NameLength + sizeof(WCHAR);
        SuggestedLinkName->Buffer = ExAllocatePool(PagedPool,
                                                   SuggestedLinkName->MaximumLength);
        if (SuggestedLinkName->Buffer) {

            RtlCopyMemory(SuggestedLinkName->Buffer, output->Name,
                          output->NameLength);
            SuggestedLinkName->Buffer[output->NameLength/sizeof(WCHAR)] = 0;

        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        *UseOnlyIfThereAreNoOtherLinks = output->UseOnlyIfThereAreNoOtherLinks;
    }

    ExFreePool(output);
    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);

    return status;
}

NTSTATUS
SymbolicLinkNamesFromUniqueIdCount(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine counts all of the occurences of the unique id in the
    registry key.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Supplies the num names count.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;
    UNICODE_STRING      string;

    if (ValueName[0] == '#' ||
        ValueType != REG_BINARY ||
        uniqueId->UniqueIdLength != ValueLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {


        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueName);
    if (!string.Length) {
        return STATUS_SUCCESS;
    }

    (*((PULONG) EntryContext))++;

    return STATUS_SUCCESS;
}

NTSTATUS
SymbolicLinkNamesFromUniqueIdQuery(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine counts all of the occurences of the unique id in the
    registry key.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Supplies the dos names array.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;
    UNICODE_STRING      string;
    PUNICODE_STRING     p;

    if (ValueName[0] == '#' ||
        ValueType != REG_BINARY ||
        uniqueId->UniqueIdLength != ValueLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueName);
    if (!string.Length) {
        return STATUS_SUCCESS;
    }

    string.Buffer = ExAllocatePool(PagedPool, string.MaximumLength);
    if (!string.Buffer) {
        return STATUS_SUCCESS;
    }
    RtlCopyMemory(string.Buffer, ValueName, string.Length);
    string.Buffer[string.Length/sizeof(WCHAR)] = 0;

    p = (PUNICODE_STRING) EntryContext;
    while (p->Length != 0) {
        p++;
    }

    *p = string;

    return STATUS_SUCCESS;
}

BOOLEAN
IsDriveLetter(
    IN  PUNICODE_STRING SymbolicLinkName
    )

{
    UNICODE_STRING  dosDevices;

    if (SymbolicLinkName->Length == 28 &&
        ((SymbolicLinkName->Buffer[12] >= 'A' &&
          SymbolicLinkName->Buffer[12] <= 'Z') ||
         SymbolicLinkName->Buffer[12] == 0xFF) &&
        SymbolicLinkName->Buffer[13] == ':') {

        RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

        SymbolicLinkName->Length = 24;
        if (RtlEqualUnicodeString(SymbolicLinkName, &dosDevices, TRUE)) {
            SymbolicLinkName->Length = 28;
            return TRUE;
        }
        SymbolicLinkName->Length = 28;
    }

    return FALSE;
}

NTSTATUS
CreateNewVolumeName(
    OUT PUNICODE_STRING VolumeName,
    IN  GUID*           Guid
    )

/*++

Routine Description:

    This routine creates a new name of the form \??\Volume{GUID}.

Arguments:

    VolumeName  - Returns the volume name.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS        status;
    UUID            uuid;
    UNICODE_STRING  guidString, prefix;

    if (Guid) {
        uuid = *Guid;
    } else {
        status = ExUuidCreate(&uuid);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = RtlStringFromGUID(&uuid, &guidString);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    VolumeName->MaximumLength = 98;
    VolumeName->Buffer = ExAllocatePool(PagedPool, VolumeName->MaximumLength);
    if (!VolumeName->Buffer) {
        ExFreePool(guidString.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitUnicodeString(&prefix, L"\\??\\Volume");
    RtlCopyUnicodeString(VolumeName, &prefix);
    RtlAppendUnicodeStringToString(VolumeName, &guidString);
    VolumeName->Buffer[VolumeName->Length/sizeof(WCHAR)] = 0;

    ExFreePool(guidString.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
QuerySymbolicLinkNamesFromStorage(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo,
    IN  PUNICODE_STRING             SuggestedName,
    IN  BOOLEAN                     UseOnlyIfThereAreNoOtherLinks,
    OUT PUNICODE_STRING*            SymbolicLinkNames,
    OUT PULONG                      NumNames,
    IN  BOOLEAN                     IsStable,
    IN  GUID*                       StableGuid
    )

/*++

Routine Description:

    This routine queries the symbolic link names from storage for
    the given notification name.

Arguments:

    Extension           - Supplies the device extension.

    DeviceInfo          - Supplies the device information.

    SymbolicLinkNames   - Returns the symbolic link names.

    NumNames            - Returns the number of symbolic link names.


Return Value:

    NTSTATUS

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    BOOLEAN                     extraLink;
    NTSTATUS                    status;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = SymbolicLinkNamesFromUniqueIdCount;
    queryTable[0].EntryContext = NumNames;

    *NumNames = 0;
    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    MOUNTED_DEVICES_KEY, queryTable,
                                    DeviceInfo->UniqueId, NULL);

    if (!NT_SUCCESS(status)) {
        *NumNames = 0;
    }

    if (SuggestedName && !IsDriveLetter(SuggestedName)) {
        if (UseOnlyIfThereAreNoOtherLinks) {
            if (*NumNames == 0) {
                extraLink = TRUE;
            } else {
                extraLink = FALSE;
            }
        } else {
            extraLink = TRUE;
        }
    } else {
        extraLink = FALSE;
    }

    if (IsStable) {
        (*NumNames)++;
    }

    if (extraLink) {

        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                              SuggestedName->Buffer, REG_BINARY,
                              DeviceInfo->UniqueId->UniqueId,
                              DeviceInfo->UniqueId->UniqueIdLength);

        RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
        queryTable[0].QueryRoutine = SymbolicLinkNamesFromUniqueIdCount;
        queryTable[0].EntryContext = NumNames;

        *NumNames = 0;
        status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                        MOUNTED_DEVICES_KEY, queryTable,
                                        DeviceInfo->UniqueId, NULL);

        if (!NT_SUCCESS(status) || *NumNames == 0) {
            return STATUS_NOT_FOUND;
        }

    } else if (!*NumNames) {
        return STATUS_NOT_FOUND;
    }

    *SymbolicLinkNames = ExAllocatePool(PagedPool,
                                        *NumNames*sizeof(UNICODE_STRING));
    if (!*SymbolicLinkNames) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(*SymbolicLinkNames, *NumNames*sizeof(UNICODE_STRING));

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = SymbolicLinkNamesFromUniqueIdQuery;

    if (IsStable) {

        status = CreateNewVolumeName(&((*SymbolicLinkNames)[0]), StableGuid);
        if (!NT_SUCCESS(status)) {
            ExFreePool(*SymbolicLinkNames);
            return status;
        }

        queryTable[0].EntryContext = &((*SymbolicLinkNames)[1]);
    } else {
        queryTable[0].EntryContext = *SymbolicLinkNames;
    }

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    MOUNTED_DEVICES_KEY, queryTable,
                                    DeviceInfo->UniqueId, NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
ChangeUniqueIdRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine replaces all old unique ids with new unique ids.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the old unique id.

    EntryContext    - Supplies the new unique id.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID oldId = Context;
    PMOUNTDEV_UNIQUE_ID newId = EntryContext;

    if (ValueType != REG_BINARY || oldId->UniqueIdLength != ValueLength ||
        RtlCompareMemory(oldId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                          ValueName, ValueType, newId->UniqueId,
                          newId->UniqueIdLength);

    return STATUS_SUCCESS;
}

HANDLE
OpenRemoteDatabase(
    IN  PUNICODE_STRING RemoteDatabaseVolumeName,
    IN  BOOLEAN         Create
    )

/*++

Routine Description:

    This routine opens the remote database on the given volume.

Arguments:

    RemoteDatabaseVolumeName    - Supplies the remote database volume name.

    Create                      - Supplies whether or not to create.

Return Value:

    A handle to the remote database or NULL.

--*/

{
    UNICODE_STRING      suffix;
    UNICODE_STRING      fileName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;

    RtlInitUnicodeString(&suffix, L"\\:$MountMgrRemoteDatabase");

    fileName.Length = RemoteDatabaseVolumeName->Length +
                      suffix.Length;
    fileName.MaximumLength = fileName.Length + sizeof(WCHAR);
    fileName.Buffer = ExAllocatePool(PagedPool, fileName.MaximumLength);
    if (!fileName.Buffer) {
        return NULL;
    }

    RtlCopyMemory(fileName.Buffer, RemoteDatabaseVolumeName->Buffer,
                  RemoteDatabaseVolumeName->Length);
    RtlCopyMemory((PCHAR) fileName.Buffer + RemoteDatabaseVolumeName->Length,
                  suffix.Buffer, suffix.Length);
    fileName.Buffer[fileName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwCreateFile(&h, FILE_GENERIC_READ | FILE_GENERIC_WRITE, &oa,
                          &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL |
                          FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, 0,
                          Create ? FILE_OPEN_IF : FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_ALERT | FILE_NON_DIRECTORY_FILE,
                          NULL, 0);

    ExFreePool(fileName.Buffer);

    if (!NT_SUCCESS(status)) {
        return NULL;
    }

    return h;
}

ULONG
GetRemoteDatabaseSize(
    IN  HANDLE  RemoteDatabaseHandle
    )

/*++

Routine Description:

    This routine returns the length of the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

Return Value:

    The length of the remote database or 0.

--*/

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    FILE_STANDARD_INFORMATION   info;

    status = ZwQueryInformationFile(RemoteDatabaseHandle, &ioStatus, &info,
                                    sizeof(info), FileStandardInformation);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    return info.EndOfFile.LowPart;
}

VOID
CloseRemoteDatabase(
    IN  HANDLE  RemoteDatabaseHandle
    )

/*++

Routine Description:

    This routine closes the given remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

Return Value:

    None.

--*/

{
    ULONG                           fileLength;
    FILE_DISPOSITION_INFORMATION    disp;
    IO_STATUS_BLOCK                 ioStatus;

    fileLength = GetRemoteDatabaseSize(RemoteDatabaseHandle);
    if (!fileLength) {
        disp.DeleteFile = TRUE;
        ZwSetInformationFile(RemoteDatabaseHandle, &ioStatus, &disp,
                             sizeof(disp), FileDispositionInformation);
    }

    ZwClose(RemoteDatabaseHandle);
}

NTSTATUS
TruncateRemoteDatabase(
    IN  HANDLE  RemoteDatabaseHandle,
    IN  ULONG   FileOffset
    )

/*++

Routine Description:

    This routine truncates the remote database at the given file offset.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

Return Value:

    NTSTATUS

--*/

{
    FILE_END_OF_FILE_INFORMATION    endOfFileInfo;
    FILE_ALLOCATION_INFORMATION     allocationInfo;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 ioStatus;

    endOfFileInfo.EndOfFile.QuadPart = FileOffset;
    allocationInfo.AllocationSize.QuadPart = FileOffset;

    status = ZwSetInformationFile(RemoteDatabaseHandle, &ioStatus,
                                  &endOfFileInfo, sizeof(endOfFileInfo),
                                  FileEndOfFileInformation);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwSetInformationFile(RemoteDatabaseHandle, &ioStatus,
                                  &allocationInfo, sizeof(allocationInfo),
                                  FileAllocationInformation);

    return status;
}

PMOUNTMGR_FILE_ENTRY
GetRemoteDatabaseEntry(
    IN  HANDLE  RemoteDatabaseHandle,
    IN  ULONG   FileOffset
    )

/*++

Routine Description:

    This routine gets the next database entry.  This routine fixes
    corruption as it finds it.  The memory returned from this routine
    must be freed with ExFreePool.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

Return Value:

    A pointer to the next remote database entry.

--*/

{
    LARGE_INTEGER           offset;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;
    ULONG                   size;
    PMOUNTMGR_FILE_ENTRY    entry;
    ULONG                   len1, len2, len;

    offset.QuadPart = FileOffset;
    status = ZwReadFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                        &size, sizeof(size), &offset, NULL);
    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    if (!size) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        return NULL;
    }

    entry = ExAllocatePool(PagedPool, size);
    if (!entry) {
        return NULL;
    }

    status = ZwReadFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                        entry, size, &offset, NULL);
    if (!NT_SUCCESS(status)) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    if (ioStatus.Information < size) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    if (size < sizeof(MOUNTMGR_FILE_ENTRY)) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    len1 = entry->VolumeNameOffset + entry->VolumeNameLength;
    len2 = entry->UniqueIdOffset + entry->UniqueIdLength;
    len = len1 > len2 ? len1 : len2;

    if (len > size) {
        TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
        ExFreePool(entry);
        return NULL;
    }

    return entry;
}

NTSTATUS
WriteRemoteDatabaseEntry(
    IN  HANDLE                  RemoteDatabaseHandle,
    IN  ULONG                   FileOffset,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine write the given database entry at the given file offset
    to the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

    DatabaseEntry           - Supplies the database entry.

Return Value:

    NTSTATUS

--*/

{
    LARGE_INTEGER   offset;
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    offset.QuadPart = FileOffset;
    status = ZwWriteFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                         DatabaseEntry, DatabaseEntry->EntryLength,
                         &offset, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (ioStatus.Information < DatabaseEntry->EntryLength) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

NTSTATUS
DeleteRemoteDatabaseEntry(
    IN  HANDLE  RemoteDatabaseHandle,
    IN  ULONG   FileOffset
    )

/*++

Routine Description:

    This routine deletes the database entry at the given file offset
    in the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    FileOffset              - Supplies the file offset.

Return Value:

    NTSTATUS

--*/

{
    ULONG                   fileSize;
    PMOUNTMGR_FILE_ENTRY    entry;
    LARGE_INTEGER           offset;
    ULONG                   size;
    PVOID                   buffer;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;

    fileSize = GetRemoteDatabaseSize(RemoteDatabaseHandle);
    if (!fileSize) {
        return STATUS_INVALID_PARAMETER;
    }

    entry = GetRemoteDatabaseEntry(RemoteDatabaseHandle, FileOffset);
    if (!entry) {
        return STATUS_INVALID_PARAMETER;
    }

    if (FileOffset + entry->EntryLength >= fileSize) {
        ExFreePool(entry);
        return TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
    }

    size = fileSize - FileOffset - entry->EntryLength;
    buffer = ExAllocatePool(PagedPool, size);
    if (!buffer) {
        ExFreePool(entry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset.QuadPart = FileOffset + entry->EntryLength;
    ExFreePool(entry);

    status = ZwReadFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                        buffer, size, &offset, NULL);
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return status;
    }

    if (ioStatus.Information < size) {
        ExFreePool(buffer);
        return STATUS_INVALID_PARAMETER;
    }

    status = TruncateRemoteDatabase(RemoteDatabaseHandle, FileOffset);
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return status;
    }

    offset.QuadPart = FileOffset;
    status = ZwWriteFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                         buffer, size, &offset, NULL);

    ExFreePool(buffer);

    return status;
}

NTSTATUS
AddRemoteDatabaseEntry(
    IN  HANDLE                  RemoteDatabaseHandle,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine adds a new database entry to the remote database.

Arguments:

    RemoteDatabaseHandle    - Supplies a handle to the remote database.

    DatabaseEntry           - Supplies the database entry.

Return Value:

    NTSTATUS

--*/

{
    ULONG           fileSize;
    LARGE_INTEGER   offset;
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    fileSize = GetRemoteDatabaseSize(RemoteDatabaseHandle);
    offset.QuadPart = fileSize;
    status = ZwWriteFile(RemoteDatabaseHandle, NULL, NULL, NULL, &ioStatus,
                         DatabaseEntry, DatabaseEntry->EntryLength, &offset,
                         NULL);

    return status;
}

VOID
ChangeRemoteDatabaseUniqueId(
    IN  PUNICODE_STRING     RemoteDatabaseVolumeName,
    IN  PMOUNTDEV_UNIQUE_ID OldUniqueId,
    IN  PMOUNTDEV_UNIQUE_ID NewUniqueId
    )

/*++

Routine Description:

    This routine changes the unique id in the remote database.

Arguments:

    RemoteDatabaseVolumeName    - Supplies the remote database volume name.

    OldUniqueId                 - Supplies the old unique id.

    NewUniqueId                 - Supplies the new unique id.

Return Value:

    None.

--*/

{
    HANDLE                  h;
    ULONG                   offset, newSize;
    PMOUNTMGR_FILE_ENTRY    databaseEntry, newDatabaseEntry;
    NTSTATUS                status;

    h = OpenRemoteDatabase(RemoteDatabaseVolumeName, FALSE);
    if (!h) {
        return;
    }

    offset = 0;
    for (;;) {

        databaseEntry = GetRemoteDatabaseEntry(h, offset);
        if (!databaseEntry) {
            break;
        }

        if (databaseEntry->UniqueIdLength != OldUniqueId->UniqueIdLength ||
            RtlCompareMemory(OldUniqueId->UniqueId,
                             (PCHAR) databaseEntry +
                             databaseEntry->UniqueIdOffset,
                             databaseEntry->UniqueIdLength) !=
                             databaseEntry->UniqueIdLength) {

            offset += databaseEntry->EntryLength;
            ExFreePool(databaseEntry);
            continue;
        }

        newSize = databaseEntry->EntryLength + NewUniqueId->UniqueIdLength -
                  OldUniqueId->UniqueIdLength;

        newDatabaseEntry = ExAllocatePool(PagedPool, newSize);
        if (!newDatabaseEntry) {
            offset += databaseEntry->EntryLength;
            ExFreePool(databaseEntry);
            continue;
        }

        newDatabaseEntry->EntryLength = newSize;
        newDatabaseEntry->RefCount = databaseEntry->RefCount;
        newDatabaseEntry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
        newDatabaseEntry->VolumeNameLength = databaseEntry->VolumeNameLength;
        newDatabaseEntry->UniqueIdOffset = newDatabaseEntry->VolumeNameOffset +
                                           newDatabaseEntry->VolumeNameLength;
        newDatabaseEntry->UniqueIdLength = NewUniqueId->UniqueIdLength;

        RtlCopyMemory((PCHAR) newDatabaseEntry +
                      newDatabaseEntry->VolumeNameOffset,
                      (PCHAR) databaseEntry + databaseEntry->VolumeNameOffset,
                      newDatabaseEntry->VolumeNameLength);
        RtlCopyMemory((PCHAR) newDatabaseEntry +
                      newDatabaseEntry->UniqueIdOffset,
                      NewUniqueId->UniqueId, newDatabaseEntry->UniqueIdLength);

        status = DeleteRemoteDatabaseEntry(h, offset);
        if (!NT_SUCCESS(status)) {
            ExFreePool(databaseEntry);
            ExFreePool(newDatabaseEntry);
            break;
        }

        status = AddRemoteDatabaseEntry(h, newDatabaseEntry);
        if (!NT_SUCCESS(status)) {
            ExFreePool(databaseEntry);
            ExFreePool(newDatabaseEntry);
            break;
        }

        ExFreePool(newDatabaseEntry);
        ExFreePool(databaseEntry);
    }

    CloseRemoteDatabase(h);
}

NTSTATUS
WaitForRemoteDatabaseSemaphore(
    IN  PDEVICE_EXTENSION   Extension
    )

{
    LARGE_INTEGER   timeout;
    NTSTATUS        status;

    timeout.QuadPart = -10*1000*1000*10;
    status = KeWaitForSingleObject(&Extension->RemoteDatabaseSemaphore,
                                   Executive, KernelMode, FALSE, &timeout);
    if (status == STATUS_TIMEOUT) {
        status = STATUS_IO_TIMEOUT;
    }

    return status;
}

VOID
ReleaseRemoteDatabaseSemaphore(
    IN  PDEVICE_EXTENSION   Extension
    )

{
    KeReleaseSemaphore(&Extension->RemoteDatabaseSemaphore, IO_NO_INCREMENT,
                       1, FALSE);
}

VOID
MountMgrUniqueIdChangeRoutine(
    IN  PVOID               Context,
    IN  PMOUNTDEV_UNIQUE_ID OldUniqueId,
    IN  PMOUNTDEV_UNIQUE_ID NewUniqueId
    )

/*++

Routine Description:

    This routine is called from a mounted device to notify of a unique
    id change.

Arguments:

    MountedDevice                   - Supplies the mounted device.

    MountMgrUniqueIdChangeRoutine   - Supplies the id change routine.

    Context                         - Supplies the context for this routine.

Return Value:

    None.

--*/

{
    NTSTATUS                    status;
    PDEVICE_EXTENSION           extension = Context;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PVOID                       p;
    BOOLEAN                     changedIds;

    status = WaitForRemoteDatabaseSemaphore(extension);

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = ChangeUniqueIdRoutine;
    queryTable[0].EntryContext = NewUniqueId;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, OldUniqueId, NULL);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);
        if (OldUniqueId->UniqueIdLength !=
            deviceInfo->UniqueId->UniqueIdLength) {

            continue;
        }

        if (RtlCompareMemory(OldUniqueId->UniqueId,
                             deviceInfo->UniqueId->UniqueId,
                             OldUniqueId->UniqueIdLength) !=
                             OldUniqueId->UniqueIdLength) {

            continue;
        }

        break;
    }

    if (l == &extension->MountedDeviceList) {
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        if (NT_SUCCESS(status)) {
            ReleaseRemoteDatabaseSemaphore(extension);
        }
        return;
    }

    if (!NT_SUCCESS(status)) {
        ReconcileThisDatabaseWithMaster(extension, deviceInfo);
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        return;
    }

    p = ExAllocatePool(PagedPool, NewUniqueId->UniqueIdLength +
                       sizeof(MOUNTDEV_UNIQUE_ID));
    if (!p) {
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(extension);
        return;
    }
    ExFreePool(deviceInfo->UniqueId);
    deviceInfo->UniqueId = p;

    deviceInfo->UniqueId->UniqueIdLength = NewUniqueId->UniqueIdLength;
    RtlCopyMemory(deviceInfo->UniqueId->UniqueId,
                  NewUniqueId->UniqueId, NewUniqueId->UniqueIdLength);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        changedIds = FALSE;
        for (ll = deviceInfo->ReplicatedUniqueIds.Flink;
             ll != &deviceInfo->ReplicatedUniqueIds; ll = ll->Flink) {

            replUniqueId = CONTAINING_RECORD(ll, REPLICATED_UNIQUE_ID,
                                             ListEntry);

            if (replUniqueId->UniqueId->UniqueIdLength !=
                OldUniqueId->UniqueIdLength) {

                continue;
            }

            if (RtlCompareMemory(replUniqueId->UniqueId->UniqueId,
                                 OldUniqueId->UniqueId,
                                 OldUniqueId->UniqueIdLength) !=
                                 OldUniqueId->UniqueIdLength) {

                continue;
            }

            p = ExAllocatePool(PagedPool, NewUniqueId->UniqueIdLength +
                               sizeof(MOUNTDEV_UNIQUE_ID));
            if (!p) {
                continue;
            }

            changedIds = TRUE;

            ExFreePool(replUniqueId->UniqueId);
            replUniqueId->UniqueId = p;

            replUniqueId->UniqueId->UniqueIdLength =
                    NewUniqueId->UniqueIdLength;
            RtlCopyMemory(replUniqueId->UniqueId->UniqueId,
                          NewUniqueId->UniqueId, NewUniqueId->UniqueIdLength);
        }

        if (changedIds) {
            ChangeRemoteDatabaseUniqueId(&deviceInfo->DeviceName, OldUniqueId,
                                         NewUniqueId);
        }
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
    ReleaseRemoteDatabaseSemaphore(extension);
}

VOID
SendLinkCreated(
    IN  PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine alerts the mounted device that one of its links has
    been created

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name being deleted.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject;
    ULONG               inputSize;
    PMOUNTDEV_NAME      input;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;

    status = IoGetDeviceObjectPointer(SymbolicLinkName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    inputSize = sizeof(USHORT) + SymbolicLinkName->Length;
    input = ExAllocatePool(PagedPool, inputSize);
    if (!input) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }

    input->NameLength = SymbolicLinkName->Length;
    RtlCopyMemory(input->Name, SymbolicLinkName->Buffer,
                  SymbolicLinkName->Length);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(
          IOCTL_MOUNTDEV_LINK_CREATED, deviceObject, input, inputSize, NULL,
          0, FALSE, &event, &ioStatus);

    ExFreePool (input);

    if (!irp) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);
}

VOID
CreateNoDriveLetterEntry(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine creates a "no drive letter" entry for the given device.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    UUID                uuid;
    UNICODE_STRING      guidString;
    PWSTR               valueName;

    status = ExUuidCreate(&uuid);
    if (!NT_SUCCESS(status)) {
        return;
    }

    status = RtlStringFromGUID(&uuid, &guidString);
    if (!NT_SUCCESS(status)) {
        return;
    }

    valueName = ExAllocatePool(PagedPool, guidString.Length + 2*sizeof(WCHAR));
    if (!valueName) {
        ExFreePool(guidString.Buffer);
        return;
    }

    valueName[0] = '#';
    RtlCopyMemory(&valueName[1], guidString.Buffer, guidString.Length);
    valueName[1 + guidString.Length/sizeof(WCHAR)] = 0;
    ExFreePool(guidString.Buffer);

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                          valueName, REG_BINARY, UniqueId->UniqueId,
                          UniqueId->UniqueIdLength);

    ExFreePool(valueName);
}

NTSTATUS
CreateNewDriveLetterName(
    OUT PUNICODE_STRING     DriveLetterName,
    IN  PUNICODE_STRING     TargetName,
    IN  UCHAR               SuggestedDriveLetter,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine creates a new name of the form \DosDevices\D:.

Arguments:

    DriveLetterName         - Returns the drive letter name.

    TargetName              - Supplies the target object.

    SuggestedDriveLetter    - Supplies the suggested drive letter.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                status;
    UNICODE_STRING          prefix, floppyPrefix, cdromPrefix;
    UCHAR                   driveLetter;

    DriveLetterName->MaximumLength = 30;
    DriveLetterName->Buffer = ExAllocatePool(PagedPool,
                                             DriveLetterName->MaximumLength);
    if (!DriveLetterName->Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitUnicodeString(&prefix, L"\\DosDevices\\");
    RtlCopyUnicodeString(DriveLetterName, &prefix);

    DriveLetterName->Length = 28;
    DriveLetterName->Buffer[14] = 0;
    DriveLetterName->Buffer[13] = ':';

    if (SuggestedDriveLetter == 0xFF) {
        CreateNoDriveLetterEntry(UniqueId);
        ExFreePool(DriveLetterName->Buffer);
        return STATUS_UNSUCCESSFUL;
    } else if (SuggestedDriveLetter) {
        DriveLetterName->Buffer[12] = SuggestedDriveLetter;
        status = GlobalCreateSymbolicLink(DriveLetterName, TargetName);
        if (NT_SUCCESS(status)) {
            return status;
        }
    }

    RtlInitUnicodeString(&floppyPrefix, L"\\Device\\Floppy");
    RtlInitUnicodeString(&cdromPrefix, L"\\Device\\CdRom");
    if (RtlPrefixUnicodeString(&floppyPrefix, TargetName, TRUE)) {
        driveLetter = 'A';
    } else if (RtlPrefixUnicodeString(&cdromPrefix, TargetName, TRUE)) {
        driveLetter = 'D';
    } else {
        driveLetter = 'C';
    }

    for (; driveLetter <= 'Z'; driveLetter++) {
        DriveLetterName->Buffer[12] = driveLetter;

        status = GlobalCreateSymbolicLink(DriveLetterName, TargetName);
        if (NT_SUCCESS(status)) {
            return status;
        }
    }

    ExFreePool(DriveLetterName->Buffer);

    return status;
}

NTSTATUS
CheckForNoDriveLetterEntry(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine checks for the presence of the "no drive letter" entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Returns whether or not there is a "no drive letter" entry.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;

    if (ValueName[0] != '#' || ValueType != REG_BINARY ||
        ValueLength != uniqueId->UniqueIdLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    *((PBOOLEAN) EntryContext) = TRUE;

    return STATUS_SUCCESS;
}

BOOLEAN
HasNoDriveLetterEntry(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine determines whether or not the given device has an
    entry indicating that it should not receice a drive letter.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    FALSE   - The device does not have a "no drive letter" entry.

    TRUE    - The device has a "no drive letter" entry.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    BOOLEAN                     hasNoDriveLetterEntry;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = CheckForNoDriveLetterEntry;
    queryTable[0].EntryContext = &hasNoDriveLetterEntry;

    hasNoDriveLetterEntry = FALSE;
    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);

    return hasNoDriveLetterEntry;
}

typedef struct _CHANGE_NOTIFY_WORK_ITEM {
    LIST_ENTRY          List; // Chained to the extension via this for unload
    PIO_WORKITEM        WorkItem;
    PDEVICE_EXTENSION   Extension;
    PIRP                Irp;
    PVOID               SystemBuffer;
    PFILE_OBJECT        FileObject;
    PKEVENT             Event;
    UNICODE_STRING      DeviceName;
    ULONG               OutputSize;
    CCHAR               StackSize;
} CHANGE_NOTIFY_WORK_ITEM, *PCHANGE_NOTIFY_WORK_ITEM;

VOID
RemoveWorkItem(
    IN  PCHANGE_NOTIFY_WORK_ITEM    WorkItem
    )
/*++

Routine Description:

    This routine removes a work item if its still chained to the device extension and frees it if needed or
    wakes up the waiter if unload is trying to cancel these operations.

Arguments:

    WorkItem    - Supplies the work item.

Return Value:

    None.

--*/
{
    KeWaitForSingleObject(&WorkItem->Extension->Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    if (WorkItem->Event == NULL) {
        RemoveEntryList (&WorkItem->List);

        KeReleaseSemaphore(&WorkItem->Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        IoFreeIrp(WorkItem->Irp);
        ExFreePool(WorkItem->DeviceName.Buffer);
        ExFreePool(WorkItem->SystemBuffer);
        ExFreePool(WorkItem);
    } else {
        KeReleaseSemaphore(&WorkItem->Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        KeSetEvent(WorkItem->Event, 0, FALSE);
    }
}

VOID
IssueUniqueIdChangeNotifyWorker(
    IN  PCHANGE_NOTIFY_WORK_ITEM    WorkItem,
    IN  PMOUNTDEV_UNIQUE_ID         UniqueId
    )

/*++

Routine Description:

    This routine issues a change notify request to the given mounted device.

Arguments:

    WorkItem    - Supplies the work item.

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    ULONG               inputSize;
    PIO_STACK_LOCATION  irpSp;

    status = IoGetDeviceObjectPointer(&WorkItem->DeviceName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        RemoveWorkItem (WorkItem);
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    WorkItem->FileObject = fileObject;

    irp = WorkItem->Irp;
    IoInitializeIrp(irp, IoSizeOfIrp(WorkItem->StackSize),
                    WorkItem->StackSize);

    //
    // IoCancelIrp could have been called by the unload code and the cancel flag over written by the call
    // above. To handle this case we check the work item to see if the event address has been set up.
    // We do this with an interlocked sequence (that does nothing) to make sure the ordering is preserved.
    // We don't want the read of the pointer field to be earlier than the IRP initializing code above.
    //
    if (InterlockedCompareExchangePointer (&WorkItem->Event, NULL, NULL) != NULL) {
        ObDereferenceObject(fileObject);
        ObDereferenceObject(deviceObject);
        RemoveWorkItem (WorkItem);
        return;
    }

    irp->AssociatedIrp.SystemBuffer = WorkItem->SystemBuffer;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    inputSize = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
                UniqueId->UniqueIdLength;

    RtlCopyMemory(irp->AssociatedIrp.SystemBuffer, UniqueId, inputSize);

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->Parameters.DeviceIoControl.InputBufferLength = inputSize;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = WorkItem->OutputSize;
    irpSp->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->DeviceObject = deviceObject;

    status = IoSetCompletionRoutineEx(WorkItem->Extension->DeviceObject,
                                      irp,
                                      UniqueIdChangeNotifyCompletion,
                                      WorkItem,
                                      TRUE,
                                      TRUE,
                                      TRUE);
    if (!NT_SUCCESS (status)) {
        ObDereferenceObject(fileObject);
        ObDereferenceObject(deviceObject);
        RemoveWorkItem (WorkItem);
        return;
    }

    IoCallDriver(deviceObject, irp);

    ObDereferenceObject(fileObject);
    ObDereferenceObject(deviceObject);
}

VOID
UniqueIdChangeNotifyWorker(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PVOID          WorkItem
    )

/*++

Routine Description:

    This routine updates the unique id in the database with the new version.

Arguments:

    DeviceObject - Device object
    WorkItem     - Supplies the work item.

Return Value:

    None.

--*/

{
    PCHANGE_NOTIFY_WORK_ITEM                    workItem = WorkItem;
    PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT    output;
    PMOUNTDEV_UNIQUE_ID                         oldUniqueId, newUniqueId;

    if (!NT_SUCCESS(workItem->Irp->IoStatus.Status)) {
        RemoveWorkItem (WorkItem);
        return;
    }

    output = workItem->Irp->AssociatedIrp.SystemBuffer;

    oldUniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                                 output->OldUniqueIdLength);
    if (!oldUniqueId) {
        RemoveWorkItem (WorkItem);
        return;
    }

    oldUniqueId->UniqueIdLength = output->OldUniqueIdLength;
    RtlCopyMemory(oldUniqueId->UniqueId, (PCHAR) output +
                  output->OldUniqueIdOffset, oldUniqueId->UniqueIdLength);

    newUniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                                 output->NewUniqueIdLength);
    if (!newUniqueId) {
        ExFreePool(oldUniqueId);
        RemoveWorkItem (WorkItem);
        return;
    }

    newUniqueId->UniqueIdLength = output->NewUniqueIdLength;
    RtlCopyMemory(newUniqueId->UniqueId, (PCHAR) output +
                  output->NewUniqueIdOffset, newUniqueId->UniqueIdLength);

    MountMgrUniqueIdChangeRoutine(workItem->Extension, oldUniqueId,
                                  newUniqueId);

    IssueUniqueIdChangeNotifyWorker(workItem, newUniqueId);

    ExFreePool(newUniqueId);
    ExFreePool(oldUniqueId);
}

VOID
IssueUniqueIdChangeNotify(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     DeviceName,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine issues a change notify request to the given mounted device.

Arguments:

    Extension   - Supplies the device extension.

    DeviceName  - Supplies a name for the device.

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    NTSTATUS                    status;
    PFILE_OBJECT                fileObject;
    PDEVICE_OBJECT              deviceObject;
    PCHANGE_NOTIFY_WORK_ITEM    workItem;
    ULONG                       outputSize;
    PVOID                       output;
    PIRP                        irp;
    PIO_STACK_LOCATION          irpSp;

    status = IoGetDeviceObjectPointer(DeviceName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    ObDereferenceObject(fileObject);

    workItem = ExAllocatePool(NonPagedPool, sizeof(CHANGE_NOTIFY_WORK_ITEM));
    if (!workItem) {
        ObDereferenceObject(deviceObject);
        return;
    }
    workItem->Event = NULL;
    workItem->WorkItem = IoAllocateWorkItem (Extension->DeviceObject);
    if (workItem->WorkItem == NULL) {
        ObDereferenceObject(deviceObject);
        ExFreePool(workItem);
        return;
    }

    workItem->Extension = Extension;
    workItem->StackSize = deviceObject->StackSize;
    workItem->Irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    ObDereferenceObject(deviceObject);
    if (!workItem->Irp) {
        IoFreeWorkItem (workItem->WorkItem);
        ExFreePool(workItem);
        return;
    }

    outputSize = sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT) + 1024;
    output = ExAllocatePool(NonPagedPool, outputSize);
    if (!output) {
        IoFreeIrp(workItem->Irp);
        IoFreeWorkItem (workItem->WorkItem);
        ExFreePool(workItem);
        return;
    }

    workItem->DeviceName.Length = DeviceName->Length;
    workItem->DeviceName.MaximumLength = workItem->DeviceName.Length +
                                         sizeof(WCHAR);
    workItem->DeviceName.Buffer = ExAllocatePool(NonPagedPool,
                                  workItem->DeviceName.MaximumLength);
    if (!workItem->DeviceName.Buffer) {
        ExFreePool(output);
        IoFreeIrp(workItem->Irp);
        IoFreeWorkItem (workItem->WorkItem);
        ExFreePool(workItem);
        return;
    }

    RtlCopyMemory(workItem->DeviceName.Buffer, DeviceName->Buffer,
                  DeviceName->Length);
    workItem->DeviceName.Buffer[DeviceName->Length/sizeof(WCHAR)] = 0;

    workItem->SystemBuffer = output;
    workItem->OutputSize = outputSize;

    KeWaitForSingleObject(&Extension->Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    InsertTailList (&Extension->UniqueIdChangeNotifyList, &workItem->List);

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    IssueUniqueIdChangeNotifyWorker(workItem, UniqueId);
}

NTSTATUS
QueryVolumeName(
    IN      HANDLE          Handle,
    IN      PLONGLONG       FileReference,
    IN      PUNICODE_STRING DirectoryName,
    IN OUT  PUNICODE_STRING VolumeName,
    OUT     PUNICODE_STRING PathName
    )

/*++

Routine Description:

    This routine returns the volume name contained in the reparse point
    at FileReference.

Arguments:

    Handle          - Supplies a handle to the volume containing the file
                      reference.

    FileReference   - Supplies the file reference.

    VolumeName      - Returns the volume name.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    OBJECT_ATTRIBUTES       oa;
    NTSTATUS                status;
    HANDLE                  h;
    IO_STATUS_BLOCK         ioStatus;
    UNICODE_STRING          fileId;
    PREPARSE_DATA_BUFFER    reparse;
    ULONG                   nameInfoSize;
    PFILE_NAME_INFORMATION  nameInfo;

    if (DirectoryName) {

        InitializeObjectAttributes(&oa, DirectoryName, OBJ_CASE_INSENSITIVE, 0,
                                   0);

        status = ZwOpenFile(&h, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &oa,
                            &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE, FILE_OPEN_REPARSE_POINT);

    } else {
        fileId.Length = sizeof(LONGLONG);
        fileId.MaximumLength = fileId.Length;
        fileId.Buffer = (PWSTR) FileReference;

        InitializeObjectAttributes(&oa, &fileId, 0, Handle, NULL);

        status = ZwOpenFile(&h, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &oa,
                            &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE, FILE_OPEN_BY_FILE_ID |
                            FILE_OPEN_REPARSE_POINT);
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    reparse = ExAllocatePool(PagedPool, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        ZwClose(h);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                             FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                             MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!NT_SUCCESS(status)) {
        ExFreePool(reparse);
        ZwClose(h);
        return status;
    }

    if (reparse->MountPointReparseBuffer.SubstituteNameLength + sizeof(WCHAR) >
        VolumeName->MaximumLength) {

        ExFreePool(reparse);
        ZwClose(h);
        return STATUS_BUFFER_TOO_SMALL;
    }

    VolumeName->Length = reparse->MountPointReparseBuffer.SubstituteNameLength;
    RtlCopyMemory(VolumeName->Buffer,
                  (PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                  reparse->MountPointReparseBuffer.SubstituteNameOffset,
                  VolumeName->Length);

    ExFreePool(reparse);

    if (VolumeName->Buffer[VolumeName->Length/sizeof(WCHAR) - 1] != '\\') {
        ZwClose(h);
        return STATUS_INVALID_PARAMETER;
    }

    VolumeName->Length -= sizeof(WCHAR);
    VolumeName->Buffer[VolumeName->Length/sizeof(WCHAR)] = 0;

    if (!MOUNTMGR_IS_NT_VOLUME_NAME(VolumeName)) {
        ZwClose(h);
        return STATUS_INVALID_PARAMETER;
    }

    nameInfoSize = sizeof(FILE_NAME_INFORMATION);
    nameInfo = ExAllocatePool(PagedPool, nameInfoSize);
    if (!nameInfo) {
        ZwClose(h);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwQueryInformationFile(h, &ioStatus, nameInfo, nameInfoSize,
                                    FileNameInformation);
    if (status == STATUS_BUFFER_OVERFLOW) {
        nameInfoSize = sizeof(FILE_NAME_INFORMATION) +
                       nameInfo->FileNameLength;
        ExFreePool(nameInfo);
        nameInfo = ExAllocatePool(PagedPool, nameInfoSize);
        if (!nameInfo) {
            ZwClose(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = ZwQueryInformationFile(h, &ioStatus, nameInfo, nameInfoSize,
                                        FileNameInformation);
    }

    ZwClose(h);

    if (!NT_SUCCESS(status)) {
        ExFreePool(nameInfo);
        return status;
    }

    PathName->Length = (USHORT) nameInfo->FileNameLength;
    PathName->MaximumLength = PathName->Length + sizeof(WCHAR);
    PathName->Buffer = ExAllocatePool(PagedPool, PathName->MaximumLength);
    if (!PathName->Buffer) {
        ExFreePool(nameInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(PathName->Buffer, nameInfo->FileName, PathName->Length);
    PathName->Buffer[PathName->Length/sizeof(WCHAR)] = 0;

    ExFreePool(nameInfo);

    return STATUS_SUCCESS;
}

NTSTATUS
QueryUniqueIdQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId;

    if (ValueLength >= 0x10000) {
        return STATUS_SUCCESS;
    }

    uniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                              ValueLength);
    if (!uniqueId) {
        return STATUS_SUCCESS;
    }

    uniqueId->UniqueIdLength = (USHORT) ValueLength;
    RtlCopyMemory(uniqueId->UniqueId, ValueData, ValueLength);

    *((PMOUNTDEV_UNIQUE_ID*) Context) = uniqueId;

    return STATUS_SUCCESS;
}

NTSTATUS
QueryUniqueIdFromMaster(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PUNICODE_STRING         VolumeName,
    OUT PMOUNTDEV_UNIQUE_ID*    UniqueId
    )

/*++

Routine Description:

    This routine queries the unique id from the master database.

Arguments:

    VolumeName  - Supplies the volume name.

    UniqueId    - Returns the unique id.

Return Value:

    NTSTATUS

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = QueryUniqueIdQueryRoutine;
    queryTable[0].Name = VolumeName->Buffer;

    *UniqueId = NULL;
    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);

    if (!(*UniqueId)) {
        status = FindDeviceInfo(Extension, VolumeName, FALSE, &deviceInfo);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        *UniqueId = ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                                   deviceInfo->UniqueId->UniqueIdLength);
        if (!*UniqueId) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        (*UniqueId)->UniqueIdLength = deviceInfo->UniqueId->UniqueIdLength;
        RtlCopyMemory((*UniqueId)->UniqueId, deviceInfo->UniqueId->UniqueId,
                      deviceInfo->UniqueId->UniqueIdLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
DeleteDriveLetterRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine deletes the "no drive letter" entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;
    UNICODE_STRING      string;

    if (ValueType != REG_BINARY ||
        ValueLength != uniqueId->UniqueIdLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueName);
    if (IsDriveLetter(&string)) {
        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               ValueName);
    }

    return STATUS_SUCCESS;
}

VOID
DeleteRegistryDriveLetter(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine checks the current database to see if the given unique
    id already has a drive letter.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    FALSE   - The given unique id does not already have a drive letter.

    TRUE    - The given unique id already has a drive letter.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = DeleteDriveLetterRoutine;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);
}

BOOLEAN
HasDriveLetter(
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

/*++

Routine Description:

    This routine computes whether or not the given device has a drive letter.

Arguments:

    DeviceInfo  - Supplies the device information.

Return Value:

    FALSE   - This device does not have a drive letter.

    TRUE    - This device does have a drive letter.

--*/

{
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symEntry;

    for (l = DeviceInfo->SymbolicLinkNames.Flink;
         l != &DeviceInfo->SymbolicLinkNames; l = l->Flink) {

        symEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY, ListEntry);
        if (symEntry->IsInDatabase &&
            IsDriveLetter(&symEntry->SymbolicLinkName)) {

            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
DeleteNoDriveLetterEntryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine deletes the "no drive letter" entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;

    if (ValueName[0] != '#' || ValueType != REG_BINARY ||
        ValueLength != uniqueId->UniqueIdLength ||
        RtlCompareMemory(uniqueId->UniqueId, ValueData, ValueLength) !=
        ValueLength) {

        return STATUS_SUCCESS;
    }

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           ValueName);

    return STATUS_SUCCESS;
}

VOID
DeleteNoDriveLetterEntry(
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine deletes the "no drive letter" entry for the given device.

Arguments:

    UniqueId    - Supplies the unique id.

Return Value:

    None.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = DeleteNoDriveLetterEntryRoutine;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);
}

VOID
MountMgrNotifyNameChange(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     DeviceName,
    IN  BOOLEAN             CheckForPdo
    )

/*++

Routine Description:

    This routine performs a target notification on 'DeviceName' to alert
    of a name change on the device.

Arguments:

    Extension   - Supplies the device extension.

    DeviceName  - Supplies the device name.

    CheckForPdo - Supplies whether or not there needs to be a check for PDO
                    status.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                         l;
    PMOUNTED_DEVICE_INFORMATION         deviceInfo;
    NTSTATUS                            status;
    PFILE_OBJECT                        fileObject;
    PDEVICE_OBJECT                      deviceObject;
    KEVENT                              event;
    PIRP                                irp;
    IO_STATUS_BLOCK                     ioStatus;
    PIO_STACK_LOCATION                  irpSp;
    PDEVICE_RELATIONS                   deviceRelations;
    TARGET_DEVICE_CUSTOM_NOTIFICATION   notification;

    if (CheckForPdo) {
        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);

            if (!RtlCompareUnicodeString(DeviceName, &deviceInfo->DeviceName,
                                         TRUE)) {

                break;
            }
        }

        if (l == &Extension->MountedDeviceList || deviceInfo->NotAPdo) {
            return;
        }
    }

    status = IoGetDeviceObjectPointer(DeviceName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(0, deviceObject, NULL, 0, NULL,
                                        0, FALSE, &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp->Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);

    if (!NT_SUCCESS(status)) {
        return;
    }

    deviceRelations = (PDEVICE_RELATIONS) ioStatus.Information;
    if (deviceRelations->Count < 1) {
        ExFreePool(deviceRelations);
        return;
    }

    deviceObject = deviceRelations->Objects[0];
    ExFreePool(deviceRelations);

    notification.Version = 1;
    notification.Size = (USHORT)
                        FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION,
                                     CustomDataBuffer);
    RtlCopyMemory(&notification.Event, &GUID_IO_VOLUME_NAME_CHANGE,
                  sizeof(GUID_IO_VOLUME_NAME_CHANGE));
    notification.FileObject = NULL;
    notification.NameBufferOffset = -1;

    IoReportTargetDeviceChangeAsynchronous(deviceObject, &notification, NULL,
                                           NULL);

    ObDereferenceObject(deviceObject);
}

NTSTATUS
MountMgrCreatePointWorker(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     SymbolicLinkName,
    IN  PUNICODE_STRING     DeviceName
    )

/*++

Routine Description:

    This routine creates a mount point.

Arguments:

    Extension           - Supplies the device extension.

    SymbolicLinkName    - Supplies the symbolic link name.

    DeviceName          - Supplies the device name.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING                  symbolicLinkName, deviceName;
    NTSTATUS                        status;
    UNICODE_STRING                  targetName;
    PMOUNTDEV_UNIQUE_ID             uniqueId;
    PWSTR                           symName;
    PLIST_ENTRY                     l;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo, d;
    PSYMBOLIC_LINK_NAME_ENTRY       symlinkEntry;

    symbolicLinkName = *SymbolicLinkName;
    deviceName = *DeviceName;

    status = QueryDeviceInformation(&deviceName, &targetName, NULL, NULL,
                                    NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (!RtlCompareUnicodeString(&targetName, &deviceInfo->DeviceName,
                                     TRUE)) {

            break;
        }
    }

    symName = ExAllocatePool(PagedPool, symbolicLinkName.Length +
                                        sizeof(WCHAR));
    if (!symName) {
        ExFreePool(targetName.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(symName, symbolicLinkName.Buffer,
                  symbolicLinkName.Length);
    symName[symbolicLinkName.Length/sizeof(WCHAR)] = 0;

    symbolicLinkName.Buffer = symName;
    symbolicLinkName.MaximumLength += sizeof(WCHAR);

    if (l == &Extension->MountedDeviceList) {

        status = QueryDeviceInformation(&deviceName, NULL, &uniqueId, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            ExFreePool(symName);
            ExFreePool(targetName.Buffer);
            return status;
        }

        status = GlobalCreateSymbolicLink(&symbolicLinkName, &targetName);
        if (!NT_SUCCESS(status)) {
            ExFreePool(uniqueId);
            ExFreePool(symName);
            ExFreePool(targetName.Buffer);
            return status;
        }

        if (IsDriveLetter(&symbolicLinkName)) {
            DeleteRegistryDriveLetter(uniqueId);
        }

        status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       MOUNTED_DEVICES_KEY,
                                       symName, REG_BINARY, uniqueId->UniqueId,
                                       uniqueId->UniqueIdLength);

        ExFreePool(uniqueId);
        ExFreePool(symName);
        ExFreePool(targetName.Buffer);

        return status;
    }

    if (IsDriveLetter(&symbolicLinkName) && HasDriveLetter(deviceInfo)) {
        ExFreePool(symName);
        ExFreePool(targetName.Buffer);
        return STATUS_INVALID_PARAMETER;
    }

    status = GlobalCreateSymbolicLink(&symbolicLinkName, &targetName);
    ExFreePool(targetName.Buffer);
    if (!NT_SUCCESS(status)) {
        ExFreePool(symName);
        return status;
    }

    uniqueId = deviceInfo->UniqueId;
    status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                   MOUNTED_DEVICES_KEY,
                                   symName, REG_BINARY, uniqueId->UniqueId,
                                   uniqueId->UniqueIdLength);

    if (!NT_SUCCESS(status)) {
        GlobalDeleteSymbolicLink(&symbolicLinkName);
        ExFreePool(symName);
        return status;
    }

    symlinkEntry = ExAllocatePool(PagedPool, sizeof(SYMBOLIC_LINK_NAME_ENTRY));
    if (!symlinkEntry) {
        GlobalDeleteSymbolicLink(&symbolicLinkName);
        ExFreePool(symName);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    symlinkEntry->SymbolicLinkName.Length = symbolicLinkName.Length;
    symlinkEntry->SymbolicLinkName.MaximumLength =
            symlinkEntry->SymbolicLinkName.Length + sizeof(WCHAR);
    symlinkEntry->SymbolicLinkName.Buffer =
            ExAllocatePool(PagedPool,
                           symlinkEntry->SymbolicLinkName.MaximumLength);
    if (!symlinkEntry->SymbolicLinkName.Buffer) {
        ExFreePool(symlinkEntry);
        GlobalDeleteSymbolicLink(&symbolicLinkName);
        ExFreePool(symName);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(symlinkEntry->SymbolicLinkName.Buffer,
                  symbolicLinkName.Buffer, symbolicLinkName.Length);
    symlinkEntry->SymbolicLinkName.Buffer[
            symlinkEntry->SymbolicLinkName.Length/sizeof(WCHAR)] = 0;
    symlinkEntry->IsInDatabase = TRUE;

    InsertTailList(&deviceInfo->SymbolicLinkNames, &symlinkEntry->ListEntry);

    SendLinkCreated(&symlinkEntry->SymbolicLinkName);

    if (IsDriveLetter(&symbolicLinkName)) {
        DeleteNoDriveLetterEntry(uniqueId);
    }

    if (MOUNTMGR_IS_NT_VOLUME_NAME(&symbolicLinkName) &&
        Extension->AutomaticDriveLetterAssignment) {

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (d->HasDanglingVolumeMountPoint) {
                ReconcileThisDatabaseWithMaster(Extension, d);
            }
        }
    }

    ExFreePool(symName);

    MountMgrNotify(Extension);

    if (!deviceInfo->NotAPdo) {
        MountMgrNotifyNameChange(Extension, DeviceName, FALSE);
    }

    return status;
}

NTSTATUS
WriteUniqueIdToMaster(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine writes the unique id to the master database.

Arguments:

    Extension       - Supplies the device extension.

    DatabaseEntry   - Supplies the database entry.

    DeviceName      - Supplies the device name.

Return Value:

    NTSTATUS

--*/

{
    PWSTR                       name;
    NTSTATUS                    status;
    UNICODE_STRING              symName;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    name = ExAllocatePool(PagedPool, DatabaseEntry->VolumeNameLength +
                          sizeof(WCHAR));
    if (!name) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(name, (PCHAR) DatabaseEntry +
                  DatabaseEntry->VolumeNameOffset,
                  DatabaseEntry->VolumeNameLength);
    name[DatabaseEntry->VolumeNameLength/sizeof(WCHAR)] = 0;

    status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                                   name, REG_BINARY, (PCHAR) DatabaseEntry +
                                   DatabaseEntry->UniqueIdOffset,
                                   DatabaseEntry->UniqueIdLength);

    ExFreePool(name);

    symName.Length = symName.MaximumLength = DatabaseEntry->VolumeNameLength;
    symName.Buffer = (PWSTR) ((PCHAR) DatabaseEntry +
                              DatabaseEntry->VolumeNameOffset);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (DatabaseEntry->UniqueIdLength ==
            deviceInfo->UniqueId->UniqueIdLength &&
            RtlCompareMemory((PCHAR) DatabaseEntry +
                             DatabaseEntry->UniqueIdOffset,
                             deviceInfo->UniqueId->UniqueId,
                             DatabaseEntry->UniqueIdLength) ==
                             DatabaseEntry->UniqueIdLength) {

            break;
        }
    }

    if (l != &Extension->MountedDeviceList) {
        MountMgrCreatePointWorker(Extension, &symName,
                                  &deviceInfo->DeviceName);
    }

    return status;
}

VOID
UpdateReplicatedUniqueIds(
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo,
    IN  PMOUNTMGR_FILE_ENTRY        DatabaseEntry
    )

/*++

Routine Description:

    This routine updates the list of replicated unique ids in the device info.

Arguments:

    DeviceInfo      - Supplies the device information.

    DatabaseEntry   - Supplies the database entry.

Return Value:

    None.

--*/

{
    PLIST_ENTRY             l;
    PREPLICATED_UNIQUE_ID   replUniqueId;

    for (l = DeviceInfo->ReplicatedUniqueIds.Flink;
         l != &DeviceInfo->ReplicatedUniqueIds; l = l->Flink) {

        replUniqueId = CONTAINING_RECORD(l, REPLICATED_UNIQUE_ID, ListEntry);

        if (replUniqueId->UniqueId->UniqueIdLength ==
            DatabaseEntry->UniqueIdLength &&
            RtlCompareMemory(replUniqueId->UniqueId->UniqueId,
                             (PCHAR) DatabaseEntry +
                             DatabaseEntry->UniqueIdOffset,
                             replUniqueId->UniqueId->UniqueIdLength) ==
                             replUniqueId->UniqueId->UniqueIdLength) {

            break;
        }
    }

    if (l != &DeviceInfo->ReplicatedUniqueIds) {
        return;
    }

    replUniqueId = ExAllocatePool(PagedPool, sizeof(REPLICATED_UNIQUE_ID));
    if (!replUniqueId) {
        return;
    }

    replUniqueId->UniqueId = ExAllocatePool(PagedPool,
                                            sizeof(MOUNTDEV_UNIQUE_ID) +
                                            DatabaseEntry->UniqueIdLength);
    if (!replUniqueId->UniqueId) {
        ExFreePool(replUniqueId);
        return;
    }

    replUniqueId->UniqueId->UniqueIdLength = DatabaseEntry->UniqueIdLength;
    RtlCopyMemory(replUniqueId->UniqueId->UniqueId, (PCHAR) DatabaseEntry +
                  DatabaseEntry->UniqueIdOffset,
                  replUniqueId->UniqueId->UniqueIdLength);

    InsertTailList(&DeviceInfo->ReplicatedUniqueIds, &replUniqueId->ListEntry);
}

BOOLEAN
IsUniqueIdPresent(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PMOUNTMGR_FILE_ENTRY    DatabaseEntry
    )

/*++

Routine Description:

    This routine checks to see if the given unique id exists in the system.

Arguments:

    Extension       - Supplies the device extension.

    DatabaseEntry   - Supplies the database entry.

Return Value:

    FALSE   - The unique id is not in the system.

    TRUE    - The unique id is in the system.

--*/

{
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (DatabaseEntry->UniqueIdLength ==
            deviceInfo->UniqueId->UniqueIdLength &&
            RtlCompareMemory((PCHAR) DatabaseEntry +
                             DatabaseEntry->UniqueIdOffset,
                             deviceInfo->UniqueId->UniqueId,
                             DatabaseEntry->UniqueIdLength) ==
                             DatabaseEntry->UniqueIdLength) {

            return TRUE;
        }
    }

    return FALSE;
}

VOID
ReconcileThisDatabaseWithMasterWorker(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine reconciles the remote database with the master database.

Arguments:

    WorkItem    - Supplies the device information.

Return Value:

    None.

--*/

{
    PRECONCILE_WORK_ITEM_INFO       workItem = WorkItem;
    PDEVICE_EXTENSION               Extension;
    PMOUNTED_DEVICE_INFORMATION     DeviceInfo;
    PLIST_ENTRY                     l, ll, s;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo;
    HANDLE                          remoteDatabaseHandle, indexHandle, junctionHandle;
    UNICODE_STRING                  suffix, indexName, pathName;
    OBJECT_ATTRIBUTES               oa;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 ioStatus;
    FILE_REPARSE_POINT_INFORMATION  reparseInfo, previousReparseInfo;
    ULONG                           offset;
    PMOUNTMGR_FILE_ENTRY            entry;
    WCHAR                           volumeNameBuffer[MAX_VOLUME_PATH];
    UNICODE_STRING                  volumeName, otherVolumeName;
    BOOLEAN                         restartScan;
    PMOUNTDEV_UNIQUE_ID             uniqueId;
    ULONG                           entryLength;
    REPARSE_INDEX_KEY               reparseKey;
    UNICODE_STRING                  reparseName;
    PMOUNTMGR_MOUNT_POINT_ENTRY     mountPointEntry;
    BOOLEAN                         actualDanglesFound;

    Extension = workItem->Extension;
    DeviceInfo = workItem->DeviceInfo;

    if (Unloading) {
        return;
    }

    status = WaitForRemoteDatabaseSemaphore(Extension);
    if (!NT_SUCCESS(status)) {
        ASSERT(FALSE);
        return;
    }

    if (Unloading) {
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo == DeviceInfo) {
            break;
        }
    }

    if (l == &Extension->MountedDeviceList) {
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    if (DeviceInfo->IsRemovable) {
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    DeviceInfo->ReconcileOnMounts = TRUE;
    DeviceInfo->HasDanglingVolumeMountPoint = TRUE;
    actualDanglesFound = FALSE;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        for (ll = deviceInfo->MountPointsPointingHere.Flink;
             ll != &deviceInfo->MountPointsPointingHere; ll = ll->Flink) {

            mountPointEntry = CONTAINING_RECORD(ll, MOUNTMGR_MOUNT_POINT_ENTRY,
                                                ListEntry);
            if (mountPointEntry->DeviceInfo == DeviceInfo) {
                s = ll->Blink;
                RemoveEntryList(ll);
                ExFreePool(mountPointEntry->MountPath.Buffer);
                ExFreePool(mountPointEntry);
                ll = s;
            }
        }
    }

    remoteDatabaseHandle = OpenRemoteDatabase(&DeviceInfo->DeviceName, FALSE);

    RtlInitUnicodeString(&suffix, L"\\$Extend\\$Reparse:$R:$INDEX_ALLOCATION");
    indexName.Length = DeviceInfo->DeviceName.Length +
                       suffix.Length;
    indexName.MaximumLength = indexName.Length + sizeof(WCHAR);
    indexName.Buffer = ExAllocatePool(PagedPool, indexName.MaximumLength);
    if (!indexName.Buffer) {
        if (remoteDatabaseHandle) {
            CloseRemoteDatabase(remoteDatabaseHandle);
        }
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    RtlCopyMemory(indexName.Buffer, DeviceInfo->DeviceName.Buffer,
                  DeviceInfo->DeviceName.Length);
    RtlCopyMemory((PCHAR) indexName.Buffer + DeviceInfo->DeviceName.Length,
                  suffix.Buffer, suffix.Length);
    indexName.Buffer[indexName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &indexName, OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwOpenFile(&indexHandle, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    ExFreePool(indexName.Buffer);
    if (!NT_SUCCESS(status)) {
        if (remoteDatabaseHandle) {
            TruncateRemoteDatabase(remoteDatabaseHandle, 0);
            CloseRemoteDatabase(remoteDatabaseHandle);
        }
        DeviceInfo->HasDanglingVolumeMountPoint = FALSE;
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    RtlZeroMemory(&reparseKey, sizeof(reparseKey));
    reparseKey.FileReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    reparseName.Length = reparseName.MaximumLength = sizeof(reparseKey);
    reparseName.Buffer = (PWCHAR) &reparseKey;
    status = ZwQueryDirectoryFile(indexHandle, NULL, NULL, NULL, &ioStatus,
                                  &reparseInfo, sizeof(reparseInfo),
                                  FileReparsePointInformation, TRUE,
                                  &reparseName, FALSE);
    if (!NT_SUCCESS(status)) {
        ZwClose(indexHandle);
        if (remoteDatabaseHandle) {
            TruncateRemoteDatabase(remoteDatabaseHandle, 0);
            CloseRemoteDatabase(remoteDatabaseHandle);
        }
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        ReleaseRemoteDatabaseSemaphore(Extension);
        return;
    }

    if (!remoteDatabaseHandle) {
        remoteDatabaseHandle = OpenRemoteDatabase(&DeviceInfo->DeviceName,
                                                  TRUE);
        if (!remoteDatabaseHandle) {
            ZwClose(indexHandle);
            KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            ReleaseRemoteDatabaseSemaphore(Extension);
            return;
        }
    }

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    offset = 0;
    for (;;) {

        entry = GetRemoteDatabaseEntry(remoteDatabaseHandle, offset);
        if (!entry) {
            break;
        }

        entry->RefCount = 0;
        status = WriteRemoteDatabaseEntry(remoteDatabaseHandle, offset, entry);
        if (!NT_SUCCESS(status)) {
            ExFreePool(entry);
            ZwClose(indexHandle);
            CloseRemoteDatabase(remoteDatabaseHandle);
            ReleaseRemoteDatabaseSemaphore(Extension);
            return;
        }

        offset += entry->EntryLength;
        ExFreePool(entry);
    }

    volumeName.MaximumLength = MAX_VOLUME_PATH*sizeof(WCHAR);
    volumeName.Length = 0;
    volumeName.Buffer = volumeNameBuffer;

    restartScan = TRUE;
    for (;;) {

        previousReparseInfo = reparseInfo;

        status = ZwQueryDirectoryFile(indexHandle, NULL, NULL, NULL, &ioStatus,
                                      &reparseInfo, sizeof(reparseInfo),
                                      FileReparsePointInformation, TRUE,
                                      restartScan ? &reparseName : NULL,
                                      restartScan);
        if (restartScan) {
            restartScan = FALSE;
        } else {
            if (previousReparseInfo.FileReference ==
                reparseInfo.FileReference &&
                previousReparseInfo.Tag == reparseInfo.Tag) {

                break;
            }
        }

        if (!NT_SUCCESS(status) || Unloading) {
            break;
        }

        if (reparseInfo.Tag != IO_REPARSE_TAG_MOUNT_POINT) {
            break;
        }

        status = QueryVolumeName(indexHandle, &reparseInfo.FileReference, NULL,
                                 &volumeName, &pathName);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        offset = 0;
        for (;;) {

            entry = GetRemoteDatabaseEntry(remoteDatabaseHandle, offset);
            if (!entry) {
                break;
            }

            otherVolumeName.Length = otherVolumeName.MaximumLength =
                    entry->VolumeNameLength;
            otherVolumeName.Buffer = (PWSTR) ((PCHAR) entry +
                    entry->VolumeNameOffset);

            if (RtlEqualUnicodeString(&otherVolumeName, &volumeName, TRUE)) {
                break;
            }

            offset += entry->EntryLength;
            ExFreePool(entry);
        }

        if (!entry) {

            KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);
            status = QueryUniqueIdFromMaster(Extension, &volumeName, &uniqueId);
            KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

            if (!NT_SUCCESS(status)) {
                goto BuildMountPointGraph;
            }

            entryLength = sizeof(MOUNTMGR_FILE_ENTRY) +
                          volumeName.Length + uniqueId->UniqueIdLength;
            entry = ExAllocatePool(PagedPool, entryLength);
            if (!entry) {
                ExFreePool(uniqueId);
                goto BuildMountPointGraph;
            }

            entry->EntryLength = entryLength;
            entry->RefCount = 1;
            entry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
            entry->VolumeNameLength = volumeName.Length;
            entry->UniqueIdOffset = entry->VolumeNameOffset +
                                    entry->VolumeNameLength;
            entry->UniqueIdLength = uniqueId->UniqueIdLength;

            RtlCopyMemory((PCHAR) entry + entry->VolumeNameOffset,
                          volumeName.Buffer, entry->VolumeNameLength);
            RtlCopyMemory((PCHAR) entry + entry->UniqueIdOffset,
                          uniqueId->UniqueId, entry->UniqueIdLength);

            status = AddRemoteDatabaseEntry(remoteDatabaseHandle, entry);

            ExFreePool(entry);
            ExFreePool(uniqueId);

            if (!NT_SUCCESS(status)) {
                ExFreePool(pathName.Buffer);
                ZwClose(indexHandle);
                CloseRemoteDatabase(remoteDatabaseHandle);
                ReleaseRemoteDatabaseSemaphore(Extension);
                return;
            }

            goto BuildMountPointGraph;
        }

        if (entry->RefCount) {

            entry->RefCount++;
            status = WriteRemoteDatabaseEntry(remoteDatabaseHandle, offset,
                                              entry);

            if (!NT_SUCCESS(status)) {
                ExFreePool(entry);
                ExFreePool(pathName.Buffer);
                ZwClose(indexHandle);
                CloseRemoteDatabase(remoteDatabaseHandle);
                ReleaseRemoteDatabaseSemaphore(Extension);
                return;
            }

        } else {

            KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);

            status = QueryUniqueIdFromMaster(Extension, &volumeName, &uniqueId);

            if (NT_SUCCESS(status)) {

                if (uniqueId->UniqueIdLength == entry->UniqueIdLength &&
                    RtlCompareMemory(uniqueId->UniqueId,
                                     (PCHAR) entry + entry->UniqueIdOffset,
                                     entry->UniqueIdLength) ==
                                     entry->UniqueIdLength) {

                    entry->RefCount++;
                    status = WriteRemoteDatabaseEntry(remoteDatabaseHandle,
                                                      offset, entry);

                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                } else if (IsUniqueIdPresent(Extension, entry)) {

                    status = WriteUniqueIdToMaster(Extension, entry);
                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                    entry->RefCount++;
                    status = WriteRemoteDatabaseEntry(remoteDatabaseHandle,
                                                      offset, entry);

                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                } else {

                    status = DeleteRemoteDatabaseEntry(remoteDatabaseHandle,
                                                       offset);
                    if (!NT_SUCCESS(status)) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(entry);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                    ExFreePool(entry);

                    entryLength = sizeof(MOUNTMGR_FILE_ENTRY) +
                                  volumeName.Length + uniqueId->UniqueIdLength;
                    entry = ExAllocatePool(PagedPool, entryLength);
                    if (!entry) {
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }

                    entry->EntryLength = entryLength;
                    entry->RefCount = 1;
                    entry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
                    entry->VolumeNameLength = volumeName.Length;
                    entry->UniqueIdOffset = entry->VolumeNameOffset +
                                            entry->VolumeNameLength;
                    entry->UniqueIdLength = uniqueId->UniqueIdLength;

                    RtlCopyMemory((PCHAR) entry + entry->VolumeNameOffset,
                                  volumeName.Buffer, entry->VolumeNameLength);
                    RtlCopyMemory((PCHAR) entry + entry->UniqueIdOffset,
                                  uniqueId->UniqueId, entry->UniqueIdLength);

                    status = AddRemoteDatabaseEntry(remoteDatabaseHandle,
                                                    entry);
                    if (!NT_SUCCESS(status)) {
                        ExFreePool(entry);
                        ExFreePool(uniqueId);
                        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                           1, FALSE);
                        ExFreePool(pathName.Buffer);
                        ZwClose(indexHandle);
                        CloseRemoteDatabase(remoteDatabaseHandle);
                        ReleaseRemoteDatabaseSemaphore(Extension);
                        return;
                    }
                }

                ExFreePool(uniqueId);

            } else {
                status = WriteUniqueIdToMaster(Extension, entry);
                if (!NT_SUCCESS(status)) {
                    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                       1, FALSE);
                    ExFreePool(entry);
                    ExFreePool(pathName.Buffer);
                    ZwClose(indexHandle);
                    CloseRemoteDatabase(remoteDatabaseHandle);
                    ReleaseRemoteDatabaseSemaphore(Extension);
                    return;
                }

                entry->RefCount++;
                status = WriteRemoteDatabaseEntry(remoteDatabaseHandle, offset,
                                                  entry);

                if (!NT_SUCCESS(status)) {
                    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT,
                                       1, FALSE);
                    ExFreePool(entry);
                    ExFreePool(pathName.Buffer);
                    ZwClose(indexHandle);
                    CloseRemoteDatabase(remoteDatabaseHandle);
                    ReleaseRemoteDatabaseSemaphore(Extension);
                    return;
                }
            }

            KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        }

        ExFreePool(entry);

BuildMountPointGraph:
        status = FindDeviceInfo(Extension, &volumeName, FALSE, &deviceInfo);
        if (NT_SUCCESS(status)) {
            mountPointEntry = (PMOUNTMGR_MOUNT_POINT_ENTRY)
                              ExAllocatePool(PagedPool,
                                             sizeof(MOUNTMGR_MOUNT_POINT_ENTRY));
            if (mountPointEntry) {
                InsertTailList(&deviceInfo->MountPointsPointingHere,
                               &mountPointEntry->ListEntry);
                mountPointEntry->DeviceInfo = DeviceInfo;
                mountPointEntry->MountPath = pathName;
            } else {
                ExFreePool(pathName.Buffer);
            }
        } else {
            actualDanglesFound = TRUE;
            ExFreePool(pathName.Buffer);
        }
    }

    ZwClose(indexHandle);

    KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo == DeviceInfo) {
            break;
        }
    }

    if (l == &Extension->MountedDeviceList) {
        deviceInfo = NULL;
    }

    offset = 0;
    for (;;) {

        entry = GetRemoteDatabaseEntry(remoteDatabaseHandle, offset);
        if (!entry) {
            break;
        }

        if (!entry->RefCount) {
            status = DeleteRemoteDatabaseEntry(remoteDatabaseHandle, offset);
            if (!NT_SUCCESS(status)) {
                ExFreePool(entry);
                KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1,
                                   FALSE);
                CloseRemoteDatabase(remoteDatabaseHandle);
                ReleaseRemoteDatabaseSemaphore(Extension);
                return;
            }

            ExFreePool(entry);
            continue;
        }

        if (deviceInfo) {
            UpdateReplicatedUniqueIds(deviceInfo, entry);
        }

        offset += entry->EntryLength;
        ExFreePool(entry);
    }

    if (deviceInfo && !actualDanglesFound) {
        DeviceInfo->HasDanglingVolumeMountPoint = FALSE;
    }

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    CloseRemoteDatabase(remoteDatabaseHandle);
    ReleaseRemoteDatabaseSemaphore(Extension);
}

VOID
ReconcileThisDatabaseWithMaster(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

/*++

Routine Description:

    This routine reconciles the remote database with the master database.

Arguments:

    DeviceInfo  - Supplies the device information.

Return Value:

    None.

--*/

{
    PRECONCILE_WORK_ITEM    workItem;

    if (DeviceInfo->IsRemovable) {
        return;
    }

    workItem = ExAllocatePool(NonPagedPool,
                              sizeof(RECONCILE_WORK_ITEM));
    if (!workItem) {
        return;
    }

    workItem->WorkItem = IoAllocateWorkItem(Extension->DeviceObject);
    if (workItem->WorkItem == NULL) {
        ExFreePool (workItem);
        return;
    }

    workItem->WorkerRoutine = ReconcileThisDatabaseWithMasterWorker;
    workItem->WorkItemInfo.Extension = Extension;
    workItem->WorkItemInfo.DeviceInfo = DeviceInfo;

    QueueWorkItem(Extension, workItem, &workItem->WorkItemInfo);
}

NTSTATUS
DeleteFromLocalDatabaseRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Supplies the unique id.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_UNIQUE_ID uniqueId = Context;

    if (uniqueId->UniqueIdLength == ValueLength &&
        RtlCompareMemory(uniqueId->UniqueId,
                         ValueData, ValueLength) == ValueLength) {

        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               ValueName);
    }

    return STATUS_SUCCESS;
}

VOID
DeleteFromLocalDatabase(
    IN  PUNICODE_STRING     SymbolicLinkName,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine makes sure that the given symbolic link names exists in the
    local database and that its unique id is equal to the one given.  If these
    two conditions are true then this local database entry is deleted.

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name.

    UniqueId            - Supplies the unique id.

Return Value:

    None.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = DeleteFromLocalDatabaseRoutine;
    queryTable[0].Name = SymbolicLinkName->Buffer;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                           queryTable, UniqueId, NULL);
}

PSAVED_LINKS_INFORMATION
RemoveSavedLinks(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PMOUNTDEV_UNIQUE_ID UniqueId
    )

/*++

Routine Description:

    This routine finds and removed the given unique id from the saved links
    list.

Arguments:

    Extension   - Supplies the device extension.

    UniqueId    - Supplies the unique id.

Return Value:

    The removed saved links list or NULL.

--*/

{
    PLIST_ENTRY                 l;
    PSAVED_LINKS_INFORMATION    savedLinks;

    for (l = Extension->SavedLinksList.Flink;
         l != &Extension->SavedLinksList; l = l->Flink) {

        savedLinks = CONTAINING_RECORD(l, SAVED_LINKS_INFORMATION, ListEntry);
        if (savedLinks->UniqueId->UniqueIdLength != UniqueId->UniqueIdLength) {
            continue;
        }

        if (RtlCompareMemory(savedLinks->UniqueId->UniqueId,
                             UniqueId->UniqueId, UniqueId->UniqueIdLength) ==
            UniqueId->UniqueIdLength) {

            break;
        }
    }

    if (l == &Extension->SavedLinksList) {
        return NULL;
    }

    RemoveEntryList(l);

    return savedLinks;
}

BOOLEAN
RedirectSavedLink(
    IN  PSAVED_LINKS_INFORMATION    SavedLinks,
    IN  PUNICODE_STRING             SymbolicLinkName,
    IN  PUNICODE_STRING             DeviceName
    )

/*++

Routine Description:

    This routine attempts to redirect the given link to the given device name
    if this link is in the saved links list.  When this is done, the
    symbolic link entry is removed from the saved links list.

Arguments:


Return Value:

    FALSE   - The link was not successfully redirected.

    TRUE    - The link was successfully redirected.

--*/

{
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;

    for (l = SavedLinks->SymbolicLinkNames.Flink;
         l != &SavedLinks->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        if (RtlEqualUnicodeString(SymbolicLinkName,
                                  &symlinkEntry->SymbolicLinkName, TRUE)) {

            break;
        }
    }

    if (l == &SavedLinks->SymbolicLinkNames) {
        return FALSE;
    }

    // NOTE There is a small window here where the drive letter could be
    // taken away.  This is the best we can do without more support from OB.

    GlobalDeleteSymbolicLink(SymbolicLinkName);
    GlobalCreateSymbolicLink(SymbolicLinkName, DeviceName);

    ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
    ExFreePool(symlinkEntry);
    RemoveEntryList(l);

    return TRUE;
}

BOOLEAN
IsOffline(
    IN  PUNICODE_STRING     SymbolicLinkName
    )

/*++

Routine Description:

    This routine checks to see if the given name has been marked to be
    an offline volume.

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name.

Return Value:

    FALSE   - This volume is not marked for offline.

    TRUE    - This volume is marked for offline.

--*/

{
    ULONG                       zero, offline;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = SymbolicLinkName->Buffer;
    queryTable[0].EntryContext = &offline;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    MOUNTED_DEVICES_OFFLINE_KEY, queryTable,
                                    NULL, NULL);
    if (!NT_SUCCESS(status)) {
        offline = 0;
    }

    return offline ? TRUE : FALSE;
}

VOID
SendOnlineNotification(
    IN  PUNICODE_STRING     NotificationName
    )

/*++

Routine Description:

    This routine sends an ONLINE notification to the given device.

Arguments:

    NotificationName    - Supplies the notification name.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;

    status = IoGetDeviceObjectPointer(NotificationName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_VOLUME_ONLINE, deviceObject,
                                        NULL, 0, NULL, 0, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);
}

NTSTATUS
MountMgrTargetDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   DeviceInfo
    )

/*++

Routine Description:

    This routine processes target device notifications.

Arguments:

    NotificationStructure    - Supplies the notification structure.

    DeviceInfo               - Supplies the device information.

Return Value:

    None.

--*/

{
    PTARGET_DEVICE_REMOVAL_NOTIFICATION     notification = NotificationStructure;
    PMOUNTED_DEVICE_INFORMATION             deviceInfo = DeviceInfo;
    PDEVICE_EXTENSION                       extension = deviceInfo->Extension;

    if (IsEqualGUID(&notification->Event,
                    &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        MountMgrMountedDeviceRemoval(extension, &deviceInfo->NotificationName);
        return STATUS_SUCCESS;
    }

    if (IsEqualGUID(&notification->Event, &GUID_IO_VOLUME_MOUNT) &&
        deviceInfo->ReconcileOnMounts) {

        deviceInfo->ReconcileOnMounts = FALSE;
        ReconcileThisDatabaseWithMaster(extension, deviceInfo);
        return STATUS_SUCCESS;
    }

    return STATUS_SUCCESS;
}

VOID
RegisterForTargetDeviceNotification(
    IN  PDEVICE_EXTENSION           Extension,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

/*++

Routine Description:

    This routine registers for target device notification so that the
    symbolic link to a device interface can be removed in a timely manner.

Arguments:

    Extension   - Supplies the device extension.

    DeviceInfo  - Supplies the device information.

Return Value:

    None.

--*/

{
    NTSTATUS                                status;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;

    status = IoGetDeviceObjectPointer(&DeviceInfo->DeviceName,
                                      FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }

    status = IoRegisterPlugPlayNotification(
                EventCategoryTargetDeviceChange, 0, fileObject,
                Extension->DriverObject, MountMgrTargetDeviceNotification,
                DeviceInfo, &DeviceInfo->TargetDeviceNotificationEntry);

    if (!NT_SUCCESS(status)) {
        DeviceInfo->TargetDeviceNotificationEntry = NULL;
    }

    ObDereferenceObject(fileObject);
}

VOID
MountMgrFreeDeadDeviceInfo(
    PMOUNTED_DEVICE_INFORMATION deviceInfo
    )
{
    ExFreePool(deviceInfo->NotificationName.Buffer);
    ExFreePool(deviceInfo);
}

VOID
MountMgrFreeSavedLink(
    PSAVED_LINKS_INFORMATION                savedLinks
    )
{
    PLIST_ENTRY                             l;
    PSYMBOLIC_LINK_NAME_ENTRY               symlinkEntry;

    while (!IsListEmpty(&savedLinks->SymbolicLinkNames)) {
        l = RemoveHeadList(&savedLinks->SymbolicLinkNames);
        symlinkEntry = CONTAINING_RECORD(l,
                                         SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);
        GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
        ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
        ExFreePool(symlinkEntry);
    }
    ExFreePool(savedLinks->UniqueId);
    ExFreePool(savedLinks);
}

NTSTATUS
MountMgrMountedDeviceArrival(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     NotificationName,
    IN  BOOLEAN             NotAPdo
    )

{
    PDEVICE_EXTENSION           extension = Extension;
    PMOUNTED_DEVICE_INFORMATION deviceInfo, d;
    NTSTATUS                    status;
    UNICODE_STRING              targetName, otherTargetName;
    PMOUNTDEV_UNIQUE_ID         uniqueId, uniqueIdCopy;
    BOOLEAN                     isRecognized;
    UNICODE_STRING              suggestedName;
    BOOLEAN                     useOnlyIfThereAreNoOtherLinks;
    PUNICODE_STRING             symbolicLinkNames;
    ULONG                       numNames, i, allocSize;
    BOOLEAN                     hasDriveLetter, offline, isStable, isFT;
    BOOLEAN                     hasVolumeName, isLinkPreset;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    UNICODE_STRING              volumeName;
    UNICODE_STRING              driveLetterName;
    PSAVED_LINKS_INFORMATION    savedLinks;
    PLIST_ENTRY                 l;
    GUID                        stableGuid;

    deviceInfo = ExAllocatePool(PagedPool,
                                sizeof(MOUNTED_DEVICE_INFORMATION));
    if (!deviceInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceInfo, sizeof(MOUNTED_DEVICE_INFORMATION));

    InitializeListHead(&deviceInfo->SymbolicLinkNames);
    InitializeListHead(&deviceInfo->ReplicatedUniqueIds);
    InitializeListHead(&deviceInfo->MountPointsPointingHere);

    deviceInfo->NotificationName.Length =
            NotificationName->Length;
    deviceInfo->NotificationName.MaximumLength =
            deviceInfo->NotificationName.Length + sizeof(WCHAR);
    deviceInfo->NotificationName.Buffer =
            ExAllocatePool(PagedPool,
                           deviceInfo->NotificationName.MaximumLength);
    if (!deviceInfo->NotificationName.Buffer) {
        ExFreePool(deviceInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(deviceInfo->NotificationName.Buffer,
                  NotificationName->Buffer,
                  deviceInfo->NotificationName.Length);
    deviceInfo->NotificationName.Buffer[
            deviceInfo->NotificationName.Length/sizeof(WCHAR)] = 0;
    deviceInfo->NotAPdo = NotAPdo;
    deviceInfo->Extension = extension;

    status = QueryDeviceInformation(NotificationName,
                                    &targetName, &uniqueId,
                                    &deviceInfo->IsRemovable, &isRecognized,
                                    &isStable, &stableGuid, &isFT);
    if (!NT_SUCCESS(status)) {

        KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                              FALSE, NULL);

        for (l = extension->DeadMountedDeviceList.Flink;
             l != &extension->DeadMountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (RtlEqualUnicodeString(&deviceInfo->NotificationName,
                                      &d->NotificationName, TRUE)) {

                break;
            }
        }

        if (l == &extension->DeadMountedDeviceList) {
            InsertTailList(&extension->DeadMountedDeviceList,
                           &deviceInfo->ListEntry);
        } else {
            MountMgrFreeDeadDeviceInfo (deviceInfo);
        }

        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        return status;
    }

    deviceInfo->UniqueId = uniqueId;
    deviceInfo->DeviceName = targetName;
    deviceInfo->KeepLinksWhenOffline = FALSE;

    if (extension->SystemPartitionUniqueId &&
        uniqueId->UniqueIdLength ==
        extension->SystemPartitionUniqueId->UniqueIdLength &&
        RtlCompareMemory(uniqueId->UniqueId,
                         extension->SystemPartitionUniqueId->UniqueId,
                         uniqueId->UniqueIdLength) ==
                         uniqueId->UniqueIdLength) {

        IoSetSystemPartition(&targetName);
    }

    status = QuerySuggestedLinkName(&deviceInfo->NotificationName,
                                    &suggestedName,
                                    &useOnlyIfThereAreNoOtherLinks);
    if (!NT_SUCCESS(status)) {
        suggestedName.Buffer = NULL;
    }

    if (suggestedName.Buffer && IsDriveLetter(&suggestedName)) {
        deviceInfo->SuggestedDriveLetter = (UCHAR)
                                           suggestedName.Buffer[12];
    } else {
        deviceInfo->SuggestedDriveLetter = 0;
    }

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
        if (!RtlCompareUnicodeString(&d->DeviceName, &targetName, TRUE)) {
            break;
        }
    }

    if (l != &extension->MountedDeviceList) {
        if (suggestedName.Buffer) {
            ExFreePool(suggestedName.Buffer);
        }
        ExFreePool(uniqueId);
        ExFreePool(targetName.Buffer);
        ExFreePool(deviceInfo->NotificationName.Buffer);
        ExFreePool(deviceInfo);
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    status = QuerySymbolicLinkNamesFromStorage(extension,
             deviceInfo, suggestedName.Buffer ? &suggestedName : NULL,
             useOnlyIfThereAreNoOtherLinks, &symbolicLinkNames, &numNames,
             isStable, &stableGuid);

    if (suggestedName.Buffer) {
        ExFreePool(suggestedName.Buffer);
    }

    if (!NT_SUCCESS(status)) {
        symbolicLinkNames = NULL;
        numNames = 0;
        status = STATUS_SUCCESS;
    }

    savedLinks = RemoveSavedLinks(extension, uniqueId);

    hasDriveLetter = FALSE;
    offline = FALSE;
    hasVolumeName = FALSE;
    for (i = 0; i < numNames; i++) {

        if (MOUNTMGR_IS_VOLUME_NAME(&symbolicLinkNames[i])) {
            hasVolumeName = TRUE;
        } else if (IsDriveLetter(&symbolicLinkNames[i])) {
            if (hasDriveLetter) {
                DeleteFromLocalDatabase(&symbolicLinkNames[i], uniqueId);
                continue;
            }
            hasDriveLetter = TRUE;
        }

        status = GlobalCreateSymbolicLink(&symbolicLinkNames[i], &targetName);
        if (!NT_SUCCESS(status)) {
            isLinkPreset = TRUE;
            if (!savedLinks ||
                !RedirectSavedLink(savedLinks, &symbolicLinkNames[i],
                                   &targetName)) {

                status = QueryDeviceInformation(&symbolicLinkNames[i],
                                                &otherTargetName, NULL, NULL,
                                                NULL, NULL, NULL, NULL);
                if (!NT_SUCCESS(status)) {
                    isLinkPreset = FALSE;
                }

                if (isLinkPreset &&
                    !RtlEqualUnicodeString(&targetName, &otherTargetName,
                                           TRUE)) {

                    isLinkPreset = FALSE;
                }

                if (NT_SUCCESS(status)) {
                    ExFreePool(otherTargetName.Buffer);
                }
            }

            if (!isLinkPreset) {
                if (IsDriveLetter(&symbolicLinkNames[i])) {
                    hasDriveLetter = FALSE;
                    DeleteFromLocalDatabase(&symbolicLinkNames[i], uniqueId);
                }

                ExFreePool(symbolicLinkNames[i].Buffer);
                continue;
            }
        }

        if (IsOffline(&symbolicLinkNames[i])) {
            offline = TRUE;
        }

        symlinkEntry = ExAllocatePool(PagedPool,
                                      sizeof(SYMBOLIC_LINK_NAME_ENTRY));
        if (!symlinkEntry) {
            GlobalDeleteSymbolicLink(&symbolicLinkNames[i]);
            ExFreePool(symbolicLinkNames[i].Buffer);
            continue;
        }

        symlinkEntry->SymbolicLinkName = symbolicLinkNames[i];
        symlinkEntry->IsInDatabase = TRUE;

        InsertTailList(&deviceInfo->SymbolicLinkNames,
                       &symlinkEntry->ListEntry);
    }

    for (l = deviceInfo->SymbolicLinkNames.Flink;
         l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);
        SendLinkCreated(&symlinkEntry->SymbolicLinkName);
    }

    if (savedLinks) {
        MountMgrFreeSavedLink (savedLinks);
    }

    if (!hasVolumeName) {
        status = CreateNewVolumeName(&volumeName, NULL);
        if (NT_SUCCESS(status)) {
            RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                    MOUNTED_DEVICES_KEY, volumeName.Buffer, REG_BINARY,
                    uniqueId->UniqueId, uniqueId->UniqueIdLength);

            GlobalCreateSymbolicLink(&volumeName, &targetName);

            symlinkEntry = ExAllocatePool(PagedPool,
                                          sizeof(SYMBOLIC_LINK_NAME_ENTRY));
            if (symlinkEntry) {
                symlinkEntry->SymbolicLinkName = volumeName;
                symlinkEntry->IsInDatabase = TRUE;
                InsertTailList(&deviceInfo->SymbolicLinkNames,
                               &symlinkEntry->ListEntry);
                SendLinkCreated(&volumeName);
            } else {
                ExFreePool(volumeName.Buffer);
            }
        }
    }

    if (hasDriveLetter) {
        deviceInfo->SuggestedDriveLetter = 0;
    }

    if (!hasDriveLetter && extension->AutomaticDriveLetterAssignment &&
        (isRecognized || deviceInfo->SuggestedDriveLetter) &&
        !HasNoDriveLetterEntry(uniqueId)) {

        status = CreateNewDriveLetterName(&driveLetterName, &targetName,
                                          deviceInfo->SuggestedDriveLetter,
                                          uniqueId);
        if (NT_SUCCESS(status)) {
            RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                    MOUNTED_DEVICES_KEY, driveLetterName.Buffer,
                    REG_BINARY, uniqueId->UniqueId,
                    uniqueId->UniqueIdLength);

            symlinkEntry = ExAllocatePool(PagedPool,
                                          sizeof(SYMBOLIC_LINK_NAME_ENTRY));
            if (symlinkEntry) {
                symlinkEntry->SymbolicLinkName = driveLetterName;
                symlinkEntry->IsInDatabase = TRUE;
                InsertTailList(&deviceInfo->SymbolicLinkNames,
                               &symlinkEntry->ListEntry);
                SendLinkCreated(&driveLetterName);
            } else {
                ExFreePool(driveLetterName.Buffer);
            }
        } else {
            CreateNoDriveLetterEntry(uniqueId);
        }
    }

    if (!NotAPdo) {
        RegisterForTargetDeviceNotification(extension, deviceInfo);
    }

    InsertTailList(&extension->MountedDeviceList, &deviceInfo->ListEntry);

    allocSize = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
                uniqueId->UniqueIdLength;
    uniqueIdCopy = ExAllocatePool(PagedPool, allocSize);
    if (uniqueIdCopy) {
        RtlCopyMemory(uniqueIdCopy, uniqueId, allocSize);
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    if (!offline && !isFT) {
        SendOnlineNotification(NotificationName);
    }

    if (symbolicLinkNames) {
        ExFreePool(symbolicLinkNames);
    }

    if (uniqueIdCopy) {
        IssueUniqueIdChangeNotify(extension, NotificationName,
                                  uniqueIdCopy);
        ExFreePool(uniqueIdCopy);
    }

    if (extension->AutomaticDriveLetterAssignment) {
        KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                              FALSE, NULL);

        ReconcileThisDatabaseWithMaster(extension, deviceInfo);

        for (l = extension->MountedDeviceList.Flink;
             l != &extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (d->HasDanglingVolumeMountPoint) {
                ReconcileThisDatabaseWithMaster(extension, d);
            }
        }

        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
    }

    return STATUS_SUCCESS;
}

VOID
MountMgrFreeMountedDeviceInfo(
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo
    )

{

    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    while (!IsListEmpty(&DeviceInfo->SymbolicLinkNames)) {

        l = RemoveHeadList(&DeviceInfo->SymbolicLinkNames);
        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
        ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
        ExFreePool(symlinkEntry);
    }

    while (!IsListEmpty(&DeviceInfo->ReplicatedUniqueIds)) {

        l = RemoveHeadList(&DeviceInfo->ReplicatedUniqueIds);
        replUniqueId = CONTAINING_RECORD(l, REPLICATED_UNIQUE_ID,
                                         ListEntry);

        ExFreePool(replUniqueId->UniqueId);
        ExFreePool(replUniqueId);
    }

    while (!IsListEmpty(&DeviceInfo->MountPointsPointingHere)) {

        l = RemoveHeadList(&DeviceInfo->MountPointsPointingHere);
        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);
        ExFreePool(mountPointEntry->MountPath.Buffer);
        ExFreePool(mountPointEntry);
    }

    ExFreePool(DeviceInfo->NotificationName.Buffer);

    if (!DeviceInfo->KeepLinksWhenOffline) {
        ExFreePool(DeviceInfo->UniqueId);
    }

    ExFreePool(DeviceInfo->DeviceName.Buffer);

    if (DeviceInfo->TargetDeviceNotificationEntry) {
        IoUnregisterPlugPlayNotification(
                DeviceInfo->TargetDeviceNotificationEntry);
    }

    ExFreePool(DeviceInfo);
}

NTSTATUS
MountMgrMountedDeviceRemoval(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     NotificationName
    )

{
    PDEVICE_EXTENSION           extension = Extension;
    PMOUNTED_DEVICE_INFORMATION deviceInfo, d;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    PLIST_ENTRY                 l, ll, s;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PSAVED_LINKS_INFORMATION    savedLinks;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    for (l = extension->MountedDeviceList.Flink;
         l != &extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);
        if (!RtlCompareUnicodeString(&deviceInfo->NotificationName,
                                     NotificationName, TRUE)) {
            break;
        }
    }

    if (l != &extension->MountedDeviceList) {

        if (deviceInfo->KeepLinksWhenOffline) {
            savedLinks = ExAllocatePool(PagedPool,
                                        sizeof(SAVED_LINKS_INFORMATION));
            if (!savedLinks) {
                deviceInfo->KeepLinksWhenOffline = FALSE;
            }
        }

        if (deviceInfo->KeepLinksWhenOffline) {

            InsertTailList(&extension->SavedLinksList,
                           &savedLinks->ListEntry);
            InitializeListHead(&savedLinks->SymbolicLinkNames);
            savedLinks->UniqueId = deviceInfo->UniqueId;

            while (!IsListEmpty(&deviceInfo->SymbolicLinkNames)) {

                ll = RemoveHeadList(&deviceInfo->SymbolicLinkNames);
                symlinkEntry = CONTAINING_RECORD(ll,
                                                 SYMBOLIC_LINK_NAME_ENTRY,
                                                 ListEntry);

                if (symlinkEntry->IsInDatabase) {
                    InsertTailList(&savedLinks->SymbolicLinkNames, ll);
                } else {
                    GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
                    ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
                    ExFreePool(symlinkEntry);
                }
            }
        } else {

            while (!IsListEmpty(&deviceInfo->SymbolicLinkNames)) {

                ll = RemoveHeadList(&deviceInfo->SymbolicLinkNames);
                symlinkEntry = CONTAINING_RECORD(ll,
                                                 SYMBOLIC_LINK_NAME_ENTRY,
                                                 ListEntry);

                GlobalDeleteSymbolicLink(&symlinkEntry->SymbolicLinkName);
                ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
                ExFreePool(symlinkEntry);
            }
        }

        while (!IsListEmpty(&deviceInfo->ReplicatedUniqueIds)) {

            ll = RemoveHeadList(&deviceInfo->ReplicatedUniqueIds);
            replUniqueId = CONTAINING_RECORD(ll, REPLICATED_UNIQUE_ID,
                                             ListEntry);

            ExFreePool(replUniqueId->UniqueId);
            ExFreePool(replUniqueId);
        }

        while (!IsListEmpty(&deviceInfo->MountPointsPointingHere)) {

            ll = RemoveHeadList(&deviceInfo->MountPointsPointingHere);
            mountPointEntry = CONTAINING_RECORD(ll, MOUNTMGR_MOUNT_POINT_ENTRY,
                                                ListEntry);

            mountPointEntry->DeviceInfo->HasDanglingVolumeMountPoint = TRUE;

            ExFreePool(mountPointEntry->MountPath.Buffer);
            ExFreePool(mountPointEntry);
        }

        RemoveEntryList(l);

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);

            for (ll = d->MountPointsPointingHere.Flink;
                 ll != &d->MountPointsPointingHere; ll = ll->Flink) {

                mountPointEntry = CONTAINING_RECORD(ll, MOUNTMGR_MOUNT_POINT_ENTRY,
                                                    ListEntry);
                if (mountPointEntry->DeviceInfo == deviceInfo) {
                    s = ll->Blink;
                    RemoveEntryList(ll);
                    ExFreePool(mountPointEntry->MountPath.Buffer);
                    ExFreePool(mountPointEntry);
                    ll = s;
                }
            }
        }

        ExFreePool(deviceInfo->NotificationName.Buffer);

        if (!deviceInfo->KeepLinksWhenOffline) {
            ExFreePool(deviceInfo->UniqueId);
        }

        ExFreePool(deviceInfo->DeviceName.Buffer);

        if (deviceInfo->TargetDeviceNotificationEntry) {
            IoUnregisterPlugPlayNotification(
                    deviceInfo->TargetDeviceNotificationEntry);
        }

        ExFreePool(deviceInfo);

    } else {

        for (l = extension->DeadMountedDeviceList.Flink;
             l != &extension->DeadMountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);
            if (!RtlCompareUnicodeString(&deviceInfo->NotificationName,
                                         NotificationName, TRUE)) {
                break;
            }
        }

        if (l != &extension->DeadMountedDeviceList) {
            RemoveEntryList(l);
            MountMgrFreeDeadDeviceInfo (deviceInfo);
        }
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrMountedDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   Extension
    )

/*++

Routine Description:

    This routine is called whenever a volume comes or goes.

Arguments:

    NotificationStructure   - Supplies the notification structure.

    Extension               - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   notification = NotificationStructure;
    PDEVICE_EXTENSION                       extension = Extension;
    BOOLEAN                                 oldHardErrorMode;
    NTSTATUS                                status;

    oldHardErrorMode = PsGetThreadHardErrorsAreDisabled(PsGetCurrentThread());
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),TRUE);

    if (IsEqualGUID(&notification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        status = MountMgrMountedDeviceArrival(extension,
                                              notification->SymbolicLinkName,
                                              FALSE);

    } else if (IsEqualGUID(&notification->Event,
                           &GUID_DEVICE_INTERFACE_REMOVAL)) {

        status = MountMgrMountedDeviceRemoval(extension,
                                              notification->SymbolicLinkName);

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),oldHardErrorMode);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrCreateClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a create or close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    if (irpSp->MajorFunction == IRP_MJ_CREATE) {
        if (irpSp->Parameters.Create.Options&FILE_DIRECTORY_FILE) {
            status = STATUS_NOT_A_DIRECTORY;
        } else {
            status = STATUS_SUCCESS;
        }
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
MountMgrCreatePoint(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine creates a mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_CREATE_POINT_INPUT    input = Irp->AssociatedIrp.SystemBuffer;
    ULONG                           len1, len2, len;
    UNICODE_STRING                  symbolicLinkName, deviceName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_CREATE_POINT_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    len1 = input->DeviceNameOffset + input->DeviceNameLength;
    len2 = input->SymbolicLinkNameOffset + input->SymbolicLinkNameLength;
    len = len1 > len2 ? len1 : len2;

    if (len > irpSp->Parameters.DeviceIoControl.InputBufferLength) {
        return STATUS_INVALID_PARAMETER;
    }

    symbolicLinkName.Length = symbolicLinkName.MaximumLength =
            input->SymbolicLinkNameLength;
    symbolicLinkName.Buffer = (PWSTR) ((PCHAR) input +
                                       input->SymbolicLinkNameOffset);
    deviceName.Length = deviceName.MaximumLength = input->DeviceNameLength;
    deviceName.Buffer = (PWSTR) ((PCHAR) input + input->DeviceNameOffset);

    return MountMgrCreatePointWorker(Extension, &symbolicLinkName, &deviceName);
}

NTSTATUS
QueryPointsFromSymbolicLinkName(
    IN      PDEVICE_EXTENSION   Extension,
    IN      PUNICODE_STRING     SymbolicLinkName,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries the mount point information from the
    symbolic link name.

Arguments:

    SymbolicLinkName    - Supplies the symbolic link name.

    Irp                 - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              deviceName;
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY   symEntry;
    ULONG                       len;
    PIO_STACK_LOCATION          irpSp;
    PMOUNTMGR_MOUNT_POINTS      output;

    status = QueryDeviceInformation(SymbolicLinkName, &deviceName, NULL, NULL,
                                    NULL, NULL, NULL, NULL);
    if (NT_SUCCESS(status)) {

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);

            if (!RtlCompareUnicodeString(&deviceName, &deviceInfo->DeviceName,
                                         TRUE)) {

                break;
            }
        }

        ExFreePool(deviceName.Buffer);

        if (l == &Extension->MountedDeviceList) {
            return STATUS_INVALID_PARAMETER;
        }

        for (l = deviceInfo->SymbolicLinkNames.Flink;
             l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

            symEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY, ListEntry);
            if (RtlEqualUnicodeString(SymbolicLinkName,
                                      &symEntry->SymbolicLinkName, TRUE)) {

                break;
            }
        }

        if (l == &deviceInfo->SymbolicLinkNames) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                           ListEntry);

            for (ll = deviceInfo->SymbolicLinkNames.Flink;
                 ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

                symEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);
                if (RtlEqualUnicodeString(SymbolicLinkName,
                                          &symEntry->SymbolicLinkName, TRUE)) {

                    break;
                }
            }

            if (ll != &deviceInfo->SymbolicLinkNames) {
                break;
            }
        }

        if (l == &Extension->MountedDeviceList) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    len = sizeof(MOUNTMGR_MOUNT_POINTS) + symEntry->SymbolicLinkName.Length +
          deviceInfo->DeviceName.Length + deviceInfo->UniqueId->UniqueIdLength;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    output = Irp->AssociatedIrp.SystemBuffer;
    output->Size = len;
    output->NumberOfMountPoints = 1;
    Irp->IoStatus.Information = len;

    if (len > irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
        Irp->IoStatus.Information = sizeof(MOUNTMGR_MOUNT_POINTS);
        return STATUS_BUFFER_OVERFLOW;
    }

    output->MountPoints[0].SymbolicLinkNameOffset =
            sizeof(MOUNTMGR_MOUNT_POINTS);
    output->MountPoints[0].SymbolicLinkNameLength =
            symEntry->SymbolicLinkName.Length;

    if (symEntry->IsInDatabase) {
        output->MountPoints[0].UniqueIdOffset =
                output->MountPoints[0].SymbolicLinkNameOffset +
                output->MountPoints[0].SymbolicLinkNameLength;
        output->MountPoints[0].UniqueIdLength =
                deviceInfo->UniqueId->UniqueIdLength;
    } else {
        output->MountPoints[0].UniqueIdOffset = 0;
        output->MountPoints[0].UniqueIdLength = 0;
    }

    output->MountPoints[0].DeviceNameOffset =
            output->MountPoints[0].SymbolicLinkNameOffset +
            output->MountPoints[0].SymbolicLinkNameLength +
            output->MountPoints[0].UniqueIdLength;
    output->MountPoints[0].DeviceNameLength = deviceInfo->DeviceName.Length;

    RtlCopyMemory((PCHAR) output +
                  output->MountPoints[0].SymbolicLinkNameOffset,
                  symEntry->SymbolicLinkName.Buffer,
                  output->MountPoints[0].SymbolicLinkNameLength);

    if (symEntry->IsInDatabase) {
        RtlCopyMemory((PCHAR) output + output->MountPoints[0].UniqueIdOffset,
                      deviceInfo->UniqueId->UniqueId,
                      output->MountPoints[0].UniqueIdLength);
    }

    RtlCopyMemory((PCHAR) output + output->MountPoints[0].DeviceNameOffset,
                  deviceInfo->DeviceName.Buffer,
                  output->MountPoints[0].DeviceNameLength);

    return STATUS_SUCCESS;
}

NTSTATUS
QueryPointsFromMemory(
    IN      PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      PMOUNTDEV_UNIQUE_ID UniqueId,
    IN      PUNICODE_STRING     DeviceName
    )

/*++

Routine Description:

    This routine queries the points for the given unique id or device name.

Arguments:

    Extension           - Supplies the device extension.

    Irp                 - Supplies the I/O request packet.

    UniqueId            - Supplies the unique id.

    DeviceName          - Supplies the device name.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              targetName;
    ULONG                       numPoints, size;
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    PIO_STACK_LOCATION          irpSp;
    PMOUNTMGR_MOUNT_POINTS      output;
    ULONG                       offset, uOffset, dOffset;
    USHORT                      uLen, dLen;

    if (DeviceName) {
        status = QueryDeviceInformation(DeviceName, &targetName, NULL, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    numPoints = 0;
    size = 0;
    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (UniqueId) {

            if (UniqueId->UniqueIdLength ==
                deviceInfo->UniqueId->UniqueIdLength) {

                if (RtlCompareMemory(UniqueId->UniqueId,
                                     deviceInfo->UniqueId->UniqueId,
                                     UniqueId->UniqueIdLength) !=
                    UniqueId->UniqueIdLength) {

                    continue;
                }

            } else {
                continue;
            }

        } else if (DeviceName) {

            if (!RtlEqualUnicodeString(&targetName, &deviceInfo->DeviceName,
                                       TRUE)) {

                continue;
            }
        }

        size += deviceInfo->UniqueId->UniqueIdLength;
        size += deviceInfo->DeviceName.Length;

        for (ll = deviceInfo->SymbolicLinkNames.Flink;
             ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

            symlinkEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);

            numPoints++;
            size += symlinkEntry->SymbolicLinkName.Length;
        }

        if (UniqueId || DeviceName) {
            break;
        }
    }

    if (UniqueId || DeviceName) {
        if (l == &Extension->MountedDeviceList) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    output = Irp->AssociatedIrp.SystemBuffer;
    output->Size = FIELD_OFFSET(MOUNTMGR_MOUNT_POINTS, MountPoints) +
                   numPoints*sizeof(MOUNTMGR_MOUNT_POINT) + size;
    output->NumberOfMountPoints = numPoints;
    Irp->IoStatus.Information = output->Size;

    if (output->Size > irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
        Irp->IoStatus.Information = sizeof(MOUNTMGR_MOUNT_POINTS);
        if (DeviceName) {
            ExFreePool(targetName.Buffer);
        }
        return STATUS_BUFFER_OVERFLOW;
    }

    numPoints = 0;
    offset = output->Size - size;
    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (UniqueId) {

            if (UniqueId->UniqueIdLength ==
                deviceInfo->UniqueId->UniqueIdLength) {

                if (RtlCompareMemory(UniqueId->UniqueId,
                                     deviceInfo->UniqueId->UniqueId,
                                     UniqueId->UniqueIdLength) !=
                    UniqueId->UniqueIdLength) {

                    continue;
                }

            } else {
                continue;
            }

        } else if (DeviceName) {

            if (!RtlEqualUnicodeString(&targetName, &deviceInfo->DeviceName,
                                       TRUE)) {

                continue;
            }
        }

        uOffset = offset;
        uLen = deviceInfo->UniqueId->UniqueIdLength;
        dOffset = uOffset + uLen;
        dLen = deviceInfo->DeviceName.Length;
        offset += uLen + dLen;

        RtlCopyMemory((PCHAR) output + uOffset, deviceInfo->UniqueId->UniqueId,
                      uLen);
        RtlCopyMemory((PCHAR) output + dOffset, deviceInfo->DeviceName.Buffer,
                      dLen);

        for (ll = deviceInfo->SymbolicLinkNames.Flink;
             ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

            symlinkEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);

            output->MountPoints[numPoints].SymbolicLinkNameOffset = offset;
            output->MountPoints[numPoints].SymbolicLinkNameLength =
                    symlinkEntry->SymbolicLinkName.Length;

            if (symlinkEntry->IsInDatabase) {
                output->MountPoints[numPoints].UniqueIdOffset = uOffset;
                output->MountPoints[numPoints].UniqueIdLength = uLen;
            } else {
                output->MountPoints[numPoints].UniqueIdOffset = 0;
                output->MountPoints[numPoints].UniqueIdLength = 0;
            }

            output->MountPoints[numPoints].DeviceNameOffset = dOffset;
            output->MountPoints[numPoints].DeviceNameLength = dLen;

            RtlCopyMemory((PCHAR) output + offset,
                          symlinkEntry->SymbolicLinkName.Buffer,
                          symlinkEntry->SymbolicLinkName.Length);

            offset += symlinkEntry->SymbolicLinkName.Length;
            numPoints++;
        }

        if (UniqueId || DeviceName) {
            break;
        }
    }

    if (DeviceName) {
        ExFreePool(targetName.Buffer);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryPoints(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries a range of mount points.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_MOUNT_POINT   input;
    LONGLONG                len1, len2, len3, len;
    UNICODE_STRING          name;
    NTSTATUS                status;
    PMOUNTDEV_UNIQUE_ID     id;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_MOUNT_POINT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = Irp->AssociatedIrp.SystemBuffer;
    if (!input->SymbolicLinkNameLength) {
        input->SymbolicLinkNameOffset = 0;
    }
    if (!input->UniqueIdLength) {
        input->UniqueIdOffset = 0;
    }
    if (!input->DeviceNameLength) {
        input->DeviceNameOffset = 0;
    }

    if ((input->SymbolicLinkNameOffset&1) ||
        (input->SymbolicLinkNameLength&1) ||
        (input->UniqueIdOffset&1) ||
        (input->UniqueIdLength&1) ||
        (input->DeviceNameOffset&1) ||
        (input->DeviceNameLength&1)) {

        return STATUS_INVALID_PARAMETER;
    }

    len1 = (LONGLONG) input->SymbolicLinkNameOffset +
                      input->SymbolicLinkNameLength;
    len2 = (LONGLONG) input->UniqueIdOffset + input->UniqueIdLength;
    len3 = (LONGLONG) input->DeviceNameOffset + input->DeviceNameLength;
    len = len1 > len2 ? len1 : len2;
    len = len > len3 ? len : len3;
    if (len > irpSp->Parameters.DeviceIoControl.InputBufferLength) {
        return STATUS_INVALID_PARAMETER;
    }
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTMGR_MOUNT_POINTS)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->SymbolicLinkNameLength) {

        if (input->SymbolicLinkNameLength > 0xF000) {
            return STATUS_INVALID_PARAMETER;
        }

        name.Length = input->SymbolicLinkNameLength;
        name.MaximumLength = name.Length + sizeof(WCHAR);
        name.Buffer = ExAllocatePool(PagedPool, name.MaximumLength);
        if (!name.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(name.Buffer,
                      (PCHAR) input + input->SymbolicLinkNameOffset,
                      name.Length);
        name.Buffer[name.Length/sizeof(WCHAR)] = 0;

        status = QueryPointsFromSymbolicLinkName(Extension, &name, Irp);

        ExFreePool(name.Buffer);

    } else if (input->UniqueIdLength) {

        id = ExAllocatePool(PagedPool, input->UniqueIdLength + sizeof(USHORT));
        if (!id) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        id->UniqueIdLength = input->UniqueIdLength;
        RtlCopyMemory(id->UniqueId, (PCHAR) input + input->UniqueIdOffset,
                      input->UniqueIdLength);

        status = QueryPointsFromMemory(Extension, Irp, id, NULL);

        ExFreePool(id);

    } else if (input->DeviceNameLength) {

        if (input->DeviceNameLength > 0xF000) {
            return STATUS_INVALID_PARAMETER;
        }

        name.Length = input->DeviceNameLength;
        name.MaximumLength = name.Length + sizeof(WCHAR);
        name.Buffer = ExAllocatePool(PagedPool, name.MaximumLength);
        if (!name.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(name.Buffer, (PCHAR) input + input->DeviceNameOffset,
                      name.Length);
        name.Buffer[name.Length/sizeof(WCHAR)] = 0;

        status = QueryPointsFromMemory(Extension, Irp, NULL, &name);

        ExFreePool(name.Buffer);

    } else {
        status = QueryPointsFromMemory(Extension, Irp, NULL, NULL);
    }

    return status;
}

VOID
SendLinkDeleted(
    IN  PUNICODE_STRING DeviceName,
    IN  PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine alerts the mounted device that one of its links is
    being deleted.

Arguments:

    DeviceName  - Supplies the device name.

    SymbolicLinkName    - Supplies the symbolic link name being deleted.

Return Value:

    None.

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        fileObject;
    PDEVICE_OBJECT      deviceObject;
    ULONG               inputSize;
    PMOUNTDEV_NAME      input;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;

    status = IoGetDeviceObjectPointer(DeviceName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);

    inputSize = sizeof(USHORT) + SymbolicLinkName->Length;
    input = ExAllocatePool(PagedPool, inputSize);
    if (!input) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }

    input->NameLength = SymbolicLinkName->Length;
    RtlCopyMemory(input->Name, SymbolicLinkName->Buffer,
                  SymbolicLinkName->Length);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(
          IOCTL_MOUNTDEV_LINK_DELETED, deviceObject, input, inputSize, NULL, 0,
          FALSE, &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);
    ObDereferenceObject(fileObject);
}

VOID
DeleteSymbolicLinkNameFromMemory(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUNICODE_STRING     SymbolicLinkName,
    IN  BOOLEAN             DbOnly
    )

/*++

Routine Description:

    This routine deletes the given symbolic link name from memory.

Arguments:

    Extension           - Supplies the device extension.

    SymbolicLinkName    - Supplies the symbolic link name.

    DbOnly              - Supplies whether or not this is DBONLY.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                 l, ll;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        for (ll = deviceInfo->SymbolicLinkNames.Flink;
             ll != &deviceInfo->SymbolicLinkNames; ll = ll->Flink) {

            symlinkEntry = CONTAINING_RECORD(ll, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);

            if (!RtlCompareUnicodeString(SymbolicLinkName,
                                         &symlinkEntry->SymbolicLinkName,
                                         TRUE)) {

                if (DbOnly) {
                    symlinkEntry->IsInDatabase = FALSE;
                } else {

                    SendLinkDeleted(&deviceInfo->NotificationName,
                                    SymbolicLinkName);

                    RemoveEntryList(ll);
                    ExFreePool(symlinkEntry->SymbolicLinkName.Buffer);
                    ExFreePool(symlinkEntry);
                }
                return;
            }
        }
    }
}

NTSTATUS
MountMgrDeletePoints(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine creates a mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_MOUNT_POINT   point;
    BOOLEAN                 singlePoint;
    NTSTATUS                status;
    PMOUNTMGR_MOUNT_POINTS  points;
    ULONG                   i;
    UNICODE_STRING          symbolicLinkName;
    PMOUNTDEV_UNIQUE_ID     uniqueId;
    UNICODE_STRING          deviceName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_MOUNT_POINT)) {

        return STATUS_INVALID_PARAMETER;
    }

    point = Irp->AssociatedIrp.SystemBuffer;
    if (point->SymbolicLinkNameOffset && point->SymbolicLinkNameLength) {
        singlePoint = TRUE;
    } else {
        singlePoint = FALSE;
    }

    status = MountMgrQueryPoints(Extension, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    points = Irp->AssociatedIrp.SystemBuffer;
    for (i = 0; i < points->NumberOfMountPoints; i++) {

        symbolicLinkName.Length = points->MountPoints[i].SymbolicLinkNameLength;
        symbolicLinkName.MaximumLength = symbolicLinkName.Length + sizeof(WCHAR);
        symbolicLinkName.Buffer = ExAllocatePool(PagedPool,
                                                 symbolicLinkName.MaximumLength);
        if (!symbolicLinkName.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(symbolicLinkName.Buffer,
                      (PCHAR) points +
                      points->MountPoints[i].SymbolicLinkNameOffset,
                      symbolicLinkName.Length);

        symbolicLinkName.Buffer[symbolicLinkName.Length/sizeof(WCHAR)] = 0;

        if (singlePoint && IsDriveLetter(&symbolicLinkName)) {
            uniqueId = ExAllocatePool(PagedPool,
                                      points->MountPoints[i].UniqueIdLength +
                                      sizeof(MOUNTDEV_UNIQUE_ID));
            if (uniqueId) {
                uniqueId->UniqueIdLength =
                        points->MountPoints[i].UniqueIdLength;
                RtlCopyMemory(uniqueId->UniqueId, (PCHAR) points +
                              points->MountPoints[i].UniqueIdOffset,
                              uniqueId->UniqueIdLength);

                CreateNoDriveLetterEntry(uniqueId);

                ExFreePool(uniqueId);
            }
        }

        if (i == 0 && !singlePoint) {
            uniqueId = ExAllocatePool(PagedPool,
                                      points->MountPoints[i].UniqueIdLength +
                                      sizeof(MOUNTDEV_UNIQUE_ID));
            if (uniqueId) {
                uniqueId->UniqueIdLength =
                        points->MountPoints[i].UniqueIdLength;
                RtlCopyMemory(uniqueId->UniqueId, (PCHAR) points +
                              points->MountPoints[i].UniqueIdOffset,
                              uniqueId->UniqueIdLength);

                DeleteNoDriveLetterEntry(uniqueId);

                ExFreePool(uniqueId);
            }
        }

        GlobalDeleteSymbolicLink(&symbolicLinkName);
        DeleteSymbolicLinkNameFromMemory(Extension, &symbolicLinkName, FALSE);

        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               symbolicLinkName.Buffer);

        ExFreePool(symbolicLinkName.Buffer);

        deviceName.Length = points->MountPoints[i].DeviceNameLength;
        deviceName.MaximumLength = deviceName.Length;
        deviceName.Buffer = (PWCHAR) ((PCHAR) points +
                                      points->MountPoints[i].DeviceNameOffset);

        MountMgrNotifyNameChange(Extension, &deviceName, TRUE);
    }

    MountMgrNotify(Extension);

    return status;
}

NTSTATUS
MountMgrDeletePointsDbOnly(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine deletes mount points from the database.  It does not
    delete the symbolic links or the in memory representation.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                status;
    PMOUNTMGR_MOUNT_POINTS  points;
    ULONG                   i;
    UNICODE_STRING          symbolicLinkName;
    PMOUNTDEV_UNIQUE_ID     uniqueId;

    status = MountMgrQueryPoints(Extension, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    points = Irp->AssociatedIrp.SystemBuffer;
    for (i = 0; i < points->NumberOfMountPoints; i++) {

        symbolicLinkName.Length = points->MountPoints[i].SymbolicLinkNameLength;
        symbolicLinkName.MaximumLength = symbolicLinkName.Length + sizeof(WCHAR);
        symbolicLinkName.Buffer = ExAllocatePool(PagedPool,
                                                 symbolicLinkName.MaximumLength);
        if (!symbolicLinkName.Buffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(symbolicLinkName.Buffer,
                      (PCHAR) points +
                      points->MountPoints[i].SymbolicLinkNameOffset,
                      symbolicLinkName.Length);

        symbolicLinkName.Buffer[symbolicLinkName.Length/sizeof(WCHAR)] = 0;

        if (points->NumberOfMountPoints == 1 &&
            IsDriveLetter(&symbolicLinkName)) {

            uniqueId = ExAllocatePool(PagedPool,
                                      points->MountPoints[i].UniqueIdLength +
                                      sizeof(MOUNTDEV_UNIQUE_ID));
            if (uniqueId) {
                uniqueId->UniqueIdLength =
                        points->MountPoints[i].UniqueIdLength;
                RtlCopyMemory(uniqueId->UniqueId, (PCHAR) points +
                              points->MountPoints[i].UniqueIdOffset,
                              uniqueId->UniqueIdLength);

                CreateNoDriveLetterEntry(uniqueId);

                ExFreePool(uniqueId);
            }
        }

        DeleteSymbolicLinkNameFromMemory(Extension, &symbolicLinkName, TRUE);

        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY,
                               symbolicLinkName.Buffer);

        ExFreePool(symbolicLinkName.Buffer);
    }

    return status;
}

VOID
ProcessSuggestedDriveLetters(
    IN OUT  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine processes the saved suggested drive letters.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    UNICODE_STRING              symbolicLinkName;
    WCHAR                       symNameBuffer[30];

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo->SuggestedDriveLetter == 0xFF) {

            if (!HasDriveLetter(deviceInfo) &&
                !HasNoDriveLetterEntry(deviceInfo->UniqueId)) {

                CreateNoDriveLetterEntry(deviceInfo->UniqueId);
            }

            deviceInfo->SuggestedDriveLetter = 0;

        } else if (deviceInfo->SuggestedDriveLetter &&
                   !HasNoDriveLetterEntry(deviceInfo->UniqueId)) {

            symbolicLinkName.Length = symbolicLinkName.MaximumLength = 28;
            symbolicLinkName.Buffer = symNameBuffer;
            RtlCopyMemory(symbolicLinkName.Buffer, L"\\DosDevices\\", 24);
            symbolicLinkName.Buffer[12] = deviceInfo->SuggestedDriveLetter;
            symbolicLinkName.Buffer[13] = ':';

            MountMgrCreatePointWorker(Extension, &symbolicLinkName,
                                      &deviceInfo->DeviceName);
        }
    }
}

BOOLEAN
IsFtVolume(
    IN  PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine checks to see if the given volume is an FT volume.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    FALSE   - This is not an FT volume.

    TRUE    - This is an FT volume.

--*/

{
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject, checkObject;
    KEVENT                  event;
    PIRP                    irp;
    PARTITION_INFORMATION   partInfo;
    IO_STATUS_BLOCK         ioStatus;

    status = IoGetDeviceObjectPointer(DeviceName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }
    checkObject = fileObject->DeviceObject;
    deviceObject = IoGetAttachedDeviceReference(checkObject);

    if (checkObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);
        return FALSE;
    }

    ObDereferenceObject(fileObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        deviceObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        return FALSE;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    if (IsFTPartition(partInfo.PartitionType)) {
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
MountMgrNextDriveLetterWorker(
    IN OUT  PDEVICE_EXTENSION                   Extension,
    IN      PUNICODE_STRING                     DeviceName,
    OUT     PMOUNTMGR_DRIVE_LETTER_INFORMATION  DriveLetterInfo
    )

{
    UNICODE_STRING                      deviceName = *DeviceName;
    PMOUNTMGR_DRIVE_LETTER_INFORMATION  output = DriveLetterInfo;
    UNICODE_STRING                      targetName;
    NTSTATUS                            status;
    BOOLEAN                             isRecognized;
    PLIST_ENTRY                         l;
    PMOUNTED_DEVICE_INFORMATION         deviceInfo;
    PSYMBOLIC_LINK_NAME_ENTRY           symlinkEntry;
    UNICODE_STRING                      symbolicLinkName, floppyPrefix, cdromPrefix;
    WCHAR                               symNameBuffer[30];
    UCHAR                               startDriveLetterName;
    PMOUNTDEV_UNIQUE_ID                 uniqueId;

    if (!Extension->SuggestedDriveLettersProcessed) {
        ProcessSuggestedDriveLetters(Extension);
        Extension->SuggestedDriveLettersProcessed = TRUE;
    }

    status = QueryDeviceInformation(&deviceName, &targetName, NULL, NULL,
                                    &isRecognized, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (!RtlCompareUnicodeString(&targetName, &deviceInfo->DeviceName,
                                     TRUE)) {

            break;
        }
    }

    if (l == &Extension->MountedDeviceList) {
        ExFreePool(targetName.Buffer);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    deviceInfo->NextDriveLetterCalled = TRUE;

    output->DriveLetterWasAssigned = TRUE;

    for (l = deviceInfo->SymbolicLinkNames.Flink;
         l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        if (IsDriveLetter(&symlinkEntry->SymbolicLinkName) &&
            symlinkEntry->IsInDatabase) {

            output->DriveLetterWasAssigned = FALSE;
            output->CurrentDriveLetter =
                    (UCHAR) symlinkEntry->SymbolicLinkName.Buffer[12];
            break;
        }
    }

    if (l == &deviceInfo->SymbolicLinkNames &&
        (!isRecognized || HasNoDriveLetterEntry(deviceInfo->UniqueId))) {

        output->DriveLetterWasAssigned = FALSE;
        output->CurrentDriveLetter = 0;
        ExFreePool(targetName.Buffer);
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&floppyPrefix, L"\\Device\\Floppy");
    RtlInitUnicodeString(&cdromPrefix, L"\\Device\\CdRom");
    if (RtlPrefixUnicodeString(&floppyPrefix, &targetName, TRUE)) {
        startDriveLetterName = 'A';
    } else if (RtlPrefixUnicodeString(&cdromPrefix, &targetName, TRUE)) {
        startDriveLetterName = 'D';
    } else {
        startDriveLetterName = 'C';
    }

    if (output->DriveLetterWasAssigned) {

        ASSERT(deviceInfo->SuggestedDriveLetter != 0xFF);

        if (!deviceInfo->SuggestedDriveLetter &&
            IsFtVolume(&deviceInfo->DeviceName)) {

            output->DriveLetterWasAssigned = FALSE;
            output->CurrentDriveLetter = 0;
            ExFreePool(targetName.Buffer);
            return STATUS_SUCCESS;
        }

        symbolicLinkName.Length = symbolicLinkName.MaximumLength = 28;
        symbolicLinkName.Buffer = symNameBuffer;
        RtlCopyMemory(symbolicLinkName.Buffer, L"\\DosDevices\\", 24);
        symbolicLinkName.Buffer[13] = ':';

        if (deviceInfo->SuggestedDriveLetter) {
            output->CurrentDriveLetter = deviceInfo->SuggestedDriveLetter;
            symbolicLinkName.Buffer[12] = output->CurrentDriveLetter;
            status = MountMgrCreatePointWorker(Extension, &symbolicLinkName,
                                               &targetName);
            if (NT_SUCCESS(status)) {
                ExFreePool(targetName.Buffer);
                return STATUS_SUCCESS;
            }
        }

        for (output->CurrentDriveLetter = startDriveLetterName;
             output->CurrentDriveLetter <= 'Z';
             output->CurrentDriveLetter++) {

            symbolicLinkName.Buffer[12] = output->CurrentDriveLetter;
            status = MountMgrCreatePointWorker(Extension, &symbolicLinkName,
                                               &targetName);
            if (NT_SUCCESS(status)) {
                break;
            }
        }

        if (output->CurrentDriveLetter > 'Z') {
            output->CurrentDriveLetter = 0;
            output->DriveLetterWasAssigned = FALSE;
            status = QueryDeviceInformation(&targetName, NULL, &uniqueId,
                                            NULL, NULL, NULL, NULL, NULL);
            if (NT_SUCCESS(status)) {
                CreateNoDriveLetterEntry(uniqueId);
                ExFreePool(uniqueId);
            }
        }
    }

    ExFreePool(targetName.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrNextDriveLetter(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine gives the next available drive letter to the given device
    unless the device already has a drive letter or the device has a flag
    specifying that it should not receive a drive letter.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_DRIVE_LETTER_TARGET       input;
    UNICODE_STRING                      deviceName;
    NTSTATUS                            status;
    MOUNTMGR_DRIVE_LETTER_INFORMATION   driveLetterInfo;
    PMOUNTMGR_DRIVE_LETTER_INFORMATION  output;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_DRIVE_LETTER_TARGET) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTMGR_DRIVE_LETTER_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = Irp->AssociatedIrp.SystemBuffer;
    if (input->DeviceNameLength +
        (ULONG) FIELD_OFFSET(MOUNTMGR_DRIVE_LETTER_TARGET, DeviceName) >
        irpSp->Parameters.DeviceIoControl.InputBufferLength) {

        return STATUS_INVALID_PARAMETER;
    }

    deviceName.MaximumLength = deviceName.Length = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = MountMgrNextDriveLetterWorker(Extension, &deviceName,
                                           &driveLetterInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    output = Irp->AssociatedIrp.SystemBuffer;
    *output = driveLetterInfo;

    Irp->IoStatus.Information = sizeof(MOUNTMGR_DRIVE_LETTER_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrVolumeMountPointChanged(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      NTSTATUS            ResultOfWaitForDatabase,
    OUT     PUNICODE_STRING     SourceVolume,
    OUT     PUNICODE_STRING     MountPath,
    OUT     PUNICODE_STRING     TargetVolume
    )

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_VOLUME_MOUNT_POINT    input;
    ULONG                           len1, len2, len;
    OBJECT_ATTRIBUTES               oa;
    NTSTATUS                        status;
    HANDLE                          h;
    IO_STATUS_BLOCK                 ioStatus;
    PFILE_OBJECT                    fileObject;
    UNICODE_STRING                  deviceName;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_VOLUME_MOUNT_POINT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = Irp->AssociatedIrp.SystemBuffer;

    len1 = input->SourceVolumeNameOffset + input->SourceVolumeNameLength;
    len2 = input->TargetVolumeNameOffset + input->TargetVolumeNameLength;
    len = len1 > len2 ? len1 : len2;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < len) {
        return STATUS_INVALID_PARAMETER;
    }

    SourceVolume->Length = SourceVolume->MaximumLength =
            input->SourceVolumeNameLength;
    SourceVolume->Buffer = (PWSTR) ((PCHAR) input +
                                    input->SourceVolumeNameOffset);

    InitializeObjectAttributes(&oa, SourceVolume, OBJ_CASE_INSENSITIVE, 0, 0);
    status = ZwOpenFile(&h, FILE_READ_ATTRIBUTES, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_REPARSE_POINT);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ObReferenceObjectByHandle(h, 0, *IoFileObjectType, KernelMode,
                                       (PVOID*) &fileObject, NULL);
    ZwClose(h);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    SourceVolume->Length -= fileObject->FileName.Length;
    SourceVolume->MaximumLength = SourceVolume->Length;

    MountPath->MaximumLength = MountPath->Length = fileObject->FileName.Length;
    MountPath->Buffer = (PWSTR) ((PCHAR) SourceVolume->Buffer +
                                 SourceVolume->Length);

    ObDereferenceObject(fileObject);

    TargetVolume->Length = TargetVolume->MaximumLength =
            input->TargetVolumeNameLength;
    TargetVolume->Buffer = (PWSTR) ((PCHAR) input +
                                    input->TargetVolumeNameOffset);

    status = QueryDeviceInformation(TargetVolume, &deviceName, NULL,
                                    NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    MountMgrNotify(Extension);
    MountMgrNotifyNameChange(Extension, &deviceName, TRUE);
    ExFreePool(deviceName.Buffer);

    if (!NT_SUCCESS(ResultOfWaitForDatabase)) {
        status = FindDeviceInfo(Extension, SourceVolume, FALSE, &deviceInfo);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        ReconcileThisDatabaseWithMaster(Extension, deviceInfo);

        return STATUS_PENDING;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQuerySymbolicLink(
    IN      PUNICODE_STRING SourceOfLink,
    IN OUT  PUNICODE_STRING TargetOfLink
    )

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;

    InitializeObjectAttributes(&oa, SourceOfLink, OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwOpenSymbolicLinkObject(&handle, GENERIC_READ, &oa);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwQuerySymbolicLinkObject(handle, TargetOfLink, NULL);
    ZwClose(handle);

    if (NT_SUCCESS(status)) {
        if (TargetOfLink->Length > 1*sizeof(WCHAR) &&
            TargetOfLink->Buffer[TargetOfLink->Length/sizeof(WCHAR) - 1] ==
            '\\') {

            TargetOfLink->Length -= sizeof(WCHAR);
            TargetOfLink->Buffer[TargetOfLink->Length/sizeof(WCHAR)] = 0;
        }
    }

    return status;
}

NTSTATUS
MountMgrVolumeMountPointCreated(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      NTSTATUS            ResultOfWaitForDatabase
    )

/*++

Routine Description:

    This routine alerts that mount manager that a volume mount point has
    been created so that the mount manager can replicate the database entry
    for the given mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              sourceVolume, mountPath, targetVolume, v, p;
    WCHAR                       volumeNameBuffer[MAX_VOLUME_PATH];
    PMOUNTED_DEVICE_INFORMATION sourceDeviceInfo, targetDeviceInfo;
    HANDLE                      h;
    ULONG                       offset;
    BOOLEAN                     entryFound;
    PMOUNTMGR_FILE_ENTRY        databaseEntry;
    UNICODE_STRING              otherTargetVolumeName;
    PMOUNTDEV_UNIQUE_ID         uniqueId;
    ULONG                       size;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    status = MountMgrVolumeMountPointChanged(Extension, Irp,
                                             ResultOfWaitForDatabase,
                                             &sourceVolume, &mountPath,
                                             &targetVolume);
    if (status == STATUS_PENDING) {
        return STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                            &sourceDeviceInfo);
    if (!NT_SUCCESS(status)) {

        v.MaximumLength = MAX_VOLUME_PATH*sizeof(WCHAR);
        v.Length = 0;
        v.Buffer = volumeNameBuffer;

        status = QueryVolumeName(NULL, NULL, &sourceVolume, &v, &p);
        if (NT_SUCCESS(status)) {
            ExFreePool(p.Buffer);
        } else {
            status = MountMgrQuerySymbolicLink(&sourceVolume, &v);
            if (!NT_SUCCESS(status)) {
                return status;
            }
        }
        sourceVolume = v;

        status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                                &sourceDeviceInfo);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = FindDeviceInfo(Extension, &targetVolume, FALSE,
                            &targetDeviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    h = OpenRemoteDatabase(&sourceVolume, TRUE);
    if (!h) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset = 0;
    entryFound = FALSE;
    for (;;) {

        databaseEntry = GetRemoteDatabaseEntry(h, offset);
        if (!databaseEntry) {
            break;
        }

        otherTargetVolumeName.Length = otherTargetVolumeName.MaximumLength =
                databaseEntry->VolumeNameLength;
        otherTargetVolumeName.Buffer = (PWSTR) ((PCHAR) databaseEntry +
                                       databaseEntry->VolumeNameOffset);

        if (RtlEqualUnicodeString(&targetVolume, &otherTargetVolumeName,
                                  TRUE)) {

            entryFound = TRUE;
            break;
        }

        offset += databaseEntry->EntryLength;
        ExFreePool(databaseEntry);
    }

    if (entryFound) {

        databaseEntry->RefCount++;
        status = WriteRemoteDatabaseEntry(h, offset, databaseEntry);
        ExFreePool(databaseEntry);

    } else {

        status = QueryDeviceInformation(&targetVolume, NULL, &uniqueId, NULL,
                                        NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            CloseRemoteDatabase(h);
            return status;
        }

        size = sizeof(MOUNTMGR_FILE_ENTRY) + targetVolume.Length +
               uniqueId->UniqueIdLength;

        databaseEntry = ExAllocatePool(PagedPool, size);
        if (!databaseEntry) {
            ExFreePool(uniqueId);
            CloseRemoteDatabase(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        databaseEntry->EntryLength = size;
        databaseEntry->RefCount = 1;
        databaseEntry->VolumeNameOffset = sizeof(MOUNTMGR_FILE_ENTRY);
        databaseEntry->VolumeNameLength = targetVolume.Length;
        databaseEntry->UniqueIdOffset = databaseEntry->VolumeNameOffset +
                                        databaseEntry->VolumeNameLength;
        databaseEntry->UniqueIdLength = uniqueId->UniqueIdLength;

        RtlCopyMemory((PCHAR) databaseEntry + databaseEntry->VolumeNameOffset,
                      targetVolume.Buffer, databaseEntry->VolumeNameLength);
        RtlCopyMemory((PCHAR) databaseEntry + databaseEntry->UniqueIdOffset,
                      uniqueId->UniqueId, databaseEntry->UniqueIdLength);

        status = AddRemoteDatabaseEntry(h, databaseEntry);

        ExFreePool(databaseEntry);

        if (!NT_SUCCESS(status)) {
            ExFreePool(uniqueId);
            CloseRemoteDatabase(h);
            return status;
        }

        replUniqueId = ExAllocatePool(PagedPool, sizeof(REPLICATED_UNIQUE_ID));
        if (!replUniqueId) {
            ExFreePool(uniqueId);
            CloseRemoteDatabase(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        replUniqueId->UniqueId = uniqueId;

        InsertTailList(&sourceDeviceInfo->ReplicatedUniqueIds,
                       &replUniqueId->ListEntry);
    }

    CloseRemoteDatabase(h);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    mountPointEntry = (PMOUNTMGR_MOUNT_POINT_ENTRY)
                      ExAllocatePool(PagedPool,
                                     sizeof(MOUNTMGR_MOUNT_POINT_ENTRY));
    if (!mountPointEntry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mountPointEntry->MountPath.Length = mountPath.Length;
    mountPointEntry->MountPath.MaximumLength = mountPath.Length +
                                               sizeof(WCHAR);
    mountPointEntry->MountPath.Buffer =
            ExAllocatePool(PagedPool,
                           mountPointEntry->MountPath.MaximumLength);
    if (!mountPointEntry->MountPath.Buffer) {
        ExFreePool(mountPointEntry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(mountPointEntry->MountPath.Buffer,
                  mountPath.Buffer, mountPath.Length);
    mountPointEntry->MountPath.Buffer[mountPath.Length/sizeof(WCHAR)] = 0;

    mountPointEntry->DeviceInfo = sourceDeviceInfo;
    InsertTailList(&targetDeviceInfo->MountPointsPointingHere,
                   &mountPointEntry->ListEntry);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrVolumeMountPointDeleted(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp,
    IN      NTSTATUS            ResultOfWaitForDatabase
    )

/*++

Routine Description:

    This routine alerts that mount manager that a volume mount point has
    been created so that the mount manager can replicate the database entry
    for the given mount point.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              sourceVolume, mountPath, targetVolume, v, p;
    WCHAR                       volumeNameBuffer[MAX_VOLUME_PATH];
    PMOUNTED_DEVICE_INFORMATION sourceDeviceInfo, targetDeviceInfo;
    HANDLE                      h;
    ULONG                       offset;
    BOOLEAN                     entryFound;
    PMOUNTMGR_FILE_ENTRY        databaseEntry;
    UNICODE_STRING              otherTargetVolumeName;
    PLIST_ENTRY                 l;
    PREPLICATED_UNIQUE_ID       replUniqueId;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    status = MountMgrVolumeMountPointChanged(Extension, Irp,
                                             ResultOfWaitForDatabase,
                                             &sourceVolume, &mountPath,
                                             &targetVolume);
    if (status == STATUS_PENDING) {
        return STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                            &sourceDeviceInfo);
    if (!NT_SUCCESS(status)) {

        v.MaximumLength = MAX_VOLUME_PATH*sizeof(WCHAR);
        v.Length = 0;
        v.Buffer = volumeNameBuffer;

        status = QueryVolumeName(NULL, NULL, &sourceVolume, &v, &p);
        if (NT_SUCCESS(status)) {
            ExFreePool(p.Buffer);
        } else {
            status = MountMgrQuerySymbolicLink(&sourceVolume, &v);
            if (!NT_SUCCESS(status)) {
                return status;
            }
        }
        sourceVolume = v;

        status = FindDeviceInfo(Extension, &sourceVolume, FALSE,
                                &sourceDeviceInfo);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = FindDeviceInfo(Extension, &targetVolume, FALSE,
                            &targetDeviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    h = OpenRemoteDatabase(&sourceVolume, TRUE);
    if (!h) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset = 0;
    entryFound = FALSE;
    for (;;) {

        databaseEntry = GetRemoteDatabaseEntry(h, offset);
        if (!databaseEntry) {
            break;
        }

        otherTargetVolumeName.Length = otherTargetVolumeName.MaximumLength =
                databaseEntry->VolumeNameLength;
        otherTargetVolumeName.Buffer = (PWSTR) ((PCHAR) databaseEntry +
                                       databaseEntry->VolumeNameOffset);

        if (RtlEqualUnicodeString(&targetVolume, &otherTargetVolumeName,
                                  TRUE)) {

            entryFound = TRUE;
            break;
        }

        offset += databaseEntry->EntryLength;
        ExFreePool(databaseEntry);
    }

    if (!entryFound) {
        CloseRemoteDatabase(h);
        return STATUS_INVALID_PARAMETER;
    }

    databaseEntry->RefCount--;
    if (databaseEntry->RefCount) {
        status = WriteRemoteDatabaseEntry(h, offset, databaseEntry);
    } else {
        status = DeleteRemoteDatabaseEntry(h, offset);
        if (!NT_SUCCESS(status)) {
            ExFreePool(databaseEntry);
            CloseRemoteDatabase(h);
            return status;
        }

        for (l = sourceDeviceInfo->ReplicatedUniqueIds.Flink;
             l != &sourceDeviceInfo->ReplicatedUniqueIds; l = l->Flink) {

            replUniqueId = CONTAINING_RECORD(l, REPLICATED_UNIQUE_ID,
                                             ListEntry);

            if (replUniqueId->UniqueId->UniqueIdLength ==
                databaseEntry->UniqueIdLength &&
                RtlCompareMemory(replUniqueId->UniqueId->UniqueId,
                                 (PCHAR) databaseEntry +
                                 databaseEntry->UniqueIdOffset,
                                 databaseEntry->UniqueIdLength) ==
                                 databaseEntry->UniqueIdLength) {

                break;
            }
        }

        if (l == &sourceDeviceInfo->ReplicatedUniqueIds) {
            ExFreePool(databaseEntry);
            CloseRemoteDatabase(h);
            return STATUS_UNSUCCESSFUL;
        }

        RemoveEntryList(l);
        ExFreePool(replUniqueId->UniqueId);
        ExFreePool(replUniqueId);
    }

    ExFreePool(databaseEntry);
    CloseRemoteDatabase(h);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    for (l = targetDeviceInfo->MountPointsPointingHere.Flink;
         l != &targetDeviceInfo->MountPointsPointingHere; l = l->Flink) {

        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        if (mountPointEntry->DeviceInfo == sourceDeviceInfo &&
            RtlEqualUnicodeString(&mountPointEntry->MountPath,
                                  &mountPath, TRUE)) {

            RemoveEntryList(l);
            ExFreePool(mountPointEntry->MountPath.Buffer);
            ExFreePool(mountPointEntry);
            break;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrKeepLinksWhenOffline(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets up the internal data structure to remember to keep
    the symbolic links for the given device even when the device goes offline.
    Then when the device becomes on-line again, it is guaranteed that these
    links will be available and not taken by some other device.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME       input = Irp->AssociatedIrp.SystemBuffer;
    ULONG                       size;
    UNICODE_STRING              deviceName;
    NTSTATUS                    status;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    size = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
           input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < size) {
        return STATUS_INVALID_PARAMETER;
    }

    deviceName.Length = deviceName.MaximumLength = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = FindDeviceInfo(Extension, &deviceName, FALSE, &deviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    deviceInfo->KeepLinksWhenOffline = TRUE;

    return STATUS_SUCCESS;
}

VOID
ReconcileAllDatabasesWithMaster(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine goes through all of the devices known to the MOUNTMGR and
    reconciles their database with the master database.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        if (deviceInfo->IsRemovable) {
            continue;
        }

        ReconcileThisDatabaseWithMaster(Extension, deviceInfo);
    }
}

NTSTATUS
MountMgrCheckUnprocessedVolumes(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets up the internal data structure to remember to keep
    the symbolic links for the given device even when the device goes offline.
    Then when the device becomes on-line again, it is guaranteed that these
    links will be available and not taken by some other device.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status = STATUS_SUCCESS;
    LIST_ENTRY                  q;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    NTSTATUS                    status2;

    if (IsListEmpty(&Extension->DeadMountedDeviceList)) {
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    q = Extension->DeadMountedDeviceList;
    InitializeListHead(&Extension->DeadMountedDeviceList);

    KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    q.Blink->Flink = &q;
    q.Flink->Blink = &q;

    while (!IsListEmpty(&q)) {

        l = RemoveHeadList(&q);

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);

        status2 = MountMgrMountedDeviceArrival(Extension,
                                               &deviceInfo->NotificationName,
                                               deviceInfo->NotAPdo);
        MountMgrFreeDeadDeviceInfo (deviceInfo);

        if (NT_SUCCESS(status)) {
            status = status2;
        }
    }

    return status;
}

NTSTATUS
MountMgrVolumeArrivalNotification(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine performs the same actions as though PNP had notified
    the mount manager of a new volume arrival.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME       input = Irp->AssociatedIrp.SystemBuffer;
    ULONG                       size;
    UNICODE_STRING              deviceName;
    BOOLEAN                     oldHardErrorMode;
    NTSTATUS                    status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    size = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
           input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < size) {
        return STATUS_INVALID_PARAMETER;
    }

    deviceName.Length = deviceName.MaximumLength = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    oldHardErrorMode = PsGetThreadHardErrorsAreDisabled(PsGetCurrentThread());
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),TRUE);

    status = MountMgrMountedDeviceArrival(Extension, &deviceName, TRUE);

    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(),oldHardErrorMode);

    return status;
}

NTSTATUS
MountMgrQuerySystemVolumeNameQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the system volume name.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PUNICODE_STRING systemVolumeName = Context;
    UNICODE_STRING  string;

    if (ValueType != REG_SZ) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, ValueData);

    systemVolumeName->Length = string.Length;
    systemVolumeName->MaximumLength = systemVolumeName->Length + sizeof(WCHAR);
    systemVolumeName->Buffer = ExAllocatePool(PagedPool,
                                              systemVolumeName->MaximumLength);
    if (!systemVolumeName->Buffer) {
        return STATUS_SUCCESS;
    }

    RtlCopyMemory(systemVolumeName->Buffer, ValueData,
                  systemVolumeName->Length);
    systemVolumeName->Buffer[systemVolumeName->Length/sizeof(WCHAR)] = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQuerySystemVolumeName(
    OUT PUNICODE_STRING SystemVolumeName
    )

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = MountMgrQuerySystemVolumeNameQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"SystemPartition";

    SystemVolumeName->Buffer = NULL;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\Setup",
                           queryTable, SystemVolumeName, NULL);

    if (!SystemVolumeName->Buffer) {
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

VOID
MountMgrAssignDriveLetters(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine is invoked after IoAssignDriveLetters has run.  It goes
    through all of the mounted devices and checks to see whether or not they
    need to get a drive letter.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    NTSTATUS                            status;
    UNICODE_STRING                      systemVolumeName;
    PLIST_ENTRY                         l;
    PMOUNTED_DEVICE_INFORMATION         deviceInfo;
    MOUNTMGR_DRIVE_LETTER_INFORMATION   driveLetterInfo;

    status = MountMgrQuerySystemVolumeName(&systemVolumeName);

    for (l = Extension->MountedDeviceList.Flink;
         l != &Extension->MountedDeviceList; l = l->Flink) {

        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION,
                                       ListEntry);
        if (!deviceInfo->NextDriveLetterCalled) {
            MountMgrNextDriveLetterWorker(Extension, &deviceInfo->DeviceName,
                                          &driveLetterInfo);
        }
        if (NT_SUCCESS(status) &&
            RtlEqualUnicodeString(&systemVolumeName, &deviceInfo->DeviceName,
                                  TRUE)) {

            Extension->SystemPartitionUniqueId =
                    ExAllocatePool(PagedPool, sizeof(MOUNTDEV_UNIQUE_ID) +
                    deviceInfo->UniqueId->UniqueIdLength);
            if (Extension->SystemPartitionUniqueId) {
                Extension->SystemPartitionUniqueId->UniqueIdLength =
                        deviceInfo->UniqueId->UniqueIdLength;
                RtlCopyMemory(Extension->SystemPartitionUniqueId->UniqueId,
                              deviceInfo->UniqueId->UniqueId,
                              deviceInfo->UniqueId->UniqueIdLength);
            }
        }
    }
}

NTSTATUS
MountMgrValidateBackPointer(
    IN  PMOUNTMGR_MOUNT_POINT_ENTRY MountPointEntry,
    IN  PMOUNTED_DEVICE_INFORMATION DeviceInfo,
    OUT PBOOLEAN                    InvalidBackPointer
    )

{
    UNICODE_STRING              reparseName, volumeName;
    OBJECT_ATTRIBUTES           oa;
    NTSTATUS                    status;
    HANDLE                      h;
    IO_STATUS_BLOCK             ioStatus;
    PREPARSE_DATA_BUFFER        reparse;
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;

    reparseName.Length = MountPointEntry->DeviceInfo->DeviceName.Length +
                         sizeof(WCHAR) + MountPointEntry->MountPath.Length;
    reparseName.MaximumLength = reparseName.Length + sizeof(WCHAR);
    reparseName.Buffer = ExAllocatePool(PagedPool, reparseName.MaximumLength);
    if (!reparseName.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(reparseName.Buffer,
                  MountPointEntry->DeviceInfo->DeviceName.Buffer,
                  MountPointEntry->DeviceInfo->DeviceName.Length);
    reparseName.Length = MountPointEntry->DeviceInfo->DeviceName.Length;
    reparseName.Buffer[reparseName.Length/sizeof(WCHAR)] = '\\';
    reparseName.Length += sizeof(WCHAR);
    RtlCopyMemory((PCHAR) reparseName.Buffer + reparseName.Length,
                  MountPointEntry->MountPath.Buffer,
                  MountPointEntry->MountPath.Length);
    reparseName.Length += MountPointEntry->MountPath.Length;
    reparseName.Buffer[reparseName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &reparseName, OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwOpenFile(&h, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_REPARSE_POINT);
    ExFreePool(reparseName.Buffer);
    if (!NT_SUCCESS(status)) {
        *InvalidBackPointer = TRUE;
        return STATUS_SUCCESS;
    }

    reparse = ExAllocatePool(PagedPool, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        ZwClose(h);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                             FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                             MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    ZwClose(h);
    if (!NT_SUCCESS(status)) {
        *InvalidBackPointer = TRUE;
        ExFreePool(reparse);
        return STATUS_SUCCESS;
    }

    volumeName.MaximumLength = volumeName.Length =
            reparse->MountPointReparseBuffer.SubstituteNameLength;
    volumeName.Buffer = (PWCHAR)
                        ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                        reparse->MountPointReparseBuffer.SubstituteNameOffset);
    if (!MOUNTMGR_IS_NT_VOLUME_NAME_WB(&volumeName)) {
        ExFreePool(reparse);
        *InvalidBackPointer = TRUE;
        return STATUS_SUCCESS;
    }

    volumeName.Length -= sizeof(WCHAR);

    for (l = DeviceInfo->SymbolicLinkNames.Flink;
         l != &DeviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);

        if (RtlEqualUnicodeString(&volumeName, &symlinkEntry->SymbolicLinkName,
                                  TRUE)) {

            ExFreePool(reparse);
            return STATUS_SUCCESS;
        }
    }

    ExFreePool(reparse);
    *InvalidBackPointer = TRUE;
    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryVolumePaths(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PMOUNTED_DEVICE_INFORMATION     DeviceInfo,
    IN  PLIST_ENTRY                     DeviceInfoList,
    OUT PMOUNTMGR_VOLUME_PATHS*         VolumePaths,
    OUT PMOUNTED_DEVICE_INFORMATION*    ReconcileThisDeviceInfo
    )

{
    PLIST_ENTRY                 l;
    PMOUNTMGR_DEVICE_ENTRY      entry;
    ULONG                       MultiSzLength;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    ULONG                       numPoints, i, j, k;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;
    PMOUNTMGR_VOLUME_PATHS*     childVolumePaths;
    NTSTATUS                    status;
    PMOUNTMGR_VOLUME_PATHS      volumePaths;
    LIST_ENTRY                  deviceInfoList;
    BOOLEAN                     invalidBackPointer;

    MultiSzLength = sizeof(WCHAR);

    for (l = DeviceInfo->SymbolicLinkNames.Flink;
         l != &DeviceInfo->SymbolicLinkNames; l = l->Flink) {

        symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                         ListEntry);
        if (MOUNTMGR_IS_DRIVE_LETTER(&symlinkEntry->SymbolicLinkName) &&
            symlinkEntry->IsInDatabase) {

            MultiSzLength += 3*sizeof(WCHAR);
            break;
        }
    }

    if (l == &DeviceInfo->SymbolicLinkNames) {
        symlinkEntry = NULL;
    }

    for (l = DeviceInfoList->Flink; l != DeviceInfoList; l = l->Flink) {

        entry = CONTAINING_RECORD(l, MOUNTMGR_DEVICE_ENTRY, ListEntry);

        if (entry->DeviceInfo == DeviceInfo) {
            volumePaths = ExAllocatePool(PagedPool,
                          FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                          MultiSzLength);
            if (!volumePaths) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            volumePaths->MultiSzLength = MultiSzLength;
            if (symlinkEntry) {
                volumePaths->MultiSz[0] =
                        symlinkEntry->SymbolicLinkName.Buffer[12];
                volumePaths->MultiSz[1] = ':';
                volumePaths->MultiSz[2] = 0;
                volumePaths->MultiSz[3] = 0;
            } else {
                volumePaths->MultiSz[0] = 0;
            }

            *VolumePaths = volumePaths;

            return STATUS_SUCCESS;
        }
    }

    entry = ExAllocatePool(PagedPool, sizeof(MOUNTMGR_DEVICE_ENTRY));
    if (!entry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    entry->DeviceInfo = DeviceInfo;
    InsertTailList(DeviceInfoList, &entry->ListEntry);

    numPoints = 0;
    for (l = DeviceInfo->MountPointsPointingHere.Flink;
         l != &DeviceInfo->MountPointsPointingHere; l = l->Flink) {

        numPoints++;
    }

    if (numPoints) {
        childVolumePaths = ExAllocatePool(PagedPool,
                                          numPoints*sizeof(PMOUNTMGR_VOLUME_PATHS));
        if (!childVolumePaths) {
            RemoveEntryList(&entry->ListEntry);
            ExFreePool(entry);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        childVolumePaths = NULL;
    }

    i = 0;
    for (l = DeviceInfo->MountPointsPointingHere.Flink;
         l != &DeviceInfo->MountPointsPointingHere; l = l->Flink, i++) {

        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        invalidBackPointer = FALSE;
        status = MountMgrValidateBackPointer(mountPointEntry, DeviceInfo,
                                             &invalidBackPointer);
        if (invalidBackPointer) {
            *ReconcileThisDeviceInfo = mountPointEntry->DeviceInfo;
            status = STATUS_UNSUCCESSFUL;
        }

        if (!NT_SUCCESS(status)) {
            for (j = 0; j < i; j++) {
                ExFreePool(childVolumePaths[j]);
            }
            ExFreePool(childVolumePaths);
            RemoveEntryList(&entry->ListEntry);
            ExFreePool(entry);
            return status;
        }

        status = MountMgrQueryVolumePaths(Extension,
                                          mountPointEntry->DeviceInfo,
                                          DeviceInfoList,
                                          &childVolumePaths[i],
                                          ReconcileThisDeviceInfo);
        if (!NT_SUCCESS(status)) {
            for (j = 0; j < i; j++) {
                ExFreePool(childVolumePaths[j]);
            }
            ExFreePool(childVolumePaths);
            RemoveEntryList(&entry->ListEntry);
            ExFreePool(entry);
            return status;
        }

        k = 0;
        for (j = 0; j < childVolumePaths[i]->MultiSzLength/sizeof(WCHAR) - 1;
             j++) {

            if (!childVolumePaths[i]->MultiSz[j]) {
                k++;
            }
        }

        MultiSzLength += k*mountPointEntry->MountPath.Length +
                         childVolumePaths[i]->MultiSzLength - sizeof(WCHAR);
    }

    volumePaths = ExAllocatePool(PagedPool,
                  FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                  MultiSzLength);
    if (!volumePaths) {
        for (i = 0; i < numPoints; i++) {
            ExFreePool(childVolumePaths[i]);
        }
        if (childVolumePaths) {
            ExFreePool(childVolumePaths);
        }
        RemoveEntryList(&entry->ListEntry);
        ExFreePool(entry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    volumePaths->MultiSzLength = MultiSzLength;

    j = 0;
    if (symlinkEntry) {
        volumePaths->MultiSz[j++] = symlinkEntry->SymbolicLinkName.Buffer[12];
        volumePaths->MultiSz[j++] = ':';
        volumePaths->MultiSz[j++] = 0;
    }

    i = 0;
    for (l = DeviceInfo->MountPointsPointingHere.Flink;
         l != &DeviceInfo->MountPointsPointingHere; l = l->Flink, i++) {

        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        for (k = 0; k < childVolumePaths[i]->MultiSzLength/sizeof(WCHAR) - 1;
             k++) {

            if (childVolumePaths[i]->MultiSz[k]) {
                volumePaths->MultiSz[j++] = childVolumePaths[i]->MultiSz[k];
            } else {
                RtlCopyMemory(&volumePaths->MultiSz[j],
                              mountPointEntry->MountPath.Buffer,
                              mountPointEntry->MountPath.Length);
                j += mountPointEntry->MountPath.Length/sizeof(WCHAR);
                volumePaths->MultiSz[j++] = 0;
            }
        }

        ExFreePool(childVolumePaths[i]);
    }
    volumePaths->MultiSz[j] = 0;

    if (childVolumePaths) {
        ExFreePool(childVolumePaths);
    }

    RemoveEntryList(&entry->ListEntry);
    ExFreePool(entry);

    *VolumePaths = volumePaths;

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryDosVolumePaths(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME           input = (PMOUNTMGR_TARGET_NAME) Irp->AssociatedIrp.SystemBuffer;
    PMOUNTMGR_VOLUME_PATHS          output = (PMOUNTMGR_VOLUME_PATHS) Irp->AssociatedIrp.SystemBuffer;
    ULONG                           len, i;
    UNICODE_STRING                  deviceName;
    NTSTATUS                        status;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo, reconcileThisDeviceInfo, d;
    PMOUNTMGR_VOLUME_PATHS          volumePaths;
    LIST_ENTRY                      deviceInfoList;
    RECONCILE_WORK_ITEM_INFO        workItemInfo;
    PLIST_ENTRY                     l;
    BOOLEAN                         assertNameChange;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->DeviceNameLength&1) {
        return STATUS_INVALID_PARAMETER;
    }

    len = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
          input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < len) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz)) {

        return STATUS_INVALID_PARAMETER;
    }

    deviceName.MaximumLength = deviceName.Length = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = FindDeviceInfo(Extension, &deviceName, FALSE, &deviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    assertNameChange = FALSE;
    for (i = 0; i < 1000; i++) {
        InitializeListHead(&deviceInfoList);
        reconcileThisDeviceInfo = NULL;
        status = MountMgrQueryVolumePaths(Extension, deviceInfo,
                                          &deviceInfoList, &volumePaths,
                                          &reconcileThisDeviceInfo);
        if (NT_SUCCESS(status)) {
            break;
        }

        if (!reconcileThisDeviceInfo) {
            return status;
        }

        if (!deviceInfo->NotAPdo) {
            assertNameChange = TRUE;
        }

        workItemInfo.Extension = Extension;
        workItemInfo.DeviceInfo = reconcileThisDeviceInfo;
        KeReleaseSemaphore(&Extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        ReconcileThisDatabaseWithMasterWorker(&workItemInfo);

        KeWaitForSingleObject(&Extension->Mutex, Executive, KernelMode,
                              FALSE, NULL);

        for (l = Extension->MountedDeviceList.Flink;
             l != &Extension->MountedDeviceList; l = l->Flink) {

            d = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);
            if (d == deviceInfo) {
                break;
            }
        }

        if (l == &Extension->MountedDeviceList) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (assertNameChange) {
        MountMgrNotifyNameChange(Extension, &deviceName, FALSE);
    }

    output->MultiSzLength = volumePaths->MultiSzLength;
    Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                                output->MultiSzLength;

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        ExFreePool(volumePaths);
        Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS,
                                                 MultiSz);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->MultiSz, volumePaths->MultiSz,
                  output->MultiSzLength);

    ExFreePool(volumePaths);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrQueryDosVolumePath(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_TARGET_NAME       input = (PMOUNTMGR_TARGET_NAME) Irp->AssociatedIrp.SystemBuffer;
    PMOUNTMGR_VOLUME_PATHS      output = (PMOUNTMGR_VOLUME_PATHS) Irp->AssociatedIrp.SystemBuffer;
    ULONG                       len, i;
    UNICODE_STRING              deviceName;
    NTSTATUS                    status;
    PMOUNTED_DEVICE_INFORMATION deviceInfo, origDeviceInfo;
    PLIST_ENTRY                 l;
    PSYMBOLIC_LINK_NAME_ENTRY   symlinkEntry;
    UNICODE_STRING              path, oldPath;
    PMOUNTMGR_MOUNT_POINT_ENTRY mountPointEntry;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_TARGET_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->DeviceNameLength&1) {
        return STATUS_INVALID_PARAMETER;
    }

    len = FIELD_OFFSET(MOUNTMGR_TARGET_NAME, DeviceName) +
          input->DeviceNameLength;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < len) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz)) {

        return STATUS_INVALID_PARAMETER;
    }

    deviceName.MaximumLength = deviceName.Length = input->DeviceNameLength;
    deviceName.Buffer = input->DeviceName;

    status = FindDeviceInfo(Extension, &deviceName, FALSE, &deviceInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    origDeviceInfo = deviceInfo;

    path.Length = path.MaximumLength = 0;
    path.Buffer = NULL;

    for (i = 0; i < 1000; i++) {

        for (l = deviceInfo->SymbolicLinkNames.Flink;
             l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

            symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);
            if (MOUNTMGR_IS_DRIVE_LETTER(&symlinkEntry->SymbolicLinkName) &&
                symlinkEntry->IsInDatabase) {

                break;
            }
        }

        if (l != &deviceInfo->SymbolicLinkNames) {
            oldPath = path;
            path.Length += 2*sizeof(WCHAR);
            path.MaximumLength = path.Length;
            path.Buffer = ExAllocatePool(PagedPool, path.MaximumLength);
            if (!path.Buffer) {
                if (oldPath.Buffer) {
                    ExFreePool(oldPath.Buffer);
                }
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            path.Buffer[0] = symlinkEntry->SymbolicLinkName.Buffer[12];
            path.Buffer[1] = ':';

            if (oldPath.Buffer) {
                RtlCopyMemory(&path.Buffer[2], oldPath.Buffer, oldPath.Length);
                ExFreePool(oldPath.Buffer);
            }
            break;
        }

        if (IsListEmpty(&deviceInfo->MountPointsPointingHere)) {
            break;
        }

        l = deviceInfo->MountPointsPointingHere.Flink;
        mountPointEntry = CONTAINING_RECORD(l, MOUNTMGR_MOUNT_POINT_ENTRY,
                                            ListEntry);

        oldPath = path;
        path.Length += mountPointEntry->MountPath.Length;
        path.MaximumLength = path.Length;
        path.Buffer = ExAllocatePool(PagedPool, path.MaximumLength);
        if (!path.Buffer) {
            if (oldPath.Buffer) {
                ExFreePool(oldPath.Buffer);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(path.Buffer, mountPointEntry->MountPath.Buffer,
                      mountPointEntry->MountPath.Length);

        if (oldPath.Buffer) {
            RtlCopyMemory(
                &path.Buffer[mountPointEntry->MountPath.Length/sizeof(WCHAR)],
                oldPath.Buffer, oldPath.Length);
            ExFreePool(oldPath.Buffer);
        }

        deviceInfo = mountPointEntry->DeviceInfo;
    }

    if (path.Length < 2*sizeof(WCHAR) || path.Buffer[1] != ':') {

        if (path.Buffer) {
            ExFreePool(path.Buffer);
        }

        deviceInfo = origDeviceInfo;

        for (l = deviceInfo->SymbolicLinkNames.Flink;
             l != &deviceInfo->SymbolicLinkNames; l = l->Flink) {

            symlinkEntry = CONTAINING_RECORD(l, SYMBOLIC_LINK_NAME_ENTRY,
                                             ListEntry);
            if (MOUNTMGR_IS_VOLUME_NAME(&symlinkEntry->SymbolicLinkName)) {
                break;
            }
        }

        if (l != &deviceInfo->SymbolicLinkNames) {
            path.Length = path.MaximumLength =
                    symlinkEntry->SymbolicLinkName.Length;
            path.Buffer = ExAllocatePool(PagedPool, path.MaximumLength);
            if (!path.Buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory(path.Buffer, symlinkEntry->SymbolicLinkName.Buffer,
                          path.Length);
            path.Buffer[1] = '\\';
        }
    }

    output->MultiSzLength = path.Length + 2*sizeof(WCHAR);
    Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS, MultiSz) +
                                output->MultiSzLength;
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        ExFreePool(path.Buffer);
        Irp->IoStatus.Information = FIELD_OFFSET(MOUNTMGR_VOLUME_PATHS,
                                                 MultiSz);
        return STATUS_BUFFER_OVERFLOW;
    }

    if (path.Length) {
        RtlCopyMemory(output->MultiSz, path.Buffer, path.Length);
    }

    if (path.Buffer) {
        ExFreePool(path.Buffer);
    }

    output->MultiSz[path.Length/sizeof(WCHAR)] = 0;
    output->MultiSz[path.Length/sizeof(WCHAR) + 1] = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a device io control request.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                        status, status2;
    PMOUNTED_DEVICE_INFORMATION     deviceInfo;

    Irp->IoStatus.Information = 0;

    KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode, FALSE,
                          NULL);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_MOUNTMGR_CREATE_POINT:
            status = MountMgrCreatePoint(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_QUERY_POINTS_ADMIN:
        case IOCTL_MOUNTMGR_QUERY_POINTS:
            status = MountMgrQueryPoints(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_DELETE_POINTS:
            status = MountMgrDeletePoints(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY:
            status = MountMgrDeletePointsDbOnly(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER:
            status = MountMgrNextDriveLetter(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS:
            extension->AutomaticDriveLetterAssignment = TRUE;
            MountMgrAssignDriveLetters(extension);
            ReconcileAllDatabasesWithMaster(extension);
            status = STATUS_SUCCESS;
            break;

        case IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED:
            KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            status2 = WaitForRemoteDatabaseSemaphore(extension);
            KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);
            status = MountMgrVolumeMountPointCreated(extension, Irp, status2);
            if (NT_SUCCESS(status2)) {
                ReleaseRemoteDatabaseSemaphore(extension);
            }
            break;

        case IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED:
            KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            status2 = WaitForRemoteDatabaseSemaphore(extension);
            KeWaitForSingleObject(&extension->Mutex, Executive, KernelMode,
                                  FALSE, NULL);
            status = MountMgrVolumeMountPointDeleted(extension, Irp, status2);
            if (NT_SUCCESS(status2)) {
                ReleaseRemoteDatabaseSemaphore(extension);
            }
            break;

        case IOCTL_MOUNTMGR_CHANGE_NOTIFY:
            status = MountMgrChangeNotify(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE:
            status = MountMgrKeepLinksWhenOffline(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES:
            status = MountMgrCheckUnprocessedVolumes(extension, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION:
            KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);
            status = MountMgrVolumeArrivalNotification(extension, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH:
            status = MountMgrQueryDosVolumePath(extension, Irp);
            break;

        case IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS:
            status = MountMgrQueryDosVolumePaths(extension, Irp);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

VOID
WorkerThread(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PVOID          Extension
    )

/*++

Routine Description:

    This is a worker thread to process work queue items.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION    extension = Extension;
    UNICODE_STRING       volumeSafeEventName;
    OBJECT_ATTRIBUTES    oa;
    KEVENT               event;
    LARGE_INTEGER        timeout;
    ULONG                i;
    NTSTATUS             status;
    HANDLE               volumeSafeEvent;
    KIRQL                irql;
    PLIST_ENTRY          l;
    PRECONCILE_WORK_ITEM queueItem;

    RtlInitUnicodeString(&volumeSafeEventName,
                         L"\\Device\\VolumesSafeForWriteAccess");
    InitializeObjectAttributes(&oa, &volumeSafeEventName,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    timeout.QuadPart = -10*1000*1000;   // 1 second

    for (i = 0; i < 1000; i++) {
        if (Unloading) {
            i = 999;
            continue;
        }

        status = ZwOpenEvent(&volumeSafeEvent, EVENT_ALL_ACCESS, &oa);
        if (NT_SUCCESS(status)) {
            break;
        }
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &timeout);
    }

    if (i < 1000) {
        for (;;) {
            status = ZwWaitForSingleObject(volumeSafeEvent, FALSE, &timeout);
            if (status != STATUS_TIMEOUT || Unloading) {
                break;
            }
        }
        ZwClose(volumeSafeEvent);
    }

    for (;;) {

        KeWaitForSingleObject(&extension->WorkerSemaphore,
                              Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&extension->WorkerSpinLock, &irql);
        if (IsListEmpty(&extension->WorkerQueue)) {
            KeReleaseSpinLock(&extension->WorkerSpinLock, irql);
            InterlockedDecrement(&extension->WorkerRefCount);
            KeSetEvent(&UnloadEvent, 0, FALSE);
            break;
        }
        l = RemoveHeadList(&extension->WorkerQueue);
        KeReleaseSpinLock(&extension->WorkerSpinLock, irql);

        queueItem = CONTAINING_RECORD(l, RECONCILE_WORK_ITEM, List);
        queueItem->WorkerRoutine(queueItem->Parameter);
        IoFreeWorkItem(queueItem->WorkItem);
        ExFreePool(queueItem);
        if (InterlockedDecrement(&extension->WorkerRefCount) < 0) {
            break;
        }
    }
}

NTSTATUS
QueueWorkItem(
    IN  PDEVICE_EXTENSION    Extension,
    IN  PRECONCILE_WORK_ITEM WorkItem,
    IN  PVOID                Parameter
    )

/*++

Routine Description:

    This routine queues the given work item to the worker thread and if
    necessary starts the worker thread.

Arguments:

    Extension   - Supplies the device extension.

    WorkItem    - Supplies the work item to be queued.

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    KIRQL               irql;

    WorkItem->Parameter = Parameter;
    if (!InterlockedIncrement(&Extension->WorkerRefCount)) {
        IoQueueWorkItem(WorkItem->WorkItem, WorkerThread, DelayedWorkQueue,
                        Extension);
    }

    KeAcquireSpinLock(&Extension->WorkerSpinLock, &irql);
    InsertTailList(&Extension->WorkerQueue, &WorkItem->List);
    KeReleaseSpinLock(&Extension->WorkerSpinLock, irql);

    KeReleaseSemaphore(&Extension->WorkerSemaphore, 0, 1, FALSE);

    return STATUS_SUCCESS;
}

VOID
MountMgrNotify(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine completes all of the change notify irps in the queue.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    LIST_ENTRY                      q;
    KIRQL                           irql;
    PLIST_ENTRY                     p;
    PIRP                            irp;
    PMOUNTMGR_CHANGE_NOTIFY_INFO    output;

    Extension->EpicNumber++;

    InitializeListHead(&q);
    IoAcquireCancelSpinLock(&irql);
    while (!IsListEmpty(&Extension->ChangeNotifyIrps)) {
        p = RemoveHeadList(&Extension->ChangeNotifyIrps);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        IoSetCancelRoutine(irp, NULL);
        InsertTailList(&q, p);
    }
    IoReleaseCancelSpinLock(irql);

    while (!IsListEmpty(&q)) {
        p = RemoveHeadList(&q);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        output = irp->AssociatedIrp.SystemBuffer;
        output->EpicNumber = Extension->EpicNumber;
        irp->IoStatus.Information = sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

VOID
MountMgrCancel(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called on when the given IRP is cancelled.  It
    will dequeue this IRP off the work queue and complete the
    request as CANCELLED.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IRP.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
MountMgrChangeNotify(
    IN OUT  PDEVICE_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns when the current Epic number is different than
    the one given.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTMGR_CHANGE_NOTIFY_INFO    input;
    KIRQL                           irql;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = Irp->AssociatedIrp.SystemBuffer;
    if (input->EpicNumber != Extension->EpicNumber) {
        input->EpicNumber = Extension->EpicNumber;
        Irp->IoStatus.Information = sizeof(MOUNTMGR_CHANGE_NOTIFY_INFO);
        return STATUS_SUCCESS;
    }

    IoAcquireCancelSpinLock(&irql);
    if (Irp->Cancel) {
        IoReleaseCancelSpinLock(irql);
        return STATUS_CANCELLED;
    }

    InsertTailList(&Extension->ChangeNotifyIrps, &Irp->Tail.Overlay.ListEntry);
    IoMarkIrpPending(Irp);
    IoSetCancelRoutine(Irp, MountMgrCancel);
    IoReleaseCancelSpinLock(irql);

    return STATUS_PENDING;
}

NTSTATUS
UniqueIdChangeNotifyCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           WorkItem
    )

/*++

Routine Description:

    Completion routine for a change notify.

Arguments:

    DeviceObject    - Not used.

    Irp             - Supplies the IRP.

    Extension       - Supplies the work item.


Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PCHANGE_NOTIFY_WORK_ITEM    workItem = WorkItem;

    IoQueueWorkItem(workItem->WorkItem, UniqueIdChangeNotifyWorker, DelayedWorkQueue, workItem);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
MountMgrCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine cancels all of the IRPs currently queued on
    the given device.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the cleanup IRP.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PDEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT        file = irpSp->FileObject;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;

    IoAcquireCancelSpinLock(&irql);

    for (;;) {

        for (l = Extension->ChangeNotifyIrps.Flink;
             l != &Extension->ChangeNotifyIrps; l = l->Flink) {

            irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
            if (IoGetCurrentIrpStackLocation(irp)->FileObject == file) {
                break;
            }
        }

        if (l == &Extension->ChangeNotifyIrps) {
            break;
        }

        irp->Cancel = TRUE;
        irp->CancelIrql = irql;
        irp->CancelRoutine = NULL;
        MountMgrCancel(DeviceObject, irp);

        IoAcquireCancelSpinLock(&irql);
    }

    IoReleaseCancelSpinLock(irql);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
MountMgrShutdown(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

{
    PDEVICE_EXTENSION   extension = DeviceObject->DeviceExtension;

    InterlockedExchange(&Unloading, TRUE);
    KeInitializeEvent(&UnloadEvent, NotificationEvent, FALSE);
    if (InterlockedIncrement(&extension->WorkerRefCount) > 0) {
        KeReleaseSemaphore(&extension->WorkerSemaphore, 0, 1, FALSE);
        KeWaitForSingleObject(&UnloadEvent, Executive, KernelMode, FALSE,
                              NULL);
    } else {
        InterlockedDecrement(&extension->WorkerRefCount);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the entry point for the driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING      deviceName, symbolicLinkName;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   extension;

    RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, MOUNTED_DEVICES_KEY);

    RtlInitUnicodeString(&deviceName, MOUNTMGR_DEVICE_NAME);
    status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                            &deviceName, FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    DriverObject->DriverUnload = MountMgrUnload;

    extension = deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(DEVICE_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->DriverObject = DriverObject;
    InitializeListHead(&extension->MountedDeviceList);
    InitializeListHead(&extension->DeadMountedDeviceList);
    KeInitializeSemaphore(&extension->Mutex, 1, 1);
    KeInitializeSemaphore(&extension->RemoteDatabaseSemaphore, 1, 1);
    InitializeListHead(&extension->ChangeNotifyIrps);
    extension->EpicNumber = 1;
    InitializeListHead(&extension->SavedLinksList);
    InitializeListHead(&extension->WorkerQueue);
    KeInitializeSemaphore(&extension->WorkerSemaphore, 0, MAXLONG);
    extension->WorkerRefCount = -1;
    KeInitializeSpinLock(&extension->WorkerSpinLock);

    InitializeListHead(&extension->UniqueIdChangeNotifyList);

    RtlInitUnicodeString(&symbolicLinkName, SYMBOLIC_LINK_NAME);
    GlobalCreateSymbolicLink(&symbolicLinkName, &deviceName);

    status = IoRegisterPlugPlayNotification(
             EventCategoryDeviceInterfaceChange,
             PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
             (PVOID) &MOUNTDEV_MOUNTED_DEVICE_GUID, DriverObject,
             MountMgrMountedDeviceNotification, extension,
             &extension->NotificationEntry);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice (deviceObject);
        return status;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = MountMgrCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = MountMgrCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MountMgrDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = MountMgrCleanup;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = MountMgrShutdown;
    gdeviceObject = deviceObject;

    status = IoRegisterShutdownNotification(gdeviceObject);
    if (!NT_SUCCESS(status)) {
        IoDeleteDevice (deviceObject);
        return status;
    }

    return STATUS_SUCCESS;
}

VOID
MountMgrUnload(
    PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Driver unload routine.

Arguments:

    DeviceObject    - Supplies the driver object.

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION           extension;
    UNICODE_STRING              symbolicLinkName;
    PLIST_ENTRY                 l;
    PMOUNTED_DEVICE_INFORMATION deviceInfo;
    PSAVED_LINKS_INFORMATION    savedLinks;
    PCHANGE_NOTIFY_WORK_ITEM    WorkItem;

    IoUnregisterShutdownNotification(gdeviceObject);

    extension = gdeviceObject->DeviceExtension;

    //
    // See if the worker is active
    //
    InterlockedExchange(&Unloading, TRUE);
    KeInitializeEvent (&UnloadEvent, NotificationEvent, FALSE);
    if (InterlockedIncrement(&extension->WorkerRefCount) > 0) {
        KeReleaseSemaphore(&extension->WorkerSemaphore, 0, 1, FALSE);
        KeWaitForSingleObject(&UnloadEvent, Executive, KernelMode, FALSE,
                              NULL);
    } else {
        InterlockedDecrement(&extension->WorkerRefCount);
    }

    IoUnregisterPlugPlayNotification(extension->NotificationEntry);

    KeWaitForSingleObject(&extension->Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    while (!IsListEmpty (&extension->DeadMountedDeviceList)) {

        l = RemoveHeadList (&extension->DeadMountedDeviceList);
        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);

        MountMgrFreeDeadDeviceInfo (deviceInfo);
    }

    while (!IsListEmpty (&extension->MountedDeviceList)) {

        l = RemoveHeadList (&extension->MountedDeviceList);
        deviceInfo = CONTAINING_RECORD(l, MOUNTED_DEVICE_INFORMATION, ListEntry);

        MountMgrFreeMountedDeviceInfo (deviceInfo);
    }

    while (!IsListEmpty (&extension->SavedLinksList)) {

        l = RemoveHeadList (&extension->SavedLinksList);
        savedLinks = CONTAINING_RECORD(l, SAVED_LINKS_INFORMATION, ListEntry);

        MountMgrFreeSavedLink (savedLinks);
    }

    while (!IsListEmpty (&extension->UniqueIdChangeNotifyList)) {
        l = RemoveHeadList (&extension->UniqueIdChangeNotifyList);
        WorkItem = CONTAINING_RECORD(l, CHANGE_NOTIFY_WORK_ITEM, List);
        KeResetEvent (&UnloadEvent);

        InterlockedExchangePointer (&WorkItem->Event, &UnloadEvent);
        KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);

        IoCancelIrp (WorkItem->Irp);

        KeWaitForSingleObject (&UnloadEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        IoFreeIrp(WorkItem->Irp);
        ExFreePool(WorkItem->DeviceName.Buffer);
        ExFreePool(WorkItem->SystemBuffer);
        ExFreePool(WorkItem);
        KeWaitForSingleObject(&extension->Mutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    if (extension->SystemPartitionUniqueId) {
        ExFreePool(extension->SystemPartitionUniqueId);
        extension->SystemPartitionUniqueId = NULL;
    }

    KeReleaseSemaphore(&extension->Mutex, IO_NO_INCREMENT, 1, FALSE);


    RtlInitUnicodeString(&symbolicLinkName, SYMBOLIC_LINK_NAME);
    GlobalDeleteSymbolicLink(&symbolicLinkName);

    IoDeleteDevice (gdeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\debug.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    debug.h
    
Abstract:

    Debug support definitions for the s/g dma driver

Author:

    Eric Nelson (enelson) 3/14/1999

Revision History:

--*/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG
extern  BOOLEAN SgDmaFake;

#define SG_DMA_DEBUG_BUFFER_SIZE 512
#define SgDmaDebugPrint SgDmaDebugPrintf
#else
#define SgDmaDebugPrint
#endif // DBG
      
typedef enum _SG_DMA_DEBUG_LEVEL {
    SgDmaDebugAlways=0,
    SgDmaDebugInit=1,
    SgDmaDebugDispatch=2,
    SgDmaDebugInterface=4,
    SgDmaDebugMapRegs=8,
    SgDmaDebugHw=0x10,
    SgDmaDebugBreak=0x20,
    SgDmaMaxDebug
} SG_DMA_DEBUG_LEVEL, *PSG_DMA_DEBUG_LEVEL;

extern SG_DMA_DEBUG_LEVEL SgDmaDebug;

VOID
SgDmaDebugPrintf(
    SG_DMA_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR             DebugMessage,
    ...
    );

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\hw.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    hw.h

Abstract:

    This module contains platform specific HW definitions

Author:

    Eric Nelson (enelson) July-13-1999

Environment:

    Kernel mode
    
Revision History:

--*/

#ifndef __HW_H__
#define __HW_H__

//
// Define the format of a translation entry aka a scatter/gather entry
// or map register
//
typedef union _TRANSLATION_ENTRY {
    struct {
        ULONGLONG Valid: 1;
        ULONGLONG Pfn: 22;
        ULONGLONG Reserved: 41;
    };
    ULONGLONG AsULONGLONG;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
// S/G DMA HW register control structure
//
typedef enum _SG_HR_REG_TYPE {
    TxBaseAddrRegVa,
    WindowBaseRegVa,
    WindowMaskRegVa,
    WindowTLBIARegVa,
    WindowTLBIVRegVa,
    SgDmaMaxHwReg
} SG_HR_REG_TYPE, *PSG_HR_REG_TYPE;

#define __1GB 0x40000000
#define __2GB 0x80000000

#define DMA_HW_ALIGN_REQ 8
#define DMA_HW_ALIGN(Bytes) ((Bytes) >> 10)
#define DMA_HW_REG_SIZE 8

#define TSUNAMI_MAX_HW_BUS_COUNT 2

#define TSUNAMI_PCHIP_0_TBA0_PHYS     0x80180000200
#define TSUNAMI_PCHIP_0_WSBA0_PHYS    0x80180000000
#define TSUNAMI_PCHIP_0_WSM0_PHYS     0x80180000100
#define TSUNAMI_PCHIP_0_TLBIA_PHYS    0x801800004C0
#define TSUNAMI_PCHIP_0_TLBIV_PHYS    0x80180000480

#define TSUNAMI_PCHIP_1_TBA0_PHYS     0x80380000200
#define TSUNAMI_PCHIP_1_WSBA0_PHYS    0x80380000000
#define TSUNAMI_PCHIP_1_WSM0_PHYS     0x80380000100
#define TSUNAMI_PCHIP_1_TLBIA_PHYS    0x803800004C0
#define TSUNAMI_PCHIP_1_TLBIV_PHYS    0x80380000480

//
//VOID
//FASTCALL
//SgDmaHwInvalidateTx(
//    PTRANSLATION_ENTRY TxEntry
//    )
///*++
//
//Routine Description:
//
//    This routine invalidates a s/g dma map register
//
//Arguments:
//
//    TxEntry - Map Register to invalidate
//
//Return Value:
//
//    None
//  
//--*/
//
#if DBG
#define SgDmaHwInvalidateTx(TxEntry) ((TxEntry)->Valid = 0)
#else
#define SgDmaHwInvalidateTx(TxEntry) ((TxEntry)->AsULONGLONG = 0)
#endif // DBG

//
//VOID
//FASTCALL
//SgDmaHwMakeValidTx(
//    IN OUT PTRANSLATION_ENTRY TxEntry,
//    IN PFN_NUMBER Pfn
//    )
///*++
//
//Routine Description:
//
//    This routine programs a s/g dma map register
//
//Arguments:
//
//    TxEntry - Map register to program
//
//    Pfn - The page to map
//
//Return Value:
//
//    None
//
//--*/
//
#define SgDmaHwMakeValidTx(TxEntry, Pfn) \
    ((TxEntry)->AsULONGLONG = ((Pfn) << 1) | 1)

struct _SG_MAP_ADAPTER;
typedef struct _SG_MAP_ADAPTER *PSG_MAP_ADAPTER;

NTSTATUS
SgDmaHwStart(
    IN ULONG HwBus,
    IN OUT PSG_MAP_ADAPTER SgMapAdapter
    );

VOID
SgDmaHwStop(
    IN OUT PSG_MAP_ADAPTER SgMapAdapter
    );

//
//VOID
//SgDmaHwTlbFlush(
//    IN PSG_MAP_ADAPTER SgMapAdapter
//    )
///*++
//
//Routine Description:
//
//    This routine flushes all cached translations in the s/g dma TLB
//
//Arguments:
//    
//    SgMapAdapter - This adapter contains the s/g dma HW register addresses
//                   for this bus, and its children
//
//Return Value:
//
//    None
//    
//--*/
//
#define SgDmaHwTlbFlush(SgMapAdapter) (*(PULONGLONG)(SgMapAdapter)->HwRegs[WindowTLBIARegVa] = 0)

//
//VOID
//FASTCALL
//SgDmaHwTlbInvalidate(
//    IN PSG_MAP_ADAPTER SgMapAdapter,
//    IN ULONG LogicalAddr
//    )
///*++
//
//Routine Description:
//
//    This routine invalidates any cached translations in the s/g dma TLB
//
//Arguments:
//    
//    SgMapAdapter - This adapter contains the s/g dma HW register addresses
//                   for this bus, and its children
//
//    LogicalAddr - PCI address of map register whose TLB entry we must
//                  invalidate
//
//Return Value:
//
//    None
//                  
//--*/
//
#define SgDmaHwTlbInvalidate(SgMapAdapter, LogicalAddr) (*(PULONGLONG)(SgMapAdapter)->HwRegs[WindowTLBIVRegVa] = (LogicalAddr) >> 12)

#endif // __HW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\null\nls.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    nls.c

Abstract:

    This module contains the code that implements the Synchronous NULL device
    driver.

Author:

    Darryl E. Havens (darrylh) 22-May-1989

Environment:

    Kernel mode

Notes:

    This device driver is built into the NT operating system.

Revision History:


--*/

#include "ntddk.h"
#include "string.h"

//
// Define driver entry routine.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// Define the local routines used by this driver module.
//

static
NTSTATUS
NlsDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

static
NTSTATUS
NlsQueryFileInformation(
    OUT PVOID Buffer,
    IN OUT PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    );

static
BOOLEAN
NlsRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

static
BOOLEAN
NlsWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID 
NlsUnload ( 
    IN PDRIVER_OBJECT DriverObject 
    );
 

//
// Global variables
//
PDEVICE_OBJECT gDeviceObject = NULL;

//
// Fast I/O dispatch block
//
FAST_IO_DISPATCH NlsFastIoDispatch =
{
    sizeof (FAST_IO_DISPATCH), // SizeOfFastIoDispatch
    NULL,                      // FastIoCheckIfPossible
    NlsRead,                   // FastIoRead
    NlsWrite,                  // FastIoWrite
    NULL,                      // FastIoQueryBasicInfo
    NULL,                      // FastIoQueryStandardInfo
    NULL,                      // FastIoLock
    NULL,                      // FastIoUnlockSingle
    NULL,                      // FastIoUnlockAll
    NULL,                      // FastIoUnlockAllByKey
    NULL                       // FastIoDeviceControl
};

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, NlsDispatch)
#pragma alloc_text(PAGE, NlsQueryFileInformation)
#pragma alloc_text(PAGE, NlsRead)
#pragma alloc_text(PAGE, NlsWrite)
#pragma alloc_text(PAGE, NlsUnload)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the synchronous NULL device driver.
    This routine creates the device object for the NullS device and performs
    all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();

    //
    // Mark the entire driver as pagable.
    //

    MmPageEntireDriver ((PVOID)DriverEntry);

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &nameString, L"\\Device\\Null" );
    status = IoCreateDevice( DriverObject,
                             0,
                             &nameString,
                             FILE_DEVICE_NULL,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &deviceObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    DriverObject->DriverUnload = NlsUnload;

#ifdef _PNP_POWER_
    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

    //
    // Setting the following flag changes the timing of how many I/O's per
    // second can be accomplished by going through the NULL device driver
    // from being simply getting in and out of the driver, to getting in and
    // out with the overhead of building an MDL, probing and locking buffers,
    // unlocking the pages, and deallocating the MDL.  This flag should only
    // be set for performance testing.
    //

//  deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the driver object with this device driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_READ]   = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE]  = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL] = NlsDispatch;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]  = NlsDispatch;

    //
    // Setup fast IO
    //
    DriverObject->FastIoDispatch = &NlsFastIoDispatch;
    //
    // Save device object for unload
    //
    gDeviceObject = deviceObject;

    return STATUS_SUCCESS;
}

static
NTSTATUS
NlsDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the synchronous NULL device
    driver.  It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID buffer;
    ULONG length;
    PFILE_OBJECT fileObject;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (irpSp->MajorFunction) {

        //
        // For both create/open and close operations, simply set the information
        // field of the I/O status block and complete the request.
        //

        case IRP_MJ_CREATE:
        case IRP_MJ_CLOSE:
            fileObject = irpSp->FileObject;
            if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
                fileObject->PrivateCacheMap = (PVOID) 1;
            }
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;
            break;

        //
        // For read operations, set the information field of the I/O status
        // block, set an end-of-file status, and complete the request.
        //

        case IRP_MJ_READ:
            Irp->IoStatus.Status = STATUS_END_OF_FILE;
            Irp->IoStatus.Information = 0;
            break;

        //
        // For write operations, set the information field of the I/O status
        // block to the number of bytes which were supposed to have been written
        // to the file and complete the request.
        //

        case IRP_MJ_WRITE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = irpSp->Parameters.Write.Length;
            break;

        case IRP_MJ_LOCK_CONTROL:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_QUERY_INFORMATION:
            buffer = Irp->AssociatedIrp.SystemBuffer;
            length = irpSp->Parameters.QueryFile.Length;
            Irp->IoStatus.Status = NlsQueryFileInformation( buffer,
                                                            &length,
                                                            irpSp->Parameters.QueryFile.FileInformationClass );
            Irp->IoStatus.Information = length;
            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );
    return status;
}

static
NTSTATUS
NlsQueryFileInformation(
    OUT PVOID Buffer,
    IN PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine queries information about the opened file and returns the
    information in the specified buffer provided that the buffer is large
    enough and the specified type of information about the file is supported
    by this device driver.

    Information about files supported by this driver are:

        o   FileStandardInformation

Arguments:

    Buffer - Supplies a pointer to the buffer in which to return the
        information.

    Length - Supplies the length of the buffer on input and the length of
        the data actually written on output.

    InformationClass - Supplies the information class that is being queried.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    PFILE_STANDARD_INFORMATION standardBuffer;

    PAGED_CODE();

    //
    // Switch on the type of information that the caller would like to query
    // about the file.
    //

    switch (InformationClass) {

        case FileStandardInformation:

            //
            // Return the standard information about the file.
            //

            standardBuffer = (PFILE_STANDARD_INFORMATION) Buffer;
            *Length = (ULONG) sizeof( FILE_STANDARD_INFORMATION );
            standardBuffer->NumberOfLinks = 1;
            standardBuffer->DeletePending = FALSE;
            standardBuffer->AllocationSize.LowPart = 0;
            standardBuffer->AllocationSize.HighPart = 0;
            standardBuffer->Directory = FALSE;
            standardBuffer->EndOfFile.LowPart = 0;
            standardBuffer->EndOfFile.HighPart = 0;
            break;

        default:

            //
            // An invalid (or unsupported) information class has been queried
            // for the file.  Return the appropriate status.
            //

            return STATUS_INVALID_INFO_CLASS;

    }

    return STATUS_SUCCESS;
}

static
BOOLEAN
NlsRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is the Fast I/O Read routine for the NULL device driver.  It simply
    indicates that the read path was successfully taken, but that the end of
    the file has been reached.

Arguments:

    FileObject - File object representing the open instance to this device.

    FileOffset - Offset from which to begin the read.

    Length - Length of the read to be performed.

    Wait - Indicates whether or not the caller can wait.

    LockKey - Specifies the key for any lock contention that may be encountered.

    Buffer - Address of the buffer in which to return the data read.

    IoStatus - Supplies the I/O status block into which the final status is to
        be returned.

Return Value:

    The function value is TRUE, meaning that the fast I/O path was taken.

--*/

{
    PAGED_CODE();

    //
    // Simply indicate that the read operation worked, but the end of the file
    // was encountered.
    //

    IoStatus->Status = STATUS_END_OF_FILE;
    IoStatus->Information = 0;
    return TRUE;
}

static
BOOLEAN
NlsWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is the Fast I/O Write routine for the NULL device driver.  It simply
    indicates that the write path was successfully taken, and that all of the
    data was written to the device.

Arguments:

    FileObject - File object representing the open instance to this device.

    FileOffset - Offset from which to begin the read.

    Length - Length of the write to be performed.

    Wait - Indicates whether or not the caller can wait.

    LockKey - Specifies the key for any lock contention that may be encountered.

    Buffer - Address of the buffer containing the data to be written.

    IoStatus - Supplies the I/O status block into which the final status is to
        be returned.

Return Value:

    The function value is TRUE, meaning that the fast I/O path was taken.

--*/

{
    PAGED_CODE();

    //
    // Simply return TRUE, indicating that the fast I/O path was taken, and
    // that the write operation worked.
    //

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = Length;
    return TRUE;
}

VOID 
NlsUnload ( 
    IN PDRIVER_OBJECT DriverObject 
    )
{
    UNICODE_STRING us;

    RtlInitUnicodeString (&us, L"\\??\\NUL"); // Created by SMSS
    IoDeleteSymbolicLink (&us);

    IoDeleteDevice (gDeviceObject);
    gDeviceObject = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\debug.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debug support for the s/g dma driver

Author:

    Eric Nelson (enelson) 3/14/1999

Revision History:

--*/

#include "sgdma.h"
#include "stdarg.h"
#include "stdio.h"

#if DBG
BOOLEAN SgDmaFake = FALSE;

SG_DMA_DEBUG_LEVEL SgDmaDebug = SgDmaDebugInit | SgDmaDebugDispatch |
                                SgDmaDebugHw;
static UCHAR       SgDmaDebugBuffer[SG_DMA_DEBUG_BUFFER_SIZE];
#endif // DBG

VOID
SgDmaDebugPrintf(
    SG_DMA_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR             DebugMessage,
    ...
    )
/*++

Routine Description:

    Print s/g dma debug output to the kernel debugger

Arguments:

    DebugPrintLevel - Specifies the debug print level

    DebugMessage    - Output message

Return Value:

    None

--*/
{
#if DBG
    va_list ap;

    va_start(ap, DebugMessage);

    if ((DebugPrintLevel == 0) || (DebugPrintLevel & SgDmaDebug)) {
        _vsnprintf(SgDmaDebugBuffer,
                   sizeof(SgDmaDebugBuffer), DebugMessage, ap);
        DbgPrint(SgDmaDebugBuffer);
    }

    va_end(ap);
#endif // DBG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\intrface.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    intrface.c
    
Abstract:

    This module implements the BUS_INTERFACE_STANDARD for the s/g dma driver
    
Author:
        
    Eric F. Nelson (enelson) 4-5-1999
    
Revision History:

--*/

#include "sgdma.h"


//
// Local function prototypes
//
NTSTATUS
SgDmaAllocateAdapterChannel0(
    IN PADAPTER_OBJECT AdapterObj,
    IN PDEVICE_OBJECT  DevObj,
    IN ULONG           NumMapRegs,
    IN PDRIVER_CONTROL ExecRoutine,
    IN PVOID           Context
    );

NTSTATUS
SgDmaAllocateAdapterChannel1(
    IN PADAPTER_OBJECT     AdapterObj,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG               NumMapRegs,
    IN PDRIVER_CONTROL     ExecRoutine
    );

PVOID
SgDmaAllocateCommonBuffer(
    IN PADAPTER_OBJECT    AdapterObj,
    IN ULONG              Length,
    OUT PPHYSICAL_ADDRESS LogicalAddr,
    IN BOOLEAN            CacheEnable
    );

BOOLEAN
SgDmaFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObj,
    IN PMDL            Mdl,
    IN PVOID           MapRegsBase,
    IN PVOID           CurrentVa,
    IN ULONG           Length,
    IN BOOLEAN         Write2Dev
    );

VOID
SgDmaFreeAdapterChannel(
    PADAPTER_OBJECT AdapterObj
    );
    
VOID
SgDmaFreeCommonBuffer(
    IN PADAPTER_OBJECT  AdapterObj,
    IN ULONG            Length,
    IN PHYSICAL_ADDRESS LogicalAddr,
    IN PVOID            VirtualAddr,
    IN BOOLEAN          CacheEnable
    );

VOID
SgDmaFreeMapRegisters(
    IN PADAPTER_OBJECT AdapterObj,
    IN PVOID           MapRegsBase,
    IN ULONG           NumMapRegs
    );

ULONG
SgDmaGetAlignment(
    PVOID Context
    );

NTSTATUS
SgDmaGetScatterGatherList(
    IN PADAPTER_OBJECT      AdapterObj,
    IN PDEVICE_OBJECT       DevObj,
    IN PMDL                 Mdl,
    IN PVOID                CurrentVa,
    IN ULONG                Length,
    IN PDRIVER_LIST_CONTROL ExecRoutine,
    IN PVOID                Context,
    IN BOOLEAN              Write2Dev
    );

PHYSICAL_ADDRESS
SgDmaMapTransfer(
    IN PADAPTER_OBJECT AdapterObj,
    IN PMDL            Mdl,
    IN PVOID           MapRegsBase,
    IN PVOID           CurrentVa,
    IN OUT PULONG      Length,
    IN BOOLEAN         Write2Dev
    );

PSG_DMA_ADAPTER
SgDmapAllocAdapter(
    VOID
    );

IO_ALLOCATION_ACTION
SgDmapAllocAdapterCallback(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PVOID          MapRegsBase,
    IN PVOID          Context
    );

BOOLEAN
SgDmapAllocMapRegs(
    IN PSG_DMA_ADAPTER SgAdapter,
    IN ULONG           NumMapRegs,
    IN BOOLEAN         MapAdapterLocked,
    IN BOOLEAN         NewAlloc
);

IO_ALLOCATION_ACTION
SgDmapAllocRoutine(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PVOID          MapRegsBase,
    IN PVOID          Context
    );

VOID
SgDmaPutAdapter(
    IN PADAPTER_OBJECT AdapterObj
    );

VOID
SgDmaPutScatterGatherList(
    IN PADAPTER_OBJECT      AdapterObj,
    IN PSCATTER_GATHER_LIST SGList,
    IN BOOLEAN              Write2Dev
    );

ULONG
SgDmaReadCounter(
    IN PADAPTER_OBJECT AdapterObj
    );


//
// Globals
//
DMA_OPERATIONS SgDmaOps = {
    sizeof(DMA_OPERATIONS),
    (PPUT_DMA_ADAPTER)SgDmaPutAdapter,
    (PALLOCATE_COMMON_BUFFER)SgDmaAllocateCommonBuffer,
    (PFREE_COMMON_BUFFER)SgDmaFreeCommonBuffer,
    (PALLOCATE_ADAPTER_CHANNEL)SgDmaAllocateAdapterChannel0,
    (PFLUSH_ADAPTER_BUFFERS)SgDmaFlushAdapterBuffers,
    (PFREE_ADAPTER_CHANNEL)SgDmaFreeAdapterChannel,
    (PFREE_MAP_REGISTERS)SgDmaFreeMapRegisters,
    (PMAP_TRANSFER)SgDmaMapTransfer,
    (PGET_DMA_ALIGNMENT)SgDmaGetAlignment,
    (PREAD_DMA_COUNTER)SgDmaReadCounter,
    (PGET_SCATTER_GATHER_LIST)SgDmaGetScatterGatherList,
    (PPUT_SCATTER_GATHER_LIST)SgDmaPutScatterGatherList
};


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SgDmaInterfaceDereference)
#pragma alloc_text(PAGE, SgDmaInterfaceReference)
#endif // ALLOC_PRAGMA



NTSTATUS
SgDmaAllocateAdapterChannel0(
    IN PADAPTER_OBJECT AdapterObj,
    IN PDEVICE_OBJECT  DeviceObj,
    IN ULONG           NumMapRegs,
    IN PDRIVER_CONTROL ExecRoutine,
    IN PVOID           Context
    )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object,
    this is accomplished by calling SgDmaAllocateAdapterChannel1 which does
    all of the work

Arguments:

    AdapterObj - The adapter control object to allocate to the driver

    DeviceObj - The driver's device object that represents the device
                allocating the adapter

    NumMapRegs - The number of map registers that are to be allocated
                 from the channel, if any

    ExecRoutine - The address of the driver's execution routine that is
                  invoked once the adapter channel (and possibly map
                  registers) have been allocated

    Context - An untyped longword context parameter passed to the driver's
              execution routine

Return Value:

    STATUS_SUCESS unless too many map registers are requested

Notes:

    This routine MUST be invoked at DISPATCH_LEVEL or above

--*/
{
    PWAIT_CONTEXT_BLOCK Wcb;

    Wcb = &DeviceObj->Queue.Wcb;

    Wcb->DeviceObject = DeviceObj;
    Wcb->CurrentIrp = DeviceObj->CurrentIrp;
    Wcb->DeviceContext = Context;

    return SgDmaAllocateAdapterChannel1(AdapterObj,
                                        Wcb,
                                        NumMapRegs,
                                        ExecRoutine);
}



NTSTATUS
SgDmaAllocateAdapterChannel1(
    IN PADAPTER_OBJECT     AdapterObj,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG               NumMapRegs,
    IN PDRIVER_CONTROL     ExecRoutine
    )
/*++

Routine Description:

    This routine allocates an adapter "channel" by inserting the
    driver's device object into the s/g dma adapter queue, when the
    adapter becomes free, the driver's execution routine is called

Arguments:

    AdapterObj - s/g dma adapter object

    Wcb - Wait context block of device requesting dma resource

    NumMapRegs - Number of map registers to allocate

    ExecRoutine - Driver's execution routine

Return Value:

    NTSTATUS
  
--*/
{
    BOOLEAN Busy              = FALSE;
    PSG_DMA_ADAPTER SgAdapter = ADAPT2SG(AdapterObj);
    
    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaAllocateAdapterChannel: AdapterObj=%p, "
                    "NumMapRegs=%x\n",
                    AdapterObj,
                    NumMapRegs);

    ASSERT(SgAdapter);

    //
    // Initialize the device object's wait context block in case this device
    // must wait before being able to allocate the adapter
    //    
    Wcb->DeviceRoutine = ExecRoutine;
    Wcb->NumberOfMapRegisters = NumMapRegs;

    //
    // Allocate the adapter object for this particular device, and if the
    // adapter cannot be allocated because it has already been allocated
    // to another device, return to the caller now; otherwise continue
    // 
    if (!KeInsertDeviceQueue(&SgAdapter->AdapterQ,
                             &Wcb->WaitQueueEntry)) {

        //
        // The adapter was not busy so it has been allocated, check
        // to see whether this driver wishes to allocate any map registers,
        // if so, then queue the device object to the master adapter queue
        // to wait for them to become available, if the driver wants map
        // registers, ensure that this adapter has enough total map registers
        // to satisfy the request
        // 
        SgAdapter->CurrentWcb = Wcb;
        SgAdapter->MapRegsAlloc = Wcb->NumberOfMapRegisters;

        if (NumMapRegs != 0) {

            //
            // Validate that the requested number of map registers is
            // within the maximum limit
            // 
            if (NumMapRegs > SgAdapter->MapAdapter->MaxMapRegs /
                AVG_ROOT_BUS_DEV_COUNT) {
                SgAdapter->MapRegsAlloc = 0;
                SgDmaFreeAdapterChannel(AdapterObj);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            
            Busy = SgDmapAllocMapRegs(SgAdapter,
                                      NumMapRegs,
                                      FALSE,
                                      TRUE);
        }

        //
        // If there were either enough map registers available, or no map
        // registers were requested, invoke the driver's execution
        // routine
        //                                           
        if (Busy == FALSE) {
                IO_ALLOCATION_ACTION Action =
                    ExecRoutine(Wcb->DeviceObject,
                                Wcb->CurrentIrp,
                                SgAdapter->MapRegsBase,
                                Wcb->DeviceContext);

            //
            // If the driver wants to keep the map registers, then set the
            // number allocated to zero and set the action to deallocate
            // object
            //                                       
            if (Action == DeallocateObjectKeepRegisters) {
                SgAdapter->MapRegsAlloc = 0;
                Action = DeallocateObject;
            }

            //
            // If the driver would like to have the adapter deallocated,
            // then deallocate any map registers allocated, then release
            // the adapter object
            //                                       
            if (Action == DeallocateObject) {
                SgDmaFreeAdapterChannel(AdapterObj);
            }

        } else {
            SgDmaDebugPrint(SgDmaDebugMapRegs,
                            "No map registers available! SgAdapter=%p, "
                            "NumMapRegs=%x\n",
                            SgAdapter,
                            NumMapRegs);
        }
        
    } else {
        SgDmaDebugPrint(SgDmaDebugMapRegs,
                        "AdapterQ busy! SgAdapter=%p\n",
                        SgAdapter);
    }
    
    return STATUS_SUCCESS;
}



PVOID
SgDmaAllocateCommonBuffer(
    IN PADAPTER_OBJECT    AdapterObj,
    IN ULONG              Length,
    OUT PPHYSICAL_ADDRESS LogicalAddr,
    IN BOOLEAN            CacheEnable
    )
/*++

Routine Description:

    This function allocates the memory for a common buffer and maps it so that
    it can be accessed by a s/g dma device and the CPU

Argumenmts:

    AdapterObj - s/g dma adapter object

    Length - Length of buffer

    LogicalAddr - The logical, bus-relative, address of the buffer
    
    CacheEnable - Idicates whether the memory is Cached or not

Return Value:

    Virtual address of the common buffer
  
--*/
{
    PVOID VirtualAddr;
    PVOID MapRegsBase;
    ULONG NumMapRegs;
    ULONG MappedLength;
    WAIT_CONTEXT_BLOCK Wcb;
    KEVENT AllocEvent;
    NTSTATUS Status;
    PMDL Mdl;
    KIRQL Irql;
    PHYSICAL_ADDRESS MaxPhysAddr;
    PSG_DMA_ADAPTER SgAdapter = ADAPT2SG(AdapterObj);

    ASSERT(SgAdapter);

    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaAllocateCommonBuffer: AdapterObj=%p, "
                    "Length=%x\n",
                    AdapterObj,
                    Length);

    NumMapRegs = BYTES_TO_PAGES(Length);

    //
    // Allocate the actual buffer and limit its physical address
    // below 1GB, the 1GB limitation guarantees that the buffer will
    // be accessible via 32-bit superpage
    //
    MaxPhysAddr.HighPart = 0;
    MaxPhysAddr.LowPart = __1GB - 1;
    VirtualAddr = MmAllocateContiguousMemory(Length, MaxPhysAddr);

    if (VirtualAddr == NULL) {
        return VirtualAddr;
    }

    KeInitializeEvent(&AllocEvent, NotificationEvent, FALSE);

    //
    // Initialize the wait context block, use the device object to indicate
    // where the map register base should be stored
    //
    Wcb.DeviceObject = &MapRegsBase;
    Wcb.CurrentIrp = NULL;
    Wcb.DeviceContext = &AllocEvent;

    //
    // Allocate the adapter and the map registers
    //
    KeRaiseIrql(DISPATCH_LEVEL, &Irql);
    Status = SgDmaAllocateAdapterChannel1(AdapterObj,
                                          &Wcb,
                                          NumMapRegs,
                                          SgDmapAllocRoutine);
    KeLowerIrql(Irql);

    if (!NT_SUCCESS(Status)) {

        //
        // Cleanup and return NULL
        //
        MmFreeContiguousMemory(VirtualAddr);
        return NULL;
    }

    //
    // Wait for the map registers to be allocated
    //
    Status = KeWaitForSingleObject(&AllocEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);

    if (!NT_SUCCESS(Status)) {

        //
        // Cleanup and return NULL
        //
        MmFreeContiguousMemory(VirtualAddr);
        return NULL;
    }

    //
    // Create a mdl suitable for I/O map transfer
    //
    Mdl = IoAllocateMdl(VirtualAddr,
                        Length,
                        FALSE,
                        FALSE,
                        NULL);
    
    if (Mdl == NULL) {

        //
        // Cleanup and return NULL
        //
        MmFreeContiguousMemory(VirtualAddr);
        return NULL;
    }
    MmBuildMdlForNonPagedPool(Mdl);

    //
    // Map the transfer so that the controller can access the memory
    //
    MappedLength = Length;
    *LogicalAddr = SgDmaMapTransfer(AdapterObj,
                                    Mdl,
                                    MapRegsBase,
                                    VirtualAddr,
                                    &MappedLength,
                                    TRUE);           
    IoFreeMdl(Mdl);

    if (MappedLength < Length) {

        //
        // Cleanup and indicate that the allocation failed
        //
        SgDmaFreeCommonBuffer(AdapterObj,
                              Length,
                              *LogicalAddr,
                              VirtualAddr,
                              FALSE);
        return NULL;
    }

    //
    // The allocation completed successfully
    //
    return VirtualAddr;
}



BOOLEAN
SgDmaFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObj,
    IN PMDL            Mdl,
    IN PVOID           MapRegsBase,
    IN PVOID           CurrentVa,
    IN ULONG           Length,
    IN BOOLEAN         Write2Dev
    )
/*++

Routine Description:

    This routine "flushes" the s/g dma adapter buffer

Arguments:

    AdapterObj - s/g dma adapter object

    Mdl - Memory descriptor list

    MapRegsBase - Map register base

    CurrentVa - The current virtual address in the buffer described by the mdl
                where the IO operation occurred

    Length - Length of the transfer

    Write2Dev - TRUE if the direction of the dma write was to the device
        
Return Value:

    BOOLEAN indicating whether the operation was successful
  
--*/
{
    ULONG i;
    ULONG Offset;
    ULONG NumPages;
    ULONG LogicalAddr;
    PTRANSLATION_ENTRY MapReg;
    PSG_MAP_ADAPTER SgMapAdapter;

    SgDmaDebugPrint(SgDmaDebugMapRegs | SgDmaDebugInterface,
                    "SgDmaFlushAdapterBuffers: AdapterObj=%p, CurrentVa=%p, "
                    "MapRegsBase=%p, Length=%x, Write2Dev=%x\n",
                    AdapterObj,
                    CurrentVa,
                    MapRegsBase,
                    Length,
                    Write2Dev);

    ASSERT(AdapterObj);
    
    SgMapAdapter = ADAPT2SG(AdapterObj)->MapAdapter;

    //
    // The Mdl Base VA must point to a page boundary
    //
    ASSERT(((ULONG_PTR)MmGetMdlBaseVa(Mdl) & (PAGE_SIZE - 1)) == 0);

    //
    // Compute the starting offset of the transfer
    //
    Offset = BYTE_OFFSET((PUCHAR)CurrentVa);

    //
    // Compute the number of pages that this transfer spanned
    //
    NumPages = (Offset + Length + PAGE_SIZE - 1) >> PAGE_SHIFT;

    //
    // Compute a pointer to the first translation entry that mapped this
    // transfer
    //
    MapReg = (PTRANSLATION_ENTRY)MapRegsBase;

    //
    // Mark each translation as invalid
    //
    for (i=0; i < NumPages; i++) {
        SgDmaDebugPrint(SgDmaDebugMapRegs,
                        "Invalidate MapReg=%p, PFN=%x\n",
                        MapReg,
                        MapReg->Pfn);
        SgDmaHwInvalidateTx(MapReg);
        LogicalAddr =
            (ULONG)((((PTRANSLATION_ENTRY)MapReg -
                      (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase) <<
                     PAGE_SHIFT) | (ULONG_PTR)SgMapAdapter->WindowBase);
        SgDmaHwTlbInvalidate(SgMapAdapter, LogicalAddr);
        MapReg++;
    }

    if (Write2Dev) {
        SgDmaHwInvalidateTx(MapReg);
        LogicalAddr =
            (ULONG)((((PTRANSLATION_ENTRY)MapReg -
                      (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase) <<
                     PAGE_SHIFT) | (ULONG_PTR)SgMapAdapter->WindowBase);
        SgDmaHwTlbInvalidate(SgMapAdapter, LogicalAddr);
    }

    //
    // Synchronize the updated translations with any subsequent device
    // accesses, also synchronize any reads of the newly written DMA
    // data by ensuring this processors view of memory is coherent
    //
#ifdef _ALPHA_
    __MB();
#endif // _ALPHA_

    return TRUE;
}



VOID
SgDmaFreeAdapterChannel(
    PADAPTER_OBJECT AdapterObj
    )
/*++

Routine Description:

    This routine frees the adapter channel, and any map registers that were
    allocated to it, and calls the next execution routine in the s/g dma
    adapter queue

Arguments:

    AdapterObj - s/g dma adapter object

Return Value:

    None
  
--*/
{
    BOOLEAN Busy = FALSE;
    PWAIT_CONTEXT_BLOCK Wcb;
    IO_ALLOCATION_ACTION Action;
    PKDEVICE_QUEUE_ENTRY Packet;
    PSG_DMA_ADAPTER SgAdapter = ADAPT2SG(AdapterObj);

    ASSERT(SgAdapter);
    
    SgDmaDebugPrint(SgDmaDebugInterface | SgDmaDebugMapRegs,
                    "SgDmaFreeAdapterChannel: SgAdapter=%p, SgMapAdapter=%p\n",
                    SgAdapter, SgAdapter->MapAdapter);
    
    //
    // Pull requests of the adapter's device wait queue as long as the
    // adapter is free and there are sufficient map registers available
    //
    while (TRUE) {

        //
        // Begin by checking to see whether there are any map registers that
        // need to be deallocated, if so, then deallocate them now
        //
        if (SgAdapter->MapRegsAlloc != 0) {
            SgDmaFreeMapRegisters(SG2ADAPT(SgAdapter),
                                  SgAdapter->MapRegsBase,
                                  SgAdapter->MapRegsAlloc);
        }

        //
        // Remove the next entry from the adapter's device wait queue,
        // if one was successfully removed, allocate any map registers that it
        // requires and invoke its execution routine
        //
        Packet = KeRemoveDeviceQueue(&SgAdapter->AdapterQ);
        if (Packet == NULL) {
            
            //
            // There are no more requests break out of the loop
            //
            break;
        }
        Wcb = CONTAINING_RECORD(Packet,
                                WAIT_CONTEXT_BLOCK,
                                WaitQueueEntry);      
        SgAdapter->CurrentWcb = Wcb;
        SgAdapter->MapRegsAlloc = Wcb->NumberOfMapRegisters;
        
        SgDmaDebugPrint(SgDmaDebugMapRegs,
                        "SgDmaFreeAdapterChannel: Pop SgAdapter=%p, "
                        "NumMapRegs=%x\n",
                        SgAdapter,
                        Wcb->NumberOfMapRegisters);
        
        //
        // Check to see whether this driver wishes to allocate any map
        // registers, if so, queue the device object to the master
        // adapter queue to wait for them to become available, if the driver
        // wants map registers, ensure that this adapter has enough total
        // map registers to satisfy the request
        //
        if (Wcb->NumberOfMapRegisters != 0) {
            Busy = SgDmapAllocMapRegs(SgAdapter,
                                      Wcb->NumberOfMapRegisters,
                                      FALSE,
                                      FALSE);
        }

            
        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now
        //
        if (Busy == FALSE) {
            SgAdapter->CurrentWcb = Wcb;
            Action = Wcb->DeviceRoutine(Wcb->DeviceObject,
                                        Wcb->CurrentIrp,
                                        SgAdapter->MapRegsBase,
                                        Wcb->DeviceContext);

            //
            // If the execution routine would like to have the adapter
            // deallocated, then release the adapter object
            //
            if (Action == KeepObject) {

                //
                // This request wants to keep the channel a while so break
                // out of the loop
                //
                break;
            }

            //
            // If the driver wants to keep the map registers then set the
            // number allocated to 0, this keeps the deallocation routine
            // from deallocating them
            //
            if (Action == DeallocateObjectKeepRegisters) {
                SgAdapter->MapRegsAlloc = 0;
            }

        //
        // This request did not get the desired number of map registers
        // so we fall out of the loop
        //
        } else {
            SgDmaDebugPrint(SgDmaDebugMapRegs,
                            "SgDmaFreeAdapterChannel: Not enough maps! "
                            "SgAdapter=%p, NumMapRegs=%x\n",
                            SgAdapter, Wcb->NumberOfMapRegisters);
            break;
        }
    }
}



VOID
SgDmaFreeCommonBuffer(
    IN PADAPTER_OBJECT  AdapterObj,
    IN ULONG            Length,
    IN PHYSICAL_ADDRESS LogicalAddr,
    IN PVOID            VirtualAddr, 
    IN BOOLEAN          CacheEnable
    )
/*++

Routine Description:

    This function frees a common buffer and its resources

Argumenmts:

    AdapterObj - s/g dma adapter object

    Length - Length of buffer

    LogicalAddr - The logical, bus-relative, address of the buffer
    
    CacheEnable - Cached/non-cached memory
    
Return Value:

    None
  
--*/
{
    ULONG NumMapRegs;
    ULONG MapRegsIndex;
    PSG_MAP_ADAPTER SgMapAdapter;
    PTRANSLATION_ENTRY MapRegsBase;
    PSG_DMA_ADAPTER SgAdapter = ADAPT2SG(AdapterObj);
    
    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaFreeCommonBuffer: AdapterObj=%p\n",
                    AdapterObj);
    
    ASSERT(SgAdapter);
    
    SgMapAdapter = SgAdapter->MapAdapter;
    
    //
    // Calculate the number of map registers, the map register index, and
    // its base
    //
    NumMapRegs =
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(VirtualAddr, Length);
    MapRegsIndex =
        (LogicalAddr.LowPart - (ULONG)((ULONG_PTR)SgMapAdapter->WindowBase)) >>
        PAGE_SHIFT;
    MapRegsBase = (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase + MapRegsIndex;
    
    //
    // Free the map registers
    //
    SgDmaFreeMapRegisters(AdapterObj,
                          (PVOID)MapRegsBase,
                          NumMapRegs);
    
    //
    // Free the memory for the common buffer
    //
    MmFreeContiguousMemory(VirtualAddr);
}



VOID
SgDmaFreeMapRegisters(
    IN PADAPTER_OBJECT AdapterObj,
    IN PVOID           MapRegsBase,
    IN ULONG           NumMapRegs
    )
/*++

Routine Description:

    This routine deallocates the map registers for the adapter

    If there are any queued adapters waiting for the device, an attempt
    to allocate the next entry is made

Arguments:

    AdapterObj - s/g dma adapter object

    MapRegsBase - Map register base

    NumMapRegs - Number of map registers

Return Value:

    None
  
--*/
{
    KIRQL Irql;
    LONG MapRegsIndex;
    PLIST_ENTRY Packet;
    BOOLEAN Busy = FALSE;
    PWAIT_CONTEXT_BLOCK Wcb;
    IO_ALLOCATION_ACTION Action;
    PSG_MAP_ADAPTER SgMapAdapter;
    PSG_DMA_ADAPTER SgAdapter= ADAPT2SG(AdapterObj);
     
    ASSERT(SgAdapter);
    
    //
    // Deallocate the extra map register that we originally allocated to fix
    // the DMA prefetch problem
    //
    NumMapRegs += 1;

    SgMapAdapter = SgAdapter->MapAdapter;

    SgDmaDebugPrint(SgDmaDebugMapRegs | SgDmaDebugInterface,
                    "SgDmaFreeMapRegs: AdapterObj=%p, SgMapAdapter=%p, "
                    "NumMapRegs=%x\n",
                    SgAdapter,
                    SgMapAdapter,
                    NumMapRegs - 1);
    
    MapRegsIndex = (LONG)((PTRANSLATION_ENTRY)MapRegsBase -
                          (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase);

    //
    // Acquire the map adapter spinlock which locks the adapter queue and the
    // bit map for the map registers
    //                          
    KeAcquireSpinLock(&SgMapAdapter->MapsLock, &Irql);

    //
    // Return the registers to the bit map
    //
    RtlClearBits(SgMapAdapter->MapRegsBitmap,
                  MapRegsIndex,
                  NumMapRegs);

    //
    // Process any requests waiting for map registers in the adapter queue,
    // requests are processed until a request cannot be satisfied, or until
    // there are no more requests in the queue
    //
    while (TRUE) {

        if (IsListEmpty(&SgMapAdapter->RegsWaitQ)) {
            break;
        }
        
        Packet = RemoveHeadList(&SgMapAdapter->RegsWaitQ);
        SgAdapter = CONTAINING_RECORD(Packet,
                                      SG_DMA_ADAPTER,
                                      AdapterQ);
        
        SgDmaDebugPrint(SgDmaDebugMapRegs,
                        "SgDmaFreeMapRegs: Pop SgAdapter=%p\n", SgAdapter);
        
        Wcb = SgAdapter->CurrentWcb;

        //
        // Attempt to allocate the map registers
        //                  
        Busy = SgDmapAllocMapRegs(SgAdapter,
                                  Wcb->NumberOfMapRegisters,
                                  TRUE,
                                  FALSE);

        if (Busy == TRUE) {
            SgDmaDebugPrint(SgDmaDebugMapRegs,
                            "SgDmaFreeMapRegs: No free maps, SgAdapter=%p, "
                            "NumMapRegs=%x\n",
                            SgAdapter,
                            Wcb->NumberOfMapRegisters);
            break;
        }
        
        KeReleaseSpinLock(&SgMapAdapter->MapsLock, Irql);

        //
        // Invoke the driver's execution routine now
        //
        Action = Wcb->DeviceRoutine(Wcb->DeviceObject,
                                    Wcb->CurrentIrp,
                                    SgAdapter->MapRegsBase,
                                    Wcb->DeviceContext);

        //
        // If the driver wishes to keep the map registers, then set the
        // number allocated to zero and set the action to deallocate object
        //
        if (Action == DeallocateObjectKeepRegisters) {
            SgAdapter->MapRegsAlloc = 0;
            Action = DeallocateObject;
        }

        //
        // If the driver would like to have the adapter deallocated,
        // then deallocate any map registers allocated and release
        // the adapter object
        //
        if (Action == DeallocateObject) {

            //
            // The map registers are deallocated here rather than in
            // SgDmaFreeAdapterChannel, this limits the number of times
            // this routine can be called recursively possibly overflowing
            // the stack, the worst case occurs if there is a pending
            // request for the adapter that uses map registers, and whose
            // excution routine decallocates the adapter, in that case if
            // there are no requests in the map adapter queue, then
            // SgDmaFreeMapRegisters will get called again
            //
            if (SgAdapter->MapRegsAlloc != 0) {

                //
                // Deallocate the map registers and clear the count so that
                // SgDmaFreeAdapterChannel will not deallocate them again
                //
                KeAcquireSpinLock(&SgMapAdapter->MapsLock, &Irql);
                MapRegsIndex =
                    (LONG)((PTRANSLATION_ENTRY)SgAdapter->MapRegsBase -
                           (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase);
                RtlClearBits(SgMapAdapter->MapRegsBitmap,
                             MapRegsIndex,
                             SgAdapter->MapRegsAlloc);
                SgAdapter->MapRegsAlloc = 0;
                KeReleaseSpinLock(&SgMapAdapter->MapsLock, Irql);
            }
            SgDmaFreeAdapterChannel(AdapterObj);
            
        }
        KeAcquireSpinLock(&SgMapAdapter->MapsLock, &Irql);
        
    }
    KeReleaseSpinLock(&SgMapAdapter->MapsLock, Irql);
}



PDMA_ADAPTER
SgDmaGetAdapter(
    IN PVOID               Context,
    IN PDEVICE_DESCRIPTION DevDesc,
    OUT PULONG             NumMapRegs
    )
/*++

Routine Description:

    This routine allocates a s/g dma adapter

Arguments:

    Context - s/g dma device extension

    DevDesc - Describes the device requesting dma resources

    NumMapRegs - Maximum number of map registers the device can request

Return Value:

    Pointer to a s/g dma adapter

--*/
{
    ULONG DeviceMaxMapRegs;
    PSG_DMA_ADAPTER SgAdapter;
    PDMA_ADAPTER DmaAdapter = NULL;
    PSG_DMA_EXTENSION SgDmaExt = (PSG_DMA_EXTENSION)Context;

    ASSERT(SgDmaExt->MapAdapter != NULL);
    
    SgDmaDebugPrint(SgDmaDebugDispatch,
                    "SgDmaGetAdapter: SgDmaExt=%p, ",
                    Context);

    //
    // Allocate and initialize a s/g dma adapter
    //
    if (
#if DBG
        !SgDmaFake &&
#endif // DBG

        //
        // EFNhack:  I don't think we should be making this descision 
        //           based on InterfaceType, but currently videoprt/perm2
        //           doesn't set Dma32BitAddresses, although it must
        //           support it as the map registers reside above 2GB, so
        //           for now we will make the same check as the HAL to avoid
        //           an invalid s/g pte machine check
        //
        //(DevDesc->Dma32BitAddresses || DevDesc->Dma64BitAddresses)
        (DevDesc->InterfaceType != Isa) && (DevDesc->InterfaceType != Eisa)
        && DevDesc->Master) {

        SgAdapter = SgDmapAllocAdapter();
            
        if (SgAdapter != NULL) {
            DmaAdapter = SG2DMA(SgAdapter);
            SgAdapter->MapAdapter = SgDmaExt->MapAdapter;
            
            if (NumMapRegs != NULL) {
                *NumMapRegs = BYTES_TO_PAGES(DevDesc->MaximumLength) + 1;
                DeviceMaxMapRegs =
                    SgAdapter->MapAdapter->MaxMapRegs / AVG_ROOT_BUS_DEV_COUNT;

                if (*NumMapRegs > DeviceMaxMapRegs) {
                    *NumMapRegs = DeviceMaxMapRegs;
                }
                SgAdapter->DeviceMaxMapRegs = *NumMapRegs;
                
            } else {                
                SgAdapter->DeviceMaxMapRegs = 0;
            }
            
            SgDmaDebugPrint(SgDmaDebugDispatch,
                            "DeviceMaxMapRegs=%x, New AdapterObj=%p\n",
                            SgAdapter->DeviceMaxMapRegs,
                            DmaAdapter);

        } else {
            SgDmaDebugPrint(SgDmaDebugDispatch,
                            "ERROR allocating AdapterObj!\n");
        }
        
    //
    // The HAL handles all legacy, and 64-bit dma
    //
    } else {
        DmaAdapter = SgDmaExt->HalGetAdapter(Context, DevDesc, NumMapRegs);
    }
    
    return DmaAdapter;
}



ULONG
SgDmaGetAlignment(
    PVOID Context
    )
/*++

Routine Description:

    This routine returns the dma alignment

Arguments:

    Context - Not used

Return Value:

    Dma alignment
  
--*/
{
    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaGetAlignment: Context=%p\n",
                    Context);
    
    return DMA_HW_ALIGN_REQ;
}



NTSTATUS
SgDmaGetScatterGatherList(
    IN PADAPTER_OBJECT      AdapterObj,
    IN PDEVICE_OBJECT       DevObj,
    IN PMDL                 Mdl,
    IN PVOID                CurrentVa,
    IN ULONG                Length,
    IN PDRIVER_LIST_CONTROL ExecRoutine,
    IN PVOID                Context,
    IN BOOLEAN              Write2Dev
    )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object

    A s/g list is built based on the mdl, the current virtual address and
    length, then the driver's execution routine is called with the list, and
    the adapter is released when the execution function returns

Arguments:

    AdapterObj - s/g dma adapter object

    DevObj - Device object that is allocating the adapter

    Mdl - Memory descriptor list

    CurrentVa - Current virtual address in the buffer described by mdl that
                the transfer is from or to

    Length - Length of the transfer

    ExecRoutine - Driver's execution routine to be called when the adapter
                  channel, and possibly map registers, have been allocated

    Context - An untyped longword context parameter passed to the driver's
              execution routine

    Write2Dev - TRUE if the dma transfer is to the device
    
Return Value:

    NTSTATUS
  
--*/
{
    PMDL TempMdl;
    PUCHAR MdlVa;
    ULONG MdlLength;
    NTSTATUS Status;
    ULONG NumMapRegs;
    ULONG PageOffset;
    ULONG ContextSize;
    ULONG TransferLength;
    PSCATTER_GATHER_ELEMENT Element;
    PDMA_WAIT_CTX_BLOCK WaitBlock;
    PSCATTER_GATHER_LIST ScatterGather;
    PSG_DMA_ADAPTER SgAdapter = ADAPT2SG(AdapterObj);

    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaGetScatterGatherList: AdapterObj=%p\n",
                    AdapterObj);

    ASSERT(SgAdapter);

    MdlVa = MmGetMdlVirtualAddress(Mdl);

    ASSERT(MdlVa <= (PUCHAR)CurrentVa && MdlVa + Mdl->ByteCount >
           (PUCHAR)CurrentVa);

    //
    // Calculate the number of required map registers
    //
    TempMdl = Mdl;
    TransferLength = TempMdl->ByteCount - (ULONG)((PUCHAR)CurrentVa - MdlVa);
    MdlLength = TransferLength;  
    PageOffset = BYTE_OFFSET(CurrentVa);
    NumMapRegs = 0;

    //
    // Loop through the any chained MDLs accumulating the the required
    // number of map registers
    //
    while (TransferLength < Length && TempMdl->Next != NULL) {
        NumMapRegs += (PageOffset + MdlLength + PAGE_SIZE - 1) >> PAGE_SHIFT;
        TempMdl = TempMdl->Next;
        PageOffset = TempMdl->ByteOffset;
        MdlLength = TempMdl->ByteCount;
        TransferLength += MdlLength;
    }

    if (TransferLength + PAGE_SIZE < Length + PageOffset) {
        ASSERT(TransferLength >= Length);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Calculate the last number of map registers base on the requested
    // length not the length of the last MDL
    //
    ASSERT(TransferLength <= MdlLength + Length);

    NumMapRegs +=
        (PageOffset + Length + MdlLength - TransferLength + PAGE_SIZE - 1) >>
        PAGE_SHIFT;

    if (NumMapRegs > SgAdapter->DeviceMaxMapRegs) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Calculate how much memory is required for context structure
    //
    ContextSize = NumMapRegs * sizeof(SCATTER_GATHER_ELEMENT) +
        sizeof(SCATTER_GATHER_LIST);

    ContextSize += FIELD_OFFSET(DMA_WAIT_CTX_BLOCK, ScatterGather);

    if (ContextSize < sizeof(DMA_WAIT_CTX_BLOCK)) {
        ContextSize = sizeof(DMA_WAIT_CTX_BLOCK);
    }
    WaitBlock = ExAllocatePoolWithTag(NonPagedPool, ContextSize, SG_DMA_TAG);

    if (WaitBlock == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Save the interesting data in the wait block
    //
    WaitBlock->Mdl = Mdl;
    WaitBlock->CurrentVa = CurrentVa;
    WaitBlock->Length = Length;
    WaitBlock->DriverExecRoutine = ExecRoutine;
    WaitBlock->DriverCtx = Context;
    WaitBlock->AdapterObj = AdapterObj;
    WaitBlock->Write2Dev = Write2Dev;
    WaitBlock->Wcb.DeviceContext = WaitBlock;
    WaitBlock->Wcb.DeviceObject = DevObj;
    WaitBlock->Wcb.CurrentIrp = DevObj->CurrentIrp;

    //
    // Call the HAL to allocate the adapter channel,
    // HalpAllocateAdapterCallback will fill in the scatter/gather list
    //
    Status = SgDmaAllocateAdapterChannel1(AdapterObj,
                                          &WaitBlock->Wcb,
                                          NumMapRegs,
                                          SgDmapAllocAdapterCallback);

    //
    // If HalAllocateAdapterChannel failed then free the wait block
    //
    if (!NT_SUCCESS(Status)) {
        ExFreePool(WaitBlock);
    }

    return Status;
}



VOID
SgDmaInterfaceDereference(
    IN PSG_DMA_EXTENSION SgExtension
    )
/*++

Routine Description:

    This routine dereferences a s/g dma interface

Arguments:

    s/g dma extension

Return Value:

    None
  
--*/
{
    PAGED_CODE();
    
    InterlockedDecrement(&SgExtension->InterfaceCount);
}



VOID
SgDmaInterfaceReference(
    IN PSG_DMA_EXTENSION SgExtension
    )

/*++

Routine Description:

    This routine references a s/g dma interface

Arguments:

    

Return Value:

    None
  
--*/
{
    PAGED_CODE();
    
    InterlockedIncrement(&SgExtension->InterfaceCount);
}



PHYSICAL_ADDRESS
SgDmaMapTransfer(
    IN PADAPTER_OBJECT AdapterObj,
    IN PMDL            Mdl,
    IN PVOID           MapRegsBase,
    IN PVOID           CurrentVa,
    IN OUT PULONG      Length,
    IN BOOLEAN         Write2Dev
    )
/*++

Routine Description:

    This routine programs the map registers for a s/g dma transfer

Arguments:

    AdapterObj - s/g dma adapter object

    Mdl - Mmeory descriptor list

    MapRegsBase - Map register base

    CurrentVa - The current virtual address in the buffer described by the mdl
                where the IO operation occurred

    Length - Length of the transfer

    Write2Dev - TRUE if the direction of the dma write was to the device

Return Value:

    Logical, bus-relative address address for the transfer
  
--*/
{
    ULONG i;
    ULONG Offset;
    ULONG PageCount;
    PPFN_NUMBER Pfn;
    ULONG LogicalAddr;
    ULONG TransferLength;
    PTRANSLATION_ENTRY MapReg;
    PSG_MAP_ADAPTER SgMapAdapter;
    PHYSICAL_ADDRESS ReturnAddr = { 0, 0 };

    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaMapTransfer: AdapterObj=%p\n",
                    AdapterObj);

    ASSERT(AdapterObj);
    
    //
    // Compute a pointer to the page frame of the starting page of the
    // transfer
    //
    Pfn = MmGetMdlPfnArray(Mdl);
    Pfn += (((ULONG_PTR)CurrentVa - (ULONG_PTR)MmGetMdlBaseVa(Mdl)) >>
            PAGE_SHIFT);

    SgDmaDebugPrint(SgDmaDebugMapRegs,
                    "SgDmaMapTransfer: CurrentVa=%p, Length=%x, "
                    "Write2Dev=%x\n",
                    CurrentVa,
                    *Length,
                    Write2Dev);

    SgMapAdapter = ADAPT2SG(AdapterObj)->MapAdapter;

    //
    // Begin by determining where in the buffer this portion of the operation
    // is taking place
    //
    Offset = BYTE_OFFSET((PUCHAR)CurrentVa);
    SgDmaDebugPrint(SgDmaDebugMapRegs,  "Offset (1)=%x\n", Offset);

    //
    // Compute number of pages that this transfer spans
    //
    PageCount = (Offset + *Length + PAGE_SIZE - 1) >> PAGE_SHIFT;
    SgDmaDebugPrint(SgDmaDebugMapRegs, "PageCount=%x\n", PageCount);

    //
    // Compute a pointer to the map register that maps the starting page of
    // the transfer
    //
    MapReg = MapRegsBase;

    //
    // For each page, setup the mapping in the s/g dma registers
    //
    TransferLength = 0;
    for (i = 0; i < PageCount; i++) {
        SgDmaHwMakeValidTx(MapReg, *Pfn);
        LogicalAddr =
            (ULONG)((((PTRANSLATION_ENTRY)MapReg -
                      (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase) <<
                     PAGE_SHIFT) | (ULONG_PTR)SgMapAdapter->WindowBase);
        SgDmaHwTlbInvalidate(SgMapAdapter, LogicalAddr);
        SgDmaDebugPrint(SgDmaDebugMapRegs,
                        "Validate: *Pfn=%x, MapReg=%p\n",
                        *Pfn,
                        MapReg);
        TransferLength += i ? PAGE_SIZE: PAGE_SIZE - BYTE_OFFSET(CurrentVa);
        Pfn++;
        MapReg++;
    }

    //
    // Couldn't map all pages, adjust length accordingly
    //
    if (TransferLength < *Length) {
        SgDmaDebugPrint(SgDmaDebugMapRegs,
                        "!!! Couldn't map entire transfer, wanted=%x, "
                        "mapped=%x\n", *Length, TransferLength);
        *Length = TransferLength;
    }

    //
    // If the operation is a write to device (transfer from memory to device),
    // we will validate the extra map register so we don't generate a PFN
    // error due to DMA prefetch by some devices
    //
    if (Write2Dev) {
        Pfn -= 1;
        SgDmaHwMakeValidTx(MapReg, *Pfn);
        LogicalAddr =
            (ULONG)((((PTRANSLATION_ENTRY)MapReg -
                      (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase) <<
                     PAGE_SHIFT) | (ULONG_PTR)SgMapAdapter->WindowBase);
        SgDmaHwTlbInvalidate(SgMapAdapter, LogicalAddr);
    }
    
    //
    // Synchronize the s/g map register write with any subsequent writes
    // to the device
    //
#ifdef _ALPHA_
    __MB();
#endif // _ALPHA_

    //
    // Set the offset to point to the map register plus the offset
    //
    Offset +=
        (ULONG)((PTRANSLATION_ENTRY)MapRegsBase -
                (PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase) << PAGE_SHIFT;
    Offset += (ULONG)((ULONG_PTR)SgMapAdapter->WindowBase);
    SgDmaDebugPrint(SgDmaDebugMapRegs, "Offset(2)=%x\n", Offset);    
    ReturnAddr.QuadPart = Offset;

    return ReturnAddr;
}



PSG_DMA_ADAPTER
SgDmapAllocAdapter(
    VOID
    )
/*++

Routine Description:

    This routine allocates and initializes a s/g dma adapter to represent
    a device's dma controller

Arguments:

    None

Return Value:

    The function value is a pointer to a s/g dma adapter, or NULL

--*/
{                            
    ULONG Size;
    HANDLE Handle;
    NTSTATUS Status;
    PSG_DMA_ADAPTER SgAdapter;
    OBJECT_ATTRIBUTES ObjAttrib;

    //
    // Begin by initializing the object attributes structure to be used when
    // creating the adapter
    //
    InitializeObjectAttributes(&ObjAttrib,
                               NULL,
                               OBJ_PERMANENT,
                               (HANDLE)NULL,
                               (PSECURITY_DESCRIPTOR)NULL);

    Size = sizeof(SG_DMA_ADAPTER);

    //
    // Now create the adapter object
    //
    Status = ObCreateObject(KernelMode,
                            *((POBJECT_TYPE *)IoAdapterObjectType),
                            &ObjAttrib,
                            KernelMode,
                            (PVOID)NULL,
                            Size,
                            0,
                            0,
                            (PVOID *)&SgAdapter);

    //
    // Reference the object
    //
    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByPointer(SgAdapter,
                                            FILE_READ_DATA | FILE_WRITE_DATA,
                                            *IoAdapterObjectType,
                                            KernelMode);
    }

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the the object table
    //
    if (NT_SUCCESS(Status)) {

        Status = ObInsertObject(SgAdapter,
                                NULL,
                                FILE_READ_DATA | FILE_WRITE_DATA,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        if (NT_SUCCESS(Status)) {

            ZwClose(Handle);

            //
            // Initialize the adapter object itself
            //
            SgAdapter->DmaHeader.Version = IO_TYPE_ADAPTER;
            SgAdapter->DmaHeader.Size = (USHORT)Size;
            SgAdapter->DmaHeader.DmaOperations = &SgDmaOps;
            SgAdapter->MapRegsBase = NULL;
            SgAdapter->MapRegsAlloc = 0;
            SgAdapter->CurrentWcb = NULL;
            InitializeListHead(&SgAdapter->MapAdapterQ);
            
            //
            // Initialize the channel wait queue for this
            // adapter
            //
            KeInitializeDeviceQueue(&SgAdapter->AdapterQ);

        //
        // An error was incurred for some reason set the return value
        // to NULL
        //
        } else {
            SgAdapter = NULL;
        }
    } else {
        SgAdapter = NULL;
    }

    return SgAdapter;
}



IO_ALLOCATION_ACTION
SgDmapAllocAdapterCallback(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PVOID          MapRegsBase,
    IN PVOID          Context
    )
/*++

Routine Description:

    This routine is called when the adapter object and map registers are
    available for the data transfer, this routines saves the map register
    base away, if all of the required bases have not been saved then it
    returns, otherwise it builds the entire scatter/gather list by calling
    IoMapTransfer, after the list is build it is passed to the driver

Arguments:

    DevObj - The device object of the device that is allocating the adapter

    Irp - The map register offset assigned for this callback

    MapRegsBase - The map register base for use by the adapter routines

    Context - A pointer to the s/g dma wait context block

Return Value:

    Returns DeallocateObjectKeepRegisters

--*/
{
    PMDL Mdl;
    LONG MdlLength;
    PVOID DriverCtx;
    PIRP CurrentIrp;
    PUCHAR CurrentVa;
    BOOLEAN Write2Dev;
    ULONG TransferLength;
    PADAPTER_OBJECT AdapterObj;
    PTRANSLATION_ENTRY NextEntry;
    PSCATTER_GATHER_ELEMENT Element;
    PSCATTER_GATHER_LIST ScatterGather;
    PDRIVER_LIST_CONTROL DriverExecRoutine;
    PDMA_WAIT_CTX_BLOCK WaitBlock       = (PDMA_WAIT_CTX_BLOCK)Context;
    PTRANSLATION_ENTRY TranslationEntry = (PTRANSLATION_ENTRY)MapRegsBase;

    //
    // Save the map register base
    //
    WaitBlock->MapRegsBase = MapRegsBase;

    //
    // Save the data that will be over written by the scatter gather list
    //
    DriverCtx = WaitBlock->DriverCtx;
    CurrentIrp = WaitBlock->Wcb.CurrentIrp;
    AdapterObj = WaitBlock->AdapterObj;
    Write2Dev = WaitBlock->Write2Dev;
    DriverExecRoutine = WaitBlock->DriverExecRoutine;

    //
    // Put the scatter gatther list after wait block, add a back pointer to
    // the begining of the wait block
    //
    ScatterGather = &WaitBlock->ScatterGather;
    ScatterGather->Reserved = (ULONG_PTR)WaitBlock;
    Element = ScatterGather->Elements;

    //
    // Setup for the first MDL, we expect the MDL pointer to be pointing
    // at the first used MDL
    //
    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;
    ASSERT(CurrentVa >= (PUCHAR)MmGetMdlVirtualAddress(Mdl) && CurrentVa <
           (PUCHAR)MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount);
    MdlLength = Mdl->ByteCount -
        (ULONG)(CurrentVa - (PUCHAR)MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;

    //
    // Loop build the list for each MDL
    //
    while (TransferLength >  0) {

        if ((ULONG)MdlLength > TransferLength) {
            MdlLength = TransferLength;
        }
        TransferLength -= MdlLength;             
        NextEntry = TranslationEntry +
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, MdlLength);

        //
        // Loop building the list for the elments within and MDL
        //
        while (MdlLength > 0) { 
            Element->Length = MdlLength;
            Element->Address = SgDmaMapTransfer(AdapterObj,
                                                Mdl,
                                                MapRegsBase,
                                                CurrentVa,
                                                &Element->Length,
                                                WaitBlock->Write2Dev);
            
            ASSERT((ULONG)MdlLength >= Element->Length);            
            MdlLength -= Element->Length;
            CurrentVa += Element->Length;
            Element++;
        }

        if (Mdl->Next == NULL) {

            //
            // There are a few cases where the buffer described by the MDL
            // is less than the transfer length, this occurs when the
            // file system is transfering the last page of file and MM defines
            // the MDL to be file size, but the file system rounds the write
            // up to a sector, this extra should never cross a page
            // bountry, add this extra to the length of the last element
            //
            ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) +
                   TransferLength <= PAGE_SIZE);
            (Element - 1)->Length += TransferLength;
            break;
        }

        //
        // Advance to the next MDL, update the current VA and the MdlLength
        //
        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
        TranslationEntry = NextEntry;
    }

    //
    // Set the number of elements actually used
    //
    ScatterGather->NumberOfElements =
        (ULONG)(Element - ScatterGather->Elements);

    //
    // Call the driver with the scatter/gather list
    //
    DriverExecRoutine(DevObj,
                      CurrentIrp,
                      ScatterGather,
                      DriverCtx);

    return DeallocateObjectKeepRegisters;
}

//
// EFNhack:  On Alpha the map register buffer HW alignment requirement
//           is always half the allocation size, and since MmAllocateConti-
//           guousMemorySpecifyCache doesn't really allow us to specify an
//           alignment, we need to play games, if IA64 s/g HW has the same
//           issues, then we may want to consider an API that actually uses
//           alignment
//
#define MAX_RETRY_COUNT 4


PSG_MAP_ADAPTER
SgDmapAllocMapAdapter(
    IN ULONG            WindowSize,
    IN ULONG            Align,
    IN PHYSICAL_ADDRESS MinPhysAddr,
    IN PHYSICAL_ADDRESS MaxPhysAddr
    )
/*++

Routine Description:

    This routine allocates a buffer of map registers for use with s/g dma

Arguments:

    WindowSize - Size of DMA Window

    Align - Alignment for map register buffer

    MinPhysAddr - The minimum physical address for the map register buffer

    MaxPhysAddr - The maximum ...
    
Return Value:

    Map register adapter on success, otherwise NULL
    
--*/
{
    ULONG i, j;
    ULONG NumMapRegs;
    ULONG SgMapAdapterSize;
    ULONG MapRegsBufferSize;
    PHYSICAL_ADDRESS AlignReq;
    PHYSICAL_ADDRESS LogicalAddr;
    PSG_MAP_ADAPTER SgMapAdapter;
    PTRANSLATION_ENTRY SgDmaMapRegs;
    PTRANSLATION_ENTRY HackAllocs[MAX_RETRY_COUNT];
    
    AlignReq.QuadPart = Align;

    NumMapRegs = WindowSize / PAGE_SIZE;
    MapRegsBufferSize = NumMapRegs * sizeof(TRANSLATION_ENTRY);
    
    //
    // Allocate map register buffer
    //
    for (i = 0; i < MAX_RETRY_COUNT; i++) {
        HackAllocs[i] =
            MmAllocateContiguousMemorySpecifyCache(MapRegsBufferSize,
                                                   MinPhysAddr,
                                                   MaxPhysAddr,
                                                   AlignReq,
                                                   MmNonCached);
    
        if (HackAllocs[i] == NULL) {
            return NULL;
        }

        LogicalAddr = MmGetPhysicalAddress(HackAllocs[i]);

        //
        // See if the HW alignment is satisfied
        //
        if ((LogicalAddr.LowPart & (AlignReq.LowPart - 1)) == 0) {
            break;
        }
    }

    //
    // We couldn't allocate a suitably aligned buffer, bail...
    //
    if (i == MAX_RETRY_COUNT) {
        for (i = 0; i < MAX_RETRY_COUNT; i++) {
            MmFreeContiguousMemory(HackAllocs[i]);
        }
        return NULL;
    }

    //
    // We successfully allocated a buffer that satisfies our HW alignment
    //
    SgDmaMapRegs = HackAllocs[i];

    //
    // If we had to make more than one allocation to achieve the desired
    // alignment, free hack allocations
    //
    while (i > 0) {
        i--;
        MmFreeContiguousMemory(HackAllocs[i]);
    }

    //
    // Zero the map register buffer
    //
    RtlZeroMemory(SgDmaMapRegs, MapRegsBufferSize);
    
    //
    // The size of the bitmap is the number of bytes required,
    // computed by dividing map registers by 8 ( >> 3), then rounding up
    // to the nearest value divisible by 4 (EFN: go figure???)
    //
    SgMapAdapterSize = sizeof(SG_MAP_ADAPTER);
    SgMapAdapterSize += sizeof(RTL_BITMAP) +
        ((((NumMapRegs + 7) >> 3) + 3) & ~3);

    //
    // Allocate the s/g dma map adapter
    //
    SgMapAdapter = ExAllocatePoolWithTag(NonPagedPool,
                                         SgMapAdapterSize,
                                         SG_DMA_TAG);

    if (SgMapAdapter == NULL) {
        MmFreeContiguousMemory(SgDmaMapRegs);
        return NULL;
    }

    //
    // Initialize the fields within the map adapter structure
    //
    KeInitializeSpinLock(&SgMapAdapter->MapsLock);
    InitializeListHead(&SgMapAdapter->RegsWaitQ);
    
    SgMapAdapter->MapRegsBase = SgDmaMapRegs;
    SgMapAdapter->MaxMapRegs = NumMapRegs;
    SgMapAdapter->MapRegsBitmap = (PRTL_BITMAP)(SgMapAdapter + 1);

    RtlInitializeBitMap(SgMapAdapter->MapRegsBitmap,
                        (PULONG)((PCHAR)(SgMapAdapter->MapRegsBitmap) +
                                 sizeof(RTL_BITMAP)),
                        NumMapRegs);
    RtlClearAllBits(SgMapAdapter->MapRegsBitmap);
    
    SgMapAdapter->WindowSize = WindowSize;

    //
    // Initialize HW register VAs
    //
    for (i = 0; i < SgDmaMaxHwReg; i++) {
        SgMapAdapter->HwRegs[i] = NULL;
    }

    return SgMapAdapter;
}



BOOLEAN
SgDmapAllocMapRegs(
    IN PSG_DMA_ADAPTER SgAdapter,
    IN ULONG           NumMapRegs,
    IN BOOLEAN         MapAdapterLocked,
    IN BOOLEAN         NewAlloc
    )
/*++

Routine Description:

    Allocate the requested number of contiguous map registers from
    the Map adapter.

Arguments:

    AdapterObj - The s/g dma adapter for the device bus corresponding to this
                 request

    NumMapRegs - The number of map registers to allocate

    MapAdapterLocked - Indicates whether the map adapter for this
                       AdapterObj is locked

    NewAlloc - Indicates whether this is a new allocation, or if it
               has been popped off of a queue via free

Return Value:

    The value returned indicates if the map register adapter is busy,    
    the value FALSE is returned if the map registers were allocated,
    otherwise, the AdapterObj is put on the register wait queue for its
    associated map adapter, and TRUE is returned

--*/
{
    ULONG AllocMask;
    BOOLEAN Busy = FALSE;
    ULONG ExtentBegin;
    ULONG HintIndex;
    KIRQL Irql;
    ULONG MapRegsIndex;
    PSG_MAP_ADAPTER SgMapAdapter;

    ASSERT(SgAdapter);

    //
    // Some devices do DMA prefetch, this is bad since it will cause certain
    // chipsets to generate a PFN error because a map register has not been
    // allocated and validated, to fix this, we'll put in a hack, we'll
    // allocate one extra map register and map it to some junk page to avoid
    // this nasty problem
    //
    NumMapRegs += 1;

    SgMapAdapter = SgAdapter->MapAdapter;

    //
    // Lock the map register bit map and the adapter queue in the
    // master adapter object
    //
    if (MapAdapterLocked == FALSE) {
        KeAcquireSpinLock(&SgMapAdapter->MapsLock, &Irql);
    }
    
    MapRegsIndex = MAXULONG;

    if (MapAdapterLocked || IsListEmpty(&SgMapAdapter->RegsWaitQ)) {
        MapRegsIndex = RtlFindClearBitsAndSet(SgMapAdapter->MapRegsBitmap,
                                              NumMapRegs,
                                              0);
    }

    //
    // There were not enough free map registers, queue this request
    // on the map adapter where it will wait until some registers
    // are deallocated
    //
    if (MapRegsIndex == MAXULONG) {

        if (NewAlloc) {
            InsertTailList(&SgMapAdapter->RegsWaitQ,
                           &SgAdapter->MapAdapterQ);            
        } else {
            InsertHeadList(&SgMapAdapter->RegsWaitQ,
                           &SgAdapter->MapAdapterQ);
        }
        
        Busy = TRUE;
    }

    //
    // Unlock the map adapter unless locked by the caller
    //
    if (MapAdapterLocked == FALSE) {
        KeReleaseSpinLock(&SgMapAdapter->MapsLock, Irql);
    }

    //
    // If map registers were allocated, return the index of the first
    // map register in the contiguous extent
    //
    if (Busy == FALSE) {
        SgAdapter->MapRegsBase =
            (PVOID)((PTRANSLATION_ENTRY)SgMapAdapter->MapRegsBase +
                    MapRegsIndex);
    }

    return Busy;                                   
}



IO_ALLOCATION_ACTION
SgDmapAllocRoutine(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp,
    IN PVOID          MapRegsBase,
    IN PVOID          Context
    )
/*++

Routine Description:

    This function is called by SgDmaAllocateAdapterChannel when sufficent
    resources are available to the driver, this routine saves the
    MapRegisterBase, and signals the event passed via context

Arguments:

    DevObj - Contains the pointer where the map register base should be
             stored

    Irp - Unused

    MapRegsBase - Supplied by the I/O subsystem for use in SgDmaMapTransfer

    Context - The event to signal indicating that the AdapterObj has been
    allocated

Return Value:

    DeallocateObjectKeepRegisters - Indicates the adapter should be freed,
                                    and map registers should remain
                                    allocated after return

--*/
{
    UNREFERENCED_PARAMETER(Irp);

    *((PVOID *)DevObj) = MapRegsBase;
    (VOID)KeSetEvent((PKEVENT)Context, 0, FALSE);

    return DeallocateObjectKeepRegisters;
}



VOID
SgDmapFreeMapAdapter(
    PSG_MAP_ADAPTER SgMapAdapter
    )
/*++

Routine Description:

    This routine frees a s/g map adapter and map registers

Arguments:

    SgMapAdapter - S/g dma adapter to free

Return Value:

    None
    
--*/
{
    ASSERT(SgMapAdapter);
    
    MmFreeContiguousMemory(SgMapAdapter->MapRegsBase);
    ExFreePool(SgMapAdapter);
}



VOID
SgDmaPutAdapter(
    IN PADAPTER_OBJECT AdapterObj
    )
/*++

Routine Description:

    This routine frees the s/g DMA adapter ???

Arguments:

    AdapterObj - s/g dma adapter object

Return Value:

    None
    
--*/
{
    SgDmaDebugPrint(SgDmaDebugDispatch,
                    "SgDmaPutAdapter: AdapterObj=%p\n",
                    AdapterObj);
    
    ASSERT(AdapterObj);
    
    ObDereferenceObject(AdapterObj);
}



VOID
SgDmaPutScatterGatherList(
    IN PADAPTER_OBJECT      AdapterObj,
    IN PSCATTER_GATHER_LIST SGList,
    IN BOOLEAN              Write2Dev
    )
/*++

Routine Description:

    This routine frees the adapter and associated resources allocated via
    GetScatterGatherList

Arguments:

    AdapterObj - s/g dma adapter object

    SGList - s/g list

    Write2Dev - TRUE if dma is to the device

Return Value:

    None
  
--*/
{
    PMDL Mdl;
    ULONG Offset;
    ULONG NumPages;
    ULONG MdlLength;
    PUCHAR CurrentVa;
    ULONG TransferLength;
    PTRANSLATION_ENTRY TranslationEntry;
    PDMA_WAIT_CTX_BLOCK WaitBlock = (PVOID)SGList->Reserved;

    ASSERT(AdapterObj);

    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaPutScatterGatherList: AdapterObj=%p\n",
                    AdapterObj);
    
    ASSERT(WaitBlock != NULL);
    
    ASSERT(WaitBlock == CONTAINING_RECORD(SGList,
                                          DMA_WAIT_CTX_BLOCK,
                                          ScatterGather));

    //
    // Setup for the first MDL, we expect the MDL pointer to be pointing
    // at the first used mdl
    //
    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;
    
    ASSERT(CurrentVa >= (PUCHAR)MmGetMdlVirtualAddress(Mdl) && CurrentVa <
           (PUCHAR)MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount);

    MdlLength = Mdl->ByteCount - 
        (ULONG)(CurrentVa - (PUCHAR)MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;
    TranslationEntry = WaitBlock->MapRegsBase;

    //
    // Loop through the used MDLs call IoFlushAdapterBuffers
    //
    while (TransferLength >  0) {      

        if (MdlLength > TransferLength) {
            MdlLength = TransferLength;
        }
        TransferLength -= MdlLength;
        SgDmaFlushAdapterBuffers(AdapterObj,
                                 Mdl,
                                 TranslationEntry,
                                 CurrentVa,
                                 MdlLength,
                                 Write2Dev);

        //
        // Compute the starting offset of the transfer
        //
        Offset = BYTE_OFFSET((PUCHAR)CurrentVa);

        //
        // Compute the number of pages that this transfer spanned
        //
        NumPages = (Offset + MdlLength + PAGE_SIZE - 1) >> PAGE_SHIFT;
        
        //
        // Free up the map registers
        //
        SgDmaFreeMapRegisters(AdapterObj,
                              TranslationEntry,
                              NumPages);
        
        if (Mdl->Next == NULL) {
            break;
        }

        //
        // Advance to the next MDL, update the current VA and the MdlLength
        //
        TranslationEntry +=
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, MdlLength);
        
        if (Mdl->Next == NULL) {
            break;
        }

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
    }

    ExFreePool(WaitBlock);
}



ULONG
SgDmaReadCounter(
    IN PADAPTER_OBJECT AdapterObj
    )
/*++

Routine Description:

    This routine reads the dma counter and returns the number of bytes left
    to be transferred

Arguments:

    AdapterObj - s/g dma adapter object
    
Return Value:

    Number of bytes remaining to transfer
  
--*/
{
    SgDmaDebugPrint(SgDmaDebugInterface,
                    "SgDmaReadCounter: AdapterObj=%p\n",
                    AdapterObj);
    
    ASSERT(AdapterObj);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\hw.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    hw.h

Abstract:

    This module contains platform specific routines for accesing s/g dma HW

Author:

    Eric Nelson (enelson) Aug-10-1999

Environment:

    Kernel mode
    
Revision History:

--*/

#include "sgdma.h"

//
// NOTE: The order here is crutial, and is dictated by the HW register
//       enum
//
static ULONGLONG TsunamiRegs[TSUNAMI_MAX_HW_BUS_COUNT][SgDmaMaxHwReg] = {
    { TSUNAMI_PCHIP_0_TBA0_PHYS,
      TSUNAMI_PCHIP_0_WSBA0_PHYS,
      TSUNAMI_PCHIP_0_WSM0_PHYS,
      TSUNAMI_PCHIP_0_TLBIA_PHYS,
      TSUNAMI_PCHIP_0_TLBIV_PHYS },
    { TSUNAMI_PCHIP_1_TBA0_PHYS,
      TSUNAMI_PCHIP_1_WSBA0_PHYS,
      TSUNAMI_PCHIP_1_WSM0_PHYS,
      TSUNAMI_PCHIP_1_TLBIA_PHYS,
      TSUNAMI_PCHIP_1_TLBIV_PHYS }
};


NTSTATUS
SgDmaHwStart(
    IN ULONG HwBus,
    IN OUT PSG_MAP_ADAPTER SgMapAdapter
    )
/*++

Routine Description:

    This routine starts the s/g DMA HW on a root PCI bus

Arguments:

    HwBus - Describes which _root_ PCI bus to start (not the PCI bus #)

    SgMapAdapter - S/g map adapter allocated to this root

Return Value:

    None
    
--*/
{
#ifdef _WIN64
    ULONG i;
    PHYSICAL_ADDRESS LogicalAddr;
    PHYSICAL_ADDRESS SgDmaHwRegPhysAddr;

    ASSERT(HwBus <= TSUNAMI_MAX_HW_BUS_COUNT);
    
    for (i = 0; i < SgDmaMaxHwReg; i++) {
        SgDmaHwRegPhysAddr.QuadPart = TsunamiRegs[HwBus][i];
        
        SgMapAdapter->HwRegs[i] = MmMapIoSpace(SgDmaHwRegPhysAddr,
                                               DMA_HW_REG_SIZE,
                                               MmNonCached);
        if (SgMapAdapter->HwRegs[i] == NULL) {
            break;
        }
    }

    if (i != SgDmaMaxHwReg) {
        SgDmaDebugPrint(SgDmaDebugHw, "SgDmaHwStart: Could not map reg=%p!\n",
                        SgDmaHwRegPhysAddr.QuadPart);        
        SgDmaHwStop(SgMapAdapter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Grap the physical address of the map register buffer
    //
    LogicalAddr = MmGetPhysicalAddress(SgMapAdapter->MapRegsBase);
    
    //
    // Fire in the hole!
    //
#if DBG
    if (!SgDmaFake) {
#endif // DBG
        *(PULONGLONG)SgMapAdapter->HwRegs[WindowBaseRegVa] = 0; // Stop!
        *(PULONGLONG)SgMapAdapter->HwRegs[WindowBaseRegVa] =
            SgMapAdapter->WindowBase | 3;
        *(PULONGLONG)SgMapAdapter->HwRegs[WindowMaskRegVa] =
            (SgMapAdapter->WindowSize - 1) & ~0xFFFFF;
        *(PULONGLONG)SgMapAdapter->HwRegs[TxBaseAddrRegVa] =
            LogicalAddr.QuadPart;
        
        SgDmaHwTlbFlush(SgMapAdapter);

#if DBG
    }
#endif // DBG    
    
    SgDmaDebugPrint(SgDmaDebugHw,
                    "SgDmaHwStart: WindowBaseReg=%p\n"
                    "              WindowMaskReg=%p\n"
                    "              TxBaseAddrReg=%p\n",
                    *(PULONGLONG)SgMapAdapter->HwRegs[WindowBaseRegVa],
                    *(PULONGLONG)SgMapAdapter->HwRegs[WindowMaskRegVa],
                    *(PULONGLONG)SgMapAdapter->HwRegs[TxBaseAddrRegVa]);

#endif // _WIN64

    return STATUS_SUCCESS;
}



VOID
SgDmaHwStop(
    IN PSG_MAP_ADAPTER SgMapAdapter
    )
/*++

Routine Description:

    This routine frees any HW specific IO resources

Arguments:

    SgMapAdapter - S/g map adapter allocated to this root

Return Value:

    None  

--*/
{
    ULONG i;

    for (i = 0; i < SgDmaMaxHwReg; i++) {

        if (SgMapAdapter->HwRegs[i] != NULL) {            
            MmUnmapIoSpace(SgMapAdapter->HwRegs[i], DMA_HW_REG_SIZE);
            SgMapAdapter->HwRegs[i] = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\dispatch.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dispatch.c    
        
Abstract:

    This module provides IRP dispatching for s/g dma driver

Author:

    Eric Nelson (enelson) 3/16/1999

Revision History:

--*/

#include "sgdma.h"

//
// Local function prototypes
//
NTSTATUS
SgDmaBusInterfaceStdCompletion(
    IN PDEVICE_OBJECT     DevObj,
    IN PIRP               Irp,
    IN PSG_DMA_EXTENSION  SgDmaExt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SgDmaBusInterfaceStdCompletion)
#pragma alloc_text(PAGE, SgDmaDispatchDeviceControl)
#pragma alloc_text(PAGE, SgDmaDispatchPnp)
#endif // ALLOC_PRAGMA

//
// External
//
PSG_MAP_ADAPTER
SgDmapAllocMapAdapter(
    IN ULONG            WindowSize,
    IN ULONG            Align,
    IN PHYSICAL_ADDRESS MinPhysAddr,
    IN PHYSICAL_ADDRESS MaxPhysAddr
    );

VOID
SgDmapFreeMapAdapter(
    PSG_MAP_ADAPTER SgMapAdapter
    );


NTSTATUS
SgDmaBusInterfaceStdCompletion(
    IN PDEVICE_OBJECT    DevObj,
    IN PIRP              Irp,
    IN PSG_DMA_EXTENSION SgDmaExt
    )
/*++

Routine Description:

    This is the completion routine for IRP_MN_QUERY_INTERFACE

    kidnap the HAL's BUS_INTERFACE_STANDARD, and supply our own

Arguments:

    DevObj - Device object

    Irp - IRP_MN_QUERY_INTERFACE, BUS_INTERFACE_STANDARD

    SgDmaExt - s/g dma device extension 

Return Value:

    NTSTATUS
  
--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PBUS_INTERFACE_STANDARD Standard =
        (PBUS_INTERFACE_STANDARD)irpStack->Parameters.QueryInterface.Interface;
   
    PAGED_CODE();

    ASSERT(Standard);
    
    SgDmaDebugPrint(SgDmaDebugDispatch,
                    "SgDmaBusInterfaceStdCompletion: DevObj=%p, Irp=%x, "
                    "SgDmaExt=%p\n",
                    DevObj,
                    irpStack->MinorFunction,
                    SgDmaExt);
    
    //
    // Munge irpStack parameters with our interface
    //
    SgDmaExt->HalGetAdapter        = Standard->GetDmaAdapter; // Save this
    Standard->GetDmaAdapter        = SgDmaGetAdapter;
    Standard->Context              = SgDmaExt;
    Standard->InterfaceReference   = SgDmaInterfaceReference;
    Standard->InterfaceDereference = SgDmaInterfaceDereference;
    
    return STATUS_SUCCESS;
}



NTSTATUS
SgDmaDispatchDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN OUT PIRP       Irp
    )
/*++

Routine Description:

    This is the main dispatch routine for device control IRPs sent to the s/g
    dma driver

Arguments:

    DevObj - Pointer to a s/g dma device object
    
    Irp - Pointer to the device control IRP

Return Value:

    NTSTATUS
    
--*/
{
    PSG_DMA_EXTENSION  SgDmaExt = DevObj->DeviceExtension;
    PIO_STACK_LOCATION irpStack  = IoGetCurrentIrpStackLocation(Irp);
    
    PAGED_CODE();

    ASSERT(SgDmaExt->AttachedDevice != NULL);
    
    SgDmaDebugPrint(SgDmaDebugDispatch,
                    "SgDmaDispatchDeviceControl: DevObj=%p, Irp=%x\n",
                    DevObj,
                    irpStack->MinorFunction);

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(SgDmaExt->AttachedDevice, Irp);
}



NTSTATUS
SgDmaDispatchPnp(
    IN PDEVICE_OBJECT DevObj,
    IN OUT PIRP       Irp
    )
/*++

Routine Description:

    This is the main dispatch routine for PnP IRPs sent to the s/g dma driver

Arguments:

    DevObj - Pointer to a s/g dma device object
    
    Irp - Pointer to the IRP

Return Value:

    NTSTATUS
    
--*/
{
    ULONG HwBus;
    ULONG Count;
    NTSTATUS Status;
    ULONG DmaWindowSize = __1GB;
    PHYSICAL_ADDRESS MinPhysAddr;
    PHYSICAL_ADDRESS MaxPhysAddr;
    
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc = NULL;
        PSG_DMA_EXTENSION SgDmaExt = DevObj->DeviceExtension;
    PIO_STACK_LOCATION    irpStack = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    ASSERT(SgDmaExt->AttachedDevice != NULL);

    SgDmaDebugPrint(SgDmaDebugDispatch,
                    "SgDmaDispatchPnp: DevObj=%p, Irp=%x\n",
                    DevObj,
                    irpStack->MinorFunction);

    switch (irpStack->MinorFunction) {

        case IRP_MN_START_DEVICE:
#if DBG
            if (SgDmaDebug & SgDmaDebugBreak) {
                DbgBreakPoint();
            }
#endif // DBG
            
            Count = 0;
            PartialDesc = RtlUnpackPartialDesc(CmResourceTypeBusNumber,
                                               irpStack->Parameters.StartDevice.AllocatedResources,
                                               &Count);
            
            ASSERT(PartialDesc);

            //
            // Print start Irp bus number info
            //
            SgDmaDebugPrint(SgDmaDebugInit,
                            "SgDmaDispatchPnp: Start Bus=%x, DevObj=%p\n",
                            PartialDesc->u.BusNumber.Start,
                            DevObj);

            //
            // Allocate a s/g dma adapter for this bus
            //
            MinPhysAddr.QuadPart = 0;
            MaxPhysAddr.QuadPart = __1GB;
            SgDmaExt->MapAdapter =
                SgDmapAllocMapAdapter(DmaWindowSize,
                                      DMA_HW_ALIGN(DmaWindowSize),
                                      MinPhysAddr,
                                      MaxPhysAddr);
            
            if (SgDmaExt->MapAdapter == NULL) {
                SgDmaDebugPrint(SgDmaDebugAlways,
                                "SgDmaDispatchPnp: Start failed to allocate "
                                "map adapter!\n");
                
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // EFNhack:  For Alpha/Tsunami-based platforms, I happen to know
            //           that the BIOS reserves the top 2GB of PCI memory
            //           space for DMA, but I have no idea where the
            //           WindowBase could, or should be for x86/IA64-based
            //           platforms...
            //
            SgDmaExt->MapAdapter->WindowBase = __2GB;
            
            //
            // Start the HW
            //
            // EFNhack: On Tsunami, since there are only two root PCI busses,
            //          and since HW bus 0 will always be PCI bus 0, this
            //          simplifies things a lot, but we will need to change
            //          this to use ACPI to communicate this information for
            //          platforms with more than two root busses, and JakeO has
            //          suggested two different approaches using the current
            //          ACPI infrastructure that can be used to accomplish
            //          this, but for now, and until we see real IA64 s/g HW
            //          we'll hack around this problem for dev/test on Alpha
            //
            HwBus  = (PartialDesc->u.BusNumber.Start == 0) ? 0: 1;
            Status = SgDmaHwStart(HwBus, SgDmaExt->MapAdapter);
            
            if (!NT_SUCCESS(Status)) {
                SgDmaDebugPrint(SgDmaDebugAlways,
                                "SgDmaDispatchPnp: Start failed to init dma "
                                "HW!\n");
                SgDmapFreeMapAdapter(SgDmaExt->MapAdapter);
                SgDmaExt->MapAdapter = NULL;
            }
            break;
            
        //
        // Succeed if nobody has an interface
        //
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
            Status = (SgDmaExt->InterfaceCount == 0) ? STATUS_SUCCESS:
                STATUS_UNSUCCESSFUL;
            break;
            
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = STATUS_SUCCESS;
            break;
            
        case IRP_MN_REMOVE_DEVICE:
            
            //
            // Send the Irp down
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(SgDmaExt->AttachedDevice, Irp);

            ASSERT(SgDmaExt->InterfaceCount == 0);

            //
            // Delete ourselves
            //
            if (SgDmaExt->MapAdapter != NULL) {
                SgDmaHwStop(SgDmaExt->MapAdapter);
                SgDmapFreeMapAdapter(SgDmaExt->MapAdapter);
                SgDmaExt->MapAdapter = NULL;
            }
            IoDetachDevice(SgDmaExt->AttachedDevice);
            IoDeleteDevice(DevObj);
            return Status;

        case IRP_MN_QUERY_INTERFACE:

            if (IsEqualGUID(&GUID_BUS_INTERFACE_STANDARD,
                            irpStack->Parameters.QueryInterface.InterfaceType)) {
                
                SgDmaDebugPrint(SgDmaDebugAlways,
                                "SgDmaDispatchPnp: Query Interface "
                                "BUS_INTERFACE_STANDARD, DevObj=%p\n",
                                DevObj);
                
                //
                // We need to filter this Irp on the way back so we can
                // override the HAL's BUS_INTERFACE_STANDARD
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       SgDmaBusInterfaceStdCompletion,
                                       SgDmaExt,
                                       TRUE,
                                       FALSE,
                                       FALSE);
                return IoCallDriver(SgDmaExt->AttachedDevice, Irp);
            }
            Status = STATUS_NOT_SUPPORTED;
            break;
    
        //
        // Not supported
        //
        default:
            Status = STATUS_NOT_SUPPORTED;
            break;
    }

    ASSERT(Status != STATUS_PENDING);
    
    if (Status != STATUS_NOT_SUPPORTED) {
        Irp->IoStatus.Status = Status;
    }

    //
    // Forward to attached device
    //
    if (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED)) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(SgDmaExt->AttachedDevice, Irp);
        
    } else {
        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return Status;
    }
}



NTSTATUS
SgDmaDispatchPower(
    IN PDEVICE_OBJECT DevObj,
    IN OUT PIRP       Irp
    )
/*++

Routine Description:

    This is the main dispatch routine for Power IRPs sent to the s/g dma driver

Arguments:

    DevObj - Pointer to a s/g dma device object
    
    Irp - Pointer to the power IRP

Return Value:

    NTSTATUS
    
--*/
{
    PSG_DMA_EXTENSION  SgDmaExt  = DevObj->DeviceExtension;
    PIO_STACK_LOCATION irpStack  = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(SgDmaExt->AttachedDevice != NULL);
    
    SgDmaDebugPrint(SgDmaDebugDispatch,
                    "SgDmaDispatchPower: DevObj=%p, Irp=%x\n",
                    DevObj,
                    irpStack->MinorFunction);

    //
    // Forward to attached device
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(SgDmaExt->AttachedDevice, Irp);
}



PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN  UCHAR             Type,
    IN  PCM_RESOURCE_LIST ResList,
    IN  OUT PULONG        Count
    )
/*++

Routine Description:

    Pulls out a pointer to the partial descriptor you're interested in

Arguments:

    Type - CmResourceTypePort, ...

    ResList - The list to search

    Count - Points to the index of the partial descriptor you're looking
            for, gets incremented if found, i.e., start with *Count = 0,
            then subsequent calls will find next partial, make sense?

Return Value:

    Pointer to the partial descriptor if found, otherwise NULL

--*/
{
    ULONG i, j, hit = 0;

    for (i = 0; i < ResList->Count; i++) {
        for (j = 0; j < ResList->List[i].PartialResourceList.Count; j++) {
            if (ResList->List[i].PartialResourceList.PartialDescriptors[j].Type == Type) {
                if (hit == *Count) {
                    (*Count)++;
                    return &ResList->List[i].PartialResourceList.PartialDescriptors[j];
                } else {
                    hit++;
                }
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    init.c
    
Abstract:

    Initialization routines for the s/g dma filter driver

Author:

    Eric Nelson (enelson) 3/14/1999
  
Revision History:

--*/

#include "sgdma.h"

//
// Local function prototypes
//
NTSTATUS
SgDmaAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT PhysDevObj
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    );

//
// Globals
//
PDRIVER_OBJECT SgDmaDriver       = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SgDmaAddDevice)
#pragma alloc_text(PAGE, DriverEntry)
#endif // ALLOC_PRAGMA



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    )
/*++

Routine Description:

    Initialize the s/g dma driver

Arguments:

    DrvObj - Points to the driver object created by the system
    
    RegistryPath - Points to our unicode registry service path

Return Value:

    NT status    

--*/

{
    PAGED_CODE();

    SgDmaDebugPrint(SgDmaDebugInit, "SgDmaDriverEntry: DrvObj=%p\n", DrvObj);

    SgDmaDriver = DrvObj;

    DrvObj->DriverExtension->AddDevice = SgDmaAddDevice;
    DrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        SgDmaDispatchDeviceControl;
    DrvObj->MajorFunction[IRP_MJ_PNP] = SgDmaDispatchPnp;
    DrvObj->MajorFunction[IRP_MJ_POWER] = SgDmaDispatchPower;
    
    return STATUS_SUCCESS;
}



NTSTATUS
SgDmaAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT PhysDevObj
    )
/*++

Routine Description:

    Creates a s/g dma device

Arguments:

    DrvObj - Our driver object
    
    PhysDevObj - The physical device object for which we will create a
                 functional device object

Return Value:

    NTSTATUS    
    
--*/
{
    NTSTATUS           Status;
    PDEVICE_OBJECT     DevObj;
    PSG_DMA_EXTENSION  SgDmaExt;

    PAGED_CODE();

    SgDmaDebugPrint(SgDmaDebugInit,
                    "SgDmaAddDevice: DrvObj=%p, PhysDevObj=%p ",
                    DrvObj,
                    PhysDevObj);

    //
    // Create device
    //
    Status = IoCreateDevice(DrvObj,
                            sizeof(SG_DMA_EXTENSION),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            0,
                            FALSE,
                            &DevObj);
    if (!NT_SUCCESS(Status)) {
        SgDmaDebugPrint(SgDmaDebugAlways,
                        "\nSgDmaAddDevice: IoCreateDevice failed, status=%x\n",
                        Status);
        return Status;
    }

    //
    // Initialize device extension
    //
    SgDmaExt = DevObj->DeviceExtension;
    SgDmaExt->InterfaceCount = 0;
    SgDmaExt->MapAdapter     = NULL;

    //
    // Attach to the supplied PDO
    //
    SgDmaExt->AttachedDevice =
        IoAttachDeviceToDeviceStack(DevObj, PhysDevObj);
    if (SgDmaExt->AttachedDevice == NULL) {
        SgDmaDebugPrint(SgDmaDebugAlways,
                        "\nSgDmaAddDevice: IoAttachDeviceToDeviceStack(%p, %p)"
                        " failed!\n",
                        DevObj,
                        PhysDevObj);
        IoDeleteDevice(DevObj);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DevObj->Flags &= ~DO_DEVICE_INITIALIZING;

    SgDmaDebugPrint(SgDmaDebugInit,
                    "SgDmaExt=%p\n",
                    SgDmaExt);
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\filters\sgdma\sgdma.h ===
/*++

Copyright (c) 1999 Microsoft Corporation    
    
Module Name:

    sgdma.h

Abstract:
    
    Definitions for the s/g dma driver

Author:

    Eric Nelson (enelson) 3/14/1999

Revision History:

--*/

//
// SgDma is a driver, ensure correct linkage
//
#define _NTDRIVER_

#include "ntddk.h"
#include "hw.h"
#include "debug.h"
#include "initguid.h"
#include "wdmguid.h"

#ifndef __SGDMA_H__
#define __SGDMA_H__

//
// The following structures define the s/g dma resources we grant to
// devices requesting 32-bit, PCI, bus-master, dma resources on a
// given bus
//
// We assume the HAL will provide any legacy, and/or 64-bit resources
//

//
// We allocate one map register adapter for each root PCIBus and it implements
// a "DMA Window" at 2GB (logical), and consumes the upper 1GB of PCI memory
// space, although the code is dynamic, and will allow any _Size window to be
// created at any _Base, these are the values we use for development on
// Alpha/Tsunami
//
// Fortunately AlphaBIOS (Tsunami Platforms) assignes PCI device memory from
// 0 .. 2GB - 1, and leaves 2GB .. 4GB - 1 for DMA
//
// Also noteworth on Alpha is the fact that this 1GB DMA window requires
// a 1MB map register allocation per root PCI bus that must be naturally
// aligned
//
typedef struct _SG_MAP_ADAPTER {

    //
    // Access control for allocating map registers, MapsLock guarantees
    // exclusive access to this adapter
    //
    KSPIN_LOCK MapsLock;

    //
    // RegsWaitQ is a list of devices waiting for map registers on this
    // root bus, or any child busses
    //
    LIST_ENTRY RegsWaitQ;

    //
    // MapRegsBase is the base address of the s/g map register allocation
    // for this root bus
    //
    PVOID MapRegsBase;

    //
    // MaxMapRegs is the total number of s/g map registers available for use
    // on this root bus, including all child busses
    //
    ULONG MaxMapRegs;

    //
    // MapRegsBitmap is the allocation bitmap we use to track s/g map
    // register usage on this root bus, including all child busses
    //
    PRTL_BITMAP MapRegsBitmap;

    //
    // WindowSize is the size of the DMA window in bytes, and WindowBase is
    // the logical base address of the DMA window controlled by this adapter
    //
    ULONG WindowSize;
    ULONG WindowBase;

    //
    // S/G DMA HW registers
    //
    PVOID HwRegs[SgDmaMaxHwReg];

} SG_MAP_ADAPTER, *PSG_MAP_ADAPTER;

//
// We allocate one s/g DMA adapter per device, and the maximum map registers
// we will ever allocate to the device is min(1/4 * total map registers for
// this root bus, including any children, and the maximum transfer length
// passed to our GetAdapter routine via device descriptor)
//
typedef struct _SG_DMA_ADAPTER {

    DMA_ADAPTER DmaHeader; // hal.h

    //
    // The map register adapter that controls the map registers
    // corresponding to this root bus, including any child busses
    //
    PSG_MAP_ADAPTER MapAdapter;

    //
    // The maximum map registers we'll ever allocate to this device
    //
    ULONG DeviceMaxMapRegs;

    //
    // The map registers currently allocated to this adapter, the base
    // address and the number- the number will be the number desired for
    // allocation if this adapter is waiting on the map register queue
    //
    PVOID MapRegsBase;
    ULONG MapRegsAlloc;

    //
    // This queue is for devices trying to all allocate this adapter
    //
    KDEVICE_QUEUE AdapterQ;

    //
    // The wait context block of the driver that has currently allocated
    // the adapter
    //
    struct _WAIT_CONTEXT_BLOCK *CurrentWcb;

    //
    // The list entry used when this adapter is queued to a map adapter,
    // waiting for map registers
    //
    LIST_ENTRY MapAdapterQ;

} SG_DMA_ADAPTER, *PSG_DMA_ADAPTER;

//
// S/G dma device extension
//
typedef struct _SG_DMA_EXTENSION {
    PDEVICE_OBJECT   AttachedDevice;
    ULONG            InterfaceCount;
    PSG_MAP_ADAPTER  MapAdapter;
    PGET_DMA_ADAPTER HalGetAdapter;
} SG_DMA_EXTENSION, *PSG_DMA_EXTENSION;

#define SG_DMA_BUS_INTERFACE_STD_VER 1

#define ADAPT2SG(X) ((PSG_DMA_ADAPTER)(X))

#define SG2ADAPT(X) ((PADAPTER_OBJECT)(X))

#define SG2DMA(X) ((PDMA_ADAPTER)(X))

#define SG_DMA_BAD 0xBADCEEDE

#define SG_DMA_TAG 'AmdS'

typedef struct _DMA_WAIT_CTX_BLOCK {
    PMDL Mdl;
    PVOID MapRegsBase;
    PVOID CurrentVa;
    ULONG Length;
    union {
        struct {
            WAIT_CONTEXT_BLOCK Wcb;
            PDRIVER_LIST_CONTROL DriverExecRoutine;
            PVOID DriverCtx;
            PIRP CurrentIrp;
            PADAPTER_OBJECT AdapterObj;
            BOOLEAN Write2Dev;
        };
        SCATTER_GATHER_LIST ScatterGather;
    };
} DMA_WAIT_CTX_BLOCK, *PDMA_WAIT_CTX_BLOCK;

//
// This constant represents the average number of PCI devices we expect
// to see on a normal root PCIBus, we use it as a guide in determining a
// fair number for the maximum map registers we allow a particular device
//
// For example, if there are 800 map registers on a particular root bus, we
// will suggest that a device on this bus can use no more than
// 800 / AVG_ROOT_BUS_DEV_COUNT
//
#define AVG_ROOT_BUS_DEV_COUNT 4

//
// Local function prototypes
//
NTSTATUS
SgDmaDispatchDeviceControl(
    IN PDEVICE_OBJECT DevObj,
    IN OUT PIRP       Irp
    );

NTSTATUS
SgDmaDispatchPnp(
    IN PDEVICE_OBJECT DevObj,
    IN OUT PIRP       Irp
    );

NTSTATUS
SgDmaDispatchPower(
    IN PDEVICE_OBJECT DevObj,
    IN OUT PIRP       Irp
    );

PDMA_ADAPTER
SgDmaGetAdapter(
    IN PVOID               Context,
    IN PDEVICE_DESCRIPTION DevDesc,
    OUT PULONG             NumMapRegs
    );

VOID
SgDmaInterfaceDereference(
    IN PSG_DMA_EXTENSION SgExtension
    );

VOID
SgDmaInterfaceReference(
    IN PSG_DMA_EXTENSION SgExtension
    );

PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN  UCHAR             Type,
    IN  PCM_RESOURCE_LIST ResList,
    IN  OUT PULONG        Count
    );

//
// EFNhack: There's no convenient file to include to access these APIs so
//          we'll swipe 'em for now...
//
// Object Manager types
//
#if 1
extern POBJECT_TYPE *IoAdapterObjectType;

NTKERNELAPI
NTSTATUS
ObCreateObject(
    IN KPROCESSOR_MODE ProbeMode,
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN KPROCESSOR_MODE OwnershipMode,
    IN OUT PVOID ParseContext OPTIONAL,
    IN ULONG ObjectBodySize,
    IN ULONG PagedPoolCharge,
    IN ULONG NonPagedPoolCharge,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN PACCESS_STATE PassedAccessState OPTIONAL,
    IN ACCESS_MASK DesiredAccess OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PVOID *NewObject OPTIONAL,
    OUT PHANDLE Handle
    );

#endif // 0

#endif // __SGDMA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftasr\ftasr.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ftasr.cpp

Abstract:

    Implementation of class CFtasrApp
    This is the application class of FTASR

Author:

    Cristian Teodorescu     3-March-1999      

Notes:

Revision History:    

--*/

#include "stdafx.h"
#include "ftasr.h"
#include "ftasrdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CFtasrApp

BEGIN_MESSAGE_MAP(CFtasrApp, CWinApp)
     //{{AFX_MSG_MAP(CFtasrApp)
     //}}AFX_MSG
     ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFtasrApp construction

CFtasrApp::CFtasrApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CFtasrApp object

CFtasrApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CFtasrApp initialization

BOOL CFtasrApp::InitInstance()
{
     AfxEnableControlContainer();

     // Standard initialization

#ifndef _WIN64
// Sundown: ctl3d was intended for NT3.51
#ifdef _AFXDLL
     Enable3dControls();               // Call this when using MFC in a shared DLL
#else
     Enable3dControlsStatic();     // Call this when linking to MFC statically
#endif
#endif // !_WIN64

     CFtasrDlg dlg;
     m_pMainWnd = &dlg;
     INT_PTR nResponse = dlg.DoModal();

     exit((INT)nResponse) ;
     return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftasr\ftasr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ftasr.cpp

Abstract:

    Main header file for application FTASR
    Declaration of class CFtasrApp    

Author:

    Cristian Teodorescu     3-March-1999      

Notes:

Revision History:    

--*/

#if !defined(AFX_FTASR_H__A507D047_3854_11D2_87D7_006008A71E8F__INCLUDED_)
#define AFX_FTASR_H__A507D047_3854_11D2_87D7_006008A71E8F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CFtasrApp:
// See ftasr.cpp for the implementation of this class
//

class CFtasrApp : public CWinApp
{
public:
	CFtasrApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFtasrApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CFtasrApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FTASR_H__A507D047_3854_11D2_87D7_006008A71E8F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftasr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ftasr.rc
//
#define IDS_BACKUP_STATE                1
#define IDS_RESTORE_STATE               2
#define IDS_REGISTER_STATE              3
#define IDS_ERROR_TITLE                 4
#define IDS_ERROR_USAGE                 5
#define IDS_ERROR_ADD_TO_COMMANDS       6
#define IDS_ERROR_PRINT_VOLUME_NAMES    7
#define IDS_ERROR_PRINT_VOLUME_INFO     8
#define IDS_ERROR_RESTORE_VOLUME_NAMES  9
#define IDS_ERROR_INVALID_BACKUP        10
#define IDS_ERROR_UNEXPECTED            11
#define IDS_ERROR_RESTORE_VOLUME        12
#define IDS_ERROR_PARTITION_NOT_FOUND   13
#define IDS_ERROR_CHECK_FAILURE         14
#define IDS_ERROR_UNSUPPORTED_CONFIGURATION 15
#define IDS_ERROR_FTPARTITION_DETECTED  16
#define IDS_ERROR_SWP_DETECTED          17
#define IDS_ERROR_REDISTRIBUTION_DETECTED 18
#define IDS_ERROR_NOT_BOOT_SYSTEM_MIRROR 19
#define IDS_ERROR_BOOT_SYSTEM_NOT_MIRROR 20
#define IDS_ERROR_STACK                 21
#define IDS_ERROR_VOLUME_SET_SIZE       22
#define IDS_ERROR_STRIPE_SET_SIZE       23
#define IDS_ERROR_MIRROR_SET_SIZE       24
#define IDS_ERROR_MIRRORS_ON_DIFFERENT_DISKS 25
#define IDS_ERROR_MIRRORS_SIZES         26
#define IDS_ERROR_ONE_MIRROR            27
#define IDS_ERROR_OPEN_VOLUME           28
#define IDS_ERROR_MORE_FORMATTED        29
#define IDS_ERROR_MIRROR_BOOT_VOLUME    30
#define IDD_FTASR_DIALOG                127
#define IDR_MAINFRAME                   128
#define IDC_PROGRESS                    1000
#define IDC_PROGRESS_TEXT               1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftasr\ftasrdlg.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ftasr.cpp

Abstract:

    Declaration of class CFtasrDlg

    This class provides a GUI interface for the FTASR process.
    It also implements the 3 main FTASR operations:
        "register"  - register FTASR as a BackupRestore command
        "backup"    - save the current FT hierarchy state in dr_state.sif file
        "restore"   - restore the FT hierarchy as it is in dr_state.sif file

Author:

    Cristian Teodorescu     3-March-1999      

Notes:

Revision History:    

--*/

#if !defined(AFX_FTASRDLG_H__A507D049_3854_11D2_87D7_006008A71E8F__INCLUDED_)
#define AFX_FTASRDLG_H__A507D049_3854_11D2_87D7_006008A71E8F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <ftapi.h>
#include <winioctl.h>

#define DISPLAY_HELP    0
#define BACKUP_STATE    1
#define RESTORE_STATE   2
#define REGISTER_STATE  3

#define MAX_STACK_DEPTH     100

/////////////////////////////////////////////////////////////////////////////
// CFtasrDlg dialog

class CFtasrDlg : public CDialog
{

    enum
    {
        WM_WORKER_THREAD_DONE = WM_USER + 1,
        WM_UPDATE_STATUS_TEXT,
    } ;

// Construction
public:
	CFtasrDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CFtasrDlg)
	enum { IDD = IDD_FTASR_DIALOG };
	CProgressCtrl	m_Progress;
    //}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFtasrDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFtasrDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	
    static long DoWork(CFtasrDlg *_this) ;
	
    UINT  ParseCommandLine();

    // Main operations
    long DoBackup();
	long DoRestore() ;
    long DoRegister();
    
    // Methods used in the Backup process:

    long AddToCommands(
        IN FILE* Output
        );
    
    long PrintOutVolumeNames(
        IN FILE* Output, 
        IN FT_LOGICAL_DISK_ID  RootLogicalDiskId
        );

    long PrintOutDiskInfo(
        IN FILE* Output, 
        IN FT_LOGICAL_DISK_ID  LogicalDiskId
        );

#ifdef CHECK_UNSUPPORTED_CONFIG

    // Methods used to check for FT configurations not supported by FTASR

    long CheckForUnsupportedConfig(
        IN DWORD                NumDisks, 
        IN PFT_LOGICAL_DISK_ID  DiskId
        );

    long IsSystemOrBootVolume(
        IN  FT_LOGICAL_DISK_ID  DiskId,
        OUT PBOOL               IsSystem,
        OUT PBOOL               IsBoot
        );

    long GetDiskGeometry(
        ULONG           DiskNumber,
        PDISK_GEOMETRY  Geometry
        );

#endif  // #ifdef CHECK_UNSUPPORTED_CONFIG

    // Methods used in the Restore process:

    long Restore(
        IN FILE* Input
        );

    VOID LinkVolumeNamesToLogicalDisk(
        IN  PWCHAR*             VolumeNames,
        IN  DWORD               NumNames,
        IN  FT_LOGICAL_DISK_ID  LogicalDiskId
        );

    FT_LOGICAL_DISK_ID BuildFtDisk(
        IN      FILE*               Input,
        IN OUT  PFT_LOGICAL_DISK_ID ExpectedPath,
        IN      WORD                ExpectedPathSize,
        IN      BOOL                AllowBreak,
        OUT     PBOOL               Existing,               /* OPTIONAL */
        OUT     PBOOL               Overwriteable           /* OPTIONAL */
        );

    FT_LOGICAL_DISK_ID CreateFtPartition(
        IN  ULONG       Signature,
        IN  LONGLONG    Offset,
        IN  LONGLONG    Length,
        OUT PBOOL       Overwriteable
        );

    BOOL QueryPartitionInformation(
        IN  HANDLE      Handle,
        OUT PDWORD      Signature,
        OUT PLONGLONG   Offset,
        OUT PLONGLONG   Length
        );
    
    BOOL GetPathFromLogicalDiskToRoot(
        IN  FT_LOGICAL_DISK_ID  LogicalDiskId, 
        OUT PFT_LOGICAL_DISK_ID Path, 
        OUT PWORD               PathSize
        );

    BOOL GetParentLogicalDiskInVolume(
        IN  FT_LOGICAL_DISK_ID  VolumeId,
        IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
        OUT PFT_LOGICAL_DISK_ID ParentId    
        );

    BOOL FtGetParentLogicalDisk(
        IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
        OUT PFT_LOGICAL_DISK_ID ParentId    
        );

    // Display error messages
    void DisplayError (const CString& ErrorMsg);
    void DisplaySystemError (DWORD ErrorCode);
    void DisplayResourceError (DWORD ErrorId);
    void DisplayResourceSystemError (DWORD ErrorId, DWORD ErrorCode);
    void DisplayResourceResourceError (DWORD ErrorId1, DWORD ErrorId2);

protected:    
    HICON m_hIcon;

    HANDLE  m_Thread ;
    DWORD   m_EndStatusCode;
    CString m_StatusText;

	DECLARE_MESSAGE_MAP()

     // manually added message-handler 
     afx_msg LRESULT OnWorkerThreadDone( WPARAM wparam, LPARAM lparam ) ;
     afx_msg LRESULT OnUpdateStatusText( WPARAM wparam, LPARAM lparam ) ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_FTASRDLG_H__A507D049_3854_11D2_87D7_006008A71E8F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftasr\ftasrdlg.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ftasr.cpp

Abstract:

    Implementation of class CFtasrDlg

    This class provides a GUI interface for the FTASR process.
    It also implements the 3 main FTASR operations:
        "register"  - register FTASR as a BackupRestore command
        "backup"    - save the current FT hierarchy state in dr_state.sif file
        "restore"   - restore the FT hierarchy as it is in dr_state.sif file

Author:

    Norbert Kusters
    Cristian Teodorescu     3-March-1999      

Notes:

Revision History:    

--*/


#include "stdafx.h"
#include "ftasr.h"
#include "ftasrdlg.h"

#include <mountmgr.h>
#include <ntddft2.h>
#include <winbase.h>
#include <winioctl.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

ULONG DbgPrint(PWSTR Format, ...)
{
    WCHAR achMsg[256];
    va_list vlArgs;

    va_start(vlArgs, Format);
    _vsnwprintf(achMsg, sizeof(achMsg), Format, vlArgs);
    va_end(vlArgs);
    OutputDebugString(achMsg);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFtasrDlg dialog

CFtasrDlg::CFtasrDlg(
    CWnd* pParent /*=NULL*/
    )
     : CDialog(CFtasrDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CFtasrDlg)
    //}}AFX_DATA_INIT
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void 
CFtasrDlg::DoDataExchange(
    CDataExchange* pDX
    )
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFtasrDlg)
    DDX_Control(pDX, IDC_PROGRESS, m_Progress);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFtasrDlg, CDialog)
    //{{AFX_MSG_MAP(CFtasrDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    //}}AFX_MSG_MAP

    // manually added message handlers (for user-defined messages) should be added OUTSIDE
    // the AFX_MSG_MAP part above

    ON_MESSAGE( WM_WORKER_THREAD_DONE, OnWorkerThreadDone )
    ON_MESSAGE( WM_UPDATE_STATUS_TEXT, OnUpdateStatusText )


END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFtasrDlg message handlers

BOOL 
CFtasrDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    SetIcon(m_hIcon, TRUE);               // Set big icon
    SetIcon(m_hIcon, FALSE);          // Set small icon

    // initialize the progress range and start posiiton
    m_Progress.SetRange(0, 100 );
    m_Progress.SetPos( 0 ) ;

    DWORD dummy ;

    // Launch the worker thread.
    CreateThread(NULL,0, (LPTHREAD_START_ROUTINE) CFtasrDlg::DoWork,this,0,&dummy ) ;

    return TRUE;  // return TRUE  unless you set the focus to a control
}

LRESULT 
CFtasrDlg::OnWorkerThreadDone( 
    WPARAM wparam, 
    LPARAM lparam 
    )
{
    EndDialog( m_EndStatusCode ) ;
    return 0 ;
}


LRESULT 
CFtasrDlg::OnUpdateStatusText( 
    WPARAM wparam, 
    LPARAM lparam 
    )
{
    SetDlgItemText( IDC_PROGRESS_TEXT, m_StatusText ) ;    
    return 0 ;
}

long 
CFtasrDlg::DoWork( 
    CFtasrDlg *_this
    )
{
    UINT operation ;

    operation = _this->ParseCommandLine();
     //((CFtasrDlg *)_this)->m_drState = NULL ;

    _this->m_EndStatusCode = 0 ;

    switch( operation ) {

        case DISPLAY_HELP :
            _this->m_EndStatusCode = 2;
            break; 

        case BACKUP_STATE:
            _this->m_EndStatusCode = _this->DoBackup();
            break ;

        case RESTORE_STATE :
            _this->m_EndStatusCode = _this->DoRestore();
            break ;          

        case REGISTER_STATE :
            _this->m_EndStatusCode = _this->DoRegister();
            break ;                      
     }
     
     _this->PostMessage( WM_WORKER_THREAD_DONE, 0, 0 ) ;

     return 0 ;           
}

long 
CFtasrDlg::DoBackup()
{
    BOOL                b;
    DWORD               numDisks, i;
    PFT_LOGICAL_DISK_ID diskId;
    FILE*               output;
    long                r;
    CHAR*               windir;
    CHAR                fileName[MAX_PATH];

    m_StatusText.LoadString( IDS_BACKUP_STATE );
    PostMessage( WM_UPDATE_STATUS_TEXT );

    b = FtEnumerateLogicalDisks(0, NULL, &numDisks);
    if (!b) {
        r = GetLastError();
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_INFO, r);
        return r;
    }

    m_Progress.SetStep(100/(numDisks+3));
    
    diskId = (PFT_LOGICAL_DISK_ID)LocalAlloc(0, numDisks*sizeof(FT_LOGICAL_DISK_ID));
    if (!diskId) {
        r = GetLastError();
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_INFO, r);
        return r;
    }

    b = FtEnumerateLogicalDisks(numDisks, diskId, &numDisks);
    if (!b) {
        r = GetLastError();
        LocalFree(diskId);
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_INFO, r);
        return r;
    }

#ifdef CHECK_UNSUPPORTED_CONFIG
    r = CheckForUnsupportedConfig(numDisks, diskId);
    if (r != ERROR_SUCCESS) {
        LocalFree(diskId);
        // The error message was already displayed in CheckForUnsupportedConfig
        return r;
    }
#endif

    m_Progress.StepIt();
    Sleep(300);
    
    windir = getenv("windir");
    strcpy(fileName, windir);
    strcat(fileName, "\\repair\\dr_state.sif");
    output = fopen(fileName, "r+");
    if (!output) {
        LocalFree(diskId);
        DisplaySystemError(ERROR_FILE_NOT_FOUND);
        return ERROR_FILE_NOT_FOUND;
    }

    m_Progress.StepIt();
    Sleep(300);
    
    r = AddToCommands(output);
    if (r != ERROR_SUCCESS) {
        fclose(output);
        LocalFree(diskId);
        DisplayResourceError(IDS_ERROR_ADD_TO_COMMANDS);
        return r;
    }

    if (fseek(output, 0, SEEK_END)) {
        fclose(output);
        LocalFree(diskId);
        DisplaySystemError(ERROR_INVALID_FUNCTION);
        return ERROR_INVALID_FUNCTION;
    }

    fprintf(output, "\n[FT.VolumeState]\n");
    fprintf(output, "%lu\n", numDisks);

    m_Progress.StepIt();
    Sleep(300);
    
    for (i = 0; i < numDisks; i++) {
        
        r = PrintOutVolumeNames(output, diskId[i]);
        if (r != ERROR_SUCCESS) {
            fclose(output);
            LocalFree(diskId);
            // The error message was already displayed in PrintOutVolumeNames
            return r;
        }
        
        r = PrintOutDiskInfo(output, diskId[i]);
        if (r != ERROR_SUCCESS) {
            fclose(output);
            LocalFree(diskId);
            // The error message was already displayed in PrintOutDiskInfo
            return r;
        }

        m_Progress.StepIt();
        Sleep(300);        
    }

    fclose(output);
    LocalFree(diskId);
    
    m_Progress.SetPos(101);
    return ERROR_SUCCESS;
}

long 
CFtasrDlg::DoRestore()
{
    FILE*   input;
    CHAR*   windir;
    CHAR    fileName[MAX_PATH];
    CHAR    string[MAX_PATH];
    int     result;

    m_StatusText.LoadString( IDS_RESTORE_STATE );
    PostMessage( WM_UPDATE_STATUS_TEXT );
    
    windir = getenv("windir");
    strcpy(fileName, windir);
    strcat(fileName, "\\repair\\dr_state.sif");
    input = fopen(fileName, "r");
    if (!input) {
        DisplaySystemError(ERROR_FILE_NOT_FOUND);
        return ERROR_FILE_NOT_FOUND;
    }

    for (;;) {

        if (!fgets(string, MAX_PATH, input)) {
            fclose(input);
            DbgPrint(L"ftasr: Section [FT.VolumeState] not found\n"); 
            m_Progress.SetPos(101);
            Sleep(300);
            return ERROR_SUCCESS;
        }

        if (!strncmp(string, "[FT.VolumeState]", 16)) {
            break;
        }
    }

    result = Restore(input);
    
    fclose(input);
    return result;    
}

long 
CFtasrDlg::DoRegister()
{
    int     r;
    HKEY    key;

    m_StatusText.LoadString( IDS_REGISTER_STATE ) ;
    PostMessage( WM_UPDATE_STATUS_TEXT ) ;

    
    r = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       L"SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\AsrCommands",
                       0, NULL, 0, KEY_SET_VALUE, NULL, &key, NULL);
    if (r != ERROR_SUCCESS) {
        DisplaySystemError(r);
        return r;
    }
    
    m_Progress.SetPos(50);
    Sleep(300) ;

    r = RegSetValueEx(key, L"FT Volumes Recovery", 0, REG_SZ, (CONST BYTE*) L"ftasr backup",
                      26);
    if (r != ERROR_SUCCESS) {
        DisplaySystemError(r);
        return r;
    }
    
    m_Progress.SetPos(101);
    Sleep(300) ;

    return r;

}

UINT 
CFtasrDlg::ParseCommandLine() 
{
    CString cmd;
    
    cmd = GetCommandLine() ;
    cmd.MakeLower( ) ;
    if (cmd.Find(TEXT("backup") ) != -1) {
        return BACKUP_STATE ;

    } else if (cmd.Find(TEXT("restore")) != -1) {
        return RESTORE_STATE ;

    } else if (cmd.Find(TEXT("register")) != -1) {
        return REGISTER_STATE;

    }

    CString error_msg ;
    
    error_msg.LoadString(IDS_ERROR_USAGE);
    DisplayError(error_msg);
    
    return DISPLAY_HELP;
}

void 
CFtasrDlg::DisplayError(
    const CString& ErrorMsg
    )
{
    CString title;

    title.LoadString(IDS_ERROR_TITLE);
    ::MessageBox(m_hWnd, ErrorMsg, title, MB_OK);
}

void 
CFtasrDlg::DisplaySystemError(
    DWORD ErrorCode
    )
{
    CString title;
    WCHAR   messageBuffer[MAX_PATH];
    
    title.LoadString(IDS_ERROR_TITLE);

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ErrorCode,
                  0, messageBuffer, MAX_PATH, NULL);
            
    ::MessageBox(m_hWnd, messageBuffer, title, MB_OK);
}

void 
CFtasrDlg::DisplayResourceError(
    DWORD ErrorId
    )
{
    CString title, errorMsg;

    title.LoadString(IDS_ERROR_TITLE);
    errorMsg.LoadString(ErrorId);

    ::MessageBox(m_hWnd, errorMsg, title, MB_OK);
}

void 
CFtasrDlg::DisplayResourceSystemError(
    DWORD ErrorId,
    DWORD ErrorCode
    )
{
    CString title, errorMsg;
    WCHAR   messageBuffer[MAX_PATH];

    title.LoadString(IDS_ERROR_TITLE);
    errorMsg.LoadString(ErrorId);

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ErrorCode,
                  0, messageBuffer, MAX_PATH, NULL);

    errorMsg += messageBuffer;

    ::MessageBox(m_hWnd, errorMsg, title, MB_OK);

}

void 
CFtasrDlg::DisplayResourceResourceError(
    DWORD ErrorId1,
    DWORD ErrorId2
    )
{
    CString title, errorMsg1, errorMsg2;
    
    title.LoadString(IDS_ERROR_TITLE);
    errorMsg1.LoadString(ErrorId1);
    errorMsg2.LoadString(ErrorId2);
    
    errorMsg1 += errorMsg2;

    ::MessageBox(m_hWnd, errorMsg1, title, MB_OK);

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


long
CFtasrDlg::AddToCommands(
    FILE*   Output
    )

/*++

Routine Description:

    This routine registers ftasr in the "Commands" section of
    the ASR backup file

Arguments:

    Output          - Supplies the backup file open in write mode

Return Value:

    ERROR_SUCCESS if the function succeeded. Other error codes for failure

--*/

{
    CHAR    string[MAX_PATH];
    CHAR    lastString[MAX_PATH];
    int     c, nextNumber;
    long    position, endPosition;
    PCHAR   buffer;
    size_t  amountRead;
    long    r;

    for (;;) {

        if (!fgets(string, MAX_PATH, Output)) {
            return ERROR_INVALID_DATA;
        }

        if (!strncmp(string, "[COMMANDS]", 10)) {
            break;
        }
    }

    strcpy(lastString, "");

    nextNumber = 1;
    for (;;) {

        c = getc(Output);
        ungetc(c, Output);

        if (c == '[') {
            break;
        }

        if (!fgets(string, MAX_PATH, Output)) {
            return ERROR_INVALID_DATA;
        }

        if (string[0] >= '0' && string[0] <= '9') {
            nextNumber = string[0] - '0' + 1;
        }
    }

    position = ftell(Output);

    r = fseek(Output, 0, SEEK_END);
    if (r) {
        return r;
    }

    endPosition = ftell(Output);

    r = fseek(Output, position, SEEK_SET);
    if (r) {
        return r;
    }

    buffer = (PCHAR)LocalAlloc(0, endPosition - position + 1);
    if (!buffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    amountRead = fread(buffer, 1, endPosition - position + 1, Output);
    if (!amountRead) {
        return ERROR_INVALID_DATA;
    }

    r = fseek(Output, position + 28, SEEK_SET);
    if (r) {
        return r;
    }

    if (fwrite(buffer, 1, amountRead, Output) != amountRead) {
        return ERROR_INVALID_DATA;
    }

    r = fseek(Output, position, SEEK_SET);
    if (r) {
        return r;
    }

    fprintf(Output, "%d=1,2000,1,ftasr,\"restore\"\n", nextNumber);

    return ERROR_SUCCESS;
}

long
CFtasrDlg::PrintOutVolumeNames(
    IN  FILE*               Output,
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId
    )

/*++

Routine Description:

    This routine saves all volume names of a root logical disk in a 
    backup file

Arguments:

    Output                  - Supplies the backup file open in write mode

    RootLogicalDiskId       - Supplies the id of the root logical disk.
    
Return Value:

    ERROR_SUCCESS if the function succeeded. Other error codes for failure

--*/

{
    HANDLE                  h;
    PMOUNTMGR_MOUNT_POINT   point;
    PMOUNTMGR_MOUNT_POINTS  points;
    BOOL                    b;
    DWORD                   bytes;
    ULONG                   i;
    PWSTR                   name;
    WCHAR                   s;
    DWORD                   numNames;
    long                    r;

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        r = GetLastError();
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_NAMES, r);
        return r;
    }

    point = (PMOUNTMGR_MOUNT_POINT)LocalAlloc(0, sizeof(MOUNTMGR_MOUNT_POINT) +
                                                 sizeof(FT_LOGICAL_DISK_ID));
    if (!point) {
        r = GetLastError();
        CloseHandle(h);
        DisplaySystemError(r);
        return r;
    }

    ZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    point->UniqueIdOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->UniqueIdLength = sizeof(FT_LOGICAL_DISK_ID);
    CopyMemory((PCHAR) point + point->UniqueIdOffset, &RootLogicalDiskId,
               point->UniqueIdLength);

    points = (PMOUNTMGR_MOUNT_POINTS)LocalAlloc(0, sizeof(MOUNTMGR_MOUNT_POINTS) + sizeof(WCHAR));
    if (!points) {
        r = GetLastError();
        LocalFree(point);
        CloseHandle(h);
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_NAMES, r);
        return r;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                        sizeof(MOUNTMGR_MOUNT_POINT) +
                        sizeof(FT_LOGICAL_DISK_ID), points,
                        sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);
    while (!b && GetLastError() == ERROR_MORE_DATA) {
        bytes = points->Size + sizeof(WCHAR);
        LocalFree(points);
        points = (PMOUNTMGR_MOUNT_POINTS)LocalAlloc(0, bytes);
        if (!points) {
            r = GetLastError();
            LocalFree(point);
            CloseHandle(h);
            DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_NAMES, r);
            return r;
        }

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                            sizeof(MOUNTMGR_MOUNT_POINT) +
                            sizeof(FT_LOGICAL_DISK_ID), points, bytes, &bytes,
                            NULL);
    }

    r = GetLastError();
    LocalFree(point);
    CloseHandle(h);

    if (!b) {
        LocalFree(points);
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_NAMES, r);
        return r;
    }

    numNames = 0;
    for (i = 0; i < points->NumberOfMountPoints; i++) {
        point = &points->MountPoints[i];

        if (point->SymbolicLinkNameLength != 96) {
            continue;
        }

        name = (PWCHAR) ((PCHAR) points + point->SymbolicLinkNameOffset);

        if (name[0] == '\\' &&
            name[1] == '?' &&
            name[2] == '?' &&
            name[3] == '\\' &&
            name[4] == 'V' &&
            name[5] == 'o' &&
            name[6] == 'l' &&
            name[7] == 'u' &&
            name[8] == 'm' &&
            name[9] == 'e' &&
            name[10] == '{' &&
            name[19] == '-' &&
            name[24] == '-' &&
            name[29] == '-' &&
            name[34] == '-' &&
            name[47] == '}') {

            numNames++;
        }
    }

    fprintf(Output, "%d\n", numNames);

    for (i = 0; i < points->NumberOfMountPoints; i++) {
        point = &points->MountPoints[i];

        if (point->SymbolicLinkNameLength != 96) {
            continue;
        }

        name = (PWCHAR) ((PCHAR) points + point->SymbolicLinkNameOffset);

        if (name[0] == '\\' &&
            name[1] == '?' &&
            name[2] == '?' &&
            name[3] == '\\' &&
            name[4] == 'V' &&
            name[5] == 'o' &&
            name[6] == 'l' &&
            name[7] == 'u' &&
            name[8] == 'm' &&
            name[9] == 'e' &&
            name[10] == '{' &&
            name[19] == '-' &&
            name[24] == '-' &&
            name[29] == '-' &&
            name[34] == '-' &&
            name[47] == '}') {

            s = name[48];
            name[48] = 0;
            fprintf(Output,"\"");
            fwprintf(Output, name);
            fprintf(Output, "\"\n");
            name[48] = s;
        }
    }

    LocalFree(points);

    return ERROR_SUCCESS;
}

long
CFtasrDlg::PrintOutDiskInfo(
    IN  FILE*               Output,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine saves all information needed to restore a
    logical disk in a backup file

Arguments:

    Output              - Supplies the backup file open in write mode

    LogicalDiskId       - Supplies the id of the logical disk.
    
Return Value:

    ERROR_SUCCESS if the function succeeded. Other error codes for failure

--*/

{
    BOOL                                                    b;
    WORD                                                    numMembers;
    PFT_LOGICAL_DISK_ID                                     members;
    FT_LOGICAL_DISK_TYPE                                    diskType;
    LONGLONG                                                volumeSize;
    WORD                                                    i;
    CHAR                                                    configInfo[100];
    CHAR                                                    stateInfo[100];
    PFT_PARTITION_CONFIGURATION_INFORMATION                 partConfig;
    PFT_STRIPE_SET_CONFIGURATION_INFORMATION                stripeConfig;
    PFT_MIRROR_SET_CONFIGURATION_INFORMATION                mirrorConfig;
    PFT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION    swpConfig;
    PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION            redistConfig;
    long                                                    r;

    fprintf(Output, "%I64X", LogicalDiskId);

    if (!LogicalDiskId) {
        fprintf(Output, "\n");
        return ERROR_SUCCESS;
    }

    b = FtQueryLogicalDiskInformation(LogicalDiskId, NULL, NULL,
                                      0, NULL, &numMembers, 0, NULL, 0, NULL);
    if (!b) {
        r = GetLastError();
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_INFO, r);
        return r;
    }

    if (numMembers) {
        members = (PFT_LOGICAL_DISK_ID)LocalAlloc(0, numMembers*sizeof(FT_LOGICAL_DISK_ID));
        if (!members) {
            r = GetLastError();
            DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_INFO, r);
            return r;
        }
    } else {
        members = NULL;
    }

    b = FtQueryLogicalDiskInformation(LogicalDiskId, &diskType, &volumeSize,
                                      numMembers, members, &numMembers,
                                      100, configInfo, 100, stateInfo);
    if (!b) {
        r = GetLastError();
        LocalFree(members);
        DisplayResourceSystemError(IDS_ERROR_PRINT_VOLUME_INFO, r);
        return r;
    }

    fprintf(Output, ",%d,%d", diskType, numMembers);

    switch (diskType) {
        case FtPartition:
            partConfig = (PFT_PARTITION_CONFIGURATION_INFORMATION) configInfo;
            fprintf(Output, ",%X,%I64X,%I64X", partConfig->Signature,
                    partConfig->ByteOffset, volumeSize);
            break;

        case FtStripeSet:
            stripeConfig = (PFT_STRIPE_SET_CONFIGURATION_INFORMATION) configInfo;
            fprintf(Output, ",%X", stripeConfig->StripeSize);
            break;

        case FtMirrorSet:
            mirrorConfig = (PFT_MIRROR_SET_CONFIGURATION_INFORMATION) configInfo;
            fprintf(Output, ",%I64X", mirrorConfig->MemberSize);
            break;

        case FtStripeSetWithParity:
            swpConfig = (PFT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION) configInfo;
            fprintf(Output, ",%I64X,%X", swpConfig->MemberSize, swpConfig->StripeSize);
            break;

        case FtRedistribution:
            redistConfig = (PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION) configInfo;
            fprintf(Output, ",%X,%d,%d", redistConfig->StripeSize,
                   redistConfig->FirstMemberWidth,
                   redistConfig->SecondMemberWidth);
            break;

    }

    fprintf(Output, "\n");

    for (i = 0; i < numMembers; i++) {
        r = PrintOutDiskInfo(Output, members[i]);
        if (r != ERROR_SUCCESS) {
            LocalFree(members);
            return r;
        }
    }

    LocalFree(members);
    return ERROR_SUCCESS;
}

long
CFtasrDlg::Restore(
    IN FILE*    Input
    )

/*++

Routine Description:

    This routine restores the logical disks hierarchy using information
    saved in a backup file

Arguments:

    Input           - Supplies the backup file open in read mode
    
Return Value:

    ERROR_SUCCESS if the restore succeeded. Other error codes for failure

--*/

{
    DWORD               numDisks, numNames, i, j, k;
    PWCHAR*             volumeNames;
    PWCHAR              volumeName;
    int                 nameLength;
    FT_LOGICAL_DISK_ID  diskId;
    FT_LOGICAL_DISK_ID  expectedPath[MAX_STACK_DEPTH];
    long                r;
    
    m_Progress.SetPos(20);
    Sleep(300);
    
    fwscanf(Input, L"%lu", &numDisks);
    if (feof(Input)) {
        numDisks = 0;
    }

    if (numDisks > 0) {
        m_Progress.SetStep(80/numDisks);
    }

    for (k = 0; k < numDisks; k++) {

        DbgPrint(L"ftasr: Start processing disk\n");
        fwscanf(Input, L"%d", &numNames);
        if (feof(Input)) {
            break;
        }

        if (numNames) {
            volumeNames = (PWCHAR*)LocalAlloc(0, numNames*sizeof(PWCHAR));
            if (!volumeNames) {
                r = GetLastError();
                DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME_NAMES, r);
                return r;
            }

            for (i = 0; i < numNames; i++) {
                volumeName = (PWCHAR)LocalAlloc(0, MAX_PATH*sizeof(WCHAR));
                if (!volumeName) {
                    r = GetLastError();
                    for (j = 0; j < i; j++) {
                        LocalFree(volumeNames[j]);
                    }
                    LocalFree(volumeNames);
                    DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME_NAMES, r);
                    return r;                    
                }

                fwscanf(Input, L"%s", volumeName);
                nameLength = wcslen(volumeName);
                if (nameLength < 2 ||
                    volumeName[0] != L'\"' || volumeName[nameLength-1] != L'\"') {
                    for (j = 0; j < i; j++) {
                        LocalFree(volumeNames[j]);
                    }
                    LocalFree(volumeNames);
                    LocalFree(volumeName);
                    DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME_NAMES, IDS_ERROR_INVALID_BACKUP);
                    return ERROR_INVALID_DATA;
                }
                for (j = 0; (long)j < nameLength - 2; j++) {
                    volumeName[j] = volumeName[j+1];
                }
                volumeName[j] = L'\0';
                
                volumeNames[i] = volumeName;                
            }
        }

        if (feof(Input)) {
            break;
        }

        diskId = BuildFtDisk(Input, expectedPath, 0, TRUE, NULL, NULL);
        
        if (diskId && numNames) {
            LinkVolumeNamesToLogicalDisk(volumeNames, numNames, diskId);

            for (i = 0; i < numNames; i++) {
                LocalFree(volumeNames[i]);
            }
            LocalFree(volumeNames);
        }

        m_Progress.StepIt();
        Sleep(300);
    }

    m_Progress.SetPos(101);
    Sleep(300);
    
    return ERROR_SUCCESS;
}

VOID
CFtasrDlg::LinkVolumeNamesToLogicalDisk(
    IN  PWCHAR*             VolumeNames,
    IN  DWORD               NumNames,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This links volumes names to a root logical disk

Arguments:

    VolumeNames         - Supplies the volume names

    NumNames            - Supplies the number of volume names

    LogicalDiskId       - Supplies the id of the logical disk
    
Return Value:

    -

--*/

{
    HANDLE                                              h;
    FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT      inputNtDevice;
    PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT    outputNtDevice;
    WCHAR                                               bufferNtDevice[MAX_PATH];
    ULONG					                            inputQueryPointsSize;    
	PMOUNTMGR_MOUNT_POINT                               inputQueryPoints;
    MOUNTMGR_MOUNT_POINTS                               outputQueryPoints;
    PMOUNTMGR_TARGET_NAME                               inputArrival;    
    WCHAR                                               buffer[MAX_PATH];
    PMOUNTMGR_CREATE_POINT_INPUT                        inputCreatePoint;
    BOOL                                                b;
    long                                                r;
    DWORD                                               i;
    DWORD                                               bytes;
    
    // 1. Get the NT device name of the volume
    
    inputNtDevice.RootLogicalDiskId = LogicalDiskId;
    outputNtDevice = (PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT)bufferNtDevice;

    h = CreateFile(DD_DOS_FT_CONTROL_NAME, GENERIC_READ, FILE_SHARE_READ |
                   FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        r = GetLastError();
        DbgPrint(L"ftasr: Link volume names failed: Open DD_DOS_FT_CONTROL_NAME failed with %lu\n", r);
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME_NAMES, r);
        return;
    }

    b = DeviceIoControl(h, FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK, &inputNtDevice, sizeof(inputNtDevice), 
                        outputNtDevice, MAX_PATH * sizeof(WCHAR), &bytes, NULL);
    
    r = GetLastError();
    CloseHandle(h);

    if (!b) { 
        DbgPrint(L"ftasr: Link volume names failed: FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK failed with %lu\n", r);
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME_NAMES, r);
        return;
    }

    outputNtDevice->NtDeviceName[outputNtDevice->NumberOfCharactersInNtDeviceName] = 0;

    // 2. Open the mount manager
    
    h = CreateFile(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        r = GetLastError();
        DbgPrint(L"ftasr: Link volume names failed: Open MOUNTMGR_DOS_DEVICE_NAME failed with %lu\n", r);
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME_NAMES, r);
        return;
    }

    // 3. Call IOCTL_MOUNTMGR_QUERY_POINTS to check whether the volume is installed or not
    
    inputQueryPointsSize = sizeof(MOUNTMGR_MOUNT_POINT) + outputNtDevice->NumberOfCharactersInNtDeviceName * sizeof(WCHAR);
    inputQueryPoints = (PMOUNTMGR_MOUNT_POINT)LocalAlloc(0, inputQueryPointsSize);    
	if (!inputQueryPoints)    
	{
        r = GetLastError();
        CloseHandle(h);
        DbgPrint(L"ftasr: Link volume names failed: Cannot allocate memory for IOCTL_MOUNTMGR_QUERY_POINTS input\n");
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME_NAMES, r);
        return;    
	}    
	
	inputQueryPoints->SymbolicLinkNameLength = 0;    
	inputQueryPoints->SymbolicLinkNameOffset = 0;
	inputQueryPoints->UniqueIdOffset = 0;
	inputQueryPoints->UniqueIdLength = 0;
    inputQueryPoints->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    inputQueryPoints->DeviceNameLength = outputNtDevice->NumberOfCharactersInNtDeviceName * sizeof(WCHAR);
    CopyMemory((PCHAR)inputQueryPoints + inputQueryPoints->DeviceNameOffset, outputNtDevice->NtDeviceName,
               inputQueryPoints->DeviceNameLength);

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, inputQueryPoints, inputQueryPointsSize,
                        &outputQueryPoints, sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);

    r = GetLastError();    
    LocalFree(inputQueryPoints);
    
    // 4. If the volume is not installed then force the installation
    
    if (!b && r != ERROR_MORE_DATA) {
        DbgPrint(L"ftasr: Link volume names: IOCTL_MOUNTMGR_QUERY_POINTS failed with %lu\n", r);
      
        inputArrival = (PMOUNTMGR_TARGET_NAME)buffer;
        inputArrival->DeviceNameLength = outputNtDevice->NumberOfCharactersInNtDeviceName * sizeof(WCHAR);
        CopyMemory((PCHAR)inputArrival->DeviceName, outputNtDevice->NtDeviceName,
                   inputArrival->DeviceNameLength);
        
        // Send volume arrival notifications until one of them succeedes. Timeout 2 minutes
        for (i = 0; i < 1200; i++) {
            b = DeviceIoControl(h, IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION, inputArrival, 
                                MAX_PATH * sizeof(WCHAR), NULL, 0, &bytes, NULL);
            if (b) {
                DbgPrint(L"ftasr: Link volume names: IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for %s succeeded\n", 
                         outputNtDevice->NtDeviceName);
                break;
            }
            
            r = GetLastError();
            DbgPrint(L"ftasr: Link volume names: %lu. IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for %s failed with %lu\n", 
                     i, outputNtDevice->NtDeviceName, r);
            Sleep(100);
        }
                
        if (!b) {                                                        
            CloseHandle(h);
            DbgPrint(L"ftasr: Link volume names failed: IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION for %s timed out\n", 
                       outputNtDevice->NtDeviceName);
            DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME_NAMES, r);
            return;                
        }        
    } 
    
    // 5. Call IOCTL_MOUNTMGR_CREATE_POINT  

    inputCreatePoint = (PMOUNTMGR_CREATE_POINT_INPUT)buffer;

    for (i = 0; i < NumNames; i++) {
        inputCreatePoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
        inputCreatePoint->SymbolicLinkNameLength = wcslen(VolumeNames[i]) * sizeof(WCHAR);
        inputCreatePoint->DeviceNameOffset = inputCreatePoint->SymbolicLinkNameOffset +
                                             inputCreatePoint->SymbolicLinkNameLength;
        inputCreatePoint->DeviceNameLength = outputNtDevice->NumberOfCharactersInNtDeviceName * sizeof(WCHAR);

        CopyMemory((PCHAR)inputCreatePoint + inputCreatePoint->SymbolicLinkNameOffset,
                   VolumeNames[i], inputCreatePoint->SymbolicLinkNameLength);
        CopyMemory((PCHAR)inputCreatePoint + inputCreatePoint->DeviceNameOffset,
                   outputNtDevice->NtDeviceName, inputCreatePoint->DeviceNameLength);

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_CREATE_POINT, inputCreatePoint,
                            MAX_PATH * sizeof(WCHAR), NULL, 0, &bytes, NULL);
        if (b) {
            DbgPrint(L"ftasr: Link volume names: IOCTL_MOUNTMGR_CREATE_POINT succeeded\n");
        } else {
            DbgPrint(L"ftasr: Link volume names: IOCTL_MOUNTMGR_CREATE_POINT failed with %lu\n", 
                     GetLastError());            
        }
    }

    // 6. Close the mount manager

    CloseHandle(h);
}

FT_LOGICAL_DISK_ID
CFtasrDlg::BuildFtDisk(
    IN      FILE*               Input,
    IN OUT  PFT_LOGICAL_DISK_ID ExpectedPath,
    IN      WORD                ExpectedPathSize,
    IN      BOOL                AllowBreak,
    OUT     PBOOL               Existing,               /* OPTIONAL */
    OUT     PBOOL               Overwriteable           /* OPTIONAL */
    )

/*++

Routine Description:

    This routine restores a logical disk based on the information saved
    in the backup file

Arguments:

    Input               - Supplies the backup file open in read mode

    ExpectedPath        - Supplies the expected forefathers of the logical disk
                          as they appear in the backup file, starting with a root
                          logical volume and ending with the expected parent. 
                          The size of this array is maximum MAX_STACK_DEPTH. 
                          The array content may change inside this function due 
                          to logical disk breakings or replacements

    ExpectedPathSize    - Supplies the number of expected forefathers

    AllowBreak          - Specifies whether the expected forefathers can be broken
                          inside this function

    Existing            - Returns TRUE if the logical disk was already alive and valid
                          at the moment of the execution of this function

    Overwriteable       - Returns TRUE if the FT volume can be overwritten later in the FT ASR process 
                          If FALSE we should avoid building an FT set on top of it that may destroy the content of the FT volume                          

Return Value:

    The id of the logical disk. 0 if the function failed

--*/

{
    FT_LOGICAL_DISK_ID                                  diskId, candidate;
    FT_LOGICAL_DISK_TYPE                                diskType, candidateType;
    DWORD                                               numMembers; 
    WORD                                                candidateNumMembers;
    DWORD                                               numNewMembers, numInvalidNewMembers;
    DWORD                                               numNotOverwriteableMembers, notOverwriteableMember;
    DWORD                                               numReplacedMembers, i, j;
    PFT_LOGICAL_DISK_ID                                 members;
    PBOOL                                               existingMembers;
    ULONG                                               signature;
    LONGLONG                                            offset, length;
    DWORD                                               configSize;
    PVOID                                               config;
    DWORD                                               stripeSize, firstWidth, secondWidth;
    DWORDLONG                                           memberSize;
    FT_STRIPE_SET_CONFIGURATION_INFORMATION             stripeConfig;
    FT_MIRROR_SET_CONFIGURATION_INFORMATION             mirrorConfig;
    FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION swpConfig;
    FT_REDISTRIBUTION_CONFIGURATION_INFORMATION         redistConfig;
    WCHAR                                               messageBuffer[MAX_PATH];
    BOOL                                                ioCapable, b;
    FT_LOGICAL_DISK_ID                                  realPath[MAX_STACK_DEPTH];
    FT_LOGICAL_DISK_ID                                  newRealPath[MAX_STACK_DEPTH];
    WORD                                                realPathSize, newRealPathSize;
    SHORT                                               k;
    LONGLONG                                            size0, size1;
    long                                                r;
    BOOL                                                isSystem, isBoot;
    
    DbgPrint(L"ftasr: Build FT disk: ");
    
    // Initialization
    if (Existing) {
        *Existing = FALSE;
    }
    if (Overwriteable) {
        *Overwriteable = TRUE;
    }
    ioCapable = FALSE;
    candidate = 0;
    
    // 1. Read the disk id, type and number of members from the file

    diskId = 0;
    fwscanf(Input, L"%I64X", &diskId);
    if (!diskId) {
        DbgPrint(L"Error - cannot read DiskId\n");
        DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_INVALID_BACKUP);
        return candidate;
    }
    DbgPrint(L"DiskId = %I64X\n", diskId);

    fwscanf(Input, L",%d,%d", &diskType, &numMembers);

    // 2. Check whether the disk is alive, has the same main parameters and is IO capable
    b = FtQueryLogicalDiskInformation(
        diskId, &candidateType, NULL, 0, NULL,
        &candidateNumMembers, 0, NULL, 0, NULL );

    if (b && diskType == candidateType && 
        numMembers == candidateNumMembers) {
        if (Existing) {
            *Existing = TRUE;
        }
        candidate = diskId;
        b = FtCheckIo(candidate, &ioCapable); 
        if (!b) {
            ioCapable = FALSE;
        }
    }

    // 3. Read the configuration information from file. Dismiss the FtPartition case
        
    switch (diskType) {
        case FtPartition:
            fwscanf(Input, L",%X,%I64X,%I64X", &signature, &offset, &length);
            if (candidate) {
                ASSERT(candidate == diskId);
                DbgPrint(L"ftasr: Build FT disk succeeded - FT partition already exists\n");
                return candidate;
            }
            
            candidate = CreateFtPartition(signature, offset, length, &b);

            // If the new FT partition is not overwritable break the expected path
            // We try to avoid regenerations that may overwrite the content of the boot/system partition
            if (!b) {                
                for (i = 0; i < ExpectedPathSize; i++) {
                    if (ExpectedPath[i]) {
                        b = FtBreakLogicalDisk(ExpectedPath[i]);
                        if (b) {
                            DbgPrint(L"ftasr: Expected parent %I64X broken\n", ExpectedPath[i]);
                            ExpectedPath[i] = 0;
                        } else {
                            DbgPrint(L"ftasr: Expected parent %I64X break failed with %ld\n", ExpectedPath[i], GetLastError());                            
                        }
                    }
                }
            }

            if (Overwriteable) {
                *Overwriteable = b;
            }
            
            DbgPrint(L"ftasr: Build FT disk succeeded - new FT partition %I64X\n", candidate);
            return candidate;
            break;
        
        case FtVolumeSet:
            configSize = 0;
            config = NULL;
            break;

        case FtStripeSet:
            fwscanf(Input, L",%X", &stripeSize);
            stripeConfig.StripeSize = stripeSize;
            configSize = sizeof(FT_STRIPE_SET_CONFIGURATION_INFORMATION);
            config = &stripeConfig;
            break;

        case FtMirrorSet:
            fwscanf(Input, L",%I64X", &memberSize);
            mirrorConfig.MemberSize = memberSize;
            configSize = sizeof(FT_MIRROR_SET_CONFIGURATION_INFORMATION);
            config = &mirrorConfig;
            break;

        case FtStripeSetWithParity:
            fwscanf(Input, L",%I64X,%X", &memberSize, &stripeSize);
            ZeroMemory(&swpConfig, sizeof(swpConfig));
            swpConfig.MemberSize = memberSize;
            swpConfig.StripeSize = stripeSize;
            configSize = sizeof(FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION);
            config = &swpConfig;
            break;

        case FtRedistribution:
            fwscanf(Input, L",%X,%d,%d", &stripeSize, &firstWidth, &secondWidth);
            redistConfig.StripeSize = stripeSize | 0x80000000;
            redistConfig.FirstMemberWidth = (USHORT) firstWidth;
            redistConfig.SecondMemberWidth = (USHORT) secondWidth;
            configSize = sizeof(FT_REDISTRIBUTION_CONFIGURATION_INFORMATION);
            config = &redistConfig;
            break;

        default:
            ASSERT(!candidate);
            DbgPrint(L"ftasr: Build FT disk failed - unrecognized logical disk type\n");
            DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_INVALID_BACKUP);
            return 0;
    }

    // 4. Build the members
        
    members = (PFT_LOGICAL_DISK_ID)LocalAlloc(0, numMembers*sizeof(FT_LOGICAL_DISK_ID));
    if (!members) {
        DbgPrint(L"ftasr: Build FT disk failed - allocation failed for members array\n");
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME, GetLastError());
        return candidate;
    }

    existingMembers = (PBOOL)LocalAlloc(0, numMembers*sizeof(BOOL));
    if (!existingMembers) {
        DbgPrint(L"ftasr: Build FT disk failed - allocation failed for existing members array\n");
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME, GetLastError());
        LocalFree(members);
        return candidate;
    }

    if (ExpectedPathSize >= MAX_STACK_DEPTH) {
        // that's really a huge, huge stack!
        DbgPrint(L"ftasr: Build FT disk failed - expected path size overpassed\n");
        DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_UNEXPECTED);
        goto _cleanup;
    }
    ExpectedPath[ExpectedPathSize] = candidate; // kind of push in a stack

    numNewMembers = 0;
    numInvalidNewMembers = 0;
    numNotOverwriteableMembers = 0;
    for (i = 0; i < numMembers; i++) {
        members[i] = BuildFtDisk(Input, ExpectedPath, (WORD)(ExpectedPathSize + 1),
                                 AllowBreak && !ioCapable, &(existingMembers[i]), &b);
        if (!existingMembers[i]) {
            DbgPrint(L"ftasr: New member %I64X\n", members[i]);
            numNewMembers++;            
        }
        if (!members[i]) {
            numInvalidNewMembers++;
        }
        if (!b && members[i] && !existingMembers[i]) {
            numNotOverwriteableMembers++;
            notOverwriteableMember = i;
        }
    }
    ASSERT(numInvalidNewMembers <= numNewMembers);
    
    // 5. See what happened with the candidate during step 4
    // It might have been broken or replaced, so we must update the candidate
    
    candidate = ExpectedPath[ExpectedPathSize]; // kind of pop from a stack
    if (Existing) {
        *Existing = (candidate != 0);
    }
    
    // 6. "Use Candidate" - check whether the candidate is intact, can be repaired or should be broken

    if (candidate) {
        ASSERT(!Existing || *Existing);

        // 6.1. All members are intact -> return candidate
        if (!numNewMembers) {
            DbgPrint(L"ftasr: Build FT disk succeeded - all members are intact\n");
            goto _cleanup;
        }
        
        // 6.2. "Replace members" - We have new valid members waiting to replace old invalid members
        if (numNewMembers > numInvalidNewMembers) {
            
            // 6.2.1. Get the path from the candidate to its root volume
            b = GetPathFromLogicalDiskToRoot(candidate, realPath, &realPathSize);
            if (!b) {
                // Unexpected error. Cannot take the risk to replace members or break the disk
                DbgPrint(L"ftasr: Build FT disk failed - GetPathFromLogicalDiskToRoot failed\n");
                DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_UNEXPECTED);
                goto _cleanup;
            }
            
            // 6.2.2. Call replace for every new valid member
            numReplacedMembers = 0;
            for (i = 0; i < numMembers; i++) {
                if (!existingMembers[i] && members[i] != 0) {
                    DbgPrint(L"ftasr: Replace member %d with logical disk %I64X\n", i, members[i]);
                    b = FtReplaceLogicalDiskMember(candidate, (WORD)i, members[i], &diskId);
                    if (b) {
                        candidate = diskId;
                        numReplacedMembers++;
                        DbgPrint(L"ftasr: Replacement succeeded. Id = %I64X\n", candidate);
                    } else {
                        DbgPrint(L"ftasr: Replacement failed with %ld\n", GetLastError());
                    }
                }
            }

            // 6.2.3. If at least one replacement succeeded update the expected path
            if (numReplacedMembers > 0) {
                b = GetPathFromLogicalDiskToRoot(candidate, newRealPath, &newRealPathSize);
                ASSERT(!b || realPathSize == newRealPathSize);
                // Stop synchronization at this moment
                if (b) {
                    if (newRealPathSize > 0 ) {
                        FtStopSyncOperations(newRealPath[newRealPathSize - 1]);
                    } else {
                        FtStopSyncOperations(candidate);
                    }
                }
                // Update the expected path. Some of the expected parents may have been changed
                // due to replacements performed
                for(i = 0; i < ExpectedPathSize; i++) {
                    if (ExpectedPath[i]) {
                        for(j = 0; j < realPathSize; j++) {
                            if (ExpectedPath[i] == realPath[j]) {
                                ExpectedPath[i] = b ? newRealPath[j] : 0;                                
                                break;                               
                            }
                        } 
                    }
                }
            }

            // 6.2.4. If all replacements succeeded return the candidate
            if (numReplacedMembers == numNewMembers - numInvalidNewMembers) {
                DbgPrint(L"ftasr: Build FT disk succeeded - all replacements succeeded\n");
                goto _cleanup;
            }
        }
        // End "Replace members"

        // 6.3. "Break" - Check whether we are allowed to break the candidate. If we aren't, return it.
        b = FtCheckIo(candidate, &ioCapable); 
        if (!b) {
            ioCapable = FALSE;
        }

        if (!AllowBreak || ioCapable || numInvalidNewMembers > 0 ||
            !GetPathFromLogicalDiskToRoot(candidate, realPath, &realPathSize) ) {
            // Cannot break or doesn't make sense to break
            DbgPrint(L"ftasr: Build FT disk failed - cannot break or doesn't make sense to break\n");
            goto _cleanup;
        }
        
        // Check whether the real path matches with the expected path
        // Note: real path is a reversed path 
        for (i = 0; i < realPathSize; i++) {
            if (i >= ExpectedPathSize || realPath[i] != ExpectedPath[ExpectedPathSize - i - 1]) {
                DbgPrint(L"ftasr: Build FT disk failed - real path doesn't match with the expected path\n");
                goto _cleanup;
            }
        }
        
        for (k = (SHORT)realPathSize - 1; k >= 0; k--){
            DbgPrint(L"ftasr: Break parent %I64X\n", realPath[k]);
            b = FtBreakLogicalDisk(realPath[k]);
            if (!b) {
                DbgPrint(L"ftasr: Build FT disk failed - parent break failed with %ld\n", GetLastError());
                DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_UNEXPECTED);
                goto _cleanup;
            }
            for (i = 0; i < ExpectedPathSize; i++) {
                if (ExpectedPath[i] == realPath[k]) {
                    ExpectedPath[i] = 0;
                    break;
                }
            }
        }

        DbgPrint(L"ftasr: Break candidate %I64X\n", candidate);
        b = FtBreakLogicalDisk(candidate);
        if (!b) {
            DbgPrint(L"ftasr: Build FT disk - candidate break failed with %ld\n", GetLastError());
            DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_UNEXPECTED);
            goto _cleanup;
        }

        candidate = 0;
        if (Existing) {
            *Existing = FALSE;
        }
        // End "Break"
    }
    // End "Use candidate"


    // 7. Take care of not overwriteable members
    if (numNotOverwriteableMembers > 0) {
        ASSERT(candidate == 0);

        if (diskType != FtMirrorSet ||
            numNotOverwriteableMembers > 1) {
            DbgPrint(L"ftasr: Build FT disk failed - too many not overwriteable members\n");
            DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_MORE_FORMATTED);
            goto _cleanup;
        }

        // Make sure the not overwriteable member is the winner of the mirror set
        if (notOverwriteableMember > 0) {
            ASSERT(notOverwriteableMember == 1);
            diskId = members[0];
            members[0] = members[notOverwriteableMember];
            members[notOverwriteableMember] = diskId;
        }

    }
    
    // At this moment we have to create a brand new logical disk

    ASSERT(candidate == 0);
    ASSERT(!Existing || !(*Existing));

    // 8. Check whether all members are valid

    if (numInvalidNewMembers > 0) {
        DbgPrint(L"ftasr: Build FT disk failed - invalid members\n");
        candidate = 0;
        goto _cleanup;
    }
    
    // 9. If we create a stripe or a swp take every old member and
    // delete its file system info
/*
    //If we create a stripe or a swp take every old member and call 
    //DeleteFileSystemInfo().
    //This is to prevent those annoying popups "The file or directory ... is 
    //corrupt and unreadable."

    if (diskType == FtStripeSet || diskType == FtStripeSetWithParity) {  
        for (i = 0; i < numMembers; i++) {
            if (existingMembers[i]) {
                ASSERT(members[i]);
                if (DeleteFileSystemInfo(members[i])) {
                    DbgPrint(L"ftasr: Build FT disk - file system info deleted successfully for %I64X\n", members[i]);    
                } else {
                    DbgPrint(L"ftasr: Build FT disk - delete file system info failed for %I64X\n", members[i]);    
                }
            }
        }
    }
*/
    // 10. If we try to mirror the boot volume make sure the second member is
    // at least as large as the boot volume (which should be the first member
    // because of step 7)
       
    if (diskType == FtMirrorSet) {
        ASSERT(members[0]);
        ASSERT(members[1]);
        r = IsSystemOrBootVolume(members[0], &isSystem, &isBoot);        
        
        if( r != ERROR_SUCCESS) {
            DbgPrint(L"ftasr: Build FT disk failed - IsSystemOrBootVolume failed with %lu", r);
            DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME, r);
            goto _cleanup;
        }

        if (isBoot) {
            if (!FtQueryLogicalDiskInformation(members[0], NULL, &size0, 0, 
                                                NULL, NULL, 0, NULL, 0, NULL) ||
                !FtQueryLogicalDiskInformation(members[1], NULL, &size1, 0, 
                                                NULL, NULL, 0, NULL, 0, NULL) ||
                (size0 > size1) ) {
                DbgPrint(L"ftasr: Build FT disk - cannot mirror the boot volume\n");
                DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_MIRROR_BOOT_VOLUME);

                goto _cleanup;
            }
        }
    }
                
    // 11. "Create" - No candidate.Create a brand new logical disk
    
    if (!FtCreateLogicalDisk(diskType, (USHORT) numMembers, members,
                             (USHORT) configSize, config, &candidate)) {
        DbgPrint(L"ftasr: Build FT disk failed - logical disk creation failed\n");
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME, GetLastError());
        candidate = 0;
        goto _cleanup;
    }
    
    DbgPrint(L"ftasr: Build FT disk succeeded - logical disk created successfully. DiskId = %I64X\n", candidate);
    
    // Stop synchronization at this moment
    FtStopSyncOperations(candidate);

    if (Overwriteable) {
        *Overwriteable = (numNotOverwriteableMembers == 0);
    }

_cleanup:
    LocalFree(members);
    LocalFree(existingMembers);
    return candidate;
}

FT_LOGICAL_DISK_ID
CFtasrDlg::CreateFtPartition(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset,
    IN  LONGLONG    Length,
    OUT PBOOL       Overwriteable
    )

/*++

Routine Description:

    This routine creates an FT partition based on a disk partition

Arguments:

    Signature       - Supplies the signature of the disk partition

    Offset          - Supplies the offset of the disk partition

    Length          - Supplies the length of the disk partition

    Overwriteable   - Returns TRUE if the partition can be overwritten later in the FT ASR process 
                      If FALSE we should avoid building an FT set on top of it that may destroy the content of the partition
                      FALSE if the partition is already formatted and contains data.
    
Return Value:

    The id of the FT partition. 0 if the creation failed

--*/

{
    ULONG               s;
    LONGLONG            o, l, bestDelta, newDelta;
    HANDLE              h, hh, best;
    WCHAR               volumeName[MAX_PATH], bestVolName[MAX_PATH];
    FT_LOGICAL_DISK_ID  diskId;
    long                r;
    BOOL                b;
    WCHAR               fileSystem[100];


    DbgPrint(L"ftasr: Create FT partition: Signature = %lX, Offset = %I64X, Length = %I64X\n", 
             Signature, Offset, Length);
    
    *Overwriteable = TRUE;
    
    h = FindFirstVolume(volumeName, MAX_PATH);
    if (h == INVALID_HANDLE_VALUE) {
        DbgPrint(L"ftasr: Create FT partition failed - FindFirstVolume failed\n");
        DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_PARTITION_NOT_FOUND);
        return 0;
    }

    bestDelta = -1;
    
    for (;;) {

        volumeName[lstrlen(volumeName) - 1] = 0;
        hh = CreateFile(volumeName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
        if (hh == INVALID_HANDLE_VALUE) {
            DbgPrint(L"ftasr: Create FT partition failed - Volume opening failed\n");
            continue;
        }

        if (QueryPartitionInformation(hh, &s, &o, &l) && s == Signature &&
            l >= Length) {

            if (o > Offset) {
                newDelta = o - Offset;
            } else {
                newDelta = Offset - o;
            }

            if (bestDelta == -1 ||
                newDelta < bestDelta) {
                if (bestDelta >= 0 ) {
                    CloseHandle(best);
                }
                bestDelta = newDelta;
                best = hh;          
                wcscpy(bestVolName, volumeName);                
            } else {
                CloseHandle(hh);
            }

        } else {
            CloseHandle(hh);
        }

        if (!FindNextVolume(h, volumeName, MAX_PATH)) {
            break;
        }
    }

    FindVolumeClose(h);

    if (bestDelta < 0) {
        DisplayResourceResourceError(IDS_ERROR_RESTORE_VOLUME, IDS_ERROR_PARTITION_NOT_FOUND);
        return 0;
    }
    
    b = FtCreatePartitionLogicalDisk(best, &diskId);        
    r = GetLastError();
    CloseHandle(best);
    if (!b) {
        DbgPrint(L"ftasr: Create FT partition failed - FtCreatePartitionLogicalDisk failed\n");   
        DisplayResourceSystemError(IDS_ERROR_RESTORE_VOLUME, r);
        return 0;
    }
     
    // Check whether the partition is formatted
    wcscat(bestVolName, L"\\");        
    b = GetVolumeInformation(bestVolName, NULL, 0, NULL, NULL, NULL, fileSystem, 100);  
    if (b) {
        DbgPrint(L"ftasr: Create FT partition - GetVolumeInformation returned %s\n", fileSystem); 
        if (wcscmp(fileSystem, L"RAW")) {
            *Overwriteable = FALSE;
        }
    } else {
        r = GetLastError();
        DbgPrint(L"ftasr: Create FT partition - GetVolumeInformation failed with %lu\n", r);        
    }
    
    DbgPrint(L"ftasr: Create FT partition succeeded: DiskId = %I64X %s\n", diskId, *Overwriteable ? L"" : L"Formatted");
    return diskId;
}

BOOL
CFtasrDlg::QueryPartitionInformation(
    IN  HANDLE      Handle,
    OUT PDWORD      Signature,
    OUT PLONGLONG   Offset,
    OUT PLONGLONG   Length
    )

/*++

Routine Description:

    This routine returns the signature, offset and length of a partition

Arguments:

    Handle          - Supplies a handle to an open partition

    Signature       - Returns the signature of the partition

    Offset          - Returns the offset of the partition

    Length          - Returns the length of the partition
    
Return Value:

    TRUE if the query succeeded

--*/

{
    BOOL                        b;
    STORAGE_DEVICE_NUMBER       number;
    DWORD                       bytes;
    WCHAR                       diskName[MAX_PATH];
    HANDLE                      h;
    PDRIVE_LAYOUT_INFORMATION   layout;
    PARTITION_INFORMATION       partInfo;

    b = DeviceIoControl(Handle, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);
    if (!b || number.PartitionNumber == -1 || number.PartitionNumber == 0) {
        return FALSE;
    }

    swprintf(diskName, L"\\\\.\\PhysicalDrive%d", number.DeviceNumber);

    h = CreateFile(diskName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    layout = (PDRIVE_LAYOUT_INFORMATION)LocalAlloc(0, 4096);
    if (!layout) {
        CloseHandle(h);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0,
                        layout, 4096, &bytes, NULL);
    if (!b) {
        LocalFree(layout);
        CloseHandle(h);
        return FALSE;
    }

    *Signature = layout->Signature;

    LocalFree(layout);
    CloseHandle(h);

    b = DeviceIoControl(Handle, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                        &partInfo, sizeof(partInfo), &bytes, NULL);
    if (!b) {
        return b;
    }

    *Offset = partInfo.StartingOffset.QuadPart;
    *Length = partInfo.PartitionLength.QuadPart;

    return b;
}

/****************************************************************************************************/
/*                                                                                                  */    
/*  Method FtGetParentLogicalDisk should be a ftapi call based on a ftdisk IOCTL. When this will    */
/*  happen the next two methods will disappear from this code.                                      */
/*                                                                                                  */
/****************************************************************************************************/

BOOL
CFtasrDlg::GetParentLogicalDiskInVolume(
    IN  FT_LOGICAL_DISK_ID  VolumeId,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PFT_LOGICAL_DISK_ID ParentId    
    )

/*++

Routine Description:

    This routine search for a logical disk inside a (sub)volume and 
    returns the logical disk id of its parent.

Arguments:

    VolumeId            - Supplies the id of the (sub)volume.

    LogicalDiskId       - Supplies the id of the logical disk.

    ParentId            - Returns the id of the parent.
                          0 if the disk is not found inside the volume.

Return Value:

    FALSE   - Failure to search for the given disk.

    TRUE    - The search succeeded. The value returned in ParentId is valid

--*/

{
    WORD                    numberOfMembers, i;
    PFT_LOGICAL_DISK_ID     members; 
    FT_LOGICAL_DISK_ID      parentId;
    BOOL                    b, result;
    
    *ParentId = 0;
    
    b = FtQueryLogicalDiskInformation(
        VolumeId, NULL, NULL, 0, NULL, &numberOfMembers,
        0, NULL, 0, NULL);
    if (!b) {
        return FALSE;
    }

    if (numberOfMembers > 0 ) {
        members = (PFT_LOGICAL_DISK_ID)LocalAlloc(0, numberOfMembers * sizeof(FT_LOGICAL_DISK_ID));
        if (!members) {
            return FALSE;
        }
    
        b = FtQueryLogicalDiskInformation(
            VolumeId, NULL, NULL, numberOfMembers, members, &numberOfMembers,
            0, NULL, 0, NULL);
        if (!b) {
            LocalFree(members);
            return FALSE;
        }
    } else {
        members = NULL;
    }
    
    result = TRUE;
    for (i = 0; i < numberOfMembers; i++) {
        if (members[i] == LogicalDiskId) {
            *ParentId = VolumeId;
            result = TRUE;
            break;
        }

        b = GetParentLogicalDiskInVolume(members[i], LogicalDiskId, &parentId);
        if (!b) {
            result = FALSE;
            continue;
        }

        if (parentId) {
            *ParentId = parentId;
            result = TRUE;
            break;
        }
    }
    
    if (members) {
        LocalFree(members);
    }
    return result;
}

BOOL
CFtasrDlg::FtGetParentLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PFT_LOGICAL_DISK_ID ParentId    
    )
/*++

Routine Description:

    This routine returns the parent of a logical disk

Arguments:

    LogicalDiskId           - Supplies the id of the logical disk.

    ParentId                - Returns the id of the parent.
                              0 if the disk doesn't exist or has no parent

Return Value:

    FALSE   - Failure to search for the given disk.

    TRUE    - The search succeeded. The value returned in ParentId is valid

--*/

{
    BOOL                b, result;
    PFT_LOGICAL_DISK_ID diskId;
    FT_LOGICAL_DISK_ID  parentId;
    DWORD               numDisks, i;
    
    *ParentId = 0;
    
    b = FtEnumerateLogicalDisks(0, NULL, &numDisks);
    if (!b) {
        return FALSE;
    }

    if (numDisks > 0) { 
        diskId = (PFT_LOGICAL_DISK_ID)LocalAlloc(0, numDisks*sizeof(FT_LOGICAL_DISK_ID));
        if (!diskId) {
            return FALSE;
        }

        b = FtEnumerateLogicalDisks(numDisks, diskId, &numDisks);
        if (!b) {
            LocalFree(diskId);
            return FALSE;
        }
    } else {
        diskId = NULL;
    }

    result = TRUE;
    for (i = 0; i < numDisks; i++) {
        if (diskId[i] == LogicalDiskId) {
            result = TRUE;
            break;
        }
        
        b = GetParentLogicalDiskInVolume(diskId[i], LogicalDiskId, &parentId);  
        if (!b) {
            result = FALSE;
            continue;
        }
        if (parentId) {
            *ParentId = parentId;
            result = TRUE;
            break;
        }        
    }

    if (diskId) { 
        LocalFree(diskId);
    }
    return result;
}

BOOL
CFtasrDlg::GetPathFromLogicalDiskToRoot(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId, 
    OUT PFT_LOGICAL_DISK_ID Path, 
    OUT PWORD               PathSize
    )

/*++

Routine Description:

    This routine returns all forefathers of a logical disk starting with its
    parent and ending with a root logical disk

Arguments:

    LogicalDiskId       - Supplies the id of the logical disk

    Path                - Returns the forefathers of the logical disk.
                          The size of the array is maximum MAX_STACK_DEPTH

    PathSize            - Returns the number of forefathers 
    
Return Value:

    TRUE if all forefathers were found and added to Path

--*/

{
    FT_LOGICAL_DISK_ID  diskId;
    WORD                i;
    BOOL                b;

    diskId = LogicalDiskId;
    for (i = 0; i < MAX_STACK_DEPTH; i++) {
        b = FtGetParentLogicalDisk(diskId, &(Path[i]));
        if (!b) {
            return FALSE;
        }
        diskId = Path[i];
        if (!diskId) {
            break;
        }
    }

    if (i >= MAX_STACK_DEPTH) {
        return FALSE;
    }

    *PathSize = i;
    return TRUE;
}

/*********************************************************************************************/
/*  Some methods used to check for FT configurations not supported by ftasr at this moment   */
/*********************************************************************************************/

#ifdef CHECK_UNSUPPORTED_CONFIG

long
CFtasrDlg::CheckForUnsupportedConfig(
    IN DWORD                NumDisks, 
    IN PFT_LOGICAL_DISK_ID  ArrayOfDiskId
    )
/*++

Routine Description:

    This routine check if the current FT configuration is supported by ASR.
    Supported configurations are:
    - Mirrored boot and system partition filling the entire disk
    - Mirrored boot partition and mirrored system partition, saharing the same disk and filling it completely
    - Data volume sets whose members fill their disks completely
    - Data stripe sets whose members fill their disks completely

Arguments:

    NumDisks            - Supplies the number of root FT volumes

    ArrayOfDiskId       - Supplies the Id's of the root FT volumes
    
Return Value:

    ERROR_SUCCESS if the restore succeeded. Other error codes for failure

--*/
{
    DWORD                                   i, j;
    FT_LOGICAL_DISK_ID                      diskId;
    WORD                                    numMembers;
    PFT_LOGICAL_DISK_ID                     members;
    FT_LOGICAL_DISK_TYPE                    diskType;
    BOOL                                    b;
    BOOL                                    isSystem;
    BOOL                                    isBoot;
    long                                    r;
    FT_LOGICAL_DISK_TYPE                    memberType;
    LONGLONG                                memberSize;
    CHAR                                    configInfo[100];
    PFT_PARTITION_CONFIGURATION_INFORMATION partConfig;
    DISK_GEOMETRY	                        geometry;
    LONGLONG                                cylinderSize;
    
    WORD                                    numMirrors = 0;
    DWORD                                   lastMirrorFirstMemberDiskNumber;
    LONGLONG                                lastMirrorFirstMemberByteOffset;
    LONGLONG                                lastMirrorFirstMemberSize;
    
    for (i = 0; i < NumDisks; i++) {
        diskId = ArrayOfDiskId[i];

        b = FtQueryLogicalDiskInformation(diskId, &diskType, NULL,
                                          0, NULL, &numMembers, 0, NULL, 0, NULL);
        if (!b) {
            r = GetLastError();
            DisplayResourceSystemError(IDS_ERROR_CHECK_FAILURE, r);
            return r;
        }

        switch(diskType) {
            case FtMirrorSet:
            case FtVolumeSet:
            case FtStripeSet:
                break;

            case FtPartition:
                DisplayResourceResourceError(IDS_ERROR_FTPARTITION_DETECTED, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                return ERROR_NOT_SUPPORTED;

            case FtStripeSetWithParity:
                DisplayResourceResourceError(IDS_ERROR_SWP_DETECTED, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                return ERROR_NOT_SUPPORTED;

            case FtRedistribution:
                DisplayResourceResourceError(IDS_ERROR_REDISTRIBUTION_DETECTED, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                return ERROR_NOT_SUPPORTED;

            default:
                DisplayResourceError(IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                return ERROR_NOT_SUPPORTED;
        }
                
        r = IsSystemOrBootVolume(diskId, &isSystem, &isBoot);
        if (r != ERROR_SUCCESS) {
            DisplayResourceSystemError(IDS_ERROR_CHECK_FAILURE, r);
            return r;
        }

        if(diskType == FtMirrorSet) {
            if (!isSystem && !isBoot) {
                DisplayResourceResourceError(IDS_ERROR_NOT_BOOT_SYSTEM_MIRROR, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                return ERROR_NOT_SUPPORTED;
            }
        } else {  // Volume set or stripe set
            if (isSystem || isBoot) {
                DisplayResourceResourceError(IDS_ERROR_BOOT_SYSTEM_NOT_MIRROR, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                return ERROR_NOT_SUPPORTED;
            }
        }

        members = (PFT_LOGICAL_DISK_ID)LocalAlloc(0, numMembers*sizeof(FT_LOGICAL_DISK_ID));
        if (!members) {
            r = GetLastError();
            DisplayResourceSystemError(IDS_ERROR_CHECK_FAILURE, r);
            return r;
        }
    
        b = FtQueryLogicalDiskInformation(diskId, &diskType, NULL,
                                          numMembers, members, &numMembers,
                                          0, NULL, 0, NULL);
        if (!b) {
            r = GetLastError();
            LocalFree(members);
            DisplayResourceSystemError(IDS_ERROR_CHECK_FAILURE, r);
            return r;
        }

        for (j = 0; j < numMembers; j++) {
            b = FtQueryLogicalDiskInformation(members[j], &memberType, &memberSize,
                                          0, NULL, NULL, 100, configInfo, 0, NULL);
            if (!b) {
                r = GetLastError();
                LocalFree(members);
                DisplayResourceSystemError(IDS_ERROR_CHECK_FAILURE, r);
                return r;
            }
            
            if (memberType != FtPartition) {
                LocalFree(members);
                DisplayResourceResourceError(IDS_ERROR_STACK, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                return ERROR_NOT_SUPPORTED;
            }

            partConfig = (PFT_PARTITION_CONFIGURATION_INFORMATION)configInfo;

            if ((diskType != FtMirrorSet) || (j == 0)) {            
                
                r = GetDiskGeometry(partConfig->DiskNumber, &geometry);
                if (r != ERROR_SUCCESS) {
                    LocalFree(members);
                    DisplayResourceSystemError(IDS_ERROR_CHECK_FAILURE, r);
		            return r;
                }

                cylinderSize = geometry.TracksPerCylinder *
                               geometry.SectorsPerTrack *
                               geometry.BytesPerSector; 
                
                if((diskType != FtMirrorSet) || (isSystem && isBoot)) {
                    if (partConfig->ByteOffset < cylinderSize &&
                        partConfig->ByteOffset + memberSize >= (geometry.Cylinders.QuadPart - 1) * cylinderSize) { 
                        // It's OK.  The first member of the boot/system mirror fills the entire disk
                    } else {
                        LocalFree(members);
                        switch(diskType) {
                            case FtVolumeSet:
                                DisplayResourceResourceError(IDS_ERROR_VOLUME_SET_SIZE, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                                break;
                            case FtStripeSet:
                                DisplayResourceResourceError(IDS_ERROR_STRIPE_SET_SIZE, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                                break;
                            case FtMirrorSet:
                                DisplayResourceResourceError(IDS_ERROR_MIRROR_SET_SIZE, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                                break;                           
                        }
                        return ERROR_NOT_SUPPORTED;
                    }
                } else {  // Mirror set  boot OR system  first member
                    if (numMirrors == 0) {
                        numMirrors++;
                        lastMirrorFirstMemberDiskNumber = partConfig->DiskNumber;
                        lastMirrorFirstMemberByteOffset = partConfig->ByteOffset;
                        lastMirrorFirstMemberSize = memberSize;                        
                    } else {   // numMirrors == 1   We cannot find more than one boot and one system mirror
                        numMirrors++;
                        
                        if (lastMirrorFirstMemberDiskNumber != partConfig->DiskNumber) {
                            LocalFree(members);
                            DisplayResourceResourceError(IDS_ERROR_MIRRORS_ON_DIFFERENT_DISKS, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                            return ERROR_NOT_SUPPORTED;
                        }
                        
                        if ( ( partConfig->ByteOffset < cylinderSize &&
                               partConfig->ByteOffset + memberSize + cylinderSize > lastMirrorFirstMemberByteOffset &&
                               lastMirrorFirstMemberByteOffset + lastMirrorFirstMemberSize >= (geometry.Cylinders.QuadPart - 1) * cylinderSize 
                             ) ||
                             ( lastMirrorFirstMemberByteOffset < cylinderSize && 
                               lastMirrorFirstMemberByteOffset + lastMirrorFirstMemberSize + cylinderSize > partConfig->ByteOffset &&
                               partConfig->ByteOffset + memberSize >= (geometry.Cylinders.QuadPart - 1) * cylinderSize 
                             )
                           ) {
                            // It's OK. The first members of the two mirrors fill the entire disk
                        } else {
                            LocalFree(members);
                            DisplayResourceResourceError(IDS_ERROR_MIRRORS_SIZES, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
                            return ERROR_NOT_SUPPORTED;
                        }                        
                    }
                }
            } 
        } // members loop  

        LocalFree(members);
    } // disks loop  
    
    if (numMirrors == 1) {
        DisplayResourceResourceError(IDS_ERROR_ONE_MIRROR, IDS_ERROR_UNSUPPORTED_CONFIGURATION);
        return ERROR_NOT_SUPPORTED;
    }
    
    return ERROR_SUCCESS;
}

#define DOSDEV_PREFIX  L"\\DosDevices\\"

long 
CFtasrDlg::IsSystemOrBootVolume(
    IN  FT_LOGICAL_DISK_ID  DiskId,
    OUT PBOOL               IsSystem,
    OUT PBOOL               IsBoot
    )
/*++

Routine Description:

    This routine check if a FT root volume is the boot and/or system volume
    
Arguments:

    DiskId              - Supplies the Id of the root FT volume

    IsSystem            - Returns TRUE if the volume contains the NT loader files

    IsBoot              - Returns TRUE if the volume contains the NT root
    
Return Value:

    ERROR_SUCCESS if the restore succeeded. Other error codes for failure

--*/
{
    HANDLE												h;
    FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT		input1;
    ULONG												output1Size;
    PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT	output1;
    BOOL												b;
    ULONG												bytes;
    long                                                r;
    HKEY                                                key = NULL ;
    DWORD                                               disposition;
    WCHAR                                               system[MAX_PATH];
    DWORD                                               valueSize ;
    DWORD                                               type ;
    WCHAR                                               ntPath[MAX_PATH] ;
    ULONG					                            input2Size;    
	PMOUNTMGR_MOUNT_POINT                               input2;
    ULONG                                               output2Size;
    PMOUNTMGR_MOUNT_POINTS                              output2;
    ULONG                                               i;
    PWSTR                                               symName;

    *IsSystem = FALSE;
    *IsBoot = FALSE;
    
    // First get the NT volume name of the logical disk

    h = CreateFile(L"\\\\.\\FtControl", GENERIC_READ, 
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);    
    if (h == INVALID_HANDLE_VALUE){		
        return GetLastError(); 
    }
	
	input1.RootLogicalDiskId = DiskId;
    output1Size = MAX_PATH;
    output1 = (PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT)LocalAlloc(0, output1Size);    
	if (!output1) 
	{        
		r = GetLastError();
        CloseHandle(h);
        return r;   
	}

    b = DeviceIoControl(h, FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK, &input1,
                        sizeof(input1), output1, output1Size, &bytes, NULL);
	r = GetLastError();
    CloseHandle(h);        

    if (!b) {        
		LocalFree(output1);
        return r;    
	}
	
    //output1->NtDeviceName, 
    //output1->NumberOfCharactersInNtDeviceName
    output1->NtDeviceName[output1->NumberOfCharactersInNtDeviceName] = L'\0';

    // Second get the NT volume name of the system partition from HKLM:\SYSTEM\Setup

    r = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                        L"SYSTEM\\SETUP",
                        0,
                        NULL,
                        0,
                        KEY_READ,
                        NULL,
                        &key,
                        &disposition);
    if (r != ERROR_SUCCESS) {
        LocalFree(output1);
        return r;
    }
        
    valueSize = sizeof(system) ;
    r = RegQueryValueEx(key,
                        L"SystemPartition",
                        NULL,
                        &type,
                        (PBYTE)system,
                        &valueSize);
    if (r != ERROR_SUCCESS) {
        LocalFree(output1);
        return r;
    }

    // Compare the logical disk NT volume name with the system volume name
    if (!wcscmp(output1->NtDeviceName, system)) {
        *IsSystem = TRUE;
    }
    
    // Third get the boot volume path

    b = GetEnvironmentVariable(L"SystemRoot", ntPath, MAX_PATH);
    if (!b) {
        LocalFree(output1);
        return ERROR_SUCCESS;
    }

    // Then compare its drive letter with our logical disk drive letter

    h = CreateFile( MOUNTMGR_DOS_DEVICE_NAME,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE );

    if (h == INVALID_HANDLE_VALUE) {
        r = GetLastError();
        LocalFree(output1);
        return r;
    }

    input2Size = sizeof(MOUNTMGR_MOUNT_POINT) + ((output1->NumberOfCharactersInNtDeviceName + 1)*sizeof(WCHAR));
    input2 = (PMOUNTMGR_MOUNT_POINT)LocalAlloc(0, input2Size);    
	if (!input2)    
	{
        r = GetLastError();
        CloseHandle(h);
        LocalFree(output1);
		return r;    
	}    
	
	input2->SymbolicLinkNameLength = 0;    
	input2->SymbolicLinkNameOffset = 0;
	input2->UniqueIdOffset = 0;
	input2->UniqueIdLength = 0;
    input2->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input2->DeviceNameLength = output1->NumberOfCharactersInNtDeviceName * sizeof(WCHAR);
    wcscpy((PWSTR)((PCHAR)input2 + input2->DeviceNameOffset), output1->NtDeviceName);    
	LocalFree(output1);

    output2Size = sizeof(MOUNTMGR_MOUNT_POINTS) + 1024;
    output2 = (PMOUNTMGR_MOUNT_POINTS)LocalAlloc(0, output2Size);    
	if (!output2) {        
		r = GetLastError();
        CloseHandle(h);
        LocalFree(input2);
		return r;    
	}   

	b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, input2, input2Size,
                        output2, output2Size, &bytes, NULL);

    r = GetLastError();
    while (!b && r == ERROR_MORE_DATA) 
	{        
		output2Size = output2->Size;
        LocalFree(output2);
        output2 = (PMOUNTMGR_MOUNT_POINTS)LocalAlloc(0, output2Size);
        if (!output2) 
		{            
			r = GetLastError();
            CloseHandle(h);
			LocalFree(input2);
			return r;
        }        
		b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, input2, input2Size,
						    output2, output2Size, &bytes, NULL);    
        r = GetLastError();
	}

    CloseHandle(h);
	LocalFree(input2);

    if (!b) {
		LocalFree(output2);
		return r;
	}

	for (i = 0; i < output2->NumberOfMountPoints; i++) {
		symName = (PWSTR)( (PCHAR)output2 + output2->MountPoints[i].SymbolicLinkNameOffset) ;
        
        if (!wcsncmp(DOSDEV_PREFIX, symName, wcslen(DOSDEV_PREFIX))) {
            if (ntPath[0] == symName[wcslen(DOSDEV_PREFIX)]) {
                *IsBoot = TRUE;                           
            }
        }
	}
	
	LocalFree(output2);    

    return ERROR_SUCCESS;
}

long
CFtasrDlg::GetDiskGeometry(
    ULONG           DiskNumber,
    PDISK_GEOMETRY  Geometry
)
/*++

Routine Description:

    This routine retrieves the geometry of the given disk
    
Arguments:

    DiskNumber          - Supplies the disk number (0, 1, 2 ...)

    Geometry            - Returns the disk geometry

Return Value:

    ERROR_SUCCESS if the restore succeeded. Other error codes for failure

--*/

{
    WCHAR   name[50];
    ULONG   bytes;
    HANDLE  h;
    BOOL    b;
    long    r;
    
    wsprintf(name, L"\\\\.\\PHYSICALDRIVE%lu", DiskNumber); 
			        
	h = CreateFile(name, GENERIC_READ, 
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
				   NULL, OPEN_EXISTING, 0 , INVALID_HANDLE_VALUE );
	if (h == INVALID_HANDLE_VALUE) {		
        return GetLastError();               
	}
			
	b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
						Geometry, sizeof(DISK_GEOMETRY), &bytes, NULL );
    r = GetLastError();
    CloseHandle(h);

	if (!b) {
	    return r;
    }

    return ERROR_SUCCESS;
}

#endif  // #ifdef CHECK_UNSUPPORTED_CONFIG

/*
BOOL
CFtasrDlg::DeleteFileSystemInfo( 
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId )
{
    // This should be done only for partitions.
    // We have to fill the first sector of the partition with zeroes. There is 
    // the file system info stored.
    
    
    
    //1. Open the volume READ & WRITE, FILE_SHARE_EVERYTHING ....
    //2. GET_DISK_GEOMETRY   ---> get SectorSize
    //3. Allocate a buffer 2*SectorSize
    //4. Choose the first address in the buffer which is multiple of sector size
    //5. Fill the buffer with zeroes
    //6. DeviceIoControl  FSCTL_LOCK_VOLUME
    //7. SetFilePointer to the beginning of the file
    //8. WriteFile (address multiple of SectorSize in the buffer, SectorSize)
    //9. CloseHandle

    //If one of them doesn't work, don't worry! All that can happen is to keep 
    //getting those annoying popups
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftasr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_)
#define AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500

#undef _WIN32_IE
#define _WIN32_IE 0x0400

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
//#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Make "ftasr backup" check for unsupported FT configurations
// This should be a temporary issue
#define CHECK_UNSUPPORTED_CONFIG

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftbreak\ftbreak.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR               driveName[7];
    HANDLE              h;
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId;

    if (argc != 2) {
        printf("usage: %s <diskId>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);

    printf("Breaking %I64X...\n", diskId);

    b = FtBreakLogicalDisk(diskId);

    if (b) {
        printf("Logical disk broken.\n");
    } else {
        printf("Break failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftlink\ftlink.c ===
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    UCHAR               driveLetter;
    FT_LOGICAL_DISK_ID  diskId;
    BOOL                b;

    if (argc != 3 || argv[1][1] != ':') {
        printf("usage: %s <drive:> <DiskId>\n", argv[0]);
        return;
    }

    driveLetter = (UCHAR)toupper(argv[1][0]);
    sscanf(argv[2], "%I64X", &diskId);

    printf("Creating a symbolic link from %c: to %I64X\n", driveLetter, diskId);

    b = FtSetStickyDriveLetter(diskId, driveLetter);

    if (b) {
        printf("Symbolic link created.\n");
    } else {
        printf("Symbolic link create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftextend\ftextend.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    TCHAR                   dosDriveName[10];
    HANDLE                  h;
    BOOL                    b;
    PARTITION_INFORMATION   partInfo;
    DWORD                   bytes;
    DISK_GEOMETRY           geometry;
    LONGLONG                newSectors;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    if (argv[1][1] != ':' || argv[1][2] != 0) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    wsprintf(dosDriveName, TEXT("\\\\.\\%c:"), argv[1][0]);

    h = CreateFile(dosDriveName, GENERIC_READ,
                   FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        printf("Can't open, failed with %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                        &partInfo, sizeof(partInfo), &bytes, NULL);
    if (!b) {
        printf("Can't read partition info, failed with %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
                        &geometry, sizeof(geometry), &bytes, NULL);
    if (!b) {
        printf("Can't read geometry info, failed with %d\n", GetLastError());
        return;
    }

    newSectors = partInfo.PartitionLength.QuadPart/geometry.BytesPerSector;

    b = DeviceIoControl(h, FSCTL_EXTEND_VOLUME, &newSectors, sizeof(newSectors),
                        NULL, 0, &bytes, NULL);

    if (b) {
        printf("File system extended successfully.\n");
    } else {
        printf("File system extension failed.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftinit\ftinit.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId;

    if (argc < 2) {
        printf("usage: %s <diskId> [init-orphans]\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);
    printf("Initializing %I64X...\n", diskId);

    b = FtInitializeLogicalDisk(diskId, argc > 2 ? TRUE : FALSE);

    if (b) {
        printf("Initialize started.\n");
    } else {
        printf("Initialize failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\actdlg.cpp ===
// ActionDlg.cpp : implementation file
//

#include "stdafx.h"

#include "Resource.h"

#include "ActDlg.h"
#include "FrSpace.h"
#include "FTManDef.h"
#include "Item.h"
#include "LogVol.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern LV_COLUMN_CONFIG ColumnsConfig[];

/////////////////////////////////////////////////////////////////////////////
// CActionDlg dialog


CActionDlg::CActionDlg( CObArray* parrVolumeData, UINT nIDTemplate /* =IDD_GENERIC_ACTION */ ,
						BOOL bChangeOrder /* =TRUE */ , CWnd* pParent /* =NULL */)
	: CDialog(nIDTemplate, pParent), m_parrVolumeData( parrVolumeData ), m_bChangeOrder( bChangeOrder )
{
	//{{AFX_DATA_INIT(CActionDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	ASSERT( parrVolumeData );
}


void CActionDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionDlg)
	if( m_bChangeOrder )
	{
		DDX_Control(pDX, IDC_BUTTON_DOWN, m_buttonDown);
		DDX_Control(pDX, IDC_BUTTON_UP, m_buttonUp);
	}
	DDX_Control(pDX, IDC_LIST_VOLUMES, m_listVol);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionDlg, CDialog)
	//{{AFX_MSG_MAP(CActionDlg)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
	ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_VOLUMES, OnItemchangedListVolumes)
	ON_NOTIFY(LVN_KEYDOWN, IDC_LIST_VOLUMES, OnKeydownListVolumes)
	ON_NOTIFY(NM_CLICK, IDC_LIST_VOLUMES, OnClickListVolumes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////////////////////
//  Protected methods

// Insert a item ( with the given data ) at a certain position in the given list ctrl
BOOL CActionDlg::InsertItem( CListCtrl& listCtrl, int iIndex, CItemData* pData )
{
	MY_TRY

	ASSERT(pData);
		
	LVITEM lvitem;
	CString strDisplay;

	// 1. Insert the item

	lvitem.iItem = iIndex;
	ASSERT(LVC_Name==0);		// The first SubItem must be zero
	lvitem.iSubItem = 0;
	pData->GetDisplayExtendedName(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	lvitem.iImage = pData->GetImageIndex();
	lvitem.lParam = (LPARAM)pData;
	lvitem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM ;
	int iActualItem =  listCtrl.InsertItem( &lvitem );
	if( iActualItem < 0 )
		return FALSE;

	// 2. Set all subitems
	
	lvitem.iItem = iActualItem;
	lvitem.mask = LVIF_TEXT;

	// Disks set
	lvitem.iSubItem = 1;
	pData->GetDisplayDisksSet(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	listCtrl.SetItem( &lvitem );

	// Size
	lvitem.iSubItem = 2;
	pData->GetDisplaySize(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	listCtrl.SetItem( &lvitem );

	return TRUE;

	MY_CATCH_AND_THROW
}

// Move an item from the old index to a new index in the given list ctrl
BOOL CActionDlg::MoveItem( CListCtrl& listCtrl, int iOldIndex, int iNewIndex )
{
	MY_TRY

	ASSERT( ( iOldIndex >= 0 )  &&  ( iOldIndex < listCtrl.GetItemCount() ) );
	ASSERT( ( iNewIndex >= 0 )  &&  ( iNewIndex < listCtrl.GetItemCount() ) );

	if( iOldIndex == iNewIndex )
		return TRUE;

	// 1. Get the item information
	LVITEM lvitem;
	lvitem.iItem = iOldIndex;
	lvitem.iSubItem = 0;
	lvitem.mask = LVIF_PARAM;
	if( !listCtrl.GetItem(&lvitem) )
		return FALSE;
	CItemData* pData = (CItemData*)(lvitem.lParam);


	// 2. Delete the item at the old position
	if( !listCtrl.DeleteItem(iOldIndex) )
		return FALSE;

	// 3. Insert the item at the new position
	if ( !InsertItem( listCtrl, iNewIndex, pData ) )
		return FALSE;

	// 4. Select and focus again the item
	m_listVol.SetItemState( iNewIndex, LVIS_SELECTED | LVIS_FOCUSED  , LVIS_SELECTED | LVIS_FOCUSED   );
	return TRUE;

	MY_CATCH_AND_THROW
}

// Prepare the given control list to display volume information
void CActionDlg::ConfigureList ( CListCtrl& listCtrl )
{
	MY_TRY

	if( m_ImageListSmall.GetSafeHandle() != NULL )
		listCtrl.SetImageList(&m_ImageListSmall, LVSIL_SMALL);
	
	// Insert columns (REPORT mode) 
	CRect rect;
	listCtrl.GetWindowRect(&rect);

	// Add some columns ( not all columns from ColumnConfig are necessary in the dialog )
	
	// The name
	PLV_COLUMN_CONFIG pColumn = &(ColumnsConfig[LVC_Name]);
	CString str;
	if( !str.LoadString(pColumn->dwTitleID) )
		ASSERT(FALSE);
	listCtrl.InsertColumn( 0, str, pColumn->nFormat , 
								rect.Width() * 1/2, 0);

	// The disks set
	pColumn = &(ColumnsConfig[LVC_DiskNumber]);
	if( !str.LoadString(pColumn->dwTitleID) )
		ASSERT(FALSE);
	listCtrl.InsertColumn( 1, str, pColumn->nFormat , 
								rect.Width() * 1/6, 1);

	// The size
	pColumn = &(ColumnsConfig[LVC_Size]);
	if( !str.LoadString(pColumn->dwTitleID) )
		ASSERT(FALSE);
	listCtrl.InsertColumn( 2, str, pColumn->nFormat , 
								rect.Width() * 4/15, 2);

	MY_CATCH_AND_THROW

}

// Populate the given control list with the given volumes data
//		parrData should point to an array of CLVTreeItemData objects
void CActionDlg::PopulateList ( CListCtrl& listCtrl, CObArray* parrData )
{
	MY_TRY

	for( int i = 0; i < parrData->GetSize(); i++ )
	{
		CItemData* pData = (CItemData*)(parrData->GetAt(i));
		ASSERT(pData);
		InsertItem( listCtrl, i, pData );
	}

	MY_CATCH_AND_THROW
}

/////////////////////////////////////////////////////////////////////////////
// CActionDlg message handlers

BOOL CActionDlg::OnInitDialog() 
{
	MY_TRY

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	// Set caption
	CString str;
	str.LoadString(IDS_ACTION_DLG_CAPTION);
	SetWindowText(str);

	// Create the image list small icons
	
	// The background color for mask is pink. All image's pixels of this color will take
	// the view's background color.
	if( !m_ImageListSmall.Create( IDB_IMAGELIST_SMALL, 16, 16, RGB( 255, 0, 255 ) ) )
		AfxMessageBox( IDS_ERR_CREATE_IMAGELIST, MB_ICONSTOP );

	// Configure and populate the list ctrl
	ConfigureList( m_listVol );
	ASSERT( m_parrVolumeData->GetSize() > 0 );
	PopulateList( m_listVol, m_parrVolumeData );

	// Select and focus the first item in the list ctrl
	if( m_listVol.GetItemCount() > 0 )
		m_listVol.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED  , LVIS_SELECTED | LVIS_FOCUSED   );

	MY_CATCH_REPORT_AND_CANCEL

    return TRUE;  // return TRUE unless you set the focus to a control
				  // EXCEPTION: OCX Property Pages should return FALSE
}

void CActionDlg::OnDestroy() 
{
	// Delete the image list
	m_ImageListSmall.DeleteImageList();
	
	CDialog::OnDestroy();
}

void CActionDlg::OnButtonUp() 
{
	MY_TRY
	
	ASSERT( m_bChangeOrder );
	int iItem = m_listVol.GetNextItem(-1, LVNI_SELECTED); 
	if (iItem < 0 )
	{
		TRACE(_T("No items were selected!\n"));
		return;
	}
	
	if( iItem > 0 )
	{
		MoveItem( m_listVol, iItem, iItem-1 );
		m_listVol.EnsureVisible(iItem-1, FALSE);
		m_listVol.SetFocus();
	}
	
	MY_CATCH_REPORT_AND_CANCEL
}

void CActionDlg::OnButtonDown() 
{
	MY_TRY
	
	ASSERT( m_bChangeOrder );
	int iItem = m_listVol.GetNextItem(-1, LVNI_SELECTED); 
	if (iItem < 0 )
	{
		TRACE(_T("No items were selected!\n"));
		return;
	}
	
	if( iItem < m_listVol.GetItemCount()-1 )
	{
		MoveItem( m_listVol, iItem, iItem+1 );
		m_listVol.EnsureVisible(iItem+1, FALSE);
		m_listVol.SetFocus();
	}
	
	MY_CATCH_REPORT_AND_CANCEL
}

void CActionDlg::OnItemchangedListVolumes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	// We are interested on items who received focus
	if( m_bChangeOrder &&
		( pNMListView->uChanged & LVIF_STATE ) &&
		( pNMListView->uNewState & LVIS_FOCUSED ) &&
		!( pNMListView->uOldState & LVIS_FOCUSED ) )
	{
		m_buttonUp.EnableWindow( pNMListView->iItem > 0 );
		m_buttonDown.EnableWindow( pNMListView->iItem < m_listVol.GetItemCount() - 1 );
	}
	
	*pResult = 0;
}

void CActionDlg::OnClickListVolumes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	
	POINT pt;
	GetCursorPos( &pt );
	
	LVHITTESTINFO lvhittestinfo;
	lvhittestinfo.pt = pt;
	m_listVol.ScreenToClient( &(lvhittestinfo.pt) );
	lvhittestinfo.pt.x = 4;
	
	int iItem = ListView_SubItemHitTest( m_listVol.GetSafeHwnd(), &lvhittestinfo );

	if( iItem >= 0 )
		m_listVol.SetItemState( iItem, LVIS_SELECTED | LVIS_FOCUSED  , LVIS_SELECTED | LVIS_FOCUSED   );
	else
	{
		if( m_bChangeOrder )
		{
			// Disable buttons Up and Down because no item will be selected
			m_buttonUp.EnableWindow( FALSE );
			m_buttonDown.EnableWindow( FALSE );
		}
	}
}

void CActionDlg::OnOK() 
{
	MY_TRY

	// Just read the new order of members

	if( m_bChangeOrder )
	{
		m_parrVolumeData->RemoveAll();
		for( int i = 0; i < m_listVol.GetItemCount(); i++ )
		{
			LVITEM lvitem;
			lvitem.iItem = i;
			lvitem.iSubItem = 0;
			lvitem.mask = LVIF_PARAM;
			if( !m_listVol.GetItem(&lvitem) )
				return;

			CItemData* pData = (CItemData*)(lvitem.lParam);
			ASSERT(pData);
			m_parrVolumeData->Add( pData );
		}
	}
	
	CDialog::OnOK();
	
	MY_CATCH_REPORT_AND_CANCEL
}

void CActionDlg::OnKeydownListVolumes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	if( !m_bChangeOrder )
	{
		*pResult = 0;
		return;
	}

#pragma message("TODO: A keyboard hook would be more useful here")	
	LV_KEYDOWN* pLVKeyDown = (LV_KEYDOWN*)pNMHDR;
	// TODO: Add your control notification handler code here

	// We are interested on:
	//    SHIFT-UP or U		equivalent with pressing button "Up"
	//	  SHIFT_DOWN or D	equivalent with pressing button "Down"	
	
	BOOL bIsShiftPressed = ( GetAsyncKeyState( VK_SHIFT ) & 0x8000 );
	
	if(	( ( pLVKeyDown->wVKey == VK_DOWN ) && bIsShiftPressed ) ||
		( pLVKeyDown->wVKey == 'D') )
	{
		OnButtonDown();
		*pResult = 1;
		return;
	}
	
	if(	( ( pLVKeyDown->wVKey == VK_UP ) && bIsShiftPressed ) ||
		( pLVKeyDown->wVKey == 'U') )
	{
		OnButtonUp();
		*pResult = 1;
		return;
	}
	
	*pResult = 0;
}



/////////////////////////////////////////////////////////////////////////////
// CCreateStripeDlg dialog


CCreateStripeDlg::CCreateStripeDlg( CObArray* parrVolumeData, 
						UINT nIDTemplate /* =IDD_CREATE_STRIPE */ ,CWnd* pParent /* =NULL */)
	: CActionDlg( parrVolumeData, nIDTemplate, TRUE, pParent)
{
	//{{AFX_DATA_INIT(CCreateStripeDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_ulStripeSize = 0x10000;  // 64KB
}


void CCreateStripeDlg::DoDataExchange(CDataExchange* pDX)
{
	CActionDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreateStripeDlg)
	DDX_Control(pDX, IDC_COMBO_STRIPE_SIZE, m_comboStripeSize);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateStripeDlg, CActionDlg)
	//{{AFX_MSG_MAP(CCreateStripeDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionDlg message handlers

BOOL CCreateStripeDlg::OnInitDialog() 
{
	MY_TRY

	CActionDlg::OnInitDialog();

	// Fill the stripe size combo with all powers of 2 between 8KB and 4MB
	for( ULONG ulStripeSize = 0x2000; ulStripeSize <= 0x400000; ulStripeSize = ( ulStripeSize << 1 ) )
	{
		CString strStripeSize;
		FormatVolumeSize( strStripeSize, ulStripeSize );
		int nIndex = m_comboStripeSize.AddString( strStripeSize );
		if( nIndex != CB_ERR )
		{
			m_comboStripeSize.SetItemData(nIndex, ulStripeSize );
			if( ulStripeSize == m_ulStripeSize )
				m_comboStripeSize.SetCurSel(nIndex);
		}
	}
	
	MY_CATCH_REPORT_AND_CANCEL

    return TRUE;  // return TRUE unless you set the focus to a control
				  // EXCEPTION: OCX Property Pages should return FALSE
}

void CCreateStripeDlg::OnOK() 
{
	// TODO: Add extra validation here

	int nIndex = m_comboStripeSize.GetCurSel();
	ASSERT( nIndex >= 0 );
	m_ulStripeSize = (ULONG)(m_comboStripeSize.GetItemData(nIndex));
	
	CActionDlg::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CBreakDlg dialog

CBreakDlg::CBreakDlg( CLogicalVolumeData *pSetData, CObArray* parrMembersData, 
						UINT nIDTemplate /* =IDD_BREAK */ ,	CWnd* pParent /* =NULL */ )
	: CActionDlg( parrMembersData, nIDTemplate, FALSE, pParent), 
				m_pSetData(pSetData), m_nWinnerIndex(-1), m_nFocusedItem(-1)
					
{
	MY_TRY

	//{{AFX_DATA_INIT(CBreakDlg)
	m_staticSetName = _T("");
	//}}AFX_DATA_INIT

	ASSERT( pSetData );
	m_pSetData->GetDisplayExtendedName(m_staticSetName);	

	MY_CATCH_AND_REPORT
}


void CBreakDlg::DoDataExchange(CDataExchange* pDX)
{
	CActionDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBreakDlg)
	DDX_Text(pDX, IDC_STATIC_SET_NAME, m_staticSetName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBreakDlg, CActionDlg)
	//{{AFX_MSG_MAP(CBreakDlg)
	ON_NOTIFY(LVN_ITEMCHANGING, IDC_LIST_VOLUMES, OnItemchangingListVolumes)
	ON_NOTIFY(NM_CLICK, IDC_LIST_VOLUMES, OnClickListVolumes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBreakDlg message handlers

BOOL CBreakDlg::OnInitDialog() 
{
	CActionDlg::OnInitDialog();

	// Select and focus the first healthy member
	for( int i = 0; i < m_listVol.GetItemCount(); i++ )
	{
		CItemData* pData = (CItemData*)(m_listVol.GetItemData(i));
		ASSERT(pData);
		if( pData->GetMemberStatus() == FtMemberHealthy )
		{
			m_listVol.SetItemState( i, LVIS_SELECTED | LVIS_FOCUSED  , LVIS_SELECTED | LVIS_FOCUSED   );
			break;
		}
	}

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CBreakDlg::OnOK() 
{
	// Get the winner
	int iItem = m_listVol.GetNextItem(-1, LVNI_SELECTED); 
	if (iItem < 0 )
	{
		TRACE(_T("No items were selected!\n"));
		return;
	}

	m_nWinnerIndex = iItem;

	CActionDlg::OnOK();
}

void CBreakDlg::OnItemchangingListVolumes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	if(	pNMListView->uChanged & LVIF_STATE )
	{
		// If the item receives focus check whether the item is healthy or not
		if(	( pNMListView->uNewState & LVIS_FOCUSED ) &&
			!( pNMListView->uOldState & LVIS_FOCUSED ) )
		{
			CItemData* pMemberData = (CItemData*)(pNMListView->lParam);
			if( pMemberData->GetMemberStatus() == FtMemberHealthy )
			{
				// The member is healthy so proceed with item changing
				m_nFocusedItem = pNMListView->iItem;
				*pResult = 0;
				return;
			}
			else
			{
				// The member is not healthy so prevent item changing
				if( m_nFocusedItem >= 0 )
				{
					m_listVol.SetItemState( m_nFocusedItem, LVIS_SELECTED | LVIS_FOCUSED  , LVIS_SELECTED | LVIS_FOCUSED   );
					m_listVol.RedrawItems( m_nFocusedItem, m_nFocusedItem );
				}
				*pResult = 1;
				return;
			}
		}
		
		// If the item has the focus but looses selection then prevent this to happen
		if(	!( pNMListView->uNewState & LVIS_SELECTED ) &&
			( pNMListView->uOldState & LVIS_SELECTED ) )
		{
			if( m_listVol.GetItemState( pNMListView->iItem, LVIS_FOCUSED ) & LVIS_FOCUSED )
			{
				*pResult = 1;
				return;
			}
		}
	}

	*pResult = 0;
}

void CBreakDlg::OnClickListVolumes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	*pResult = 0;
	
	POINT pt;
	GetCursorPos( &pt );
	
	LVHITTESTINFO lvhittestinfo;
	lvhittestinfo.pt = pt;
	m_listVol.ScreenToClient( &(lvhittestinfo.pt) );
	lvhittestinfo.pt.x = 4;
	
	int iItem = ListView_SubItemHitTest( m_listVol.GetSafeHwnd(), &lvhittestinfo );

	if( iItem < 0 )
		return;

	CItemData* pMemberData = (CItemData*)(m_listVol.GetItemData( iItem ) ); 
	if( pMemberData->GetMemberStatus() == FtMemberHealthy )
	{
		int iFocusedItem = m_nFocusedItem;
		m_listVol.SetItemState( iItem, LVIS_SELECTED | LVIS_FOCUSED  , LVIS_SELECTED | LVIS_FOCUSED   );		
		m_listVol.SetItemState( iFocusedItem, 0, LVIS_SELECTED | LVIS_FOCUSED );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSwapDlg dialog

CSwapDlg::CSwapDlg( CLogicalVolumeData *pParentData, CLogicalVolumeData *pMemberData, 
						CObArray* parrVolumeData, UINT nIDTemplate /* =IDD_SWAP */ , CWnd* pParent /* =NULL */ )
	: CActionDlg( parrVolumeData, nIDTemplate, FALSE, pParent), 
				m_pParentData(pParentData), m_pMemberData(pMemberData), m_nReplacementIndex(-1)
					
{
	MY_TRY

	//{{AFX_DATA_INIT(CBreakDlg)
	m_staticTitle = _T("");
	//}}AFX_DATA_INIT

	ASSERT( pParentData );
	ASSERT( pMemberData );

	CString strParentName, strMemberName;
	pParentData->GetDisplayExtendedName( strParentName );
	pMemberData->GetDisplayExtendedName( strMemberName );

	AfxFormatString2( m_staticTitle, IDS_SWAP_DLG_TITLE, strMemberName, strParentName );

	MY_CATCH_AND_REPORT
}


void CSwapDlg::DoDataExchange(CDataExchange* pDX)
{
	CActionDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSwapDlg)
	DDX_Text(pDX, IDC_STATIC_TITLE, m_staticTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSwapDlg, CActionDlg)
	//{{AFX_MSG_MAP(CSwapDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSwapDlg message handlers

BOOL CSwapDlg::OnInitDialog() 
{
	CActionDlg::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSwapDlg::OnOK() 
{
	// Get the replacement index
	int iItem = m_listVol.GetNextItem(-1, LVNI_SELECTED); 
	if (iItem < 0 )
	{
		TRACE(_T("No items were selected!\n"));
		return;
	}

	m_nReplacementIndex = iItem;

	CActionDlg::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
// CAssignDlg dialog


CAssignDlg::CAssignDlg( CItemData* pVolumeData, CWnd* pParent /*=NULL*/)
	: CDialog(CAssignDlg::IDD, pParent), m_pVolumeData( pVolumeData )
{
	MY_TRY

	//{{AFX_DATA_INIT(CAssignDlg)
	m_staticName = _T("");
	m_radioAssign = pVolumeData->GetDriveLetter() ? 0 : 1;
	//}}AFX_DATA_INIT

	ASSERT( pVolumeData );

	pVolumeData->GetDisplayExtendedName(m_staticName );

	MY_CATCH_AND_REPORT
}


void CAssignDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAssignDlg)
	DDX_Control(pDX, IDC_COMBO_DRIVE_LETTERS, m_comboDriveLetters);
	DDX_Text(pDX, IDC_STATIC_SET_NAME, m_staticName);
	DDX_Radio(pDX, IDC_RADIO_ASSIGN, m_radioAssign);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAssignDlg, CDialog)
	//{{AFX_MSG_MAP(CAssignDlg)
	ON_BN_CLICKED(IDC_RADIO_ASSIGN, OnRadioAssign)
	ON_BN_CLICKED(IDC_RADIO_DO_NOT_ASSIGN, OnRadioDoNotAssign)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CAssignDlg::FillDriveLettersCombo()
{
	MY_TRY

	DWORD bitmask, bit;
	TCHAR cDriveLetter;

	bitmask = GetLogicalDrives();
	if( bitmask == 0 )
	{
		DisplaySystemErrorMessage( IDS_ERR_GET_LOGICAL_DRIVES );
		return FALSE;
	}

	for( cDriveLetter = _T('C'), bit = 4 ; cDriveLetter <= _T('Z'); cDriveLetter++, bit = bit<<1 )
	{
		if( ( cDriveLetter == m_pVolumeData->GetDriveLetter() ) ||
			!( bitmask&bit ) )
		{
			CString str;
			str.Format( _T("%c:"), cDriveLetter );
			int nIndex = m_comboDriveLetters.AddString(str);
			if( nIndex == CB_ERR )
				return FALSE;
			if( !m_comboDriveLetters.SetItemData(nIndex, (DWORD)cDriveLetter ) )
				return FALSE;
			if( cDriveLetter == m_pVolumeData->GetDriveLetter() )
				m_comboDriveLetters.SetCurSel(nIndex);
		}
	}

	return TRUE;

	MY_CATCH_AND_THROW
}

/////////////////////////////////////////////////////////////////////////////
// CAssignDlg message handlers

BOOL CAssignDlg::OnInitDialog() 
{
	MY_TRY

	CDialog::OnInitDialog();

	if( !FillDriveLettersCombo() )
		OnCancel();

	if( m_comboDriveLetters.GetCount() == 0 )
	{
		ASSERT( !m_pVolumeData->GetDriveLetter() );
		GetDlgItem(IDC_RADIO_ASSIGN)->EnableWindow(FALSE);
	}
	else if ( m_comboDriveLetters.GetCurSel() == CB_ERR )
		m_comboDriveLetters.SetCurSel(0);

	if( m_radioAssign != 0 )
		m_comboDriveLetters.EnableWindow(FALSE);
	
	MY_CATCH_REPORT_AND_CANCEL

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAssignDlg::OnOK() 
{
	// TODO: Add extra validation here
	UpdateData(TRUE);

	m_bAssign = ( m_radioAssign == 0 );

	if( m_bAssign )
	{
		int nIndex = m_comboDriveLetters.GetCurSel();
		ASSERT( nIndex != CB_ERR );
		m_cDriveLetter = (TCHAR)(m_comboDriveLetters.GetItemData(nIndex)); 
	}
	else
		m_cDriveLetter = _T('\0');
	
	CDialog::OnOK();
}

void CAssignDlg::OnRadioAssign() 
{
	// Enable the drive letters combo
	m_comboDriveLetters.EnableWindow(TRUE);
}

void CAssignDlg::OnRadioDoNotAssign() 
{
	// Disable the drive letters combo
	m_comboDriveLetters.EnableWindow(FALSE);
	
}
/////////////////////////////////////////////////////////////////////////////
// CCreatePartitionDlg dialog


CCreatePartitionDlg::CCreatePartitionDlg(	CFreeSpaceData* pFreeData, LONGLONG llPartStartOffset,
											BOOL bExtendedPartition /* = FALSE */, CWnd* pParent /*=NULL*/)
		: CDialog(CCreatePartitionDlg::IDD, pParent), m_pFreeData( pFreeData ), 
			m_llPartStartOffset( llPartStartOffset), m_bExtendedPartition( bExtendedPartition)
{
	//{{AFX_DATA_INIT(CCreatePartitionDlg)
	//}}AFX_DATA_INIT

	ASSERT( pFreeData );
	ASSERT( llPartStartOffset >= pFreeData->m_llOffset );
	// The partition size should be greater than or equal with the cylinder size
	ASSERT( llPartStartOffset + pFreeData->m_llCylinderSize <= pFreeData->m_llOffset + pFreeData->m_llSize );
}


void CCreatePartitionDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreatePartitionDlg)
	DDX_Control(pDX, IDC_STATIC_PARTITION_TYPE, m_staticPartitionType);
	DDX_Control(pDX, IDC_EDIT_PARTITION_SIZE, m_editPartitionSize);
	DDX_Control(pDX, IDC_STATIC_MINIMUM_SIZE, m_staticMinimumSize);
	DDX_Control(pDX, IDC_STATIC_MAXIMUM_SIZE, m_staticMaximumSize);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreatePartitionDlg, CDialog)
	//{{AFX_MSG_MAP(CCreatePartitionDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreatePartitionDlg message handlers

BOOL CCreatePartitionDlg::OnInitDialog() 
{
	MY_TRY

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	CString str;

	if( m_bExtendedPartition )
	{
		ASSERT( m_pFreeData->m_wFreeSpaceType == FST_Primary );
		str.LoadString( IDS_TYPE_EXTENDED_PARTITION );
	}
	else
	{
		if( m_pFreeData->m_wFreeSpaceType == FST_Primary )
			str.LoadString( IDS_TYPE_PRIMARY_PARTITION );
		else
			str.LoadString( IDS_TYPE_PARTITION_IN_EXTENDED_PARTITION );
	}
	m_staticPartitionType.SetWindowText( str);
	
	ASSERT( m_pFreeData->m_llCylinderSize <= m_pFreeData->m_llSize );
	
	str.Format(_T("%I64u"), (LONGLONG)(m_pFreeData->m_llCylinderSize / 0x100000) );
	m_staticMinimumSize.SetWindowText(str);
	
	str.Format(_T("%I64u"), 
		(LONGLONG)( ( m_pFreeData->m_llOffset + m_pFreeData->m_llSize - m_llPartStartOffset ) / 0x100000 ) );
	m_staticMaximumSize.SetWindowText(str);
	m_editPartitionSize.SetWindowText(str);

	// The number input in the edit-box must be less than 2^63 / 2^20 = 8796093022208
	m_editPartitionSize.LimitText(13);
		
	MY_CATCH_REPORT_AND_CANCEL

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCreatePartitionDlg::OnOK() 
{
	MY_TRY

	// TODO: Add extra validation here

	CString str;

	m_editPartitionSize.GetWindowText(str);
	LONGLONG llSizeInMB = _ttoi64(str);

	if(	( llSizeInMB < (LONGLONG)( m_pFreeData->m_llCylinderSize / 0x100000 ) ) ||
		( llSizeInMB > (LONGLONG)( ( m_pFreeData->m_llOffset + m_pFreeData->m_llSize - m_llPartStartOffset ) / 0x100000 ) ) )
	{
		AfxMessageBox(IDS_ERR_INVALID_SIZE, MB_ICONSTOP );
		return;
	}

	m_llPartitionSize = llSizeInMB * 0x100000;
	
	CDialog::OnOK();

	MY_CATCH_REPORT_AND_CANCEL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\actdlg.h ===
#if !defined(AFX_ACTDLG_H__190377E2_727F_11D2_B499_00A0C9063765__INCLUDED_)
#define AFX_ACTDLG_H__190377E2_727F_11D2_B499_00A0C9063765__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CActionDlg dialog

class CItemData;
class CLogicalVolumeData;
class CFreeSpaceData;

class CActionDlg : public CDialog
{
// Construction
public:
	CActionDlg(CObArray* parrVolumeData, UINT nIDTemplate = IDD_GENERIC_ACTION ,
					BOOL bChangeOrder = TRUE, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CActionDlg)
	enum { IDD = IDD_GENERIC_ACTION };
	CButton	m_buttonDown;
	CButton	m_buttonUp;
	CListCtrl	m_listVol;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CActionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Protected data members
protected:
	// Array of CItemData. The list of volumes to display in the "Members" list ctrl 
	CObArray*	m_parrVolumeData;

	// Should the user be allowed to change the order of the volumes in list-view m_listVol ?
	BOOL		m_bChangeOrder;

	// Image lists for all list controls
	CImageList	m_ImageListSmall;	// Small (16x16) icons

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CActionDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonUp();
	afx_msg void OnButtonDown();
	afx_msg void OnItemchangedListVolumes(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnKeydownListVolumes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClickListVolumes(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Insert a item ( with the given data ) at a certain position in the given list ctrl
	BOOL InsertItem( CListCtrl& listCtrl, int iIndex, CItemData* pData );

	// Move an item from the old index to a new index in the given list ctrl
	BOOL MoveItem( CListCtrl& listCtrl, int iOldIndex, int iNewIndex );
	
	// Prepare the given control list to display volume information
	void ConfigureList ( CListCtrl& listCtrl );

	// Populate the given control list with the given volumes data
	//		parrData should point to an array of CItemData objects
	void PopulateList ( CListCtrl& listCtrl, CObArray* parrData );
};

/////////////////////////////////////////////////////////////////////////////
// CCreateStripeDlg dialog


class CCreateStripeDlg : public CActionDlg
{
// Construction
public:
	CCreateStripeDlg(CObArray* parrVolumeData, UINT nIDTemplate = IDD_CREATE_STRIPE ,CWnd* pParent = NULL);   // standard constructor

// Public data members
public:
	// Dialog Data
	//{{AFX_DATA(CCreateStripeDlg)
	// enum { IDD = IDD_CREATE_STRIPE };
	CComboBox	m_comboStripeSize;
	//}}AFX_DATA
	
	ULONG	m_ulStripeSize;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateStripeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateStripeDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CBreakDlg dialog

class CBreakDlg : public CActionDlg
{
// Construction
public:
	CBreakDlg( CLogicalVolumeData *pSetData, CObArray* parrMembersData, 
					UINT nIDTemplate = IDD_BREAK ,	CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CBreakDlg)
	enum { IDD = IDD_BREAK };
	CString	m_staticSetName;
	//}}AFX_DATA

	int		m_nWinnerIndex;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBreakDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Protected data members
protected:
	// Pointer to the data of the set to be broken
	CLogicalVolumeData* m_pSetData;

	// The item having focus ( and selection )
	int	m_nFocusedItem;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBreakDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnItemchangingListVolumes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClickListVolumes(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSwapDlg dialog

class CSwapDlg : public CActionDlg
{
// Construction
public:
	CSwapDlg( CLogicalVolumeData *pParentData, CLogicalVolumeData *pMemberData,	
				CObArray* parrReplacementsData, UINT nIDTemplate = IDD_SWAP ,	CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSwapDlg)
	enum { IDD = IDD_SWAP };
	CString	m_staticTitle;
	//}}AFX_DATA

	int		m_nReplacementIndex;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSwapDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Protected data members
protected:
	// Pointer to the data of the parent set 
	CLogicalVolumeData* m_pParentData;

	// Pointer to the data of the member to replace
	CLogicalVolumeData* m_pMemberData;
	
// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSwapDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CAssignDlg dialog

class CAssignDlg : public CDialog
{
// Construction
public:
	CAssignDlg(CItemData* pVolumeData, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAssignDlg)
	enum { IDD = IDD_ASSIGN_DRIVE_LETTER };
	CComboBox	m_comboDriveLetters;
	CString	m_staticName;
	int		m_radioAssign;
	//}}AFX_DATA

	BOOL	m_bAssign;
	TCHAR	m_cDriveLetter;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAssignDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Data of the volume
	CItemData* m_pVolumeData;

	// Generated message map functions
	//{{AFX_MSG(CAssignDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnRadioAssign();
	afx_msg void OnRadioDoNotAssign();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL FillDriveLettersCombo();
};
/////////////////////////////////////////////////////////////////////////////
// CCreatePartitionDlg dialog

class CCreatePartitionDlg : public CDialog
{
// Construction
public:
	CCreatePartitionDlg(	CFreeSpaceData* pFreeData, LONGLONG llPartStartOffset, 
							BOOL bExtendedPartition = FALSE,  CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreatePartitionDlg)
	enum { IDD = IDD_CREATE_PARTITION };
	CStatic	m_staticPartitionType;
	CEdit	m_editPartitionSize;
	CStatic	m_staticMinimumSize;
	CStatic	m_staticMaximumSize;
	//}}AFX_DATA

	LONGLONG	m_llPartitionSize;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreatePartitionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Pointer to the data of the free space
	CFreeSpaceData* m_pFreeData;

	// Partition starting offset
	LONGLONG m_llPartStartOffset;

	// Should we create an extended partition?
	BOOL	m_bExtendedPartition;

	// Generated message map functions
	//{{AFX_MSG(CCreatePartitionDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTDLG_H__190377E2_727F_11D2_B499_00A0C9063765__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\actions.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	Actions.h

Abstract:

    Definition of global functions related to actions that can be performed in the tree and list views
	All action function receives an array of CItemData items and performs the appropriate action on them

Author:

    Cristian Teodorescu      December 1, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONS_H_INCLUDED_)
#define AFX_ACTIONS_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Assign drive letter
void ActionAssign( CObArray& arrSelectedItems  );
void UpdateActionAssign( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Break mirror
void ActionFtbreak( CObArray& arrSelectedItems  );
void UpdateActionFtbreak( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Create extended partition
void ActionCreateExtendedPartition( CObArray& arrSelectedItems  );
void UpdateActionCreateExtendedPartition( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Create partition
void ActionCreatePartition( CObArray& arrSelectedItems  );
void UpdateActionCreatePartition( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Delete
void ActionDelete( CObArray& arrSelectedItems  );
void UpdateActionDelete( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Regenerate the broken member of a mirror set or stripe set with parity
void ActionFtinit( CObArray& arrSelectedItems  );
void UpdateActionFtinit( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Create mirror set
void ActionFtmirror( CObArray& arrSelectedItems  );
void UpdateActionFtmirror( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Create stripe set
void ActionFtstripe( CObArray& arrSelectedItems  );
void UpdateActionFtstripe( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Swap member of a mirror set or stripe set with parity
void ActionFtswap( CObArray& arrSelectedItems  );
void UpdateActionFtswap( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Create stripe set with parity
void ActionFtswp( CObArray& arrSelectedItems  );
void UpdateActionFtswp( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

// Create volume set
void ActionFtvolset( CObArray& arrSelectedItems  );
void UpdateActionFtvolset( CCmdUI* pCmdUI, CObArray& arrSelectedItems );

#endif // !defined(AFX_ACTIONS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\actions.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	Actions.cpp

Abstract:

    Definition of global functions related to actions that can be performed in the tree and list views
	Every action function receives an array of CItemData items and performs the appropriate action on them

Author:

    Cristian Teodorescu      December 1, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "Resource.h"

#include "ActDlg.h"
#include "Actions.h"
#include "DiskMap.h"
#include "FrSpace.h"
#include "FTTreeVw.h"
#include "FTUtil.h"
#include "Item.h"
#include "LogVol.h"
#include "MainFrm.h"
#include "PhPart.h"
#include "RootVol.h"

#include <winbase.h>

//////////////////////////////////////////////////////////////////////////////////////////////
// Assign drive letter

void ActionAssign( CObArray& arrSelectedItems )
{
	MY_TRY
	
	CAutoRefresh  ar(FALSE);

	CItemData*	pData;
	
	ASSERT( arrSelectedItems.GetSize() == 1 );

	pData = (CItemData*)( arrSelectedItems[0] );
	ASSERT(pData);

	ASSERT( ( pData->GetItemType() == IT_LogicalVolume  ) ||
			( pData->GetItemType() == IT_PhysicalPartition )  ); 			
	ASSERT( pData->IsRootVolume() && pData->IsValid() );

	CAssignDlg dlg( pData );
	if( dlg.DoModal() != IDOK )
		return;;
	
	AfxGetApp()->DoWaitCursor(1);

	TCHAR cOldDriveLetter = pData->GetDriveLetter();
	BOOL bResult = FALSE, bChanged = FALSE;
	
	// If the volume had a drive letter and now it shouldn't have any or it should have another one
	// then free the old drive letter
	if(	cOldDriveLetter &&
		( !dlg.m_bAssign || ( dlg.m_bAssign && ( cOldDriveLetter != dlg.m_cDriveLetter ) ) ) )
	{
		CString strMountPoint;
		strMountPoint.Format(_T("%c:\\"), cOldDriveLetter);
		bResult = DeleteVolumeMountPoint(strMountPoint);
		if( !bResult )
		{
			DisplaySystemErrorMessage( IDS_ERR_DELETE_MOUNT_POINT );
			AfxRefreshAll();
			AfxGetApp()->DoWaitCursor(-1);
			return;
		}
		else
			bChanged = TRUE;
	}

	// If the volume had a drive letter and now it should have another one or if it had no drive letter and
	// now it should have one then assign a the new drive letter to the volume
	if( dlg.m_bAssign &&
		( ( cOldDriveLetter && ( cOldDriveLetter != dlg.m_cDriveLetter ) ) || !cOldDriveLetter )  )
	{
		CString strMountPoint, strVolumeName;
		strMountPoint.Format(_T("%c:\\"), dlg.m_cDriveLetter );
		strVolumeName = pData->GetVolumeName();
		strVolumeName += _T("\\");
		
		bResult = SetVolumeMountPoint( strMountPoint, strVolumeName );
		if( !bResult )
			DisplaySystemErrorMessage( IDS_ERR_SET_MOUNT_POINT );
		else
			bChanged = TRUE;
	}

	if( bResult )
		AfxMessageBox(IDS_MSG_ASSIGN, MB_ICONINFORMATION);

	if( bChanged )
		AfxRefreshAll();
	
	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionAssign( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// Action enabling conditions:
	// 1. 1 ( and only 1 ) item must be selected
	// 2. The selected item must be a root volume ( logical volume or physical partition )
	// 3. The selected item must be valid
	
	CItemData*			pData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)( arrSelectedItems[0] );
	ASSERT(pData);

	if( ( pData->GetItemType() != IT_LogicalVolume ) &&
		( pData->GetItemType() != IT_PhysicalPartition ) )
			goto label_disable;
	if( !pData->IsRootVolume() || !pData->IsValid() )
		goto label_disable;
	
	pCmdUI->Enable(TRUE);
	return;

label_disable:
	pCmdUI->Enable(FALSE);	
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Break mirror

/*
void ActionFtbreak( CObArray& arrSelectedItems )
{
	MY_TRY

	ASSERT( arrSelectedItems.GetSize() == 1 );
	ASSERT( m_pParentData->GetItemType() == IT_Root );

	CItemData* pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_LogicalVolume );

	CObArray	arrVolumeData;
	arrVolumeData.Add(pData);
	CActionDlg dlg(&arrVolumeData);
	if( dlg.DoModal() != IDOK )
		return;
	
	FT_LOGICAL_DISK_ID llVolID;
	pData->GetVolumeID( llVolID );
	
	FTBreak( llVolID );
	
	AfxRefreshAll();

	MY_CATCH_AND_REPORT
}
*/

void ActionFtbreak( CObArray& arrSelectedItems)
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	CItemData*			pData;

	ASSERT( arrSelectedItems.GetSize() == 1 );
		
	pData = (CItemData*)( arrSelectedItems[0] );
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_LogicalVolume ); 			
	ASSERT( pData->IsRootVolume() && pData->IsValid() );

	CLogicalVolumeData* pLogVolData = (CLogicalVolumeData*)pData;
	ASSERT( pLogVolData->m_nVolType == FtMirrorSet );

	// Read the members of the mirror
	CObArray	arrMembersData;
	CString		strErrors;
	if( !pLogVolData->ReadMembers( arrMembersData, strErrors ) )
	{
		AfxMessageBox( strErrors, MB_ICONSTOP );
		return;
	}

	CBreakDlg dlg( pLogVolData, &arrMembersData );
	if( dlg.DoModal() != IDOK )
		goto label_cleanup;
	
	AfxGetApp()->DoWaitCursor(1);

	if( dlg.m_nWinnerIndex == 1 )
	{
		// The winner is the second member. We have to orphan the first member ( if healthy )
		if( ((CItemData*)arrMembersData[0])->GetMemberStatus() == FtMemberHealthy )
		{
			if( !FTOrphan( pLogVolData->m_llVolID, 0 ) )
			{
				AfxGetApp()->DoWaitCursor(-1);
				goto label_cleanup;
			}
		}
	}
	else
	{
		ASSERT( dlg.m_nWinnerIndex == 0 );
	}

	// Break the mirror
	if( FTBreak( pLogVolData->m_llVolID ) )
	{
		CItemIDSet	setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;
		
		// Now break all former members ( if they are FT Partitions )
		// All members must be added to setListSelectedItems in order to emphasize them after
		// refreshing the list view
		
		// Select the root volumes item in the tree view
		idItem.m_wItemType = IT_RootVolumes;
		setTreeSelectedItems.Add( idItem );
		
		for( int i = 0; i < arrMembersData.GetSize(); i++ )
		{
			BOOL bPhPart;

			CLogicalVolumeData* pMemberData = (CLogicalVolumeData*)(arrMembersData[i]);
			if( pMemberData->m_nVolType == FtPartition )
				bPhPart = FTBreak( pMemberData->m_llVolID );
			else
				bPhPart = FALSE;

			if( bPhPart )
			{
				// The member is now a physical partition
				ASSERT( pMemberData->m_nVolType == FtPartition );
				idItem.m_wItemType = IT_PhysicalPartition;
				idItem.m_ID.m_PhysicalPartitionID.m_ulDiskNumber = pMemberData->m_ConfigInfo.partConfig.Config.DiskNumber;
				idItem.m_ID.m_PhysicalPartitionID.m_llOffset = pMemberData->m_ConfigInfo.partConfig.Config.ByteOffset;
			}
			else
			{
				// The member is still a logical volume
				idItem.m_wItemType = IT_LogicalVolume;
				idItem.m_ID.m_LogicalVolumeID.m_llVolID = pMemberData->m_llVolID;
			}
			setListSelectedItems.Add( idItem );
		}

		AfxMessageBox( IDS_MSG_FTBREAK, MB_ICONINFORMATION );

		// Now refresh both views and emphasize the members of the old mirror set
		AfxRefreshAll( NULL, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
		AfxRefreshAll();

	AfxGetApp()->DoWaitCursor(-1);

label_cleanup:	
	// Delete the array of members
	for( int i = 0; i < arrMembersData.GetSize(); i++ )
	{
		pData = (CItemData*)(arrMembersData[i]);
		if( pData )
			delete pData;
	}
	arrMembersData.RemoveAll();

	MY_CATCH_AND_REPORT
}

/*
void UpdateActionFtbreak( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// This action should be enabled only when:
	// 1. single selection
	// 2. Its parent is the root item
	// 3. the selected item is a logical volume

	POSITION			pos;
	
	if( ( arrSelectedItems.GetSize() != 1 ) ||
		( m_pParentData->GetItemType() != IT_Root) )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetTreeItemType() != IT_LogicalVolume )
		goto label_disable;

	pCmdUI->Enable(TRUE);
	return;

label_disable:
	pCmdUI->Enable(FALSE);

}
*/

void UpdateActionFtbreak( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// Action enabling conditions:
	// 1. 1 ( and only 1 ) item must be selected
	// 2. The selected item must be a root volume
	// 3. The selected item must be a mirror set
	// 4. The selected item must be valid
	
	CItemData*			pData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetItemType() != IT_LogicalVolume )
			goto label_disable;
	if( !pData->IsRootVolume() || !pData->IsValid() )
		goto label_disable;
	if( ((CLogicalVolumeData*)pData)->m_nVolType != FtMirrorSet )
			goto label_disable;
	
	pCmdUI->Enable(TRUE);
	return;

label_disable:
	pCmdUI->Enable(FALSE);	
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Create extended partition

void ActionCreateExtendedPartition( CObArray& arrSelectedItems )
{
	MY_TRY
	
	CAutoRefresh  ar(FALSE);
	
	CItemData*			pData;

	ASSERT( arrSelectedItems.GetSize() == 1 );
		
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_FreeSpace  );
	
	CFreeSpaceData* pFreeData = (CFreeSpaceData*)pData;

	ASSERT( pFreeData->m_wFreeSpaceType == FST_Primary );
	
	if( pFreeData->m_dwExtendedPartitionCountOnLevel > 0 )
	{
		// There is another extended partition on the disk
		AfxMessageBox( IDS_ERR_ANOTHER_EXTENDED_PARTITION, MB_ICONSTOP );
		return;
	}

	if( pFreeData->m_dwPartitionCountOnLevel + pFreeData->m_dwExtendedPartitionCountOnLevel >= 4 )
	{
		// This must not happen inside an extended partition!
		AfxMessageBox( IDS_ERR_PARTITION_TABLE_FULL, MB_ICONSTOP );
		return;
	}
		
	// The starting offset of the extended partition must be the next cylinder border after the beginning of the free space
	LONGLONG llExtPartStartOffset = ((LONGLONG)((pFreeData->m_llOffset + pFreeData->m_llCylinderSize - 1) / pFreeData->m_llCylinderSize)) * pFreeData->m_llCylinderSize;
	CCreatePartitionDlg dlg( pFreeData, llExtPartStartOffset, TRUE );
	if( dlg.DoModal() != IDOK )
		return;;
	
	AfxGetApp()->DoWaitCursor(1);

	CDiskMap diskMap( pFreeData->m_dwDiskNumber );
	LONGLONG llNewFreeSpaceOffset;
	
	BOOL bResult = diskMap.CreateExtendedPartition( llExtPartStartOffset, dlg.m_llPartitionSize, llNewFreeSpaceOffset );

	if( bResult )
	{
		AfxMessageBox( IDS_MSG_CREATE_EXTENDED_PARTITION, MB_ICONINFORMATION );
		
		// Now refresh both views and emphasize the new partition
		CItemIDSet	setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_RootFreeSpaces;
		setTreeSelectedItems.Add( idItem );

		idItem.m_wItemType = IT_FreeSpace;
		idItem.m_ID.m_FreeSpaceID.m_ulDiskNumber = pFreeData->m_dwDiskNumber;
		idItem.m_ID.m_FreeSpaceID.m_llOffset = llNewFreeSpaceOffset;
		setListSelectedItems.Add( idItem );

		AfxRefreshAll( NULL, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
	{
		AfxMessageBox( IDS_ERR_CREATE_EXTENDED_PARTITION, MB_ICONSTOP );
		AfxRefreshAll();
	}

	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionCreateExtendedPartition( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// Action enabling conditions:
	// 1. 1 ( and only 1 ) item must be selected
	// 2. The selected item must be a free space
	// 3. The free space must be primary ( between primary partitions )
	
	CItemData*			pData;
	CFreeSpaceData*		pFreeData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetItemType() != IT_FreeSpace )
		goto label_disable;

	pFreeData = (CFreeSpaceData*)pData;

	if( pFreeData->m_wFreeSpaceType != FST_Primary )
		goto label_disable;
	
	pCmdUI->Enable(TRUE);
	return;

label_disable:
	pCmdUI->Enable(FALSE);	
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Create partition

void ActionCreatePartition( CObArray& arrSelectedItems )
{
	MY_TRY
	
	CAutoRefresh  ar(FALSE);
	
	CItemData*			pData;

	ASSERT( arrSelectedItems.GetSize() == 1 );
		
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_FreeSpace  );
	
	CFreeSpaceData* pFreeData = (CFreeSpaceData*)pData;

	if( pFreeData->m_dwPartitionCountOnLevel + pFreeData->m_dwExtendedPartitionCountOnLevel >= 4 )
	{
		// This must not happen inside an extended partition!
		ASSERT( pFreeData->m_wFreeSpaceType == FST_Primary );
		AfxMessageBox( IDS_ERR_PARTITION_TABLE_FULL, MB_ICONSTOP );
		return;
	}
		
	CCreatePartitionDlg dlg( pFreeData, pFreeData->m_llOffset );
	if( dlg.DoModal() != IDOK )
		return;;
	
	AfxGetApp()->DoWaitCursor(1);

	CDiskMap diskMap( pFreeData->m_dwDiskNumber );
	LONGLONG llExactPartStartOffset;

	BOOL bResult = diskMap.CreatePartition( pFreeData->m_llOffset, dlg.m_llPartitionSize, llExactPartStartOffset );

	if( bResult )
	{
		AfxMessageBox( IDS_MSG_CREATE_PARTITION, MB_ICONINFORMATION );
		
		// Now refresh both views and emphasize the new partition
		CItemIDSet  setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_RootVolumes;
		setTreeSelectedItems.Add( idItem );

		idItem.m_wItemType = IT_PhysicalPartition;
		idItem.m_ID.m_PhysicalPartitionID.m_ulDiskNumber = pFreeData->m_dwDiskNumber;
		idItem.m_ID.m_PhysicalPartitionID.m_llOffset = llExactPartStartOffset;
		setListSelectedItems.Add( idItem );

		AfxRefreshAll( NULL, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
	{
		AfxMessageBox( IDS_ERR_CREATE_PARTITION, MB_ICONSTOP );
		AfxRefreshAll();
	}

	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionCreatePartition( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// Action enabling conditions:
	// 1. 1 ( and only 1 ) item must be selected
	// 2. The selected item must be a free space
	
	CItemData*			pData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetItemType() != IT_FreeSpace )
			goto label_disable;
	
	pCmdUI->Enable(TRUE);
	return;

label_disable:
	pCmdUI->Enable(FALSE);	
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Delete

void ActionDelete( CObArray& arrSelectedItems )
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	CItemData*			pData;

	ASSERT( arrSelectedItems.GetSize() == 1 );
		
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	// A special case is when the selected item is an empty extended partition
	if( pData->GetItemType() == IT_FreeSpace )
	{
		CFreeSpaceData* pFree = (CFreeSpaceData*)pData;
		ASSERT(pFree->m_wFreeSpaceType == FST_EmptyExtendedPartition );

		CString strQuestion;
		strQuestion.Format( IDS_QST_DELETE_EXTENDED_PARTITION, pFree->m_dwDiskNumber );
		if( IDYES != AfxMessageBox(strQuestion, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 ) )
			return;

		CDiskMap diskMap( pFree->m_dwDiskNumber );
		if( diskMap.DeleteExtendedPartition( pFree->m_llOffset ) )
		{
			CItemIDSet	setTreeSelectedItems;
			CItemID		idItem;

			idItem.m_wItemType = IT_RootFreeSpaces;
			setTreeSelectedItems.Add( idItem );

			AfxMessageBox( IDS_MSG_DELETE_EXTENDED_PARTITION, MB_ICONINFORMATION );

			AfxRefreshAll( NULL, &setTreeSelectedItems, NULL );
		}
		else
		{
			AfxMessageBox( IDS_ERR_DELETE_EXTENDED_PARTITION, MB_ICONSTOP );
			AfxRefreshAll();
		}
		return;
	}
	
	ASSERT( ( pData->GetItemType() == IT_LogicalVolume ) ||
			( pData->GetItemType() == IT_PhysicalPartition ) );
	ASSERT( pData->IsRootVolume() && pData->IsValid() );

	CString strQuestion, strName;
	pData->GetDisplayExtendedName(strName);
	strQuestion.Format( IDS_QST_DELETE_VOLUME, strName );
	if( IDYES != AfxMessageBox(strQuestion, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 ) )
		return;
	
	// Delete the volume
	BOOL bResult;

	AfxGetApp()->DoWaitCursor(1);

	if( pData->GetItemType() == IT_LogicalVolume )
	{
		FT_LOGICAL_DISK_ID llVolID;
		((CLogicalVolumeData*)pData)->GetVolumeID(llVolID);
		bResult = FTDelete( llVolID );
	}
	else if( pData->GetItemType() == IT_PhysicalPartition )
	{
		CDiskMap diskMap( ((CPhysicalPartitionData*)pData)->m_dwDiskNumber );
		bResult = diskMap.DeletePartition( ((CPhysicalPartitionData*)pData)->m_PartInfo.StartingOffset.QuadPart );
	}
	else
		ASSERT(FALSE);
	
	if( bResult )
	{
		CItemIDSet	setTreeSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_RootVolumes;
		setTreeSelectedItems.Add( idItem );

		AfxMessageBox( IDS_MSG_DELETE_VOLUME, MB_ICONINFORMATION );
		
		AfxRefreshAll( NULL, &setTreeSelectedItems, NULL );
	}
	else
	{
		if( pData->GetItemType() == IT_LogicalVolume )
			AfxMessageBox(IDS_ERR_DELETE_LOGICAL_VOLUME, MB_ICONSTOP );
		else if( pData->GetItemType() == IT_PhysicalPartition )
			AfxMessageBox( IDS_ERR_DELETE_PHYSICAL_PARTITION, MB_ICONSTOP );
		
		AfxRefreshAll();
	}
	
	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionDelete( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// Action enabling conditions:
	// 1. 1 ( and only 1 ) item must be selected
	// 2. The selected item must be a root volume ( logical volume or physical partition )
	// 3. The selected item must be valid
	//OR
	// 1. 1 ( and only 1 ) item must be selected
	// 2. The selected item is an empty extended partition
	
	CItemData*			pData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( ( pData->GetItemType() != IT_LogicalVolume ) &&
		( pData->GetItemType() != IT_PhysicalPartition ) )
	{
		if( ( pData->GetItemType() == IT_FreeSpace ) && ( ((CFreeSpaceData*)pData)->m_wFreeSpaceType == FST_EmptyExtendedPartition ) )
			goto label_enable;
		else
			goto label_disable;
	}
	if( !pData->IsRootVolume() || !pData->IsValid() )
		goto label_disable;

label_enable:	
	pCmdUI->Enable(TRUE);
	return;

label_disable:
	pCmdUI->Enable(FALSE);	
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Regenerate an orphan member of a mirror set or stripe set with parity

void ActionFtinit( CObArray& arrSelectedItems )
{
    MY_TRY

	CAutoRefresh  ar(FALSE);
	
	ASSERT( arrSelectedItems.GetSize() == 1 );
	
	CItemData* pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_LogicalVolume );
	ASSERT( pData->IsValid() );
	CLogicalVolumeData* pMemberData = (CLogicalVolumeData*)pData;

	CItemData* pParentData = pData->GetParentData();
	ASSERT( pParentData );
	ASSERT( pParentData->GetItemType() == IT_LogicalVolume );
	
	CLogicalVolumeData* pLVParentData = (CLogicalVolumeData*)pParentData;
	ASSERT( ( pLVParentData->m_nVolType == FtMirrorSet ) ||
			( pLVParentData->m_nVolType == FtStripeSetWithParity ) );

    ASSERT( pLVParentData->m_StateInfo.stripeState.UnhealthyMemberState == FtMemberOrphaned );
    ASSERT( pLVParentData->m_StateInfo.stripeState.UnhealthyMemberNumber == ((CLogicalVolumeData*)pData)->m_unMemberIndex );

	CString strMemberDisplayName, strParentDisplayName, strQuestion;
    pData->GetDisplayExtendedName( strMemberDisplayName );
    pLVParentData->GetDisplayExtendedName( strParentDisplayName );
    strQuestion.Format( IDS_QST_FTINIT, strMemberDisplayName, strParentDisplayName );

	if( IDYES != AfxMessageBox(strQuestion, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 ) )
		return;

	AfxGetApp()->DoWaitCursor(1);

	// Now is time to reinitialize the member
	if( FTInit( pLVParentData->m_llVolID, TRUE ) )
		AfxMessageBox( IDS_MSG_FTINIT, MB_ICONINFORMATION );
		
    AfxRefreshAll();
	
    AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionFtinit( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
    // Action enabling conditions:
	// 1. 1 ( and only one ) item must be selected
	// 2. The selected item is a logical volume
	// 3. The parent of the item must be a mirror set or a stripe set with parity
	// 4. The selected item must be valid
	// 5. The selected item is an orphan member of its parent
	
	CItemData*				pData;
	CItemData*				pParentData;
	CLogicalVolumeData*		pLVParentData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetItemType() != IT_LogicalVolume )
		goto label_disable;

	if( !pData->IsValid() )
		goto label_disable;

	pParentData = pData->GetParentData();
	if( ( pParentData == NULL ) || ( pParentData->GetItemType() != IT_LogicalVolume ) )
		goto label_disable;
	
	pLVParentData = (CLogicalVolumeData*)pParentData;
	if( ( pLVParentData->m_nVolType != FtMirrorSet ) &&
		( pLVParentData->m_nVolType != FtStripeSetWithParity ) )
		goto label_disable;

	if( pLVParentData->m_StateInfo.stripeState.UnhealthyMemberState != FtMemberOrphaned )
        goto label_disable;

    if( pLVParentData->m_StateInfo.stripeState.UnhealthyMemberNumber != ((CLogicalVolumeData*)pData)->m_unMemberIndex )
		goto label_disable;

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Create mirror

void ActionFtmirror( CObArray& arrSelectedItems )
{
	MY_TRY
	
	CAutoRefresh  ar(FALSE);
	
	int nNumVols =   (int)arrSelectedItems.GetSize();
	ASSERT( nNumVols == 2 );
	
	for( int i = 0; i < nNumVols; i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		ASSERT( ( pData->GetItemType() == IT_LogicalVolume ) ||
				( pData->GetItemType() == IT_PhysicalPartition ) );
		ASSERT( pData->IsRootVolume() && pData->IsValid() );
	}

	// Display the dialog
	CActionDlg dlg(&arrSelectedItems, IDD_CREATE_MIRROR);
	if( dlg.DoModal() != IDOK )
		return;

	// Display the warning. All data of the second volume will be lost
	CString strDisplayName, strNameList, strWarning;
	for( i = 1; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pVolData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pVolData);
		pVolData->GetDisplayExtendedName(strDisplayName);
		if( i != 1 )
			strNameList += _T(",  ");
		strNameList += _T("\"");
		strNameList += strDisplayName;
		strNameList += _T("\"");
	}
	strWarning.Format( IDS_WRN_DATA_LOST, strNameList );
	if( IDYES != AfxMessageBox(strWarning, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) )
			return;
		
	AfxGetApp()->DoWaitCursor(1);

	// Make sure that all selected physical partitions are converted to FT partitions
	// and then get all selected items logical volume ID's
	FT_LOGICAL_DISK_ID* arrVolID = (FT_LOGICAL_DISK_ID*)LocalAlloc(0, nNumVols*sizeof(FT_LOGICAL_DISK_ID) );
	if( !arrVolID )
	{
		AfxMessageBox(IDS_ERR_ALLOCATION, MB_ICONSTOP );
		return;
	}
	if( !ConvertPartitionsToFT( arrSelectedItems, arrVolID ) )
	{
		LocalFree(arrVolID);
		AfxRefreshAll();
		AfxGetApp()->DoWaitCursor(-1);
		return;
	}

	FT_LOGICAL_DISK_ID llNewSetID;
	if( FTMirror( arrVolID, (WORD)nNumVols, &llNewSetID ) )
	{
		AfxMessageBox( IDS_MSG_FTMIRROR, MB_ICONINFORMATION );
		
		// Refresh all and emphasize the newly created mirror
		CItemIDSet	setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_RootVolumes;
		setTreeSelectedItems.Add( idItem );

		idItem.m_wItemType = IT_LogicalVolume;
		idItem.m_ID.m_LogicalVolumeID.m_llVolID = llNewSetID;
		setListSelectedItems.Add(idItem);
		AfxRefreshAll( NULL, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
	{
		DeconvertPartitionsFromFT( arrSelectedItems, arrVolID );
		AfxRefreshAll();
	}
	
	LocalFree(arrVolID);		
	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionFtmirror( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	MY_TRY

	// Action enabling conditions:
	// 1. 2 ( and only 2 ) items must be selected
	// 2. Every selected item must be a root volume ( logical volume or physical partition )
	// 3. Every selected item must be valid
	// 4. The disks sets intersection for every couple of selected items must be empty !

	int i;

	if( arrSelectedItems.GetSize() != 2 )
		goto label_disable;
	
	for( i = 0; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		if( ( pData->GetItemType() != IT_LogicalVolume ) &&
			( pData->GetItemType() != IT_PhysicalPartition ) )
			goto label_disable;
		if( !pData->IsRootVolume() || !pData->IsValid() )
			goto label_disable;

		for( int j = 0; j < i; j++ )
		{
			CItemData* pData2 = (CItemData*)(arrSelectedItems[j]);
			CULONGSet setIntersection( pData->GetDisksSet() );
			setIntersection *= pData2->GetDisksSet();
			if( !setIntersection.IsEmpty() )
				goto label_disable;
		}
	}

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);

	MY_CATCH
}

/*
//////////////////////////////////////////////////////////////////////////////////////////////
// Orphan member

void ActionFtorphan( CObArray& arrSelectedItems )
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	ASSERT( arrSelectedItems.GetSize() == 1 );
	
	CItemData* pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_LogicalVolume );

	CItemData* pParentData = pData->GetParentData();
	ASSERT( pParentData );
	ASSERT( pParentData->GetItemType() == IT_LogicalVolume );
	ASSERT( ( ((CLogicalVolumeData*)pParentData)->m_nVolType == FtMirrorSet ) ||
			( ((CLogicalVolumeData*)pParentData)->m_nVolType == FtStripeSetWithParity ) );

	CObArray	arrVolumeData;
	arrVolumeData.Add(pData);
	CActionDlg dlg(&arrSelectedItems);
	if( dlg.DoModal() != IDOK )
		return;
	
	FT_LOGICAL_DISK_ID	llVolID;
	pLogVolData->GetVolumeID( llVolID );

	AfxGetApp()->DoWaitCursor(1);
	
	if( FTOrphan( llVolID, iItem ) )
		AfxRefreshAll();
	
	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionFtorphan( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// This action should be enabled only when:
	// 1. single selection
	// 2. The selected item is a logical volume
	// 3. the parent is a Mirror or Stripe with parity

	CItemData*			pData, pParentData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetItemType() != IT_LogicalVolume )
		goto label_disable;

	pParentData = pData->GetParentData();
	if( ( pParentData == NULL ) || ( pParentData->GetItemType() != IT_LogicalVolume ) )
		goto label_disable;
	
	if( ( ((CLogicalVolumeData*)pParentData)->m_nVolType != FtMirrorSet ) &&
		( ((CLogicalVolumeData*)pParentData)->m_nVolType != FtStripeSetWithParity ) )
		goto label_disable;

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);
}
*/

/*
//////////////////////////////////////////////////////////////////////////////////////////////
// Create FT partition

void ActionFtpart( CObArray& arrSelectedItems )
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	ASSERT( arrSelectedItems.GetSize() == 1 );
	
	CItemData* pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_PhysicalPartition );

	CActionDlg dlg(&arrSelectedItems);
	if( dlg.DoModal() != IDOK )
		return;
	
	CPhysicalPartitionData* pPhPartData = (CPhysicalPartitionData*)pData;
	ASSERT( !pPhPartData->IsFTPartition() );
	ASSERT( !pData->GetVolumeName().IsEmpty() );

	AfxGetApp()->DoWaitCursor(1);
	
	FTPart(	pPhPartData->GetVolumeName(), pPhPartData->GetDriveLetter() );
	
	AfxRefreshAll();
	AfxGetApp()->DoWaitCursor(-1);	

	MY_CATCH_AND_REPORT
}

void UpdateActionFtpart( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// This action should be enabled only when:
	// 1. single selection
	// 2. the selected item is a physical partition
	// 3. This partition is not a FT partition
	// 4. We have a volume name for this partition

	CItemData*			pData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetItemType() != IT_PhysicalPartition )
		goto label_disable;

	if( ((CPhysicalPartitionData*)pData)->IsFTPartition() )
		goto label_disable;

	if( pData->GetVolumeName().IsEmpty() )
		goto label_disable;

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);
}
*/

//////////////////////////////////////////////////////////////////////////////////////////////
// Create stripe set

void ActionFtstripe( CObArray& arrSelectedItems )
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	int nNumVols =   (int)arrSelectedItems.GetSize();
	ASSERT( nNumVols >= 2 );
	
	for( int i = 0; i < nNumVols; i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		ASSERT( ( pData->GetItemType() == IT_LogicalVolume ) ||
				( pData->GetItemType() == IT_PhysicalPartition ) );
		ASSERT( pData->IsRootVolume() && pData->IsValid() );
	}

	// Display the dialog
	CCreateStripeDlg dlg(&arrSelectedItems);
	if( dlg.DoModal() != IDOK )
		return;

	// Display the warning. All data of selected volumes will be lost
	CString strDisplayName, strNameList, strWarning;
	for( i = 0; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pVolData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pVolData);
		pVolData->GetDisplayExtendedName(strDisplayName);
		if( i != 0 )
			strNameList += _T(",  ");
		strNameList += _T("\"");
		strNameList += strDisplayName;
		strNameList += _T("\"");
	}	
	strWarning.Format( IDS_WRN_DATA_LOST, strNameList );
	if( IDYES != AfxMessageBox(strWarning, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) )
			return;

	AfxGetApp()->DoWaitCursor(1);

	// Make sure that all selected physical partitions are converted to FT partitions
	// and then get all selected items logical volume ID's
	FT_LOGICAL_DISK_ID* arrVolID = (FT_LOGICAL_DISK_ID*)LocalAlloc(0, nNumVols*sizeof(FT_LOGICAL_DISK_ID) );
	if( !arrVolID )
	{
		AfxMessageBox(IDS_ERR_ALLOCATION, MB_ICONSTOP );
		return;
	}
	if( !ConvertPartitionsToFT( arrSelectedItems, arrVolID ) )
	{
		LocalFree(arrVolID);
		AfxRefreshAll();
		AfxGetApp()->DoWaitCursor(-1);
		return;
	}

	FT_LOGICAL_DISK_ID llNewSetID;
	if( FTStripe( arrVolID, (WORD)nNumVols, dlg.m_ulStripeSize, &llNewSetID) )
	{
		AfxMessageBox( IDS_MSG_FTSTRIPE, MB_ICONINFORMATION );

		// Refresh all and emphasize the newly created stripe set
		CItemIDSet	setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_RootVolumes;
		setTreeSelectedItems.Add( idItem );

		idItem.m_wItemType = IT_LogicalVolume;
		idItem.m_ID.m_LogicalVolumeID.m_llVolID = llNewSetID;
		setListSelectedItems.Add(idItem);

		AfxRefreshAll( NULL, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
	{
		DeconvertPartitionsFromFT( arrSelectedItems, arrVolID );
		AfxRefreshAll();
	}
			
	LocalFree(arrVolID);
	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionFtstripe( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	MY_TRY

	// Action enabling conditions:
	// 1. 2 or more items must be selected
	// 2. Every selected item must be a root volume ( logical volume or physical partition )
	// 3. Every selected item must be valid
	// 4. The disks sets intersection for every couple of selected items must be empty !
	
	int i;
	
	if( arrSelectedItems.GetSize() < 2 )
		goto label_disable;
	
	for( i = 0; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		if( ( pData->GetItemType() != IT_LogicalVolume ) &&
			( pData->GetItemType() != IT_PhysicalPartition ) )
			goto label_disable;
		if( !pData->IsRootVolume() || !pData->IsValid() )
			goto label_disable;

		for( int j = 0; j < i; j++ )
		{
			CItemData* pData2 = (CItemData*)(arrSelectedItems[j]);
			CULONGSet setIntersection( pData->GetDisksSet() );
			setIntersection *= pData2->GetDisksSet();
			if( !setIntersection.IsEmpty() )
				goto label_disable;
		}
	}

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);

	MY_CATCH
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Swap a member of a mirror set or of a stripe set with parity

void ActionFtswap( CObArray& arrSelectedItems )
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	ASSERT( arrSelectedItems.GetSize() == 1 );
	
	CItemData* pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);
	ASSERT( pData->GetItemType() == IT_LogicalVolume );
	ASSERT( pData->IsValid() );
	CLogicalVolumeData* pMemberData = (CLogicalVolumeData*)pData;

	CItemData* pParentData = pData->GetParentData();
	ASSERT( pParentData );
	ASSERT( pParentData->GetItemType() == IT_LogicalVolume );
	
	CLogicalVolumeData* pLVParentData = (CLogicalVolumeData*)pParentData;
	ASSERT( ( pLVParentData->m_nVolType == FtMirrorSet ) ||
			( pLVParentData->m_nVolType == FtStripeSetWithParity ) );

	// Now get all possible replacements for the selected member
	// Conditions for possible replacements:
	// 1. Must be a root volume
	// 2. Must be at least as big as the member size of the mirror or stripe set with parity
	// 3. Must be valid
	// 4. Must not be the parent of the selected member
	// 5. Its disks set must not intersect with the reunion of all other members disks sets. And if its
	//		forefathers to the root are also members of mirrors, stripes or stripe sets with parity take
	//		also their siblings into consideration

	AfxGetApp()->DoWaitCursor(1);

	// So, first read all logical volumes
	CRootVolumesData	objRoot;
	CObArray			arrVolumeData;
	CString				strErrors;
	if( !objRoot.ReadMembers( arrVolumeData, strErrors ) )
	{
		AfxMessageBox( strErrors, MB_ICONSTOP );
		AfxGetApp()->DoWaitCursor(-1);
		return;
	}

	// Second get the member size of the parent set
	LONGLONG			llMemberSize;
	if( pLVParentData->m_nVolType == FtMirrorSet )
		llMemberSize = pLVParentData->m_ConfigInfo.mirrorConfig.MemberSize;
	else if ( pLVParentData->m_nVolType == FtStripeSetWithParity )
		llMemberSize = pLVParentData->m_ConfigInfo.swpConfig.MemberSize;
	else
		ASSERT(FALSE);

	// Third get the reunion of all other siblings and forefathers' siblings disks set
	CULONGSet setForbiddenDisks;
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CFTTreeView* pLeftView = (CFTTreeView*)(pFrame->GetLeftPane());
	ASSERT( pLeftView );
	GetVolumeReplacementForbiddenDisksSet( pLeftView, pMemberData, setForbiddenDisks );
	
	// Now select only those root volumes that match the 5 conditions enumerated above
	for( int i = (int)arrVolumeData.GetSize() - 1; i >= 0; i-- )
	{
		CItemData* pVolData = (CItemData*)(arrVolumeData[i]);
		ASSERT( pVolData );
		ASSERT( pVolData->IsRootVolume() );
		
		// Get the size of the volume
		LONGLONG	llVolSize;
		pVolData->GetSize( llVolSize );
		
		// Intersect the disks set of the volume with the reunion of all other members disks sets
		CULONGSet setIntersection;
		setIntersection = setForbiddenDisks;
		setIntersection *= pVolData->GetDisksSet();

		if( (	( pVolData->GetItemType() != IT_LogicalVolume ) &&
				( pVolData->GetItemType() != IT_PhysicalPartition )
			)																
			||
			( !pVolData->IsValid() )										
			||
			( llVolSize < llMemberSize )											
			||
			(	( pVolData->GetItemType() == IT_LogicalVolume ) &&
				( ((CLogicalVolumeData*)pVolData)->m_llVolID == pLVParentData->m_llVolID )
			)
			||
			( !setIntersection.IsEmpty() )
		  )
		{
			delete pVolData;
			arrVolumeData.RemoveAt(i);
		}
	}
	
	AfxGetApp()->DoWaitCursor(-1);

	CSwapDlg dlg(pLVParentData, pMemberData, &arrVolumeData);
	CItemData* pReplData;
	CString strDisplayName, strNameList, strWarning;

	// If no possible replacements then error message
	if( arrVolumeData.GetSize() == 0 )
	{
		CString str, strSize;
		FormatVolumeSize( strSize, llMemberSize  );
		AfxFormatString1(str, IDS_ERR_NO_REPLACEMENTS, strSize );
		AfxMessageBox( str, MB_ICONSTOP );
		goto label_cleanup;
	}

	if( dlg.DoModal() != IDOK )
		goto label_cleanup;

	ASSERT( ( dlg.m_nReplacementIndex >= 0 ) && ( dlg.m_nReplacementIndex < arrVolumeData.GetSize() ) );
	
	AfxGetApp()->DoWaitCursor(1);

	FT_LOGICAL_DISK_ID llReplVolID;

	// If the selected replacement is a physical partition then convert it to FT Partition
	pReplData = (CItemData*)(arrVolumeData[dlg.m_nReplacementIndex]);
	ASSERT( pReplData );

	// Display the warning. All data of the replacement volume will be lost
	pReplData->GetDisplayExtendedName(strDisplayName);
	strNameList += _T("\"");
	strNameList += strDisplayName;
	strNameList += _T("\"");
	strWarning.Format( IDS_WRN_DATA_LOST, strNameList );
	if( IDYES != AfxMessageBox(strWarning, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) )
		goto label_cleanup;

	if( pReplData->GetItemType() == IT_PhysicalPartition )
	{
		ASSERT( !pReplData->GetVolumeName().IsEmpty() );
		if( !FTPart(	pReplData->GetVolumeName(),
						pReplData->GetDriveLetter(),
						&llReplVolID ) )
		{
			AfxGetApp()->DoWaitCursor(-1);
			goto label_cleanup;
		}
	}
	else if( pReplData->GetItemType() == IT_LogicalVolume )
		pReplData->GetVolumeID( llReplVolID );
	else
		ASSERT(FALSE);

	// If the selected member is not orphaned then orphan it
	if( pMemberData->GetMemberStatus() != FtMemberOrphaned )
	{
		if( !FTOrphan( pLVParentData->m_llVolID, pMemberData->m_unMemberIndex ) )
		{
			if( pReplData->GetItemType() == IT_PhysicalPartition )
				FTBreak( llReplVolID );
			AfxGetApp()->DoWaitCursor(-1);
			goto label_cleanup;
		}
	}
	
	// Now is time to replace the member
	FT_LOGICAL_DISK_ID	llNewSetID;
	if( FTRegen( pLVParentData->m_llVolID, pMemberData->m_unMemberIndex, llReplVolID, &llNewSetID ) )
	{
		// If the parent is a mirror set and the old member is a FT Partition break the old member
		// If the parent is a stripe set with parity delete the old member
		if( pLVParentData->m_nVolType == FtMirrorSet )
		{
			if( pMemberData->m_nVolType == FtPartition )
				FTBreak( pMemberData->m_llVolID );
		}
		else if( pLVParentData->m_nVolType == FtStripeSetWithParity )
			FTDelete( pMemberData->m_llVolID );
		else
			ASSERT(FALSE);

		AfxMessageBox( IDS_MSG_FTREGEN, MB_ICONINFORMATION );

		// Now refresh both views and emphasize the new set and its new member
		CItemIDSet	setAddTreeExpandedItems;
		CItemIDSet  setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_LogicalVolume;
		idItem.m_ID.m_LogicalVolumeID.m_llVolID = llNewSetID;
		setAddTreeExpandedItems.Add( idItem );
		setTreeSelectedItems.Add( idItem );

		ASSERT( idItem.m_wItemType == IT_LogicalVolume );
		idItem.m_ID.m_LogicalVolumeID.m_llVolID = llReplVolID;
		setListSelectedItems.Add( idItem );

		AfxRefreshAll( &setAddTreeExpandedItems, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
	{
		if( pReplData->GetItemType() == IT_PhysicalPartition )
				FTBreak( llReplVolID );
		AfxRefreshAll();
	}

	AfxGetApp()->DoWaitCursor(-1);

label_cleanup:
	for( i = 0; i < arrVolumeData.GetSize() ; i++ )
	{
		CItemData* pVolData = (CItemData*)(arrVolumeData[i]);
		delete pVolData;
	}
	arrVolumeData.RemoveAll();

	MY_CATCH_AND_REPORT
}

void UpdateActionFtswap( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// Action enabling conditions:
	// 1. 1 ( and only one ) item must be selected
	// 2. The selected item is a logical volume
	// 3. The parent of the item must be a mirror set or a stripe set with parity
	// 4. The selected item must be valid
	// 5. If its parent has a not healthy member, then this member should be the selected item.
	//		( You cannot regenerate a member of an FT set who already has another not healthy member )
	// 6. If its parent is a stripe set with parity, then the parent shouldn't be initializing
	
	CItemData*				pData;
	CItemData*				pParentData;
	CLogicalVolumeData*		pLVParentData;

	if( arrSelectedItems.GetSize() != 1 )
		goto label_disable;
	
	pData = (CItemData*)(arrSelectedItems[0]);
	ASSERT(pData);

	if( pData->GetItemType() != IT_LogicalVolume )
		goto label_disable;

	if( !pData->IsValid() )
		goto label_disable;

	pParentData = pData->GetParentData();
	if( ( pParentData == NULL ) || ( pParentData->GetItemType() != IT_LogicalVolume ) )
		goto label_disable;
	
	pLVParentData = (CLogicalVolumeData*)pParentData;
	if( ( pLVParentData->m_nVolType != FtMirrorSet ) &&
		( pLVParentData->m_nVolType != FtStripeSetWithParity ) )
		goto label_disable;

	if( ( pLVParentData->m_StateInfo.stripeState.UnhealthyMemberState != FtMemberHealthy ) &&
		( pLVParentData->m_StateInfo.stripeState.UnhealthyMemberNumber != ((CLogicalVolumeData*)pData)->m_unMemberIndex ) )
		goto label_disable;

	if( ( pLVParentData->m_nVolType == FtStripeSetWithParity ) &&
		( pLVParentData->m_StateInfo.stripeState.IsInitializing ) )
		goto label_disable;

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Create stripe set with parity

void ActionFtswp( CObArray& arrSelectedItems )
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	int nNumVols = (int)arrSelectedItems.GetSize();
	ASSERT( nNumVols >= 3 );
	
	for( int i = 0; i < nNumVols; i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		ASSERT( ( pData->GetItemType() == IT_LogicalVolume ) ||
				( pData->GetItemType() == IT_PhysicalPartition ) );
		ASSERT( pData->IsRootVolume() && pData->IsValid() );
	}

	// Display the dialog
	CCreateStripeDlg dlg(&arrSelectedItems, IDD_CREATE_SWP);
	if( dlg.DoModal() != IDOK )
		return;

	// Display the warning. All data of selected volumes will be lost
	CString strDisplayName, strNameList, strWarning;
	for( i = 0; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pVolData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pVolData);
		pVolData->GetDisplayExtendedName(strDisplayName);
		if( i != 0 )
			strNameList += _T(",  ");
		strNameList += _T("\"");
		strNameList += strDisplayName;
		strNameList += _T("\"");
	}	
	strWarning.Format( IDS_WRN_DATA_LOST, strNameList );
	if( IDYES != AfxMessageBox(strWarning, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) )
			return;

	AfxGetApp()->DoWaitCursor(1);

	// Make sure that all selected physical partitions are converted to FT partitions
	// and then get all selected items logical volume ID's
	FT_LOGICAL_DISK_ID* arrVolID = (FT_LOGICAL_DISK_ID*)LocalAlloc(0, nNumVols*sizeof(FT_LOGICAL_DISK_ID) );
	if( !arrVolID )
	{
		AfxMessageBox(IDS_ERR_ALLOCATION, MB_ICONSTOP );
		return;
	}
	if( !ConvertPartitionsToFT( arrSelectedItems, arrVolID ) )
	{
		LocalFree(arrVolID);
		AfxRefreshAll();
		AfxGetApp()->DoWaitCursor(-1);
		return;
	}

	FT_LOGICAL_DISK_ID llNewSetID;
	if( FTSWP( arrVolID, (WORD)nNumVols, dlg.m_ulStripeSize, &llNewSetID) )
	{
		AfxMessageBox( IDS_MSG_FTSWP, MB_ICONINFORMATION );

		// Refresh all and emphasize the newly created stripe set with parity
		CItemIDSet	setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_RootVolumes;
		setTreeSelectedItems.Add( idItem );

		idItem.m_wItemType = IT_LogicalVolume;
		idItem.m_ID.m_LogicalVolumeID.m_llVolID = llNewSetID;
		setListSelectedItems.Add(idItem);
		
		AfxRefreshAll( NULL, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
	{
		DeconvertPartitionsFromFT( arrSelectedItems, arrVolID );			
		AfxRefreshAll();
	}
	
	LocalFree(arrVolID);
	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionFtswp( CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	MY_TRY

	// Action enabling conditions:
	// 1. 3 or more items must be selected
	// 2. Every selected item must be a root volume ( logical volume or physical partition )
	// 3. Every selected item must be valid
	// 4. The disks sets intersection for every couple of selected items must be empty !

	int i;

	if( arrSelectedItems.GetSize() < 3 )
		goto label_disable;
	
	for( i = 0; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		if( ( pData->GetItemType() != IT_LogicalVolume ) &&
			( pData->GetItemType() != IT_PhysicalPartition ) )
			goto label_disable;
		if( !pData->IsRootVolume() || !pData->IsValid() )
			goto label_disable;

		for( int j = 0; j < i; j++ )
		{
			CItemData* pData2 = (CItemData*)(arrSelectedItems[j]);
			CULONGSet setIntersection( pData->GetDisksSet() );
			setIntersection *= pData2->GetDisksSet();
			if( !setIntersection.IsEmpty() )
				goto label_disable;
		}
	}

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);

	MY_CATCH
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Create volume set

void ActionFtvolset( CObArray& arrSelectedItems )
{
	MY_TRY

	CAutoRefresh  ar(FALSE);
	
	int nNumVols = (int)arrSelectedItems.GetSize();
	ASSERT( nNumVols >= 2 );
	
	// Get the array of selected items
	for( int i = 0; i < nNumVols; i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		ASSERT( ( pData->GetItemType() == IT_LogicalVolume ) ||
				( pData->GetItemType() == IT_PhysicalPartition ) );
		ASSERT( pData->IsRootVolume() && pData->IsValid() );
	}

	// Display the dialog
	CActionDlg dlg(&arrSelectedItems, IDD_CREATE_VOLSET);
	if( dlg.DoModal() != IDOK )
		return;

	// Display the warning. All data of selected volumes ( except the first one ) will be lost
	CString strDisplayName, strNameList, strWarning;
	for( i = 1; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pVolData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pVolData);
		pVolData->GetDisplayExtendedName(strDisplayName);
		if( i != 1 )
			strNameList += _T(",  ");
		strNameList += _T("\"");
		strNameList += strDisplayName;
		strNameList += _T("\"");
	}	
	strWarning.Format( IDS_WRN_DATA_LOST, strNameList );
	if( IDYES != AfxMessageBox(strWarning, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) )
			return;

	AfxGetApp()->DoWaitCursor(1);

	// Make sure that all selected physical partitions are converted to FT partitions
	// and then get all selected items logical volume ID's
	FT_LOGICAL_DISK_ID* arrVolID = (FT_LOGICAL_DISK_ID*)LocalAlloc(0, nNumVols*sizeof(FT_LOGICAL_DISK_ID) );
	if( !arrVolID )
	{
		AfxMessageBox(IDS_ERR_ALLOCATION, MB_ICONSTOP );
		return;
	}
	if( !ConvertPartitionsToFT( arrSelectedItems, arrVolID ) )
	{
		LocalFree(arrVolID);
		AfxRefreshAll();
		AfxGetApp()->DoWaitCursor(-1);
		return;
	}

	FT_LOGICAL_DISK_ID llNewSetID;
	if( FTVolSet( arrVolID, (WORD)nNumVols, &llNewSetID ) )
	{
		AfxMessageBox( IDS_MSG_FTVOLSET, MB_ICONINFORMATION );
		FTExtend( llNewSetID );

		// Refresh all and emphasize the newly created volume set
		CItemIDSet	setTreeSelectedItems;
		CItemIDSet	setListSelectedItems;
		CItemID		idItem;

		idItem.m_wItemType = IT_RootVolumes;
		setTreeSelectedItems.Add( idItem );

		idItem.m_wItemType = IT_LogicalVolume;
		idItem.m_ID.m_LogicalVolumeID.m_llVolID = llNewSetID;
		setListSelectedItems.Add(idItem);

		AfxRefreshAll( NULL, &setTreeSelectedItems, &setListSelectedItems );
	}
	else
	{
		DeconvertPartitionsFromFT( arrSelectedItems, arrVolID );
		AfxRefreshAll();
	}
			
	LocalFree(arrVolID);
	AfxGetApp()->DoWaitCursor(-1);

	MY_CATCH_AND_REPORT
}

void UpdateActionFtvolset(CCmdUI* pCmdUI, CObArray& arrSelectedItems )
{
	// Action enabling conditions:
	// 1. 2 or more items must be selected
	// 2. Every selected item must be a root volume ( logical volume or physical partition )
	// 3. Every selected item must be valid

	int i;

	if( arrSelectedItems.GetSize() < 2 )
		goto label_disable;
	
	for( i = 0; i < arrSelectedItems.GetSize(); i++ )
	{
		CItemData* pData = (CItemData*)(arrSelectedItems[i]);
		ASSERT(pData);
		if( ( pData->GetItemType() != IT_LogicalVolume ) &&
			( pData->GetItemType() != IT_PhysicalPartition ) )
			goto label_disable;
		if( !pData->IsRootVolume() || !pData->IsValid() )
			goto label_disable;
	}

	pCmdUI->Enable( TRUE );
	return;

label_disable:
	pCmdUI->Enable(FALSE);
}



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\diskmap.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	DiskMap.cpp

Abstract:

    Implementation of classes used to keep the disk array map in memory. Used in retrieving partitions and free spaces, 
	in creating and deleting partitions

Author:

    Cristian Teodorescu      October 23, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "DiskMap.h"
#include "FrSpace.h"
#include "PhPart.h"
#include "Resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//#define CSEC_FAT		32680
//#define CSEC_FAT32MEG	65536

///////////////////////////////////////////////////////////////////////////////////////////////////
// CDiskMap

////////////////////////////////////////////////////////////////////////////////////////////////////
// Public methods

/*
Public method:		LoadDiskInfo

Purpose:			Load the disk layout and geometry into this object
					
Parameters:			[OUT] CString& strErrors
						All errors found during LoadDiskInfo are reported through this string
					[OUT] BOOL& bMissingDisk
						Reported TRUE if the disk m_dwDiskNumber is not found ( CreateFile returns invalid handle )
						This may notify the calling procedure that the search for installed disks is over

Return value:		TRUE if the disk information is loaded successfully
*/

BOOL CDiskMap::LoadDiskInfo( 
						CString& strErrors, 
						BOOL& bMissingDisk )
{
	MY_TRY

	ASSERT( m_dwDiskNumber >= 0 );

	m_bLoaded = FALSE;
	strErrors = _T("");
	bMissingDisk = FALSE;
	

	CString strFileName;
	strFileName.Format(_T("\\\\.\\PHYSICALDRIVE%lu"), m_dwDiskNumber); 
		
	// Try to open the disk
	HANDLE hDisk = CreateFile( 
						strFileName, GENERIC_READ, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL, OPEN_EXISTING, 0 , INVALID_HANDLE_VALUE );
	if( hDisk == INVALID_HANDLE_VALUE )
	{
		// This disk is not installed in the system
		bMissingDisk = TRUE;
		return FALSE;
	}
			
	// Read the geometry of the disk
	ULONG			ulBytes;
	DISK_GEOMETRY	geometry;
	if( !DeviceIoControl(hDisk, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
								&geometry, sizeof(geometry), &ulBytes, NULL ) )
	{	
		AddError( strErrors, IDS_ERR_GET_DRIVE_GEOMETRY, TRUE );
		CloseHandle( hDisk );
		return FALSE;
	}

	m_llSectorSize = geometry.BytesPerSector;
	m_llTrackSize = geometry.SectorsPerTrack * m_llSectorSize;
	m_llCylinderSize = geometry.TracksPerCylinder * m_llTrackSize;
	m_llDiskSize = geometry.Cylinders.QuadPart * m_llCylinderSize;

	// Allocate some space for the drive layout buffer
	if( m_pBuffer == NULL )
	{
		ASSERT( m_dwBufferSize == 0 );
		
		m_dwBufferSize = sizeof( DRIVE_LAYOUT_INFORMATION ) + 20*sizeof(PARTITION_INFORMATION);
		// Allocate space for the drive layout information
		m_pBuffer = (PDRIVE_LAYOUT_INFORMATION)LocalAlloc(0, m_dwBufferSize);
		if( !m_pBuffer )
		{
			m_dwBufferSize = 0;
			CloseHandle( hDisk );
			AddError( strErrors, IDS_ERR_ALLOCATION, FALSE );
			// There is nothing else to do so return
			return FALSE;
		}
	}
	
	// Read the structure of the disk
	BOOL bResult = DeviceIoControl( 
							hDisk, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, 
							m_pBuffer, m_dwBufferSize, &ulBytes, NULL );

	// If the buffer is not large enough reallocate it
	while (!bResult && GetLastError() == ERROR_MORE_DATA) 
	{        
		m_dwBufferSize = ulBytes;
		LocalFree( m_pBuffer );
        m_pBuffer = (PDRIVE_LAYOUT_INFORMATION)(LocalAlloc(0, m_dwBufferSize ));
        if (!m_pBuffer) 
		{            
			m_dwBufferSize = 0;
			CloseHandle( hDisk );
			AddError( strErrors, IDS_ERR_ALLOCATION, FALSE );
			return FALSE;
        }        
		BOOL bResult = DeviceIoControl( 
							hDisk, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, 
							m_pBuffer, m_dwBufferSize, &ulBytes, NULL );
	}
	
	// If we still cannot get the drive layout then return false
	if( !bResult )
	{
		AddError( strErrors, IDS_ERR_GET_DRIVE_LAYOUT, TRUE );
		CloseHandle(hDisk);
		return FALSE;
	}

	m_bLoaded = TRUE;

	return TRUE;
	
	MY_CATCH_AND_THROW
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Public methods

/*
Public method:		SaveDiskInfo

Purpose:			Save the disk layout on disk
					
Parameters:			[OUT] CString& strErrors
						All errors found during SaveDiskInfo are reported through this string
					[OUT] BOOL& bMissingDisk
						Reported TRUE if the disk m_dwDiskNumber is not found ( CreateFile returns invalid handle )
						This may notify the calling procedure that the search for installed disks is over

Return value:		TRUE if the disk information is saved successfully
*/

BOOL CDiskMap::SaveDiskInfo( 
						CString& strErrors, 
						BOOL& bMissingDisk )
{
	MY_TRY
	
	ASSERT( m_dwDiskNumber >= 0 );

	strErrors = _T("");
	bMissingDisk = FALSE;
	

	CString strFileName;
	strFileName.Format(_T("\\\\.\\PHYSICALDRIVE%lu"), m_dwDiskNumber);
	
	// Try to open the disk
	HANDLE hDisk = CreateFile( 
						strFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL, OPEN_EXISTING, 0 , INVALID_HANDLE_VALUE );
	if( hDisk == INVALID_HANDLE_VALUE )
	{
		// This disk is not installed in the system
		bMissingDisk = TRUE;
		return FALSE;
	}
			
	ULONG ulBytes;

	BOOL bResult = DeviceIoControl( 
							hDisk, IOCTL_DISK_SET_DRIVE_LAYOUT, m_pBuffer, 
							sizeof(DRIVE_LAYOUT_INFORMATION) + m_pBuffer->PartitionCount*sizeof(PARTITION_INFORMATION),
							NULL, 0, &ulBytes, NULL );

	if( !bResult )
	{
		AddError( strErrors, IDS_ERR_SET_DRIVE_LAYOUT, TRUE );
		CloseHandle( hDisk );
		return FALSE;
	}

	CloseHandle( hDisk );
	m_bLoaded = TRUE;

	return TRUE;

	MY_CATCH_AND_THROW
}


/*
Public method:		ReadPartitions

Purpose:			Retrieve all non-container partitions on the disk and create CPhysicalPartitionData instances for 
					them
					If the disk info is not loaded the method calls LoadDiskInfo first
					
Parameters:			[OUT] CObArray& arrPartitions
						Array of CPhysicalPartitionData containing all physical partitions found on the disk
					[OUT] CString& strErrors
						All errors found during ReadPhysicalPartitions are reported through this string
					[OUT] BOOL& bMissingDisk
						Reported TRUE if the disk m_dwDiskNumber is not found ( CreateFile returns invalid handle )
						This may notify the calling procedure that the search for installed disks is over
					[IN] CItemData* pParentData
						The items' parent data. It will fill the m_pParentData member of all new
						CPhysicalPartititionData instances

Return value:		TRUE if the the method ends successfully
*/

BOOL CDiskMap::ReadPartitions( 
						CObArray& arrPartitions, 
						CString& strErrors, 
						BOOL& bMissingDisk,
						CItemData* pParentData /* = NULL */)
{
	MY_TRY
	
	ASSERT( m_dwDiskNumber >= 0 );

	arrPartitions.RemoveAll();
	strErrors = _T("");

	if( m_bLoaded )
		bMissingDisk = FALSE;
	else if( !LoadDiskInfo( strErrors, bMissingDisk ) )
		return FALSE;

	// Read all recognized partitions on the disk
	for( DWORD dwIndex = 0; dwIndex < m_pBuffer->PartitionCount; dwIndex++ )
	{
		// A partition that is not logical volume has the highest bit of field
		// PartitionType 0
		if( m_pBuffer->PartitionEntry[dwIndex].RecognizedPartition &&
			!( m_pBuffer->PartitionEntry[dwIndex].PartitionType & 0x80 ) )
		{
			// Create the logical volume item data
			CPhysicalPartitionData* pData = new CPhysicalPartitionData(
														m_dwDiskNumber, 
														m_pBuffer->Signature, 
														&(m_pBuffer->PartitionEntry[dwIndex]),
														( dwIndex < 4 ) ? PT_Primary : PT_InExtendedPartition,
														pParentData,
														TRUE);
			CString strMemberErrors;
			pData->ReadItemInfo( strMemberErrors );
			strErrors += strMemberErrors;
			// Insert the structure in the members' data array This array must be sorted by starting offset
			for( int i = 0; i < arrPartitions.GetSize(); i++ )
			{
				if( pData->m_PartInfo.StartingOffset.QuadPart < ((CPhysicalPartitionData*)arrPartitions[i])->m_PartInfo.StartingOffset.QuadPart )
					break;
			}
			arrPartitions.InsertAt( i, pData );
		}
	}

	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Public method:		ReadFreeSpaces

Purpose:			Retrieve all free spaces on the disk and create CFreeSpaceData instances for 
					them. A free space is a space not contained by a physical partition
					If the disk info is not loaded the method calls LoadDiskInfo first
					
Parameters:			[OUT] CObArray& arrFreeSpaces
						Array of CFreeSpaceData containing all free spaces found on the disk
					[OUT] CString& strErrors
						All errors found during ReadFreeSpaces are reported through this string
					[OUT] BOOL& bMissingDisk
						Reported TRUE if the disk m_dwDiskNumber is not found ( CreateFile returns invalid handle )
						This may notify the calling procedure that the search for installed disks is over
					[IN] CItemData* pParentData
						The items' parent data. It will fill the m_pParentData member of all new
						CFreeSpaceData instances

Return value:		TRUE if the method ends successfully
*/

BOOL CDiskMap::ReadFreeSpaces( 
						CObArray& arrFreeSpaces, 
						CString& strErrors, 
						BOOL& bMissingDisk,
						CItemData* pParentData /* = NULL */)
{
	MY_TRY
	
	ASSERT( m_dwDiskNumber >= 0 );

	arrFreeSpaces.RemoveAll();
	strErrors = _T("");

	if( m_bLoaded )
		bMissingDisk = FALSE;
	else if( !LoadDiskInfo( strErrors, bMissingDisk ) )
		return FALSE;

	DWORD		dwNextIndex;

	GetExtendedPartitionFreeSpaces( 0, m_llDiskSize, 0, dwNextIndex, arrFreeSpaces, pParentData );	

	for( int i = 0; i < arrFreeSpaces.GetSize(); i++ )
		((CFreeSpaceData*)(arrFreeSpaces[i]))->m_dwFreeSpaceNumber = i+1;
	
	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Public method:		ReadPartitionInformation

Purpose:			Retrieves a partition information from the disk (m_dwDiskNumber) layout

Parameters:			[IN] LONGLONG llPartStartOffset
						Offset of the partition
					[OUT] PARTITION_INFORMATION& partInfo
						Structure to receive the partition info
					[OUT] PARTITION_TYPE& wPartitionType
						Partition type ( primary or partition in ectended partition )
					[OUT] CString& strErrors
						All errors found during ReadPartitionInformation are reported through this string
					[OUT] BOOL& bMissingDisk
						Reported TRUE if the disk m_dwDiskNumber is not found ( CreateFile returns invalid handle )
						This may notify the calling procedure that the search for installed disks is over

Return value:		TRUE	if the query succeeded							
*/

BOOL CDiskMap::ReadPartitionInformation(	
						LONGLONG llPartStartOffset, 
						PARTITION_INFORMATION& partInfo, 
						PARTITION_TYPE& wPartitionType,
						CString& strErrors, 
						BOOL& bMissingDisk )
{
	MY_TRY
	
	ASSERT( m_dwDiskNumber >= 0 );

	strErrors = _T("");

	if( m_bLoaded )
		bMissingDisk = FALSE;
	else if( !LoadDiskInfo( strErrors, bMissingDisk ) )
		return FALSE;

	// Check all recognized partitions on the disk
	for( DWORD dwIndex = 0; dwIndex < m_pBuffer->PartitionCount; dwIndex++ )
	{
		if(	( m_pBuffer->PartitionEntry[dwIndex].RecognizedPartition ) &&
			( m_pBuffer->PartitionEntry[dwIndex].StartingOffset.QuadPart == llPartStartOffset ) )
		{
			wPartitionType = ( dwIndex < 4 ) ? PT_Primary : PT_InExtendedPartition;
			memcpy(&partInfo, &(m_pBuffer->PartitionEntry[dwIndex]), sizeof(PARTITION_INFORMATION) );
			return TRUE;
		}
	}
		
	// The partition was not found
	AddError( strErrors, IDS_ERR_PARTITION_NOT_FOUND, FALSE );

	return FALSE;

	MY_CATCH_AND_THROW
}

/*
Public method:		DeletePartition

Purpose:			Deletes a partition of the disk ( m_dwDiskNumber )

Parameters:			[IN] LONGLONG llPartStartOffset
						Offset of the partition

Return value:		TRUE	if the deletion succeeded							
*/

BOOL CDiskMap::DeletePartition( 
						LONGLONG llPartStartOffset )
{
	MY_TRY

	ASSERT( m_dwDiskNumber >= 0 );

	CString strErrors;
	BOOL	bMissingDisk;
	
	if( !m_bLoaded )
	{
		if( !LoadDiskInfo( strErrors, bMissingDisk ) )
		{
			if( bMissingDisk )
				strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
			AfxMessageBox( strErrors, MB_ICONSTOP );
			return FALSE;
		}
	}

	// Retrieve the indexes in the partition table of the partition itself and of its parent extended partition ( if any )
	DWORD dwPartIndex, dwParentIndex, dwNextIndex;
	if( !SearchForPartitionInExtendedPartition( llPartStartOffset, MAXDWORD, 0, dwNextIndex, dwPartIndex, dwParentIndex ) )
	{
		// The partition was not found
		AfxMessageBox( IDS_ERR_PARTITION_NOT_FOUND, MB_ICONSTOP );
		return FALSE;
	}

	// Delete the partition from its parent table
	DeletePartitionFromTable( dwPartIndex );

	// Update / Delete the parent extended partition ( depends on what's left inside it )
	if( dwParentIndex != MAXDWORD )     // The partition was a member of an extended partition
		UpdateExtendedPartitionAfterMemberDeletion( dwParentIndex, ((DWORD)( dwPartIndex / 4 ))*4 ); 

	// Time to save on the disk
	if( !SaveDiskInfo( strErrors, bMissingDisk ) )
	{
		if( bMissingDisk )
			strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
		AfxMessageBox( strErrors, MB_ICONSTOP );
		return FALSE;
	}

	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Public method:		DeleteExtendedPartition

Purpose:			Delete an extended partition of the disk ( m_dwDiskNumber ).
					The extended partition should not be contained by another extended partition

Parameters:			[IN] LONGLONG llPartStartOffset
						Offset of the extended partition

Return value:		TRUE	if the deletion succeeded							
*/

BOOL CDiskMap::DeleteExtendedPartition(  
						LONGLONG llPartStartOffset )
{
	MY_TRY
	
	ASSERT( m_dwDiskNumber >= 0 );

	CString strErrors;
	BOOL	bMissingDisk;
	
	if( !m_bLoaded )
	{
		if( !LoadDiskInfo( strErrors, bMissingDisk ) )
		{
			if( bMissingDisk )
				strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
			AfxMessageBox( strErrors, MB_ICONSTOP );
			return FALSE;
		}
	}

	// The real offset of the extended partition is one track before the offset of the free space
	llPartStartOffset -= m_llTrackSize;
	
	// Search the extended partition in the disk 4 slots table
	DWORD dwMemberCount = ( 4 <= m_pBuffer->PartitionCount ) ? 4 : m_pBuffer->PartitionCount;
	for( UINT i = 0; i < dwMemberCount; i++ )
	{
		PARTITION_INFORMATION* pPart = &(m_pBuffer->PartitionEntry[i]);

		if( IsContainerPartition( pPart->PartitionType ) && ( pPart->StartingOffset.QuadPart == llPartStartOffset ) )
			break;
	}

	if( i == dwMemberCount )
	{
		// Partition not found
		AfxMessageBox( IDS_ERR_PARTITION_NOT_FOUND, MB_ICONSTOP );
		return FALSE;
	}

	DeletePartitionFromTable(i);

	// Time to save on the disk
	if( !SaveDiskInfo( strErrors, bMissingDisk ) )
	{
		if( bMissingDisk )
			strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
		AfxMessageBox( strErrors, MB_ICONSTOP );
		return FALSE;
	}

	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Public method:		CreatePartition

Purpose:			Create a partition on the disk ( m_dwDiskNumber )

Parameters:			[IN] LONGLONG llPartStartOffset
						Aproximative starting offset of the partition ( this might be modified due to 
						the creation of an extra container for this partition
					[IN] LONGLONG llPartSize
						Aproximative size of the partition ( this should be rounded-up to the next cylinder border )
					[OUT] LONGLONG& llExactPartStartOffset
						The exact starting offset of the partition

Return value:		TRUE	if the creation succeeded							
*/

BOOL CDiskMap::CreatePartition( 
						LONGLONG	llPartStartOffset,
						LONGLONG	llPartSize,
						LONGLONG&	llExactPartStartOffset)
{
	MY_TRY
	
	ASSERT( m_dwDiskNumber >= 0 );

	CString strErrors;
	BOOL	bMissingDisk;
	
	if( !m_bLoaded )
	{
		if( !LoadDiskInfo( strErrors, bMissingDisk ) )
		{
			if( bMissingDisk )
				strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
			AfxMessageBox( strErrors, MB_ICONSTOP );
			return FALSE;
		}
	}

	LONGLONG	llPartEndOffset = GetCylinderBorderAfter( llPartStartOffset + llPartSize );
	LONGLONG	llPartTrueSize = llPartEndOffset - llPartStartOffset;
	LONGLONG	llFreeSpaceStartOffset;
	LONGLONG	llFreeSpaceEndOffset;
	BOOL		bAtBeginningOfExtendedPartition;
	DWORD		dwNewPartIndex;
	
	if( !SearchForFreeSpaceInExtendedPartition( llPartStartOffset, llPartTrueSize, 0, m_llDiskSize, 0,
												llFreeSpaceStartOffset, llFreeSpaceEndOffset,
												bAtBeginningOfExtendedPartition, dwNewPartIndex) )
	{
		// The free space was not found
		AfxMessageBox( IDS_ERR_FREE_SPACE_NOT_FOUND, MB_ICONSTOP );
		return FALSE;
	}

	// If the partition must be created inside a container and it can't be created at the beginning of
	// this container then a new container must be created for it
	BOOL bCreateContainer = ( ( dwNewPartIndex >= 4 ) && !bAtBeginningOfExtendedPartition );

	if( !AddPartitionToTable( llPartStartOffset, llPartTrueSize, dwNewPartIndex, bCreateContainer, TRUE ) )
		return FALSE;

	if( bCreateContainer )
		llExactPartStartOffset = llPartStartOffset + m_llTrackSize;
	else
		llExactPartStartOffset = llPartStartOffset;
	
	// Time to save on the disk
	if( !SaveDiskInfo( strErrors, bMissingDisk ) )
	{
		if( bMissingDisk )
			strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
		AfxMessageBox( strErrors, MB_ICONSTOP );
		return FALSE;
	}

	return TRUE;

	MY_CATCH_AND_THROW
}


/*
Public method:		CreateExtendedPartition

Purpose:			Create an extended partition on the disk ( m_dwDiskNumber )

Parameters:			[IN] LONGLONG llPartStartOffset
						Offset of the partition
					[IN] LONGLONG llPartSize
						Estimate size of the partition ( this should be rounded-up to the next cylinder border )
					[OUT] LONGLONG& llNewFreeSpaceOffset
						The starting offset of the newly created free space inside the new empty extended partition
						Usually it is the starting offset of the extended partition + a track size


Return value:		TRUE	if the creation succeeded							
*/

BOOL CDiskMap::CreateExtendedPartition( 
						LONGLONG	llPartStartOffset,
						LONGLONG	llPartSize,
						LONGLONG&	llNewFreeSpaceOffset )
{
	MY_TRY
	
	ASSERT( m_dwDiskNumber >= 0 );

	CString strErrors;
	BOOL	bMissingDisk;
	
	if( !m_bLoaded )
	{
		if( !LoadDiskInfo( strErrors, bMissingDisk ) )
		{
			if( bMissingDisk )
				strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
			AfxMessageBox( strErrors, MB_ICONSTOP );
			return FALSE;
		}
	}

	LONGLONG	llPartEndOffset = GetCylinderBorderAfter( llPartStartOffset + llPartSize );
	LONGLONG	llPartTrueSize = llPartEndOffset - llPartStartOffset;
	LONGLONG	llFreeSpaceStartOffset;
	LONGLONG	llFreeSpaceEndOffset;
	BOOL		bAtBeginningOfExtendedPartition;
	DWORD		dwNewPartIndex;
	
	if( !SearchForFreeSpaceInExtendedPartition( llPartStartOffset, llPartTrueSize, 0, m_llDiskSize, 0,
												llFreeSpaceStartOffset, llFreeSpaceEndOffset, 
												bAtBeginningOfExtendedPartition, dwNewPartIndex) ||
		( dwNewPartIndex >= 4 ) )
	{
		// The free space was not found or was found in another extended partition
		AfxMessageBox( IDS_ERR_FREE_SPACE_NOT_FOUND, MB_ICONSTOP );
		return FALSE;
	}

	if( !AddPartitionToTable( llPartStartOffset, llPartTrueSize, dwNewPartIndex, TRUE, FALSE ) )
		return FALSE;
	
	// Time to save on the disk
	if( !SaveDiskInfo( strErrors, bMissingDisk ) )
	{
		if( bMissingDisk )
			strErrors.Format( IDS_ERR_MISSING_DISK, m_dwDiskNumber );
		AfxMessageBox( strErrors, MB_ICONSTOP );
		return FALSE;
	}
	
	llNewFreeSpaceOffset = llPartStartOffset + m_llTrackSize;

	return TRUE;

	MY_CATCH_AND_THROW
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods

/*
Protected method:	GetNextIndex

Purpose:			Given an extended partition table index in m_pBuffer->PartitionInfo, scan recursively  
					the extended partition tree and find the chunk of m_pBuffer->PartitionInfo filled with
					members of the extended partition
					Then return the next index. This index is the index of the following extended partition 
					from the same ( or superior ) level as the given extended partition
					
Parameters:			[IN] DWORD dwTableIndex
						Index in m_pBuffer->PartitionInfo of the extended partition
						( 0 for the whole disk );

Return value:		Index in m_pBuffer->PartitionEntry of the next extended partition table on the same level
*/

DWORD CDiskMap::GetNextIndex( DWORD dwTableIndex )
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( dwTableIndex >= 0 );
	ASSERT( dwTableIndex%4 == 0 );

	PARTITION_INFORMATION*	pTable = &( m_pBuffer->PartitionEntry[dwTableIndex] );
	
	DWORD dwNextIndex = dwTableIndex + 4; 
	
	// 1. Scan the partition table. Compute the end offset for every member. For container members retrieve all
	// their free spaces.
	for( UINT i = 0; ( i < 4 ) && ( dwTableIndex + i < m_pBuffer->PartitionCount ); i++ )
	{
		if( IsContainerPartition( pTable[i].PartitionType ) )
			dwNextIndex = GetNextIndex( dwNextIndex );	
	}
	
	return dwNextIndex;

	MY_CATCH_AND_THROW
}

/*
Protected method:	GetExtendedPartitionFreeSpaces

Purpose:			Search recursively for free spaces inside an extended partition given its starting offset, 
					size and partitions table index inside m_pBuffer
					This method may be called also to get the free spaces of the whole disk.

					For every found free space create a CFreeSpace instance and add it to arrFreeSpaces
					
Parameters:			[IN] LONGLONG llExtPartStartOffset
						The start offset of the extended partition ( 0 for the whole disk )
					[IN] LONGLONG llExtPartEndOffset
						The end offset of the extended partition ( m_llDiskSize for the whole disk )
					[IN] DWORD dwTableIndex
						Index in m_pBuffer->PartitionEntry of the partition table of the extended partition
						( 0 for the whole disk )
					[OUT] DWORD& dwNextIndex
						Index in m_pBuffer->PartitionEntry of the next extended partition table
					[OUT] CObArray& arrFreeSpaces
						Array of CFreeSpaceData containing all free spaces found in this extended partition (disk)
					[IN] CItemData* pParentData
						The items' parent data. It will fill the m_pParentData member of all new
						CFreeSpaceData instances

Return value:		-
*/

void CDiskMap::GetExtendedPartitionFreeSpaces( 
						LONGLONG llExtPartStartOffset, 
						LONGLONG llExtPartEndOffset, 
						DWORD dwTableIndex,
						DWORD& dwNextIndex,
						CObArray& arrFreeSpaces,
						CItemData* pParentData /* = NULL */)
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( dwTableIndex >= 0 );
	ASSERT( dwTableIndex%4 == 0 );
	
	PARTITION_INFORMATION*	pTable = &( m_pBuffer->PartitionEntry[dwTableIndex] );
	CObArray				arrPartFreeSpaces[4];
	LONGLONG				arrPartEndOffset[4];
	PARTITION_INFORMATION*	pPart;

	DWORD	dwMemberCount = ( dwTableIndex + 4 <= m_pBuffer->PartitionCount ) ? 4 : m_pBuffer->PartitionCount - dwTableIndex;
	
	// 1. Order the members by starting offset ( they may be not ordered in pTable )
	
	DWORD arrOrder[4];
	DWORD dwPartitionCount = SortPartitionsByOffset( pTable, dwMemberCount, arrOrder );
	ASSERT( dwPartitionCount <= dwMemberCount );

	// 2. Scan the partition table. For container members retrieve all their free spaces.
	
	dwNextIndex = dwTableIndex + 4;
	DWORD dwExtendedPartitionCountOnLevel = 0;
	
	for( UINT i = 0; i < dwMemberCount; i++ )
	{
		pPart = &(pTable[i]);
		if( pPart->PartitionType == 0 )
			continue;

		if( IsContainerPartition( pPart->PartitionType ) )
		{
			if( dwTableIndex == 0 )
			{
				// This is a root container partition. Its superior limit is given by its size
				arrPartEndOffset[i] = pPart->StartingOffset.QuadPart + pPart->PartitionLength.QuadPart;
			}
			else
			{
				// This is a container inside another container. Its superior limit is given by the starting offset
				// of the next partition ( as position ) or by the end of its parent container
				for( UINT j = 0; j < dwPartitionCount; j++ )
				{
					if( arrOrder[j] == i )
						break;
				}
				ASSERT( j < dwPartitionCount );
				if( j < dwPartitionCount - 1 )
					arrPartEndOffset[i] = pTable[ arrOrder[j+1] ].StartingOffset.QuadPart;
				else
					arrPartEndOffset[i] = llExtPartEndOffset;				
			}
			
			GetExtendedPartitionFreeSpaces( 
							pPart->StartingOffset.QuadPart, arrPartEndOffset[i], 
							dwNextIndex, dwNextIndex, arrPartFreeSpaces[i], pParentData );	

			dwExtendedPartitionCountOnLevel++;
		}
		else
			arrPartEndOffset[i] = pPart->StartingOffset.QuadPart + pPart->PartitionLength.QuadPart;
	}

	// 3. Now retrieve all free spaces inside this extended partition and add them to arrFreeSpaces
	// together with the free spaces of the container members. arrFreeSpaces must be sorted by starting offset
	
	// The first track of the disk / extended partition is reserved
	LONGLONG	llFreeSpaceStartOffset = llExtPartStartOffset + m_llTrackSize;
	LONGLONG	llFreeSpaceEndOffset;
	for( i = 0; i <= dwPartitionCount ; i++ )
	{
		// The end of a free space could be the starting offset of the next member or the end of the extended 
		// partition
		if( i == dwPartitionCount )
			llFreeSpaceEndOffset = llExtPartEndOffset;
		else
		{
			pPart = &(pTable[ arrOrder[i] ]);
			// Always take the greatest cylinder border less than or equal with the starting offset of the next member
			llFreeSpaceEndOffset = GetCylinderBorderBefore(pPart->StartingOffset.QuadPart);
		}
		
		// A free space must be at least 1 cylinder size long
		if( llFreeSpaceStartOffset + m_llCylinderSize <= llFreeSpaceEndOffset )
		{
			FREE_SPACE_TYPE wFreeSpaceType;
			if( dwTableIndex == 0 )				// This is a free space between primary partitions
				wFreeSpaceType = FST_Primary;
			else if( dwPartitionCount > 0 )		// This is a free space inside a non-empty extended partition
				wFreeSpaceType = FST_InExtendedPartition;
			else								// This is an empty extended partition
				wFreeSpaceType = FST_EmptyExtendedPartition;
			
			// We found a free space !!!
			CFreeSpaceData* pData = new CFreeSpaceData(
														m_dwDiskNumber, 
														m_pBuffer->Signature, 
														llFreeSpaceStartOffset,
														llFreeSpaceEndOffset - llFreeSpaceStartOffset,
														wFreeSpaceType,
														m_llCylinderSize,
														dwPartitionCount - dwExtendedPartitionCountOnLevel,
														dwExtendedPartitionCountOnLevel,
														pParentData
														);
			CString strMemberErrors;
			pData->ReadItemInfo( strMemberErrors );
			ASSERT( strMemberErrors.IsEmpty() ); 
			// Add the structure to the members' data array
			arrFreeSpaces.Add(pData);
		}			

		if( i != dwPartitionCount )
		{
			// The starting offset of the next free space could be the end offset of the current member		
			// Always take the lower cylinder border greater or equal with this value
			llFreeSpaceStartOffset =	GetCylinderBorderAfter( arrPartEndOffset[ arrOrder[i] ] );
			if( IsContainerPartition( pPart->PartitionType ) )
				arrFreeSpaces.Append( arrPartFreeSpaces[ arrOrder[i] ] );
		}
		
	}

	return;

	MY_CATCH_AND_THROW
}

/*
Protected method:	SortPartitionsByOffset

Purpose:			Sort a partition table by starting offset without actually changing the table
					
Parameters:			[IN] PARTITION_INFORMATION* arrTable
						Array of partitions ( inside m_pBuffer )
					[IN] DWORD
						The size of the array
					[OUT] DWORD* arrOrder
						Array of indexes in arrTable of partitions sorted by starting offset
						The null partitions are not considered at all

Return value:		The number of not null sorted partitions
*/

DWORD CDiskMap::SortPartitionsByOffset( 
						PARTITION_INFORMATION* arrTable, 
						DWORD dwSize, 
						DWORD* arrOrder )
{
	MY_TRY
	
	DWORD dwOrderedSize = 0;
	for( DWORD i = 0; i < dwSize; i++ )
	{
		// Just ignore null partitions
		if( arrTable[i].PartitionType == 0 )
			continue;

		for( DWORD j = 0; j < dwOrderedSize; j++ )
		{
			if( arrTable[i].StartingOffset.QuadPart < arrTable[arrOrder[j]].StartingOffset.QuadPart )
				break;
		}
		
		for( DWORD k = dwOrderedSize; k > j; k-- )
			arrOrder[k] = arrOrder[k-1];

		arrOrder[j] = i;
		dwOrderedSize++;
	}
	return dwOrderedSize;

	MY_CATCH_AND_THROW
}

/*
Protected method:	GetCylinderBorderBefore

Purpose:			Get the greatest cylinder border less than or equal with an offset
					
Parameters:			[IN] LONGLONG llOffset
						The offset
					
Return value:		The greatest cylinder border less than or equal with llOffset
*/

LONGLONG CDiskMap::GetCylinderBorderBefore( LONGLONG llOffset )
{	
	// This is the most common case so treat it separately
	if( llOffset%m_llCylinderSize == 0 )
		return llOffset;
	
	//And this the generic formula
	return ((LONGLONG)(llOffset / m_llCylinderSize)) * m_llCylinderSize;
}

/*
Protected method:	GetCylinderBorderAfter

Purpose:			Get the lowest cylinder border greater than or equal with an offset
					
Parameters:			[IN] LONGLONG llOffset
						The offset
					
Return value:		The lowest cylinder border greater than or equal with llOffset
*/

LONGLONG CDiskMap::GetCylinderBorderAfter( LONGLONG llOffset )
{
	// This is the most common case so treat it separately
	if( llOffset%m_llCylinderSize == 0 )
		return llOffset;

	// And this is the generic formula
	return ((LONGLONG)((llOffset + m_llCylinderSize - 1) / m_llCylinderSize)) * m_llCylinderSize;
}

/*
Protected method:	SearchForPartitionInExtendedPartition

Purpose:			Search recursively for a partition inside an extended partition
					This method may be called also to search for a partition inside the whole disk.
					
Parameters:			[IN] LONGLONG llPartOffset
						The start offset of the partition we are looking for
					[IN] DWORD dwExtPartIndex
						Index in m_pBuffer->PartitionEntry of the extended partition
						( MAXDWORD for the whole disk because we don't have -1 available )
					[IN] DWORD dwTableIndex
						Index in m_pBuffer->PartitionEntry of the partition table of the extended partition
						( 0 for the whole disk )
					[OUT] DWORD& dwNextIndex
						Index in m_pBuffer->PartitionEntry of the next extended partition table
					[OUT] DWORD& dwPartIndex
						Index in m_pBuffer->PartitionEntry of the partition we are looking for ( if found )
					[OUT] DWORD& dwParentIndex
						Index in m_pBuffer->PartitionEntry of the parent partition ( if partition found )

Return value:		TRUE if the partition was found inside this extended partition ( disk )
*/

BOOL CDiskMap::SearchForPartitionInExtendedPartition( 
						LONGLONG	llPartOffset,
						DWORD		dwExtPartIndex,	
						DWORD		dwTableIndex,
						DWORD&		dwNextIndex,
						DWORD&		dwPartIndex, 
						DWORD&		dwParentIndex )
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( dwTableIndex >= 0 );
	ASSERT( dwTableIndex%4 == 0 );
	
	PARTITION_INFORMATION*	pTable = &( m_pBuffer->PartitionEntry[dwTableIndex] );
	
	dwNextIndex = dwTableIndex + 4; 
	
	for( UINT i = 0; ( i < 4 ) && ( dwTableIndex + i < m_pBuffer->PartitionCount ) ; i++ )
	{
		PARTITION_INFORMATION* pPart = &(pTable[i]);
		if( pPart->PartitionType == 0 )
			continue;

		if( IsContainerPartition( pPart->PartitionType ) )
		{
			// Search in depth
			if( SearchForPartitionInExtendedPartition(	llPartOffset, dwTableIndex + i, dwNextIndex, 
														dwNextIndex, dwPartIndex, dwParentIndex ) )
				return TRUE;
		}
		else
		{
			if( pPart->StartingOffset.QuadPart == llPartOffset )
			{
				// This is my partition
				dwPartIndex = dwTableIndex + i;
				dwParentIndex = dwExtPartIndex;
				return TRUE;
			}
		}
	}

	return FALSE;

	MY_CATCH_AND_THROW
}

/*
Protected method:	DeletePartitionFromTable

Purpose:			Delete a partition from m_pBuffer->PartitionInfo table.
					
Parameters:			[IN] DWORD dwPartIndex
						The index of the partition in m_pBuffer->PartitionInfo
					

Return value:		-
*/

void CDiskMap::DeletePartitionFromTable( DWORD dwPartIndex )
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( ( dwPartIndex >= 0 ) && ( dwPartIndex < m_pBuffer->PartitionCount ) );
	
	// Get the 4 slots table of its parent
	DWORD dwTableIndex = ((DWORD)( dwPartIndex / 4 )) * 4;
	DWORD dwEndIndex = dwTableIndex + 3;
	if( dwEndIndex >= m_pBuffer->PartitionCount )
		dwEndIndex = m_pBuffer->PartitionCount - 1;
	
	PARTITION_INFORMATION*	pTable = &( m_pBuffer->PartitionEntry[dwTableIndex] );
	
	// Check if the given partition is a container partition
	BOOL bContainer = IsContainerPartition( m_pBuffer->PartitionEntry[dwPartIndex].PartitionType );

	// If container partition get the index in m_pBuffer->PartitionEntry for the 4 slots table of that partition
	DWORD dwPartTableIndex = dwTableIndex + 4;
	DWORD dwPartNextIndex;
	DWORD dwShift = 0;
	if( bContainer )
	{
		for( DWORD i = dwTableIndex; i < dwPartIndex; i++ )
		{
			if( IsContainerPartition( m_pBuffer->PartitionEntry[i].PartitionType ) )
				dwPartTableIndex = GetNextIndex( dwPartTableIndex );
		}

		dwPartNextIndex = GetNextIndex( dwPartTableIndex );
		dwShift = dwPartNextIndex - dwPartTableIndex;
	}
	
	// Move all following partitions one position to the left in the 4 slots table
	for( DWORD i = dwPartIndex; i < dwEndIndex;  i++ )
	{
		memcpy( &(m_pBuffer->PartitionEntry[i]), &(m_pBuffer->PartitionEntry[i+1]), sizeof( PARTITION_INFORMATION ) ); 
		m_pBuffer->PartitionEntry[i].RewritePartition = TRUE;
	}


	// Fill the last entry in the 4 slots table with zero
	memset( &(m_pBuffer->PartitionEntry[ dwEndIndex ]), 0, sizeof( PARTITION_INFORMATION ) ); 
	m_pBuffer->PartitionEntry[dwEndIndex].RewritePartition = TRUE;
	
	// If container partition remove from m_pBuffer->PartitionEntry all entries belonging to this container partition
	if( bContainer && ( dwShift > 0 ) )
	{
		for( DWORD i = dwPartTableIndex; i < m_pBuffer->PartitionCount - dwShift; i++ )
		{
			memcpy( &(m_pBuffer->PartitionEntry[i]), &(m_pBuffer->PartitionEntry[i+dwShift]), sizeof( PARTITION_INFORMATION ) ); 
			m_pBuffer->PartitionEntry[i].RewritePartition = TRUE;
		}
		m_pBuffer->PartitionCount -= dwShift;
	}

	MY_CATCH_AND_THROW
}

/*
Protected method:	UpdateExtendedPartitionAfterMemberDeletion

Purpose:			Update / Delete an extended partition after one of its members was deleted
					If the extended partition remains empty then it must be deleted
					If only one member is left and this member is an extended partition too then replace the
					extended partition with its member ( promote the member on the superior level )
					All other situations are unlikely to happen so I don't treat them here
					
Parameters:			[IN] DWORD dwPartIndex
						The index in m_pBuffer->PartitionInfo of the partition
					[IN] DWORD
						The index in m_pBuffer->PartitionInfo of the 4 slots table of the partition
					
Return value:		-
*/

void CDiskMap::UpdateExtendedPartitionAfterMemberDeletion( 
					DWORD dwPartIndex, 
					DWORD dwTableIndex )
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( ( dwPartIndex >= 0 ) && ( dwPartIndex < m_pBuffer->PartitionCount ) );
	ASSERT( dwTableIndex >= 0 );
	ASSERT( dwTableIndex%4 == 0 );

	// If the extended partition is member of the whole disk then don't touch it
	if( dwPartIndex < 4 )
		return;

	PARTITION_INFORMATION*	pTable = &( m_pBuffer->PartitionEntry[dwTableIndex] );

	// Order the members by starting offset
	DWORD arrOrder[4];
	DWORD dwMemberCount = ( dwTableIndex + 4 <= m_pBuffer->PartitionCount ) ? 4 : m_pBuffer->PartitionCount - dwTableIndex;
	dwMemberCount = SortPartitionsByOffset( pTable, dwMemberCount, arrOrder );

	if( dwMemberCount == 0 )
	{
		// The extended partition is empty so delete it
		DeletePartitionFromTable( dwPartIndex );
		return;
	}
	else if( dwMemberCount == 1 )
	{
		PARTITION_INFORMATION* pPart = &(pTable[ arrOrder[0] ]);
		if( IsContainerPartition( pPart->PartitionType ) )
		{
			// Replace the parent extended partition with this extended partition
			memcpy( &(m_pBuffer->PartitionEntry[dwPartIndex]), pPart, sizeof(PARTITION_INFORMATION) );
			m_pBuffer->PartitionEntry[dwPartIndex].RewritePartition = TRUE;
			// Remove the 4 slots table of the parent extended partition
			for( DWORD i = dwTableIndex; ( i + 4 < m_pBuffer->PartitionCount ); i++ )
			{
				memcpy( &(m_pBuffer->PartitionEntry[i]), &(m_pBuffer->PartitionEntry[i+4]), sizeof( PARTITION_INFORMATION ) ); 
				m_pBuffer->PartitionEntry[i].RewritePartition = TRUE;
			}
			m_pBuffer->PartitionCount -= 4;
			return;
		}
	}

	MY_CATCH_AND_THROW
}

/*
Protected method:	SearchForFreeSpaceInExtendedPartition

Purpose:			Given an offset and size search recursively for an appropriate free space
					inside an extended partition ( or the whole disk ).
					Return the start and end offset of the whole free space and the index in the partition table 
					where a new partition having the given offset and size might be inserted.
					
Parameters:			[IN] LONGLONG llOffset
						The start offset of the space we are looking for
					[IN] LONGLONG llSize
						The size of the space
					[IN] LONGLONG llExtPartStartOffset
						The start offset of the extended partition ( 0 for the whole disk )
					[IN] LONGLONG llExtPartEndOffset
						The end offset of the extended partition ( m_llDiskSize for the whole disk )
					[IN] DWORD dwTableIndex
						Index in m_pBuffer->PartitionEntry of the partition table of the extended partition
						( 0 for the whole disk )
					[OUT] LONGLONG& llFreeSpaceStartOffset
						The start offset of the appropriate free space
					[OUT] LONGLONG& llFreeSpaceEndOffset
						The end offset of the appropriate end space
					[OUT] BOOL &bAtBeginningOfExtendedPartition
						Is the free space at the beginning of the extended partition?
					[OUT] DWORD& dwNewPartIndex
						The index in m_pBuffer->PartitionEntry where a new partition having the given offset 
						and size may be inserted


Return value:		TRUE if a free space was found
*/

BOOL CDiskMap::SearchForFreeSpaceInExtendedPartition(
						LONGLONG	llOffset,
						LONGLONG	llSize,
						LONGLONG	llExtPartStartOffset, 
						LONGLONG	llExtPartEndOffset, 
						DWORD		dwTableIndex,
						LONGLONG&	llFreeSpaceStartOffset,
						LONGLONG&	llFreeSpaceEndOffset,
						BOOL		&bAtBeginningOfExtendedPartition,
						DWORD&		dwNewPartIndex)
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( dwTableIndex >= 0 );
	ASSERT( dwTableIndex%4 == 0 );
	
	PARTITION_INFORMATION*	pTable = &( m_pBuffer->PartitionEntry[dwTableIndex] );
	LONGLONG				arrPartEndOffset[4];
	PARTITION_INFORMATION*	pPart;

	DWORD	dwMemberCount = ( dwTableIndex + 4 <= m_pBuffer->PartitionCount ) ? 4 : m_pBuffer->PartitionCount - dwTableIndex;
	
	// 1. Order the members by starting offset ( they may be not ordered in pTable )
	
	DWORD arrOrder[4];
	DWORD dwPartitionCount = SortPartitionsByOffset( pTable, dwMemberCount, arrOrder );
	ASSERT( dwPartitionCount <= dwMemberCount );

	// 2. Scan the partition table. For container members try to create the partition inside them
	
	DWORD dwNextIndex = dwTableIndex + 4; 
	
	for( UINT i = 0; i < dwMemberCount; i++ )
	{
		pPart = &(pTable[i]);
		if( pPart->PartitionType == 0 )
			continue;

		if( IsContainerPartition( pPart->PartitionType ) )
		{
			if( dwTableIndex == 0 )
			{
				// This is a root container partition. Its superior limit is given by its size
				arrPartEndOffset[i] = pPart->StartingOffset.QuadPart + pPart->PartitionLength.QuadPart;
			}
			else
			{
				// This is a container inside another container. Its superior limit is given by the starting offset
				// of the next partition ( as position ) or by the end of its parent container
				for( UINT j = 0; j < dwPartitionCount; j++ )
				{
					if( arrOrder[j] == i )
						break;
				}
				ASSERT( j < dwPartitionCount );
				if( j < dwPartitionCount - 1 )
					arrPartEndOffset[i] = pTable[ arrOrder[j+1] ].StartingOffset.QuadPart;
				else
					arrPartEndOffset[i] = llExtPartEndOffset;				
			}
			
			if( ( llOffset >= pPart->StartingOffset.QuadPart ) &&
				( llOffset + llSize <= arrPartEndOffset[i] ) )
			{
				// Create the partition inside this container
				return SearchForFreeSpaceInExtendedPartition( llOffset, llSize,
							pPart->StartingOffset.QuadPart, arrPartEndOffset[i], dwNextIndex,
							llFreeSpaceStartOffset, llFreeSpaceEndOffset, bAtBeginningOfExtendedPartition, dwNewPartIndex );
			}
			else
				dwNextIndex = GetNextIndex(dwNextIndex);
		}
		else
			arrPartEndOffset[i] = pPart->StartingOffset.QuadPart + pPart->PartitionLength.QuadPart;
	}

	// 3. We must search for our free space among the free spaces between the members of this extended partition !!!

	// The first track of the disk / extended partition is reserved
	llFreeSpaceStartOffset = llExtPartStartOffset + m_llTrackSize;
	
	for( i = 0 ; i <= dwPartitionCount ; i++ )
	{
		// The end of a free space could be the starting offset of the next member or the end of the extended 
		// partition
		if( i == dwPartitionCount )
			llFreeSpaceEndOffset = llExtPartEndOffset;
		else
		{
			pPart = &(pTable[ arrOrder[i] ]);
			// Always take the greatest cylinder border less than or equal with the starting offset of the next member
			llFreeSpaceEndOffset = GetCylinderBorderBefore(pPart->StartingOffset.QuadPart);
		}
		
		// A free space must be at least 1 cylinder size long
		// Check also if the new partition would match in the free space
		if( ( llFreeSpaceStartOffset + m_llCylinderSize <= llFreeSpaceEndOffset ) &&
			( llOffset >= llFreeSpaceStartOffset) &&
			( llOffset + llSize <= llFreeSpaceEndOffset) )
		{
			// We found the appropriate free space but there is still a problem
			// What if the 4 slots table is already full?

			if( dwPartitionCount >= dwMemberCount )
			{
				AfxMessageBox( IDS_ERR_PARTITION_TABLE_FULL, MB_ICONSTOP );
				return FALSE;
			}
			bAtBeginningOfExtendedPartition = ( llFreeSpaceStartOffset == llExtPartStartOffset + m_llTrackSize );
			dwNewPartIndex = dwTableIndex + i;	
			return TRUE;
		}
		
		if( i != dwPartitionCount )
		{
			// The starting offset of the next free space could be the end offset of the current member		
			// Always take the lower cylinder border greater or equal with this value
			llFreeSpaceStartOffset =	GetCylinderBorderAfter( arrPartEndOffset[ arrOrder[i] ] );			
		}
	}

	// We didn't find a matching free space

	return FALSE;

	MY_CATCH_AND_THROW
}

/*
Protected method:	AddPartitionToTable

Purpose:			Add a new container partition AND/OR a new non-container partition to m_pBuffer->PartitionInfo 
					table and make all necessary changes to the partition table
					
Parameters:			[IN] LONGLONG llPartStartOffset
						The starting offset of the new partition
					[IN] LONGLONG llPartTrueSize
						The size of the new partition
					[IN] DWORD dwNewPartIndex
						The index of the new partition in m_pBuffer->PartitionInfo
					[IN] BOOL bCreateContainer
						Should we create a new extended partition?
					[IN] BOOL bCreateNonContainer
						Should we create a new non-container partition?

					Note: bCreateContainer and bNonCreateContainer can be both TRUE. Then a container partition
					is created first and a non-container partition is created inside this container
					These BOOL values cannot be both FALSE.
					

Return value:		TRUE if the partition table was modified successfully
*/

BOOL CDiskMap::AddPartitionToTable( 
						LONGLONG	llPartStartOffset, 
						LONGLONG	llPartSize, 
						DWORD		dwNewPartIndex, 
						BOOL		bCreateContainer,
						BOOL		bCreateNonContainer)
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( ( dwNewPartIndex >= 0 ) && ( dwNewPartIndex < m_pBuffer->PartitionCount ) );
	
	// We can create a new container partition, a new non-container partition or a 
	// new non-container partition inside a new container partition
	ASSERT( bCreateContainer || bCreateNonContainer );
	
	// Get the 4 slots table of its parent
	DWORD dwTableIndex = ((DWORD)( dwNewPartIndex / 4 )) * 4;
	DWORD dwMemberCount = ( dwTableIndex + 4 <= m_pBuffer->PartitionCount ) ? 4 : m_pBuffer->PartitionCount - dwTableIndex;
	
	PARTITION_INFORMATION*	pTable = &( m_pBuffer->PartitionEntry[dwTableIndex] );

	// 1. Get the chunks of m_pBuffer->PartitionEntry allocated for every container member of the extended partition
	DWORD arrStartIndex[4];
	DWORD arrEndIndex[4];
	DWORD dwNextIndex = dwTableIndex + 4;

	for( DWORD i = 0; i < dwMemberCount; i++ )
	{
		if( IsContainerPartition( pTable[i].PartitionType ) )
		{
			arrStartIndex[i] = dwNextIndex;
			arrEndIndex[i] = dwNextIndex = GetNextIndex(dwNextIndex);
		}
	}
	
	// 2. Sort the members of the extended partition by starting offset
	DWORD arrOrder[4];
	DWORD dwPartitionCount = SortPartitionsByOffset( pTable, dwMemberCount, arrOrder );	

	// There should be another free slot in the table. SearchForFreeSpaceInExtendedPartition should take care of this
	ASSERT( dwPartitionCount < dwMemberCount );
	
	
	// 3. Allocate a new buffer. We must be prepared to add some extra 4 slots to the partition table
	PDRIVE_LAYOUT_INFORMATION pNewBuffer = (PDRIVE_LAYOUT_INFORMATION)LocalAlloc( 0, 
		sizeof(DRIVE_LAYOUT_INFORMATION) + ( m_pBuffer->PartitionCount + 4 )*sizeof(PARTITION_INFORMATION) );
	if( pNewBuffer == NULL )
	{
		AfxMessageBox( IDS_ERR_ALLOCATION, MB_ICONSTOP);
		return FALSE;
	}

	// The drive info and the first m_dwTableIndex partition entries will not be changed in the new buffer
	memcpy( pNewBuffer, m_pBuffer, sizeof(DRIVE_LAYOUT_INFORMATION) + dwTableIndex*sizeof(PARTITION_INFORMATION) );

	// 4. Add the first ( dwNewPartIndex - dwTableIndex ) members of the extended partition to the new buffer 
	// in the starting offset order. Add also their chunks of m_pBuffer->PartitionEntry
	
	PARTITION_INFORMATION*	pNewTable = &( pNewBuffer->PartitionEntry[dwTableIndex] );	
	UINT	iNext;								// Index in pTable
	UINT	iNewNext = 0;						// Index in pNewTable
	DWORD	dwNewNextIndex = dwTableIndex + 4;	// Index in pNewBuffer->PartitionEntry of the next free chunk for an extended partition

	for( iNext = 0, iNewNext = 0; iNext < dwNewPartIndex - dwTableIndex; iNext++, iNewNext++ )
	{
		DWORD iOrder = arrOrder[iNext];
		memcpy( &(pNewTable[iNewNext]), &(pTable[iOrder]), sizeof(PARTITION_INFORMATION));
		if( iNewNext != iOrder )
			pNewTable[iNewNext].RewritePartition = TRUE;

		if( IsContainerPartition( pNewTable[iNewNext].PartitionType ) )
		{
			memcpy( &(pNewBuffer->PartitionEntry[dwNewNextIndex]), 
					&(m_pBuffer->PartitionEntry[ arrStartIndex[iOrder] ]), 
					( arrEndIndex[iOrder] - arrStartIndex[iOrder] ) * sizeof(PARTITION_INFORMATION));
		
			if( arrStartIndex[iOrder] != dwNewNextIndex )
			{
				for( DWORD j = arrStartIndex[iOrder]; j < arrEndIndex[iOrder]; j++ )
					pNewBuffer->PartitionEntry[dwNewNextIndex++].RewritePartition = TRUE;
			}
			else
				dwNewNextIndex += ( arrEndIndex[iOrder] - arrStartIndex[iOrder] );
		}
	}

	// 5. Add the partition ( or a container if required ) in the slot dwNewPartIndex
	FillNewPartitionInfo(	llPartStartOffset, llPartSize, 
							&(pNewTable[iNewNext++]), bCreateContainer );
	if( bCreateContainer )		
	{ 
		// 5.1 Add a new 4 slots table for the new container
		pNewBuffer->PartitionCount += 4;
		PARTITION_INFORMATION* pContainerTable = &( pNewBuffer->PartitionEntry[dwNewNextIndex] );
		dwNewNextIndex += 4;
		UINT iContainerNext = 0;

		// 5.2 Create the non-container partition in the first slot 
		if( bCreateNonContainer )
			FillNewPartitionInfo(	llPartStartOffset + m_llTrackSize, llPartSize - m_llTrackSize, 
									&(pContainerTable[iContainerNext++]), FALSE );

		if( dwTableIndex == 0 )
		{
			// The new container is among primary partitions

			// 5.3 Fill with zeroes the last entries of the new container table
			for( ; iContainerNext < 4; iContainerNext++ )
			{
				memset( &(pContainerTable[iContainerNext]), 0, sizeof(PARTITION_INFORMATION) );
				pContainerTable[iContainerNext].RewritePartition = TRUE;
			}
			// All following primary partitions will be added to pNewTable after this new container
		}
		else
		{
			// The new container is inside another container

			// 5.3 Fill with zeroes the last entries of the table pNewTable
			for( ; iNewNext < 4; iNewNext++ )
			{
				memset( &(pNewTable[iNewNext]), 0, sizeof(PARTITION_INFORMATION));
				pNewTable[iNewNext].RewritePartition = TRUE;
			}

			// 5.4. The new table becomes the table of the newly created container
			// All following partitions of the parent container will be added to the new container
			pNewTable = pContainerTable;
			iNewNext = iContainerNext;

		}
	}
	
	// 6. Copy the rest of valid partitions from pTable to pNewTable ( also ordered by starting offset )
	for( ; iNext < dwPartitionCount; iNext++, iNewNext++ )
	{
		DWORD iOrder = arrOrder[iNext];
		memcpy( &(pNewTable[iNewNext]), &(pTable[iOrder]), sizeof(PARTITION_INFORMATION));
		pNewTable[iNewNext].RewritePartition = TRUE;

		if( IsContainerPartition( pNewTable[iNewNext].PartitionType ) )
		{
			memcpy( &(pNewBuffer->PartitionEntry[dwNewNextIndex]), 
					&(m_pBuffer->PartitionEntry[ arrStartIndex[iOrder] ]), 
					( arrEndIndex[iOrder] - arrStartIndex[iOrder] ) * sizeof(PARTITION_INFORMATION));
		
			if( arrStartIndex[iOrder] != dwNewNextIndex )
			{
				for( DWORD j = arrStartIndex[iOrder]; j < arrEndIndex[iOrder]; j++ )
					pNewBuffer->PartitionEntry[dwNewNextIndex++].RewritePartition = TRUE;
			}
			else
				dwNewNextIndex += ( arrEndIndex[iOrder] - arrStartIndex[iOrder] );
		}
	}

	// 7. Fill with zeroes the last entries of pNewTable
	for( ; iNewNext < 4; iNewNext++ )
	{
		memset( &(pNewTable[iNewNext]), 0, sizeof(PARTITION_INFORMATION));
		pNewTable[iNewNext].RewritePartition = TRUE;
	}

	// 8. Add the tail of m_pBuffer to the tail of pNewBuffer
	if( bCreateContainer )
		ASSERT( dwNewNextIndex == dwNextIndex + 4 );
	else
		ASSERT( dwNewNextIndex == dwNextIndex );

	memcpy( &( pNewBuffer->PartitionEntry[dwNewNextIndex] ),
			&( m_pBuffer->PartitionEntry[dwNextIndex] ),
			( m_pBuffer->PartitionCount - dwNextIndex ) * sizeof(PARTITION_INFORMATION) );
	
	if( dwNewNextIndex != dwNextIndex )
	{
		for( DWORD j = dwNextIndex; j < m_pBuffer->PartitionCount; j++ )
			pNewBuffer->PartitionEntry[dwNewNextIndex++].RewritePartition = TRUE;
	}
	else
		dwNewNextIndex += ( m_pBuffer->PartitionCount - dwNextIndex );
	ASSERT( dwNewNextIndex == pNewBuffer->PartitionCount );

	// 9. Replace the old m_pBuffer with the new buffer

	LocalFree( m_pBuffer );
	m_pBuffer = pNewBuffer;
	
	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Protected method:	FillNewPartitionInfo

Purpose:			Fill a PARTITION_INFORMATION structure with the info of a new partition
					
Parameters:			[IN] LONGLONG llPartStartOffset
						The starting offset of the new partition
					[IN] LONGLONG llPartSize
						The size of the new partition
					[OUT] PARTITION_INFORMATION*
						Pointer to the structure to fill
					[IN] BOOL bContainer
						Is the new partition a container?
					

Return value:		- 
*/

void CDiskMap::FillNewPartitionInfo(	LONGLONG llPartStartOffset, LONGLONG llPartSize,/* LONGLONG llExtPartStartOffset, */
										PARTITION_INFORMATION* pPartInfo, BOOL bContainer )
{
	MY_TRY
	
	ASSERT( m_bLoaded );
	ASSERT( pPartInfo );

	pPartInfo->StartingOffset.QuadPart = llPartStartOffset;
	pPartInfo->PartitionLength.QuadPart = llPartSize; 

//#pragma message("TODO: HiddenSectors must be the number of sectors between the start of the disk or extended partition that contains the new partition and the start of the new partition?")
	pPartInfo->HiddenSectors = (DWORD)( ( llPartStartOffset ) / m_llSectorSize);

	// Don't assign any particular number for the partition. The system will take care of that
	pPartInfo->PartitionNumber = 0;

	pPartInfo->BootIndicator = FALSE;
	pPartInfo->RewritePartition = TRUE;

	if( bContainer )
	{
		pPartInfo->PartitionType = PARTITION_EXTENDED;
		pPartInfo->RecognizedPartition = FALSE;
	}
	else
	{
		//Windisk and Disk Management don't care about the number of sectors of the partition
		//They always create partitions with the type PARTITION_HUGE
		
		/*
		LONGLONG llSectorCount = ( llPartSize + m_llSectorSize - 1 ) / m_llSectorSize;
		if( llSectorCount <= CSEC_FAT )
			pPartInfo->PartitionType = PARTITION_FAT_12;
		else if( llSectorCount <= CSEC_FAT32MEG )
			pPartInfo->PartitionType = PARTITION_FAT_16;
		else
			pPartInfo->PartitionType = PARTITION_HUGE;
		*/

		pPartInfo->PartitionType = PARTITION_HUGE;
		pPartInfo->RecognizedPartition = TRUE;
	}

	MY_CATCH_AND_THROW
}

/*
Protected method:	AddError

Purpose:			Add a error message to a string .The error message will be formatted like this:
						<Disk number: >< My error message > [ System error message ]
					
Parameters:			[IN/OUT] CString& strErrors
						The string that must be appended with the error message
					[IN] UINT unErrorMsg
						Our error message. ID of a string from resources
					[IN] BOOL bAddSystemMsg
						TRUE if the latest error system message must be added to our message
					
Return value:		-
*/

void CDiskMap::AddError( 
						CString& strErrors, 
						UINT unErrorMsg, 
						BOOL bAddSystemMsg /* =FALSE */ )
{
	MY_TRY
	
	CString str, strName, strErr, strSystemErr;
	
	// Get system error message
	if( bAddSystemMsg )
	{
		LPVOID lpMsgBuf;
		if( ::FormatMessage(	
						FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,    
						NULL,
						GetLastError(),
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
						(LPTSTR) &lpMsgBuf,    
						0,    
						NULL ) ) // Process any inserts in lpMsgBuf.
		{			
			strSystemErr = (LPCTSTR)lpMsgBuf;
			LocalFree( lpMsgBuf );
		}
	}

	strName.Format( IDS_DISK, m_dwDiskNumber );

	// Get my error message
	strErr.LoadString(unErrorMsg);

	str.Format(_T("%s: %s %s\n"), strName, strErr, strSystemErr );
	strErrors += str;

	MY_CATCH_AND_THROW
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\diskmap.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	DiskMap.h

Abstract:

    Definition of classes used to keep the disk array map in memory. Used in retrieving partitions and free spaces, 
	in creating and deleting partitions

Author:

    Cristian Teodorescu      November 20, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DISKMAP_H_INCLUDED_)
#define AFX_DISKMAP_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <winioctl.h>

#include "FTManDef.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CDiskMap

class CItemData;

class CDiskMap
{
public:
	// Constructor
	CDiskMap();
	// Constructor providing the disk number
	CDiskMap( DWORD dwDiskNumber );
	
	~CDiskMap();

// Operations
public: 
	// Set the disk number and reset m_bLoaded
	void SetDiskNumber( DWORD dwDiskNumber );

	// Load disk layout and geometry
	BOOL LoadDiskInfo( CString& strErrors, BOOL& bMissingDisk );

	// Save the disk layout on disk
	BOOL SaveDiskInfo( CString& strErrors, BOOL& bMissingDisk );

	// Retrieve all non-container partitions on the disk and create CPhysicalPartitionData instances for them
	// If the disk info is not loaded the method calls LoadDiskInfo first
	BOOL ReadPartitions( CObArray& arrPartitions, CString& strErrors, BOOL& bMissingDisk, CItemData* pParentData = NULL );

	// Retrieve all free spaces on the disk and create CFreeSpaceData instances for them
	// If the disk info is not loaded the method calls LoadDiskInfo first
	BOOL ReadFreeSpaces( CObArray& arrFreeSpaces, CString& strErrors, BOOL& bMissingDisk, CItemData* pParentData = NULL );

	// Retrieve a non-container partition information from the disk layout given the partition offset
	BOOL ReadPartitionInformation(	LONGLONG llPartStartOffset, PARTITION_INFORMATION& partInfo, 
									PARTITION_TYPE& wPartitionType, CString& strErrors, BOOL& bMissingDisk );

	// Delete a non-container partition from the disk
	BOOL DeletePartition( LONGLONG llPartStartOffset );

	// Deletes an extended partition from the disk
	// The extended partition should not be contained by another extended partition
	BOOL DeleteExtendedPartition( LONGLONG llPartStartOffset );

	// Create a partition on the disk ( m_dwDiskNumber )
	BOOL CreatePartition( LONGLONG llPartStartOffset, LONGLONG llPartSize, LONGLONG& llExactPartStartOffset );

	// Create an extended  partition on the disk ( m_dwDiskNumber )
	BOOL CreateExtendedPartition( LONGLONG llPartStartOffset, LONGLONG llPartSize, LONGLONG& llNewFreeSpaceOffset );

//Data members
public:	

protected:
	// Disk number
	DWORD						m_dwDiskNumber;

	// Disk geometry
	LONGLONG					m_llTrackSize;
	LONGLONG					m_llSectorSize;
	LONGLONG					m_llCylinderSize;
	LONGLONG					m_llDiskSize;
	
	// Pointer to the drive layout buffer
	PDRIVE_LAYOUT_INFORMATION	m_pBuffer;
	
	// The size of the drive layout buffer
	DWORD						m_dwBufferSize;

	// Is the information related to disk m_dwDiskNumber loaded into this object ?
	BOOL						m_bLoaded;

protected:
	
	// Some recursive methods
	
	// Given an extended partition table index in m_pBuffer->PartitionInfo, scan recursively  
	// the extended partition tree and find the chunk of m_pBuffer->PartitionInfo filled with
	// members of the extended partition
	// Then return the next index. This index is the index of the following extended partition 
	// from the same ( or superior ) level as the given extended partition
	DWORD GetNextIndex( DWORD dwTableIndex );

	// Search for free spaces inside an extended partition given its starting offset, size and partitions table 
	// index inside m_pBuffer
	// For every found free space create a CFreeSpace instance and add it to arrFreeSpaces
	void GetExtendedPartitionFreeSpaces(	LONGLONG llExtPartStartOffset, LONGLONG llExtPartEndOffset, 
											DWORD dwTableIndex, DWORD& dwNextIndex, CObArray& arrFreeSpaces,
											CItemData* pParentData = NULL );

	// Search recursively for a partition inside an extended partition
	// This method may be called also to search for a partition inside the whole disk.
	BOOL SearchForPartitionInExtendedPartition( LONGLONG llPartOffset, DWORD dwExtPartIndex, DWORD dwTableIndex,
												DWORD& dwNextIndex, DWORD& dwPartIndex, DWORD& dwParentIndex );


	// Given an offset and size search recursively for an appropriate free space
	// inside an extended partition ( or the whole disk ).
	// Return the start and end offset of the whole free space and the index in the partition table 
	// where a new partition having the given offset and size might be inserted.
	BOOL SearchForFreeSpaceInExtendedPartition( LONGLONG llOffset, LONGLONG llSize, LONGLONG llExtPartStartOffset, 
						                        LONGLONG llExtPartEndOffset, DWORD dwTableIndex,
												LONGLONG& llFreeSpaceStartOffset, LONGLONG& llFreeSpaceEndOffset,
												BOOL &bAtBeginningOfExtendedPartition, DWORD&	 dwNewPartIndex);
	
	// Sort a partition table by starting offset without actually changing the table
	DWORD SortPartitionsByOffset( PARTITION_INFORMATION* arrTable, DWORD dwSize, DWORD* arrOrder );

	// Get the greatest cylinder border less than or equal with an offset
	LONGLONG GetCylinderBorderBefore( LONGLONG llOffset );
	// Get the lowest cylinder border greater than or equal with an offset
	LONGLONG GetCylinderBorderAfter( LONGLONG llOffset );

	// Delete a partition from m_pBuffer->PartitionInfo table
	void DeletePartitionFromTable( DWORD dwPartIndex );
	
	// Update / Delete an extended partition after one of its members was deleted
	// If the extended partition remains empty then it must be deleted
	// If only one member is left and this member is an extended partition too then replace the
	// extended partition with its member ( promote the member on the superior level )
	// All other situations are unlikely to happen so I don't treat them here
	void UpdateExtendedPartitionAfterMemberDeletion( DWORD dwPartIndex, DWORD dwTableIndex );

	// Add a new container partition AND/OR a new non-container partition to m_pBuffer->PartitionInfo table 
	// and make all necessary changes to the partition table
	BOOL AddPartitionToTable(	LONGLONG llPartStartOffset, LONGLONG llPartSize, 
								DWORD dwNewPartIndex, BOOL bCreateContainer, BOOL bCreateNonContainer );

	// Fill a PARTITION_INFORMATION structure with the info of a new partition
	void FillNewPartitionInfo(	LONGLONG llPartStartOffset, LONGLONG llPartSize,
								PARTITION_INFORMATION* pPartInfo, BOOL bContainer );
	
	// Add a error message to a string
	// The error message will be formatted like this:
	//		<Disk Number: >< My error message > [ System error message ]
	void AddError( CString& strErrors, UINT unErrorMsg, BOOL bAddSystemMsg = FALSE ); 

};

inline CDiskMap::CDiskMap() 
	: m_dwDiskNumber(-1), m_pBuffer(NULL), m_dwBufferSize(0), m_bLoaded(FALSE)
{
}

inline CDiskMap::CDiskMap( DWORD dwDiskNumber )
	: m_dwDiskNumber( dwDiskNumber ), m_pBuffer(NULL), m_dwBufferSize(0), m_bLoaded(FALSE)
{
	ASSERT( dwDiskNumber >= 0 );
}


inline CDiskMap::~CDiskMap()
{
	if( m_pBuffer )
		LocalFree( m_pBuffer );
}

inline void CDiskMap::SetDiskNumber( DWORD dwDiskNumber )
{
	ASSERT( dwDiskNumber >= 0 );
	if( m_dwDiskNumber != dwDiskNumber )
	{
		m_dwDiskNumber = dwDiskNumber;
		m_bLoaded = FALSE;
	}
}

#endif // !defined(AFX_DISKMAP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftdoc.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTDoc.cpp

Abstract:

    Implementation of the CFTDocument class. It is the MFC document class for the FT Volume views

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/


#include "stdafx.h"

#include "FTDoc.h"
#include "FTManDef.h"
#include "Item.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFTDocument

IMPLEMENT_DYNCREATE(CFTDocument, CDocument)

BEGIN_MESSAGE_MAP(CFTDocument, CDocument)
	//{{AFX_MSG_MAP(CFTDocument)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFTDocument construction/destruction

CFTDocument::CFTDocument()
{
	// TODO: add one-time construction code here

}

CFTDocument::~CFTDocument()
{
}

BOOL CFTDocument::OnNewDocument()
{
	MY_TRY

	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	CString strTitle;
	strTitle.LoadString(AFX_IDS_APP_TITLE);
	SetTitle( strTitle );
	
	return TRUE;

	MY_CATCH_REPORT_AND_RETURN_FALSE
}



/////////////////////////////////////////////////////////////////////////////
// CFTDocument serialization

void CFTDocument::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFTDocument diagnostics

#ifdef _DEBUG
void CFTDocument::AssertValid() const
{
	CDocument::AssertValid();
}

void CFTDocument::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFTDocument commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\frspace.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FrSpace.h

Abstract:

    The definition of class CFreeSpaceData. The class that stores all information related
	to a free space on a disk. A free space is a contiguous block on a physical disk which
	is not inside a partition

Author:

    Cristian Teodorescu      October 23, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FRSPACE_H_INCLUDED_)
#define AFX_FRSPACE_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Item.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CFreeSpaceData

class CFreeSpaceData : public CItemData
{
public:
	// Constructor providing the partition information
	CFreeSpaceData( 
				DWORD			dwDiskNumber, 
				DWORD			dwSignature, 
				LONGLONG		llOffset, 
				LONGLONG		llSize,
				FREE_SPACE_TYPE	wFreeSpaceType,
				LONGLONG		llCylinderSize,
				DWORD			dwPartitionCountOnLevel,
				DWORD			dwExtendedPartitionCountOnLevel,
				CItemData*		pParentData = NULL);

	virtual ~CFreeSpaceData() {};
	
// Operations
public: 
	virtual BOOL ReadItemInfo( CString& strErrors );

	virtual BOOL ReadMembers( CObArray& arrMembersData, CString& strErrors );

	virtual int ComputeImageIndex() const;

	virtual BOOL operator==(CItemData& rData) const;

	// Provide item properties
	virtual void GetDisplayName( CString& strDisplay ) const;
	virtual void GetDisplayType( CString& strDisplay ) const ;
	
	virtual BOOL GetSize( LONGLONG& llSize ) const;
	virtual BOOL GetDiskNumber( ULONG& ulDiskNumber ) const;
	virtual BOOL GetOffset( LONGLONG& llOffset) const;

//Data members
public:	
	DWORD				m_dwDiskNumber;						// Disk number
	DWORD				m_dwSignature;						// Disk signature
	LONGLONG			m_llOffset;							// Free space starting offset
	LONGLONG			m_llSize;							// Free space size
	FREE_SPACE_TYPE		m_wFreeSpaceType;					// Free space type 
	DWORD				m_dwFreeSpaceNumber;				// Free space number ( internal value )
	LONGLONG			m_llCylinderSize;					// Disk cylinder size
	DWORD				m_dwPartitionCountOnLevel;			// Number of non-container partitions on the same level with the free space
	DWORD				m_dwExtendedPartitionCountOnLevel;	// Number of container partitions on the same level with the free space

protected:
	virtual BOOL RetrieveDisksSet();
};

#endif // !defined(AFX_FRSPACE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\frspace.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FrSpace.cpp

Abstract:

    Implementation of the CFreeSpaceData class. The class that stores all information related
	to a free space

Author:

    Cristian Teodorescu      October 23, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "FrSpace.h"
#include "Resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// CFreeSpaceData

// Constructor
CFreeSpaceData::CFreeSpaceData(
							DWORD			dwDiskNumber, 
							DWORD			dwSignature, 
							LONGLONG		llOffset, 
							LONGLONG		llSize,
							FREE_SPACE_TYPE	wFreeSpaceType,
							LONGLONG		llCylinderSize,
							DWORD			dwPartitionCountOnLevel,
							DWORD			dwExtendedPartitionCountOnLevel,
							CItemData*		pParentData /* = NULL */) 
	:	CItemData( IT_FreeSpace, pParentData, FALSE ),						m_dwDiskNumber(dwDiskNumber),	
		m_dwSignature(dwSignature),			m_llOffset(llOffset),			m_llSize(llSize),				
		m_wFreeSpaceType( wFreeSpaceType ), m_dwFreeSpaceNumber(0),			m_llCylinderSize(llCylinderSize),
		m_dwPartitionCountOnLevel( dwPartitionCountOnLevel ),		
		m_dwExtendedPartitionCountOnLevel( dwExtendedPartitionCountOnLevel )
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Public methods

BOOL CFreeSpaceData::ReadItemInfo( CString& strErrors )
{
	MY_TRY

	m_bValid = TRUE;
	strErrors = _T("");
	
	m_ulNumMembers = 0;	
	
	// Retrieve all disks used by this volume
	if( !RetrieveDisksSet() )
	{
		AddError( strErrors, IDS_ERR_RETRIEVE_DISKS_SET, FALSE );
		m_bValid = FALSE;
	}

	m_bIoOK = TRUE;

	m_iImage = ComputeImageIndex();

	return m_bValid;

	MY_CATCH_AND_THROW
}

BOOL CFreeSpaceData::ReadMembers( CObArray& arrMembersData, CString& strErrors )
{
	arrMembersData.RemoveAll();
	strErrors = _T("");
	m_ulNumMembers = 0;
	return TRUE;
}

int CFreeSpaceData::ComputeImageIndex() const
{
	return II_FreeSpace;
}

BOOL CFreeSpaceData::operator==(CItemData& rData) const
{
	MY_TRY

	if( rData.GetItemType() != IT_FreeSpace )
		return FALSE;

	CFreeSpaceData* pFrSpaceData = (CFreeSpaceData*)(&rData);

	return( ( m_dwDiskNumber == pFrSpaceData->m_dwDiskNumber ) &&
			( m_dwSignature == pFrSpaceData->m_dwSignature ) &&
			( m_llOffset == pFrSpaceData->m_llOffset ) &&
			( m_llSize == pFrSpaceData->m_llSize ) &&
			( m_wFreeSpaceType == pFrSpaceData->m_wFreeSpaceType ) &&
			( m_llCylinderSize == pFrSpaceData->m_llCylinderSize ) &&
			( m_dwPartitionCountOnLevel == pFrSpaceData->m_dwPartitionCountOnLevel ) &&
			( m_dwExtendedPartitionCountOnLevel == pFrSpaceData->m_dwExtendedPartitionCountOnLevel ) );

	MY_CATCH_AND_THROW
}

void CFreeSpaceData::GetDisplayName( CString& strDisplay ) const 
{
	MY_TRY
		
	strDisplay.Format( IDS_FREE_SPACE_NAME, m_dwDiskNumber, m_dwFreeSpaceNumber );
	
	MY_CATCH_AND_THROW
}

void CFreeSpaceData::GetDisplayType( CString& strDisplay ) const 
{
	MY_TRY

	switch( m_wFreeSpaceType )
	{
		case FST_Primary:
			strDisplay.LoadString( IDS_TYPE_FREE_SPACE );
			break;
		case FST_InExtendedPartition:
			strDisplay.LoadString( IDS_TYPE_FREE_SPACE_IN_EXTENDED_PARTITION );
			break;
		case FST_EmptyExtendedPartition:
			strDisplay.LoadString( IDS_TYPE_EMPTY_EXTENDED_PARTITION );
			break;
		default:
			ASSERT(FALSE);
	}

	MY_CATCH_AND_THROW
}

BOOL CFreeSpaceData::GetSize( LONGLONG& llSize ) const
{
	llSize = m_llSize;
	return TRUE;
}

BOOL CFreeSpaceData::GetDiskNumber( ULONG& ulDiskNumber ) const
{
	ulDiskNumber  = m_dwDiskNumber;
	return TRUE;
}

BOOL CFreeSpaceData::GetOffset( LONGLONG& llOffset) const
{
	llOffset = m_llOffset;
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods

BOOL CFreeSpaceData::RetrieveDisksSet()
{
	MY_TRY

	m_setDisks.RemoveAll();
	m_setDisks.Add( m_dwDiskNumber );
	return TRUE;

	MY_CATCH_AND_THROW
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftdoc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTDoc.h

Abstract:

    The definition of class CFTDocument. It is the MFC document class for the FT Volume views

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FTDOC_H__B83E0001_6873_11D2_A297_00A0C9063765__INCLUDED_)
#define AFX_FTDOC_H__B83E0001_6873_11D2_A297_00A0C9063765__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CFTDocument : public CDocument
{
protected: // create from serialization only
	CFTDocument();
	DECLARE_DYNCREATE(CFTDocument)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFTDocument)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFTDocument();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CFTDocument)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FTDOC_H__B83E0001_6873_11D2_A297_00A0C9063765__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftlistvw.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTListVw.cpp

Abstract:

    Implementation of the CFTListView class. It is a list view displaying all members of a 
	logical volume

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/


#include "stdafx.h"

#include "Actions.h"
#include "FTDoc.h"
#include "FTListVw.h"
#include "FTTreeVw.h"
#include "Item.h"
#include "MainFrm.h"
#include "LogVol.h"
#include "PhPart.h"
#include "Resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This is the configuration of the list-view columns
LV_COLUMN_CONFIG ColumnsConfig[COLUMNS_NUMBER] = {
	{ LVC_Name,			IDS_COLUMN_NAME,	LVCFMT_LEFT,	20 },
	{ LVC_Type,			IDS_COLUMN_TYPE,	LVCFMT_LEFT,	20 },
	{ LVC_DiskNumber,	IDS_COLUMN_DISKS,	LVCFMT_RIGHT,	10 },
	{ LVC_Size,			IDS_COLUMN_SIZE,	LVCFMT_RIGHT,	15 },
	{ LVC_Offset,		IDS_COLUMN_OFFSET,	LVCFMT_RIGHT,	15 }, 
	{ LVC_VolumeID,		IDS_COLUMN_VOLUMEID,LVCFMT_RIGHT,	20 } };

/////////////////////////////////////////////////////////////////////////////
// CFTListView

IMPLEMENT_DYNCREATE(CFTListView, CListView)

BEGIN_MESSAGE_MAP(CFTListView, CListView)
	//{{AFX_MSG_MAP(CFTListView)
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_COMMAND(ID_ITEM_EXPAND, OnItemExpand)
	ON_NOTIFY_REFLECT(NM_RCLICK, OnRclick)
	ON_COMMAND(ID_ACTION_ASSIGN, OnActionAssign)
	ON_UPDATE_COMMAND_UI(ID_ACTION_ASSIGN, OnUpdateActionAssign)
	ON_COMMAND(ID_ACTION_FTBREAK, OnActionFtbreak)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTBREAK, OnUpdateActionFtbreak)
	ON_COMMAND(ID_ACTION_CREATE_EXTENDED_PARTITION, OnActionCreateExtendedPartition)
	ON_UPDATE_COMMAND_UI(ID_ACTION_CREATE_EXTENDED_PARTITION, OnUpdateActionCreateExtendedPartition)
	ON_COMMAND(ID_ACTION_CREATE_PARTITION, OnActionCreatePartition)
	ON_UPDATE_COMMAND_UI(ID_ACTION_CREATE_PARTITION, OnUpdateActionCreatePartition)
	ON_COMMAND(ID_ACTION_DELETE, OnActionDelete)
	ON_UPDATE_COMMAND_UI(ID_ACTION_DELETE, OnUpdateActionDelete)
    ON_COMMAND(ID_ACTION_FTINIT, OnActionFtinit)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTINIT, OnUpdateActionFtinit)
	ON_COMMAND(ID_ACTION_FTMIRROR, OnActionFtmirror)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTMIRROR, OnUpdateActionFtmirror)
	ON_COMMAND(ID_ACTION_FTSTRIPE, OnActionFtstripe)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTSTRIPE, OnUpdateActionFtstripe)
	ON_COMMAND(ID_ACTION_FTSWAP, OnActionFtswap)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTSWAP, OnUpdateActionFtswap)
	ON_COMMAND(ID_ACTION_FTSWP, OnActionFtswp)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTSWP, OnUpdateActionFtswp)
	ON_COMMAND(ID_ACTION_FTVOLSET, OnActionFtvolset)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTVOLSET, OnUpdateActionFtvolset)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFTListView construction/destruction

CFTListView::CFTListView() : m_pParentData(NULL)
{
	// TODO: add construction code here
}

CFTListView::~CFTListView()
{
}

BOOL CFTListView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CFTListView drawing

void CFTListView::OnDraw(CDC* pDC)
{
	// TODO: add draw code for native data here
}

void CFTListView::OnInitialUpdate()
{
	MY_TRY

	CListView::OnInitialUpdate();

	// fill in image list for normal icons
	
	CImageList* pImageList = new CImageList();
	if( pImageList->Create( IDB_IMAGELIST_LARGE, 32, 32, RGB( 255, 0, 255 ) ) )
		GetListCtrl().SetImageList(pImageList, LVSIL_NORMAL);
	else
		AfxMessageBox( IDS_ERR_CREATE_IMAGELIST, MB_ICONSTOP );

	// fill in image list for small icons
	pImageList = new CImageList();
	if( pImageList->Create( IDB_IMAGELIST_SMALL, 16, 16, RGB( 255, 0, 255 ) ) )
		GetListCtrl().SetImageList(pImageList, LVSIL_SMALL);
	else
		AfxMessageBox( IDS_ERR_CREATE_IMAGELIST, MB_ICONSTOP );

	// insert columns (REPORT mode) and modify the new header items
	CRect rect;
	GetListCtrl().GetWindowRect(&rect);

	for( int i = 0; i < COLUMNS_NUMBER; i++ )
	{
		PLV_COLUMN_CONFIG pColumn = &(ColumnsConfig[i]);
		CString str;
		if( !str.LoadString(pColumn->dwTitleID) )
			ASSERT(FALSE);
		GetListCtrl().InsertColumn( i, str, pColumn->nFormat , 
								rect.Width() * pColumn->wWidthPercent/100, pColumn->iSubItem);
	}

	// Set the list-view style 
	ModifyStyle(LVS_TYPEMASK, LVS_REPORT | LVS_SHOWSELALWAYS ); 
	
	// Load the popup menu
	m_menuPopup.LoadMenu(IDM_POPUP);
	
	// TODO: You may populate your ListView with items by directly accessing
	//  its list control through a call to GetListCtrl().

	MY_CATCH_AND_REPORT
}

int CFTListView::GetFocusedItem() const
{
	return GetListCtrl().GetNextItem(-1, LVNI_FOCUSED );
}

BOOL CFTListView::SetFocusedItem( int iItem )
{
	// The old focused item must loose the focus
	GetListCtrl().SetItemState(GetFocusedItem(), 0, LVNI_FOCUSED);
	// The new item receive focus
	return GetListCtrl().SetItemState(iItem, LVNI_FOCUSED, LVNI_FOCUSED);
}

BOOL CFTListView::SelectItem( int iItem, BOOL bSelect /* =TRUE */ )
{
	return GetListCtrl().SetItemState( iItem, bSelect ? LVNI_SELECTED : 0, LVNI_SELECTED );
}

CItemData* CFTListView::GetItemData( int iItem )
{
	LVITEM lvItem;
	lvItem.iItem = iItem;
	lvItem.iSubItem = LVC_Name;
	lvItem.mask = LVIF_PARAM;
	if( !GetListCtrl().GetItem(&lvItem) )
		return NULL;
	return (CItemData*)(lvItem.lParam);
	
}

BOOL CFTListView::AddItem( CItemData* pData )
{
	MY_TRY
	
	LVITEM lvitem;
	CString strDisplay;

	// Just in case
	if( pData == NULL )
		return FALSE;
	
	BOOL bReportStyle = ( GetWindowLong( GetListCtrl().GetSafeHwnd(), GWL_STYLE ) & LVS_REPORT );

	// 1. Insert the item

	lvitem.iItem = GetListCtrl().GetItemCount();
	ASSERT(LVC_Name==0);		// The first SubItem must be zero
	lvitem.iSubItem = LVC_Name;
	if( bReportStyle )
		pData->GetDisplayName(strDisplay);
	else
		pData->GetDisplayExtendedName(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	lvitem.iImage = pData->GetImageIndex();
	lvitem.lParam = (LPARAM)pData;
	lvitem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM ;
	int iActualItem =  GetListCtrl().InsertItem( &lvitem );
	if( iActualItem < 0 )
		return FALSE;

	// The items must appear in the list exactly in the order we added them 
	ASSERT( iActualItem == lvitem.iItem );
	pData->SetListItem( iActualItem );
	
	// 2. Set all subitems
	lvitem.iItem = iActualItem;
	lvitem.mask = LVIF_TEXT;

	// Type
	lvitem.iSubItem = LVC_Type;
	pData->GetDisplayType(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	GetListCtrl().SetItem( &lvitem );

	// Disks set
	lvitem.iSubItem = LVC_DiskNumber;
	pData->GetDisplayDisksSet(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	GetListCtrl().SetItem( &lvitem );

	// Size
	lvitem.iSubItem = LVC_Size;
	pData->GetDisplaySize(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	GetListCtrl().SetItem( &lvitem );

	// Offset
	lvitem.iSubItem = LVC_Offset;
	pData->GetDisplayOffset(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	GetListCtrl().SetItem( &lvitem );

	// Volume ID
	lvitem.iSubItem = LVC_VolumeID;
	pData->GetDisplayVolumeID(strDisplay);
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	GetListCtrl().SetItem( &lvitem );

	return TRUE;

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

BOOL CFTListView::RefreshItem( int iItem )
{
	MY_TRY

	LVITEM lvitem;
	CString strDisplay;

	BOOL bReportStyle = ( GetWindowLong( GetListCtrl().GetSafeHwnd(), GWL_STYLE ) & LVS_REPORT );

	// 1. Get the item data

	lvitem.iItem = iItem;
	ASSERT(LVC_Name==0);		// The first SubItem must be zero
	lvitem.iSubItem = LVC_Name;
	lvitem.mask = LVIF_PARAM ;
	if( !GetListCtrl().GetItem( &lvitem ) )
		return FALSE;
	CItemData* pData = (CItemData*)(lvitem.lParam);
	ASSERT( pData );
	ASSERT( pData->GetListItem() == iItem );

	// 2. Now refresh the name and the image of the item
	if( bReportStyle )
		pData->GetDisplayName( strDisplay );
	else
		pData->GetDisplayExtendedName( strDisplay );
	lvitem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
	lvitem.iImage = pData->GetImageIndex();
	lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
	
	return GetListCtrl().SetItem( &lvitem );

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

BOOL CFTListView::AddMembersFromTree()
{
	MY_TRY
	
	GetListCtrl().DeleteAllItems();
	if( !m_pParentData )
		return TRUE;

	CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, GetParentFrame() );
	CFTTreeView* pLeftView = (CFTTreeView*)(pFrame->GetLeftPane());
	ASSERT( pLeftView );
	CTreeCtrl& rTreeCtrl = pLeftView->GetTreeCtrl(); 
	
	ASSERT( m_pParentData->AreMembersInserted() );
	HTREEITEM hItem = m_pParentData->GetTreeItem();
	ASSERT(hItem);

	// For each member of the item add a new item to the list view
	HTREEITEM hChild = rTreeCtrl.GetChildItem(hItem);
	while( hChild != NULL )
	{
		TVITEM tvItem;
		tvItem.hItem = hChild;
		tvItem.mask = TVIF_PARAM;

		if( rTreeCtrl.GetItem(&tvItem) )
		{
			ASSERT(tvItem.lParam);
			if( !AddItem( (CItemData*)(tvItem.lParam) ) )
				return FALSE;
		}
		else
			ASSERT(FALSE);

		hChild = rTreeCtrl.GetNextSiblingItem(hChild);
	}

	SelectItem(0);
	SetFocusedItem(0);
	return TRUE;

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

// This method fills the list view with all members of the given item
// It causes also the expandation of the parent item in the tree view ( if it is not expanded ) 
BOOL CFTListView::ExpandItem( int iItem)
{
	MY_TRY
	
	if( iItem < 0 )
		return FALSE;

	// Now get the CItemData structure of the selected item
	
	CItemData* pData = GetItemData(iItem);
	if( !pData )
		return FALSE;
	
	// TODO: Add your control notification handler code here
	ASSERT( m_pParentData );
	
	// Double-clicking a member of the list is equivalent with two actions in the tree:
	// 1. Expand the selected item ( if not expanded )
	// 2. Select a member of it
	
	CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, GetParentFrame() );
	CFTTreeView* pLeftView = (CFTTreeView*)(pFrame->GetLeftPane());
	ASSERT(pLeftView); 
	CTreeCtrl& rTreeCtrl = pLeftView->GetTreeCtrl();
	
	// First expand the parent tree item
	HTREEITEM hItem = m_pParentData->GetTreeItem();
	ASSERT( hItem );
		
	TVITEM tvItem;
	tvItem.hItem = hItem;
	tvItem.stateMask = TVIS_EXPANDED; 
	tvItem.mask = TVIF_STATE;
	rTreeCtrl.GetItem(&tvItem);

	// If the parent node is not expanded then expand it
	if( !(tvItem.state & TVIS_EXPANDED ) )
	{
		// Reset the ExpandedOnce flag; so the tree view will receive the OnItemExpanding notification
		tvItem.stateMask = TVIS_EXPANDEDONCE;
		tvItem.state = 0;
		rTreeCtrl.SetItem(&tvItem);			

		// Before expanding the tree we must take a copy of pData ( because the expandation causes
		// all list-view items to be refreshed i.e. the old CItemData structures to be deleted
		CItemData* pOldData;
		if( pData->GetItemType() == IT_LogicalVolume )
			pOldData = new CLogicalVolumeData( *((CLogicalVolumeData*)pData) );
		else if( pData->GetItemType() == IT_PhysicalPartition )
			pOldData = new CPhysicalPartitionData( *((CPhysicalPartitionData*)pData) );
		else
			ASSERT(FALSE);
		
		rTreeCtrl.Expand( hItem, TVE_EXPAND );

		// Now we must find the old member among the new refreshed members
		int i;
		for( i=0, pData = NULL; ( i < GetListCtrl().GetItemCount() ) && !pData; i++ )
		{
			CItemData* pItemData = GetItemData(i);
			if( *pOldData == *pItemData )
				pData = pItemData;
		}
		// It is possible to don't find our member anymore
		// That means something happened with it outside our application
		if( !pData )
		{
			CString strDisplayName, str;
			pOldData->GetDisplayExtendedName(strDisplayName);
			AfxFormatString1(str, IDS_ERR_MEMBER_NOT_FOUND_ANYMORE, strDisplayName);
			AfxMessageBox(str,MB_ICONSTOP);
			delete pOldData;
			return FALSE;
		}
		delete pOldData;			
	}

	// Then mark the double-clicked item as selected in the tree
	ASSERT( pData->GetTreeItem() );
	//rTreeCtrl.EnsureVisible( pData->GetTreeItem() );	
	return rTreeCtrl.SelectItem( pData->GetTreeItem() );

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

////////////////////////////////////////////////////////////////////////////////////////////////
//   Public methods

void CFTListView::GetSnapshot( LIST_SNAPSHOT& snapshot )
{
	MY_TRY

	CWaitCursor wc;
	snapshot.setSelectedItems.RemoveAll();

	int iItem = GetListCtrl().GetNextItem( -1, LVNI_SELECTED );
	while (iItem >= 0)   
	{      
		CItemData* pData = GetItemData(iItem);
		ASSERT(pData);
		
		CItemID		idItem( *pData );
		snapshot.setSelectedItems.Add(idItem);

		iItem = GetListCtrl().GetNextItem( iItem, LVNI_SELECTED );
	}	

	MY_CATCH_AND_REPORT
}

void CFTListView::SetSnapshot( LIST_SNAPSHOT& snapshot )
{
	MY_TRY
	
	CWaitCursor wc;
	
	for ( int i = 0; i < GetListCtrl().GetItemCount(); i++ )   
	{      
		CItemData* pData = GetItemData(i);
		ASSERT( pData );
		
		CItemID		idItem( *pData );
		if( snapshot.setSelectedItems.InSet(idItem ) )
		{
			SelectItem( i, TRUE );
			SetFocusedItem(i);
		}
		else
			SelectItem( i, FALSE );
		
	}

	MY_CATCH_AND_REPORT
}

BOOL CFTListView::SynchronizeMembersWithTree( CItemData* pParentData )
{
	m_pParentData = pParentData;
	return AddMembersFromTree();
}

void CFTListView::GetSelectedItems( CObArray& arrSelectedItems )
{
	MY_TRY

	arrSelectedItems.RemoveAll();

	int iItem = GetListCtrl().GetNextItem( -1, LVNI_SELECTED );
	while (iItem >= 0)   
	{      
		CItemData* pData = GetItemData(iItem);
		ASSERT(pData);
		arrSelectedItems.Add(pData);

		iItem = GetListCtrl().GetNextItem( iItem, LVNI_SELECTED );
	}	

	MY_CATCH_AND_REPORT
}

void CFTListView::DisplayItemsExtendedNames( BOOL bExtended /* = TRUE */ )
{
	MY_TRY

	for( int i = 0; i < GetListCtrl().GetItemCount(); i++ )
	{
		CItemData* pData = (CItemData*)(GetListCtrl().GetItemData(i));
		ASSERT( pData );
		CString strDisplayName;

		if( bExtended )
			pData->GetDisplayExtendedName( strDisplayName );
		else
			pData->GetDisplayName( strDisplayName );

		GetListCtrl().SetItemText( i, LVC_Name, strDisplayName );
	}

	MY_CATCH_AND_REPORT
}

/////////////////////////////////////////////////////////////////////////////
// CFTListView diagnostics

#ifdef _DEBUG
void CFTListView::AssertValid() const
{
	CListView::AssertValid();
}

void CFTListView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

CFTDocument* CFTListView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CFTDocument)));
	return (CFTDocument*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFTListView message handlers
void CFTListView::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	//TODO: add code to react to the user changing the view style of your window
}

void CFTListView::OnDestroy() 
{
	GetListCtrl().DeleteAllItems();
	
	// Delete the image list
	CImageList* pImageList = GetListCtrl().GetImageList(LVSIL_NORMAL);
	if( pImageList )
	{
		pImageList->DeleteImageList();
		delete pImageList;
	}
	pImageList = GetListCtrl().GetImageList(LVSIL_SMALL);
	if( pImageList )
	{
		pImageList->DeleteImageList();
		delete pImageList;
	}

	// Destroy the popup menu
	m_menuPopup.DestroyMenu();
	
	CListView::OnDestroy();
	
	// TODO: Add your message handler code here
	
}

void CFTListView::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LPNMLISTVIEW pNMLV = (LPNMLISTVIEW) pNMHDR;
	*pResult = 0;
	ExpandItem( pNMLV->iItem );	
}

void CFTListView::OnItemExpand() 
{
	// TODO: Add your command handler code here
	int iItem =  GetFocusedItem();	
	ExpandItem(iItem);	
}

void CFTListView::OnRclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	*pResult = 0;

	LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW) pNMHDR;
	if( lpnmlv->iItem < 0 )
		return ;
	
	ClientToScreen( &(lpnmlv->ptAction) );

	// We want to display in fact only the first popup of the menu m_menuPopup
	CMenu* pPopup = m_menuPopup.GetSubMenu(0);
	if( pPopup != NULL )
		pPopup->TrackPopupMenu( TPM_LEFTALIGN, lpnmlv->ptAction.x, lpnmlv->ptAction.y, AfxGetMainWnd(), NULL);	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//		FT Actions

void CFTListView::OnActionAssign() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionAssign( arrSelectedItems );		
}

void CFTListView::OnUpdateActionAssign(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionAssign( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionFtbreak() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtbreak( arrSelectedItems );		
}

void CFTListView::OnUpdateActionFtbreak(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtbreak( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionCreateExtendedPartition() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionCreateExtendedPartition( arrSelectedItems );		
}

void CFTListView::OnUpdateActionCreateExtendedPartition(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionCreateExtendedPartition( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionCreatePartition() 
{	
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionCreatePartition( arrSelectedItems );		
}

void CFTListView::OnUpdateActionCreatePartition(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionCreatePartition( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionDelete() 
{	
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionDelete( arrSelectedItems );		
}

void CFTListView::OnUpdateActionDelete(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionDelete( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionFtinit() 
{	
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtinit( arrSelectedItems );		
}

void CFTListView::OnUpdateActionFtinit(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtinit( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionFtmirror() 
{	
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtmirror( arrSelectedItems );		
}

void CFTListView::OnUpdateActionFtmirror(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtmirror( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionFtstripe() 
{	
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtstripe( arrSelectedItems );		
}

void CFTListView::OnUpdateActionFtstripe(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtstripe( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionFtswap() 
{	
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtswap( arrSelectedItems );		
}

void CFTListView::OnUpdateActionFtswap(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtswap( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionFtswp() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtswp( arrSelectedItems );		
}

void CFTListView::OnUpdateActionFtswp(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtswp( pCmdUI, arrSelectedItems );		
}

void CFTListView::OnActionFtvolset() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtvolset( arrSelectedItems );		
}

void CFTListView::OnUpdateActionFtvolset(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtvolset( pCmdUI, arrSelectedItems );		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftman.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTMan.h

Abstract:

    Main header file for the FTMan application

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

#if !defined(AFX_FTMAN_H__B83DFFFB_6873_11D2_A297_00A0C9063765__INCLUDED_)
#define AFX_FTMAN_H__B83DFFFB_6873_11D2_A297_00A0C9063765__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "Resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFTManApp:
// See FTMan.cpp for the implementation of this class
//

class CFTManApp : public CWinApp
{
public:
	CFTManApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFTManApp)
	public:
	virtual BOOL InitInstance();
	virtual BOOL OnIdle( LONG lCount );
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CFTManApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	BOOL m_bStatusBarUpdatedOnce;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FTMAN_H__B83DFFFB_6873_11D2_A297_00A0C9063765__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftmandef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTManDef.h

Abstract:

    Types and constants definitions for application FTMan

Author:

    Cristian Teodorescu      October 22 1998

Notes:

Revision History:

--*/

#if !defined(AFX_FTMANDEF_H_INCLUDED_)
#define AFX_FTMANDEF_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////

class CItemID;

// Macros

/*
	My exception handling macros
*/
#define MY_TRY						try{
// Catch and do nothing
#define MY_CATCH					}catch(CException* e){ e->Delete(); }
// Catch and throw the exception to the superior try-catch block 
#define MY_CATCH_AND_THROW			}catch(CException* e){ throw; }
// Catch and report the exception
#define MY_CATCH_AND_REPORT			}catch(CException* e){ e->ReportError(MB_ICONSTOP); e->Delete(); }
// A catch macro to be used in dialog methods
#define MY_CATCH_REPORT_AND_CANCEL	}catch(CException* e){ e->ReportError(MB_ICONSTOP); e->Delete(); OnCancel(); }
// A catch macro to be used in functions that return BOOL
#define MY_CATCH_REPORT_AND_RETURN_FALSE }catch(CException* e){ e->ReportError(MB_ICONSTOP); e->Delete(); return FALSE; }
// A catch macro to be used in functions that return handle or pointer
#define MY_CATCH_REPORT_AND_RETURN_NULL }catch(CException* e){ e->ReportError(MB_ICONSTOP); e->Delete(); return NULL; }

// Some macros above are used in set.h so I include set.h here after the macro definitions
#include "Set.h"


// Constants / Enums

/*
	MainFrame timer's event id
*/
#define ID_TIMER_EVENT	2103
/*
	MainFrame timer's elapse ( in milliseconds )
*/
#define TIMER_ELAPSE	3000

/*
	Images index in all image lists
*/
enum tagImageIndex
{
	II_Root = 0,
	II_FTPartition,
	II_VolumeSet,
	II_StripeSet,
	II_MirrorSet,
	II_StripeSetWithParity,
	II_PhysicalPartition,
	II_FreeSpace,
	II_RootExpanded,
	// Exclamation marks on the images
	II_FTPartition_Warning,
	II_VolumeSet_Warning,
	II_StripeSet_Warning,
	II_MirrorSet_Warning,
	II_StripeSetWithParity_Warning,
	II_PhysicalPartition_Warning,
	// Red X's on the images
	II_FTPartition_Error,
	II_VolumeSet_Error,
	II_StripeSet_Error,
	II_MirrorSet_Error,
	II_StripeSetWithParity_Error,
	II_PhysicalPartition_Error,
	IMAGES_NUMBER	
};

/*
	Types of refreshments performed on tree and list view items every TIME_ELAPSE milliseconds.
	Used by CTreeView::RefreshOnTimer
*/
enum tagRefreshOnTimerFlags
{
	ROTT_GotDriveLetterAndVolumeName= 0x01,		// Volume's drive letter and volume name was found
	ROTT_EndInitialization			= 0x02,		// A stripe set with parity finished its initializing process
	ROTT_EndRegeneration			= 0x04		// A mirror set or stripe set with parity finished the regeneration process
};

// Types

/*	
	Type ITEM_TYPE - Defines all possible types of items that may appear in the tree view
								and the list view
*/
typedef enum tagItemType
{
	IT_RootVolumes,
	IT_LogicalVolume,
	IT_PhysicalPartition,
	IT_RootFreeSpaces,
	IT_FreeSpace
} ITEM_TYPE;

/*	
	Type PARTITION_TYPE - Defines all possible types of physical partitions
*/
typedef enum tagPartitionType
{
	PT_Primary,					// Primary partition
	PT_InExtendedPartition		// Partition inside an extended partition
} PARTITION_TYPE;

/*	
	Type FREE_SPACE_TYPE - Defines all possible types of free spaces
*/
typedef enum tagFreeSpaceType
{
	FST_Primary,				// Primary free space ( not in extended partitions )
	FST_InExtendedPartition,	// Free space inside an extended partition whose table is not empty
	FST_EmptyExtendedPartition	// Empty extended partition
} FREE_SPACE_TYPE;

/*
	Type LV_COLUMNS - Defines the indexes of columns in the list view
*/
typedef enum tagLVColumns
{
	LVC_Name = 0,
	LVC_Type,
	LVC_DiskNumber,
	LVC_Size,
	LVC_Offset,
	LVC_VolumeID,
	COLUMNS_NUMBER
} LV_COLUMNS;

/*
	Type LV_COLUMN_CONFIG - Defines the configuration of a list-view column
*/
typedef struct tagLVColumnConfig
{
	LV_COLUMNS	iSubItem;		// The index of the subitem
	DWORD		dwTitleID;		// The ID of the resource string to be title of this column
	int			nFormat;		// Alignment 
	WORD		wWidthPercent;	// The percent of the list-view width to be used by this column
} LV_COLUMN_CONFIG, *PLV_COLUMN_CONFIG;

/*
	Type CULONGSet  -  A set of ULONG elements. 
*/
typedef CSet<ULONG, ULONG> CULONGSet;	

/*
	Type CItemIDSet  - A set of CItemID elements
*/
typedef CSet<CItemID, CItemID&> CItemIDSet;

/*
	Type TREE_SNAPSHOT  -  Defines the current status of the tree-view. It is used when refreshing the tree 
*/
typedef struct tagTreeSnapshot
{
	CItemIDSet	setExpandedItems;	// All expanded items
	CItemIDSet	setSelectedItems;	// All selected items ( should be only one )
} TREE_SNAPSHOT, *PTREE_SNAPSHOT;

/*
	Type LIST_SNAPSHOT  -  Defines the current status of the list-view. It is used when refreshing the list 
*/
typedef struct tagListSnapshot
{
	CItemIDSet setSelectedItems;	// All selected items
} LIST_SNAPSHOT, *PLIST_SNAPSHOT;

#endif // !defined(AFX_FTMANDEF_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftman.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTMan.cpp

Abstract:

    Defines the class behaviors for the FTMan application.

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/


#include "stdafx.h"

#include "Item.h"
#include "FTDoc.h"
#include "FTMan.h"
#include "FTTreeVw.h"
#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFTManApp

BEGIN_MESSAGE_MAP(CFTManApp, CWinApp)
	//{{AFX_MSG_MAP(CFTManApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFTManApp construction

CFTManApp::CFTManApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CFTManApp object

CFTManApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CFTManApp initialization

BOOL CFTManApp::InitInstance()
{
	MY_TRY

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifndef _WIN64
// Sundown: ctl3d is only necessary if you intend on running on NT 3.51
#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif
#endif // !_WIN64

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	//SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	//LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Check whether the current user is a member of the Administrators group
	// If he/she's not then he/she can't use this application
	BOOL bIsAdministrator;
	if( !CheckAdministratorsMembership( bIsAdministrator ) )
		return FALSE;
	if( !bIsAdministrator )
	{
		AfxMessageBox(IDS_ERR_NOT_ADMINISTRATOR, MB_ICONSTOP);
		return FALSE;
	}
	
	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CFTDocument),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CFTTreeView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;
	
	// The one and only window has been initialized, so show and update it.
	m_bStatusBarUpdatedOnce = FALSE;
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();
	
	return TRUE;

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

BOOL CFTManApp::OnIdle( LONG lCount )
{
	// This is a dirty trick used to cover a status bar bug. I must repaint the status bar immediately after its 
	// first painting because the last pane appears with border although it shouldn't
	if( !m_bStatusBarUpdatedOnce )
	{
		((CMainFrame*)m_pMainWnd)->GetStatusBar()->InvalidateRect(NULL);
		((CMainFrame*)m_pMainWnd)->GetStatusBar()->UpdateWindow();
		m_bStatusBarUpdatedOnce = TRUE;
	}

	return CWinApp::OnIdle( lCount );
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CFTManApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CFTManApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftlistvw.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTListVw.h

Abstract:

    The definition of class CFTListView. It is a list view displaying all members of a volume

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FTLISTVW_H__B83E0003_6873_11D2_A297_00A0C9063765__INCLUDED_)
#define AFX_FTLISTVW_H__B83E0003_6873_11D2_A297_00A0C9063765__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "FTManDef.h"

class CItemData;
class CFTDocument;

class CFTListView : public CListView
{
protected: // create from serialization only
	CFTListView();
	DECLARE_DYNCREATE(CFTListView)

// Attributes
public:
	CFTDocument* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFTListView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFTListView();

	// Get the current status of the list ( what items are selected )
	void GetSnapshot( LIST_SNAPSHOT& snaphshot );
	// Set the snapshot of the list ( what items must be selected )
	void SetSnapshot( LIST_SNAPSHOT& snapshot );

	// Fill the list view with all children of the given item. Take this children from the tree view
	BOOL SynchronizeMembersWithTree( CItemData* pParentData );
	
	// Refresh item ( redisplay the item according with the information contained by its lParam which is a CItemData* )
	// WARNING: Now it only redisplays the name of the item !!!!
	BOOL RefreshItem( int iItem );

	// Display the names of items in extended format ( name + type ) when bExtended is TRUE
	// Otherwise display the names in reduced format
	void DisplayItemsExtendedNames( BOOL bExtended = TRUE );

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	// Get focused item
	int GetFocusedItem() const;

	// Set focused item
	BOOL SetFocusedItem( int iItem );

	// Select / Deselect a given item
	BOOL SelectItem( int iItem, BOOL bSelect=TRUE );

	// Retrieve the data structure associated with the item
	CItemData* GetItemData( int iItem );

	// Add a new item at the end of the list given a CItemData instance
	BOOL AddItem( CItemData* pData );

	// Repopulate the list by adding all members of m_pParentData from the tree 
	BOOL AddMembersFromTree();

	// Fill the list view with all members of the given item
	// It causes also the expandation of the parent item in the tree view ( if it is not expanded ) 
	// and the selection of the given item in the tree view
	BOOL ExpandItem(int iItem);

	// Get all selected items in the given array ( array of CItemData )
	void GetSelectedItems( CObArray& arrSelectedItems );

protected:
	
	// Structure containing info related to the parent of the members displayed by the list view
	CItemData* m_pParentData;

	// The popup menu that appears when the user clicks the mouse right button is the first popup
	// of the following menu
	CMenu	m_menuPopup;

// Generated message map functions
protected:
	//{{AFX_MSG(CFTListView)
	afx_msg void OnDestroy();
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemExpand();
	afx_msg void OnRclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnActionAssign();
	afx_msg void OnUpdateActionAssign(CCmdUI* pCmdUI);
	afx_msg void OnActionFtbreak();
	afx_msg void OnUpdateActionFtbreak(CCmdUI* pCmdUI);
	afx_msg void OnActionCreateExtendedPartition();
	afx_msg void OnUpdateActionCreateExtendedPartition(CCmdUI* pCmdUI);
	afx_msg void OnActionCreatePartition();
	afx_msg void OnUpdateActionCreatePartition(CCmdUI* pCmdUI);
	afx_msg void OnActionDelete();
	afx_msg void OnUpdateActionDelete(CCmdUI* pCmdUI);
    afx_msg void OnActionFtinit();
	afx_msg void OnUpdateActionFtinit(CCmdUI* pCmdUI);
	afx_msg void OnActionFtmirror();
	afx_msg void OnUpdateActionFtmirror(CCmdUI* pCmdUI);
	afx_msg void OnActionFtstripe();
	afx_msg void OnUpdateActionFtstripe(CCmdUI* pCmdUI);
	afx_msg void OnActionFtswap();
	afx_msg void OnUpdateActionFtswap(CCmdUI* pCmdUI);
	afx_msg void OnActionFtswp();
	afx_msg void OnUpdateActionFtswp(CCmdUI* pCmdUI);
	afx_msg void OnActionFtvolset();
	afx_msg void OnUpdateActionFtvolset(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in FTListVw.cpp
inline CFTDocument* CFTListView::GetDocument()
   { return (CFTDocument*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FTLISTVW_H__B83E0003_6873_11D2_A297_00A0C9063765__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftutil.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTUtil.cpp

Abstract:

    Implementation of FT utilities

Author:

    Cristian Teodorescu      October 29, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "DiskMap.h"
#include "FTUtil.h"
#include "Global.h"
#include "Item.h"
#include "Resource.h"

extern "C"
{
	#include <FTAPI.h>
}

#include <ntddft2.h>
#include <winioctl.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*
Global function:	FTBreak

Purpose:			Break a logical volume
					
Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						ID of the logical volume 

Return value:		TRUE if the volume is broken  successfully
*/

BOOL FTBreak( FT_LOGICAL_DISK_ID llVolID )
{
	MY_TRY

	CWaitCursor wc;
	BOOL bResult;

	DisplayStatusBarMessage( IDS_STATUS_FTBREAK );

	bResult = FtBreakLogicalDisk( llVolID );

	if( bResult )
	{
		//AfxMessageBox( IDS_MSG_FTBREAK, MB_ICONINFORMATION );	
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTBREAK );
	
	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTChkIO

Purpose:			Check the IO status of a logical volume
					
Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						ID of the logical volume 
					[OUT] BOOL* pbOK
						The result of the IO check

Return value:		TRUE if the IO check operation succeeded
*/

BOOL FTChkIO( FT_LOGICAL_DISK_ID llVolID, BOOL* pbOK  )
{
	MY_TRY
	
	BOOL bResult; 

	bResult = FtCheckIo( llVolID, pbOK );

	/*
	if( bResult )
	{
		CString strMsg, strOK;
		strOK.LoadString( bOK ? IDS_OK : IDS_NOTOK );
		AfxFormatString1(strMsg, IDS_MSG_FTCHKIO, strOK);
		AfxMessageBox(strMsg,MB_ICONINFORMATION);
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTCHKIO );
	*/

	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTExtend

Purpose:			Extend the file system of a volume to the maximum possible
					
Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						ID of the logical volume 

Return value:		TRUE if the file system is extended successfully
*/

BOOL FTExtend( FT_LOGICAL_DISK_ID llVolID )
{
	MY_TRY

	CWaitCursor				wc;
	BOOL					bReturn;
	HANDLE					h;
	PARTITION_INFORMATION	partInfo;
	DISK_GEOMETRY			geometry;
	ULONG					ulBytes;
	LONGLONG				llNewSectors;
	
	CString strVolumeName;
	if( !FTQueryVolumeName( llVolID, strVolumeName ) )
		return FALSE;

	h = CreateFile( strVolumeName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE );
	if( h == INVALID_HANDLE_VALUE )
	{
		DisplaySystemErrorMessage( IDS_ERR_FTEXTEND );
		return FALSE;
	}

	bReturn = DeviceIoControl( h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
								&partInfo, sizeof(partInfo), &ulBytes, NULL );
	if( !bReturn )
	{
		DisplaySystemErrorMessage( IDS_ERR_FTEXTEND );
		CloseHandle(h);
		return FALSE;
	}
	
	bReturn = DeviceIoControl( h, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
								&geometry, sizeof(geometry), &ulBytes, NULL );
	if( !bReturn )
	{
		DisplaySystemErrorMessage( IDS_ERR_FTEXTEND );
		CloseHandle(h);
		return FALSE;
	}

	llNewSectors = partInfo.PartitionLength.QuadPart / geometry.BytesPerSector;

	bReturn = DeviceIoControl( h, FSCTL_EXTEND_VOLUME, &llNewSectors, sizeof(llNewSectors),
								NULL, 0, &ulBytes, NULL );

	CloseHandle(h);
	return bReturn;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTInit

Purpose:			Initialize a logical volume with repairing ( or not ) the orphan member
					
Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						The ID of the logical volume
					[BOOL] bInitOrphans
                        Initialize the orphan member or not

Return value:		TRUE if the logical volume was initialized successfully
*/
BOOL FTInit( FT_LOGICAL_DISK_ID llVolID, BOOL bInitOrphans /* = TRUE */ )
{
    MY_TRY

	CWaitCursor								wc;
	BOOL									bResult;
	
    DisplayStatusBarMessage( IDS_STATUS_FTINIT );

	bResult = FtInitializeLogicalDisk( llVolID, bInitOrphans );

	if( bResult )
	{
		//AfxMessageBox( IDS_MSG_FTINIT, MB_ICONINFORMATION );
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTINIT );

	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTMirror

Purpose:			Create a mirror set based on the given logical volumes
					
Parameters:			[IN] FT_LOGICAL_DISK_ID* arrVolID
						ID's of the members
					[IN] WORD wNumVols
						The number of members ( must be 2 )
					[OUT] FT_LOGICAL_DISK_ID* pllVolID 
						Address where the logical volume ID of the new mirror set is to be stored
						If NULL then don't return the ID

Return value:		TRUE if the mirror set is created successfully
*/

BOOL FTMirror( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, FT_LOGICAL_DISK_ID* pllVolID /* = NULL */ )
{
	MY_TRY

	ASSERT( arrVolID );
	ASSERT( wNumVols == 2 );
	
	CWaitCursor								wc;
	BOOL									bResult;
	FT_MIRROR_SET_CONFIGURATION_INFORMATION	configInfo;
	FT_LOGICAL_DISK_ID						llNewVolID;
	LONGLONG								llMemberSize, llZeroMemberSize;

	DisplayStatusBarMessage( IDS_STATUS_FTMIRROR );

	configInfo.MemberSize = MAXLONGLONG;

	for( int i = 0; i < wNumVols; i++ )
	{
		bResult = FtQueryLogicalDiskInformation( arrVolID[i], NULL, &llMemberSize, 0,
													NULL, NULL, 0, NULL, 0, NULL );
		if( !bResult )
		{
			DisplaySystemErrorMessage(IDS_ERR_RETRIEVING_VOL_INFO);
			return FALSE;
		}

		if( llMemberSize < configInfo.MemberSize )
			configInfo.MemberSize = llMemberSize;

		if( i == 0 )
			llZeroMemberSize = llMemberSize;
	}

	if( llMemberSize < llZeroMemberSize )
	{
		CString str, strSize1, strSize2;
		FormatVolumeSize( strSize1, llZeroMemberSize );
		FormatVolumeSize( strSize2, llMemberSize );
		AfxFormatString2(str, IDS_QST_FTMIRROR, strSize1, strSize2);
		if( IDYES != AfxMessageBox( str, MB_YESNO | MB_DEFBUTTON2 ) )
		{
			DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
			return FALSE;
		}		
		wc.Restore();
	}

	bResult = FtCreateLogicalDisk( FtMirrorSet, wNumVols, arrVolID, sizeof(configInfo),
									&configInfo, &llNewVolID );

	if( bResult )
	{
		//AfxMessageBox( IDS_MSG_FTMIRROR, MB_ICONINFORMATION );
		if( pllVolID )
			*pllVolID = llNewVolID;
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTMIRROR );

	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTOrphan

Purpose:			Orphan the given member of the given logical volume.
					
Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						ID of the logical volume
					[IN] WORD wMember
						Zero-based index of the member to be orphaned

Return value:		TRUE if the member is orphaned successfully
*/

BOOL FTOrphan( FT_LOGICAL_DISK_ID llVolID, WORD wMember )
{
	MY_TRY

	CWaitCursor			wc;
	BOOL				bResult;

	DisplayStatusBarMessage( IDS_STATUS_FTORPHAN );

	bResult = FtOrphanLogicalDiskMember( llVolID, wMember );

	if( bResult )
	{
		// AfxMessageBox( IDS_MSG_FTORPHAN, MB_ICONINFORMATION );
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTORPHAN );

	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTPart

Purpose:			Converts a physical partition into a FT partition 
					
Parameters:			[IN] CString& strVolumeName
						Volume name of the physical partition
						It should be like this: "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
					[IN] TCHAR cDriveLetter
						The drive letter of the physical partition
						'\0' if none
					[OUT] FT_LOGICAL_DISK_ID* pllVolID 
						Address where the logical volume ID of the new FT partitions to be stored
						If NULL then don't return the ID

Return value:		TRUE if the FT partition is created successfully
*/

BOOL FTPart( const CString& strVolumeName, TCHAR cDriveLetter /* =_T('\0') */, FT_LOGICAL_DISK_ID* pllVolID /* = NULL */ )
{
	MY_TRY

	CWaitCursor			wc;
	BOOL				bResult;
	HANDLE				hPart;
	FT_LOGICAL_DISK_ID	llVolID;

	// First open the partition
	hPart = OpenVolume( strVolumeName );

	if( hPart == INVALID_HANDLE_VALUE )
	{
		DisplaySystemErrorMessage( IDS_ERR_FTPART );
		return FALSE;
	}
	
	// Second create the logical volume
	bResult = FtCreatePartitionLogicalDisk( hPart, &llVolID );
	CloseHandle(hPart);

	if( bResult )
	{
		//AfxMessageBox( IDS_MSG_FTPART, MB_ICONINFORMATION );
		if( cDriveLetter != _T('\0') )
		{
			#ifdef UNICODE
				cDriveLetter = (WCHAR)(towupper( cDriveLetter ));
			#else
				cDriveLetter = (char)(toupper( cDriveLetter ));
			#endif

            FtSetStickyDriveLetter( llVolID, (UCHAR) cDriveLetter );
		}
		if( pllVolID )
			*pllVolID = llVolID;
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTPART );

	return bResult; 

	MY_CATCH_AND_THROW
}

/*
Global function:	FTRegen

Purpose:			Replace a member of a logical volume with another logical volume and start the
					regeneration process.
					
Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						ID of the logical volume whose member is to be replaced
					[IN] WORD wMember
						Zero-based index of the member to be replced
					[IN] FT_LOGICAL_DISK_ID llReplVolID
						ID of the replacement
					[OUT] FT_LOGICAL_DISK_ID* pllVolID 
						Address where the logical volume ID of the new set is to be stored
						If NULL then don't return the ID

Return value:		TRUE if the stripe set is created successfully
*/

BOOL FTRegen( FT_LOGICAL_DISK_ID llVolID, WORD wMember, FT_LOGICAL_DISK_ID llReplVolID, 
					FT_LOGICAL_DISK_ID* pllVolID /* =NULL */ )
{
	MY_TRY
	
	CWaitCursor								wc;
	BOOL									bResult;
	FT_LOGICAL_DISK_ID						llNewVolID;

	DisplayStatusBarMessage( IDS_STATUS_FTREGEN );

	bResult = FtReplaceLogicalDiskMember( llVolID, wMember, llReplVolID, &llNewVolID );

	if( bResult )
	{
		//AfxMessageBox( IDS_MSG_FTREGEN, MB_ICONINFORMATION );
		if( pllVolID )
			*pllVolID = llNewVolID;
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTREGEN );
	
	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTStripe

Purpose:			Create a stripe set based on the given logical volumes
					
Parameters:			[IN] FT_LOGICAL_DISK_ID* arrVolID
						ID's of the members
					[IN] WORD wNumVols
						The number of members
					[IN] LONGLONG llStripeSize
						The size of the stripe chunks
					[OUT] FT_LOGICAL_DISK_ID* pllVolID 
						Address where the logical volume ID of the new stripe set is to be stored
						If NULL then don't return the ID

Return value:		TRUE if the stripe set is created successfully
*/

BOOL FTStripe( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, ULONG ulStripeSize, FT_LOGICAL_DISK_ID* pllVolID /* = NULL */) 
{
	MY_TRY

	ASSERT( arrVolID );
	ASSERT( wNumVols >= 2 );

	CWaitCursor								wc;
	BOOL									bResult;
	FT_STRIPE_SET_CONFIGURATION_INFORMATION	configInfo;
	FT_LOGICAL_DISK_ID						llNewVolID;

	DisplayStatusBarMessage( IDS_STATUS_FTSTRIPE );

	configInfo.StripeSize = ulStripeSize;
	bResult = FtCreateLogicalDisk( FtStripeSet, wNumVols, arrVolID, sizeof(configInfo),
									&configInfo, &llNewVolID );

	if( bResult )
	{
		//AfxMessageBox( IDS_MSG_FTSTRIPE, MB_ICONINFORMATION );
		if( pllVolID )
			*pllVolID = llNewVolID;
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTSTRIPE );

	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTSWP

Purpose:			Create a stripe set with parity based on the given logical volumes
					
Parameters:			[IN] FT_LOGICAL_DISK_ID* arrVolID
						ID's of the members
					[IN] WORD wNumVols
						The number of members
					[IN] LONGLONG llStripeSize
						The size of the stripe chunks
					[OUT] FT_LOGICAL_DISK_ID* pllVolID 
						Address where the logical volume ID of the new stripe set with parity is to be stored
						If NULL then don't return the ID

Return value:		TRUE if the stripe set with parity is created successfully
*/

BOOL FTSWP( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, ULONG ulStripeSize, FT_LOGICAL_DISK_ID* pllVolID /* = NULL */ )
{
	MY_TRY
	
	ASSERT( arrVolID );
	ASSERT( wNumVols >= 3 );

	CWaitCursor								wc;
	BOOL									bResult;
	FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION	configInfo;
	FT_LOGICAL_DISK_ID						llNewVolID;
	LONGLONG								llMemberSize;

	DisplayStatusBarMessage( IDS_STATUS_FTSWP );

	configInfo.MemberSize = MAXLONGLONG;
	for( int i=0; i < wNumVols; i++ )
	{
		bResult = FtQueryLogicalDiskInformation( arrVolID[i], NULL, &llMemberSize, 0,
													NULL, NULL, 0, NULL, 0, NULL );

		if( !bResult )
		{
			DisplaySystemErrorMessage(IDS_ERR_RETRIEVING_VOL_INFO);
			return FALSE;
		}

		if( llMemberSize < configInfo.MemberSize )
			configInfo.MemberSize = llMemberSize;
	}

	configInfo.StripeSize = ulStripeSize;

	bResult = FtCreateLogicalDisk( FtStripeSetWithParity, wNumVols, arrVolID, sizeof( configInfo),
										&configInfo, &llNewVolID );

	if( bResult )
	{
		//AfxMessageBox(IDS_MSG_FTSWP, MB_ICONINFORMATION);
		if( pllVolID )
			*pllVolID = llNewVolID;
	}
	else
		DisplaySystemErrorMessage(IDS_ERR_FTSWP);

	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTVolSet

Purpose:			Create a volume set based on the given logical volumes
					
Parameters:			[IN] FT_LOGICAL_DISK_ID* arrVolID
						ID's of the members
					[IN] WORD wNumVols
						The number of members
					[OUT] FT_LOGICAL_DISK_ID* pllVolID 
						Address where the logical volume ID of the new volume set is to be stored
						If NULL then don't return the ID

Return value:		TRUE if the volume set is created successfully
*/

BOOL FTVolSet( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, FT_LOGICAL_DISK_ID* pllVolID /* = NULL */)
{
	MY_TRY

	ASSERT( arrVolID );
	ASSERT( wNumVols >= 2 );

	CWaitCursor								wc;
	BOOL									bResult;
	FT_LOGICAL_DISK_ID						llNewVolID;

	DisplayStatusBarMessage( IDS_STATUS_FTVOLSET );

	bResult = FtCreateLogicalDisk( FtVolumeSet, wNumVols, arrVolID, 0,
									NULL, &llNewVolID );

	if( bResult )
	{
		//AfxMessageBox( IDS_MSG_FTVOLSET, MB_ICONINFORMATION );
		if( pllVolID )
			*pllVolID = llNewVolID;
	}
	else
		DisplaySystemErrorMessage( IDS_ERR_FTVOLSET );
	
	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;

	MY_CATCH_AND_THROW
}

BOOL  FTQueryNTDeviceName( FT_LOGICAL_DISK_ID llVolID, CString& strNTName )
{
	MY_TRY
	
	CWaitCursor											wc;
	HANDLE												h;
    FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT		Input;
	ULONG												ulOutputSize;
    PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT	pOutput;
    BOOL												b;
    ULONG												ulBytes;

    h = CreateFile(_T("\\\\.\\FtControl"), GENERIC_READ, 
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);    
	if (h == INVALID_HANDLE_VALUE) 
		return FALSE; 
	
	Input.RootLogicalDiskId = llVolID;
    ulOutputSize = MAX_PATH;
    pOutput = (PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT)LocalAlloc(0, ulOutputSize);    
	if (!pOutput) 
	{        
		CloseHandle(h);
        return FALSE;   
	}

    b = DeviceIoControl(h, FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK, &Input,
                        sizeof(Input), pOutput, ulOutputSize, &ulBytes, NULL);
	CloseHandle(h);        

    if (!b )
	{        
		LocalFree(pOutput);
        return FALSE;    
	}
	
	CopyW2Str( strNTName, pOutput->NtDeviceName, pOutput->NumberOfCharactersInNtDeviceName );
	
	LocalFree(pOutput);
    return TRUE;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTGetDisksSet

Purpose:			Retrieves all disks the logical volume is located on

Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						The ID of the logical volume
					[OUT] CULONGSet& setDisks
						The set of disks

Return value:		TRUE	if the functions succeeds
*/

BOOL FTGetDisksSet( FT_LOGICAL_DISK_ID llVolID, CULONGSet& setDisks )
{
	MY_TRY
	
	CWaitCursor								wc;
	FT_LOGICAL_DISK_TYPE					nVolType;
	LONGLONG								llVolSize;
	WORD									numMembers;
	FT_LOGICAL_DISK_ID						members[100];
	CHAR									stateInfo[100];
	CHAR									configInfo[100];
	
	setDisks.RemoveAll();
	
	// Read all information related to this logical volume
	BOOL b = FtQueryLogicalDiskInformation (	llVolID,
												&nVolType,
												&llVolSize,
												100,
												members,
												&numMembers,
												sizeof(configInfo),
												&configInfo,
												sizeof(stateInfo),
												&stateInfo );
	if(!b)
		return FALSE;

	if( nVolType == FtPartition )
	{
		setDisks.Add( ((PFT_PARTITION_CONFIGURATION_INFORMATION)configInfo)->DiskNumber );
		return TRUE;
	}

	// The disks set is the reunion of all members disk sets
	for( WORD i = 0; i < numMembers; i++ )
	{
		CULONGSet	setMemberDisks;
		if( !FTGetDisksSet( members[i], setMemberDisks ) )
			return FALSE;
		setDisks += setMemberDisks;
	}

	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Global function:	FTQueryVolumeName

Purpose:			Retrieve the volume name of a logical volume
					The volume name should be like this: "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"


Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						The ID of the logical volume
					[OUT] CString& strVolumeName
						Reference to a string to receive the volume name

Return value:		TRUE	if the functions succeeds
*/

BOOL FTQueryVolumeName( FT_LOGICAL_DISK_ID llVolID, CString& strVolumeName )
{
	MY_TRY

	CWaitCursor		wc;
	CString			strNTName;

	if (!FTQueryNTDeviceName( llVolID, strNTName ) )
		return FALSE;
	
	TCHAR cDriveLetter;
	return QueryDriveLetterAndVolumeName( strNTName, cDriveLetter, strVolumeName );	

	MY_CATCH_AND_THROW
}

/*
Global function:	FTDelete

Purpose:			Delete a logical volume by deleting all its physical partitions


Parameters:			[IN] FT_LOGICAL_DISK_ID llVolID
						The ID of the logical volume
					
Return value:		TRUE	if all its physical partitions were deleted
*/

BOOL FTDelete( FT_LOGICAL_DISK_ID llVolID )
{
	MY_TRY
	
	CWaitCursor								wc;
	FT_LOGICAL_DISK_TYPE					nVolType;
	LONGLONG								llVolSize;
	WORD									numMembers;
	FT_LOGICAL_DISK_ID						members[100];
	CHAR									stateInfo[100];
	CHAR									configInfo[100];
	
	// Read all information related to this logical volume
	BOOL b = FtQueryLogicalDiskInformation (	llVolID,
												&nVolType,
												&llVolSize,
												100,
												members,
												&numMembers,
												sizeof(configInfo),
												&configInfo,
												sizeof(stateInfo),
												&stateInfo );
	if(!b)
	{
		::DisplaySystemErrorMessage( IDS_ERR_RETRIEVING_VOL_INFO );
		return FALSE;
	}

	if( nVolType == FtPartition )
	{
		CDiskMap diskMap( ((PFT_PARTITION_CONFIGURATION_INFORMATION)configInfo)->DiskNumber );
		return diskMap.DeletePartition( ((PFT_PARTITION_CONFIGURATION_INFORMATION)configInfo)->ByteOffset );
	}
	
	// Delete all members
	BOOL bResult = TRUE;
	for( WORD i = 0; i < numMembers; i++ )
		bResult = FTDelete( members[i] ) && bResult;
	
	return bResult;

	MY_CATCH_AND_THROW
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\fttreevw.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTTreeVw.h

Abstract:

    The definition of class CFTTreeView. It is a tree view displaying:
	- all logical volumes
	- all physical partitions that are not logical volumes 
	existing in the system

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FTTREEVW_H__B83E0005_6873_11D2_A297_00A0C9063765__INCLUDED_)
#define AFX_FTTREEVW_H__B83E0005_6873_11D2_A297_00A0C9063765__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "FTManDef.h"

class CFTDocument;
class CItemData;

class CFTTreeView : public CTreeView
{
protected: // create from serialization only
	CFTTreeView();
	DECLARE_DYNCREATE(CFTTreeView)

// Attributes
public:
	CFTDocument* GetDocument();

// Operations
public:
	// Get the current snapshot of the tree ( what items are expanded, what items are selected )
	void GetSnapshot( TREE_SNAPSHOT& snaphshot );
	// Refresh the content of the tree given a certain snapshot ( items expanded, items selected )
	BOOL Refresh( TREE_SNAPSHOT& snapshot);
	// Refresh the content of the tree based on the current snapshot ( items expanded, items selected )
	BOOL Refresh();
	// Performs some minor refreshment for the tree items. This should be called every TIMER_ELAPSE milliseconds.
	void RefreshOnTimer();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFTTreeView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFTTreeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	
	// Insert item 
	HTREEITEM InsertItem(CItemData* pData, HTREEITEM hParent, HTREEITEM hInsertAfter );

	// Refresh item ( redisplay the item according with the information contained by its lParam which is a CItemData* )
	BOOL RefreshItem( HTREEITEM hItem );
	
	// Query for the members of an item and add them to the tree
	BOOL AddItemMembers(HTREEITEM hItem);
	// Delete a subtree ( with or wihout its root )
	BOOL DeleteItemSubtree(HTREEITEM hItem, BOOL bDeleteSubtreeRoot=TRUE);
	// Delete all items of the tree
	BOOL DeleteAllItems();
	// Add the subtree current status ( items expanded and selected ) to the tree current status
	void AddSubtreeSnapshot( HTREEITEM hSubtreeRoot, TREE_SNAPSHOT& snapshot );

	// Expand and select items in a subtree given a pattern
	BOOL RefreshSubtree( HTREEITEM hSubtreeRoot, TREE_SNAPSHOT& snapshot );

	// Scan a subtree for:
	// 1. Initializing stripe sets with parity that are not initializing anymore
	// 2. Regenerating mirror sets or stripe sets with parity that are not regenerating anymore
	// 3. Root volumes whose drive letter and volume name were eventually found
	void ScanSubtreeOnTimer( HTREEITEM hSubtreeRoot, CObArray& arrRefreshedItems, CWordArray& arrRefreshFlags);

	// Get all selected items in the given array ( array of CItemData ). Usually is only one item selected in a tree ctrl
	void GetSelectedItems( CObArray& arrSelectedItems );

protected:
	// The popup menu that appears when the user clicks the mouse right button is the first popup
	// of the following menu
	CMenu	m_menuPopup;

// Generated message map functions
protected:
	//{{AFX_MSG(CFTTreeView)
	afx_msg void OnDestroy();
	afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemExpand();
	afx_msg void OnRclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnViewUp();
	afx_msg void OnUpdateViewUp(CCmdUI* pCmdUI);
	afx_msg void OnActionAssign();
	afx_msg void OnUpdateActionAssign(CCmdUI* pCmdUI);
	afx_msg void OnActionFtbreak();
	afx_msg void OnUpdateActionFtbreak(CCmdUI* pCmdUI);
	afx_msg void OnActionCreateExtendedPartition();
	afx_msg void OnUpdateActionCreateExtendedPartition(CCmdUI* pCmdUI);
	afx_msg void OnActionCreatePartition();
	afx_msg void OnUpdateActionCreatePartition(CCmdUI* pCmdUI);
	afx_msg void OnActionDelete();
	afx_msg void OnUpdateActionDelete(CCmdUI* pCmdUI);
    afx_msg void OnActionFtinit();
	afx_msg void OnUpdateActionFtinit(CCmdUI* pCmdUI);
	afx_msg void OnActionFtswap();
	afx_msg void OnUpdateActionFtswap(CCmdUI* pCmdUI);
	//}}AFX_MSG
	// Status bar indicators handlers
	afx_msg void OnUpdateIndicatorName(CCmdUI* pCmdUI);
	afx_msg void OnUpdateIndicatorType(CCmdUI* pCmdUI);
	afx_msg void OnUpdateIndicatorDisks(CCmdUI* pCmdUI);
	afx_msg void OnUpdateIndicatorSize(CCmdUI* pCmdUI);
	afx_msg void OnUpdateIndicatorNothing(CCmdUI* pCmdUI);
	DECLARE_MESSAGE_MAP()

// MainFrame must have access to method OnCmdMsg which is still protected in MFC 4.2
friend class CMainFrame;

// Retrieves the set of disks whose volumes cannot be used as replacements for a 
// certain volume in a logical volume set ( stripe, mirror, stripe with parity, volume set )
// The function uses the volume hierarchy of the ( left pane )tree view
friend void GetVolumeReplacementForbiddenDisksSet( CFTTreeView* pTreeView, CItemData* pVolumeData, 
															CULONGSet& setDisks );

};

#ifndef _DEBUG  // debug version in FTTreeVw.cpp
inline CFTDocument* CFTTreeView::GetDocument()
   { return (CFTDocument*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FTTREEVW_H__B83E0005_6873_11D2_A297_00A0C9063765__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\fttreevw.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTTreeVw.cpp

Abstract:

    Implementation of the CFTTreeView class. It is a tree view displaying:
	- all logical volumes
	- all physical partitions that are not logical volumes 
	existing in the system

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "Actions.h"
#include "FTDoc.h"
#include "FTListVw.h"
#include "FTTreeVw.h"
#include "Item.h"
#include "LogVol.h"
#include "MainFrm.h"
#include "PhPart.h"
#include "Resource.h"
#include "RootFree.h"
#include "RootVol.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFTTreeView

IMPLEMENT_DYNCREATE(CFTTreeView, CTreeView)

BEGIN_MESSAGE_MAP(CFTTreeView, CTreeView)
	//{{AFX_MSG_MAP(CFTTreeView)
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
	ON_COMMAND(ID_ITEM_EXPAND, OnItemExpand)
	ON_NOTIFY_REFLECT(NM_RCLICK, OnRclick)
	ON_COMMAND(ID_VIEW_UP, OnViewUp)
	ON_UPDATE_COMMAND_UI(ID_VIEW_UP, OnUpdateViewUp)
	ON_COMMAND(ID_ACTION_ASSIGN, OnActionAssign)
	ON_UPDATE_COMMAND_UI(ID_ACTION_ASSIGN, OnUpdateActionAssign)
	ON_COMMAND(ID_ACTION_FTBREAK, OnActionFtbreak)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTBREAK, OnUpdateActionFtbreak)
	ON_COMMAND(ID_ACTION_CREATE_EXTENDED_PARTITION, OnActionCreateExtendedPartition)
	ON_UPDATE_COMMAND_UI(ID_ACTION_CREATE_EXTENDED_PARTITION, OnUpdateActionCreateExtendedPartition)
	ON_COMMAND(ID_ACTION_CREATE_PARTITION, OnActionCreatePartition)
	ON_UPDATE_COMMAND_UI(ID_ACTION_CREATE_PARTITION, OnUpdateActionCreatePartition)
	ON_COMMAND(ID_ACTION_DELETE, OnActionDelete)
	ON_UPDATE_COMMAND_UI(ID_ACTION_DELETE, OnUpdateActionDelete)
    ON_COMMAND(ID_ACTION_FTINIT, OnActionFtinit)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTINIT, OnUpdateActionFtinit)
	ON_COMMAND(ID_ACTION_FTSWAP, OnActionFtswap)
	ON_UPDATE_COMMAND_UI(ID_ACTION_FTSWAP, OnUpdateActionFtswap)
	//}}AFX_MSG_MAP
	// Status bar indicators handlers
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_NAME, OnUpdateIndicatorName)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_TYPE, OnUpdateIndicatorType)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_DISKS, OnUpdateIndicatorDisks)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_SIZE, OnUpdateIndicatorSize)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_NOTHING, OnUpdateIndicatorNothing)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFTTreeView construction/destruction

CFTTreeView::CFTTreeView()
{
	// TODO: add construction code here

}

CFTTreeView::~CFTTreeView()
{
}

BOOL CFTTreeView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CFTTreeView drawing

void CFTTreeView::OnDraw(CDC* pDC)
{
	CFTDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}


void CFTTreeView::OnInitialUpdate()   
{
	MY_TRY
	
	CTreeView::OnInitialUpdate();

	// Set the "look and style" of the tree control
	GetTreeCtrl().ModifyStyle(0, TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS );

	// Create the image list associated with the tree control
	CImageList* pImageList = new CImageList();
	// The background color for mask is pink. All image's pixels of this color will take
	// the view's background color.
	if( pImageList->Create( IDB_IMAGELIST, 16, 15, RGB( 255, 0, 255 ) ) )
		GetTreeCtrl().SetImageList(pImageList, TVSIL_NORMAL);
	else
		AfxMessageBox( IDS_ERR_CREATE_IMAGELIST, MB_ICONSTOP );

	// Load the popup menu
	m_menuPopup.LoadMenu(IDM_POPUP);

	// TODO: You may populate your TreeView with items by directly accessing
	//  its tree control through a call to GetTreeCtrl().
	
	// I commented this because the first refresh is done on WM_ACTIVATEAPP ( see MainFrm.cpp )
	//Refresh();

	AfxEnableAutoRefresh(TRUE);

	MY_CATCH_AND_REPORT
}

/////////////////////////////////////////////////////////////////////////////
// CFTTreeView diagnostics

#ifdef _DEBUG
void CFTTreeView::AssertValid() const
{
	CTreeView::AssertValid();
}

void CFTTreeView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);
}

CFTDocument* CFTTreeView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CFTDocument)));
	return (CFTDocument*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Tree handling methods

HTREEITEM CFTTreeView::InsertItem( CItemData* pData, HTREEITEM hParent, HTREEITEM hInsertAfter )
{
	MY_TRY

	// Just in case
	if( pData == NULL )
		return NULL;

	if( hParent != NULL )
		ASSERT( pData->GetParentData() == (CItemData*)(GetTreeCtrl().GetItemData( hParent ) ) );
	else
		ASSERT( pData->GetParentData() == NULL );


	TV_INSERTSTRUCT tvstruct;

	tvstruct.hParent = hParent;
	tvstruct.hInsertAfter = hInsertAfter;
	tvstruct.item.iImage = tvstruct.item.iSelectedImage = pData->GetImageIndex();
	CString strDisplayName;
	pData->GetDisplayExtendedName(strDisplayName);
	tvstruct.item.pszText = (LPTSTR)(LPCTSTR)strDisplayName;
	tvstruct.item.cChildren = pData->GetMembersNumber()>0 ? 1 : 0 ;
	tvstruct.item.lParam  = (LPARAM)pData;
	tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM;

	// Insert the item
	HTREEITEM hItem = GetTreeCtrl().InsertItem(&tvstruct);

	// Update the m_hTreeItem member of pData
	pData->SetTreeItem(hItem);

	// If the item reports at least one member then a dummy child must be created so it
	// can be expanded later
	if( pData->GetMembersNumber() > 0 )
	{
		tvstruct.hParent = hItem;
		tvstruct.hInsertAfter = TVI_LAST;
		tvstruct.item.iImage = 0;
		tvstruct.item.iSelectedImage = 0;
		tvstruct.item.pszText = _T("Dummy");
		tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
		GetTreeCtrl().InsertItem(&tvstruct);
	}
	return hItem;

	MY_CATCH_REPORT_AND_RETURN_NULL
}

//Redisplay the name and the image of the item
BOOL CFTTreeView::RefreshItem( HTREEITEM hItem )
{
	MY_TRY

	TVITEM tvitem;

	tvitem.hItem = hItem;
	tvitem.mask = TVIF_PARAM;

	if( !GetTreeCtrl().GetItem( &tvitem ) )
		return FALSE;

	CItemData* pData = (CItemData*)(tvitem.lParam);

	CString strDisplayName;
	pData->GetDisplayExtendedName(strDisplayName);
	tvitem.pszText = (LPTSTR)(LPCTSTR)strDisplayName;
	tvitem.iImage = tvitem.iSelectedImage = pData->GetImageIndex();
	tvitem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE ;

	return GetTreeCtrl().SetItem( &tvitem );	

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

BOOL CFTTreeView::AddItemMembers(HTREEITEM hItem)
{
	MY_TRY

	CAutoRefresh	ar(FALSE);
	
	if( !hItem ) 
		return TRUE;
	
	CWaitCursor wc;

	// Get the data associated with the item
	TVITEM tvItem;
	tvItem.hItem = hItem;
	tvItem.stateMask = TVIS_SELECTED; 
	tvItem.mask = TVIF_PARAM | TVIF_STATE ;

	if( !GetTreeCtrl().GetItem(&tvItem) )
		return FALSE;

	CItemData* pData = (CItemData*)tvItem.lParam;
	ASSERT(pData);

	// If the members are already inserted then return
	if( pData->AreMembersInserted() )
		return TRUE;

	// Delete old subtree but let the root alive
	if( !DeleteItemSubtree(hItem, FALSE ) )
		return FALSE;
	
	// Get the members of this item
	CObArray arrMembers;
	CString strErrors;
	pData->ReadMembers(arrMembers, strErrors);
	if( !strErrors.IsEmpty() )
	{
		AfxMessageBox( strErrors, MB_ICONSTOP );
		wc.Restore();
	}
	
	// Add new items to the tree
	for( int i=0, nInsertedMembers = 0; i<arrMembers.GetSize(); i++ )
	{
		CItemData* pMemberData = (CItemData*)(arrMembers[i]);
		ASSERT(pMemberData);
		if( InsertItem(pMemberData, hItem, TVI_LAST ) )
			nInsertedMembers++;
		else
		{
			// Item data was not inserted in the tree so it must be deleted here
			delete pMemberData;		
		}
	}
	arrMembers.RemoveAll();

	// Now the item has its members inserted in the tree
	pData->SetAreMembersInserted(TRUE);

	ASSERT( tvItem.hItem = hItem );
	tvItem.cChildren = nInsertedMembers;
	tvItem.mask = TVIF_CHILDREN ;
	GetTreeCtrl().SetItem(&tvItem);

	// If the item is selected synchronize the list view with the new list of members 
	if( tvItem.state & TVIS_SELECTED )
	{
		CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, GetParentFrame() );
		CFTListView* pListView = pFrame->GetRightPane();
		if(pListView)
			pListView->SynchronizeMembersWithTree(pData);
	}

	return TRUE;

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

BOOL CFTTreeView::DeleteItemSubtree(HTREEITEM hItem, BOOL bDeleteSubtreeRoot /*=TRUE*/)
{
	if( !hItem )
		return TRUE;
	
	// Remove all members
	HTREEITEM hChild = GetTreeCtrl().GetChildItem(hItem);
	while( hChild != NULL )
	{
		HTREEITEM hTemp = GetTreeCtrl().GetNextSiblingItem(hChild);
		DeleteItemSubtree(hChild);
		hChild = hTemp;
	}
	
	TVITEM tvItem;
	tvItem.hItem = hItem;
	tvItem.mask = TVIF_PARAM;

	if( GetTreeCtrl().GetItem(&tvItem) )
	{
		CItemData* pItemData = (CItemData*)tvItem.lParam;
		if( bDeleteSubtreeRoot )
		{
			if( pItemData )
				delete pItemData;
			
			return GetTreeCtrl().DeleteItem(hItem);
		}
		else
		{
			// The members of this item are no more in the tree
			if( pItemData )
				pItemData->SetAreMembersInserted(FALSE);
			return TRUE;
		}					
	}
	
	return FALSE;

}

BOOL CFTTreeView::DeleteAllItems()
{
	BOOL bResult = TRUE;

	GetTreeCtrl().SelectItem(NULL);
	
	HTREEITEM hItem = GetTreeCtrl().GetRootItem();
	while( hItem )
	{
		HTREEITEM hTemp = GetTreeCtrl().GetNextSiblingItem( hItem );
		bResult = DeleteItemSubtree(hItem) && bResult;
		hItem = hTemp;
	}
	return bResult;
}

// Adds the snapshot of a subtree ( expanded items, selected items ) to the given snapshot
void CFTTreeView::AddSubtreeSnapshot( HTREEITEM hSubtreeRoot, TREE_SNAPSHOT& snapshot )
{
	MY_TRY

	if( hSubtreeRoot == NULL )
		return;

	UINT unItemState = GetTreeCtrl().GetItemState( hSubtreeRoot, TVIS_EXPANDED | TVIS_SELECTED );

	if( !unItemState )
		return;

	CItemData* pData = (CItemData*)(GetTreeCtrl().GetItemData(hSubtreeRoot));
	ASSERT(pData);

	CItemID		idItem( *pData );
	
	if( unItemState & TVIS_EXPANDED )
		snapshot.setExpandedItems.Add(idItem);

	if( unItemState & TVIS_SELECTED )
		snapshot.setSelectedItems.Add(idItem);

	HTREEITEM hChildItem = GetTreeCtrl().GetChildItem(hSubtreeRoot);
	while( hChildItem != NULL )
	{
		AddSubtreeSnapshot( hChildItem, snapshot );
		hChildItem = GetTreeCtrl().GetNextSiblingItem(hChildItem);
	}

	MY_CATCH_AND_REPORT
}

// Get the snapshot of the tree ( expanded items, selected items )
void CFTTreeView::GetSnapshot( TREE_SNAPSHOT& snapshot )
{
	MY_TRY

	CWaitCursor wc;
	snapshot.setExpandedItems.RemoveAll();
	snapshot.setSelectedItems.RemoveAll();
	
	HTREEITEM hItem = GetTreeCtrl().GetRootItem();
	while( hItem )
	{
		AddSubtreeSnapshot( hItem, snapshot );
		hItem = GetTreeCtrl().GetNextSiblingItem( hItem );
	}

	MY_CATCH_AND_REPORT
}

// Refresh the content of a subtree according with a certain snapshot ( expanded items, selected items )
BOOL CFTTreeView::RefreshSubtree( HTREEITEM hSubtreeRoot, TREE_SNAPSHOT& snapshot )
{
	MY_TRY
	
	BOOL	bResult = TRUE;
	
	CItemData* pData = (CItemData*)(GetTreeCtrl().GetItemData( hSubtreeRoot));
	ASSERT(pData);
	
	CItemID	idItem( *pData );
	
	if( snapshot.setExpandedItems.InSet( idItem ) )
	{
		GetTreeCtrl().Expand( hSubtreeRoot, TVE_EXPAND );

		HTREEITEM hChildItem =GetTreeCtrl().GetChildItem(hSubtreeRoot);
		while( hChildItem != NULL )
		{
			bResult = RefreshSubtree( hChildItem, snapshot );
			hChildItem = GetTreeCtrl().GetNextSiblingItem(hChildItem);
		}
	}
	
	if( snapshot.setSelectedItems.InSet( idItem ) )
		GetTreeCtrl().SelectItem( hSubtreeRoot );

	return bResult;

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

// Refresh the content of the tree view according to a certain snapshot ( expanded items, selected items )
BOOL CFTTreeView::Refresh( TREE_SNAPSHOT& snapshot)
{
	MY_TRY

	CAutoRefresh	ar(FALSE);
	
	LockWindowUpdate();

	DeleteAllItems();

	// 1. Add the volumes root item and expand it is necessary
	
	// Create a volumes root item ...
	CRootVolumesData* pRootVolData = new CRootVolumesData;

	// Read its data ...
	CString strErrors;
	pRootVolData->ReadItemInfo(strErrors);
	if( !strErrors.IsEmpty() )
		AfxMessageBox( strErrors, MB_ICONSTOP );
	
	// Add it to the tree
	HTREEITEM hRoot = InsertItem( pRootVolData, NULL, TVI_FIRST );
	if( !hRoot )
	{
		delete pRootVolData;
		UnlockWindowUpdate();
		return FALSE;
	}
	
	// Refresh its subtree
	BOOL bResult = RefreshSubtree( hRoot, snapshot );

	// 2. Add the free spaces root item and expand it if necessary
	
	// Create a free spaces root item ...
	CRootFreeSpacesData* pRootFreeData = new CRootFreeSpacesData;

	// Read its data ...
	pRootFreeData->ReadItemInfo(strErrors);
	if( !strErrors.IsEmpty() )
		AfxMessageBox( strErrors, MB_ICONSTOP );
	
	// Add it to the tree
	hRoot = InsertItem( pRootFreeData, NULL, TVI_LAST );
	if( !hRoot )
	{
		DeleteAllItems();
		delete pRootFreeData;
		UnlockWindowUpdate();
		return FALSE;
	}
	
	// Refresh its subtree
	bResult = RefreshSubtree( hRoot, snapshot ) && bResult;

	UnlockWindowUpdate();
	return bResult;

	MY_CATCH_REPORT_AND_RETURN_FALSE
}

// Refresh the content of the tree view.
BOOL CFTTreeView::Refresh()
{
	CWaitCursor		wc;
	CAutoRefresh	ar(FALSE);

	TREE_SNAPSHOT snapshot;
	GetSnapshot(snapshot);
	return Refresh(snapshot);
}

// Performs some minor refreshment for the tree items. This should be called every TIMER_ELAPSE milliseconds. 
void CFTTreeView::RefreshOnTimer()
{
	MY_TRY

	CAutoRefresh( FALSE );			

	HTREEITEM hRootItem = GetTreeCtrl().GetRootItem();
	if( hRootItem == NULL )
		return;

	CObArray arrRefreshedItems; 
	CWordArray arrRefreshFlags;

	ScanSubtreeOnTimer( hRootItem, arrRefreshedItems, arrRefreshFlags);
	
	if( arrRefreshedItems.GetSize() > 0 )
	{
		CWaitCursor wc;
		DisplayStatusBarMessage( IDS_STATUS_REFRESH );

		TRACE(_T("OnTimerRefresh: Some items under surveillance need some refreshment\n"));
		
		CObArray arrMount;
		for( int i = 0; i < arrRefreshedItems.GetSize(); i++ )
		{
			if( arrRefreshFlags[i] & ROTT_GotDriveLetterAndVolumeName )
				arrMount.Add( arrRefreshedItems[i] );
		}
		if( arrMount.GetSize() > 0 )
			QueryMountList( arrMount );

		HTREEITEM hSelectedItem = GetTreeCtrl().GetSelectedItem();
		
		CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, GetParentFrame() );
		CFTListView* pListView = pFrame->GetRightPane();
	
		for( i = 0; i < arrRefreshedItems.GetSize(); i++ )
		{
			// Refresh every item in this array
			CItemData* pData = (CItemData*)(arrRefreshedItems[i]);
			pData->SetImageIndex( pData->ComputeImageIndex() );

			RefreshItem( pData->GetTreeItem() );

			// If the item is also displayed in the list view ( equivalent with its parent being selected in
			// the tree view ) then refresh it there too
			if( ( pData->GetParentData() ) &&
				( pData->GetParentData()->GetTreeItem() == hSelectedItem )  && 
				pListView )
				pListView->RefreshItem( pData->GetListItem() );
		}

		DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	}

	MY_CATCH_AND_REPORT
}

// Scans a subtree for:
// 1. Initializing stripe sets with parity that are not initializing anymore
// 2. Regenerating mirror sets or stripe sets with parity that are not regenerating anymore
// 3. Root volumes whose drive letter and volume name were eventually found
void CFTTreeView::ScanSubtreeOnTimer( HTREEITEM hSubtreeRoot, CObArray& arrRefreshedItems, CWordArray& arrRefreshFlags)
{
	MY_TRY

	ASSERT( hSubtreeRoot );

	CItemData* pData = (CItemData*)(GetTreeCtrl().GetItemData( hSubtreeRoot ) );
	ASSERT( pData );
	ASSERT( pData->GetTreeItem() == hSubtreeRoot );
		
	WORD wRefreshFlags = 0;

	// Check if the drive letter and volume name are OK
	if( pData->IsRootVolume() && pData->GetVolumeName().IsEmpty() )
	{
		if( pData->ReadDriveLetterAndVolumeName() )
		{
			pData->SetValid(TRUE);
			wRefreshFlags |= ROTT_GotDriveLetterAndVolumeName;
		}	
	}

	// Check for mirror sets and stripe sets with parity who just ended the regeneration of a member
	// Check also for stripe sets with parity who just ended their initialization
	if( pData->IsValid() && ( pData->GetItemType() == IT_LogicalVolume ) )
	{
		CLogicalVolumeData* pLogVolData = ( CLogicalVolumeData*)pData;
		
		if(	( pLogVolData->m_nVolType == FtMirrorSet ) ||
			( pLogVolData->m_nVolType == FtStripeSetWithParity ) ) 
		{
			if( pLogVolData->m_StateInfo.stripeState.UnhealthyMemberState == FtMemberRegenerating )
			{
				CString strErrors;
				if( pLogVolData->ReadFTInfo( strErrors ) &&
					pLogVolData->m_StateInfo.stripeState.UnhealthyMemberState != FtMemberRegenerating )
					wRefreshFlags |= ROTT_EndRegeneration;
			}
		}
		
		if( pLogVolData->m_nVolType == FtStripeSetWithParity )
		{
			if( pLogVolData->m_StateInfo.stripeState.IsInitializing )
			{
				CString strErrors;
				if( pLogVolData->ReadFTInfo( strErrors ) && 
					!pLogVolData->m_StateInfo.stripeState.IsInitializing )
					wRefreshFlags |= ROTT_EndInitialization;
			}
		}
	}

	if( wRefreshFlags )
	{
		arrRefreshedItems.Add(pData);
		arrRefreshFlags.Add(wRefreshFlags);
	}
		
	// Now check the item's subtree
	
	if( !pData->AreMembersInserted() )
		return;
	
	HTREEITEM hChildItem = GetTreeCtrl().GetChildItem(hSubtreeRoot);
	USHORT unMember = 0;
	while( hChildItem != NULL )
	{
		if( wRefreshFlags & ( ROTT_EndRegeneration | ROTT_EndInitialization ) )
		{
			// Add all children to the refresh list
			CItemData* pChildData = (CItemData*)(GetTreeCtrl().GetItemData( hChildItem ) );
			ASSERT( pData );

			if( unMember == ((CLogicalVolumeData*)pData)->m_StateInfo.stripeState.UnhealthyMemberNumber )
				pChildData->SetMemberStatus( ((CLogicalVolumeData*)pData)->m_StateInfo.stripeState.UnhealthyMemberState );
			else
				pChildData->SetMemberStatus( FtMemberHealthy );
			arrRefreshedItems.Add( pChildData );
			arrRefreshFlags.Add( wRefreshFlags );			
		}
		ScanSubtreeOnTimer(hChildItem, arrRefreshedItems, arrRefreshFlags );
		hChildItem = GetTreeCtrl().GetNextSiblingItem(hChildItem);
		unMember++;
	}

	MY_CATCH
}

void CFTTreeView::GetSelectedItems( CObArray& arrSelectedItems )
{
	MY_TRY

	arrSelectedItems.RemoveAll();

	HTREEITEM hItem =  GetTreeCtrl().GetSelectedItem();

	if( hItem != NULL )
	{
		CItemData* pData = (CItemData*)( GetTreeCtrl().GetItemData(hItem) );
		ASSERT(pData);
		arrSelectedItems.Add(pData);
	}

	MY_CATCH_AND_REPORT
}


/////////////////////////////////////////////////////////////////////////////
// CFTTreeView message handlers

void CFTTreeView::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	*pResult = 0;

	HTREEITEM hItem = pNMTreeView->itemNew.hItem;
	ASSERT( hItem );

	CItemData* pData = (CItemData*)(pNMTreeView->itemNew.lParam);

	// When collapsing change the image for root items ( closed folder )
	if( pNMTreeView->action == TVE_COLLAPSE )
	{
		if( pData && 
			(	( pData->GetItemType() == IT_RootVolumes ) ||
				( pData->GetItemType() == IT_RootFreeSpaces ) ) )
		{
			pData->SetImageIndex( II_Root );
			GetTreeCtrl().SetItemImage( pNMTreeView->itemNew.hItem, II_Root, II_Root );
		}	
		return;
	}
	
	// We are handling only the expandation of the item
	if( pNMTreeView->action == TVE_EXPAND )
	{
	
		// When expanding change the image for root items ( open folder )
		if( pData && 
			(	( pData->GetItemType() == IT_RootVolumes ) ||
				( pData->GetItemType() == IT_RootFreeSpaces ) ) )
		{
			pData->SetImageIndex( II_RootExpanded );
			GetTreeCtrl().SetItemImage( pNMTreeView->itemNew.hItem, II_RootExpanded, II_RootExpanded );
		}	
	
		// Now it's time to prepare the item for expandation
	
		// Add all members of the item to the tree ( if they are already added to the tree AddItemMembers will return
		// without doing anything
		AddItemMembers(hItem);	
	}
}

void CFTTreeView::OnDestroy() 
{
	GetTreeCtrl().SelectItem( NULL );
	// Delete all items and destroy their associated data
	DeleteAllItems();
	
	// Delete the image list
	CImageList* pImageList = GetTreeCtrl().GetImageList(TVSIL_NORMAL);
	if( pImageList )
	{
		pImageList->DeleteImageList();
		delete pImageList;
	}

	// Destroy the popup menu
	m_menuPopup.DestroyMenu();

	CTreeView::OnDestroy();
	
	// TODO: Add your message handler code here
}


void CFTTreeView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	*pResult = 0;

	CItemData* pNewData = (CItemData*)(pNMTreeView->itemNew.lParam);
	
	// Add all members of the item to the tree ( if they are already added to the tree AddItemMembers will return
	// without doing anything
	if( pNewData )
		AddItemMembers( pNewData->GetTreeItem() );
	
	CMainFrame* pFrame = STATIC_DOWNCAST(CMainFrame, GetParentFrame() );
	CFTListView* pListView = pFrame->GetRightPane();
	if(pListView)
		pListView->SynchronizeMembersWithTree(pNewData);
}

void CFTTreeView::OnItemExpand() 
{
	// TODO: Add your command handler code here
	HTREEITEM hItem = GetTreeCtrl().GetSelectedItem( );
	if( !hItem)
		return;

	// Now reset the ExpandedOnce flag so the tree will receive OnItemExpanding notification
	TVITEM tvItem;
	tvItem.hItem = hItem;
	tvItem.state = 0;
	tvItem.stateMask = TVIS_EXPANDEDONCE; 
	tvItem.mask = TVIF_STATE;
	GetTreeCtrl().SetItem(&tvItem);

	// Now toggle the status of the item ( expanded / collapsed )
	GetTreeCtrl().Expand( hItem, TVE_TOGGLE ); 
}


void CFTTreeView::OnRclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	*pResult = 0;

	POINT pt;
	GetCursorPos( &pt );
	
	TVHITTESTINFO tvhittestinfo;
	tvhittestinfo.pt = pt;
	ScreenToClient( &(tvhittestinfo.pt) );

	GetTreeCtrl().HitTest( &tvhittestinfo );

	if( ( tvhittestinfo.hItem != NULL ) && ( tvhittestinfo.flags & TVHT_ONITEM ) )
	{
		GetTreeCtrl().SelectItem( tvhittestinfo.hItem );

		CMenu* pPopup = m_menuPopup.GetSubMenu(0);
		if( pPopup != NULL )
			pPopup->TrackPopupMenu( TPM_LEFTALIGN, pt.x, pt.y, AfxGetMainWnd(), NULL);		
	}
}

void CFTTreeView::OnViewUp() 
{
	HTREEITEM hItem = GetTreeCtrl().GetSelectedItem();
	ASSERT( hItem );
		
	HTREEITEM hParentItem = GetTreeCtrl().GetParentItem( hItem );
	ASSERT( hParentItem );

	GetTreeCtrl().SelectItem( hParentItem );
}

void CFTTreeView::OnUpdateViewUp(CCmdUI* pCmdUI) 
{
	HTREEITEM hItem = GetTreeCtrl().GetSelectedItem();
	if( hItem == NULL )
		goto label_disable;

	if( GetTreeCtrl().GetParentItem( hItem ) == NULL )
		goto label_disable;

	pCmdUI->Enable(TRUE);
	return;

label_disable:
	pCmdUI->Enable(FALSE);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//		FT Actions

void CFTTreeView::OnActionAssign() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionAssign( arrSelectedItems );	
}

void CFTTreeView::OnUpdateActionAssign(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionAssign( pCmdUI, arrSelectedItems );		
}

void CFTTreeView::OnActionFtbreak() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtbreak( arrSelectedItems );	
}

void CFTTreeView::OnUpdateActionFtbreak(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtbreak( pCmdUI, arrSelectedItems );		
}

void CFTTreeView::OnActionCreateExtendedPartition() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionCreateExtendedPartition( arrSelectedItems );	
}

void CFTTreeView::OnUpdateActionCreateExtendedPartition(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionCreateExtendedPartition( pCmdUI, arrSelectedItems );		
}

void CFTTreeView::OnActionCreatePartition() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionCreatePartition( arrSelectedItems );	
}

void CFTTreeView::OnUpdateActionCreatePartition(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionCreatePartition( pCmdUI, arrSelectedItems );		
}

void CFTTreeView::OnActionDelete() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionDelete( arrSelectedItems );	
}

void CFTTreeView::OnUpdateActionDelete(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionDelete( pCmdUI, arrSelectedItems );		
}

void CFTTreeView::OnActionFtinit() 
{	
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtinit( arrSelectedItems );		
}

void CFTTreeView::OnUpdateActionFtinit(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtinit( pCmdUI, arrSelectedItems );		
}

void CFTTreeView::OnActionFtswap() 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	ActionFtswap( arrSelectedItems );	
}

void CFTTreeView::OnUpdateActionFtswap(CCmdUI* pCmdUI) 
{
	CObArray arrSelectedItems;
	GetSelectedItems( arrSelectedItems );

	UpdateActionFtswap( pCmdUI, arrSelectedItems );		
}

void CFTTreeView::OnUpdateIndicatorName(CCmdUI* pCmdUI) 
{
	MY_TRY

	pCmdUI->Enable(TRUE);

	HTREEITEM hItem = GetTreeCtrl().GetSelectedItem();
	if( hItem == NULL )
	{
		pCmdUI->SetText( _T("") );
		return;
	}
	
	CItemData* pData = (CItemData*)(GetTreeCtrl().GetItemData(hItem));
	ASSERT( pData );

	CString str;
	pData->GetDisplayName( str );
	pCmdUI->SetText( str );

	MY_CATCH
}

void CFTTreeView::OnUpdateIndicatorType(CCmdUI* pCmdUI) 
{
	MY_TRY

	pCmdUI->Enable(TRUE);

	HTREEITEM hItem = GetTreeCtrl().GetSelectedItem();
	if( hItem == NULL )
	{
		pCmdUI->SetText( _T("") );
		return;
	}
	
	CItemData* pData = (CItemData*)(GetTreeCtrl().GetItemData(hItem));
	ASSERT( pData );

	CString str;
	pData->GetDisplayType( str );
	pCmdUI->SetText( str );

	MY_CATCH
}

void CFTTreeView::OnUpdateIndicatorDisks(CCmdUI* pCmdUI) 
{
	MY_TRY

	pCmdUI->Enable(TRUE);

	HTREEITEM hItem = GetTreeCtrl().GetSelectedItem();
	if( hItem == NULL )
	{
		pCmdUI->SetText( _T("") );
		return;
	}
	
	CItemData* pData = (CItemData*)(GetTreeCtrl().GetItemData(hItem));
	ASSERT( pData );

	CString str;
	pData->GetDisplayDisksSet( str );
	pCmdUI->SetText( str );

	MY_CATCH
}

void CFTTreeView::OnUpdateIndicatorSize(CCmdUI* pCmdUI) 
{
	MY_TRY

	pCmdUI->Enable(TRUE);

	HTREEITEM hItem = GetTreeCtrl().GetSelectedItem();
	if( hItem == NULL )
	{
		pCmdUI->SetText( _T("") );
		return;
	}
	
	CItemData* pData = (CItemData*)(GetTreeCtrl().GetItemData(hItem));
	ASSERT( pData );

	CString str;
	pData->GetDisplaySize( str );
	pCmdUI->SetText( str );

	MY_CATCH
}

void CFTTreeView::OnUpdateIndicatorNothing(CCmdUI* pCmdUI) 
{
	MY_TRY

	pCmdUI->Enable(TRUE);
	pCmdUI->SetText( _T("") );

	MY_CATCH
}


/////////////////////////////////////////////////////////////////////////////
// Friend methods

/*
Global function:	GetVolumeReplacementForbiddenDisksSet

Purpose:			Retrieves the set of disks whose volumes cannot be used as replacements for a 
					certain volume in a logical volume set ( stripe, mirror, stripe with parity, volume set )
					The function uses the volume hierarchy of the ( left pane )tree view

Parameters:			[IN] CFTTreeView* pTreeView
						Pointer to the tree view containing the volume hierarchy	
					[IN] CItemData* pVolumeData
						Pointer to the volume data
					[OUT] CULONSet& setDisks
						The forbidden disks set

Return value:		-    
*/

void GetVolumeReplacementForbiddenDisksSet( CFTTreeView* pTreeView, CItemData* pVolumeData, CULONGSet& setDisks )
{
	MY_TRY
	
	ASSERT( pTreeView );
	ASSERT( pVolumeData );
	
	setDisks.RemoveAll();

	HTREEITEM hVolumeItem = pVolumeData->GetTreeItem();
	ASSERT( hVolumeItem );
	
	HTREEITEM hParentItem = pTreeView->GetTreeCtrl().GetParentItem( hVolumeItem );
	// If our item has no parent then return an empty disks set
	if( hParentItem == NULL )
		return;

	CItemData* pParentData = (CItemData*)(pTreeView->GetTreeCtrl().GetItemData( hParentItem ));
	// hParentItem should be a valid item of the tree
	ASSERT( pParentData );

	// If the parent is not a logical volume return an empty disks set
	if( pParentData->GetItemType() != IT_LogicalVolume )
		return;

	// If the parent is a single FT partition return an empty disks set
	if(	((CLogicalVolumeData*)pParentData)->m_nVolType == FtPartition ) 
		return;

	// Now get the forbidden disks set of our item's parent
	GetVolumeReplacementForbiddenDisksSet( pTreeView, pParentData, setDisks );
	
	// Now add to the forbidden disks set the reunion of all our item's siblings disks sets
	// Attention:  Only when the parent is a stripe, mirror or stripe set with parity! Not for volume sets!!
	if(	( ((CLogicalVolumeData*)pParentData)->m_nVolType == FtStripeSet ) ||
		( ((CLogicalVolumeData*)pParentData)->m_nVolType == FtMirrorSet ) ||
		( ((CLogicalVolumeData*)pParentData)->m_nVolType == FtStripeSetWithParity ) )
	{
		HTREEITEM hSiblingItem =pTreeView->GetTreeCtrl().GetChildItem(hParentItem);
		while( hSiblingItem != NULL )
		{
			if( hSiblingItem != hVolumeItem )
			{
				CItemData* pSiblingData = (CItemData*)(pTreeView->GetTreeCtrl().GetItemData(hSiblingItem));
				ASSERT(pSiblingData);
				setDisks += pSiblingData->GetDisksSet();
			}
		
			hSiblingItem = pTreeView->GetTreeCtrl().GetNextSiblingItem(hSiblingItem);
		}
	}

	MY_CATCH_AND_THROW
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\ftutil.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	FTUtil.h

Abstract:

    Definition of FT utilities

Author:

    Cristian Teodorescu      October 29, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FTUTIL_H_INCLUDED_)
#define AFX_FTUTIL_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <FTTypes.h>

#include "FTManDef.h"

// Break a logical volume
BOOL FTBreak( FT_LOGICAL_DISK_ID llVolID );

// Check the IO status of a logical volume
BOOL FTChkIO( FT_LOGICAL_DISK_ID llVolID, BOOL* pbOK );

// Extend the file system of a volume to the maximum possible
BOOL FTExtend( FT_LOGICAL_DISK_ID llVolID );

// Initialize a logical volume with repairing ( or not ) the orphan member
BOOL FTInit( FT_LOGICAL_DISK_ID llVolID, BOOL bInitOrphans = TRUE );

// Create a mirror set
BOOL FTMirror( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, FT_LOGICAL_DISK_ID* pllVolID = NULL );

// Orphan a logical volume member
BOOL FTOrphan( FT_LOGICAL_DISK_ID llVolID, WORD wMember );

// Create a FT partition
BOOL FTPart( const CString& strVolumeName, TCHAR cDriveLetter=_T('\0'), FT_LOGICAL_DISK_ID* pllVolID = NULL );

// Replace a member of a logical volume with another logical volume and start the regeneration process.
BOOL FTRegen( FT_LOGICAL_DISK_ID llVolID, WORD wMember, FT_LOGICAL_DISK_ID llReplVolID, FT_LOGICAL_DISK_ID* pllVolID = NULL );

// Create a stripe set
BOOL FTStripe( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, ULONG ulStripeSize, FT_LOGICAL_DISK_ID* pllVolID = NULL );

// Create a stripe set with parity
BOOL FTSWP( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, ULONG ulStripeSize, FT_LOGICAL_DISK_ID* pllVolID = NULL );

// Create a volume set
BOOL FTVolSet( FT_LOGICAL_DISK_ID* arrVolID, WORD wNumVols, FT_LOGICAL_DISK_ID* pllVolID = NULL );

// Get the NT name of a logical volume
BOOL  FTQueryNTDeviceName( FT_LOGICAL_DISK_ID llVolID, CString& strNTName );

// Retrieve all disks the logical volume is located on
BOOL FTGetDisksSet( FT_LOGICAL_DISK_ID llVolID, CULONGSet& setDisks );

// Get the volume name of the logical volume
BOOL FTQueryVolumeName( FT_LOGICAL_DISK_ID llVolID, CString& strVolumeName );

// Delete a logical volume by deleting all its physical partitions
BOOL FTDelete( FT_LOGICAL_DISK_ID llVolID );

#endif // !defined(AFX_FTUTIL_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\global.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	Global.cpp

Abstract:

    Implementation of useful global functions

Author:

    Cristian Teodorescu      October 29, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "FTUtil.h"
#include "Global.h"
#include "Item.h"
#include "MainFrm.h"
#include "Resource.h"

#include <basetyps.h>
#include <mountmgr.h>
#include <winbase.h>
#include <winioctl.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////
// Display functions

/*
Global function:	DisplaySystemErrorMessage

Purpose:			Display the last system error message prefixed ( or not ) with another string taken from
					our resources explaining the context of the failure

Parameters:			[IN] UINT unContextMsgID
						The ID of the string that must prefix the system error message. ID in resource.h
						Default is 0 which means that the system error shouldn't be prefixed

Return value:		TRUE	if the functions succeeds
*/
BOOL DisplaySystemErrorMessage( UINT unContextMsgID /* =0 */)
{
	MY_TRY
	
	// Get the system error message
	LPVOID lpMsgBuf;
	if( !::FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
						NULL,
						GetLastError(),
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
						(LPTSTR) &lpMsgBuf,
						0,
						NULL ) ) // Process any inserts in lpMsgBuf.
		return FALSE;
	
	CString str;
	if( unContextMsgID != 0)  // The system error message must be prefixed with another string from the resources of this application
		if( !str.LoadString( unContextMsgID ) )  return FALSE;
	str += ((LPCTSTR)lpMsgBuf);
	LocalFree( lpMsgBuf );
	AfxMessageBox(str, MB_ICONSTOP);
	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Global function:	DisplayStatusBarMessage (1)

Purpose:			Displays a message in the first pane of the main frame status bar

Parameters:			[IN] LPCTSTR lpszMsg
						The message to display

Return value:		TRUE	if the functions succeeds
*/
BOOL DisplayStatusBarMessage( LPCTSTR lpszMsg )
{
	MY_TRY

	CStatusBar* pStatusBar = ((CMainFrame*)AfxGetMainWnd())->GetStatusBar();
	if( !pStatusBar )
		return FALSE;

	// Use the ID_SEPARATOR pane of the status bar
	return pStatusBar->SetPaneText( 5, lpszMsg );

	MY_CATCH_AND_THROW
}

/*
Global function:	DisplayStatusBarMessage (2)

Purpose:			Display a message in the first pane of the main frame status bar

Parameters:			[IN] UINT unMsgID
						Resource ID of the string to display

Return value:		TRUE	if the functions succeeds
*/
BOOL DisplayStatusBarMessage( UINT unMsgID )
{
	MY_TRY

	CString str;
	str.LoadString(unMsgID);
	return DisplayStatusBarMessage(str);

	MY_CATCH_AND_THROW
}

/*
Global function:	FormatVolumeSize

Purpose:			Format the size of a volume in a "readable" way
					( in GB, MB or KB depending on the size range )

Parameters:			[OUT] CString& strSize
						Reference to the string to receive the formatted size
					[IN] LONGLONG llSize
						The size to format  ( in Bytes )

Return value:		-
*/

void FormatVolumeSize( CString& strSize, LONGLONG llSize  )
{
	MY_TRY

	if( llSize >= 0x40000000 )  // 1GB = 2^30 B
		strSize.Format(_T("%.2f GB"),  ((double)(llSize>>20))/((double)0x400));
	else if (llSize >= 0x100000 )  // 1MB = 2^20 B
		strSize.Format(_T("%.2f MB"),  ((double)(llSize>>10))/((double)0x400));
	else
		strSize.Format(_T("%.2f KB"),  ((double)llSize)/((double)0x400));

	MY_CATCH_AND_THROW
}

/*
Global function:	CopyW2Str

Purpose:			Copy a Unicode character array into a CString

Parameters:			[OUT] CString& strDest
						Reference to the string to receive the formatted size
					[IN]  LPWSTR strSource
						Unicode character array to be copied
					[IN] ULONG ulLength
						The number of characters to copy

Return value:		-
*/

void CopyW2Str( CString& strDest, LPWSTR strSource, ULONG ulLength )
{
	MY_TRY

	LPTSTR lpstr = strDest.GetBuffer( ulLength + 1 );
#ifdef UNICODE
	memcpy( lpstr, strSource, ulLength * sizeof(WCHAR ) );
#else
	WideCharToMultiByte( CP_APP, 0, strSource, ulLength, lpstr, ulLength * sizeof(char), NULL, NULL );
#endif

	lpstr[ulLength]=_T('\0');
	strDest.ReleaseBuffer();

	MY_CATCH_AND_THROW
}

/*
Global function:	CopyStr2W

Purpose:			Copy a CString content into a Unicode character array

Parameters:			[OUT] LPWSTR strDest
						Pointer to the buffer to receive the character array. It should be already allocated
					[IN]  CString& strSource
						Reference to the string to be copied

Return value:		-
*/
void CopyStr2W( LPWSTR strDest, CString& strSource )
{
	MY_TRY

	LPTSTR lpstr = strSource.GetBuffer(0);
	int nSize = strSource.GetLength();

#ifdef UNICODE
	memcpy( strDest, lpstr, nSize * sizeof(WCHAR) );
#else
	MultiByteToWideChar(  CP_APP, 0, lpstr, nSize, strDest, nSize * sizeof(WCHAR) );
#endif

	strDest[nSize] = _T('\0');
	strSource.ReleaseBuffer();

	MY_CATCH_AND_THROW
}

/*
Global function:	OpenVolume

Purpose:			Open a volume given its name
					The name must be like this "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\"

Parameters:			[IN] CString& strVolumeName
						Volume name
					
Return value:		HANDLE	
						Handle of the open volume.  INVALID_HANDLE_VALUE if the operation failed
*/
HANDLE OpenVolume( const CString& strVolumeName )
{
	return CreateFile( strVolumeName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE );	
}

/*
Global function:	IsDOSName

Purpose:			Decides wether a name is a DOS name i.e. "\DosDevices\X:"

Parameters:			[IN] CString& str
						The name

Return value:		TRUE	if it is a DOS name
*/

BOOL IsDOSName( const CString& str )
{
	MY_TRY

	// "\DosDevices\X:"
	return( ( str.GetLength() == 14 ) &&
			( str.Left(12) == _T("\\DosDevices\\") ) &&
			( str[13] == _T(':') )  );

	MY_CATCH_AND_THROW
}

/*
Global function:	IsVolumeName

Purpose:			Decides wether a name is a volume name i.e. "\??\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"

Parameters:			[IN] CString& str
						The name

Return value:		TRUE	if it is a volume name
*/

BOOL IsVolumeName( const CString& str )
{
	MY_TRY

	// "\??\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
	return( ( str.GetLength() == 48 ) &&
			( str.Left(11) == _T("\\??\\Volume{") ) &&
			( str[19] == _T('-') ) &&
			( str[24] == _T('-') ) &&
			( str[29] == _T('-') ) &&
			( str[34] == _T('-') ) &&
			( str[47] == _T('}') )  );

	MY_CATCH_AND_THROW
}

/*
Global function:	QueryDriveLetterAndVolumeName

Purpose:			Query the drive letter and the name of the volume given its NT Name
					The name will be like this: "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"

Parameters:			[IN] CString& strNTName
						The NT name of the volume
					[OUT] TCHAR& cDriveLetter
						The drive letter of the volume
					[OUT] CString& strVolumeName
						The name ( to be used by FindFirst/FindNext ) of the volume

Return value:		TRUE	if the function succeeded							
*/

BOOL QueryDriveLetterAndVolumeName( CString& strNTName, TCHAR& cDriveLetter, CString& strVolumeName )
{
	MY_TRY

	cDriveLetter = _T('\0');
	strVolumeName = _T("");
	
	if( strNTName.IsEmpty() )
		return FALSE;
	
	HANDLE                  h;
	ULONG					ulInputSize;
	PMOUNTMGR_MOUNT_POINT   pInput;
    ULONG                   ulOutputSize;
    PMOUNTMGR_MOUNT_POINTS  pOutput;
    ULONG                   ulBytes;
	BOOL					bResult;
    USHORT					unNTNameLength;


	// Open the mount manager
	h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE);
	if (h == INVALID_HANDLE_VALUE)
	{
		TRACE( _T("Error: Open mount manager failed in GetDriveLetterAndVolumeName\n") );
		return FALSE;
	}
	
	// Prepare the input structure
	unNTNameLength	 = (USHORT)strNTName.GetLength();
	ulInputSize = sizeof(MOUNTMGR_MOUNT_POINT) + ((unNTNameLength + 1)*sizeof(WCHAR));
    pInput = (PMOUNTMGR_MOUNT_POINT) LocalAlloc( 0, ulInputSize);
	if (!pInput)
	{
        TRACE( _T("Error: Memory allocation failure in GetDriveLetterAndVolumeName\n") );
        CloseHandle(h);
		return FALSE;
	}
	
	pInput->SymbolicLinkNameLength = 0;
	pInput->SymbolicLinkNameOffset = 0;
	pInput->UniqueIdOffset = 0;
	pInput->UniqueIdLength = 0;
    pInput->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    pInput->DeviceNameLength = unNTNameLength * sizeof(WCHAR);
	CopyStr2W( (LPWSTR) ((PUCHAR) pInput + pInput->DeviceNameOffset), strNTName );

	// Prepare the output structure
	ulOutputSize = sizeof(MOUNTMGR_MOUNT_POINTS) + 1024;
    pOutput = (PMOUNTMGR_MOUNT_POINTS) LocalAlloc( 0, ulOutputSize);
	if (!pOutput)
    {
		TRACE( _T("Error: Memory allocation failure in GetDriveLetterAndVolumeName\n") );
        CloseHandle(h);
        LocalFree(pInput);
		return FALSE;
	}

	bResult = DeviceIoControl( h, IOCTL_MOUNTMGR_QUERY_POINTS, pInput, ulInputSize,
                    pOutput, ulOutputSize, &ulBytes, NULL);

    while (!bResult && GetLastError() == ERROR_MORE_DATA)
	{
		ulOutputSize = pOutput->Size;
        LocalFree( pOutput );
        pOutput = (PMOUNTMGR_MOUNT_POINTS)(LocalAlloc(0, ulOutputSize ));
        if (!pOutput)
		{
			TRACE( _T("Error: Memory Allocation failure in QueryMountPoints") );
			CloseHandle(h);
			LocalFree(pInput);
			return FALSE;
        }
		bResult = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, pInput, ulInputSize,
						pOutput, ulOutputSize, &ulBytes, NULL);
	}

    CloseHandle(h);
	LocalFree(pInput);

	if( !bResult )
	{
		TRACE( _T("Error: IOCTL_MOUNTMGR_QUERY_POINTS failure in GetDriveLetterAndVolumeName\n") );
		LocalFree(pOutput);
		return FALSE;
	}
	
	//CStringArray	arrMountPointName;
	CString			strMountPoint;
	for( ULONG i=0; i < pOutput->NumberOfMountPoints; i++ )
	{
		PMOUNTMGR_MOUNT_POINT   pMountPoint = &(pOutput->MountPoints[i]);
		
		/*
		if (!point->SymbolicLinkNameOffset) {
            continue;        }
		*/
		CopyW2Str( strMountPoint, (LPWSTR)((PCHAR)pOutput + pMountPoint->SymbolicLinkNameOffset),
											pMountPoint->SymbolicLinkNameLength / sizeof(WCHAR) );

		if( IsDOSName( strMountPoint ) )  // i.e. "\DosDevices\X:"
		{
			// I got the drive letter
			cDriveLetter = strMountPoint[12];
		}
		else if ( IsVolumeName( strMountPoint ) ) // i.e. "\??\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
		{
			// I got the volume name !!!!
			strVolumeName = strMountPoint;
			// Make it like this :  "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
			strVolumeName.SetAt( 1, _T('\\') );
		}
	}
	
	LocalFree(pOutput);
	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Global function:	QueryMountListInPath

Purpose:			Query the mount manager for all mount paths of the given volumes in a certain path
					Each found mount path is added to the corresponding volume in array arrItems ( if any )

Parameters:			[IN] CString& strPath
						The path to search in
					[IN/OUT] CObArray& arrVolumesData
						Array of CItemData - Tree items ( volumes ) whose mount paths we are looking for
					
Return value:		-
*/

void QueryMountListInPath( const CString& strPath, CObArray& arrVolumesData )
{
	MY_TRY

	BOOL		bResult;
	CString		strVolName, strVolMountPoint, strMountPointPath;

	LPTSTR lpstr = strVolName.GetBuffer(MAX_PATH);
	bResult = GetVolumeNameForVolumeMountPoint( strPath, lpstr, MAX_PATH );
	strVolName.ReleaseBuffer();
	if( !bResult )
		return;

	// Cut the final backslash of the volume name and search it in the volumes array
	CString strVolName2 = strVolName.Left( strVolName.GetLength() - 1 );
	for( int i = 0; i < arrVolumesData.GetSize(); i++ )
	{
		CItemData* pData = (CItemData*)(arrVolumesData[i]);
		if( pData->GetVolumeName() == strVolName2 )
		{
			// Cut the final backslash of the path and add it to the volume's mount paths
			CString strPath2 = strPath.Left( strPath.GetLength() - 1 );
			pData->GetMountPaths().Add(strPath2);
		}
	}

	lpstr = strVolMountPoint.GetBuffer(MAX_PATH);
	HANDLE	h = FindFirstVolumeMountPoint( strVolName, lpstr, MAX_PATH);
	strVolMountPoint.ReleaseBuffer();
	if( h == INVALID_HANDLE_VALUE )
		return;

	for( ; ; )
	{
		strMountPointPath = strPath + strVolMountPoint;
		QueryMountListInPath( strMountPointPath, arrVolumesData );
		
		lpstr = strVolMountPoint.GetBuffer(MAX_PATH);
		bResult = FindNextVolumeMountPoint( h, lpstr, MAX_PATH );
		strVolMountPoint.ReleaseBuffer();
		if( !bResult )
			break;
	}

	FindVolumeMountPointClose(h);

	MY_CATCH_AND_THROW
}

/*
Global function:	QueryMountList

Purpose:			Query the mount manager for all mount paths of the given volumes
					Each found mount path is added to the corresponding volume in array arrItems ( if any )

Parameters:			[IN/OUT] CObArray& arrVolumesData
						Array of CItemData - Tree items ( volumes ) whose mount paths we are looking for

Return value:		-
*/

void QueryMountList( CObArray& arrVolumesData )
{
	MY_TRY

	CString	strName = _T("X:\\");

	for( TCHAR cDriveLetter = _T('A'); cDriveLetter <= _T('Z'); cDriveLetter++ )
	{
		strName.SetAt(0, cDriveLetter);
		QueryMountListInPath( strName, arrVolumesData );
	}

	MY_CATCH_AND_THROW
}

/*
Global function:	ConvertPartitionsToFT

Purpose:			Scans an array of CItemData and converts all physical partitions to
					FT partitions. Then return the logical volume ID's of all items in the array
					
Parameters:			[IN] CObArray& arrVolumeData
						The array of CItemData to scan
					[OUT] FT_LOGICAL_DISK_ID* arrVolID
						The array of logical volume ID's of all items from arrVolumeData
						( arrVolID[i] is the logical volume ID of volume represented by arrVolumeData[i] )

Return value:		TRUE if all physical partitions are converted succesfully
					If one conversion fails then all previously converted partitions are deconverted
*/

BOOL ConvertPartitionsToFT( CObArray& arrVolumeData, FT_LOGICAL_DISK_ID* arrVolID )
{
	MY_TRY

	ASSERT( arrVolID );

	for( int i = 0; i < arrVolumeData.GetSize(); i++ )
	{
		CItemData* pData = (CItemData*)(arrVolumeData[i]);
		ASSERT(pData);
		if( pData->GetItemType() == IT_LogicalVolume )
			pData->GetVolumeID( arrVolID[i] );
		else if( pData->GetItemType() == IT_PhysicalPartition )
		{
			ASSERT( !pData->GetVolumeName().IsEmpty() );
			if( !FTPart(	pData->GetVolumeName(),
							pData->GetDriveLetter(),
							&(arrVolID[i]) ) )
			{
				// Deconvert all partitions you've previously converted and return FALSE
				DeconvertPartitionsFromFT( arrVolumeData, arrVolID, i );
				return FALSE;
			}
		}
		else
			ASSERT(FALSE);
	}
	return TRUE;

	MY_CATCH_AND_THROW
}

/*
Global function:	DeconvertPartitionsFromFT

Purpose:			Scans an array of CItemData and deconverts all physical partitions from
					FT partitions.
					
Parameters:			[IN] CObArray& arrVolumeData
						The array of CItemData to scan
					[IN] FT_LOGICAL_DISK_ID* arrVolID
						The array of logical volume ID's of volumes from arrVolumeData
						( arrVolID[i] is the logical volume ID of volume represented by arrVolumeData[i] )
					[IN] int nItems
						The number of items ( starting with offset zero ) to deconvert
						If nItems = -1 then all items in the array will be scanned and deconverted

Return value:		TRUE if all physical partitions are deconverted succesfully
*/

BOOL DeconvertPartitionsFromFT( CObArray& arrVolumeData, FT_LOGICAL_DISK_ID* arrVolID, int nItems /* =-1 */ )
{
	MY_TRY

	BOOL bResult = TRUE;

	if( nItems == -1 )
		nItems = (int)arrVolumeData.GetSize();

	for( int i = 0; i < nItems; i++ )
	{
		CItemData* pData = (CItemData*)(arrVolumeData[i]);
		ASSERT(pData);
		if( pData->GetItemType() == IT_PhysicalPartition )
			bResult = FTBreak( arrVolID[i] ) && bResult;
	}
	return bResult;

	MY_CATCH_AND_THROW
}

/*
Global function:	CheckAdministratorsMembership

Purpose:			Checks whether the current user is a member of the Administrators' group
					
Parameters:			[OUT] BOOL& bIsAdministrator
						Returns TRUE if the user is a member of the administrators group

Return value:		TRUE the check concluded successfully with a YES / NO answer
*/

BOOL CheckAdministratorsMembership( BOOL& bIsAdministrator )
{
	MY_TRY

	BYTE sidBuffer[100];
	PSID pSID = (PSID)&sidBuffer;
	SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
	
	// Create a SID for the BUILTIN\Administrators group.
	if( !AllocateAndInitializeSid( &SIDAuth, 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0,
                 &pSID) )
	{
		TRACE(_T("Error in AllocateAndInitializeSid\n"));
		DisplaySystemErrorMessage( IDS_ERR_CHECK_ADMINISTRATOR );
		return FALSE;
	}
	
	if( !CheckTokenMembership(  NULL, pSID, &bIsAdministrator ) )
	{
		TRACE(_T("Error in CheckTokenMembership\n"));
		DisplaySystemErrorMessage( IDS_ERR_CHECK_ADMINISTRATOR );
		return FALSE;
	}

	if (pSID)
		FreeSid(pSID);

	return TRUE;

	MY_CATCH_AND_THROW
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\item.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	Item.cpp

Abstract:

    The  implementation of class CItemData. A generic base class to store the data of items from the 
	tree control of CFTTreeView and from the list control of CFTListView

Author:

    Cristian Teodorescu      November 3, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "FrSpace.h"
#include "Item.h"
#include "LogVol.h"
#include "PhPart.h"
#include "Resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CItemData

IMPLEMENT_DYNAMIC(CItemData, CObject)

// Constructor
CItemData::CItemData( ITEM_TYPE wItemType, CItemData* pParentData /* = NULL */, BOOL bIsRootVolume /* = FALSE */) : 
		m_wItemType(wItemType),			m_bIsRootVolume(bIsRootVolume),	m_ulNumMembers(0),				
		m_cDriveLetter(_T('\0')),		m_bIoOK(FALSE),					m_nMemberStatus(FtMemberHealthy),
		m_bValid(FALSE),				m_iImage(II_PhysicalPartition_Error),m_pParentData( pParentData ),			
		m_hTreeItem(NULL),				m_nListItem(-1),				m_bAreMembersInserted(FALSE) 
{
}

// Copy constructor
CItemData::CItemData( CItemData& rData ) : 
		m_wItemType(rData.m_wItemType),				m_ulNumMembers(rData.m_ulNumMembers),		
		m_cDriveLetter(rData.m_cDriveLetter),		m_strVolumeName( rData.m_strVolumeName ),	
		m_bIoOK(rData.m_bIoOK),						m_nMemberStatus( rData.m_nMemberStatus ),	
		m_bIsRootVolume(rData.m_bIsRootVolume),		m_bValid( rData.m_bValid ),					
		m_iImage(rData.m_iImage),					m_pParentData(rData.m_pParentData ),		
		m_hTreeItem(rData.m_hTreeItem),				m_nListItem(rData.m_nListItem),				
		m_bAreMembersInserted(rData.m_bAreMembersInserted)
{
	MY_TRY

	m_arrMountPaths.RemoveAll();
	for( int i = 0; i < rData.m_arrMountPaths.GetSize(); i++ )
		m_arrMountPaths.Add(rData.m_arrMountPaths.GetAt(i));

	m_setDisks = rData.m_setDisks;

	MY_CATCH_AND_THROW
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Public methods

void CItemData::GetDisplayVolumeID( CString& strDisplay) const
{
	MY_TRY

	FT_LOGICAL_DISK_ID llVolID;
	if( GetVolumeID(llVolID) )
		strDisplay.Format(_T("%I64X"), llVolID );
	else
		strDisplay = _T("");

	MY_CATCH_AND_THROW
}

void CItemData::GetDisplaySize( CString& strDisplay) const
{
	MY_TRY

	LONGLONG llSize;
	if( GetSize(llSize) )
		::FormatVolumeSize( strDisplay, llSize  );
	else
		strDisplay = _T("");

	MY_CATCH_AND_THROW
}

void CItemData::GetDisplayDisksSet( CString& strDisplay ) const
{
	MY_TRY

	strDisplay = _T("");
	
	for( int i = 0; i < m_setDisks.GetSize(); i++ )
	{
		CString strDisk;
		if( i > 0 )
			strDisk.Format(_T(",%lu"), m_setDisks[i] );
		else
			strDisk.Format(_T("%lu"), m_setDisks[i] );

		strDisplay += strDisk;		
	}

	MY_CATCH_AND_THROW
}

void CItemData::GetDisplayOffset( CString& strDisplay) const
{
	MY_TRY

	LONGLONG llOffset;
	if( GetOffset(llOffset) )
		::FormatVolumeSize( strDisplay, llOffset  );
	else
		strDisplay = _T("");

	MY_CATCH_AND_THROW
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods

BOOL CItemData::ReadDriveLetterAndVolumeName()
{
	MY_TRY

	m_cDriveLetter = _T('\0');
	m_strVolumeName = _T("");
	m_arrMountPaths.RemoveAll();

	if( !IsRootVolume() )
		return TRUE;
	
	CString strNTName;
	if( !RetrieveNTName( strNTName ) )
		return FALSE;
	
	if( !QueryDriveLetterAndVolumeName( strNTName, m_cDriveLetter, m_strVolumeName ) )
		return FALSE;
	
	return TRUE;

	MY_CATCH_AND_THROW
}

/*	
	Add a error message to a string .The error message will be formatted like this:
		<Item identification: >< My error message > [ System error message ]
*/
void CItemData::AddError( CString& strErrors, UINT unErrorMsg, BOOL bAddSystemMsg /* =FALSE */ )
{
	MY_TRY

	CString str, strName, strErr, strSystemErr;
	
	// Get system error message
	if( bAddSystemMsg )
	{
		LPVOID lpMsgBuf;
		if( ::FormatMessage(	
						FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,    
						NULL,
						GetLastError(),
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
						(LPTSTR) &lpMsgBuf,    
						0,    
						NULL ) ) // Process any inserts in lpMsgBuf.
		{			
			strSystemErr = (LPCTSTR)lpMsgBuf;
			LocalFree( lpMsgBuf );
		}
	}

	// Get the name of the item
	GetDisplayName(strName);

	// Get my error message
	strErr.LoadString(unErrorMsg);

	str.Format(_T("%s: %s %s\n"), strName, strErr, strSystemErr );
	strErrors += str;

	MY_CATCH_AND_THROW
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CItemID

// Constructor for a root item ID
CItemID::CItemID() : m_wItemType( IT_RootVolumes)
{
}

CItemID::CItemID( const CItemData& rData )
{
	Load( rData );
}


void CItemID::Load( const CItemData& rData )
{
	m_wItemType = rData.GetItemType();
	switch( m_wItemType )
	{
		case IT_RootVolumes:
			break;
		case IT_LogicalVolume:
			m_ID.m_LogicalVolumeID.m_llVolID = ((CLogicalVolumeData*)(&rData))->m_llVolID;
			break;
		case IT_PhysicalPartition:
			m_ID.m_PhysicalPartitionID.m_ulDiskNumber = ((CPhysicalPartitionData*)(&rData))->m_dwDiskNumber;
			m_ID.m_PhysicalPartitionID.m_llOffset = ((CPhysicalPartitionData*)(&rData))->m_PartInfo.StartingOffset.QuadPart; 
			break;
		case IT_RootFreeSpaces:
			break;
		case IT_FreeSpace:
			m_ID.m_FreeSpaceID.m_ulDiskNumber = ((CFreeSpaceData*)(&rData))->m_dwDiskNumber;
			m_ID.m_FreeSpaceID.m_llOffset = ((CFreeSpaceData*)(&rData))->m_llOffset; 
			break;
		
		default:
			ASSERT(FALSE);
	}
}

BOOL CItemID::operator==(  const CItemID& id ) const
{
	if( m_wItemType == id.m_wItemType )
	{
		switch( m_wItemType )
		{
			case IT_RootVolumes:
				return TRUE;
			case IT_LogicalVolume:
				return ( m_ID.m_LogicalVolumeID.m_llVolID == id.m_ID.m_LogicalVolumeID.m_llVolID );
			case IT_PhysicalPartition:
				return (( m_ID.m_PhysicalPartitionID.m_ulDiskNumber == id.m_ID.m_PhysicalPartitionID.m_ulDiskNumber ) &&
						( m_ID.m_PhysicalPartitionID.m_llOffset == id.m_ID.m_PhysicalPartitionID.m_llOffset ) );
			case IT_RootFreeSpaces:
				return TRUE;
			case IT_FreeSpace:
				return (( m_ID.m_FreeSpaceID.m_ulDiskNumber == id.m_ID.m_FreeSpaceID.m_ulDiskNumber ) &&
						( m_ID.m_FreeSpaceID.m_llOffset == id.m_ID.m_FreeSpaceID.m_llOffset ) );
			
			default:
				ASSERT(FALSE);
		}
	}

	return FALSE;
}

BOOL CItemID::operator>( const CItemID& id ) const
{
	if( m_wItemType == id.m_wItemType )
	{
		switch( m_wItemType )
		{
			case IT_RootVolumes:
				return FALSE;
			case IT_LogicalVolume:
				return ( m_ID.m_LogicalVolumeID.m_llVolID > id.m_ID.m_LogicalVolumeID.m_llVolID );
			case IT_PhysicalPartition:
				if( m_ID.m_PhysicalPartitionID.m_ulDiskNumber == id.m_ID.m_PhysicalPartitionID.m_ulDiskNumber )
					return ( m_ID.m_PhysicalPartitionID.m_llOffset > id.m_ID.m_PhysicalPartitionID.m_llOffset );
				return ( m_ID.m_PhysicalPartitionID.m_ulDiskNumber > id.m_ID.m_PhysicalPartitionID.m_ulDiskNumber );
			case IT_RootFreeSpaces:
				return FALSE;
			case IT_FreeSpace:
				if( m_ID.m_FreeSpaceID.m_ulDiskNumber == id.m_ID.m_FreeSpaceID.m_ulDiskNumber )
					return ( m_ID.m_FreeSpaceID.m_llOffset > id.m_ID.m_FreeSpaceID.m_llOffset );
				return ( m_ID.m_FreeSpaceID.m_ulDiskNumber > id.m_ID.m_FreeSpaceID.m_ulDiskNumber );
			
			default:
				ASSERT(FALSE);		
		}
	}

	return ( m_wItemType > id.m_wItemType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\logvol.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	LogVol.cpp

Abstract:

    Implementation of the CLogicalVolumeData class. The class who stores all properties of a logical volume

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "DiskMap.h"
#include "FTUtil.h"
#include "Global.h"
#include "LogVol.h"
#include "MainFrm.h"
#include "PhPart.h"
#include "Resource.h"

// Because ftapi library is written in C the header must be included with    extern "C".
// Otherwise it can't be linked 
extern "C"
{
	#include <FTAPI.h>
}

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////////////////
// CLogicalVolumeData

// Constructor
CLogicalVolumeData::CLogicalVolumeData( 
								FT_LOGICAL_DISK_ID	llVolID, 
								CItemData*			pParentData	  /* = NULL */,
								BOOL				bIsRootVolume /* = FALSE */, 
								USHORT				unMemberIndex /* = MAXWORD */,
								FT_MEMBER_STATE		nMemberStatus /* = FtMemberHealthy */ ) : 
	CItemData( IT_LogicalVolume, pParentData, bIsRootVolume ), m_llVolID(llVolID), m_unMemberIndex(unMemberIndex)
{
	m_nMemberStatus = nMemberStatus;
	if( bIsRootVolume )
	{
		ASSERT( unMemberIndex == MAXWORD );
		ASSERT( nMemberStatus == FtMemberHealthy );
	}
}

// Copy constructor
CLogicalVolumeData::CLogicalVolumeData( CLogicalVolumeData& rData ) 
	:	CItemData(rData), 
		m_llVolID(rData.m_llVolID), m_llVolSize(rData.m_llVolSize), m_nVolType(rData.m_nVolType),
		m_unMemberIndex(rData.m_unMemberIndex)
{
	memcpy(&m_ConfigInfo, &(rData.m_ConfigInfo), sizeof(m_ConfigInfo));
	memcpy(&m_StateInfo, &(rData.m_StateInfo), sizeof(m_StateInfo));
}

////////////////////////////////////////////////////////////////////////////////////////
// Public methods

BOOL CLogicalVolumeData::ReadItemInfo( CString& strErrors )
{
	MY_TRY

	m_bValid = TRUE;
	strErrors = _T("");

	m_ulNumMembers = 0;
	
	if( !ReadFTInfo( strErrors ) )
	{
		m_bValid = FALSE;
		// this is a serious error so return immediately
		return FALSE;
	}

	if( m_nVolType == FtPartition )
	{
		// I need some extra information for FtPartitions
		PARTITION_INFORMATION	partInfo;
		PARTITION_TYPE			wPartitionType;
		CString					strMemberErrors;
		BOOL					bMissingDisk;

		CDiskMap diskMap( m_ConfigInfo.partConfig.Config.DiskNumber );
		if( diskMap.ReadPartitionInformation(	m_ConfigInfo.partConfig.Config.ByteOffset,
												partInfo,
												wPartitionType,
												strMemberErrors,
												bMissingDisk) )
		{
			m_ConfigInfo.partConfig.dwPartitionNumber = partInfo.PartitionNumber;
			m_ConfigInfo.partConfig.wPartitionType = wPartitionType;
		}
		strErrors += strMemberErrors;
	}

	// Read the drive letter, volume name and mount paths ( if any )
	if( !ReadDriveLetterAndVolumeName() )
	{
		//AddError( strErrors, IDS_ERR_READ_DRIVE_LETTER_AND_VOLUME_NAME, FALSE );
		m_bValid =  FALSE;
	}
	
	// The mount paths will be retrieved later together with all other siblings mount paths ( for performance reason )
	m_arrMountPaths.RemoveAll();
	
	// Retrieve all disks used by this volume
	if( !RetrieveDisksSet() )
	{
		AddError( strErrors, IDS_ERR_RETRIEVE_DISKS_SET, FALSE );
		m_bValid = FALSE;
	}

	if( !FTChkIO( m_llVolID, &m_bIoOK) )
	{
		AddError( strErrors, IDS_ERR_FTCHKIO, TRUE );
		m_bValid = FALSE;
	}

	m_iImage = ComputeImageIndex();

	return m_bValid;

	MY_CATCH_AND_THROW
}

BOOL CLogicalVolumeData::ReadFTInfo( CString& strErrors )
{
	MY_TRY

	strErrors = _T("");

	USHORT										numMembers;
	FT_LOGICAL_DISK_ID							members[100];
	
	// Read all information related to this logical volume
	if( ! FtQueryLogicalDiskInformation (	m_llVolID,
											&m_nVolType,
											&m_llVolSize,
											100,
											members,
											&numMembers,
											sizeof(m_ConfigInfo),
											&m_ConfigInfo,
											sizeof(m_StateInfo),
											&m_StateInfo ) )
	{
		AddError( strErrors, IDS_ERR_RETRIEVING_VOL_INFO, TRUE );
		m_bValid = FALSE;
		// this is a serious error so return immediately
		return FALSE;
	}
	m_ulNumMembers = (ULONG)numMembers;

	return TRUE;

	MY_CATCH_AND_THROW
}

BOOL CLogicalVolumeData::ReadMembers( CObArray& arrMembersData, CString& strErrors )
{
	MY_TRY

	arrMembersData.RemoveAll();
	strErrors = _T("");
	m_ulNumMembers = 0;
	
	USHORT										numMembers;
	FT_LOGICAL_DISK_ID							members[100];
	
	// Read all information related to this logical volume
	if( !FtQueryLogicalDiskInformation (	m_llVolID,
											&m_nVolType,
											&m_llVolSize,
											100,
											members,
											&numMembers,
											sizeof(m_ConfigInfo),
											&m_ConfigInfo,
											sizeof(m_StateInfo),
											&m_StateInfo ) )
	{
		AddError( strErrors, IDS_ERR_RETRIEVING_VOL_INFO, TRUE );
		return FALSE;
	}
	m_ulNumMembers = (ULONG)numMembers;
	
	for( USHORT i = 0; i < m_ulNumMembers; i++ )
	{
		// Get the status of the member
		FT_MEMBER_STATE	nMemberStatus;
		nMemberStatus = FtMemberHealthy;
		if( ( m_nVolType == FtMirrorSet ) ||
			( m_nVolType == FtStripeSetWithParity ) )
		{
			if( ( m_StateInfo.stripeState.UnhealthyMemberState != FtMemberHealthy ) &&
				( m_StateInfo.stripeState.UnhealthyMemberNumber == i ) )
				nMemberStatus = m_StateInfo.stripeState.UnhealthyMemberState;
		}
		
		// Create the logical volume item data
		CLogicalVolumeData* pData = new CLogicalVolumeData( members[i], this, FALSE, i, nMemberStatus );
		// Read logical volume info and collect errors ( if any )
		CString strMemberErrors;
		pData->ReadItemInfo( strMemberErrors);
		strErrors += strMemberErrors;
		// Add the structure to the members' data array
		arrMembersData.Add(pData);
	}

	return TRUE;

	MY_CATCH_AND_THROW
}

int CLogicalVolumeData::ComputeImageIndex() const
{
	MY_TRY

	// Is it necessary to display the error image?
	BOOL bError = FALSE;
	// Is it necessary to display the warning image?
	BOOL bWarning = FALSE;
	
	// The error image should be displayed in three situations:
	// 1. The item is not valid. That means that not all information about the volume was successfully read, 
	// so the volume cannot be used in actions
	// 2. The check IO test failed. The volume cannot be used for IO operations
	// 3. The volume is an orphan member of a mirror set or of a stripe set with parity.
	bError = !m_bValid || !m_bIoOK || ( m_nMemberStatus == FtMemberOrphaned );
	
	if( !bError )
	{
		// The warning image should be displayed in four situations:
		// 1. The volume is a regenerating member of a mirror set or stripe set with parity
		// 2. The volume is a member of a stripe set with parity who is initializing
		// 3. The volume is a stripe set with parity initializing
		// 4. The volume is a mirror set or a stripe set with parity containing a not healthy member.
		// Situations 1,2 are general and could happen to all logical volumes
		// Situations 3,4 are particular for mirrors and swp's so they will be treated in the main switch at 
		// the end of the method
		
		
		if( m_nMemberStatus == FtMemberRegenerating )
			bWarning = TRUE;
		else if( ( m_pParentData != NULL ) && ( m_pParentData->GetItemType() == IT_LogicalVolume ) )
		{
			CLogicalVolumeData* pParentData = (CLogicalVolumeData*)m_pParentData;
			if( ( pParentData->m_nVolType == FtStripeSetWithParity ) &&
				( pParentData->m_StateInfo.stripeState.IsInitializing ) )
				bWarning = TRUE;

		}
	}
	
	switch( m_nVolType )
	{
		case FtPartition:
			if( bError )
				return II_PhysicalPartition_Error;		//II_FTPartition;  The user shouldn't know about the existence of FTPartitions
			else if( bWarning )
				return II_PhysicalPartition_Warning;
			else
				return II_PhysicalPartition;

		case FtVolumeSet:
			if( bError )
				return II_VolumeSet_Error;
			else if( bWarning )
				return II_VolumeSet_Warning;
			else
				return II_VolumeSet;

		case FtStripeSet:
			if( bError )
				return II_StripeSet_Error;
			else if( bWarning )
				return II_StripeSet_Warning;
			else
				return II_StripeSet;

		case FtMirrorSet:
			if( bError )
				return II_MirrorSet_Error;
			else if( bWarning || ( m_StateInfo.stripeState.UnhealthyMemberState != FtMemberHealthy ) )
				return II_MirrorSet_Warning;
			else
				return II_MirrorSet;

		case FtStripeSetWithParity:
			if( bError )
				return II_StripeSetWithParity_Error;
			else if( bWarning ||	( m_StateInfo.stripeState.UnhealthyMemberState != FtMemberHealthy ) ||
									( m_StateInfo.stripeState.IsInitializing ) )
				return II_StripeSetWithParity_Warning;
			else
				return II_StripeSetWithParity;
			
		case FtRedistribution:
			// I don't have yet a bitmap for redistributions
			ASSERT(FALSE);
			if( bError )
				return II_PhysicalPartition_Error;
			else if( bWarning )
				return II_PhysicalPartition_Warning;
			else
				return II_PhysicalPartition;
			
		default:
			ASSERT(FALSE);
			return II_PhysicalPartition_Error;
	}
	
	MY_CATCH_AND_THROW
}

BOOL CLogicalVolumeData::operator==(CItemData& rData) const
{
	if( rData.GetItemType() != IT_LogicalVolume )
		return FALSE;

	CLogicalVolumeData* pLogVolData = (CLogicalVolumeData*)(&rData);

	return( m_llVolID == pLogVolData->m_llVolID );			
}

void CLogicalVolumeData::GetDisplayName( CString& strDisplay ) const 
{	
	MY_TRY

	strDisplay = _T("");
	for( int i = 0; i < m_arrMountPaths.GetSize(); i++ )
	{
		if( i != 0 )
			strDisplay += _T("; ");
		strDisplay += m_arrMountPaths[i];
	}

	if( strDisplay.IsEmpty() )
	{
		if( m_cDriveLetter )
			strDisplay.Format(_T("%c:"), m_cDriveLetter );
		/*
		else
			strDisplay.Format(_T("%I64X"), m_llVolID );
		*/
	}
	
	if( m_nVolType == FtPartition )
	{
		CString str;
		str.Format( IDS_STR_PHYSICAL_PARTITION_NAME, 
							m_ConfigInfo.partConfig.Config.DiskNumber, m_ConfigInfo.partConfig.dwPartitionNumber );
		if( !strDisplay.IsEmpty() )
			strDisplay += _T("  ");
		strDisplay += str;
	}

	MY_CATCH_AND_THROW
}

void CLogicalVolumeData::GetDisplayType( CString& strDisplay ) const 
{
	MY_TRY

	switch( m_nVolType )
	{
		case FtPartition:
			//strDisplay.LoadString(IDS_TYPE_FTPARTITION);
			switch( m_ConfigInfo.partConfig.wPartitionType )
			{
				case PT_Primary:
					strDisplay.LoadString( IDS_TYPE_PRIMARY_PARTITION);
					break;
				case PT_InExtendedPartition:
					strDisplay.LoadString( IDS_TYPE_PARTITION_IN_EXTENDED_PARTITION);
				break;
					default:
					ASSERT(FALSE);
			}
			break;
		case FtVolumeSet:
			strDisplay.LoadString(IDS_TYPE_FTVOLUMESET);
			break;
		case FtStripeSet:
			strDisplay.LoadString(IDS_TYPE_FTSTRIPESET);
			break;
		case FtMirrorSet:
			strDisplay.LoadString(IDS_TYPE_FTMIRRORSET);
			break;
		case FtStripeSetWithParity:
			strDisplay.LoadString(IDS_TYPE_FTSTRIPESETWITHPARITY);
			break;
		case FtRedistribution:
			strDisplay.LoadString(IDS_TYPE_FTREDISTRIBUTION);
			break;
		default:
			ASSERT(FALSE);
			strDisplay = _T("");
	}

	MY_CATCH_AND_THROW
}

void CLogicalVolumeData::GetDisplayExtendedName( CString& strDisplay ) const 
{
	MY_TRY

	GetDisplayName( strDisplay );

	if( m_nVolType != FtPartition )
	{
		CString strType;
		GetDisplayType( strType );
		if( !strDisplay.IsEmpty() )
			strDisplay += _T("  ");
		strDisplay += strType;
	}

	MY_CATCH_AND_THROW
}


BOOL CLogicalVolumeData::GetVolumeID( FT_LOGICAL_DISK_ID& llVolID ) const
{
	llVolID = m_llVolID;
	return TRUE; 
}

BOOL CLogicalVolumeData::GetSize( LONGLONG& llSize ) const
{
	llSize = m_llVolSize;
	return TRUE;
}

BOOL CLogicalVolumeData::GetDiskNumber( ULONG& ulDiskNumber ) const
{
	if( m_nVolType == FtPartition )
	{
		ulDiskNumber = m_ConfigInfo.partConfig.Config.DiskNumber;
		return TRUE;
	}
	return FALSE;
}

BOOL CLogicalVolumeData::GetOffset( LONGLONG& llOffset) const
{
	if( m_nVolType == FtPartition )
	{
		llOffset = m_ConfigInfo.partConfig.Config.ByteOffset;
		return TRUE;
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods


BOOL CLogicalVolumeData::RetrieveNTName( CString& strNTName ) const
{
	MY_TRY

	return FTQueryNTDeviceName( m_llVolID, strNTName );

	MY_CATCH_AND_THROW
}

BOOL CLogicalVolumeData::RetrieveDisksSet()
{
	MY_TRY

	return FTGetDisksSet( m_llVolID, m_setDisks );

	MY_CATCH_AND_THROW
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\global.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	Global.h

Abstract:

    Definitions of useful global functions

Author:

    Cristian Teodorescu      October 29, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_GLOBAL_H_INCLUDED_)
#define AFX_GLOBAL_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <fttypes.h>
#include <winioctl.h>

/////////////////////////////////////////////////////////////////////////////////////////////
// Display stuff

//	Display the last system error message prefixed ( or not ) with another string taken from
//	our resources explaining the context of the failure
BOOL DisplaySystemErrorMessage( UINT unContextMsgID=0 );

// Format the size of a volume in a "readable" way
// ( in GB, MB, KB depending on the size )
void FormatVolumeSize( CString& strSize, LONGLONG llSize  );

// Display a message in the first pane of the main frame status bar
BOOL DisplayStatusBarMessage( LPCTSTR lpszMsg );

// Displays a message in the first pane of the main frame status bar
BOOL DisplayStatusBarMessage( UINT unMsgID );

// Copy a Unicode character array into a CString
void CopyW2Str( CString& strDest, LPWSTR strSource, ULONG ulLength );

// Copy a CString content into a Unicode character array
void CopyStr2W( LPWSTR strDest, CString& strSource );


/////////////////////////////////////////////////////////////////////////////////////////////
// Volume stuff

// Open a volume given its name
//  The name must be like this:  "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\"
HANDLE OpenVolume( const CString& strVolumeName );

// Query the drive letter and the name of the volume given its NT Name
// The name will be like this:  "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
BOOL QueryDriveLetterAndVolumeName( CString& strNTName, TCHAR& cDriveLetter, CString& strVolumeName );

// Query the mount manager for all mount paths of the given volumes 
// Each found mount path is added to the corresponding volume in array arrItems ( if any )
void QueryMountList( CObArray& arrVolumesData );

// Scans an array of CLVTreeItemData and converts all physical partitions to FT partitions. 
// Then return the logical volume ID's of all items in the array
BOOL ConvertPartitionsToFT( CObArray& arrVolumeData, FT_LOGICAL_DISK_ID* arrVolID );

// Scans an array of CLVTreeItemData and deconverts all physical partitions from FT partitions. 
BOOL DeconvertPartitionsFromFT( CObArray& arrVolumeData, FT_LOGICAL_DISK_ID* arrVolID, int nItems = -1 );

//////////////////////////////////////////////////////////////////////////////////////////////
// System stuff

// Checks whether the current user is a member of the Administrators' group
BOOL CheckAdministratorsMembership( BOOL& bIsAdministrator ); 


#endif // !defined(AFX_GLOBAL_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\item.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	Item.h

Abstract:

    The definition of class CItemData. A generic base class to store the data of items from the 
	tree control of CFTTreeView and from the list control of CFTListView
	An item could be:
		- a root volumes item
		- a logical volume
		- a physical partition
		- a root free spaces item
		- a free space

	It also contains the definition of class CItemID. A generic class to store the minimum information 
	needed to identify an item. It is used when refreshing the tree.

Author:

    Cristian Teodorescu      October 22, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ITEM_H_INCLUDED_)
#define AFX_ITEM_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <FTTypes.h>

#include "FTManDef.h"
#include "Global.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CItemData

class CItemData : public CObject
{
// Public constructor
public:
	CItemData( ITEM_TYPE wItemType, CItemData* pParentData = NULL, BOOL bIsRootVolume = FALSE );
	DECLARE_DYNAMIC(CItemData)

	// Copy constructor
	CItemData( CItemData& rData ); 

	virtual ~CItemData() {};	
	
// Public methods
public:
	// Retrieve all information related to this volume
	// If something wrong happens inside this method strErrors will contain error message(s)
	virtual BOOL ReadItemInfo( CString& strErrors ) = 0;

	// Retrieve the members of this volume( as an array of CItemData )
	// If something wrong happens inside this method strErrors will contain error message(s)
	virtual BOOL ReadMembers( CObArray& arrMembersData, CString& strErrors ) = 0;

	// Read the drive letter and volume name of the volume
	BOOL ReadDriveLetterAndVolumeName();

	// Decides what image should be associated with the item ( depending on the status of the item )
	virtual int ComputeImageIndex() const = 0;

	// Returns the type of the item
	ITEM_TYPE GetItemType() const { return m_wItemType;} ;
	
	// Provides the number of members of this item ( the number retrieved by ReadItemInfo )
	ULONG GetMembersNumber() const { return m_ulNumMembers;};

	// Provides the drive letter of the item
	TCHAR GetDriveLetter() const { return m_cDriveLetter; };

	// Provides the volume name of this item
	const CString& GetVolumeName() const { return m_strVolumeName; };

	// Provides the mount paths of this item
	CStringArray& GetMountPaths() { return m_arrMountPaths; }

	// Provides the disks set of the volume
	const CULONGSet& GetDisksSet() const { return m_setDisks; };

	// Is this volume ready for IO operations
	BOOL IsIoOK() const { return m_bIoOK; };

	// Provides the status of the volume as a member of its parent's set
	void SetMemberStatus( FT_MEMBER_STATE nMemberStatus ) { m_nMemberStatus = nMemberStatus; };
	FT_MEMBER_STATE GetMemberStatus() const { return m_nMemberStatus; };

	// Is this a root volume?
	BOOL IsRootVolume() const { return m_bIsRootVolume; };

	// Is all information about this volume loaded into this object so we can use it properly?
	BOOL IsValid() const { return m_bValid; };
	void SetValid( BOOL bValid = TRUE ) { m_bValid = bValid; };
	
	// Provides the index of the image associated with this item
	int GetImageIndex() const { return m_iImage; };
	void SetImageIndex( int iImageIndex ) { m_iImage = iImageIndex; }; 

	// Provides a pointer to the item's parent data 
	CItemData* GetParentData() const { return m_pParentData; };
	void SetParentData( CItemData* pParentData ) { m_pParentData = pParentData; } ;

	// Returns the tree item associated with this structure
	HTREEITEM GetTreeItem() const { return m_hTreeItem; };
	void SetTreeItem( HTREEITEM hItem) { m_hTreeItem = hItem; };

	// Returns the list item associated with this structure. If this is not -1 this doesn't mean automatically 
	// that the item is in the list. If you are not sure that it is in the list better check first if its father
	// is the father of the items displayed in the list ( equivalent with its father is the selected item in the
	// tree )
	int	GetListItem() const { return m_nListItem; };
	void SetListItem( int iItem ) { m_nListItem = iItem; };

	BOOL AreMembersInserted() const { return m_bAreMembersInserted; };
	void SetAreMembersInserted( BOOL bAreMembersInserted=TRUE) { m_bAreMembersInserted = bAreMembersInserted; };

	// Equivalence operator between 2 CItemData instances i.e. are they related to the same volume?
	virtual BOOL operator==(CItemData& rData) const = 0;
	BOOL operator!=(CItemData& rData) const { return !operator==(rData); };

	// Methods providing attributes of the item displayable in the list-view columns
	// Name ( string ).   Used in list-view in Report mode
	virtual void GetDisplayName( CString& strDisplay ) const { strDisplay = _T(" "); };
	// Type ( string )
	virtual void GetDisplayType( CString& strDisplay ) const { strDisplay = _T(" "); };
	// Extended name = name + type.   Used in tree view and in list-view in all modes other than Report   
	virtual void GetDisplayExtendedName( CString& strDisplay ) const { MY_TRY GetDisplayName(strDisplay); MY_CATCH_AND_THROW };
	// VolumeID ( number & string )
	virtual BOOL GetVolumeID( FT_LOGICAL_DISK_ID& llVolID ) const { return FALSE; };
	virtual void GetDisplayVolumeID( CString& strDisplay) const;
	// Size ( number & string )
	virtual BOOL GetSize( LONGLONG& llSize ) const { return FALSE; };
	virtual void GetDisplaySize( CString& strDisplay) const;
	// Disk Number ( number(s) & string )
	virtual BOOL GetDiskNumber( ULONG& ulDiskNumber ) const { return FALSE; };
	void GetDisplayDisksSet( CString& strDisplay ) const;
	// Offset ( number & string )
	virtual BOOL GetOffset( LONGLONG& llOffset) const { return FALSE; };
	virtual void GetDisplayOffset( CString& strDisplay) const;

// Public data members
protected:
	/****** Some data about the volume  ******/

	// The type of the item: root, logical volume or physical partition
	ITEM_TYPE			m_wItemType;

	// The number of members 
	ULONG				m_ulNumMembers;

	// Drive letter  ---- Used only by root volumes
	TCHAR				m_cDriveLetter;

	// The name of the volume "\\?\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"   ---- Used only by root volumes
	CString				m_strVolumeName;

	// Mount paths	 ---- Used only by root volumes
	CStringArray		m_arrMountPaths;

	// All disks used by this volume
	CULONGSet			m_setDisks;

	// IO status of the volume. It decides whether the volume can be used or not for IO operations
	// For physical partitions it is always TRUE
	BOOL				m_bIoOK;

	// The state of the volume as a member of its parent set ( if any ) 
	FT_MEMBER_STATE		m_nMemberStatus;

	// Set only for those logical volumes and physical partitions that are root volumes
	BOOL				m_bIsRootVolume;

	
	/****** Some data about the tree/list view item ******/

	// Is all information about this volume loaded into this object?
	// ( i.e. has ReadItemInfo succeeded? )
	BOOL				m_bValid;

	// The index of the image associated with this item ( the image depends on the item type )
	int					m_iImage;				
	
	// Pointer to the data of the item's parent ( NULL for the root items )
	CItemData*			m_pParentData;
	
	// The handle of the tree item containing this structure as tree data ( TVITEM.lParam )
	HTREEITEM			m_hTreeItem;

	// The index of the list item containing this structure as item data 
	int					m_nListItem;

	// Are the members of the item inserted in the tree?
	BOOL				m_bAreMembersInserted;

protected:
	// Get the NT name of the volume ---- Used only by root volumes
	virtual BOOL RetrieveNTName( CString& strNTName ) const { return FALSE;};
	
	// Retrieve all disks used by the volume
	virtual BOOL RetrieveDisksSet() { return FALSE; };

	// Add a error message to a string
	// The error message will be formatted like this:
	//		<Item name: >< My error message > [ System error message ]
	void AddError( CString& strErrors, UINT unErrorMsg, BOOL bAddSystemMsg = FALSE ); 
};

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CItemID

class CItemID
{
// Public constructor
public:
	// Constructor for a generic item ID
	CItemID();

	// Constructor based on a full CItemData instance
	CItemID( const CItemData& pData );
	
public:	
	ITEM_TYPE	m_wItemType;

	union
	{
		struct //tagLogicalVolumeID
		{
			FT_LOGICAL_DISK_ID	m_llVolID;
		}	m_LogicalVolumeID;

		struct //tagPhysicalPartitionID
		{
			ULONG				m_ulDiskNumber;
			LONGLONG			m_llOffset;
		}	m_PhysicalPartitionID, m_FreeSpaceID;
	}	m_ID;


public:
	void Load( const CItemData& rData );

	BOOL operator==(  const CItemID& id ) const;
	BOOL operator>( const CItemID& id ) const;
};


#endif // !defined(AFX_ITEM_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\logvol.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	LogVol.h

Abstract:

    The definition of class CLogicalVolumeData. The class who stores all properties of a logical volume

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGVOL_H_INCLUDED_)
#define AFX_LOGVOL_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <FTTypes.h>

#include "Item.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CLogicalVolumeData

class CLogicalVolumeData : public CItemData
{
public:
	// Constructor providing the ID of the Logical Volume
	CLogicalVolumeData( 
				FT_LOGICAL_DISK_ID	llVolID, 
				CItemData*			pParentData = NULL,
				BOOL				bIsRootVolume = FALSE, 
				USHORT				unMemberIndex = MAXWORD,
				FT_MEMBER_STATE		nMemberStatus = FtMemberHealthy ); 
	// Copy constructor
	CLogicalVolumeData( CLogicalVolumeData& rData );
	virtual ~CLogicalVolumeData() {};
	
// Operations
public: 
	virtual BOOL ReadItemInfo( CString& strErrors );

	// Read the FT related info of the logical volume
	BOOL ReadFTInfo( CString& strErrors );

	virtual BOOL ReadMembers( CObArray& arrMembersData, CString& strErrors );

	virtual int ComputeImageIndex() const;

	virtual BOOL operator==(CItemData& rData) const;

	// Provide item properties
	virtual void GetDisplayName( CString& strDisplay ) const ;
	virtual void GetDisplayType( CString& strDisplay ) const ;
	virtual void GetDisplayExtendedName( CString& strDisplay ) const ;
	virtual BOOL GetVolumeID( FT_LOGICAL_DISK_ID& llVolID ) const;
	virtual BOOL GetSize( LONGLONG& llSize ) const;
	virtual BOOL GetDiskNumber( ULONG& ulDiskNumber ) const;
	virtual BOOL GetOffset( LONGLONG& llOffset) const;

//Data members
public:
	// Logical Volume ID
	FT_LOGICAL_DISK_ID		m_llVolID;
	// Logical Volume Size
	LONGLONG				m_llVolSize;
	// Logical Volume Type ( FtPartition, FtVolumeSet, FtStripeSet, FtMirrorSet, FtStripeSetWithParity, FtRedistribution )
	FT_LOGICAL_DISK_TYPE	m_nVolType;

	// Configuration info
	union
	{
		// For a FT partition I must keep some extra info together with FT_PARTITION_CONFIGURATION_INFORMATION
		struct
		{
			FT_PARTITION_CONFIGURATION_INFORMATION				Config;
			PARTITION_TYPE										wPartitionType;
			DWORD												dwPartitionNumber;
		}													partConfig;

		// For all other logical volumes the FT_....  structure is enough
		FT_STRIPE_SET_CONFIGURATION_INFORMATION				stripeConfig;
		FT_MIRROR_SET_CONFIGURATION_INFORMATION				mirrorConfig;
		FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION	swpConfig;
		FT_REDISTRIBUTION_CONFIGURATION_INFORMATION			redistConfig;
	} m_ConfigInfo;
	
	// State info
	union
	{
		FT_MIRROR_AND_SWP_STATE_INFORMATION		stripeState;
		FT_REDISTRIBUTION_STATE_INFORMATION		redistState;
	} m_StateInfo;

	// If the volume is a member of a logical volume set store here the zero-based index of the member in the set
	// MAXWORD if the volume is not a member of a set ( then IsRootVolume returns TRUE )
	USHORT m_unMemberIndex;

protected:
	virtual BOOL RetrieveNTName( CString& strNTName ) const;
	virtual BOOL RetrieveDisksSet();
};


#endif // !defined(AFX_LOGVOL_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\mainfrm.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	MainFrm.cpp

Abstract:

    Implementation of the CMainFrame class. It is the MFC main frame class for this application

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "Item.h"
#include "FTListVw.h"
#include "FTTreeVw.h"
#include "MainFrm.h"
#include "Resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Range limits for OnViewStyle and OnUpdateViewStyle
#define AFX_ID_VIEW_MINIMUM				ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM				ID_VIEW_BYNAME

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_VIEW_TOGGLE, OnViewToggle)
	ON_COMMAND(ID_VIEW_REFRESH, OnViewRefresh)
	ON_WM_ACTIVATEAPP()
	ON_WM_DESTROY()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
	ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_INDICATOR_NAME,		// Name of the tree selected item
	ID_INDICATOR_TYPE,		// Type of the tree selected item
	ID_INDICATOR_DISKS,		// Disks set of the tree selected item
	ID_INDICATOR_SIZE,		// Size of the tree selected item
	ID_INDICATOR_NOTHING,	// Just an empty indicator to let some space between the first 4 indicators and the last one
	ID_SEPARATOR,           // status line indicator
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() : m_bEnableAutoRefresh(FALSE), m_bAutoRefreshRequested(FALSE), m_unTimer(0)
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	/*
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	*/
	if (!m_wndToolBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0(_T("Failed to create toolbar\n"));
		return -1;      // fail to create
	}
	m_wndToolBar.GetToolBarCtrl().ModifyStyle( 0, TBSTYLE_FLAT );

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0(_T("Failed to create status bar\n"));
		return -1;      // fail to create
	}
	// Try to compute the optimal size for the status bar indicators ( depending on the application font )

	int nAveCharWidth = 0;
	CDC* pDC = m_wndStatusBar.GetDC();
	if( pDC )
	{
		TEXTMETRIC textmetrics;
		if( pDC->GetTextMetrics(&textmetrics) )
			nAveCharWidth = textmetrics.tmAveCharWidth;
		m_wndStatusBar.ReleaseDC( pDC );
	}

	m_wndStatusBar.SetPaneInfo( 0, m_wndStatusBar.GetItemID(0), 0, nAveCharWidth ? (16 * nAveCharWidth) : 130 );
	m_wndStatusBar.SetPaneInfo( 1, m_wndStatusBar.GetItemID(1), 0, nAveCharWidth ? (22 * nAveCharWidth) : 150 );
	m_wndStatusBar.SetPaneInfo( 2, m_wndStatusBar.GetItemID(2), 0, nAveCharWidth ? (8 * nAveCharWidth) : 50 );
	m_wndStatusBar.SetPaneInfo( 3, m_wndStatusBar.GetItemID(3), 0, nAveCharWidth ? (8 * nAveCharWidth) : 60 );
	m_wndStatusBar.SetPaneInfo( 4, m_wndStatusBar.GetItemID(4), SBPS_NOBORDERS, nAveCharWidth ? (2 * nAveCharWidth) : 15 );
	m_wndStatusBar.SetPaneStyle( 5, SBPS_NOBORDERS | SBPS_STRETCH ); 

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
	// create splitter window
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
		return FALSE;

	if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CFTTreeView), CSize(200, 100), pContext) ||
		!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CFTListView), CSize(100, 100), pContext))
	{
		m_wndSplitter.DestroyWindow();
		return FALSE;
	}

	// Create timer
	m_unTimer = SetTimer( ID_TIMER_EVENT, TIMER_ELAPSE, NULL );
	if( !m_unTimer )
		TRACE( _T("Failure installing timer\n") );

	return TRUE;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/*
Public method:		RefreshAll

Purpose:			Refreshes the content of both views by keeping ( when possible ) the expanded and 
					selected items.
					It is also possible to change the selected items and to add some expanded items
					
Parameters:			[IN] CItemIDSet *psetAddTreeExpandedItems
						Items to add to the currently expanded items set
					[IN] CItemIDSet *psetTreeSelectedItems 
						Items to select in the tree ( the currently selected items are neglected )
					[IN] CItemIDSet *psetListSelectedItems 
						Items to select in the list ( the currently selected items are neglected )

Return value:		TRUE if the refresh operation succeeded
*/

BOOL CMainFrame::RefreshAll( 
					CItemIDSet* psetAddTreeExpandedItems	/* =NULL */ ,
					CItemIDSet* psetTreeSelectedItems		/* =NULL */,
					CItemIDSet* psetListSelectedItems		/* =NULL */  )
{
	CWaitCursor		wc;
	TREE_SNAPSHOT	snapshotTree;
	LIST_SNAPSHOT	snapshotList;
	BOOL			bResult;
	CAutoRefresh	ar(FALSE);
	
	DisplayStatusBarMessage( IDS_STATUS_REFRESH );
	
	CFTTreeView* pTreeView = GetLeftPane();
	CFTListView* pListView = GetRightPane();

	// Get the snapshots of the tree and list views and do some changes ( if needed )
	pTreeView->GetSnapshot(snapshotTree);
	if( psetAddTreeExpandedItems )
		snapshotTree.setExpandedItems += *psetAddTreeExpandedItems;
	if( psetTreeSelectedItems )
		snapshotTree.setSelectedItems = *psetTreeSelectedItems;

	pListView->GetSnapshot( snapshotList );
	if( psetListSelectedItems )
		snapshotList.setSelectedItems = *psetListSelectedItems;

	// Refresh the tree view
	bResult =  pTreeView->Refresh(snapshotTree);

	// Set the snapshot pf the list view
	pListView->SetSnapshot( snapshotList );

	// All previous requests for auto refresh should be neglected now
	m_bAutoRefreshRequested = FALSE;

	DisplayStatusBarMessage( AFX_IDS_IDLEMESSAGE );	
	return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

CFTTreeView* CMainFrame::GetLeftPane()
{
	CWnd* pWnd = m_wndSplitter.GetPane(0, 0);
	CFTTreeView* pView = DYNAMIC_DOWNCAST(CFTTreeView, pWnd);
	return pView;
}

CFTListView* CMainFrame::GetRightPane()
{
	CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
	CFTListView* pView = DYNAMIC_DOWNCAST(CFTListView, pWnd);
	return pView;
}

void CMainFrame::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
	// TODO: customize or extend this code to handle choices on the
	// View menu.

	CFTListView* pView = GetRightPane(); 	

	// if the right-hand pane hasn't been created or isn't a view,
	// disable commands in our range

	if (pView == NULL)
		pCmdUI->Enable(FALSE);
	else
	{
		DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

		// if the command is ID_VIEW_LINEUP, only enable command
		// when we're in LVS_ICON or LVS_SMALLICON mode

		if (pCmdUI->m_nID == ID_VIEW_LINEUP)
		{
			if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
				pCmdUI->Enable();
			else
				pCmdUI->Enable(FALSE);
		}
		else
		{
			// otherwise, use dots to reflect the style of the view
			pCmdUI->Enable();
			BOOL bChecked = FALSE;

			switch (pCmdUI->m_nID)
			{
			case ID_VIEW_DETAILS:
				bChecked = (dwStyle == LVS_REPORT);
				break;

			case ID_VIEW_SMALLICON:
				bChecked = (dwStyle == LVS_SMALLICON);
				break;

			case ID_VIEW_LARGEICON:
				bChecked = (dwStyle == LVS_ICON);
				break;

			case ID_VIEW_LIST:
				bChecked = (dwStyle == LVS_LIST);
				break;

			default:
				bChecked = FALSE;
				break;
			}

			pCmdUI->SetRadio(bChecked ? 1 : 0);
		}
	}
}


void CMainFrame::OnViewStyle(UINT nCommandID)
{
	// TODO: customize or extend this code to handle choices on the
	// View menu.
	CFTListView* pView = GetRightPane();

	// if the right-hand pane has been created and is a CFTListView,
	// process the menu commands...
	if (pView != NULL)
	{
		DWORD dwStyle = -1;
		BOOL  bExtendedNames = TRUE;

		switch (nCommandID)
		{
		case ID_VIEW_LINEUP:
			{
				// ask the list control to snap to grid
				CListCtrl& refListCtrl = pView->GetListCtrl();
				refListCtrl.Arrange(LVA_SNAPTOGRID);
			}
			break;

		// other commands change the style on the list control
		case ID_VIEW_DETAILS:
			dwStyle = LVS_REPORT;
			bExtendedNames = FALSE;
			break;

		case ID_VIEW_SMALLICON:
			dwStyle = LVS_SMALLICON;
			break;

		case ID_VIEW_LARGEICON:
			dwStyle = LVS_ICON;
			break;

		case ID_VIEW_LIST:
			dwStyle = LVS_LIST;
			break;
		}

		// change the style; window will repaint automatically
		if (dwStyle != -1)
		{
			pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
			pView->DisplayItemsExtendedNames( bExtendedNames );
		}
	}
}

void CMainFrame::OnViewToggle() 
{
	// TODO: Add your command handler code here
	int nRow,nCol;
	if( !m_wndSplitter.GetActivePane(&nRow,&nCol) )
		return;
	ASSERT( nRow == 0 );
	ASSERT( nCol <= 1 );
	m_wndSplitter.SetActivePane(0,1-nCol, NULL);	
}

void CMainFrame::OnViewRefresh() 
{
	RefreshAll( NULL, NULL, NULL );	
}

void CMainFrame::OnActivateApp(BOOL bActive, HTASK hTask) 
{
	CFrameWnd::OnActivateApp(bActive, hTask);
	
	// TODO: Add your message handler code here

	if( bActive )
	{
		if( m_bEnableAutoRefresh )
		{
			TRACE( _T("OnActivateApp AutoRefresh\n") );
			RefreshAll();
		}
		else
			m_bAutoRefreshRequested = TRUE;
	}
	
}

void CMainFrame::OnDestroy() 
{
	if( m_unTimer )
		KillTimer( m_unTimer );

	CFrameWnd::OnDestroy();
	
	// TODO: Add your message handler code here
	
}

void CMainFrame::OnTimer(UINT nIDEvent) 
{
	// TODO: Add your message handler code here and/or call default
	if( ( nIDEvent == ID_TIMER_EVENT ) && m_bEnableAutoRefresh && ( GetActiveWindow() == this ) )
	{
		//TRACE("OnTimer\n");
		CFTTreeView* pTreeView = GetLeftPane();
		pTreeView->RefreshOnTimer();		
	}
	
	CFrameWnd::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Global functions related to the main frame

/*
Global function:	RefreshAll

Purpose:			Refreshes the content of both views of the mainframe by keeping ( when possible ) 
					the expanded and selected items.
					It is also possible to change the selected items and to add some expanded items
					
Parameters:			[IN] CItemIDSet *psetAddTreeExpandedItems
						Items to add to the currently expanded items set
					[IN] CItemIDSet *psetTreeSelectedItems 
						Items to select in the tree ( the currently selected items are neglected )
					[IN] CItemIDSet *psetListSelectedItems 
						Items to select in the list ( the currently selected items are neglected )

Return value:		TRUE if the refresh operation succeeded
*/

BOOL AfxRefreshAll(
					CItemIDSet* psetAddTreeExpandedItems	/* =NULL */ ,
					CItemIDSet* psetTreeSelectedItems		/* =NULL */,
					CItemIDSet* psetListSelectedItems		/* =NULL */ )
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	return pFrame->RefreshAll( psetAddTreeExpandedItems, psetTreeSelectedItems, psetListSelectedItems );
}

/*
Global function:	AfxEnableAutoRefresh()

Purpose:			Enables / Disables the auto refresh of both views of the mainframe on WM_ACTIVATEAPP
					
Parameters:			[IN] BOOL bEnable
						Specifies whether the auto-refresh is to be enabled or disabled
					

Return value:		The previous status of the auto-refresh flag
*/

BOOL AfxEnableAutoRefresh( BOOL bEnable /* =TRUE */ )
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	BOOL bPrevious = pFrame->m_bEnableAutoRefresh;
	
	// If the flag is enabling and an auto-refresh request came while it was disabled then proceed with auto-refresh
	if( bEnable && !bPrevious && pFrame->m_bAutoRefreshRequested)
	{
		TRACE( _T("Late OnActivateApp AutoRefresh\n") );
		AfxRefreshAll();
	}
	else if ( !bEnable && bPrevious )
		pFrame->m_bAutoRefreshRequested = FALSE;

	pFrame->m_bEnableAutoRefresh = bEnable;

	return bPrevious;
}


BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{
	// TODO: Add your specialized code here and/or call the base class
	switch( nID )
	{
		case ID_VIEW_UP:
		case ID_INDICATOR_NAME:
		case ID_INDICATOR_TYPE:
		case ID_INDICATOR_DISKS:
		case ID_INDICATOR_SIZE:
		case ID_INDICATOR_NOTHING:
			CFTTreeView* pTreeView = GetLeftPane();
			return pTreeView->OnCmdMsg( nID, nCode, pExtra, pHandlerInfo );

	}
	
	return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\phpart.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	PhPart.h

Abstract:

    The definition of class CPhysicalPartitionData. The class that stores all information related
	to a physical partition

Author:

    Cristian Teodorescu      October 23, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_PHPART_H_INCLUDED_)
#define AFX_PHPART_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <winioctl.h>

#include "Item.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CPhysicalPartitionData

class CPhysicalPartitionData : public CItemData
{
public:
	// Constructor providing the partition information
	CPhysicalPartitionData( 
					DWORD			dwDiskNumber, 
					DWORD			dwSignature, 
					const PPARTITION_INFORMATION	pPartInfo, 
					PARTITION_TYPE	wPartitionType,
					CItemData*		pParentData = NULL,
					BOOL			bIsRootVolume = FALSE );
	virtual ~CPhysicalPartitionData() {};
	
// Operations
public: 
	virtual BOOL ReadItemInfo( CString& strErrors );

	virtual BOOL ReadMembers( CObArray& arrMembersData, CString& strErrors );

	virtual int ComputeImageIndex() const;

	virtual BOOL operator==(CItemData& rData) const;

	// Provide item properties
	virtual void GetDisplayName( CString& strDisplay ) const;
	virtual void GetDisplayType( CString& strDisplay ) const ;
	virtual BOOL GetSize( LONGLONG& llSize ) const;
	virtual BOOL GetDiskNumber( ULONG& ulDiskNumber ) const;
	virtual BOOL GetOffset( LONGLONG& llOffset) const;

	BOOL IsFTPartition() const;
	
//Data members
public:	
	DWORD					m_dwDiskNumber;
	DWORD					m_dwSignature;
	PARTITION_INFORMATION	m_PartInfo;
	PARTITION_TYPE			m_wPartitionType;

protected:
	virtual BOOL RetrieveNTName( CString& strNTName ) const;
	virtual BOOL RetrieveDisksSet();
};

#endif // !defined(AFX_PHPART_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\rootfree.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	RootFree.cpp

Abstract:

    Implementation of the CRootFreeSpacesData class. The class who stores the properties of the "fake" root of the
	free space tree

Author:

    Cristian Teodorescu      October 22, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "DiskMap.h"
#include "FrSpace.h"
#include "Resource.h"
#include "RootFree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// CRootFreeSpacesData

// Constructor
CRootFreeSpacesData::CRootFreeSpacesData() : CItemData( IT_RootFreeSpaces, NULL, FALSE )
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Public methods

BOOL CRootFreeSpacesData::ReadItemInfo( CString& strErrors )
{
	MY_TRY

	m_bValid = TRUE;
	strErrors = _T("");
	
	m_ulNumMembers = 1;				// Just to notify the tree that this item has children

	m_iImage = ComputeImageIndex();

	return m_bValid;

	MY_CATCH_AND_THROW
}

BOOL CRootFreeSpacesData::ReadMembers( CObArray& arrMembersData, CString& strErrors )
{
	MY_TRY

	BOOL	bReturn = TRUE;
	
	arrMembersData.RemoveAll();
	strErrors = _T("");	
	
	m_ulNumMembers = 0;

	CDiskMap diskMap;
	for( DWORD dwDiskNumber = 0; ; dwDiskNumber++ )
	{
		CObArray arrFreeSpaces;
		CString strDiskMapErrors;
		BOOL	bMissingDisk;

		diskMap.SetDiskNumber(dwDiskNumber);
		BOOL bResult = diskMap.ReadFreeSpaces( arrFreeSpaces, strDiskMapErrors, bMissingDisk, this );
		strErrors += strDiskMapErrors;

		if( !bResult )
		{
			if( bMissingDisk )  // It's over. There are no more disks in the system
				break;
			else				// Continue with the following disk
			{
				bReturn = FALSE;
				continue;
			}

		}

		arrMembersData.Append(arrFreeSpaces);
		m_ulNumMembers += (ULONG)arrFreeSpaces.GetSize();
	}
		
	return bReturn;

	MY_CATCH_AND_THROW
}

int CRootFreeSpacesData::ComputeImageIndex() const
{
	return II_Root;
}

BOOL CRootFreeSpacesData::operator==(CItemData& rData) const
{
	return(rData.GetItemType() == IT_RootFreeSpaces );
}

void CRootFreeSpacesData::GetDisplayName( CString& strDisplay ) const
{	
	MY_TRY

	strDisplay.LoadString(IDS_ROOT_FREE_SPACES_DISPLAY_NAME);

	MY_CATCH_AND_THROW
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\mainfrm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	MainFrm.h

Abstract:

    The definition of class CMainFrame. It is the MFC main frame class for this application

Author:

    Cristian Teodorescu      October 20, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__B83DFFFF_6873_11D2_A297_00A0C9063765__INCLUDED_)
#define AFX_MAINFRM_H__B83DFFFF_6873_11D2_A297_00A0C9063765__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "FTManDef.h"

class CFTTreeView;
class CFTListView;
class CItemData;

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
public:
	// Enables auto refresh of both views on WM_ACTIVATEAPP
	BOOL	m_bEnableAutoRefresh;

	// Did some auto refresh request come while the auto refresh flag was disabled?
	BOOL	m_bAutoRefreshRequested;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
	CFTTreeView* GetLeftPane();
	CFTListView* GetRightPane();
	CStatusBar* GetStatusBar() { return &m_wndStatusBar; };

	// Refreshes the content of both views by keeping ( when possible ) the expanded and
	// selected items.
	// It is also possible to change the selected items and to add some expanded items
	BOOL RefreshAll(
					CItemIDSet* psetAddTreeExpandedItems = NULL,
					CItemIDSet* psetTreeSelectedItems = NULL,
					CItemIDSet* psetListSelectedItems = NULL );

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

	UINT_PTR    m_unTimer;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnViewToggle();
	afx_msg void OnViewRefresh();
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	afx_msg void OnDestroy();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Global functions related to CMainFrame

// Refreshes the content of both views of the mainframe by keeping ( when possible )
// the expanded and selected items.
// It is also possible to change the selected items and to add some expanded items
BOOL AfxRefreshAll(
					CItemIDSet* psetAddTreeExpandedItems = NULL,
					CItemIDSet* psetTreeSelectedItems = NULL,
					CItemIDSet* psetListSelectedItems = NULL );

// Enables / Disables the auto refresh of both views of the mainframe on WM_ACTIVATEAPP
BOOL AfxEnableAutoRefresh( BOOL bEnable = TRUE );


// Class AutoRefresh - a easier way to disable / enable the auto-refresh flag inside a code block
// On constructor enables or disables the Auto refresh flag
// On destructor restores the old Auto refresh flag
class CAutoRefresh
{
public:
	CAutoRefresh( BOOL bEnable = FALSE ) { m_bPrevious = AfxEnableAutoRefresh(bEnable); };
	~CAutoRefresh() { AfxEnableAutoRefresh( m_bPrevious ); };

protected:
	BOOL m_bPrevious;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__B83DFFFF_6873_11D2_A297_00A0C9063765__INCLUDED_)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ftman.rc
//
#define IDR_MAINFRAME                   100
#define IDR_FTMANTYPE                   101
#define IDB_IMAGELIST                   102
#define IDB_IMAGELIST_LARGE             103
#define ID_INDICATOR_NAME               103
#define IDB_IMAGELIST_SMALL             104
#define ID_INDICATOR_TYPE               104
#define IDD_ABOUTBOX                    105
#define ID_INDICATOR_DISKS              105
#define IDD_GENERIC_ACTION              106
#define ID_INDICATOR_SIZE               106
#define IDD_CREATE_VOLSET               107
#define ID_INDICATOR_NOTHING            107
#define IDD_CREATE_STRIPE               108
#define IDD_CREATE_SWP                  109
#define IDD_CREATE_MIRROR               110
#define IDD_BREAK                       111
#define IDD_SWAP                        112
#define IDD_ASSIGN_DRIVE_LETTER         113
#define ID_VIEW_ARRANGE                 114
#define IDD_CREATE_PARTITION            115
#define IDM_POPUP                       116
#define IDC_LIST_VOLUMES                1002
#define IDC_STATIC_VOLUMES              1003
#define IDC_STATIC_WARNING              1004
#define IDC_BUTTON_UP                   1005
#define IDC_BUTTON_DOWN                 1006
#define IDC_COMBO_STRIPE_SIZE           1011
#define IDC_STATIC_SET_NAME             1012
#define IDC_STATIC_TITLE                1013
#define IDC_RADIO_ASSIGN                1014
#define IDC_RADIO_DO_NOT_ASSIGN         1015
#define IDC_COMBO_DRIVE_LETTERS         1016
#define IDC_STATIC_MINIMUM_SIZE         1017
#define IDC_STATIC_MAXIMUM_SIZE         1018
#define IDC_EDIT_PARTITION_SIZE         1019
#define IDC_STATIC_PARTITION_TYPE       1021
#define ID_ITEM_EXPAND                  32771
#define ID_VIEW_TOGGLE                  32772
#define ID_ACTION_FTPART                32773
#define ID_ACTION_FTMIRROR              32774
#define ID_ACTION_FTVOLSET              32775
#define ID_ACTION_STRIPE                32776
#define ID_ACTION_FTSTRIPE              32777
#define ID_ACTION_FTSWP                 32778
#define ID_ACTION_FTBREAK               32779
#define ID_ACTION_ASSIGN                32780
#define ID_ACTION_FTSWAP                32781
#define ID_ACTION_DELETE                32782
#define ID_VIEW_REFRESH                 32783
#define ID_ACTION_CREATE_PARTITION      32784
#define ID_ACTION_CREATE_EXTENDED_PARTITION 32785
#define ID_VIEW_UP                      32786
#define ID_ACTION_FTINIT                32787
#define IDS_ERR_RETRIEVING_VOL_INFO     57346
#define IDS_ERR_ENUMERATE_ROOT_VOLS     57347
#define IDS_ROOT_VOLUMES_DISPLAY_NAME   57348
#define IDS_ERR_GET_DRIVE_LAYOUT        57349
#define IDS_ERR_MEMBER_NOT_FOUND_ANYMORE 57350
#define IDS_COLUMN_NAME                 57351
#define IDS_COLUMN_VOLUMEID             57352
#define IDS_COLUMN_SIZE                 57353
#define IDS_COLUMN_DISKS                57354
#define IDS_COLUMN_OFFSET               57355
#define IDS_COLUMN_TYPE                 57356
#define IDS_TYPE_FTPARTITION            57357
#define IDS_TYPE_FTVOLUMESET            57358
#define IDS_TYPE_FTSTRIPESET            57359
#define IDS_TYPE_FTMIRRORSET            57360
#define IDS_TYPE_FTSTRIPESETWITHPARITY  57361
#define IDS_TYPE_FTREDISTRIBUTION       57362
#define IDS_TYPE_PHYSICALPARTITION      57363
#define IDS_MSG_FTCHKIO                 57364
#define IDS_OK                          57365
#define IDS_NOTOK                       57366
#define IDS_ERR_FTCHKIO                 57367
#define IDS_STATUS_FTBREAK              57368
#define IDS_MSG_FTBREAK                 57369
#define IDS_ERR_FTBREAK                 57370
#define IDS_MSG_FTPART                  57371
#define IDS_ERR_FTPART                  57372
#define IDS_STATUS_FTSTRIPE             57373
#define IDS_MSG_FTSTRIPE                57374
#define IDS_ERR_FTSTRIPE                57375
#define IDS_ERR_ALLOCATION              57376
#define IDS_STATUS_FTSWP                57377
#define IDS_MSG_FTSWP                   57378
#define IDS_ERR_FTSWP                   57379
#define IDS_STATUS_FTMIRROR             57380
#define IDS_MSG_FTMIRROR                57381
#define IDS_ERR_FTMIRROR                57382
#define IDS_STATUS_FTVOLSET             57383
#define IDS_MSG_FTVOLSET                57384
#define IDS_ERR_FTVOLSET                57385
#define IDS_ACTION_DLG_CAPTION          57386
#define IDS_ERR_READ_DRIVE_LETTER_AND_VOLUME_NAME 57387
#define IDS_ERR_DELETE_LOGICAL_VOLUME   57388
#define IDS_QST_FTMIRROR                57389
#define IDS_ERR_READ_NT_NAME            57390
#define IDS_ERR_RETRIEVE_DISKS_SET      57392
#define IDS_ERR_FTEXTEND                57393
#define IDS_STATUS_FTORPHAN             57394
#define IDS_MSG_FTORPHAN                57395
#define IDS_ERR_FTORPHAN                57396
#define IDS_ERR_SET_DRIVE_LAYOUT        57397
#define IDS_QST_DELETE_VOLUME           57398
#define IDS_MSG_DELETE_VOLUME           57399
#define IDS_ERR_DELETE_PHYSICAL_PARTITION 57401
#define IDS_ERR_PARTITION_NOT_FOUND     57402
#define IDS_ERR_NO_REPLACEMENTS         57403
#define IDS_SWAP_DLG_TITLE              57404
#define IDS_STATUS_FTREGEN              57405
#define IDS_MSG_FTREGEN                 57406
#define IDS_ERR_FTREGEN                 57407
#define IDS_ERR_GET_LOGICAL_DRIVES      57408
#define IDS_ERR_DELETE_MOUNT_POINT      57409
#define IDS_ERR_SET_MOUNT_POINT         57410
#define IDS_MSG_ASSIGN                  57411
#define IDS_STATUS_REFRESH              57412
#define IDS_STR_PHYSICAL_PARTITION_NAME 57414
#define IDS_TYPE_PRIMARY_PARTITION      57415
#define IDS_TYPE_PARTITION_IN_EXTENDED_PARTITION 57416
#define IDS_FREE_SPACE_NAME             57417
#define IDS_TYPE_FREE_SPACE_IN_EXTENDED_PARTITION 57418
#define IDS_TYPE_EMPTY_EXTENDED_PARTITION 57419
#define IDS_QST_DELETE_EXTENDED_PARTITION 57420
#define IDS_ERR_FREE_SPACE_NOT_FOUND    57421
#define IDS_ERR_MISSING_DISK            57422
#define IDS_ERR_DELETE_EXTENDED_PARTITION 57423
#define IDS_MSG_DELETE_EXTENDED_PARTITION 57424
#define IDS_ERR_INVALID_SIZE            57425
#define IDS_MSG_CREATE_PARTITION        57426
#define IDS_ERR_CREATE_PARTITION        57427
#define IDS_ERR_PARTITION_TABLE_FULL    57428
#define IDS_TYPE_EXTENDED_PARTITION     57429
#define IDS_MSG_CREATE_EXTENDED_PARTITION 57430
#define IDS_ERR_CREATE_EXTENDED_PARTITION 57431
#define IDS_WRN_DATA_LOST               57432
#define IDS_ERR_CREATE_IMAGELIST        57433
#define IDS_ERR_FTINIT                  57434
#define IDS_MSG_FTINIT                  57435
#define IDS_STATUS_FTINIT               57436
#define IDS_QST_FTINIT                  57437
#define IDS_ROOT_FREE_SPACES_DISPLAY_NAME 57438
#define IDS_TYPE_FREE_SPACE             57439
#define IDS_ERR_GET_DRIVE_GEOMETRY      57440
#define IDS_ERR_CHECK_ADMINISTRATOR     57441
#define IDS_ERR_NOT_ADMINISTRATOR       57442
#define IDS_DISK                        57443
#define IDS_ERR_ANOTHER_EXTENDED_PARTITION 57444
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                    0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         32788
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\rootvol.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	RootVol.cpp

Abstract:

    Implementation of the CRootVolumesData class. The class who stores the properties of the "fake" root of the
	volumes tree

Author:

    Cristian Teodorescu      October 22, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "DiskMap.h"
#include "Global.h"
#include "LogVol.h"
#include "Resource.h"
#include "RootVol.h"

extern "C"
{
	#include <FTAPI.h>
}

#include <winioctl.h>
#include <basetyps.h>
#include <mountmgr.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// CRootVolumesData

// Constructor
CRootVolumesData::CRootVolumesData() : CItemData( IT_RootVolumes, NULL, FALSE )
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Public methods

BOOL CRootVolumesData::ReadItemInfo( CString& strErrors )
{
	MY_TRY

	m_bValid = TRUE;
	strErrors = _T("");
	
	m_ulNumMembers = 1;				// Just to notify the tree that this item has children
	
	m_iImage = ComputeImageIndex();

	return m_bValid;

	MY_CATCH_AND_THROW
}

BOOL CRootVolumesData::ReadMembers( CObArray& arrMembersData, CString& strErrors )
{
	MY_TRY

	BOOL	bReturn = TRUE;
	
	arrMembersData.RemoveAll();
	strErrors = _T("");
			
	// 1. Read all root logical volumes
		
	FT_LOGICAL_DISK_ID	diskId[100];

	if( FtEnumerateLogicalDisks(	100,
									diskId,
									&m_ulNumMembers ) )
	{
		for( ULONG i = 0; i < m_ulNumMembers; i++ )
		{
			// Create the logical volume item data
			CLogicalVolumeData* pData = new CLogicalVolumeData( diskId[i], this, TRUE );
			// Read logical volume info and collect errors ( if any )
			CString strMemberErrors;
			pData->ReadItemInfo( strMemberErrors );
			strErrors += strMemberErrors;
			// Add the structure to the members' data array
			arrMembersData.Add(pData);
		}
	}
	else
	{
		AddError( strErrors, IDS_ERR_ENUMERATE_ROOT_VOLS, TRUE );
		bReturn = FALSE;
		m_ulNumMembers = 0;
	}

	// 2. Read all physical partitions not promoted as logical volumes

	CDiskMap diskMap;
	for( DWORD dwDiskNumber = 0; ; dwDiskNumber++ )
	{
		CObArray arrPartitions;
		CString strDiskMapErrors;
		BOOL	bMissingDisk;

		diskMap.SetDiskNumber(dwDiskNumber);
		BOOL bResult = diskMap.ReadPartitions( arrPartitions, strDiskMapErrors, bMissingDisk, this );
		strErrors += strDiskMapErrors;

		if( !bResult )
		{
			if( bMissingDisk )  // It's over. There are no more disks in the system
				break;
			else				// Continue with the following disk
			{
				bReturn = FALSE;
				continue;
			}

		}

		arrMembersData.Append(arrPartitions);
		m_ulNumMembers += (ULONG)arrPartitions.GetSize();
	}	
	
	// 3. Read all mount paths for every member
	QueryMountList( arrMembersData );

	return bReturn;

	MY_CATCH_AND_THROW
}

int CRootVolumesData::ComputeImageIndex() const
{
	return II_Root;
}

BOOL CRootVolumesData::operator==(CItemData& rData) const
{
	return(rData.GetItemType() == IT_RootVolumes );
}

void CRootVolumesData::GetDisplayName( CString& strDisplay ) const
{	
	MY_TRY

	strDisplay.LoadString(IDS_ROOT_VOLUMES_DISPLAY_NAME);

	MY_CATCH_AND_THROW
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\rootfree.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	RootFree.h

Abstract:

    The definition of class CRootFreeSpacesData. The class who stores the properties of the "fake" root of the 
	free space tree

Author:

    Cristian Teodorescu      October 22, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ROOTFREE_H_INCLUDED_)
#define AFX_ROOTFREE_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Item.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CRootFreeSpacesData

class CRootFreeSpacesData : public CItemData
{
public:
	// Constructor
	CRootFreeSpacesData();
	virtual ~CRootFreeSpacesData() {};
	
// Operations
public: 
	virtual BOOL ReadItemInfo( CString& strErrors );

	virtual BOOL ReadMembers( CObArray& arrMembersData, CString& strErrors );

	virtual int ComputeImageIndex() const;

	virtual BOOL operator==(CItemData& rData) const;

	// Provide item properties
	virtual void GetDisplayName( CString& strDisplay ) const;
	
//Data members
public:	

// Protected methods
protected:

};

#endif // !defined(AFX_ROOTFREE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\phpart.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	PhPart.cpp

Abstract:

    Implementation of the CPhysicalPartitionData class. The class that stores all information related
	to a physical partition

Author:

    Cristian Teodorescu      October 23, 1998

Notes:

Revision History:

--*/

#include "stdafx.h"

#include "Global.h"
#include "MainFrm.h"
#include "PhPart.h"
#include "Resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// CPhysicalPartitionData

// Constructor
CPhysicalPartitionData::CPhysicalPartitionData( 
							DWORD			dwDiskNumber, 
							DWORD			dwSignature, 
							const PPARTITION_INFORMATION pPartInfo, 
							PARTITION_TYPE	wPartitionType,
							CItemData*		pParentData /* = NULL */,
							BOOL			bIsRootVolume /* = FALSE */ ) 
	: CItemData( IT_PhysicalPartition, pParentData, bIsRootVolume ), m_dwDiskNumber(dwDiskNumber), 
		m_dwSignature(dwSignature), m_wPartitionType( wPartitionType )
{
	ASSERT( pPartInfo );
	memcpy(&m_PartInfo, pPartInfo, sizeof(PARTITION_INFORMATION) );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Public methods

BOOL CPhysicalPartitionData::ReadItemInfo( CString& strErrors )
{
	MY_TRY

	m_bValid = TRUE;
	strErrors = _T("");
	
	m_ulNumMembers = 0;	
	
	// Read the drive letter, volume name and mount paths ( if any )
	if( !ReadDriveLetterAndVolumeName() )
	{
		//AddError( strErrors, IDS_ERR_READ_DRIVE_LETTER_AND_VOLUME_NAME, FALSE );
		m_bValid = FALSE;
	}

	// The mount paths will be retrieved later together with all other siblings mount paths ( for performance reason )
	m_arrMountPaths.RemoveAll();
	
	// Retrieve all disks used by this volume
	if( !RetrieveDisksSet() )
	{
		AddError( strErrors, IDS_ERR_RETRIEVE_DISKS_SET, FALSE );
		m_bValid = FALSE;
	}

	m_bIoOK = TRUE;

	m_iImage = ComputeImageIndex();
	
	return m_bValid;

	MY_CATCH_AND_THROW
}

BOOL CPhysicalPartitionData::ReadMembers( CObArray& arrMembersData, CString& strErrors )
{
	MY_TRY

	arrMembersData.RemoveAll();
	strErrors = _T("");
	m_ulNumMembers = 0;
	return TRUE;

	MY_CATCH_AND_THROW
}

int CPhysicalPartitionData::ComputeImageIndex() const
{
	if( m_bValid && m_bIoOK )
		return II_PhysicalPartition;  
	else
		return II_PhysicalPartition_Error;
}

BOOL CPhysicalPartitionData::operator==(CItemData& rData) const
{
	if( rData.GetItemType() != IT_PhysicalPartition )
		return FALSE;

	CPhysicalPartitionData* pPhPartData = (CPhysicalPartitionData*)(&rData);

	return( ( m_dwDiskNumber == pPhPartData->m_dwDiskNumber ) &&
			( m_PartInfo.StartingOffset.QuadPart == pPhPartData->m_PartInfo.StartingOffset.QuadPart ) &&
			( m_PartInfo.PartitionLength.QuadPart == pPhPartData->m_PartInfo.PartitionLength.QuadPart ) );
}

void CPhysicalPartitionData::GetDisplayName( CString& strDisplay ) const 
{		
	MY_TRY

	strDisplay = _T("");
	for( int i = 0; i < m_arrMountPaths.GetSize(); i++ )
	{
		if( i != 0 )
			strDisplay += _T("; ");
		strDisplay += m_arrMountPaths[i];
	}

	if( strDisplay.IsEmpty() )
	{
		if( m_cDriveLetter )
			strDisplay.Format(_T("%c:"), m_cDriveLetter );
		/*
		else
			strDisplay.Format( IDS_STR_PHYSICAL_PARTITION_NAME, 
							m_dwDiskNumber, m_PartInfo.PartitionNumber );
		*/
	}

	CString str;
	str.Format( IDS_STR_PHYSICAL_PARTITION_NAME, 
							m_dwDiskNumber, m_PartInfo.PartitionNumber );
	if( !strDisplay.IsEmpty() )
		strDisplay += ("  ");
	strDisplay += str;

	MY_CATCH_AND_THROW
}

void CPhysicalPartitionData::GetDisplayType( CString& strDisplay ) const 
{
	MY_TRY

	switch( m_wPartitionType )
	{
		case PT_Primary:
			strDisplay.LoadString( IDS_TYPE_PRIMARY_PARTITION);
			break;
		case PT_InExtendedPartition:
			strDisplay.LoadString( IDS_TYPE_PARTITION_IN_EXTENDED_PARTITION);
			break;
		default:
			ASSERT(FALSE);
	}

	MY_CATCH_AND_THROW
}

BOOL CPhysicalPartitionData::GetSize( LONGLONG& llSize ) const
{
	llSize  = m_PartInfo.PartitionLength.QuadPart;
	return TRUE;
}

BOOL CPhysicalPartitionData::GetDiskNumber( ULONG& ulDiskNumber ) const
{
	ulDiskNumber  = m_dwDiskNumber;
	return TRUE;
}

BOOL CPhysicalPartitionData::GetOffset( LONGLONG& llOffset) const
{
	llOffset = m_PartInfo.StartingOffset.QuadPart;
	return TRUE;
}

BOOL CPhysicalPartitionData::IsFTPartition() const
{
	// FT partitions have the most significant bit of PartitionType equal with 1
	return ( ( m_PartInfo.PartitionType & 0x80 ) != 0 );
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Protected methods

BOOL CPhysicalPartitionData::RetrieveNTName( CString& strNTName ) const
{
	MY_TRY

	strNTName.Format(_T("\\Device\\Harddisk%lu\\Partition%lu"), m_dwDiskNumber, m_PartInfo.PartitionNumber );
	return TRUE;

	MY_CATCH_AND_THROW
}

BOOL CPhysicalPartitionData::RetrieveDisksSet()
{
	MY_TRY

	m_setDisks.RemoveAll();
	m_setDisks.Add( m_dwDiskNumber );
	return TRUE;

	MY_CATCH_AND_THROW
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	FTMan.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftorphan\ftorphan.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_LOGICAL_DISK_ID  diskId;
    int                 memberNumber;
    BOOL                b;

    if (argc != 3) {
        printf("usage: %s <diskId> <memberNumber>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);
    sscanf(argv[2], "%d", &memberNumber);

    printf("Orphaning member %d on %I64X...\n", memberNumber, diskId);

    b = FtOrphanLogicalDiskMember(diskId, (WORD) memberNumber);

    if (b) {
        printf("Member orphaned.\n");
    } else {
        printf("Orphaning failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftonline\ftonline.c ===
#include <windows.h>
#include <stdio.h>
#include <winioctl.h>
#include <ntddvol.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR   driveName[7];
    HANDLE  h;
    BOOL    b;
    DWORD   bytes;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = argv[1][0];
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFileW(driveName, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, INVALID_HANDLE_VALUE);

    if (h == INVALID_HANDLE_VALUE) {
        printf("Open of drive %c: failed with %d\n", argv[1][0], GetLastError());
        return;
    }

    b = DeviceIoControl(h, IOCTL_VOLUME_ONLINE, NULL, 0, NULL, 0, &bytes,
                        NULL);
    if (b) {
        printf("Online succeeded.\n");
    } else {
        printf("Online failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftmirror\ftmirror.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_MIRROR_SET_CONFIGURATION_INFORMATION config;
    int                                     i;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      diskId[2], newDiskId;
    LONGLONG                                memberSize, zeroMemberSize;

    if (argc != 3) {
        printf("usage: %s <diskId1> <diskId2>\n", argv[0]);
        return;
    }

    config.MemberSize = MAXLONGLONG;

    printf("Creating a mirror set for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);

        b = FtQueryLogicalDiskInformation(diskId[i - 1], NULL, &memberSize,
                                          0, NULL, NULL, 0, NULL, 0, NULL);
        if (!b) {
            printf("Could not query disk info, error = %d\n", GetLastError());
            return;
        }

        if (memberSize < config.MemberSize) {
            config.MemberSize = memberSize;
        }

        if (i == 1) {
            zeroMemberSize = memberSize;
        }
    }
    printf(" ...\n");

    if (memberSize < zeroMemberSize) {
        printf("First member too big.\n");
        return;
    }

    b = FtCreateLogicalDisk(FtMirrorSet, 2, diskId, sizeof(config), &config,
                            &newDiskId);

    if (b) {
        printf("Mirror %I64X created.\n", newDiskId);
    } else {
        printf("Mirror create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\rootvol.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	RootVol.h

Abstract:

    The definition of class CRootVolumesData. The class who stores the properties of the "fake" root of the 
	volumes tree

Author:

    Cristian Teodorescu      October 22, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ROOTVOL_H_INCLUDED_)
#define AFX_ROOTVOL_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Item.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Class CRootVolumesData

class CRootVolumesData : public CItemData
{
public:
	// Constructor
	CRootVolumesData();
	virtual ~CRootVolumesData() {};
	
// Operations
public: 
	virtual BOOL ReadItemInfo( CString& strErrors );

	virtual BOOL ReadMembers( CObArray& arrMembersData, CString& strErrors );

	virtual int ComputeImageIndex() const;

	virtual BOOL operator==(CItemData& rData) const;

	// Provide item properties
	virtual void GetDisplayName( CString& strDisplay ) const;
	
//Data members
public:	

// Protected methods
protected:

};

#endif // !defined(AFX_ROOTVOL_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B83DFFFD_6873_11D2_A297_00A0C9063765__INCLUDED_)
#define AFX_STDAFX_H__B83DFFFD_6873_11D2_A297_00A0C9063765__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500

#undef _WIN32_IE
#define _WIN32_IE 0x0400

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers


#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
//#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B83DFFFD_6873_11D2_A297_00A0C9063765__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftpart\ftpart.c ===
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                                   driveName[7];
    HANDLE                                  h;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      newDiskId;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = argv[1][0];
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFileW(driveName, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, INVALID_HANDLE_VALUE);

    if (h == INVALID_HANDLE_VALUE) {
        printf("Open of drive %c: failed with %d\n", argv[1][0], GetLastError());
        return;
    }

    b = FtCreatePartitionLogicalDisk(h, &newDiskId);
    CloseHandle(h);

    if (b) {
        printf("Partition created with logical disk id %I64X\n", newDiskId);
    } else {
        printf("Partition create failed with %d\n", GetLastError());
    }

    FtSetStickyDriveLetter(newDiskId, (UCHAR) toupper(argv[1][0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftman\set.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FTMan

File Name:

	Set.h

Abstract:

    Definition and implementation of template class CSet.
	CSet is a set of elements of the same type. The type of the elements must have a equivalence operator ("==")
	defined.
	No duplicate elements are allowed in the set. The elements are stored in ascendent sort order
	Main set operations:
		- Reunion
		- Intersection
		- Difference

Author:

    Cristian Teodorescu      November 4, 1998

Notes:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SET_H_INCLUDED_)
#define AFX_SET_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <afxtempl.h>

template< class TYPE, class ARG_TYPE >
class CSet : protected CArray<TYPE, ARG_TYPE>
{
// Public constructors
public:
	CSet() {};
	CSet( const CSet& set );

// Public operations
public:
	// Check if the set is empty
	BOOL IsEmpty() const;

	// Get the size of the set
	int GetSize( ) const;

	// Check if an element is in the set
	BOOL InSet( ARG_TYPE elm ) const;	
	
	// Add a element to the set
	void Add( ARG_TYPE elm );

	// Remove a element from the set
	void Remove( ARG_TYPE elm );

	// Remove all elements from the set
	void RemoveAll();

	// Subscript operator
	TYPE operator []( int nIndex ) const;
	
	// Assignment operator
	void operator=( const CSet& set );

	// Reunion of two sets
	void operator+=( const CSet& set );
	//const CSet& operator+( const CSet& set ) const;

	// Intersection of two sets
	void operator*=(const CSet& set );
	//const CSet& operator*( const CSet& set ) const;
	
	// Difference of two sets
	void operator-=( const CSet& set );
	//const CSet& operator-( const CSet& set ) const;
};

// Off-line methods

// Copy constructor
template< class TYPE, class ARG_TYPE >
CSet<TYPE, ARG_TYPE>::CSet( const CSet& set )
{
	MY_TRY

	for( int i = 0; i < set.GetSize(); i++ )
		CArray<TYPE, ARG_TYPE>::Add( set[i] );
	
	MY_CATCH_AND_THROW
}

// Check if the set is empty
template< class TYPE, class ARG_TYPE >
BOOL CSet<TYPE, ARG_TYPE>::IsEmpty() const
{
	return ( GetSize() == 0 );
}

template< class TYPE, class ARG_TYPE >
int CSet<TYPE, ARG_TYPE>::GetSize() const
{
	return (int)CArray<TYPE, ARG_TYPE>::GetSize();
}

// Check if an element is in the set
template< class TYPE, class ARG_TYPE >
BOOL CSet<TYPE, ARG_TYPE>::InSet( ARG_TYPE elm ) const
{
	// The array is sorted !!
	for( int i = 0; i < GetSize(); i++ )
	{
		if( GetAt(i) > elm )
			return FALSE;
		else if( GetAt(i) == elm )
			return TRUE;
	}
	return FALSE;
}
	
// Add a element to the set
template< class TYPE, class ARG_TYPE >
void CSet<TYPE, ARG_TYPE>::Add( ARG_TYPE elm )
{
	MY_TRY

	// No duplicates are allowed
	// The new element is inserted in the right place in the ascending sorted array
	for( int i = 0; i < GetSize(); i++ )
	{
		if( GetAt(i) > elm )
			break;
		else if( GetAt(i) == elm )
			return;
	}
	
	InsertAt( i, elm );

	MY_CATCH_AND_THROW
}

// Remove a element from the set
template< class TYPE, class ARG_TYPE >
void CSet<TYPE, ARG_TYPE>::Remove( ARG_TYPE elm )
{
	// The array is sorted !!
	for( int i = 0; i < GetSize(); i++ )
	{
		if( GetAt(i) > elm )
			return;
		else if( GetAt(i) == elm )
		{
			RemoveAt(i);
			return;
		}
	}
}

// Remove all elements from the set
template< class TYPE, class ARG_TYPE >
void CSet<TYPE, ARG_TYPE>::RemoveAll()
{
	CArray<TYPE, ARG_TYPE>::RemoveAll();
}

// Subscript operator
template< class TYPE, class ARG_TYPE >
TYPE CSet<TYPE, ARG_TYPE>::operator []( int nIndex ) const
{
	return CArray<TYPE, ARG_TYPE>::operator[]( nIndex );
}

// Assignment operator
template< class TYPE, class ARG_TYPE >
void CSet<TYPE, ARG_TYPE>::operator=( const CSet& set )
{
	MY_TRY

	RemoveAll();
	for( int i = 0; i < set.GetSize(); i++ )
		CArray<TYPE, ARG_TYPE>::Add( set[i] );

	MY_CATCH_AND_THROW

}

// Reunion of two sets.  The result is stored in the first operand
template< class TYPE, class ARG_TYPE >
void CSet<TYPE, ARG_TYPE>::operator+=( const CSet& set )
{
	MY_TRY

	for( int i = 0; i < set.GetSize(); i++ )
		Add( set[i] );

	MY_CATCH_AND_THROW
}

// Reunion of two sets.  The result is stored in a third set
/*
template< class TYPE, class ARG_TYPE >
const CSet<TYPE, ARG_TYPE>& CSet<TYPE, ARG_TYPE>::operator+( const CSet& set ) const
{
}
*/

// Intersection of two sets.  The result is stored in the first operand
template< class TYPE, class ARG_TYPE >
void CSet<TYPE, ARG_TYPE>::operator*=( const CSet& set )
{
	for( int i = GetSize()-1; i >= 0; i-- )
	{
		ARG_TYPE elm = GetAt(i);
		if( !set.InSet(elm) )
			RemoveAt(i);
	}
}

// Intersection of two sets.  The result is stored in a third set
/*
template< class TYPE, class ARG_TYPE >
const CSet<TYPE, ARG_TYPE>& CSet<TYPE, ARG_TYPE>::operator*( const CSet& set ) const
{
}
*/

// Difference of two sets.  The result is stored in the first operand
template< class TYPE, class ARG_TYPE >
void CSet<TYPE, ARG_TYPE>::operator-=( const CSet& set )
{
	for( int i = GetSize()-1; i >= 0; i-- )
	{
		ARG_TYPE elm = GetAt(i);
		if( set.InSet(elm) )
			RemoveAt[i];
	}	
}

// Difference of two sets.  The result is stored in a third set
/*
template< class TYPE, class ARG_TYPE >
const CSet<TYPE, ARG_TYPE>& CSet<TYPE, ARG_TYPE>::operator-( const CSet& set ) const
{
}
*/

#endif // !defined(AFX_SET_H_INCLUDED_)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftstripe\ftstripe.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    int                                     i;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      diskId[100], newDiskId;
    FT_STRIPE_SET_CONFIGURATION_INFORMATION configInfo;

    if (argc < 3) {
        printf("usage: %s <diskId1> <diskId2> ...\n", argv[0]);
        return;
    }

    printf("Creating a stripe for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);
    }
    printf(" ...\n");

    configInfo.StripeSize = 0x10000;

    b = FtCreateLogicalDisk(FtStripeSet, (WORD) (argc - 1), diskId,
                            sizeof(configInfo), &configInfo, &newDiskId);

    if (b) {
        printf("Stripe %I64X created.\n", newDiskId);
    } else {
        printf("Stripe create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftredist\ftredist.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_LOGICAL_DISK_ID                          diskId[2], newDiskId;
    ULONG                                       weight1, weight2;
    FT_REDISTRIBUTION_CONFIGURATION_INFORMATION configInfo;
    BOOL                                        b;
    LONGLONG                                    volsize1, volsize2, newSize, rowSize, numRows, tmp;
    INT                                         d;
    CHAR                                        c;

    if (argc != 5) {
        printf("usage: %s <diskId1> <diskId2> <width1> <width2>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId[0]);
    sscanf(argv[2], "%I64X", &diskId[1]);
    sscanf(argv[3], "%d", &weight1);
    sscanf(argv[4], "%d", &weight2);

    if (weight1 >= 0x10000 || weight2 >= 0x10000) {
        printf("Weight too large.\n");
        return;
    }

    printf("Redistributing data on disk %I64X with disk %I64X\n",
           diskId[0], diskId[1]);
    printf("Weightings are %d for first disk and %d for second disk.\n",
           weight1, weight2);

    configInfo.StripeSize = 0x10000;
    configInfo.FirstMemberWidth = (USHORT) weight1;
    configInfo.SecondMemberWidth = (USHORT) weight2;

    b = FtQueryLogicalDiskInformation(diskId[0], NULL, &volsize1,
                                      0, NULL, NULL, 0, NULL, 0, NULL);
    if (!b) {
        printf("Invalid disk id.\n");
        return;
    }
    b = FtQueryLogicalDiskInformation(diskId[1], NULL, &volsize2,
                                      0, NULL, NULL, 0, NULL, 0, NULL);
    if (!b) {
        printf("Invalid disk id.\n");
        return;
    }

    printf("Total disk size before redistribution = %I64d\n", volsize1);

    rowSize = configInfo.StripeSize*(configInfo.FirstMemberWidth +
                                     configInfo.SecondMemberWidth);

    numRows = volsize1/(configInfo.StripeSize*configInfo.FirstMemberWidth);
    tmp = volsize2/(configInfo.StripeSize*configInfo.SecondMemberWidth);
    if (tmp < numRows) {
        numRows = tmp;
    }

    newSize = numRows*rowSize;

    printf("Total disk size after redistribution = %I64d\n", newSize);
    printf("Disk space wasted by redistribution = %I64d\n",
           volsize1 + volsize2 - newSize);

    if (newSize < volsize1) {
        printf("New size less than existing size.\n");
        return;
    }

    printf("\nPress <CTRL-C> to cancel operation...");

    c = getchar();

    printf("\nCreating redistribution...\n");

    b = FtCreateLogicalDisk(FtRedistribution, 2, diskId,
                            sizeof(configInfo), &configInfo, &newDiskId);

    if (b) {
        printf("Redistribution %I64X created.\n", newDiskId);
    } else {
        printf("Redistribution create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftregen\ftregen.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId, newMemberDiskId, newDiskId;
    int                 memberNumber;

    if (argc != 4) {
        printf("usage: %s <diskId> <memberNumber> <newMemberId>\n", argv[0]);
        return;
    }

    sscanf(argv[1], "%I64X", &diskId);
    sscanf(argv[2], "%d", &memberNumber);
    sscanf(argv[3], "%I64X", &newMemberDiskId);

    printf("Regenerating member %d of %I64X with %I64X...\n",
           memberNumber, diskId, newMemberDiskId);

    b = FtReplaceLogicalDiskMember(diskId, (WORD) memberNumber,
                                   newMemberDiskId, &newDiskId);

    if (b) {
        printf("Regenerate started on disk %I64X\n", newDiskId);
    } else {
        printf("Regenerate failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftvolset\ftvolset.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    int                                     i;
    BOOL                                    b;
    FT_LOGICAL_DISK_ID                      diskId[100], newDiskId;

    if (argc < 3) {
        printf("usage: %s <diskId1> <diskId2> ...\n", argv[0]);
        return;
    }

    printf("Creating a volume set for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);
    }
    printf(" ...\n");

    b = FtCreateLogicalDisk(FtVolumeSet, (WORD) (argc - 1), diskId,
                            0, NULL, &newDiskId);

    if (b) {
        printf("Volume set %I64X created.\n", newDiskId);
    } else {
        printf("Volume set create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftstate\ftstate.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void
PrintOutDiskInfo(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  WORD                Indent
    )

{
    BOOL                                            b;
    LONGLONG                                        volumeSize;
    FT_LOGICAL_DISK_TYPE                            diskType;
    FT_LOGICAL_DISK_ID                              members[100];
    WORD                                            numMembers;
    PCHAR                                           diskTypeString;
    WORD                                            i;
    CHAR                                            stateInfo[100];
    CHAR                                            configInfo[100];
    PFT_MIRROR_AND_SWP_STATE_INFORMATION            stripeState;
    PFT_PARTITION_CONFIGURATION_INFORMATION         partConfig;
    PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION    redistConfig;
    PFT_REDISTRIBUTION_STATE_INFORMATION            redistState;

    if (!LogicalDiskId) {
        for (i = 0; i < Indent; i++) {
            printf(" ");
        }
        printf("Disk not found.\n\n");
        return;
    }

    b = FtQueryLogicalDiskInformation(LogicalDiskId, &diskType, &volumeSize,
                                      100, members, &numMembers, 100,
                                      configInfo, 100, stateInfo);
    if (!b) {
        printf("Failure retrieving disk info, %d\n", GetLastError());
        return;
    }

    for (i = 0; i < Indent; i++) {
        printf(" ");
    }

    switch (diskType) {

        case FtPartition:
            diskTypeString = "FtPartition";
            partConfig = (PFT_PARTITION_CONFIGURATION_INFORMATION)
                         configInfo;
            printf("Disk %I64X is an %s on disk %d at offset %I64X\n",
                   LogicalDiskId, diskTypeString, partConfig->DiskNumber,
                   partConfig->ByteOffset);
            break;

        case FtVolumeSet:
            diskTypeString = "FtVolumeSet";
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            break;

        case FtStripeSet:
            diskTypeString = "FtStripeSet";
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            break;

        case FtMirrorSet:
            diskTypeString = "FtMirrorSet";
            stripeState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) stateInfo;
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            for (i = 0; i < Indent; i++) {
                printf(" ");
            }
            switch (stripeState->UnhealthyMemberState) {
                case FtMemberHealthy:
                    printf("Mirror set is healthy.\n");
                    break;

                case FtMemberRegenerating:
                    printf("Mirror set is regenerating member %d\n",
                           stripeState->UnhealthyMemberNumber);
                    break;

                case FtMemberOrphaned:
                    printf("Mirror set has orphaned member %d\n",
                           stripeState->UnhealthyMemberNumber);
                    break;

            }
            break;

        case FtStripeSetWithParity:
            diskTypeString = "FtStripeSetWithParity";
            stripeState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) stateInfo;
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            for (i = 0; i < Indent; i++) {
                printf(" ");
            }
            if (stripeState->IsInitializing) {
                printf("Stripe set with parity is initializing parity.\n");
            } else {
                switch (stripeState->UnhealthyMemberState) {
                    case FtMemberHealthy:
                        printf("Stripe set with parity is healthy.\n");
                        break;

                    case FtMemberRegenerating:
                        printf("Stripe set with parity is regenerating member %d\n",
                               stripeState->UnhealthyMemberNumber);
                        break;

                    case FtMemberOrphaned:
                        printf("Stripe set with parity has orphaned member %d\n",
                               stripeState->UnhealthyMemberNumber);
                        break;

                }
            }
            break;

        case FtRedistribution:
            diskTypeString = "FtRedistribution";
            redistConfig = (PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION) configInfo;
            redistState = (PFT_REDISTRIBUTION_STATE_INFORMATION) stateInfo;
            printf("Disk %I64X is an %s composed of %d members.\n",
                   LogicalDiskId, diskTypeString, numMembers);
            for (i = 0; i < Indent; i++) {
                printf(" ");
            }
            printf("Widths = (%d, %d), Bytes redistributed = %I64d\n",
                   redistConfig->FirstMemberWidth,
                   redistConfig->SecondMemberWidth,
                   redistState->BytesRedistributed);
            break;

    }

    for (i = 0; i < Indent; i++) {
        printf(" ");
    }

    printf("Disk size = %I64d\n\n", volumeSize);

    for (i = 0; i < numMembers; i++) {
        PrintOutDiskInfo(members[i], (WORD) (Indent + 4));
    }
}

void __cdecl
main(
    int argc,
    char** argv
    )

{
    BOOL                b;
    FT_LOGICAL_DISK_ID  diskId[100];
    DWORD               numDisks, i;
    UCHAR               driveLetter;
    WORD                l;

    b = FtEnumerateLogicalDisks(100, diskId, &numDisks);
    if (!b) {
        printf("Could not enumerate disks %d\n", GetLastError());
        return;
    }

    for (i = 0; i < numDisks; i++) {
        b = FtQueryStickyDriveLetter(diskId[i], &driveLetter);
        if (b && driveLetter) {
            printf("%c:\n", driveLetter);
        }
        PrintOutDiskInfo(diskId[i], 0);
        printf("\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\ftswp\ftswp.c ===
#include <windows.h>
#include <stdio.h>
#include <ftapi.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION config;
    int                                                 i;
    BOOL                                                b;
    FT_LOGICAL_DISK_ID                                  diskId[100], newDiskId;
    LONGLONG                                            memberSize;

    if (argc < 4) {
        printf("usage: %s <diskId1> <diskId2> <diskId3>...\n", argv[0]);
        return;
    }

    config.MemberSize = MAXLONGLONG;

    printf("Creating a stripe set with parity for");
    for (i = 1; i < argc; i++) {
        sscanf(argv[i], "%I64X", &diskId[i - 1]);
        printf(" %I64X", diskId[i - 1]);

        b = FtQueryLogicalDiskInformation(diskId[i - 1], NULL, &memberSize,
                                          0, NULL, NULL, 0, NULL, 0, NULL);
        if (!b) {
            printf("Could not query disk info, error = %d\n", GetLastError());
            return;
        }

        if (memberSize < config.MemberSize) {
            config.MemberSize = memberSize;
        }
    }
    printf(" ...\n");

    config.StripeSize = 0x10000;

    b = FtCreateLogicalDisk(FtStripeSetWithParity, (WORD) (argc - 1), diskId,
                            sizeof(config), &config, &newDiskId);

    if (b) {
        printf("Stripe set with parity %I64X created.\n", newDiskId);
    } else {
        printf("Stripe set with parity create failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\lib\ftapint.c ===
#include <nt.h>
#include <ntrtl.h>
#include <ntddft2.h>
#include <ftapi.h>


HANDLE
FtOpenPartition(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine opens the given logical disk.

Arguments:

    Signature   - Supplies the disk signature.

    Offset      - Supplies the partition offset.

Return Value:

    INVALID_HANDLE_VALUE    - Failure.

    Otherwise               - A handle to the given disk.

--*/

{
    UNICODE_STRING                                  string;
    OBJECT_ATTRIBUTES                               oa;
    NTSTATUS                                        status;
    HANDLE                                          handle;
    IO_STATUS_BLOCK                                 ioStatus;
    FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT     input;
    ULONG                                           outputSize;
    FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT    output[200];

    RtlInitUnicodeString(&string, L"\\Device\\FtControl");
    InitializeObjectAttributes(&oa, &string, OBJ_CASE_INSENSITIVE, 0, 0);
    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        return (HANDLE) -1;
    }

    input.Signature = Signature;
    input.Offset = Offset;
    outputSize = 200*sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT);
    status = NtDeviceIoControlFile(handle, 0, NULL, NULL, &ioStatus,
                                   FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION,
                                   &input, sizeof(input), output, outputSize);
    NtClose(handle);
    if (!NT_SUCCESS(status)) {
        return (HANDLE) -1;
    }

    string.MaximumLength = string.Length =
            output[0].NumberOfCharactersInNtDeviceName*sizeof(WCHAR);
    string.Buffer = output[0].NtDeviceName;

    InitializeObjectAttributes(&oa, &string, OBJ_CASE_INSENSITIVE, 0, 0);
    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        return (HANDLE) -1;
    }

    return handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\lib\ftapi.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ftapi.c

Abstract:

    This implements the FT API services.

Author:

    Norbert Kusters      16-May-1995

Notes:

Revision History:

--*/

#include <windows.h>
#include <winioctl.h>
#include <ntddft2.h>
#include <ftapi.h>

BOOL
FtCreatePartitionLogicalDisk(
    IN  HANDLE              PartitionHandle,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

/*++

Routine Description:

    This routine creates a new logical disk from a single partition.

Arguments:

    PartitionHandle     - Supplies a handle to the partition.

    NewLogicalDiskId    - Returns the new logical disk id.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    BOOL                                    b;
    FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT output;
    DWORD                                   bytes;

    b = DeviceIoControl(PartitionHandle, FT_CREATE_PARTITION_LOGICAL_DISK,
                        NULL, 0, &output, sizeof(output),
                        &bytes, NULL);

    *NewLogicalDiskId = output.NewLogicalDiskId;

    return b;
}

BOOL
FtCreateLogicalDisk(
    IN  FT_LOGICAL_DISK_TYPE    LogicalDiskType,
    IN  WORD                    NumberOfMembers,
    IN  PFT_LOGICAL_DISK_ID     RootLogicalDiskIds,
    IN  WORD                    ConfigurationInformationSize,
    IN  PVOID                   ConfigurationInformation,
    OUT PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    )

/*++

Routine Description:

    This routine creates a new logical disk.

Arguments:

    LogicalDiskType                 - Supplies the logical disk type.

    NumberOfMembers                 - Supplies the number of members.

    RootLogicalDiskIds              - Supplies the array of members.

    ConfigurationInformationSize    - Supplies the number of bytes in the
                                        configuration information.

    ConfigurationInformation        - Supplies the configuration information.

    NewLogicalDiskId                - Returns the new logical disk id.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                          h;
    DWORD                           inputBufferSize;
    PFT_CREATE_LOGICAL_DISK_INPUT   input;
    FT_CREATE_LOGICAL_DISK_OUTPUT   output;
    WORD                            i;
    BOOL                            b;
    DWORD                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    inputBufferSize = FIELD_OFFSET(FT_CREATE_LOGICAL_DISK_INPUT, MemberArray) +
                      NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                      ConfigurationInformationSize;
    input = (PFT_CREATE_LOGICAL_DISK_INPUT) LocalAlloc(0, inputBufferSize);
    if (!input) {
        CloseHandle(h);
        return FALSE;
    }

    input->LogicalDiskType = LogicalDiskType;
    input->NumberOfMembers = NumberOfMembers;
    input->ConfigurationInformationSize = ConfigurationInformationSize;
    for (i = 0; i < NumberOfMembers; i++) {
        input->MemberArray[i] = RootLogicalDiskIds[i];
    }
    CopyMemory(&input->MemberArray[i], ConfigurationInformation,
               ConfigurationInformationSize);

    b = DeviceIoControl(h, FT_CREATE_LOGICAL_DISK, input,
                        inputBufferSize, &output, sizeof(output),
                        &bytes, NULL);

    *NewLogicalDiskId = output.NewLogicalDiskId;

    LocalFree(input);

    CloseHandle(h);

    return b;
}

BOOL
FtInitializeLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    IN  BOOL                RegenerateOrphans
    )

/*++

Routine Description:

    This routine initializes the given root logical disk.

Arguments:

    RootLogicalDiskId   - Supplies the root logical disk id to initialize.

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphans.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                              h;
    FT_INITIALIZE_LOGICAL_DISK_INPUT    input;
    BOOL                                b;
    DWORD                               bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;
    input.RegenerateOrphans = (RegenerateOrphans != FALSE);

    b = DeviceIoControl(h, FT_INITIALIZE_LOGICAL_DISK, &input, sizeof(input),
                        NULL, 0, &bytes, NULL);

    CloseHandle(h);

    return b;
}

BOOL
FtBreakLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId
    )

/*++

Routine Description:

    This routine breaks a given logical disk into its constituents.

Arguments:

    RootLogicalDiskId   - Supplies the root logical disk id to break.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                          h;
    FT_BREAK_LOGICAL_DISK_INPUT     input;
    BOOL                            b;
    DWORD                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;

    b = DeviceIoControl(h, FT_BREAK_LOGICAL_DISK, &input, sizeof(input), NULL,
                        0, &bytes, NULL);

    CloseHandle(h);

    return b;
}

BOOL
FtEnumerateLogicalDisks(
    IN  DWORD               ArraySize,
    OUT PFT_LOGICAL_DISK_ID RootLogicalDiskIds,         /* OPTIONAL */
    OUT PDWORD              NumberOfRootLogicalDiskIds
    )

/*++

Routine Description:

    This routine enumerates all of the root logical disk ids in the system.
    If the 'RootLogicalDiskIds' is not present then this routine just returns
    the number of root logical disk ids in 'NumberOfRootLogicalDiskIds'.

Arguments:

    ArraySize                   - Supplies the number of root logical disk ids that
                                    the given array can hold.

    RootLogicalDiskIds          - Returns an array of root logical disk ids.

    NumberOfRootLogicalDiskIds  - Returns the number of root logical disk ids.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                              h;
    DWORD                               outputSize;
    PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT  poutput;
    BOOL                                b;
    DWORD                               bytes;
    DWORD                               i;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    outputSize = sizeof(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT);
    if (RootLogicalDiskIds) {
        outputSize += ArraySize*sizeof(FT_LOGICAL_DISK_ID);
    }

    poutput = LocalAlloc(0, outputSize);
    if (!poutput) {
        CloseHandle(h);
        return FALSE;
    }

    b = DeviceIoControl(h, FT_ENUMERATE_LOGICAL_DISKS, NULL, 0, poutput,
                        outputSize, &bytes, NULL);
    CloseHandle(h);

    *NumberOfRootLogicalDiskIds = poutput->NumberOfRootLogicalDisks;

    if (!b) {
        if (GetLastError() == ERROR_MORE_DATA && !RootLogicalDiskIds) {
            return TRUE;
        }
        LocalFree(poutput);
        return b;
    }

    if (RootLogicalDiskIds &&
        *NumberOfRootLogicalDiskIds <= ArraySize) {

        for (i = 0; i < *NumberOfRootLogicalDiskIds; i++) {
            RootLogicalDiskIds[i] = poutput->RootLogicalDiskIds[i];
        }
    }

    LocalFree(poutput);

    return b;
}

BOOL
FtQueryLogicalDiskInformation(
    IN  FT_LOGICAL_DISK_ID      LogicalDiskId,
    OUT PFT_LOGICAL_DISK_TYPE   LogicalDiskType,                /* OPTIONAL */
    OUT PLONGLONG               VolumeSize,                     /* OPTIONAL */
    IN  WORD                    MembersArraySize,
    OUT PFT_LOGICAL_DISK_ID     Members,                        /* OPTIONAL */
    OUT PWORD                   NumberOfMembers,                /* OPTIONAL */
    IN  WORD                    ConfigurationInformationSize,
    OUT PVOID                   ConfigurationInformation,       /* OPTIONAL */
    IN  WORD                    StateInformationSize,
    OUT PVOID                   StateInformation                /* OPTIONAL */
    )

/*++

Routine Description:

    This routine returns information for the given logical disk.

Arguments:

    LogicalDiskId                   - Supplies the logical disk id.

    LogicalDiskType                 - Returns the logical disk type.

    VolumeSize                      - Returns the size of the volume.

    MembersArraySize                - Supplies the size of the members array.

    Members                         - Returns the members of the logical disk.

    NumberOfMembers                 - Returns the number of members for this
                                        logical disk.

    ConfigurationInformationSize    - Supplies the configuration information
                                        size.

    ConfigurationInformation        - Returns the configuration information.

    StateInformationSize            - Supplies the state information size.

    StateInformation                - Returns the state information.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                      h;
    FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT     input;
    DWORD                                       outputSize;
    PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT   output;
    BOOL                                        b;
    DWORD                                       bytes;
    DWORD                                       i;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;
    outputSize = sizeof(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT);
    output = LocalAlloc(0, outputSize);
    if (!output) {
        CloseHandle(h);
        return FALSE;
    }

    b = DeviceIoControl(h, FT_QUERY_LOGICAL_DISK_INFORMATION, &input,
                        sizeof(input), output, outputSize, &bytes, NULL);
    if (!b && GetLastError() != ERROR_MORE_DATA) {
        LocalFree(output);
        CloseHandle(h);
        return FALSE;
    }

    outputSize = FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                              MemberArray) +
                 output->NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                 output->ConfigurationInformationSize +
                 output->StateInformationSize;
    LocalFree(output);
    output = LocalAlloc(0, outputSize);
    if (!output) {
        CloseHandle(h);
        return FALSE;
    }

    b = DeviceIoControl(h, FT_QUERY_LOGICAL_DISK_INFORMATION, &input,
                        sizeof(input), output, outputSize, &bytes, NULL);
    CloseHandle(h);
    if (!b) {
        return FALSE;
    }

    if (LogicalDiskType) {
        *LogicalDiskType = output->LogicalDiskType;
    }

    if (VolumeSize) {
        *VolumeSize = output->VolumeSize;
    }

    if (Members) {
        if (output->NumberOfMembers > MembersArraySize) {
            LocalFree(output);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }

        for (i = 0; i < output->NumberOfMembers; i++) {
            Members[i] = output->MemberArray[i];
        }
    }

    if (NumberOfMembers) {
        *NumberOfMembers = output->NumberOfMembers;
    }

    if (ConfigurationInformation) {
        if (ConfigurationInformationSize <
            output->ConfigurationInformationSize) {

            LocalFree(output);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }

        CopyMemory(ConfigurationInformation,
                   &output->MemberArray[output->NumberOfMembers],
                   output->ConfigurationInformationSize);
    }

    if (StateInformation) {
        if (StateInformationSize < output->StateInformationSize) {
            LocalFree(output);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }

        CopyMemory(StateInformation,
                   (PCHAR) &output->MemberArray[output->NumberOfMembers] +
                   output->ConfigurationInformationSize,
                   output->StateInformationSize);
    }

    LocalFree(output);
    return TRUE;
}

BOOL
FtOrphanLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  WORD                MemberNumberToOrphan
    )

/*++

Routine Description:

    This routine orphans a member of a logical disk.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    MemberNumberToOrphan    - Supplies the member number to orphan.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                              h;
    FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT input;
    BOOL                                b;
    DWORD                               bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;
    input.MemberNumberToOrphan = MemberNumberToOrphan;

    b = DeviceIoControl(h, FT_ORPHAN_LOGICAL_DISK_MEMBER, &input,
                        sizeof(input), NULL, 0, &bytes, NULL);
    CloseHandle(h);

    return b;
}

BOOL
FtReplaceLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  WORD                MemberNumberToReplace,
    IN  FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId            /* OPTIONAL */
    )

/*++

Routine Description:

    This routine replaces a member of a logical disk.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    MemberNumberToReplace   - Supplies the member number to replace.

    NewMemberLogicalDiskId  - Supplies the new member.

    NewLogicalDiskId        - Returns the new logical disk id for the disk set
                                that contains the replaced member.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                  h;
    FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT    input;
    FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT   output;
    BOOL                                    b;
    DWORD                                   bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;
    input.MemberNumberToReplace = MemberNumberToReplace;
    input.NewMemberLogicalDiskId = NewMemberLogicalDiskId;

    b = DeviceIoControl(h, FT_REPLACE_LOGICAL_DISK_MEMBER, &input,
                        sizeof(input), &output, sizeof(output), &bytes, NULL);
    CloseHandle(h);

    if (NewLogicalDiskId) {
        *NewLogicalDiskId = output.NewLogicalDiskId;
    }

    return b;
}

BOOL
FtQueryLogicalDiskId(
    IN  HANDLE              RootLogicalDiskHandle,
    OUT PFT_LOGICAL_DISK_ID RootLogicalDiskId
    )

/*++

Routine Description:

    This routine returns the root logical disk id for a given disk.

Arguments:

    RootLogicalDiskHandle   - Supplies a handle to a logical disk.

    RootLogicalDiskId       - Returns a logical disk id for the given logical
                                disk.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    BOOL                            b;
    FT_QUERY_LOGICAL_DISK_ID_OUTPUT output;
    DWORD                           bytes;

    b = DeviceIoControl(RootLogicalDiskHandle, FT_QUERY_LOGICAL_DISK_ID,
                        NULL, 0, &output, sizeof(output), &bytes, NULL);

    *RootLogicalDiskId = output.RootLogicalDiskId;

    return b;
}

BOOL
FtQueryStickyDriveLetter(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    OUT PUCHAR              DriveLetter
    )

/*++

Routine Description:

    This routine queries the sticky drive letter for the given disk id.

Arguments:

    RootLogicalDiskId   - Supplies the logical disk id.

    DriveLetter         - Returns the sticky drive letter.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                          h;
    FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT    input;
    FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT   output;
    BOOL                                            b;
    DWORD                                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;

    b = DeviceIoControl(h, FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK, &input,
                        sizeof(input), &output, sizeof(output), &bytes, NULL);
    CloseHandle(h);

    *DriveLetter = output.DriveLetter;

    return b;
}

BOOL
FtSetStickyDriveLetter(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    IN  UCHAR               DriveLetter
    )

/*++

Routine Description:

    This routine sets the sticky drive letter for the given disk id.

Arguments:

    RootLogicalDiskId   - Supplies the logical disk id.

    DriveLetter         - Supplies the sticky drive letter.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                      h;
    FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT  input;
    BOOL                                        b;
    DWORD                                       bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;
    input.DriveLetter = DriveLetter;

    b = DeviceIoControl(h, FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK, &input,
                        sizeof(input), NULL, 0, &bytes, NULL);
    CloseHandle(h);

    return b;
}

BOOL
FtChangeNotify(
    )

/*++

Routine Description:

    This routine returns when a change to the FT configuration occurrs.

Arguments:

    None.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                                      h;
    BOOL                                        b;
    DWORD                                       bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = DeviceIoControl(h, FT_CHANGE_NOTIFY, NULL, 0, NULL, 0, &bytes, NULL);
    CloseHandle(h);

    return b;
}

BOOL
FtStopSyncOperations(
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId
    )

/*++

Routine Description:

    This routine stops all sync operations on the logical disk.

Arguments:

    RootLogicalDiskId   - Supplies the root logical disk id.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE                          h;
    FT_STOP_SYNC_OPERATIONS_INPUT   input;
    BOOL                            b;
    DWORD                           bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.RootLogicalDiskId = RootLogicalDiskId;

    b = DeviceIoControl(h, FT_STOP_SYNC_OPERATIONS, &input, sizeof(input),
                        NULL, 0, &bytes, NULL);

    CloseHandle(h);

    return b;
}

BOOL
FtCheckIo(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PBOOL               IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not enough members of the given logical
    disk are online so that IO is possible on all parts of the volume.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    IsIoOk          - Returns whether or not IO is possible on the entire
                        logical disk.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE              h;
    FT_CHECK_IO_INPUT   input;
    FT_CHECK_IO_OUTPUT  output;
    BOOL                b;
    DWORD               bytes;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    input.LogicalDiskId = LogicalDiskId;

    b = DeviceIoControl(h, FT_CHECK_IO, &input, sizeof(input), &output,
                        sizeof(output), &bytes, NULL);
    CloseHandle(h);

    *IsIoOk = output.IsIoOk;

    return b;
}

BOOL
FtCheckDriver(
    OUT PBOOL   IsDriverLoaded
    )

/*++

Routine Description:

    This routine returns whether or not the FTDISK driver is loaded.

Arguments:

    IsDriverLoaded  - Returns whether or not the driver is loaded.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    HANDLE  h;

    h = CreateFile("\\\\.\\FtControl", GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            *IsDriverLoaded = FALSE;
            return TRUE;
        }
        return FALSE;
    }

    CloseHandle(h);

    *IsDriverLoaded = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\busmouse\devdesc.c ===
#include "..\devdesc\devdesc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\inc\volmgrx.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    volmgrx.h

Abstract:

    This file defines the public services supplied by the volume managers.

Author:

    norbertk

Revision History:

--*/

#ifndef _VOLMGRX_
#define _VOLMGRX_

#define VOLMGRCONTROLTYPE   ((ULONG) 'v')

#define IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES   CTL_CODE(VOLMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Output structure for IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES
//

typedef struct _VOLMGR_HIDDEN_VOLUMES {
    ULONG   MultiSzLength;
    WCHAR   MultiSz[1];
} VOLMGR_HIDDEN_VOLUMES, *PVOLMGR_HIDDEN_VOLUMES;

//
// Volume managers should report this GUID in IoRegisterDeviceInterface.
//

DEFINE_GUID(VOLMGR_VOLUME_MANAGER_GUID, 0x53f5630e, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\busmouse\devdesc.h ===
#include "..\devdesc\devdesc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ftapi\lib\parttype.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    parttype.c

Abstract:

    This module contains a routine used to determine the correct
    partition type to use for a partition.

Author:

    Ted Miller (tedm) 5 Feb 1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <parttype.h>

NTSTATUS
GeneratePartitionType(
    IN  LPCWSTR NtDevicePath,               OPTIONAL
    IN  HANDLE DeviceHandle,                OPTIONAL
    IN  ULONGLONG StartSector,
    IN  ULONGLONG SectorCount,
    IN  GenPartitionClass PartitionClass,
    IN  ULONG Flags,
    IN  ULONG Reserved,
    OUT PUCHAR Type
    )

/*++

Routine Description:

    This routine determines the proper partition type to be used for a new
    partition.

Arguments:

    NtDevicePath - supplies the NT-style path of the disk device where the
        partition is to be created, such as \Device\Harddisk1\Partition0.
        If not specified, DeviceHandle must be.

    DeviceHandle - Supplies a handle to the disk device where the partition
        will be. The caller should have opened the drive for at least
        FILE_READ_DATA and FILE_READ_ATTRIBUTES access. Ignored if
        NtDevicePath is specified.

    StartOffset - supplies the 0-based start sector for the partition.

    SectorCount - supplies the number of sectors to be in the partition.

    PartitionClass - supplies a value indicating the intended use of the
        partition.

        GenPartitionClassExtended - indicates that the partition will be
            a "container" partition using the standard extended partition
            architecture. The returned type will be PARTITION_EXTENDED (5)
            or PARTITION_XINT13_EXTENDED (f), depending on placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionClassFat12Or16 - indicates that the partition will be
            used for a 12 or 16 bit FAT volume. The returned type will be
            PARTITION_FAT_12 (1), PARTITION_FAT_16 (4), PARTITION_HUGE (6),
            or PARTITION_XINT13 (e), depending on size and placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionClassFat32 - indicates that the partition will be used
            for a FAT32 volume. The returned type will be PARTITION_FAT32 (b)
            or PARTITION_FAT32_XINT13 (c), depending on placement of the
            partition, availability of extended int13 for the drive,
            and the Flags parameter.

        GenPartitionNonFat - indicates that the partition will be used for
            a non-FAT volume. The returned type will be PARTITION_IFS (7).
            It is advisable to call this routine even for type 7 partitions
            since in the future additional partition types could be returned
            in this case.

    Flags - Supplies flags that further control operation of this routine.

        GENPARTTYPE_DISALLOW_XINT13 - disallow extended int13 partition types.
            If this flag is set, PARTITION_FAT32_XINT13 (c),
            PARTITION_XINT13 (e), and PARTITION_XINT13_EXTENDED (f) will not
            be returned as the partition type to be used. Not valid with
            GENPARTTYPE_FORCE_XINT13.

        GENPARTTYPE_FORCE_XINT13 - forces use of extended int13 partition types
            even if not necessary for the partition being created. Not valid
            with GENPARTTYPE_DISALLOW_XINT13.

    Reserved - reserved, must be 0.

    Type - if this routine succeeds, this value receives the partition type
        to be used for the partition.

Return Value:

    NT Status code indicating outcome. If NO_ERROR, Type is filled in with
    the resulting partition type to be used.

--*/

{
    NTSTATUS Status;
    DISK_GEOMETRY Geometry;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Validate parameters.
    //
    if((Flags & GENPARTTYPE_DISALLOW_XINT13) && (Flags & GENPARTTYPE_FORCE_XINT13)) {
        return(STATUS_INVALID_PARAMETER_5);
    }

    if(PartitionClass >= GenPartitionClassMax) {
        return(STATUS_INVALID_PARAMETER_4);
    }

    if(Reserved) {
        return(STATUS_INVALID_PARAMETER_6);
    }

    if(!SectorCount) {
        return(STATUS_INVALID_PARAMETER_3);
    }

    //
    // Open the device if the caller specified a device path.
    // Otherwise just use the handle the caller passed in.
    //
    if(NtDevicePath) {
        Status = pOpenDevice(NtDevicePath,&DeviceHandle);
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    //
    // Get drive geometry for the device.
    //
    Status = NtDeviceIoControlFile(
                DeviceHandle,
                NULL,NULL,NULL,     // synchronous io
                &IoStatusBlock,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,0,             // no input buffer
                &Geometry,
                sizeof(DISK_GEOMETRY)
                );

    if(NtDevicePath) {
        NtClose(DeviceHandle);
    }

    if(NT_SUCCESS(Status)) {
        //
        // Call the worker routine to do the work.
        //
        Status = GeneratePartitionTypeWorker(
                    StartSector,
                    SectorCount,
                    PartitionClass,
                    Flags,
                    &Geometry,
                    Type
                    );
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\inc\volmgr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    volmgr.h

Abstract:

    This file defines the services supplied by the volume managers.

Author:

    norbertk

Revision History:

--*/

#ifndef _VOLMGR_
#define _VOLMGR_

#include <volmgrx.h>

#define IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED             CTL_CODE(VOLMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED             CTL_CODE(VOLMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED            CTL_CODE(VOLMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES   CTL_CODE(VOLMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_ARRIVED      CTL_CODE(VOLMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_REMOVED      CTL_CODE(VOLMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION        CTL_CODE(VOLMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION       CTL_CODE(VOLMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED             CTL_CODE(VOLMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT       CTL_CODE(VOLMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE               CTL_CODE(VOLMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Input structure for IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED,
// IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED,
// IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES,
// IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION,
// IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION, and
// IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED.
//

typedef struct _VOLMGR_PARTITION_INFORMATION {
    PDEVICE_OBJECT  PartitionDeviceObject;
    PDEVICE_OBJECT  WholeDiskPdo;
} VOLMGR_PARTITION_INFORMATION, *PVOLMGR_PARTITION_INFORMATION;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED.
//

typedef struct _VOLMGR_WHOLE_DISK_INFORMATION {
    PDEVICE_OBJECT  WholeDiskPdo;
} VOLMGR_WHOLE_DISK_INFORMATION, *PVOLMGR_WHOLE_DISK_INFORMATION;

//
// Output structure for IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES.
//

typedef struct _VOLMGR_DEPENDANT_VOLUMES_INFORMATION {
    PDEVICE_RELATIONS   DependantVolumeReferences;
} VOLMGR_DEPENDANT_VOLUMES_INFORMATION, *PVOLMGR_DEPENDANT_VOLUMES_INFORMATION;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_ARRIVED and
// IOCTL_INTERNAL_VOLMGR_LEGACY_PARTITION_REMOVED.
//

typedef struct _VOLMGR_LEGACY_PARTITION_INFORMATION {
    PDEVICE_OBJECT  LegacyWholeDiskDeviceObject;
    ULONG           DiskNumber;
    ULONG           PartitionNumber;
} VOLMGR_LEGACY_PARTITION_INFORMATION, *PVOLMGR_LEGACY_PARTITION_INFORMATION;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT
//

typedef
NTSTATUS
(*PPMWMICOUNTERENABLE) (
    IN OUT PVOID* CounterContext
    );

typedef
BOOLEAN
(*PPMWMICOUNTERDISABLE) (
    IN PVOID* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    );

typedef
VOID
(*PPMWMICOUNTERIOSTART) (
    IN PVOID CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    );

typedef
VOID
(*PPMWMICOUNTERIOCOMPLETE) (
    IN PVOID CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    );

typedef
VOID
(*PPMWMICOUNTERQUERY) (
    IN PVOID CounterContext,
    IN OUT PDISK_PERFORMANCE CounterBuffer,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    );

typedef struct _PMWMICOUNTERLIB_CONTEXT {
    PPMWMICOUNTERENABLE     PmWmiCounterEnable;
    PPMWMICOUNTERDISABLE    PmWmiCounterDisable;
    PPMWMICOUNTERIOSTART    PmWmiCounterIoStart;
    PPMWMICOUNTERIOCOMPLETE PmWmiCounterIoComplete;
    PPMWMICOUNTERQUERY      PmWmiCounterQuery;
} PMWMICOUNTERLIB_CONTEXT, *PPMWMICOUNTERLIB_CONTEXT;

//
// Input structure for IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE
//

typedef struct _VOLMGR_POWER_STATE {
    PDEVICE_OBJECT      PartitionDeviceObject;
    PDEVICE_OBJECT      WholeDiskPdo;
    DEVICE_POWER_STATE  PowerState;
} VOLMGR_POWER_STATE, *PVOLMGR_POWER_STATE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\busmouse\i386\busmcmn.c ===
#if defined(i386)

/*++

Copyright (c) 1990, 1991, 1992, 1993  Microsoft Corporation
Copyright (c) 1992  Logitech Inc.

Module Name:

    busmcmn.c

Abstract:

    The common portions of the Bus mouse port driver.
    This file should not require modification to support new mice
    that are similar to the Bus mouse.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - IOCTL_INTERNAL_MOUSE_DISCONNECT has not been implemented.  It's not
      needed until the class unload routine is implemented. Right now,
      we don't want to allow the mouse class driver to unload.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

    Remy Zimmermann 03-Nov-92
    Modified Inport code to support the Bus mouse.

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "busmouse.h"
#include "busmlog.h"

//
// Declare the global debug flag for this driver.
//

#if DBG
ULONG BusDebug = 0;
#endif


VOID
BusErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to log errors that are
    discovered at IRQL > DISPATCH_LEVEL (e.g., in the ISR routine or
    in a routine that is executed via KeSynchronizeExecution).  There
    is not necessarily a current request associated with this condition.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Not used.

    Context - Indicates type of error to log.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);

    BusPrint((2, "BusErrorLogDpc: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Log an error packet.
    //

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                              DeviceObject,
                                              sizeof(IO_ERROR_LOG_PACKET)
                                              + (2 * sizeof(ULONG))
                                              );
    if (errorLogEntry != NULL) {

        errorLogEntry->DumpDataSize = 2 * sizeof(ULONG);

        if ((ULONG) Context == BUSMOUSE_MOU_BUFFER_OVERFLOW) {
            errorLogEntry->UniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 210;
            errorLogEntry->DumpData[0] = sizeof(MOUSE_INPUT_DATA);
            errorLogEntry->DumpData[1] = 
                deviceExtension->Configuration.MouseAttributes.InputDataQueueLength;
        } else {
            errorLogEntry->UniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 220;
            errorLogEntry->DumpData[0] = 0;
            errorLogEntry->DumpData[1] = 0;
        }

        errorLogEntry->ErrorCode = (ULONG) Context;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->FinalStatus = 0;

        IoWriteErrorLogEntry(errorLogEntry);
    }

    BusPrint((2, "BusErrorLogDpc: exit\n"));

}

NTSTATUS
DBusFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    BusPrint((2,"DBusFlush: enter\n"));
    BusPrint((2,"DBusFlush: exit\n"));

    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
DBusInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    BusPrint((2,"DBusInternalDeviceControl: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize the returned Information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Connect a mouse class device driver to the port driver.
        //

        case IOCTL_INTERNAL_MOUSE_CONNECT:

            BusPrint((
                2,
                "DBusInternalDeviceControl: mouse connect\n"
                ));

            //
            // Only allow one connection.
            //
            // FUTURE:  Consider allowing multiple connections, just for
            // the sake of generality?
            //

            if (deviceExtension->ConnectData.ClassService
                != NULL) {

                BusPrint((
                    2,
                    "DBusInternalDeviceControl: error - already connected\n"
                    ));

                status = STATUS_SHARING_VIOLATION;
                break;

            } else 
            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CONNECT_DATA)) {

                BusPrint((
                    2,
                    "DBusInternalDeviceControl: error - invalid buffer length\n"
                    ));

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy the connection parameters to the device extension.
            //

            deviceExtension->ConnectData =
                *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

            //
            // Reinitialize the port input data queue synchronously.
            //

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) BusInitializeDataQueue,
                (PVOID) deviceExtension
                );

            //
            // Set the completion status.
            //

            status = STATUS_SUCCESS;
            break;

        //
        // Disconnect a mouse class device driver from the port driver.
        //
        // NOTE: Not implemented.
        //

        case IOCTL_INTERNAL_MOUSE_DISCONNECT:

            BusPrint((
                2,
                "DBusInternalDeviceControl: mouse disconnect\n"
                ));

            //
            // Perform a mouse interrupt disable call.
            //

            //
            // Clear the connection parameters in the device extension.
            // NOTE:  Must synchronize this with the mouse ISR.
            //
            //
            //deviceExtension->ConnectData.ClassDeviceObject =
            //    Null;
            //deviceExtension->ConnectData.ClassService =
            //    Null;

            //
            // Set the completion status.
            //

            status = STATUS_NOT_IMPLEMENTED;
            break;

        //
        // Enable mouse interrupts (mark the request pending and handle
        // it in StartIo).
        //

        case IOCTL_INTERNAL_MOUSE_ENABLE:

            BusPrint((
                2,
                "DBusInternalDeviceControl: mouse enable\n"
                ));

            status = STATUS_PENDING;
            break;

        //
        // Disable mouse interrupts (mark the request pending and handle
        // it in StartIo).
        //

        case IOCTL_INTERNAL_MOUSE_DISABLE:

            BusPrint((
                2,
                "DBusInternalDeviceControl: mouse disable\n"
                ));

            status = STATUS_PENDING;
            break;

        //
        // Query the mouse attributes.  First check for adequate buffer 
        // length.  Then, copy the mouse attributes from the device 
        // extension to the output buffer. 
        //

        case IOCTL_MOUSE_QUERY_ATTRIBUTES:

            BusPrint((
                2,
                "DBusInternalDeviceControl: mouse query attributes\n"
                ));

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(MOUSE_ATTRIBUTES)) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {

                //
                // Copy the attributes from the DeviceExtension to the
                // buffer.
                //

                *(PMOUSE_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                    deviceExtension->Configuration.MouseAttributes;

                Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
                status = STATUS_SUCCESS;
            }

            break;

        default:

            BusPrint((
                2,
                "DBusInternalDeviceControl: INVALID REQUEST\n"
                ));

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    if (status == STATUS_PENDING) {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    BusPrint((2,"DBusInternalDeviceControl: exit\n"));

    return(status);

}

VOID
DBusIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to finish processing
    mouse interrupts.  It is queued in the mouse ISR.  The real
    work is done via a callback to the connected mouse class driver.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the Irp.

    Context - Not used.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION deviceExtension;
    GET_DATA_POINTER_CONTEXT getPointerContext;
    SET_DATA_POINTER_CONTEXT setPointerContext;
    VARIABLE_OPERATION_CONTEXT operationContext;
    PVOID classService;
    PVOID classDeviceObject;
    LONG interlockedResult;
    BOOLEAN moreDpcProcessing;
    ULONG dataNotConsumed = 0;
    ULONG inputDataConsumed = 0;
    LARGE_INTEGER deltaTime;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Context);

    BusPrint((2, "DBusIsrDpc: enter\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Use DpcInterlockVariable to determine whether the DPC is running
    // concurrently on another processor.  We only want one instantiation
    // of the DPC to actually do any work.  DpcInterlockVariable is -1
    // when no DPC is executing.  We increment it, and if the result is
    // zero then the current instantiation is the only one executing, and it
    // is okay to proceed.  Otherwise, we just return.
    //
    //

    operationContext.VariableAddress = 
        &deviceExtension->DpcInterlockVariable;
    operationContext.Operation = IncrementOperation;
    operationContext.NewValue = &interlockedResult;

    KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) BusDpcVariableOperation,
            (PVOID) &operationContext
            );

    moreDpcProcessing = (interlockedResult == 0)? TRUE:FALSE;

    while (moreDpcProcessing) {

        dataNotConsumed = 0;
        inputDataConsumed = 0;

        //
        // Get the port InputData queue pointers synchronously.
        //

        getPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.InputCount = 0;

        KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) BusGetDataQueuePointer,
            (PVOID) &getPointerContext
            );

        if (getPointerContext.InputCount != 0) {

            //
            // Call the connected class driver's callback ISR with the
            // port InputData queue pointers.  If we have to wrap the queue,
            // break the operation into two pieces, and call the class callback
            // ISR once for each piece.
            //

            classDeviceObject =
                deviceExtension->ConnectData.ClassDeviceObject;
            classService =
                deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            if (getPointerContext.DataOut >= getPointerContext.DataIn) {

                //
                // We'll have to wrap the InputData circular buffer.  Call
                // the class callback ISR with the chunk of data starting at
                // DataOut and ending at the end of the queue.
                //

                BusPrint((
                    2,
                    "DBusIsrDpc: calling class callback\n"
                    ));
                BusPrint((
                    2,
                    "DBusIsrDpc: with Start 0x%x and End 0x%x\n",
                    getPointerContext.DataOut,
                    deviceExtension->DataEnd
                    ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      deviceExtension->DataEnd,
                      &inputDataConsumed
                      );

                dataNotConsumed = (((PUCHAR)
                    deviceExtension->DataEnd -
                    (PUCHAR) getPointerContext.DataOut)
                    / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                BusPrint((
                    2,
                    "DBusIsrDpc: (Wrap) Call callback consumed %d items, left %d\n",
                    inputDataConsumed,
                    dataNotConsumed
                    ));

                setPointerContext.InputCount += inputDataConsumed;

                if (dataNotConsumed) {
                    setPointerContext.DataOut =
                        ((PUCHAR)getPointerContext.DataOut) +
                        (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                } else {
                    setPointerContext.DataOut =
                        deviceExtension->InputData;
                    getPointerContext.DataOut = setPointerContext.DataOut;
                }
            }

            //
            // Call the class callback ISR with data remaining in the queue.
            //

            if ((dataNotConsumed == 0) &&
                (inputDataConsumed < getPointerContext.InputCount)){
                BusPrint((
                    2,
                    "DBusIsrDpc: calling class callback\n"
                    ));
                BusPrint((
                    2,
                    "DBusIsrDpc: with Start 0x%x and End 0x%x\n",
                    getPointerContext.DataOut,
                    getPointerContext.DataIn
                    ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      getPointerContext.DataIn,
                      &inputDataConsumed
                      );

                dataNotConsumed = (((PUCHAR) getPointerContext.DataIn -
                      (PUCHAR) getPointerContext.DataOut)
                      / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                BusPrint((
                    2,
                    "DBusIsrDpc: Call callback consumed %d items, left %d\n",
                    inputDataConsumed,
                    dataNotConsumed
                    ));

                setPointerContext.DataOut =
                    ((PUCHAR)getPointerContext.DataOut) +
                    (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                setPointerContext.InputCount += inputDataConsumed;

            }

            //
            // Update the port InputData queue DataOut pointer and InputCount
            // synchronously.
            //

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) BusSetDataQueuePointer,
                (PVOID) &setPointerContext
                );

        }

        if (dataNotConsumed) {

            //
            // The class driver was unable to consume all the data.
            // Reset the interlocked variable to -1.  We do not want
            // to attempt to move more data to the class driver at this
            // point, because it is already overloaded.  Need to wait a
            // while to give the Raw Input Thread a chance to read some
            // of the data out of the class driver's queue.  We accomplish
            // this "wait" via a timer.
            //

            BusPrint((2, "DBusIsrDpc: set timer in DPC\n"));

            operationContext.Operation = WriteOperation;
            interlockedResult = -1;
            operationContext.NewValue = &interlockedResult;
        
            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) BusDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            deltaTime.LowPart = (ULONG)(-10 * 1000 * 1000);
            deltaTime.HighPart = -1;

            (VOID) KeSetTimer(
                       &deviceExtension->DataConsumptionTimer,
                       deltaTime,
                       &deviceExtension->IsrDpcRetry
                       );

            moreDpcProcessing = FALSE;

        } else {

            //
            // Decrement DpcInterlockVariable.  If the result goes negative,
            // then we're all finished processing the DPC.  Otherwise, either
            // the ISR incremented DpcInterlockVariable because it has more
            // work for the ISR DPC to do, or a concurrent DPC executed on 
            // some processor while the current DPC was running (the 
            // concurrent DPC wouldn't have done any work).  Make sure that 
            // the current DPC handles any extra work that is ready to be
            // done.
            //

            operationContext.Operation = DecrementOperation;
            operationContext.NewValue = &interlockedResult;
        
            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) BusDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            if (interlockedResult != -1) {

                //
                // The interlocked variable is still greater than or equal to
                // zero. Reset it to zero, so that we execute the loop one
                // more time (assuming no more DPCs execute and bump the
                // variable up again).
                //

                operationContext.Operation = WriteOperation;
                interlockedResult = 0;
                operationContext.NewValue = &interlockedResult;
        
                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) BusDpcVariableOperation,
                    (PVOID) &operationContext
                    );

                BusPrint((2, "BUSMOUSE-DBusIsrDpc: loop in DPC\n"));
            } else {
                moreDpcProcessing = FALSE;
            }
        }
    }

    BusPrint((2, "DBusIsrDpc: exit\n"));

}

NTSTATUS
DBusOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for create/open and close requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    UNREFERENCED_PARAMETER(DeviceObject);

    BusPrint((3,"DBusOpenClose: enter\n"));

    //
    // Complete the request with successful status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BusPrint((3,"DBusOpenClose: exit\n"));

    return(STATUS_SUCCESS);

}

VOID
DBusStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine starts an I/O operation for the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;

    BusPrint((2, "DBusStartIo: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Bump the error log sequence number.
    //

    deviceExtension->SequenceNumber += 1;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // We know we got here with an internal device control request.  Switch
    // on IoControlCode.
    //

    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Enable mouse interrupts, by calling BusEnableInterrupts
        // synchronously.
        //

        case IOCTL_INTERNAL_MOUSE_ENABLE:

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) BusEnableInterrupts,
                (PVOID) deviceExtension
                );

            BusPrint((
                2, 
                "DBusStartIo: mouse enable (count %d)\n",
                deviceExtension->MouseEnableCount
                ));

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Complete the request.
            //

            IoStartNextPacket(DeviceObject, FALSE);
            IoCompleteRequest(Irp, IO_MOUSE_INCREMENT);

            break;

        //
        // Disable mouse interrupts, by calling BusDisableInterrupts
        // synchronously.
        //

        case IOCTL_INTERNAL_MOUSE_DISABLE:

            BusPrint((2, "DBusStartIo: mouse disable"));

            if (deviceExtension->MouseEnableCount == 0) {

                //
                // Mouse already disabled.
                //

                BusPrint((2, " - error\n"));

                Irp->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;

            } else {

                //
                // Disable mouse by calling BusDisableInterrupts.
                //

                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) BusDisableInterrupts,
                    (PVOID) deviceExtension
                    );

                BusPrint((
                    2, 
                    " (count %d)\n",
                    deviceExtension->MouseEnableCount
                    ));

                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            //
            // Complete the request.
            //

            IoStartNextPacket(DeviceObject, FALSE);
            IoCompleteRequest(Irp, IO_MOUSE_INCREMENT);

            break;

        default:

            BusPrint((2, "DBusStartIo: INVALID REQUEST\n"));

            //
            // Log an internal error.  Note that we're calling the
            // error log DPC routine directly, rather than duplicating
            // code.
            //

            BusErrorLogDpc(
                (PKDPC) NULL,
                DeviceObject,
                Irp,
                (PVOID) (ULONG) BUSMOUSE_INVALID_STARTIO_REQUEST
                );

            ASSERT(FALSE);
            break;
    }

    BusPrint((2, "DBusStartIo: exit\n"));

    return;
}

VOID
BusDpcVariableOperation(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously by the ISR DPC to perform an 
    operation on the InterlockedDpcVariable.  The operations that can be 
    performed include increment, decrement, write, and read.  The ISR 
    itself reads and writes the InterlockedDpcVariable without calling this 
    routine.  

Arguments:

    Context - Pointer to a structure containing the address of the variable
        to be operated on, the operation to perform, and the address at
        which to copy the resulting value of the variable (the latter is also
        used to pass in the value to write to the variable, on a write
        operation).

Return Value:

    None.

--*/

{
    PVARIABLE_OPERATION_CONTEXT operationContext = Context;

    BusPrint((3,"BUSMOUSE-BusDpcVariableOperation: enter\n"));
    BusPrint((
        3,
        "\tPerforming %s at 0x%x (current value 0x%x)\n",
        (operationContext->Operation == IncrementOperation)? "increment":
        (operationContext->Operation == DecrementOperation)? "decrement":
        (operationContext->Operation == WriteOperation)?     "write":
        (operationContext->Operation == ReadOperation)?      "read":"",
        operationContext->VariableAddress,
        *(operationContext->VariableAddress)
        ));

    //
    // Perform the specified operation at the specified address.
    //

    switch(operationContext->Operation) {
        case IncrementOperation:
            *(operationContext->VariableAddress) += 1;
            break;
        case DecrementOperation:
            *(operationContext->VariableAddress) -= 1;
            break;
        case ReadOperation:
            break;
        case WriteOperation:
            BusPrint((
                3,
                "\tWriting 0x%x\n",
                *(operationContext->NewValue)
                ));
            *(operationContext->VariableAddress) = 
                *(operationContext->NewValue);
            break;
        default:
            ASSERT(FALSE);
            break;
    }

    *(operationContext->NewValue) = *(operationContext->VariableAddress);

    BusPrint((
        3,
        "BUSMOUSE-BusDpcVariableOperation: exit with value 0x%x\n",
        *(operationContext->NewValue)
        ));
}

VOID
BusGetDataQueuePointer(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously to get the current DataIn and DataOut
    pointers for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension,
        address at which to store the current DataIn pointer, and the
        address at which to store the current DataOut pointer.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    BusPrint((3,"BusGetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)
                      ((PGET_DATA_POINTER_CONTEXT) Context)->DeviceExtension;

    //
    // Get the DataIn and DataOut pointers.
    //

    BusPrint((
        3,
        "BusGetDataQueuePointer: DataIn 0x%x, DataOut 0x%x\n",
        deviceExtension->DataIn,
        deviceExtension->DataOut
        ));
    ((PGET_DATA_POINTER_CONTEXT) Context)->DataIn = deviceExtension->DataIn;
    ((PGET_DATA_POINTER_CONTEXT) Context)->DataOut = deviceExtension->DataOut;
    ((PGET_DATA_POINTER_CONTEXT) Context)->InputCount =
        deviceExtension->InputCount;

    BusPrint((3,"BusGetDataQueuePointer: exit\n"));
}

VOID
BusInitializeDataQueue (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine initializes the input data queue.  It is called
    via KeSynchronization, except when called from the initialization routine.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION deviceExtension;

    BusPrint((3,"BusInitializeDataQueue: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // Initialize the input data queue.
    //

    deviceExtension->InputCount = 0;
    deviceExtension->DataIn = deviceExtension->InputData;
    deviceExtension->DataOut = deviceExtension->InputData;

    deviceExtension->OkayToLogOverflow = TRUE;

    BusPrint((3,"BusInitializeDataQueue: exit\n"));

}

VOID
BusSetDataQueuePointer(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously to set the DataOut pointer
    and InputCount for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension
        and the new DataOut value for the port InputData queue.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    BusPrint((3,"BusSetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)
                      ((PSET_DATA_POINTER_CONTEXT) Context)->DeviceExtension;

    //
    // Set the DataOut pointer.
    //

    BusPrint((
        3,
        "BusSetDataQueuePointer: old mouse DataOut 0x%x, InputCount %d\n",
        deviceExtension->DataOut,
        deviceExtension->InputCount
        ));
    deviceExtension->DataOut = ((PSET_DATA_POINTER_CONTEXT) Context)->DataOut;
    deviceExtension->InputCount -=
        ((PSET_DATA_POINTER_CONTEXT) Context)->InputCount;

    if (deviceExtension->InputCount == 0) {

        //
        // Reset the flag that determines whether it is time to log
        // queue overflow errors.  We don't want to log errors too often.
        // Instead, log an error on the first overflow that occurs after
        // the ring buffer has been emptied, and then stop logging errors
        // until it gets cleared out and overflows again.
        //

        BusPrint((
            1,
            "BUSMOUSE-BusSetDataQueuePointer: Okay to log overflow\n"
            ));
        deviceExtension->OkayToLogOverflow = TRUE;
    }

    BusPrint((
        3,
        "BusSetDataQueuePointer: new mouse DataOut 0x%x, InputCount %d\n",
        deviceExtension->DataOut,
        deviceExtension->InputCount
        ));

    BusPrint((3,"BusSetDataQueuePointer: exit\n"));
}

BOOLEAN
BusWriteDataToQueue(
    PDEVICE_EXTENSION DeviceExtension,
    IN PMOUSE_INPUT_DATA InputData
    )

/*++

Routine Description:

    This routine adds input data from the mouse to the InputData queue.

Arguments:

    DeviceExtension - Pointer to the device extension.

    InputData - Pointer to the data to add to the InputData queue.

Return Value:

    Returns TRUE if the data was added, otherwise FALSE.

--*/

{

    BusPrint((2,"BusWriteDataToQueue: enter\n"));
    BusPrint((
        3,
        "BusWriteDataToQueue: DataIn 0x%x, DataOut 0x%x\n",
        DeviceExtension->DataIn,
        DeviceExtension->DataOut
        ));
    BusPrint((
        3,
        "BusWriteDataToQueue: InputCount %d\n",
        DeviceExtension->InputCount
        ));

    //
    // Check for full input data queue.
    //

    if ((DeviceExtension->DataIn == DeviceExtension->DataOut) &&
        (DeviceExtension->InputCount != 0)) {

        //
        // The input data queue is full.  Intentionally ignore
        // the new data.
        //

        BusPrint((0,"BusWriteDataToQueue: OVERFLOW\n"));
        return(FALSE);

    } else {
        *(DeviceExtension->DataIn) = *InputData;
        DeviceExtension->InputCount += 1;
        DeviceExtension->DataIn++;
        BusPrint((
            2,
            "BusWriteDataToQueue: new InputCount %d\n",
            DeviceExtension->InputCount
            ));
        if (DeviceExtension->DataIn ==
            DeviceExtension->DataEnd) {
            BusPrint((2,"BusWriteDataToQueue: wrap buffer\n"));
            DeviceExtension->DataIn = DeviceExtension->InputData;
        }
    }

    BusPrint((2,"BusWriteDataToQueue: exit\n"));

    return(TRUE);
}

#endif

#if DBG
VOID
BusDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= BusDebug) {

        char buffer[128];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\busmouse\i386\busmdep.c ===
#if defined(i386)

/*++

Copyright (c) 1990, 1991, 1992, 1993  Microsoft Corporation
Copyright (c) 1992  Logitech Inc.

Module Name:

    busmdep.c

Abstract:

    The initialization and hardware-dependent portions of a Bus mouse port
    driver. Modifications to support new mice similar to the bus mouse should
    be localized to this file.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "busmouse.h"
#include "busmlog.h"

#ifdef PNP_IDENTIFY
#include "devdesc.h"
#endif

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,BusConfiguration)
#pragma alloc_text(INIT,BusPeripheralCallout)
#pragma alloc_text(INIT,BusServiceParameters)
#pragma alloc_text(INIT,BusInitializeHardware)
#pragma alloc_text(INIT,BusBuildResourceList)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the Bus mouse port driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PDEVICE_OBJECT portDeviceObject =  NULL;
    PDEVICE_EXTENSION deviceExtension = NULL;
    DEVICE_EXTENSION tmpDeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL coordinatorIrql = 0;
    ULONG interruptVector;
    KIRQL interruptLevel;
    KAFFINITY affinity;
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG uniqueErrorValue;
    ULONG dumpCount = 0;
    NTSTATUS errorCode = STATUS_SUCCESS;
    PCM_RESOURCE_LIST resources = NULL;
    ULONG resourceListSize = 0;
    BOOLEAN conflictDetected;
    ULONG addressSpace;
    PHYSICAL_ADDRESS cardAddress;
    ULONG i;
    UNICODE_STRING fullDeviceName;
    UNICODE_STRING baseDeviceName;
    UNICODE_STRING deviceNameSuffix;
    UNICODE_STRING registryPath;

#define NAME_MAX 256
    WCHAR nameBuffer[NAME_MAX];

#define DUMP_COUNT 4
    ULONG dumpData[DUMP_COUNT];

    BusPrint((1,"\n\nBusInitialize: enter\n"));

    //
    // Zero-initialize various structures.
    //

    RtlZeroMemory(&tmpDeviceExtension, sizeof(tmpDeviceExtension));
    for (i = 0; i < DUMP_COUNT; i++)
        dumpData[i] = 0;

    fullDeviceName.MaximumLength = 0;
    deviceNameSuffix.MaximumLength = 0;
    registryPath.MaximumLength = 0;

    RtlZeroMemory(nameBuffer, sizeof(nameBuffer));
    baseDeviceName.Buffer = nameBuffer;
    baseDeviceName.Length = 0;
    baseDeviceName.MaximumLength = sizeof(nameBuffer);

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    //

    registryPath.Buffer = ExAllocatePool(
                              PagedPool,
                              RegistryPath->Length + sizeof(UNICODE_NULL)
                              );

    if (!registryPath.Buffer) {
        BusPrint((
            1,
            "BUSMOUSE-BusInitialize: Couldn't allocate pool for registry path\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        errorCode = BUSMOUSE_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 2;
        dumpData[0] = (ULONG) RegistryPath->Length + sizeof(UNICODE_NULL);
        dumpCount = 1;
        goto BusInitializeExit;

    } else {

        registryPath.Length = RegistryPath->Length + sizeof(UNICODE_NULL);
        registryPath.MaximumLength = registryPath.Length;

        RtlZeroMemory(
            registryPath.Buffer,
            registryPath.Length
                );

        RtlMoveMemory(
            registryPath.Buffer,
            RegistryPath->Buffer,
            RegistryPath->Length
            );

    }

    //
    // Get the configuration information for this driver.
    //

    BusConfiguration(&tmpDeviceExtension, &registryPath, &baseDeviceName);

    if (tmpDeviceExtension.HardwarePresent == FALSE) {

        //
        // There is no Bus mouse attached.  Return an unsuccessful status.
        //

        BusPrint((1,"BusInitialize: No mouse attached.\n"));
        status = STATUS_NO_SUCH_DEVICE;
        errorCode = BUSMOUSE_NO_SUCH_DEVICE;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 4;
        dumpCount = 0;
        goto BusInitializeExit;

    }

    //
    // Set up space for the port's device object suffix.  Note that
    // we overallocate space for the suffix string because it is much
    // easier than figuring out exactly how much space is required.
    // The storage gets freed at the end of driver initialization, so
    // who cares...
    //

    RtlInitUnicodeString(
        &deviceNameSuffix,
        NULL
        );

    deviceNameSuffix.MaximumLength = POINTER_PORTS_MAXIMUM * sizeof(WCHAR)
                        + sizeof(UNICODE_NULL);

    deviceNameSuffix.Buffer = ExAllocatePool(
                                  PagedPool,
                                  deviceNameSuffix.MaximumLength
                                  );

    if (!deviceNameSuffix.Buffer) {

        BusPrint((
            1,
            "BusInitialize: Couldn't allocate string for device object suffix\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        errorCode = BUSMOUSE_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 6;
        dumpData[0] = (ULONG) deviceNameSuffix.MaximumLength;
        dumpCount = 1;
        goto BusInitializeExit;

    }

    RtlZeroMemory(
        deviceNameSuffix.Buffer,
        deviceNameSuffix.MaximumLength
        );

    //
    // Set up space for the port's full device object name.
    //

    RtlInitUnicodeString(
        &fullDeviceName,
        NULL
        );

    fullDeviceName.MaximumLength = sizeof(L"\\Device\\") +
                                      baseDeviceName.Length +
                                      deviceNameSuffix.MaximumLength;


    fullDeviceName.Buffer = ExAllocatePool(
                                   PagedPool,
                                   fullDeviceName.MaximumLength
                                   );

    if (!fullDeviceName.Buffer) {

        BusPrint((
            1,
            "BusInitialize: Couldn't allocate string for device object name\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        errorCode = BUSMOUSE_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 8;
        dumpData[0] = (ULONG) fullDeviceName.MaximumLength;
        dumpCount = 1;
        goto BusInitializeExit;

    }

    RtlZeroMemory(
        fullDeviceName.Buffer,
        fullDeviceName.MaximumLength
        );
    RtlAppendUnicodeToString(
        &fullDeviceName,
        L"\\Device\\"
        );
    RtlAppendUnicodeToString(
        &fullDeviceName,
        baseDeviceName.Buffer
        );

    for (i = 0; i < POINTER_PORTS_MAXIMUM; i++) {

        //
        // Append the suffix to the device object name string.  E.g., turn
        // \Device\PointerPort into \Device\PointerPort0.  Then we attempt
        // to create the device object.  If the device object already
        // exists (because it was already created by another port driver),
        // increment the suffix and try again.
        //

        status = RtlIntegerToUnicodeString(
                     i,
                     10,
                     &deviceNameSuffix
                     );

        if (!NT_SUCCESS(status)) {
            break;
        }

        RtlAppendUnicodeStringToString(
            &fullDeviceName,
            &deviceNameSuffix
        );

        BusPrint((
            1,
            "BusInitialize: Creating device object named %ws\n",
            fullDeviceName.Buffer
            ));

        //
        // Create device object for the Bus mouse port device.
        //

        status = IoCreateDevice(
                    DriverObject,
                    sizeof(DEVICE_EXTENSION),
                    &fullDeviceName,
                    FILE_DEVICE_BUS_PORT,
                    0,
                    FALSE,
                    &portDeviceObject
                    );

        if (NT_SUCCESS(status)) {

            //
            // We've successfully created a device object.
            //

            break;
        } else {

           //
           // We'll increment the suffix and try again.  Note that we reset
           // the length of the string here to get back to the beginning
           // of the suffix portion of the name.  Do not bother to
           // zero the suffix, though, because the string for the
           // incremented suffix will be at least as long as the previous
           // one.
           //

           fullDeviceName.Length -= deviceNameSuffix.Length;
        }
    }

    if (!NT_SUCCESS(status)) {
        BusPrint((
            1,
            "BusInitialize: Could not create port device object = %ws\n",
            fullDeviceName.Buffer
            ));
        errorCode = BUSMOUSE_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 10;
        dumpData[0] = (ULONG) i;
        dumpCount = 1;
        goto BusInitializeExit;
    }

    //
    // Do buffered I/O.  I.e., the I/O system will copy to/from user data
    // from/to a system buffer.
    //

    portDeviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Set up the device extension.
    //

    deviceExtension =
        (PDEVICE_EXTENSION) portDeviceObject->DeviceExtension;
    *deviceExtension = tmpDeviceExtension;
    deviceExtension->DeviceObject = portDeviceObject;

    //
    // Set up the device resource list prior to reporting resource usage.
    //

    BusBuildResourceList(deviceExtension, &resources, &resourceListSize);

    //
    // Report resource usage for the registry.
    //

    IoReportResourceUsage(
        &baseDeviceName,
        DriverObject,
        NULL,
        0,
        portDeviceObject,
        resources,
        resourceListSize,
        FALSE,
        &conflictDetected
        );

    if (conflictDetected) {

        //
        // Some other device already owns the ports or interrupts.
        // Fatal error.
        //

        BusPrint((
            1,
            "BusInitialize: Resource usage conflict\n"
            ));

        //
        // Log an error.
        //

        errorCode = BUSMOUSE_RESOURCE_CONFLICT;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 15;
        dumpData[0] =  (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Level;
        dumpData[1] = (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Vector;
        dumpData[2] = (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[1].u.Interrupt.Level;
        dumpData[3] = (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[1].u.Interrupt.Vector;
        dumpCount = 4;

        goto BusInitializeExit;

    }

    //
    // Map the Bus controller registers.
    //

    addressSpace = (deviceExtension->Configuration.PortList[0].Flags
                       & CM_RESOURCE_PORT_IO) == CM_RESOURCE_PORT_IO? 1:0;
    if (!HalTranslateBusAddress(
        deviceExtension->Configuration.InterfaceType,
        deviceExtension->Configuration.BusNumber,
        deviceExtension->Configuration.PortList[0].u.Port.Start,
        &addressSpace,
        &cardAddress
        )) {

        addressSpace = 1;
        cardAddress.QuadPart = 0;
    }

    if (!addressSpace) {

        deviceExtension->Configuration.UnmapRegistersRequired = TRUE;
        deviceExtension->Configuration.DeviceRegisters[0] =
            MmMapIoSpace(
                cardAddress,
                deviceExtension->Configuration.PortList[0].u.Port.Length,
                FALSE
                );

    } else {

        deviceExtension->Configuration.UnmapRegistersRequired = FALSE;
        deviceExtension->Configuration.DeviceRegisters[0] =
            (PVOID)cardAddress.LowPart;

    }

    if (!deviceExtension->Configuration.DeviceRegisters[0]) {

        BusPrint((
            1,
            "BusInitialize: Couldn't map the device registers.\n"
            ));
        deviceExtension->Configuration.UnmapRegistersRequired = FALSE;
        status = STATUS_NONE_MAPPED;

        //
        // Log an error.
        //

        errorCode = BUSMOUSE_REGISTERS_NOT_MAPPED;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 20;
        dumpData[0] = cardAddress.LowPart;
        dumpCount = 1;

        goto BusInitializeExit;

    }

    //
    // Initialize the Bus hardware to default values for the mouse.  Note
    // that interrupts remain disabled until the class driver
    // requests a MOUSE_CONNECT internal device control.
    //

    status = BusInitializeHardware(portDeviceObject);

    if (!NT_SUCCESS(status)) {
        BusPrint((
            1,
            "BusInitialize: Could not initialize hardware\n"
            ));
        goto BusInitializeExit;
    } 

    //
    // Allocate the ring buffer for the mouse input data.
    //

    deviceExtension->InputData =
        ExAllocatePool(
            NonPagedPool,
            deviceExtension->Configuration.MouseAttributes.InputDataQueueLength
            );

    if (!deviceExtension->InputData) {

        //
        // Could not allocate memory for the mouse data queue.
        //

        BusPrint((
            1,
            "BusInitialize: Could not allocate mouse input data queue\n"
            ));

        status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // Log an error.
        //

        errorCode = BUSMOUSE_NO_BUFFER_ALLOCATED;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 30;
        dumpData[0] =
            deviceExtension->Configuration.MouseAttributes.InputDataQueueLength;
        dumpCount = 1;

        goto BusInitializeExit;
    }

    deviceExtension->DataEnd =
        (PMOUSE_INPUT_DATA)  ((PCHAR) (deviceExtension->InputData)
        + deviceExtension->Configuration.MouseAttributes.InputDataQueueLength);

    //
    // Zero the mouse input data ring buffer.
    //

    RtlZeroMemory(
        deviceExtension->InputData, 
        deviceExtension->Configuration.MouseAttributes.InputDataQueueLength
        );

    //
    // Initialize the connection data.
    //

    deviceExtension->ConnectData.ClassDeviceObject = NULL;
    deviceExtension->ConnectData.ClassService = NULL;

    //
    // Initialize the input data queue.
    //

    BusInitializeDataQueue((PVOID) deviceExtension);

    //
    // Initialize the port ISR DPC.  The ISR DPC is responsible for
    // calling the connected class driver's callback routine to process
    // the input data queue.
    //

    deviceExtension->DpcInterlockVariable = -1;

    KeInitializeSpinLock(&deviceExtension->SpinLock);

    KeInitializeDpc(
        &deviceExtension->IsrDpc,
        (PKDEFERRED_ROUTINE) DBusIsrDpc,
        portDeviceObject
        );

    KeInitializeDpc(
        &deviceExtension->IsrDpcRetry,
        (PKDEFERRED_ROUTINE) DBusIsrDpc,
        portDeviceObject
        );

    //
    // Initialize the mouse data consumption timer.
    //

    KeInitializeTimer(&deviceExtension->DataConsumptionTimer);

    //
    // Initialize the port DPC queue to log overrun and internal
    // driver errors.
    //

    KeInitializeDpc(
        &deviceExtension->ErrorLogDpc,
        (PKDEFERRED_ROUTINE) BusErrorLogDpc,
        portDeviceObject
        );

    //
    // From the Hal, get the interrupt vector and level.
    //

    interruptVector = HalGetInterruptVector(
                          deviceExtension->Configuration.InterfaceType,
                          deviceExtension->Configuration.BusNumber,
                          deviceExtension->Configuration.MouseInterrupt.u.Interrupt.Level,
                          deviceExtension->Configuration.MouseInterrupt.u.Interrupt.Vector,
                          &interruptLevel,
                          &affinity
                          );

    //
    // Initialize and connect the interrupt object for the mouse.
    //

    status = IoConnectInterrupt(
                 &(deviceExtension->InterruptObject),
                 (PKSERVICE_ROUTINE) DBusInterruptService,
                 (PVOID) portDeviceObject,
                 (PKSPIN_LOCK)NULL,
                 interruptVector,
                 interruptLevel,
                 interruptLevel,
                 deviceExtension->Configuration.MouseInterrupt.Flags
                     == CM_RESOURCE_INTERRUPT_LATCHED ? Latched:LevelSensitive,
                 deviceExtension->Configuration.MouseInterrupt.ShareDisposition,
                 affinity,
                 deviceExtension->Configuration.FloatingSave
                 );

    if (!NT_SUCCESS(status)) {

        //
        // Failed to install.  Free up resources before exiting.
        //

        BusPrint((
            1,
            "BusInitialize: Could not connect mouse interrupt\n"
            ));

        //
        // Log an error.
        //

        errorCode = BUSMOUSE_NO_INTERRUPT_CONNECTED;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 40;
        dumpData[0] = interruptLevel;
        dumpCount = 1;

        goto BusInitializeExit;

    }

    //
    // Once initialization is finished, load the device map information
    // into the registry so that setup can determine which pointer port
    // is active.
    //

    status = RtlWriteRegistryValue(
                 RTL_REGISTRY_DEVICEMAP,
                 baseDeviceName.Buffer,
                 fullDeviceName.Buffer,
                 REG_SZ,
                 registryPath.Buffer,
                 registryPath.Length
                 );

    if (!NT_SUCCESS(status)) {

        BusPrint((
            1,
            "BusInitialize: Could not store name in DeviceMap\n"
            ));

        errorCode = BUSMOUSE_NO_DEVICEMAP_CREATED;
        uniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 50;
        dumpCount = 0;

        goto BusInitializeExit;

    } else {

        BusPrint((
            1,
            "BusInitialize: Stored name in DeviceMap\n"
            ));
    }

#ifdef PNP_IDENTIFY

    LinkDeviceToDescription(
        RegistryPath,
        &fullDeviceName,
        deviceExtension->Configuration.InterfaceType,
        deviceExtension->Configuration.BusNumber,
        deviceExtension->Configuration.ControllerType,
        deviceExtension->Configuration.ControllerNumber,
        deviceExtension->Configuration.PeripheralType,
        deviceExtension->Configuration.PeripheralNumber
        );

#endif

    ASSERT(status == STATUS_SUCCESS);

    //
    // Set up the device driver entry points.
    //

    DriverObject->DriverStartIo = DBusStartIo;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = DBusOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = DBusOpenClose;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]= DBusFlush;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                         DBusInternalDeviceControl;

    //
    // NOTE: Don't allow this driver to unload.  Otherwise, we would set
    // DriverObject->DriverUnload = DBusUnload.
    //

BusInitializeExit:

    //
    // Log an error, if necessary.
    //

    if (errorCode != STATUS_SUCCESS) {
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(
                (portDeviceObject == NULL) ? 
                    (PVOID) DriverObject : (PVOID) portDeviceObject,
                (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + (dumpCount * sizeof(ULONG)))
                );

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = errorCode;
            errorLogEntry->DumpDataSize = (USHORT) (dumpCount * sizeof(ULONG));
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = uniqueErrorValue;
            errorLogEntry->FinalStatus = status;
            for (i = 0; i < dumpCount; i++)
                errorLogEntry->DumpData[i] = dumpData[i];

            IoWriteErrorLogEntry(errorLogEntry);
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // The initialization failed.  Cleanup resources before exiting.
        //
        // Note:  No need/way to undo the KeInitializeDpc or 
        //        KeInitializeTimer calls.
        //
        if (resources) {

            //
            // Call IoReportResourceUsage to remove the resources from
            // the map.
            //

            resources->Count = 0;

            IoReportResourceUsage(
                &baseDeviceName,
                DriverObject,
                NULL,
                0,
                portDeviceObject,
                resources,
                resourceListSize,
                FALSE,
                &conflictDetected
                );

        }

        if (deviceExtension) {
            if (deviceExtension->InterruptObject != NULL)
                IoDisconnectInterrupt(deviceExtension->InterruptObject);
            if (deviceExtension->Configuration.UnmapRegistersRequired) {

                MmUnmapIoSpace(
                    deviceExtension->Configuration.DeviceRegisters[0],
                    deviceExtension->Configuration.PortList[0].u.Port.Length
                    );
            }
            if (deviceExtension->InputData)
                ExFreePool(deviceExtension->InputData);
        }
        if (portDeviceObject)
            IoDeleteDevice(portDeviceObject);
    }

    //
    // Free the resource list.
    //
    // N.B.  If we ever decide to hang on to the resource list instead,
    //       we need to allocate it from non-paged pool (it is now paged pool).
    //

    if (resources)
        ExFreePool(resources);

    //
    // Free the unicode strings.
    //

    if (deviceNameSuffix.MaximumLength != 0)
        ExFreePool(deviceNameSuffix.Buffer);
    if (fullDeviceName.MaximumLength != 0)
        ExFreePool(fullDeviceName.Buffer);
    if (registryPath.MaximumLength != 0)
        ExFreePool(registryPath.Buffer);

    BusPrint((1,"BusInitialize: exit\n"));

    return(status);

}

BOOLEAN
DBusInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the mouse device.

Arguments:

    Interrupt - A pointer to the interrupt object for this interrupt.

    Context - A pointer to the device object.

Return Value:

    Returns TRUE if the interrupt was expected (and therefore processed);
    otherwise, FALSE is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;
    UCHAR previousButtons;
    PUCHAR port;
    UCHAR scratch;
    UCHAR status;

    UNREFERENCED_PARAMETER(Interrupt);

    BusPrint((3, "BusInterruptService: enter\n"));


    //
    // Get the device extension.
    //

    deviceObject = (PDEVICE_OBJECT) Context;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;


    //
    // Quit if the interrupt is not expected.
    // There is a problem right now when we connect the interrupt. It looks
    // like an interrupt is still registered even if we disabled
    // the device in the BusInitializeHardware routine.
    //

    if (deviceExtension->MouseEnableCount == 0) {
        BusPrint((
            1,
            "BusInterruptService: Received interrupt with hardware disabled\n"));
        return TRUE;
    }

    //
    // Get the Bus mouse port address.
    //

    port = deviceExtension->Configuration.DeviceRegisters[0];

    //
    // Note:  It would be nice to verify that the interrupt really
    // belongs to this driver, but it is currently not known how to
    // make that determination.
    //

    //
    // Set the Bus hold bit.
    //

    WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE,
                BUS_CONTROL_COUNTER_CAPTURE);

    //
    // Read the position and buttons.
    //
    // The format is:
    //
    // BBBXMMMM
    // |||||---------    Movement selected by the control register
    // ||||----------    Not used (state of interrupt enable bit)
    // |||-----------    1 if button 3 is down (right button)
    // ||------------    1 if button 2 is down (middle button)
    // |-------------    1 if button 1 is down (left button)
    //

    // NOTE: Optimize as follows.
    //
    // The bus mouse could be used as a clock because it interrupts the
    // system even if the device didn't move. Change the code to perform
    // no shifting/data handling in the initial part of the ISR. Process
    // the data only after the test for a null event.
    //



    //
    // X displacement
    //

    WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE,
                BUS_CONTROL_COUNTER_CAPTURE | BUS_CONTROL_X_LOW);

    deviceExtension->CurrentInput.LastX =
        (LONG)(SCHAR) READ_PORT_UCHAR((port + BUS_DATA_PORT_READ))& 0x0F;

    WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE,
                BUS_CONTROL_COUNTER_CAPTURE | BUS_CONTROL_X_HIGH);

    deviceExtension->CurrentInput.LastX |=
        (LONG)(SCHAR) ((READ_PORT_UCHAR((port + BUS_DATA_PORT_READ)) & 0x0F)
                << 4);

    BusPrint((3, "BusInterruptService: X displacement 0x%x\n",
            (int)deviceExtension->CurrentInput.LastX));

    //
    // Y displacment
    //

    WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE,
                BUS_CONTROL_COUNTER_CAPTURE | BUS_CONTROL_Y_LOW);

    deviceExtension->CurrentInput.LastY =
        (LONG)(SCHAR) READ_PORT_UCHAR((port + BUS_DATA_PORT_READ)) & 0x0F;

    WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE,
                BUS_CONTROL_COUNTER_CAPTURE | BUS_CONTROL_Y_HIGH);

    scratch = READ_PORT_UCHAR((port + BUS_DATA_PORT_READ));

    deviceExtension->CurrentInput.LastY |=
                (LONG)(SCHAR) ((scratch & 0x0F) << 4);

    BusPrint((3, "BusInterruptService: Y displacement 0x%x\n",
            (int)deviceExtension->CurrentInput.LastY));

    //
    // Invert the button state (down = 1).
    //

    scratch = ~scratch;

    //
    // Update CurrentInput with button transition data.
    // I.e., set a button up/down bit in the Buttons field if
    // the state of a given button has changed since we
    // received the last packet.
    //
 
    previousButtons = deviceExtension->PreviousButtons;

    deviceExtension->CurrentInput.Buttons = 0;

    if ((!(previousButtons & BUS_DATA_BUTTON_1))
           && (scratch & BUS_DATA_BUTTON_1)) {
        deviceExtension->CurrentInput.Buttons |= MOUSE_LEFT_BUTTON_DOWN;
    } else
    if ((previousButtons & BUS_DATA_BUTTON_1)
           && !(scratch & BUS_DATA_BUTTON_1)) {
        deviceExtension->CurrentInput.Buttons |= MOUSE_LEFT_BUTTON_UP;
    }
    if ((!(previousButtons & BUS_DATA_BUTTON_2))
           && (scratch & BUS_DATA_BUTTON_2)) {
        deviceExtension->CurrentInput.Buttons |= MOUSE_MIDDLE_BUTTON_DOWN;
    } else
    if ((previousButtons & BUS_DATA_BUTTON_2)
           && !(scratch & BUS_DATA_BUTTON_2)) {
        deviceExtension->CurrentInput.Buttons |= MOUSE_MIDDLE_BUTTON_UP;
    }
    if ((!(previousButtons & BUS_DATA_BUTTON_3))
           && (scratch & BUS_DATA_BUTTON_3)) {
        deviceExtension->CurrentInput.Buttons |= MOUSE_RIGHT_BUTTON_DOWN;
    } else
    if ((previousButtons & BUS_DATA_BUTTON_3)
           && !(scratch & BUS_DATA_BUTTON_3)) {
        deviceExtension->CurrentInput.Buttons |= MOUSE_RIGHT_BUTTON_UP;
    }

    BusPrint((3, "BusInterruptService: Button state 0x%x\n",
            deviceExtension->CurrentInput.Buttons));

    if (deviceExtension->CurrentInput.Buttons ||
        deviceExtension->CurrentInput.LastX  ||
        deviceExtension->CurrentInput.LastY) {

        deviceExtension->CurrentInput.UnitId = deviceExtension->UnitId;

        //
        // Keep track of the state of the mouse buttons for the next
        // interrupt.
        //

        deviceExtension->PreviousButtons = 
            scratch & (BUS_DATA_BUTTON_1|BUS_DATA_BUTTON_2|BUS_DATA_BUTTON_3);

        //
        // Clear the Bus hold bit.
        //

        WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE, 0x00);

        //
        // Write the input data to the queue and request the ISR DPC to
        // finish processing the interrupt at DISPATCH_LEVEL.
        //

        if (!BusWriteDataToQueue(
                deviceExtension,
                &deviceExtension->CurrentInput
                )) {

            //
            // The mouse input data queue is full.  Just drop the
            // latest input on the floor.
            //
            // Queue a DPC to log an overrun error.
            //

            BusPrint((
                1,
                "DBusInterruptService: queue overflow\n"
                ));

            if (deviceExtension->OkayToLogOverflow) {
                KeInsertQueueDpc(
                    &deviceExtension->ErrorLogDpc,
                    (PIRP) NULL,
                    (PVOID) (ULONG) BUSMOUSE_MOU_BUFFER_OVERFLOW
                    );
                deviceExtension->OkayToLogOverflow = FALSE;
            }

        } else if (deviceExtension->DpcInterlockVariable >= 0) {
    
            //
            // The ISR DPC is already executing.  Tell the ISR DPC it has
            // more work to do by incrementing the DpcInterlockVariable.
            //
    
            deviceExtension->DpcInterlockVariable += 1;
    
        } else {
    
            //
            // Queue the ISR DPC.
            //
    
            KeInsertQueueDpc(
                &deviceExtension->IsrDpc,
                deviceObject->CurrentIrp,
                NULL
                );
    
        }

    } else {

        BusPrint((
            3,
            "DBusInterruptService: interrupt without button/motion change\n"
            ));


        //
        // Clear the Bus hold bit.
        //

        WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE, 0x00);

    }

    BusPrint((3, "DBusInterruptService: exit\n"));

    return(TRUE);
}

VOID
BusUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    UNREFERENCED_PARAMETER(DriverObject);

    BusPrint((2, "BusUnload: enter\n"));
    BusPrint((2, "BusUnload: exit\n"));
}

VOID
BusBuildResourceList(
    IN PDEVICE_EXTENSION DeviceExtension,
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceListSize
    )

/*++

Routine Description:

    Creates a resource list that is used to query or report resource usage.

Arguments:

    DeviceExtension - Pointer to the port's device extension.

    ResourceList - Pointer to a pointer to the resource list to be allocated
        and filled.

    ResourceListSize - Pointer to the returned size of the resource
        list (in bytes).

Return Value:

    None.  If the call succeeded, *ResourceList points to the built
    resource list and *ResourceListSize is set to the size (in bytes)
    of the resource list; otherwise, *ResourceList is NULL.

Note:

    Memory is allocated here for *ResourceList. It must be
    freed up by the caller, by calling ExFreePool();

--*/

{
    ULONG count = 0;
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i = 0;
    ULONG j = 0;

    BusPrint((2, "BusBuildResourceList: Enter\n"));

    count += DeviceExtension->Configuration.PortListCount;
    if (DeviceExtension->Configuration.MouseInterrupt.Type
        == CmResourceTypeInterrupt)
        count += 1;

    *ResourceListSize = sizeof(CM_RESOURCE_LIST) +
                       ((count - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    *ResourceList = (PCM_RESOURCE_LIST) ExAllocatePool(
                                            PagedPool,
                                            *ResourceListSize
                                            );

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill in the resource list.
    //

    if (!*ResourceList) {

        //
        // Could not allocate memory for the resource list.
        //

        BusPrint((
            1,
            "BusBuildResourceList: Could not allocate resource list\n"
            ));

        //
        // Log an error.
        //

        errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                              DeviceExtension->DeviceObject,
                                              sizeof(IO_ERROR_LOG_PACKET)
                                              + sizeof(ULONG)
                                              );

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = BUSMOUSE_INSUFFICIENT_RESOURCES;
            errorLogEntry->DumpDataSize = sizeof(ULONG);
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = BUSMOUSE_ERROR_VALUE_BASE + 110;
            errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
            errorLogEntry->DumpData[0] = *ResourceListSize;
            *ResourceListSize = 0;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        return;

    }

    RtlZeroMemory(
        *ResourceList,
        *ResourceListSize
        );

    //
    // Concoct one full resource descriptor.
    //

    (*ResourceList)->Count = 1;

    (*ResourceList)->List[0].InterfaceType =
        DeviceExtension->Configuration.InterfaceType;
    (*ResourceList)->List[0].BusNumber =
        DeviceExtension->Configuration.BusNumber;

    //
    // Build the partial resource descriptors for interrupt and port
    // resources from the saved values.
    //

    (*ResourceList)->List[0].PartialResourceList.Count = count;
    if (DeviceExtension->Configuration.MouseInterrupt.Type
        == CmResourceTypeInterrupt)
        (*ResourceList)->List[0].PartialResourceList.PartialDescriptors[i++] =
            DeviceExtension->Configuration.MouseInterrupt;

    for (j = 0; j < DeviceExtension->Configuration.PortListCount; j++) {
        (*ResourceList)->List[0].PartialResourceList.PartialDescriptors[i++] =
            DeviceExtension->Configuration.PortList[j];
    }

    BusPrint((2, "BusBuildResourceList: Exit\n"));

}

VOID
BusConfiguration(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine retrieves the configuration information for the mouse.

Arguments:

    DeviceExtension - Pointer to the (temporary) device extension.

    RegistryPath - Pointer to the null-terminated Unicode name of the 
        registry path for this driver.

    DeviceName - Pointer to the Unicode string that will receive
        the port device name.

Return Value:

    None.  As a side-effect, may set DeviceExtension->HardwarePresent.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PBUS_CONFIGURATION_INFORMATION configuration;
    INTERFACE_TYPE interfaceType;
    CONFIGURATION_TYPE controllerType = PointerController;
    CONFIGURATION_TYPE peripheralType = PointerPeripheral;
    ULONG i;

    BusPrint((2, "BusConfiguration: Enter\n"));

    // Loop through the different interface types (Eisa, Isa, ...)

    for (i = 0; i < MaximumInterfaceType; i++) {

        //
        // Get the registry information for this device.
        //

        interfaceType = i;
        status = IoQueryDeviceDescription(&interfaceType,
                                          NULL,
                                          &controllerType,
                                          NULL,
                                          &peripheralType,
                                          NULL,
                                          BusPeripheralCallout,
                                          (PVOID) DeviceExtension);

        if (DeviceExtension->HardwarePresent) {


            //
            // Get the service parameters (e.g., user-configurable
            // data input queue size, etc.).
            //

            BusServiceParameters(DeviceExtension, RegistryPath, DeviceName);
            configuration = &DeviceExtension->Configuration;

            //
            // Initialize mouse-specific configuration parameters.
            //

            configuration->MouseAttributes.MouseIdentifier =
                MOUSE_BUS_HARDWARE;

            break;

        } else {

            BusPrint((
                1,
                "BusConfiguration: IoQueryDeviceDescription for bus type %d failed\n",
                interfaceType
                ));
        }
    }

    BusPrint((2, "BusConfiguration: Exit\n"));

}

VOID
BusDisableInterrupts(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called from StartIo synchronously.  It touches the
    hardware to  disable interrupts.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{
    PUCHAR port;
    PLONG  enableCount;

    //
    // Decrement the reference count for device enables.
    //

    enableCount = &((PDEVICE_EXTENSION) Context)->MouseEnableCount;
    *enableCount = *enableCount - 1;

    if (*enableCount == 0) {

        //
        // Get the port register address.
        //
    
        port = ((PDEVICE_EXTENSION) Context)->Configuration.DeviceRegisters[0];
    
        //
        // Disable the interrupts
        //
    
        WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE,
                    BUS_CONTROL_INTERRUPT_DISABLE);

    }

}

VOID
BusEnableInterrupts(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called from StartIo synchronously.  It touches the
    hardware to enable interrupts.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{
    PUCHAR port;
    PLONG  enableCount;

    enableCount = &((PDEVICE_EXTENSION) Context)->MouseEnableCount;

    if (*enableCount == 0) {

        //
        // Get the port register address.
        //
    
        port = ((PDEVICE_EXTENSION) Context)->Configuration.DeviceRegisters[0];
    
        //
        // Enable the interrupts
        //
    
        WRITE_PORT_UCHAR((PUCHAR) port + BUS_CONTROL_PORT_WRITE, 0);

    }

    //
    // Increment the reference count for device enables.
    //

    *enableCount = *enableCount + 1;

}

NTSTATUS
BusInitializeHardware(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine initializes the Bus mouse.  Note that this routine is
    only called at initialization time, so synchronization is not required.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR mousePort;

    BusPrint((2, "BusInitializeHardware: enter\n"));

    //
    // Grab useful configuration parameters from the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;
    mousePort = deviceExtension->Configuration.DeviceRegisters[0];

    BusPrint((2, "BusInitializeHardware: Port base value is: 0x%x\n", (int)mousePort));

    //
    // Turn the bus interrupts off (in case).
    //

    WRITE_PORT_UCHAR((PUCHAR) mousePort + BUS_CONTROL_PORT_WRITE,
                BUS_CONTROL_INTERRUPT_DISABLE);

    //
    // Configure the controller.
    //

//    WRITE_PORT_UCHAR((PUCHAR) mousePort + BUS_CONFIGURATION_PORT_READ_WRITE,
//                BUS_CONFIGURATION_VALUE);

    //
    // Initialize the state of the mouse buttons.
    //

    deviceExtension->PreviousButtons = 0;

    BusPrint((2, "BusInitializeHardware: exit\n"));

    return(STATUS_SUCCESS);

}

NTSTATUS
BusPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This is the callout routine sent as a parameter to
    IoQueryDeviceDescription.  It grabs the pointer controller and
    peripheral configuration information.

Arguments:

    Context - Context parameter that was passed in by the routine
        that called IoQueryDeviceDescription.

    PathName - The full pathname for the registry key.

    BusType - Bus interface type (Isa, Eisa, Mca, etc.).

    BusNumber - The bus sub-key (0, 1, etc.).

    BusInformation - Pointer to the array of pointers to the full value
        information for the bus.

    ControllerType - The controller type (should be PointerController).

    ControllerNumber - The controller sub-key (0, 1, etc.).

    ControllerInformation - Pointer to the array of pointers to the full
        value information for the controller key.

    PeripheralType - The peripheral type (should be PointerPeripheral).

    PeripheralNumber - The peripheral sub-key.

    PeripheralInformation - Pointer to the array of pointers to the full
        value information for the peripheral key.


Return Value:

    None.  If successful, will have the following side-effects:

        - Sets DeviceObject->DeviceExtension->HardwarePresent.
        - Sets configuration fields in
          DeviceObject->DeviceExtension->Configuration.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PBUS_CONFIGURATION_INFORMATION configuration;
    UNICODE_STRING unicodeIdentifier;
    PUCHAR controllerData;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i;
    ULONG listCount = 0;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    ANSI_STRING ansiString;
    BOOLEAN defaultInterruptShare;
    KINTERRUPT_MODE defaultInterruptMode;

    BusPrint((
        1,
    "BusPeripheralCallout: Enter\n"
        ));
    BusPrint((
        1,
        "BusPeripheralCallout: Path @ 0x%x, Bus Type 0x%x, Bus Number 0x%x\n",
        PathName, BusType, BusNumber
        ));
    BusPrint((
        1,
        "    Controller Type 0x%x, Controller Number 0x%x, Controller info @ 0x%x\n",
        ControllerType, ControllerNumber, ControllerInformation
        ));
    BusPrint((
        1,
        "    Peripheral Type 0x%x, Peripheral Number 0x%x, Peripheral info @ 0x%x\n",
        PeripheralType, PeripheralNumber, PeripheralInformation
        ));

    //
    // Get the length of the peripheral identifier information.
    //

    unicodeIdentifier.Length = (USHORT)
        (*(PeripheralInformation + IoQueryDeviceIdentifier))->DataLength;

    //
    // If we already have the configuration information for the
    // mouse peripheral, or if the peripheral identifier is missing, 
    // just return.
    //

    deviceExtension = (PDEVICE_EXTENSION) Context;
    if ((deviceExtension->HardwarePresent) || (unicodeIdentifier.Length == 0)){
        return (status);
    }

    //
    // Get the identifier information for the peripheral.
    //

    unicodeIdentifier.MaximumLength = unicodeIdentifier.Length;
    unicodeIdentifier.Buffer = (PWSTR) (((PUCHAR)(*(PeripheralInformation +
                               IoQueryDeviceIdentifier))) +
                               (*(PeripheralInformation +
                               IoQueryDeviceIdentifier))->DataOffset);
    BusPrint((
        1,
        "BusPeripheralCallout: Mouse type %ws\n",
        unicodeIdentifier.Buffer
        ));

    //
    // Verify that this is a Bus mouse.
    //

    status = RtlUnicodeStringToAnsiString(
                 &ansiString,
                 &unicodeIdentifier,
                 TRUE
                 );

    if (!NT_SUCCESS(status)) {
        BusPrint((
            1,
            "BusPeripheralCallout: Could not convert identifier to Ansi\n"
            ));
        return(status);
    }

    if (strstr(ansiString.Buffer, "BUS")) {

         //
         // There is a Bus mouse (at least a card) present.
         //

         deviceExtension->HardwarePresent = TRUE;
    }

    RtlFreeAnsiString(&ansiString);

    if (!deviceExtension->HardwarePresent) {
        return(status);
    }

    //
    // Get the bus information.
    //

    configuration = &deviceExtension->Configuration;
    configuration->InterfaceType = BusType;
    configuration->BusNumber = BusNumber;

#ifdef PNP_IDENTIFY
    configuration->ControllerType = ControllerType;
    configuration->ControllerNumber = ControllerNumber;
    configuration->PeripheralType = PeripheralType;
    configuration->PeripheralNumber = PeripheralNumber;
#endif

    configuration->FloatingSave = BUS_FLOATING_SAVE;

    if (BusType == MicroChannel) {
        defaultInterruptShare = TRUE;
        defaultInterruptMode = LevelSensitive;
    } else {
        defaultInterruptShare = BUS_INTERRUPT_SHARE;
        defaultInterruptMode = BUS_INTERRUPT_MODE;
    }

    //
    // Look through the resource list for interrupt and port
    // configuration information.
    //

    if ((*(ControllerInformation + IoQueryDeviceConfigurationData))->DataLength != 0){

        controllerData = ((PUCHAR)(*(ControllerInformation +
                                  IoQueryDeviceConfigurationData))) +
                                  (*(ControllerInformation +
                                  IoQueryDeviceConfigurationData))->DataOffset;
    
        controllerData += FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                       PartialResourceList);
    
        listCount = ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->Count;
    
        resourceDescriptor =
            ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->PartialDescriptors;
    
        for (i = 0; i < listCount; i++, resourceDescriptor++) {
            switch(resourceDescriptor->Type) {
                case CmResourceTypePort:
    
                    //
                    // Copy the port information.  Note that we only expect to
                    // find one port range for the Bus mouse.
                    //
    
                    ASSERT(configuration->PortListCount == 0);
                    configuration->PortList[configuration->PortListCount] =
                        *resourceDescriptor;
                    configuration->PortList[configuration->PortListCount].ShareDisposition =
                        BUS_REGISTER_SHARE? CmResourceShareShared:
                                               CmResourceShareDeviceExclusive;
                    configuration->PortListCount += 1;
    
                    break;
    
                case CmResourceTypeInterrupt:
    
                    //
                    // Copy the interrupt information.
                    //
    
                    configuration->MouseInterrupt = *resourceDescriptor;
                    configuration->MouseInterrupt.ShareDisposition =
                        defaultInterruptShare?  CmResourceShareShared :
                                                CmResourceShareDeviceExclusive;
    
                    break;
    
                default:
                    break;
            }
        }
    }

    //
    // If no interrupt configuration information was found, use the
    // driver defaults.
    //

    if (!(configuration->MouseInterrupt.Type & CmResourceTypeInterrupt)) {

        BusPrint((
            1,
            "BusPeripheralCallout: Using default mouse interrupt config\n"
            ));

        configuration->MouseInterrupt.Type = CmResourceTypeInterrupt;
        configuration->MouseInterrupt.ShareDisposition =
            defaultInterruptShare?  CmResourceShareShared :
                                    CmResourceShareDeviceExclusive;
        configuration->MouseInterrupt.Flags =
            (defaultInterruptMode == Latched)? CM_RESOURCE_INTERRUPT_LATCHED :
                CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        configuration->MouseInterrupt.u.Interrupt.Level = MOUSE_IRQL;
        configuration->MouseInterrupt.u.Interrupt.Vector = MOUSE_VECTOR;
    }

    BusPrint((
        1,
        "BusPeripheralCallout: Mouse interrupt config --\n"
        ));
    BusPrint((
        1,
        "%s, %s, Irq = %d\n",
        configuration->MouseInterrupt.ShareDisposition == CmResourceShareShared?
            "Sharable" : "NonSharable",
        configuration->MouseInterrupt.Flags == CM_RESOURCE_INTERRUPT_LATCHED?
            "Latched" : "Level Sensitive",
        configuration->MouseInterrupt.u.Interrupt.Vector
        ));

    //
    // If no port configuration information was found, use the
    // driver defaults.
    //

    if (configuration->PortListCount == 0) {

        //
        // No port configuration information was found, so use
        // the driver defaults.
        //

        BusPrint((
            1,
            "BusPeripheralCallout: Using default port config\n"
            ));

        configuration->PortList[0].Type = CmResourceTypePort;
        configuration->PortList[0].Flags = BUS_PORT_TYPE;
        configuration->PortList[0].ShareDisposition =
            BUS_REGISTER_SHARE? CmResourceShareShared:
                                   CmResourceShareDeviceExclusive;
        configuration->PortList[0].u.Port.Start.LowPart =
            BUS_PHYSICAL_BASE;
        configuration->PortList[0].u.Port.Start.HighPart = 0;
        configuration->PortList[0].u.Port.Length = BUS_REGISTER_LENGTH;

        configuration->PortListCount = 1;
    }

    for (i = 0; i < configuration->PortListCount; i++) {

        BusPrint((
            1,
            "%s, Ports 0x%x - 0x%x\n",
            configuration->PortList[i].ShareDisposition
                == CmResourceShareShared?  "Sharable" : "NonSharable",
            configuration->PortList[i].u.Port.Start.LowPart,
            configuration->PortList[i].u.Port.Start.LowPart +
                configuration->PortList[i].u.Port.Length - 1
            ));
    }

    BusPrint((
        1,
    "BusPeripheralCallout: Exit\n"
        ));

    return(status);
}

VOID
BusServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    DeviceExtension - Pointer to the device extension.

    RegistryPath - Pointer to the null-terminated Unicode name of the 
        registry path for this driver.

    DeviceName - Pointer to the Unicode string that will receive
        the port device name.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Configuration.

--*/

{
    PBUS_CONFIGURATION_INFORMATION configuration;
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    UNICODE_STRING parametersPath;
    OBJECT_ATTRIBUTES parametersAttributes;
    ULONG defaultDataQueueSize = DATA_QUEUE_SIZE;
    ULONG numberOfButtons = MOUSE_NUMBER_OF_BUTTONS;
    USHORT defaultNumberOfButtons = MOUSE_NUMBER_OF_BUTTONS;
    ULONG sampleRate = MOUSE_SAMPLE_RATE_50HZ;
    UNICODE_STRING defaultUnicodeName;
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR path = NULL;
    USHORT queriesPlusOne = 4;

    BusPrint((
        1,
    "BusServiceParameters: Enter\n"
        ));

    configuration = &DeviceExtension->Configuration;
    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //

        parameters = ExAllocatePool(
                         PagedPool,
                         sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                         );

        if (!parameters) {

            BusPrint((
                1,
                "BusServiceParameters: Couldn't allocate table for Rtl query to parameters for %ws\n",
                 path
                 ));

            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                );

            //
            // Form a path to this driver's Parameters subkey.
            //

            RtlInitUnicodeString(
                &parametersPath,
                NULL
                );

            parametersPath.MaximumLength = RegistryPath->Length +
                                           sizeof(L"\\Parameters");

            parametersPath.Buffer = ExAllocatePool(
                                        PagedPool,
                                        parametersPath.MaximumLength
                                        );

            if (!parametersPath.Buffer) {

                BusPrint((
                    1,
                    "BusServiceParameters: Couldn't allocate string for path to parameters for %ws\n",
                     path
                    ));

                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            L"\\Parameters"
            );

        BusPrint((
            1,
            "BusServiceParameters: parameters path is %ws\n",
             parametersPath.Buffer
            ));

        //
        // Form the default pointer port device name, in case it is not
        // specified in the registry.
        //

        RtlInitUnicodeString(
            &defaultUnicodeName,
            DD_POINTER_PORT_BASE_NAME_U
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"MouseDataQueueSize";
        parameters[0].EntryContext =
            &configuration->MouseAttributes.InputDataQueueLength;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultDataQueueSize;
        parameters[0].DefaultLength = sizeof(ULONG);

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"NumberOfButtons";
        parameters[1].EntryContext = &numberOfButtons;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultNumberOfButtons;
        parameters[1].DefaultLength = sizeof(USHORT);

        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"PointerDeviceBaseName";
        parameters[2].EntryContext = DeviceName;
        parameters[2].DefaultType = REG_SZ;
        parameters[2].DefaultData = defaultUnicodeName.Buffer;
        parameters[2].DefaultLength = 0;

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_ABSOLUTE,
                     parametersPath.Buffer,
                     parameters,
                     NULL,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            BusPrint((
                1,
                "BusServiceParameters: RtlQueryRegistryValues failed with 0x%x\n",
                status
                ));
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // Go ahead and assign driver defaults.
        //

        configuration->MouseAttributes.InputDataQueueLength =
            defaultDataQueueSize;
        RtlCopyUnicodeString(DeviceName, &defaultUnicodeName);
    }

    BusPrint((
        1,
        "BusServiceParameters: Pointer port base name = %ws\n",
        DeviceName->Buffer
        ));

    if (configuration->MouseAttributes.InputDataQueueLength == 0) {

        BusPrint((
            1,
            "BusServiceParameters: overriding MouseInputDataQueueLength = 0x%x\n",
            configuration->MouseAttributes.InputDataQueueLength
            ));

        configuration->MouseAttributes.InputDataQueueLength =
            defaultDataQueueSize;
    }

    configuration->MouseAttributes.InputDataQueueLength *=
        sizeof(MOUSE_INPUT_DATA);

    BusPrint((
        1,
        "BusServiceParameters: MouseInputDataQueueLength = 0x%x\n",
        configuration->MouseAttributes.InputDataQueueLength
        ));

    configuration->MouseAttributes.NumberOfButtons = (USHORT) numberOfButtons;
    BusPrint((
        1,
        "BusServiceParameters: NumberOfButtons = %d\n",
        configuration->MouseAttributes.NumberOfButtons
        ));

    configuration->MouseAttributes.SampleRate = (USHORT) sampleRate;
    BusPrint((
        1,
        "BusServiceParameters: SampleRate = %d\n",
        configuration->MouseAttributes.SampleRate
        ));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

    BusPrint((
        1,
        "BusServiceParameters: Exit\n"
        ));

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\busmouse\i386\buscfg.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation
Copyright (c) 1992  Logitech Inc.

Module Name:

    buscfg.h

Abstract:

    These are the machine-dependent configuration constants that are used in
    the Bus mouse port driver.

Revision History:

--*/

#ifndef _BUSCFG_
#define _BUSCFG_

//
// Define the interrupt-related configuration constants.
//

#define BUS_INTERFACE_TYPE      Isa
#define BUS_INTERRUPT_MODE      Latched
#define BUS_INTERRUPT_SHARE     FALSE

#define BUS_FLOATING_SAVE       FALSE

#define MOUSE_VECTOR            9
#define MOUSE_IRQL              MOUSE_VECTOR
#define BUS_PHYSICAL_BASE       0x23C
#define BUS_REGISTER_LENGTH     4
#define BUS_REGISTER_SHARE      FALSE
#define BUS_PORT_TYPE           CM_RESOURCE_PORT_IO

//
// Define the default number of entries in the input data queue.
//

#define DATA_QUEUE_SIZE         100

#endif // _INPCFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\busmouse\i386\busmouse.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993  Microsoft Corporation
Copyright (c) 1992  Logitech Inc.

Module Name:

    busmouse.h

Abstract:

    These are the structures and defines that are used in the
    Microsoft/Logitech Bus mouse port driver.

Revision History:

--*/

#ifndef _BUSMOUSE_
#define _BUSMOUSE_

#include <ntddmou.h>
#include "kbdmou.h"
#include "buscfg.h"

//
// Default number of buttons and sample rate for the Inport mouse.
//

#define MOUSE_NUMBER_OF_BUTTONS     3
#define MOUSE_SAMPLE_RATE_50HZ      50

//
// NOTE:  This should be defined in the DDK instead...
//

#define MOUSE_BUS_HARDWARE          MOUSE_INPORT_HARDWARE
#define FILE_DEVICE_BUS_PORT        FILE_DEVICE_INPORT_PORT
#define BUSMOUSE_ERROR_VALUE_BASE   INPORT_ERROR_VALUE_BASE


//
// Define the control port bits.
//

#define BUS_CONTROL_INTERRUPT_DISABLE 0x10
#define BUS_CONTROL_COUNTER_CAPTURE   0x80
#define BUS_CONTROL_X_LOW             0x00
#define BUS_CONTROL_X_HIGH            0x20
#define BUS_CONTROL_Y_LOW             0x40
#define BUS_CONTROL_Y_HIGH            0x60

//
// Define the Bus data bits
//

#define BUS_DATA_BUTTON_1             0x80
#define BUS_DATA_BUTTON_1_SHIFT       0x06
#define BUS_DATA_BUTTON_2             0x40
#define BUS_DATA_BUTTON_2_SHIFT       0x04
#define BUS_DATA_BUTTON_3             0x20
#define BUS_DATA_BUTTON_3_SHIFT       0x05

//
// Define the Configuration byte
//

#define BUS_CONFIGURATION_VALUE       0x91

//
// Define the registers.
//

#define BUS_DATA_PORT_READ                0x00
#define BUS_SIGNATURE_PORT_READ_WRITE     0x01
#define BUS_INTERRUPT_PORT_READ           0x02
#define BUS_CONTROL_PORT_WRITE            0x02
#define BUS_CONFIGURATION_PORT_READ_WRITE 0x03

//
// Inport mouse configuration information.
//

typedef struct _BUS_CONFIGURATION_INFORMATION {

    //
    // Bus interface type.
    //

    INTERFACE_TYPE InterfaceType;

    //
    // Bus Number.
    //

    ULONG BusNumber;

#ifdef PNP_IDENTIFY
    //
    // Controller type & number
    //

    CONFIGURATION_TYPE ControllerType;
    ULONG ControllerNumber;

    //
    // Peripheral type & number

    CONFIGURATION_TYPE PeripheralType;
    ULONG PeripheralNumber;
#endif

    //
    // The port/register resources used by this device.
    //

    CM_PARTIAL_RESOURCE_DESCRIPTOR PortList[1];
    ULONG PortListCount;

    //
    // Interrupt resources.
    //

    CM_PARTIAL_RESOURCE_DESCRIPTOR MouseInterrupt;

    //
    // The mapped address for the set of this device's registers.
    //

    PUCHAR DeviceRegisters[1];

    //
    // Set at intialization to indicate that the base register
    // address must be unmapped when the driver is unloaded.
    //

    BOOLEAN UnmapRegistersRequired;

    //
    // Flag that indicates whether floating point context should be saved.
    //

    BOOLEAN FloatingSave;

    //
    // Mouse attributes.
    //

    MOUSE_ATTRIBUTES MouseAttributes;

} BUS_CONFIGURATION_INFORMATION, *PBUS_CONFIGURATION_INFORMATION;

//
// Port device extension.
//

typedef struct _DEVICE_EXTENSION {

    //
    // If HardwarePresent is TRUE, there is an Inport mouse present in
    // the system.
    //

    BOOLEAN HardwarePresent;

    //
    // Port configuration information.
    //

    BUS_CONFIGURATION_INFORMATION Configuration;

    //
    // Reference count for number of mouse enables.
    //

    LONG MouseEnableCount;

    //
    // Pointer to the device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Mouse class connection data.
    //

    CONNECT_DATA ConnectData;

    //
    // Number of input data items currently in the mouse InputData queue.
    //

    ULONG InputCount;

    //
    // Start of the port mouse input data queue (really a circular buffer).
    //

    PMOUSE_INPUT_DATA InputData;

    //
    // Insertion pointer for mouse InputData.
    //

    PMOUSE_INPUT_DATA DataIn;

    //
    // Removal pointer for mouse InputData.
    //

    PMOUSE_INPUT_DATA DataOut;

    //
    // Points one input packet past the end of the InputData buffer.
    //

    PMOUSE_INPUT_DATA DataEnd;

    //
    // Current mouse input packet.
    //

    MOUSE_INPUT_DATA CurrentInput;

    //
    // Keep track of the previous button state.
    //

    UCHAR PreviousButtons;

    //
    // Pointer to interrupt object.
    //

    PKINTERRUPT InterruptObject;

    //
    // Mouse ISR DPC queue.
    //

    KDPC IsrDpc;

    //
    // Mouse ISR DPC recall queue.
    //

    KDPC IsrDpcRetry;

    //
    // Used by the ISR and the ISR DPC (in BusDpcVariableOperation calls)
    // to control processing by the ISR DPC.
    //

    LONG DpcInterlockVariable;

    //
    // Spinlock used to protect the DPC interlock variable.
    //

    KSPIN_LOCK SpinLock;

    //
    // Timer used to retry the ISR DPC routine when the class
    // driver is unable to consume all the port driver's data.
    //

    KTIMER DataConsumptionTimer;

    //
    // DPC queue for logging overrun and internal driver errors.
    //

    KDPC ErrorLogDpc;

    //
    // Request sequence number (used for error logging).
    //

    ULONG SequenceNumber;

    //
    // Indicates which pointer port device this driver created (UnitId
    // is the suffix appended to the pointer port basename for the
    // call to IoCreateDevice).
    //

    USHORT UnitId;

    //
    // Indicates whether it is okay to log overflow errors.
    //

    BOOLEAN OkayToLogOverflow;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define the port Get/SetDataQueuePointer context structures.
//

typedef struct _GET_DATA_POINTER_CONTEXT {
    IN PDEVICE_EXTENSION DeviceExtension;
    OUT PVOID DataIn;
    OUT PVOID DataOut;
    OUT ULONG InputCount;
} GET_DATA_POINTER_CONTEXT, *PGET_DATA_POINTER_CONTEXT;

typedef struct _SET_DATA_POINTER_CONTEXT {
    IN PDEVICE_EXTENSION DeviceExtension;
    IN ULONG InputCount;
    IN PVOID DataOut;
} SET_DATA_POINTER_CONTEXT, *PSET_DATA_POINTER_CONTEXT;

//
// Define the context structure and operations for BusDpcVariableOperation.
//

typedef enum _OPERATION_TYPE {
        IncrementOperation,
        DecrementOperation,
        WriteOperation,
        ReadOperation
} OPERATION_TYPE;

typedef struct _VARIABLE_OPERATION_CONTEXT {
    IN PLONG VariableAddress;
    IN OPERATION_TYPE Operation;
    IN OUT PLONG NewValue;
} VARIABLE_OPERATION_CONTEXT, *PVARIABLE_OPERATION_CONTEXT;

//
// Function prototypes.
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
DBusFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DBusInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
DBusInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID
DBusIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DBusOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DBusStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DBusUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
BusBuildResourceList(
    IN PDEVICE_EXTENSION DeviceExtension,
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceListSize
    );

VOID
BusConfiguration(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DeviceName
    );

VOID
BusDisableInterrupts(
    IN PVOID Context
    );

VOID
BusDpcVariableOperation(
    IN  PVOID Context
    );

VOID
BusEnableInterrupts(
    IN PVOID Context
    );

VOID
BusErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
BusGetDataQueuePointer(
    IN PVOID Context
    );

VOID
BusInitializeDataQueue(
    IN PVOID Context
    );

NTSTATUS
BusInitializeHardware(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
BusPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

VOID
BusServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DeviceName
    );

VOID
BusSetDataQueuePointer(
    IN PVOID Context
    );

BOOLEAN
BusWriteDataToQueue(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PMOUSE_INPUT_DATA InputData
    );

#if DBG

VOID
BusDebugPrint(
    IN ULONG DebugPrintLevel,
    IN PCCHAR DebugMessage,
    ...
    );

#define BusPrint(x) BusDebugPrint x
#else
#define BusPrint(x)
#endif

#endif // _BUSMOUSE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\devdesc\devdesc.h ===
#ifndef __DEVDESC_H__
#define __DEVDESC_H__

typedef struct {
    INTERFACE_TYPE     InterfaceType;
    ULONG              InterfaceNumber;
    CONFIGURATION_TYPE ControllerType;
    ULONG              ControllerNumber;
    CONFIGURATION_TYPE PeripheralType;
    ULONG              PeripheralNumber;
} HWDESC_INFO, *PHWDESC_INFO;


NTSTATUS
LinkDeviceToDescription(
    IN PUNICODE_STRING     RegistryPath,
    IN PUNICODE_STRING     DeviceName,
    IN INTERFACE_TYPE      BusType,
    IN ULONG               BusNumber,
    IN CONFIGURATION_TYPE  ControllerType,
    IN ULONG               ControllerNumber,
    IN CONFIGURATION_TYPE  PeripheralType,
    IN ULONG               PeripheralNumber
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\devdesc\devdesc.c ===
#include <ntddk.h>

#include "devdesc.h"

#ifdef PNP_IDENTIFY

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,LinkDeviceToDescription)
#endif

NTSTATUS
LinkDeviceToDescription(
    IN PUNICODE_STRING     RegistryPath,
    IN PUNICODE_STRING     DeviceName,
    IN INTERFACE_TYPE      BusType,
    IN ULONG               BusNumber,
    IN CONFIGURATION_TYPE  ControllerType,
    IN ULONG               ControllerNumber,
    IN CONFIGURATION_TYPE  PeripheralType,
    IN ULONG               PeripheralNumber
    )
{
    //
    // This routine will create a volatile "Description" key under the
    // drivers service key. It will store values of the following form
    // in that key:
    //
    // \\Device\\PointerPortX:REG_BINARY:...
    // \\Device\\KeyboardPortX:REG_BINARY:...
    //
    // Where the binary data is six ULONG values (passed as parameters
    // to this routine) that describe the physical location of the device.
    //

    NTSTATUS            Status = STATUS_SUCCESS;
    HANDLE              ServiceKey = NULL, DescriptionKey = NULL;
    UNICODE_STRING      RegString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    ULONG               disposition;
    HWDESC_INFO         HwDescInfo;

    HwDescInfo.InterfaceType    = BusType;
    HwDescInfo.InterfaceNumber  = BusNumber;
    HwDescInfo.ControllerType   = ControllerType;
    HwDescInfo.ControllerNumber = ControllerNumber;
    HwDescInfo.PeripheralType   = PeripheralType;
    HwDescInfo.PeripheralNumber = PeripheralNumber;


    //
    // Open the service subkey
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&ServiceKey,
                       KEY_WRITE,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // Create a volatile Description subkey under the service subkey
    //
    RtlInitUnicodeString(&RegString, L"Description");

    InitializeObjectAttributes(&ObjectAttributes,
                               &RegString,
                               OBJ_CASE_INSENSITIVE,
                               ServiceKey,
                               NULL);

    Status = ZwCreateKey(&DescriptionKey,
                         KEY_ALL_ACCESS,
                         &ObjectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         REG_OPTION_VOLATILE,
                         &disposition);

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // The description data is stored under a REG_BINARY value (name
    // is the DeviceName passed in as a parameter)
    //
    Status = ZwSetValueKey(DescriptionKey,
                           DeviceName,
                           0,
                           REG_BINARY,
                           &HwDescInfo,
                           sizeof(HwDescInfo));


    Clean0:

    if (DescriptionKey) {
        ZwClose(DescriptionKey);
    }

    if (ServiceKey) {
        ZwClose(ServiceKey);
    }

    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\kbdhid\creatcls.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module contains the code for IRP_MJ_CREATE and IRP_MJ_CLOSE
    and IRP_MJ_DEVICE_CONTROL

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include "kbdhid.h"
NTSTATUS
KbdHid_CreateComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;

    UNREFERENCED_PARAMETER (DeviceObject);

    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
KbdHid_Create (
   IN PDEVICE_OBJECT DeviceObject, // the kbdhid device object
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for create/open requests.  This request
    completes successfully, unless the filename's length is non-zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION  irpSp  = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data = NULL;
    KEVENT              event;

    Print(DBG_CC_TRACE, ("DispatchCreate: Enter.\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Determine if request is trying to open a subdirectory of the
    // given device object.  This is not allowed.
    //
    if (0 != irpSp->FileObject->FileName.Length) {
        Print(DBG_CC_ERROR, ("ERROR: Create Access Denied.\n"));

        status = STATUS_ACCESS_DENIED;
        goto KbdHid_CreateReject;
    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        goto KbdHid_CreateReject;
    }

    ExAcquireFastMutex (&data->CreateCloseMutex);

    if (NULL == data->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: enable before connect!\n"));
        status = STATUS_UNSUCCESSFUL;
    } else {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                KbdHid_CreateComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (data->TopOfStack, Irp);
        if (STATUS_PENDING == status) {

            KeWaitForSingleObject(&event,
                                  Executive, // Waiting for reason of a driver
                                  KernelMode, // Waiting in kernel mode
                                  FALSE, // No allert
                                  NULL); // No timeout
        }

        if (NT_SUCCESS (status)) {
            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS (status)) {
            InterlockedIncrement(&data->EnableCount);
            if (NULL == data->ReadFile && 
                (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA)) {
                //
                // We want to start the read pump.
                //
                Print (DBG_IOCTL_INFO, ("Enabling Keyboard \n"));

                data->ReadFile = irpSp->FileObject;
                
                KeResetEvent (&data->ReadCompleteEvent);

                data->ReadInterlock = KBDHID_END_READ;
                
                // Acquire another time for the read irp.
                IoAcquireRemoveLock (&data->RemoveLock, data->ReadIrp);
                data->ReadIrp->IoStatus.Status = STATUS_SUCCESS;
                status = KbdHid_StartRead (data);

                if (STATUS_PENDING == status) {
                    status = STATUS_SUCCESS;
                } else if (!NT_SUCCESS(status)) {
                    //
                    // Set it back to NULL so that a future open tries again.
                    // Read should not fail if open passed. ASSERT!
                    //
                    ASSERT(NT_SUCCESS(status)); 
                    data->ReadFile = NULL;
                } 
            }

            ASSERT (data->EnableCount < 100);
            ASSERT (0 < data->EnableCount);
        }
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;

KbdHid_CreateReject:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;
}

NTSTATUS
KbdHid_Close (
   IN PDEVICE_OBJECT DeviceObject, // the kbdhid device object
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for close requests.  This request
    completes successfully, unless the file name length is zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION   data;
    PIO_STACK_LOCATION  stack;
    LARGE_INTEGER       time;

    Print(DBG_CC_TRACE, ("DispatchClose: Enter\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    ExAcquireFastMutex (&data->CreateCloseMutex);

    ASSERT (data->EnableCount < 100);
    ASSERT (0 < data->EnableCount);

    if (0 == InterlockedDecrement(&data->EnableCount)) {
        Print (DBG_IOCTL_INFO, ("Disabling Keyboard \n"));
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );

        if (IoCancelIrp (data->ReadIrp)) {
            KeWaitForSingleObject (&data->ReadCompleteEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL
                                   );
        }

        ASSERT (NULL != data->ReadFile);
//            ASSERT (data->ReadFile == stack->FileObject);

        time = data->AutoRepeatDelay;
        KeCancelTimer (&data->AutoRepeatTimer);
#if KEYBOARD_HW_CHATTERY_FIX
        KeCancelTimer (&data->InitiateStartReadTimer);
        //
        // NB the time is a negative (relative) number;
        //
        if (data->InitiateStartReadDelay.QuadPart < time.QuadPart) {
            time = data->InitiateStartReadDelay;
        }
#endif // KEYBOARD_HW_CHATTERY_FIX

        time.QuadPart *= 2;
        KeDelayExecutionThread (KernelMode, FALSE, &time);

        data->ReadFile = NULL;
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);

    IoSkipCurrentIrpStackLocation (Irp);
    Print(DBG_CC_TRACE, ("DispatchClose: Exit \n"));
    return IoCallDriver (data->TopOfStack, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\kbdhid\kbdhid.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    KBDHID.C

Abstract:

    This module contains the init code for the i8042 to hid converter.

    Note: This is NOT a WDM driver, since it cannot run as a HID mapper on
    Memphis (Memphis requires that the keyboard to HID mapper be a VXD) and
    since it uses Event logs, which are not part of WDM 1.0

Environment:

    Kernel mode

Revision History:

    Nov-96 : created by Kenneth D. Ray
    Jan-97 : Dan Markarian : Made work
    May-97 : Kenneth D. Ray : reconstructed as PnP filter for Keyboard class

--*/

#include "kbdhid.h"
#include "hidclass.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out). [DAN]
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,KbdHid_GetRegistryParameters)
#pragma alloc_text(PAGE,KbdHid_UpdateRegistryProblemFlagsCallback)
#pragma alloc_text(PAGE,KbdHid_Unload)
#endif

GLOBALS Globals;

NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:

   Installable driver initialization entry point.

Arguments:

   DriverObject - pointer to the driver object

   RegistryPath - pointer to a unicode string representing the path
                  to driver-specific key in the registry

Return Value:

   NT status code

--*/
{
    NTSTATUS        status       = STATUS_SUCCESS;
    PUNICODE_STRING registryPath = &Globals.RegistryPath;

    Print (DBG_SS_TRACE, ("entering DriverEntry\n"));
    Print (DBG_SS_INFO, ("Keyboard to hid mapper\n"));

    RtlZeroMemory (&Globals, sizeof (GLOBALS));

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //
    registryPath->MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length = RegistryPath->Length;
    registryPath->Buffer = ExAllocatePool(
                              PagedPool,
                              registryPath->MaximumLength
                              );

    if (!registryPath->Buffer) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate pool for registry path."));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryReject;
    }

    RtlZeroMemory (registryPath->Buffer, registryPath->MaximumLength);

    RtlMoveMemory (registryPath->Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->Length);

    //
    // Obtain configuration information for this driver.
    //
    status = KbdHid_GetRegistryParameters();
    if (!NT_SUCCESS (status)) {
        goto DriverEntryReject;
    }

    //
    // Set up the device driver entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]              = KbdHid_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]               = KbdHid_Close;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]=KbdHid_IOCTL;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]      = KbdHid_PassThrough;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]       = KbdHid_Flush;
    DriverObject->MajorFunction[IRP_MJ_PNP]                 = KbdHid_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]               = KbdHid_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]      = KbdHid_SystemControl;
    DriverObject->DriverUnload                              = KbdHid_Unload;
    DriverObject->DriverExtension->AddDevice                = KbdHid_AddDevice;

    Print (DBG_SS_TRACE, ("exit DriverEntry (0x%x) \n", status));

    return status;

DriverEntryReject:

    if (registryPath->Buffer) {
        ExFreePool (registryPath->Buffer);
    }
    return status;
}

NTSTATUS
KbdHid_PassThrough (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
/*++

Routine Description:
    Pass the irp on through


--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;

    data = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}

VOID
KbdHid_Unload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources, etc.

Arguments:

   DriverObject - pointer to a driver object

Return Value:

   None

--*/
{
    PAGED_CODE ();

    ASSERT (NULL == Driver->DeviceObject);

    Print (DBG_SS_INFO, ("Unload \n"));

    //
    // Free resources in device extension.
    //
    ExFreePool (Globals.RegistryPath.Buffer);

    return;
}

NTSTATUS
KbdHid_Flush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Respond to flush requests from the mouse class driver.  Currently does
    nothing but pass IRP down to next lower driver.   This routine expects
    the current IRQL to be < DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION  data;
    NTSTATUS           status;
    PIO_STACK_LOCATION stack;

    Print (DBG_CALL_INFO, ("Flush \n"));

    TRAP();

    //
    // Get a pointer to the device extension.
    //
    data = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Send the flush request down to the HID class driver, one for each
    // of our mouse device context structures.
    //

    IoCopyCurrentIrpStackLocationToNext (Irp);
    stack = IoGetNextIrpStackLocation (Irp);

    stack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    stack->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_FLUSH_QUEUE;

    //
    // Fire and forget
    //
    status = IoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}


NTSTATUS
KbdHid_IOCTL (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Respond to queries from the mouse class driver.

    The IOCTLs for DISABLE, ENABLE, and QUERY_ATTRIBUTES, expect the current
    IRQL to be < DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      stack;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       data;
    ULONG                   length;
    PKEYBOARD_INDICATOR_TRANSLATION translation;
    BOOLEAN                 completeIt = TRUE;

    data = DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;
    stack = IoGetCurrentIrpStackLocation (Irp);

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT (data->Started ||
            (IOCTL_INTERNAL_KEYBOARD_CONNECT ==
             stack->Parameters.DeviceIoControl.IoControlCode));

    switch (stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // Connect a keyboard class device driver to the port driver.
        //

        Print (DBG_IOCTL_TRACE, ("enter Connect \n"));

        //
        // Connect a mouse class device driver to the filter driver.
        // Only allow one connection.
        //
        if (NULL != data->ConnectData.ClassService) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Multiple connects \n"));
            TRAP ();
            status = STATUS_SHARING_VIOLATION;
            break;

        } else if (stack->Parameters.DeviceIoControl.InputBufferLength <
                   sizeof(CONNECT_DATA)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Invalid connect parameter size. \n"));
            TRAP ();
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        data->ConnectData = *(PCONNECT_DATA)
                        stack->Parameters.DeviceIoControl.Type3InputBuffer;

        status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:
        //
        // Disconnect a keyboard class device driver from the port driver.
        //
        Print (DBG_IOCTL_TRACE, ("Disconnect \n"));
        TRAP ();

        //
        // Not implemented.
        //
        // To implement, code the following:
        // ---------------------------------
        // o ENSURE that we are NOT enabled (mouHidDeviceExt->EnableCount);
        //   o If we are, then (a) return STATUS_UNSUCCESSFUL, or
        //                     (b) disable all devices immediately; see
        //                         DISABLE IOCTL call for necessary code.
        // o SYNCHRONIZE with the mouse read completion routine (must
        //   protect the callback pointer from being dereferenced when
        //   it becomes null).  Note that no mechanism currently exists
        //   for this.
        // o CLEAR the connection parameters in the device extension;
        //   ie. mouHidDeviceExt->MouClassObject   = NULL;
        //       mouHidDeviceExt->MouClassCallback = NULL;
        // o RELEASE the synchronizing lock.
        // o RETURN STATUS_SUCCESS.
        //

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_INTERNAL_KEYBOARD_ENABLE:
        //
        // Enable keyboard interrupts which really means start the ping pong
        // down to hid class.
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: PnP => use create not enable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    case IOCTL_INTERNAL_KEYBOARD_DISABLE:
        //
        // Disable keyboard interrupts which really means stop the ping pongs
        // down to hid class.
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: PnP => use close not Disable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
        //
        // Query the keyboard attributes.  First check for adequate buffer
        // length.  Then, copy the keyboard attributes from the first device
        // context to the output buffer. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Query Attributes \n"));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_ATTRIBUTES)) {

            Print (DBG_IOCTL_ERROR,
                     ("ERROR: Query Attributes buffer too small \n"));
            TRAP();
            status = STATUS_BUFFER_TOO_SMALL;
        } else {

            //
            // Copy the keyboard attributes to the buffer.
            //

            *(PKEYBOARD_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                data->Attributes;

            Irp->IoStatus.Information = sizeof (KEYBOARD_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
        //
        // Query the scan code to indicator-light mapping. Validate the
        // parameters, and copy the indicator mapping information from
        // the static translation list to the SystemBuffer.
        //
        Print (DBG_IOCTL_TRACE, ("Query Indicator Translation \n"));

        TRAP ();
        length = sizeof(KEYBOARD_INDICATOR_TRANSLATION)
            + (sizeof(INDICATOR_LIST)
            * (HID_KEYBOARD_NUMBER_OF_INDICATORS - 1));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength < length) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Copy the indicator mapping information to the system
        // buffer.
        //

        translation = ((PKEYBOARD_INDICATOR_TRANSLATION)
                       Irp->AssociatedIrp.SystemBuffer);

        translation->NumberOfIndicatorKeys = HID_KEYBOARD_NUMBER_OF_INDICATORS;
        RtlMoveMemory(translation->IndicatorList,
                      (PCHAR) IndicatorList,
                      length - FIELD_OFFSET (KEYBOARD_INDICATOR_TRANSLATION,
                                             IndicatorList));

        Irp->IoStatus.Information = length;
        status = STATUS_SUCCESS;

        break;

    case IOCTL_KEYBOARD_QUERY_INDICATORS:
        //
        // Query the keyboard indicators.  Validate the parameters, and
        // copy the indicator information from the device context to
        // the SystemBuffer. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Query Indicators \n"));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {

            TRAP ();
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Copy the keyboard indicators to the buffer.
        //
        //
        // Don't bother to synchronize access to the device context
        // KeyboardIndicators field while copying it. We don't care
        // if another process is setting the LEDs.
        //

        // Copy the keyboard indicators to the buffer.
        *(PKEYBOARD_INDICATOR_PARAMETERS) Irp->AssociatedIrp.SystemBuffer =
            data->Indicators;

        Irp->IoStatus.Information = sizeof(KEYBOARD_INDICATOR_PARAMETERS);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_KEYBOARD_SET_INDICATORS:
        //
        // Set the keyboard indicators for all known device contexts. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Set Indicators \n"));

        if (stack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Set Indicators size!\n"));
            TRAP ();
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = KbdHid_SetLedIndicators (
                     data,
                     (PKEYBOARD_INDICATOR_PARAMETERS) Irp->AssociatedIrp.SystemBuffer,
                     Irp);

        completeIt = FALSE;

        break;

    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
        //
        // Query the current keyboard typematic rate and delay.  Validate
        // the parameters, and copy the typematic information from the port
        // device extension to the SystemBuffer. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Query Typematic \n"));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: query typematic size!\n"));
            TRAP ();
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Copy the keyboard typematic info to the buffer.
        //

        //
        // Don't bother to synchronize access to the device context
        // KeyboardTypematic field while copying it.  We don't care
        // if another process is setting the typematic info.
        //

        *(PKEYBOARD_TYPEMATIC_PARAMETERS) Irp->AssociatedIrp.SystemBuffer =
            data->Typematic;

        Irp->IoStatus.Information = sizeof(KEYBOARD_TYPEMATIC_PARAMETERS);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_KEYBOARD_SET_TYPEMATIC:
        //
        // Set the keyboard typematic rate and delay for all known device
        // contexts. [DAN]
        //
        Print (DBG_IOCTL_TRACE, ("Set Typematic \n"));

        if (stack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Set Typematic size\n"));
            TRAP ();
            status = STATUS_INVALID_PARAMETER;
            break;

        }

#define NewTypematic ((PKEYBOARD_TYPEMATIC_PARAMETERS) \
                      Irp->AssociatedIrp.SystemBuffer)

        if ((NewTypematic->Rate == 0) && (NewTypematic->Delay == 0)) {
            break;
        }

        if ((NewTypematic->Rate  < data->Attributes.KeyRepeatMinimum.Rate) ||
            (NewTypematic->Rate  > data->Attributes.KeyRepeatMaximum.Rate) ||
            (NewTypematic->Delay < data->Attributes.KeyRepeatMinimum.Delay) ||
             (NewTypematic->Delay > data->Attributes.KeyRepeatMaximum.Delay)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Set Typematic range\n"));
            TRAP ();
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        Print (DBG_IOCTL_INFO,
                 ("Set Typematic Rate: %d Delay: %d\n",
                  NewTypematic->Rate,
                  NewTypematic->Delay));

        //
        // Don't bother to synchronize access to the device context
        // KeyboardTypematic field while copying it.  We don't care
        // if another thread is reading the typematic info.
        //
        // Note the only danger here is in setting the 64-bit integer
        // "AutoRepeatDelay" in two non-atomic statements.   However,
        // we are safe since we never set "HighPart" to anything but
        // -1.
        //
        data->Typematic = *NewTypematic;

        data->AutoRepeatRate = 1000 / NewTypematic->Rate;           // ms
        data->AutoRepeatDelay.LowPart = -NewTypematic->Delay*10000; // 100ns
        data->AutoRepeatDelay.HighPart = -1;
        break;

#undef NewTypematic

    default:
        Print (DBG_IOCTL_ERROR,
                 ("ERROR: unknown IOCTL: 0x%x \n",
                  stack->Parameters.DeviceIoControl.IoControlCode));
        TRAP ();
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    if (completeIt) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    Print (DBG_IOCTL_TRACE, ("IOCTL exit (%x)\n", status));
    return status;
}

NTSTATUS
KbdHid_GetRegistryParameters()
/*++

Routine Description:

    This routine retrieves this driver's parameters from the registry,
    including it's base device name.

Return Value:

--*/
{
    PRTL_QUERY_REGISTRY_TABLE parameters     = NULL;
    UNICODE_STRING            parametersPath = {0,0,0};
    PWSTR                     path           = NULL;
    USHORT                    queriesPlus1   = 2;
    NTSTATUS                  status         = STATUS_SUCCESS;

    PAGED_CODE ();

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it as a string.
    //
    path = Globals.RegistryPath.Buffer;

    //
    // Allocate the Rtl query table.
    //
    parameters = ExAllocatePool(
                     PagedPool,
                     sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlus1);

    if (!parameters) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate table for Rtl query to parameters for %ws.",
                path));

        status = STATUS_UNSUCCESSFUL;
        goto KbdHid_GetRegistryParametersExit;
    }

    RtlZeroMemory(parameters, sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlus1);

    //
    // Form a path to this driver's Parameters subkey.
    //
    parametersPath.MaximumLength = Globals.RegistryPath.Length
                                 + sizeof(L"\\Parameters");

    parametersPath.Buffer = ExAllocatePool(PagedPool,
                                           parametersPath.MaximumLength);

    if (!parametersPath.Buffer) {

        Print (DBG_SS_ERROR,
                    ("Initialize: Couldn't allocate string for path to parameters for %ws.",
                     path));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_GetRegistryParametersExit;
    }

    //
    // Form the parameters path.
    //
    RtlZeroMemory(parametersPath.Buffer, parametersPath.MaximumLength);
    RtlAppendUnicodeToString(&parametersPath, path);
    RtlAppendUnicodeToString(&parametersPath, L"\\Parameters");

#if 0 // We ignore the device name since this is now plug and play

    //
    // Gather all of the "user specified" information from
    // the registry.
    //
    parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = L"KeyboardDeviceBaseName";
    parameters[0].EntryContext = DeviceName;
    parameters[0].DefaultType = REG_SZ;
    parameters[0].DefaultData = defaultUnicodeName.Buffer;
    parameters[0].DefaultLength = 0;


    status = RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE,
                                     parametersPath.Buffer,
                                     parameters,
                                     NULL,
                                     NULL);
#endif

    if (!NT_SUCCESS(status)) {

        Print (DBG_SS_ERROR,
               ("ERROR: Initialize: RtlQueryRegistryValues (0x%x).",
                status));
    }


KbdHid_GetRegistryParametersExit:
    //
    // Free the allocated memory before returning.
    //
    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

    return status;
}

NTSTATUS
KbdHid_SetLedIndicatorsComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PIO_STACK_LOCATION  stack;
    PDEVICE_EXTENSION   data;

    stack = IoGetCurrentIrpStackLocation (Irp);
    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (Irp->PendingReturned) {
        IoMarkIrpPending (Irp);
    }

    IoFreeMdl (Irp->MdlAddress);
    Irp->MdlAddress = (PMDL) stack->Parameters.Others.Argument4;

    ExFreePool (Context);

    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return STATUS_SUCCESS;
}

NTSTATUS
KbdHid_SetLedIndicators (
    PDEVICE_EXTENSION               Data,
    PKEYBOARD_INDICATOR_PARAMETERS  NewIndicators,
    PIRP                            Irp
    )
/*++

Routine Description:

    Set the LED indicators of the supplied keyboard device context.

Arguments:

    Data       - Pointer to the driver device extension.

    Parameters - Pointer to the keyboard indicators to set/unset.

    Irp        - An Irp to use for setting these parameters

Return Value:

    STATUS_SUCCESS on success, STATUS_PENDING if operation is still pending,
    or otherwise an NTSTATUS error code on an error.

--*/
{
    PIO_STACK_LOCATION nextStack;
    PIO_STACK_LOCATION curStack;
    NTSTATUS           status         = STATUS_SUCCESS;
    USAGE              usageBuffer [4]; // only 4 known usages hardcoded below
    ULONG              usageBufferLen = 0;
    PCHAR              outputBuffer = 0;
    PMDL               outputMdl = 0;
    PHID_EXTENSION     hid = Data->HidExtension;

    status = IoAcquireRemoveLock (&Data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    if (0 == hid->Caps.OutputReportByteLength) {
        //
        // This device has no LEDs, now while that is strange it is not really
        // an error.  HID keyboards can have any LEDs that they want, including
        // none.
        //
        status = STATUS_SUCCESS;
        goto KbdHid_SetIndicatorsReject;
    }

    outputBuffer = ExAllocatePool (NonPagedPool,
                                   hid->Caps.OutputReportByteLength);

    if (NULL == outputBuffer) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_SetIndicatorsReject;
    }

    outputMdl = IoAllocateMdl (outputBuffer,   // The virtual address
                               hid->Caps.OutputReportByteLength, // length of the MDL
                               FALSE,  // No associated IRP -> not secondary
                               FALSE,  // No quota charge
                               0);     // No associated IRP

    if (NULL == outputMdl) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_SetIndicatorsReject;
    }

    MmBuildMdlForNonPagedPool (outputMdl);  // Build this MDL.

    //
    // Zero the output report packet.
    //
    RtlZeroMemory(outputBuffer, hid->Caps.OutputReportByteLength);

    //
    // Setup the usage list of LEDs.
    //
    if (NewIndicators->LedFlags & KEYBOARD_KANA_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_KANA;
    }
    if (NewIndicators->LedFlags & KEYBOARD_CAPS_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_CAPS_LOCK;
    }
    if (NewIndicators->LedFlags & KEYBOARD_NUM_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_NUM_LOCK;
    }
    if (NewIndicators->LedFlags & KEYBOARD_SCROLL_LOCK_ON) {
        usageBuffer[usageBufferLen++] = HID_USAGE_LED_SCROLL_LOCK;
    }

    if (usageBufferLen == 0) {
        ASSERT((NewIndicators->LedFlags & (KEYBOARD_KANA_LOCK_ON |
                                           KEYBOARD_CAPS_LOCK_ON |
                                           KEYBOARD_NUM_LOCK_ON |
                                           KEYBOARD_SCROLL_LOCK_ON)) == 0);
        //
        // In order to fix led setting on a multiple collection keyboard, we 
        // have to initialize the output report to make sure we get the correct
        // collection id. This is for the case where we are going from one 
        // led on to all leds off. If not initialized, we'll get a report with no 
        // collection id at the beginning.
        //
        usageBuffer[0] = HID_USAGE_LED_SCROLL_LOCK; // arbitirary led
        usageBufferLen = 1;
    
        HidP_UnsetUsages(HidP_Output,
                         HID_USAGE_PAGE_LED,
                         0,
                         usageBuffer,
                         &usageBufferLen,
                         hid->Ppd,
                         outputBuffer,
                         hid->Caps.OutputReportByteLength);

    }
    else {
        //
        // Set the usages in the output report.
        //
        HidP_SetUsages(HidP_Output,
                       HID_USAGE_PAGE_LED,
                       0,
                       usageBuffer,
                       &usageBufferLen,
                       hid->Ppd,
                       outputBuffer,
                       hid->Caps.OutputReportByteLength);
    }

    //
    // Obtain a pointer to the next IRP stack location.
    //
    nextStack = IoGetNextIrpStackLocation (Irp);
    curStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT(nextStack != NULL);

    //
    // Set up our write to HIDCLASS.
    //
    curStack->Parameters.Others.Argument4 = (PVOID) Irp->MdlAddress;
    Irp->MdlAddress = outputMdl;

    IoCopyCurrentIrpStackLocationToNext (Irp);
    nextStack->MajorFunction           = IRP_MJ_WRITE;
    nextStack->Parameters.Write.Length = hid->Caps.OutputReportByteLength;
    nextStack->Parameters.Write.Key    = 0;
    nextStack->Parameters.Write.ByteOffset.QuadPart = 0;

    //
    // Hook a completion routine to be called when the request completes.
    //

    IoSetCompletionRoutine (Irp,
                            KbdHid_SetLedIndicatorsComplete,
                            outputBuffer,
                            TRUE,
                            TRUE,
                            TRUE);
    //
    // Call the next driver.
    //
    status = IoCallDriver(Data->TopOfStack, Irp);

    //
    // Return status.
    //
    return status;

KbdHid_SetIndicatorsReject:

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    if (NULL != outputBuffer) {
        ExFreePool (outputBuffer);
    }
    if (NULL != outputMdl) {
        IoFreeMdl (outputMdl);
    }
    IoReleaseRemoveLock (&Data->RemoveLock, Irp);
    return status;
}

VOID
KbdHid_UpdateRegistryProblemFlags(
    IN PDEVICE_EXTENSION    Data
    )
/*++

[DAN]

Routine Description:

    This routine stores the OR'd ProblemFlags value into the registry.
    It will queue the write to the registry if this routine is not run
    at PASSIVE_LEVEL.

Arguments:

    KbdHidDeviceExt - HID Keyboard Filter Driver device extension.

Return Value:

    None.

--*/

{
    PIO_WORKITEM    item;
    NTSTATUS        status;

    status = IoAcquireRemoveLock (&Data->RemoveLock, KbdHid_UpdateRegistryProblemFlags);
    if (!NT_SUCCESS (status)) {
        //
        // Device has gone away, just silently exit
        //
        return;
    }

    item = IoAllocateWorkItem (Data->Self);

    if (item) {

        if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
            //
            // We are safely at PASSIVE_LEVEL, call callback directly to perform
            // this operation immediately.
            //
            KbdHid_UpdateRegistryProblemFlagsCallback (Data->Self, item);

        } else {
            //
            // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
            // at a later time.
            //
            IoQueueWorkItem (item,
                             KbdHid_UpdateRegistryProblemFlagsCallback,
                             DelayedWorkQueue,
                             item);
        }
    }
    else {
        //
        // Match the Acquire at the top of the function
        //
        IoReleaseRemoveLock (&Data->RemoveLock, KbdHid_UpdateRegistryProblemFlags);
    }
}

VOID
KbdHid_UpdateRegistryProblemFlagsCallback (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM Item
    )
/*++

[DAN]

Routine Description:

    This routine stores the OR'd ProblemFlags value into the registry.  This
    routine must execute at PASSIVE_LEVEL.

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;
    HANDLE              hDevNode;
    UNICODE_STRING      strProblemFlags;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension; 

    status = IoOpenDeviceRegistryKey (data->PDO,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &hDevNode);

    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString (&strProblemFlags, L"ProblemFlags");

        ZwSetValueKey (hDevNode,
                       &strProblemFlags,
                       0,
                       REG_DWORD,
                       &data->ProblemFlags,
                       sizeof(data->ProblemFlags));

        ZwClose(hDevNode);
    }
    else {
        Print(DBG_SS_ERROR,
                   ("UpdateRegistryProblemFlags: failed (%x).\n", status));
    }

    IoReleaseRemoveLock(&data->RemoveLock, KbdHid_UpdateRegistryProblemFlags);
    IoFreeWorkItem(Item);
}

VOID
KbdHid_LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN NTSTATUS       ErrorCode,
   IN PWSTR          ErrorInsertionString OPTIONAL)
/*++

[DAN]

Routine Description:

    Logs an error to the system.

Arguments:

    DriverObject - Pointer to driver object reporting the error.

    ErrorCode    - Indicates the type of error, system or driver-defined.

    ErrorInsertionString - Null-terminated Unicode string inserted into error
                           description, as defined by error code.  Must be no
                           no longer than 50 characters.

Return Value:

    None.

--*/
{
   ULONG                errorInsertionStringSize = 0;
   PIO_ERROR_LOG_PACKET errorLogEntry;
   ULONG                errorLogEntrySize;                  // [including null]
   PWCHAR               pWChar;

   if (ErrorInsertionString) {
      for (pWChar = ErrorInsertionString; *pWChar; pWChar++) {
         errorInsertionStringSize += sizeof(WCHAR);
      }
      errorInsertionStringSize += sizeof(UNICODE_NULL);
   }

   errorLogEntrySize = sizeof(IO_ERROR_LOG_PACKET) + errorInsertionStringSize;

   //
   // Log an error.
   //
   if (errorLogEntrySize <= ERROR_LOG_MAXIMUM_SIZE) {

      errorLogEntry = IoAllocateErrorLogEntry(DriverObject,
                                              (UCHAR)errorLogEntrySize);

      if (errorLogEntry != NULL) {

         RtlZeroMemory(errorLogEntry, errorLogEntrySize);

         errorLogEntry->ErrorCode       = ErrorCode;
         errorLogEntry->FinalStatus     = ErrorCode;
         errorLogEntry->NumberOfStrings = (ErrorInsertionString) ? 1 : 0;

         if (ErrorInsertionString) {
           RtlCopyMemory(errorLogEntry->DumpData,
                         ErrorInsertionString,
                         errorInsertionStringSize);
         }

         IoWriteErrorLogEntry(errorLogEntry);
      }
   }

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\kbdhid\pnp.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hid.c

Abstract:

    This module contains the code for translating HID reports to keyboard
    reports.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

//
// For this module only we set the INITGUID macro before including wdm and
// hidclass.h  This not only declares the guids but also initializes them.
//

#include "kbdhid.h"
#include "hidclass.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,KbdHid_CallHidClass)
#pragma alloc_text(PAGE,KbdHid_AddDevice)
#pragma alloc_text(PAGE,KbdHid_StartDevice)
#pragma alloc_text(PAGE,KbdHid_PnP)
#endif

NTSTATUS
KbdHid_CallHidClass(
    IN PDEVICE_EXTENSION    Data,
    IN ULONG          Ioctl,
    PVOID             InputBuffer,
    ULONG             InputBufferLength,
    PVOID             OutputBuffer,
    ULONG             OutputBufferLength
    )
/*++

Routine Description:

   Make a *synchronous* request of the HID class driver

Arguments:

    Ioctl              - Value of the IOCTL request.

    InputBuffer        - Buffer to be sent to the HID class driver.

    InputBufferLength  - Size of buffer to be sent to the HID class driver.

    OutputBuffer       - Buffer for received data from the HID class driver.

    OutputBufferLength - Size of receive buffer from the HID class.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            status = STATUS_SUCCESS;

    PAGED_CODE ();

    Print(DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));

    //
    // issue a synchronous request
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
                            Ioctl,
                            Data->TopOfStack,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            FALSE, // External
                            &event,
                            &ioStatus);

    if (NULL == irp) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    status = IoCallDriver(Data->TopOfStack, irp);

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                     &event,
                     Executive, // wait reason
                     KernelMode,
                     FALSE,     // we are not alertable
                     NULL);     // No time out !!!!
    }

    if (NT_SUCCESS (status)) {
        status = ioStatus.Status;
    }

    Print(DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));
    return status;
}

NTSTATUS
KbdHid_QueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}




NTSTATUS
KbdHid_AddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data;
    PDEVICE_OBJECT      device;
    POWER_STATE         state;

    PAGED_CODE ();


    Print (DBG_PNP_TRACE, ("enter Add Device \n"));

    status = IoCreateDevice(Driver,
                            sizeof(DEVICE_EXTENSION),
                            NULL, // no name for this Filter DO
                            FILE_DEVICE_KEYBOARD,
                            0,
                            FALSE,
                            &device);

    if (!NT_SUCCESS (status)) {
        return(status);
    }

    data = (PDEVICE_EXTENSION) device->DeviceExtension;

    //
    // Initialize the fields.
    //
    data->TopOfStack = IoAttachDeviceToDeviceStack (device, PDO);
    if (data->TopOfStack == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(Driver,
                                    (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = KBDHID_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }
    
    ASSERT (data->TopOfStack);

    data->Self = device;
    data->Started = FALSE;
    data->Initialized = FALSE;
    data->UnitId = (USHORT) InterlockedIncrement (&Globals.UnitId);
    data->PDO = PDO;

    KeInitializeSpinLock(&data->usageMappingSpinLock);

    data->ReadIrp = IoAllocateIrp (data->TopOfStack->StackSize, FALSE);
    // Initializiation happens automatically.
    if (NULL == data->ReadIrp) {
        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (device);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent (&data->ReadCompleteEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent (&data->ReadSentEvent, NotificationEvent, TRUE);
    IoInitializeRemoveLock (&data->RemoveLock, KBDHID_POOL_TAG, 1,  10);
    data->ReadFile = NULL;
    ExInitializeFastMutex (&data->CreateCloseMutex);

    data->InputData.UnitId = data->UnitId;
    data->InputData.MakeCode = 0;
    data->InputData.Flags = 0;

    data->ScanState   = Normal;
    //
    // Initialize the keyboard attributes structure.  This information is
    // queried via IOCTL_KEYBOARD_QUERY_ATTRIBUTES. [DAN]
    //
    data->Attributes.KeyboardIdentifier.Type = HID_KEYBOARD_IDENTIFIER_TYPE;
    data->Attributes.KeyboardIdentifier.Subtype = 0;
    data->IdEx.Type = HID_KEYBOARD_IDENTIFIER_TYPE;
    data->IdEx.Subtype = 0;
    data->Attributes.KeyboardMode = HID_KEYBOARD_SCAN_CODE_SET;
    data->Attributes.NumberOfFunctionKeys = HID_KEYBOARD_NUMBER_OF_FUNCTION_KEYS;
    data->Attributes.NumberOfIndicators = HID_KEYBOARD_NUMBER_OF_INDICATORS;
    data->Attributes.NumberOfKeysTotal = HID_KEYBOARD_NUMBER_OF_KEYS_TOTAL;
    data->Attributes.InputDataQueueLength = 1;
    data->Attributes.KeyRepeatMinimum.UnitId = data->UnitId;
    data->Attributes.KeyRepeatMinimum.Rate = HID_KEYBOARD_TYPEMATIC_RATE_MINIMUM;
    data->Attributes.KeyRepeatMinimum.Delay = HID_KEYBOARD_TYPEMATIC_DELAY_MINIMUM;
    data->Attributes.KeyRepeatMaximum.UnitId = data->UnitId;
    data->Attributes.KeyRepeatMaximum.Rate = HID_KEYBOARD_TYPEMATIC_RATE_MAXIMUM;
    data->Attributes.KeyRepeatMaximum.Delay = HID_KEYBOARD_TYPEMATIC_DELAY_MAXIMUM;

    //
    // Initialize the keyboard indicators structure. [DAN]
    //
    data->Indicators.UnitId   = data->UnitId;
    data->Indicators.LedFlags = 0;

    //
    // Initialize the keyboard typematic info structure. [DAN]
    //
    data->Typematic.UnitId = data->UnitId;
    data->Typematic.Rate   = HID_KEYBOARD_TYPEMATIC_RATE_DEFAULT;
    data->Typematic.Delay  = HID_KEYBOARD_TYPEMATIC_DELAY_DEFAULT;

    //
    // Initialize private typematic information. [DAN]
    //
    KeInitializeDpc (&data->AutoRepeatDPC, KbdHid_AutoRepeat, data);
    KeInitializeTimer (&data->AutoRepeatTimer);
    data->AutoRepeatRate = 1000 / HID_KEYBOARD_TYPEMATIC_RATE_DEFAULT;    //ms
    data->AutoRepeatDelay.LowPart = -HID_KEYBOARD_TYPEMATIC_DELAY_DEFAULT * 10000;
    //100ns
    data->AutoRepeatDelay.HighPart = -1;



#if KEYBOARD_HW_CHATTERY_FIX // [DAN]
    //
    // Initialize StartRead-initiator DPC.
    //
    KeInitializeDpc (&data->InitiateStartReadDPC,
                     KbdHid_InitiateStartRead,
                     data);
    KeInitializeTimer (&data->InitiateStartReadTimer);
    data->InitiateStartReadDelay.QuadPart = -DEFAULT_START_READ_DELAY;
    data->InitiateStartReadUserNotified = FALSE;
#endif

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState (device, DevicePowerState, state);

    data->WmiLibInfo.GuidCount = sizeof (KbdHid_WmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);

    data->WmiLibInfo.GuidList = KbdHid_WmiGuidList;
    data->WmiLibInfo.QueryWmiRegInfo = KbdHid_QueryWmiRegInfo;
    data->WmiLibInfo.QueryWmiDataBlock = KbdHid_QueryWmiDataBlock;
    data->WmiLibInfo.SetWmiDataBlock = KbdHid_SetWmiDataBlock;
    data->WmiLibInfo.SetWmiDataItem = KbdHid_SetWmiDataItem;
    data->WmiLibInfo.ExecuteWmiMethod = NULL;
    data->WmiLibInfo.WmiFunctionControl = NULL;

    device->Flags |= DO_POWER_PAGABLE;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
KbdHid_StartDevice (
    IN PDEVICE_EXTENSION    Data
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    HIDP_CAPS                  caps; // the capabilities of the found hid device
    HID_COLLECTION_INFORMATION info;
    NTSTATUS                   status = STATUS_SUCCESS;
    PHIDP_PREPARSED_DATA       preparsedData = NULL;
    PHID_EXTENSION             hid = NULL;
    ULONG                      length, usageListLength, inputBufferLength;
    ULONG                      maxUsages;
    PCHAR                      buffer;
    HANDLE                     devInstRegKey;
    ULONG                      tmp;

    PAGED_CODE ();

    Print (DBG_PNP_TRACE, ("enter START Device \n"));

    //
    // Check the registry for any usage mapping information
    // for this particular keyboard.
    //
    // Note: Need to call this after devnode created
    //       (after START_DEVICE completes).
    //       For raw devices, this will fail on the first start
    //       (b/c devnode not there yet)
    //       but succeed on the second start.
    //
    LoadKeyboardUsageMappingList (Data);

    //
    // Retrieve the capabilities of this hid device
    // IOCTL_HID_GET_COLLECTION_INFORMATION fills in HID_COLLECTION_INFORMATION.
    // we are interested in the Descriptor Size, which tells us how big a
    // buffer to allocate for the preparsed data.
    //
    if (!NT_SUCCESS (status = KbdHid_CallHidClass (
                                        Data,
                                        IOCTL_HID_GET_COLLECTION_INFORMATION,
                                        0, 0, // no input
                                        &info, sizeof (info)))) {
        goto KbdHid_StartDeviceReject;
    }

    //
    // Allocate memory to hold the preparsed data.
    //
    preparsedData = (PHIDP_PREPARSED_DATA)
                    ExAllocatePool (NonPagedPool, info.DescriptorSize);

    if (!preparsedData) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_StartDeviceReject;
    }

    //
    // Retrieve that information.
    //

    if (!NT_SUCCESS (status = KbdHid_CallHidClass (
                                       Data,
                                       IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                       0, 0, // no input
                                       preparsedData, info.DescriptorSize))) {
        goto KbdHid_StartDeviceReject;
    }

    //
    // Call the parser to determine the capabilites of this HID device.
    //

    if (!NT_SUCCESS (status = HidP_GetCaps (preparsedData, &caps))) {
        goto KbdHid_StartDeviceReject;
    }

#if 0
    //
    // Is this the thing we want?
    //
    // In this particular case we are looking for a keyboard.
    //
    if ((HID_USAGE_PAGE_GENERIC == caps.UsagePage) &&
        (HID_USAGE_GENERIC_KEYBOARD == caps.Usage)) {
        ;
    } else {
        //
        // Someone made an INF blunder!
        //
        ASSERT ((HID_USAGE_PAGE_GENERIC == caps.UsagePage) &&
                (HID_USAGE_GENERIC_KEYBOARD == caps.Usage));

        status = STATUS_UNSUCCESSFUL;

        goto KbdHid_StartDeviceReject;
    }
#endif

    //
    // Set the number of buttons for this keyboard.
    // Note: we are actually reading here the total number of independant
    // chanels on the device.  But that should be satisfactory for a keyboard.
    //

    Data->Attributes.NumberOfKeysTotal = caps.NumberInputDataIndices;

    //
    // look for any device parameters.
    //
    status = IoOpenDeviceRegistryKey (Data->PDO,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &devInstRegKey);

    if (NT_SUCCESS (status)) {
        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_TYPE_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.KeyboardIdentifier.Type = (UCHAR) tmp;
            Data->IdEx.Type = tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_SUBTYPE_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.KeyboardIdentifier.Subtype = (UCHAR) tmp;
            Data->IdEx.Subtype = tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_NUMBER_TOTAL_KEYS_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.NumberOfKeysTotal = (USHORT) tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_NUMBER_FUNCTION_KEYS_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.NumberOfFunctionKeys = (USHORT) tmp;
        }

        status = KbdHid_QueryDeviceKey (devInstRegKey,
                                        KEYBOARD_NUMBER_INDICATORS_OVERRIDE,
                                        &tmp,
                                        sizeof (tmp));
        if (NT_SUCCESS (status)) {
            Data->Attributes.NumberOfIndicators = (USHORT) tmp;
        }

        ZwClose (devInstRegKey);

        if (!NT_SUCCESS (status)) {
            status = STATUS_SUCCESS;
        }
    }

    //
    // Note: here we might also want to check the button and value capabilities
    // of the device as well.
    //
    // Then let's use it.
    //

    //
    // a buffer length to allow an Input buffer, output buffer, feature buffer,
    // and the total number of usages that can be returned from a read packet.
    //

    maxUsages = HidP_MaxUsageListLength (
                           HidP_Input,
                           HID_USAGE_PAGE_KEYBOARD,
                           preparsedData);

    //
    // Create space in the device extension for the buffer storage when working
    // with this HID device.
    //
    // We need four buffers to hold the button codes (length returned from
    // HidP_MaxUsageListLength) this will hold the current list of usages,
    // the previous list of usages, the ``Make'' and the ``Break'' lists.
    // We also need a place to put the input, output, and feature report
    // buffers.
    //

    usageListLength = ALIGNPTRLEN(maxUsages * sizeof (USAGE_AND_PAGE));
    inputBufferLength = ALIGNPTRLEN(caps.InputReportByteLength);
    
    length = (6 * usageListLength)
           + inputBufferLength
           + sizeof (HID_EXTENSION);

    Data->HidExtension = hid = ExAllocatePool (NonPagedPool, length);

    if (!hid) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_StartDeviceReject;
    }

    RtlZeroMemory (hid, length);

    //
    // Initialize the fields.
    //
    hid->Ppd = preparsedData;
    hid->Caps = caps;
    hid->MaxUsages = maxUsages;
    // hid->ModifierState.ul = 0;

    hid->InputBuffer = buffer = hid->Buffer;
    hid->PreviousUsageList =  (PUSAGE_AND_PAGE) (buffer += inputBufferLength);
    hid->CurrentUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->BreakUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->MakeUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->OldMakeUsageList = (PUSAGE_AND_PAGE) (buffer += usageListLength);
    hid->ScrapBreakUsageList = (PUSAGE_AND_PAGE) (buffer + usageListLength);

    //
    // Create the MDLs
    // HidClass uses direct IO so you need MDLs
    //

    hid->InputMdl = IoAllocateMdl (hid->InputBuffer,   // The virtual address
                                   caps.InputReportByteLength, // length
                                   FALSE,  // No associated IRP => not secondary
                                   FALSE,  // No quota charge
                                   0);     // No associated IRP
    if (NULL == hid->InputMdl) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto KbdHid_StartDeviceReject;
    }
    MmBuildMdlForNonPagedPool (hid->InputMdl);  // Build this MDL.

    return status;

KbdHid_StartDeviceReject:
    if (preparsedData) {
        // no need to set hid->Ppd to NULL becuase we will be freeing it as well
        ExFreePool (preparsedData);
    }
    if (hid) {
        if (hid->InputMdl) {
            IoFreeMdl (hid->InputMdl);
        }
        ExFreePool (hid);
        Data->HidExtension = NULL;
    }

    return status;
}

NTSTATUS
KbdHid_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   data;
    PHID_EXTENSION      hid;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    ULONG               i, j;
    PDEVICE_EXTENSION * classDataList;
    LARGE_INTEGER       time;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    hid = data->HidExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT (FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    Print(DBG_PNP_TRACE, ("PNP: Minor code = %x.", stack->MinorFunction));
    
    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        if (data->Started) {
            Print(DBG_PNP_INFO, ("PNP: Device already started." ));
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            break;
        }

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&data->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                KbdHid_PnPComplete,
                                data,
                                TRUE,
                                TRUE,
                                TRUE); // No need for Cancel

        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = IoCallDriver (data->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &data->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            if (!data->Initialized) {
                status = KbdHid_StartDevice (data);
                if (NT_SUCCESS (status)) {
                    IoWMIRegistrationControl(DeviceObject,
                                             WMIREG_ACTION_REGISTER
                                             );
                    
                    data->Started = TRUE;
                    data->Initialized = TRUE;
                }
            } else {
                data->Started = TRUE;
            }
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        if (data->Started) {
            //
            // Do what ever
            //
        }

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //

        //
        // Stop Device touching the hardware MouStopDevice(data, TRUE);
        //
        data->Started = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!usbData->Removed);
        Print (DBG_PNP_TRACE, ("enter RemoveDevice \n"));

        IoWMIRegistrationControl(data->Self,
                                 WMIREG_ACTION_DEREGISTER
                                 );

        if (data->Started) {
            // Stop the device without touching the hardware.
            // MouStopDevice(data, FALSE);
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device could be GONE so we cannot send it any non-
        // PNP IRPS.
        //

        time = data->AutoRepeatDelay;

        KeCancelTimer (&data->AutoRepeatTimer);
#if KEYBOARD_HW_CHATTERY_FIX
        KeCancelTimer (&data->InitiateStartReadTimer);
        //
        // NB the time is a negative (relative) number;
        //
        if (data->InitiateStartReadDelay.QuadPart < time.QuadPart) {
            time = data->InitiateStartReadDelay;
        }
#endif

        KeDelayExecutionThread (KernelMode, FALSE, &time);

        //
        // Cancel our read IRP.  [DAN]
        // Note - waiting is only really necessary on 98, where pnp doesn't
        // make sure all handles are closed before sending the remove.
        //
        data->ShuttingDown = TRUE;
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
        IoCancelIrp (data->ReadIrp);

        //
        // Send on the remove IRP
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);

        //
        // Wait for the remove lock to free.
        //
        IoReleaseRemoveLockAndWait (&data->RemoveLock, Irp);

        //
        // Free the associated memory.
        //
        IoFreeIrp (data->ReadIrp);

        if (hid) {
            //
            // If we are removed without being started then we will have
            // no hid extension
            //
            ExFreePool (hid->Ppd);
            IoFreeMdl (hid->InputMdl);
            ExFreePool (hid);
        }

        FreeKeyboardUsageMappingList(data);

        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (data->Self);
        return status;

    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        //
        // These IRPs have to have their status changed from 
        // STATUS_NOT_SUPPORTED b4 passing them down.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
    
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}


NTSTATUS
KbdHid_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PDEVICE_EXTENSION   data;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    data = (PDEVICE_EXTENSION) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&data->StartEvent, 0, FALSE);

            //
            // Take the IRP back so that we can continue using it during
            // the IRP_MN_START_DEVICE dispatch routine.
            // NB: we will have to call IoCompleteRequest
            //
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
KbdHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    Print(DBG_POWER_TRACE, ("Power Enter." ));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Print(DBG_POWER_INFO, ("Power Setting %s state to %d\n",
                               ((powerType == SystemPowerState) ? "System"
                                                                : "Device"),
                               powerState.SystemState));
        break;

    case IRP_MN_QUERY_POWER:
        Print (DBG_POWER_INFO, ("Power query %s status to %d\n",
                                ((powerType == SystemPowerState) ? "System"
                                                                 : "Device"),
                                powerState.SystemState));
        break;

    default:
        Print (DBG_POWER_ERROR, ("Power minor (0x%x) no known\n",
                                 stack->MinorFunction));
    }

    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);
    status = PoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\kbdhid\wmi.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    WMI.C

Abstract:

    This module contains the init code for the i8042 to hid converter.

Environment:

    Kernel mode

Revision History:

    Jan-98 : created by Kenneth D. Ray

--*/


#include <initguid.h>
#include "kbdhid.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,KbdHid_SystemControl)
#pragma alloc_text(PAGE,KbdHid_SetWmiDataItem)
#pragma alloc_text(PAGE,KbdHid_SetWmiDataBlock)
#pragma alloc_text(PAGE,KbdHid_QueryWmiDataBlock)
#pragma alloc_text(PAGE,KbdHid_QueryWmiRegInfo)
#endif

#define WMI_PORT_DRIVER_INFORMATION 0
#define WMI_PORT_EXTENDED_ID        1

WMIGUIDREGINFO KbdHid_WmiGuidList[2] =
{
    {
        &MSKeyboard_PortInformation_GUID, 1, 0 // Keyboard Port driver information
    },
    {
        &MSKeyboard_ExtendedID_GUID, 1, 0      // Keyboard extended ID information
    },
};

NTSTATUS
KbdHid_SystemControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }        
    }
    
    return(status);
}

//
// WMI System Call back functions
//

NTSTATUS
KbdHid_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION    deviceExtension;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:
    case WMI_PORT_EXTENDED_ID:

        status = STATUS_WMI_READ_ONLY;
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KbdHid_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:
    case WMI_PORT_EXTENDED_ID:

        status = STATUS_WMI_READ_ONLY;
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
KbdHid_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION           deviceExtension;
    KEYBOARD_PORT_WMI_STD_DATA  data;
    NTSTATUS    status;
    ULONG       size = 0;

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:

        size = sizeof (data);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&data,
                      size
                      );
                     
        data.ConnectorType = KEYBOARD_PORT_WMI_STD_USB;
        data.DataQueueSize = deviceExtension->Attributes.InputDataQueueLength;
        data.ErrorCount = 0;
        data.FunctionKeys = deviceExtension->Attributes.NumberOfFunctionKeys;
        data.Indicators = deviceExtension->Attributes.NumberOfIndicators;

        * (PKEYBOARD_PORT_WMI_STD_DATA) Buffer = data;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;

        break;

    case WMI_PORT_EXTENDED_ID:
        size = sizeof(KEYBOARD_ID_EX);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        *(PKEYBOARD_ID_EX) Buffer = deviceExtension->IdEx;

        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KbdHid_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
        
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\kbdhid\kbdhid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    KBDHID.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements this sample client driver.

    Note: This is not a WDM driver as it will not run on Memphis (you need a
    vxd mapper to do keyboards for Memphis) and it uses event logs

Environment:

    Kernel mode

Revision History:

    Nov-96 : created by Kenneth D. Ray

--*/

#ifndef _KBDHID_H
#define _KBDHID_H

#include "ntddk.h"
#include "hidusage.h"
#include "hidpi.h"
#include "ntddkbd.h"
#include "kbdmou.h"
#include "kbdhidm.h"
#include "wmilib.h"

//
// Sometimes we allocate a bunch of structures together and need to split the
// allocation among these different structures. Use this macro to get the
// lengths of the different structures aligned properly
// 
#if defined(_WIN64)
// Round the 
#define ALIGNPTRLEN(x) ((x + 0x7) >> 3) << 3
#else // defined(_WIN64)
#define ALIGNPTRLEN(x) x
#endif // defined(_WIN64)

//
// allow a device parameter in the dev node to override the reported keyboard
// type, with a value of this name.
//
#define KEYBOARD_TYPE_OVERRIDE L"KeyboardTypeOverride"
#define KEYBOARD_SUBTYPE_OVERRIDE L"KeyboardSubtypeOverride"
#define KEYBOARD_NUMBER_TOTAL_KEYS_OVERRIDE L"KeyboardNumberTotalKeysOverride"
#define KEYBOARD_NUMBER_FUNCTION_KEYS_OVERRIDE L"KeyboardNumberFunctionKeysOverride"
#define KEYBOARD_NUMBER_INDICATORS_OVERRIDE L"KeyboardNumberIndicatorsOverride"

//
// Only allocate with a pool tag.  Remember that NT and 95 are little endian
// systmes.
//
#define KBDHID_POOL_TAG (ULONG) 'lCdH'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, KBDHID_POOL_TAG);

//
// Registry ProblemFlags masks. [DAN]
//
#define PROBLEM_CHATTERY_KEYBOARD 0x00000001

#define KEYBOARD_HW_CHATTERY_FIX 1 // [DAN]

#if KEYBOARD_HW_CHATTERY_FIX // [DAN]
  //
  // Delay between StartRead calls for chattery keyboards.
  //
  // Note that the StartRead delay for chattery keyboards must be no greater
  // than KEYBOARD_TYPEMATIC_DELAY_MINIMUM milliseconds (250), otherwise the
  // keys on the keyboard will auto-repeat unexpectedly.
  //
  // 50ms will satisfy 212 words/minute (one word = 5 keystrokes), the world's
  // fastest typing speed as recorded in the 23rd Guiness Book of World Record.
  //
  #define DEFAULT_START_READ_DELAY (50 * 10000) // 50 miliseconds.
#endif

//
// Declarations. [DAN]
//

#define HID_KEYBOARD_NUMBER_OF_FUNCTION_KEYS 12  // 12 "known" func-key usages
#define HID_KEYBOARD_NUMBER_OF_KEYS_TOTAL    101 // 101 "known" key usages
#define HID_KEYBOARD_IDENTIFIER_TYPE         81

//
// Flags to indicate whether read completed synchronously or asynchronously
//
#define KBDHID_START_READ     0x01
#define KBDHID_END_READ       0x02
#define KBDHID_IMMEDIATE_READ 0x03

//
// Statically allocate the (known) scancode-to-indicator-light mapping.
// This information is returned by the
// IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION device control request.
//

#define HID_KEYBOARD_NUMBER_OF_INDICATORS              3

//
// Default keyboard scan code mode (lifted from I8042PRT.H). [DAN]
//

#define HID_KEYBOARD_SCAN_CODE_SET 0x01

//
// Minimum, maximum, and default values for keyboard typematic rate and delay
// (lifted from I8042PRT.H).  [DAN]
//

#define HID_KEYBOARD_TYPEMATIC_RATE_MINIMUM     2
#define HID_KEYBOARD_TYPEMATIC_RATE_MAXIMUM    30
#define HID_KEYBOARD_TYPEMATIC_RATE_DEFAULT    30
#define HID_KEYBOARD_TYPEMATIC_DELAY_MINIMUM  250
#define HID_KEYBOARD_TYPEMATIC_DELAY_MAXIMUM 1000
#define HID_KEYBOARD_TYPEMATIC_DELAY_DEFAULT  250

static const INDICATOR_LIST IndicatorList[HID_KEYBOARD_NUMBER_OF_INDICATORS] = {
        {0x3A, KEYBOARD_CAPS_LOCK_ON},
        {0x45, KEYBOARD_NUM_LOCK_ON},
        {0x46, KEYBOARD_SCROLL_LOCK_ON}
};

//
// Debugging levels
//

#define DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define DBG_SS_NOISE               0x00000001
#define DBG_SS_TRACE               0x00000002
#define DBG_SS_INFO                0x00000004
#define DBG_SS_ERROR               0x00000008

#define DBG_CALL_MASK              0x000000F0
#define DBG_CALL_NOISE             0x00000010
#define DBG_CALL_TRACE             0x00000020
#define DBG_CALL_INFO              0x00000040
#define DBG_CALL_ERROR             0x00000080

#define DBG_IOCTL_MASK             0x00000F00
#define DBG_IOCTL_NOISE            0x00000100
#define DBG_IOCTL_TRACE            0x00000200
#define DBG_IOCTL_INFO             0x00000400
#define DBG_IOCTL_ERROR            0x00000800

#define DBG_READ_MASK              0x0000F000
#define DBG_READ_NOISE             0x00001000
#define DBG_READ_TRACE             0x00002000
#define DBG_READ_INFO              0x00004000
#define DBG_READ_ERROR             0x00008000

#define DBG_CREATE_CLOSE_MASK      0x000F0000
#define DBG_CC_NOISE               0x00010000
#define DBG_CC_TRACE               0x00020000
#define DBG_CC_INFO                0x00040000
#define DBG_CC_ERROR               0x00080000

#define DBG_POWER_MASK             0x00F00000
#define DBG_POWER_NOISE            0x00100000
#define DBG_POWER_TRACE            0x00200000
#define DBG_POWER_INFO             0x00400000
#define DBG_POWER_ERROR            0x00800000

#define DBG_PNP_MASK               0x0F000000
#define DBG_PNP_NOISE              0x01000000
#define DBG_PNP_TRACE              0x02000000
#define DBG_PNP_INFO               0x04000000
#define DBG_PNP_ERROR              0x08000000

#define DBG_CANCEL_MASK            0xF0000000
#define DBG_CANCEL_NOISE           0x10000000
#define DBG_CANCEL_TRACE           0x20000000
#define DBG_CANCEL_INFO            0x40000000
#define DBG_CANCEL_ERROR           0x80000000

#define DEFAULT_DEBUG_OUTPUT_LEVEL 0x88888888

#if DBG

#define Print(_l_, _x_) \
            if (Globals.DebugLevel & (_l_)) { \
               DbgPrint ("KbdHid: "); \
               DbgPrint _x_; \
            }
#define TRAP() DbgBreakPoint()

#else
#define Print(_l_,_x_)
#define TRAP()
#endif

#define MAX(_A_,_B_) (((_A_) < (_B_)) ? (_B_) : (_A_))
#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))


//
// Define the keyboard scan code input states.
//
typedef enum _KEYBOARD_SCAN_STATE {
    Normal,
    GotE0,
    GotE1
} KEYBOARD_SCAN_STATE;

//
// Structures;
//
typedef struct _GLOBALS {
#if DBG
    //
    // The level of trace output sent to the debugger. See HidCli_KdPrint above.
    //
    ULONG               DebugLevel;
#endif

    //
    // Pointer to this driver's null-terminated registry path.
    //
    UNICODE_STRING      RegistryPath;

    //
    // Unit ID given to the keyboard class driver
    //
    ULONG               UnitId;

} GLOBALS;

extern GLOBALS Globals;


/*
 *  The UsageMappingList is used to keep track of mappings
 *  from incorrect to correct usage values (for broken keyboards).
 */
typedef struct UsageMappingList {
    USHORT sourceUsage, mappedUsage;
    struct UsageMappingList *next;
} UsageMappingList;


typedef struct _DEVICE_EXTENSION
{
    //
    // A back pointer to the device extension.
    //
    PDEVICE_OBJECT      Self;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT      TopOfStack;

    //
    // "THE PDO"  (ejected by Hidclass)
    //
    PDEVICE_OBJECT      PDO;

    //
    // Flag indicating permission to send callbacks to the mouse class driver.
    //
    LONG                EnableCount;

    //
    // Read interlock value to protect us from running out of stack space
    //
    ULONG               ReadInterlock;

    //
    // Event used to synchronize the completion of the read irp and the close irp
    //
    KEVENT              ReadCompleteEvent;

    //
    // Event used to indicate that a read irp has been sent and is now cancelable.
    //
    KEVENT              ReadSentEvent;

    //
    // Has the device been taken out from under us?
    // Has it been started?
    //
    BOOLEAN             Started;
    BOOLEAN             ShuttingDown;
    BOOLEAN             Initialized;
    USHORT              UnitId;
    
    // Make this look like mouhid.h
    ULONG               Reserved;


    //
    // Write and Feature Irps get passed straight down, but read Irps do not.
    // For this reason we keep around a read Irp, which we created.
    //
    PIRP                ReadIrp;

    //
    // A pointer to the HID extension.
    //
    struct _HID_EXTENSION * HidExtension;

    //
    // Flags indicating problems with the keyboard HID device (such as
    // a chattery keyboard). [DAN]
    //
    ULONG                ProblemFlags;

    //
    // A file pointer to be used for reading
    //
    PFILE_OBJECT        ReadFile;

    //
    // Pointer to the mouse class device object and callback routine
    // above us, Used as the first parameter and the  MouseClassCallback().
    // routine itself.
    //
    CONNECT_DATA        ConnectData;

    //
    // Remove Lock object to project IRP_MN_REMOVE_DEVICE
    //
    IO_REMOVE_LOCK      RemoveLock;

    //
    // A fast mutex to prevent Create from trouncing close, as one starts the
    // read loop and the other shuts it down.
    //
    FAST_MUTEX          CreateCloseMutex;

    //
    // An event to halt the deletion of a device until it is ready to go.
    //
    KEVENT              StartEvent;

    //
    // A place to store a single data packet so that we might hand it to the
    // keyclass driver.
    //
    KEYBOARD_INPUT_DATA InputData;
    KEYBOARD_SCAN_STATE ScanState;

    //
    // The attributes of this keyboard port [DAN]
    //
    KEYBOARD_ATTRIBUTES Attributes;

    //
    // The extended ID attributes of this keyboard port
    //
    KEYBOARD_ID_EX IdEx;

    //
    // The current state of the indicator lights [DAN]
    //
    KEYBOARD_INDICATOR_PARAMETERS   Indicators;

    //
    // The typematic parameters [DAN]
    //
    KEYBOARD_TYPEMATIC_PARAMETERS   Typematic;

    //
    // A timer DPC to do the autorepeat.
    //
    KDPC                AutoRepeatDPC;
    KTIMER              AutoRepeatTimer;
    LARGE_INTEGER       AutoRepeatDelay;
    LONG                AutoRepeatRate;

#if KEYBOARD_HW_CHATTERY_FIX
    // Added new DPC routine to schedule intermittent StartReads.
    KDPC                InitiateStartReadDPC;
    KTIMER              InitiateStartReadTimer;
    LARGE_INTEGER       InitiateStartReadDelay;
    BOOLEAN             InitiateStartReadUserNotified;
#endif

    //
    // An attachment point for the global list o devices
    //
    LIST_ENTRY          Link;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    UsageMappingList *usageMapping;
    KSPIN_LOCK usageMappingSpinLock;

} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

typedef struct _HID_EXTENSION {
    //
    // The preparsed data associated with this hid device.
    //
    PHIDP_PREPARSED_DATA Ppd;

    //
    // The capabilities of this hid device
    //
    HIDP_CAPS           Caps;

    //
    // The maximum number of usages that can be returned from a single read
    // report.
    ULONG               MaxUsages;

    //
    // A place to keep the modifier keys.  Used by the parser to translate from
    // usages to i8042 codes.
    //
    HIDP_KEYBOARD_MODIFIER_STATE ModifierState;

    //
    // We need a place to put the current packet, being retreived or sent for
    // input, output, or feature.
    // In addition to a place to put the usages (keys pressed) returned from the
    // keyboard, and a place to put the new strokes from the keyboard.
    //
    // Global buffers mean, of course, we cannot have overlapping read
    // requests.
    //
    // Pointers into the buffer contained below.
    PCHAR                InputBuffer;
    PUSAGE_AND_PAGE      PreviousUsageList;
    PUSAGE_AND_PAGE      CurrentUsageList;
    PUSAGE_AND_PAGE      BreakUsageList;
    PUSAGE_AND_PAGE      MakeUsageList;
    PUSAGE_AND_PAGE      OldMakeUsageList;
    PUSAGE_AND_PAGE      ScrapBreakUsageList;

    //
    // An MDL describing the below contained buffer.
    //
    PMDL                 InputMdl;

    //
    // A buffer to hold an Input packet, Output packet, the Maximum Usages
    // posible from a single hid packet, and
    //
    CHAR                 Buffer[];
} HID_EXTENSION, * PHID_EXTENSION;

//
// Prototypes
//
VOID
KbdHid_AutoRepeat (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    );

#if KEYBOARD_HW_CHATTERY_FIX
VOID
KbdHid_InitiateStartRead (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    );
#endif

NTSTATUS
KbdHid_StartRead (
    PDEVICE_EXTENSION   Data
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
KbdHid_AddDevice (
    IN PDRIVER_OBJECT    KbdHidDriver, // The kbd Driver object.
    IN PDEVICE_OBJECT    PDO
    );


NTSTATUS
KbdHid_Close (
   IN PDEVICE_OBJECT    DeviceObject,
   IN PIRP              Irp
   );

NTSTATUS
KbdHid_Create (
   IN PDEVICE_OBJECT    DeviceObject,
   IN PIRP              Irp
   );

NTSTATUS
KbdHid_SetLedIndicators (
    PDEVICE_EXTENSION               Data,
    PKEYBOARD_INDICATOR_PARAMETERS  Parameters,
    PIRP                            Irp
    );

NTSTATUS
KbdHid_CallHidClass(
    IN PDEVICE_EXTENSION    Data,
    IN ULONG          Ioctl,
    PVOID             InputBuffer,
    ULONG             InputBufferLength,
    PVOID             OutputBuffer,
    ULONG             OutputBufferLength
    );

BOOLEAN
KbdHid_InsertCodesIntoQueue (
   PDEVICE_EXTENSION    Data,
   PCHAR                NewCodes,
   ULONG                Length
   );

VOID
KbdHid_UpdateRegistryProblemFlags(
    IN PDEVICE_EXTENSION    Data
    );

VOID
KbdHid_UpdateRegistryProblemFlagsCallback (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM Item
    );

VOID
KbdHid_LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN NTSTATUS       ErrorCode,
   IN PWSTR          ErrorInsertionString OPTIONAL
   );

NTSTATUS
KbdHid_StartDevice (
    IN PDEVICE_EXTENSION    Data
    );

NTSTATUS
KbdHid_PnP (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
KbdHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
KbdHid_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
KbdHid_GetRegistryParameters ();

VOID
KbdHid_Unload(
   IN PDRIVER_OBJECT Driver
   );

NTSTATUS
KbdHid_IOCTL (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
KbdHid_Flush (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdHid_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdHid_PassThrough (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);

NTSTATUS
KbdHid_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
KbdHid_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
KbdHid_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
KbdHid_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
KbdHid_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

VOID LoadKeyboardUsageMappingList(PDEVICE_EXTENSION devExt);
VOID FreeKeyboardUsageMappingList(PDEVICE_EXTENSION devExt);
USHORT MapUsage(PDEVICE_EXTENSION devExt, USHORT kbdUsage);
NTSTATUS OpenSubkey(OUT PHANDLE Handle, IN HANDLE BaseHandle, IN PUNICODE_STRING KeyName, IN ACCESS_MASK DesiredAccess);
ULONG LAtoX(PWCHAR wHexString);

extern WMIGUIDREGINFO KbdHid_WmiGuidList[2];

#endif // _KBDHID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\kbdhid\mapusage.c ===
/*++

Copyright (c) 1998    Microsoft Corporation

Module Name:

    MAPUSAGE.C

Abstract:

    Code for using registry usage mapping information
    (for broken HID keyboards that return incorrect usages)
    to fix usages on the fly.

    INF example:
    ------------
    The following line in the device instance's AddReg section
    of an inf for a keyboard 
    will create a key resulting in the usage value
    0x0203 being mapped to 0x0115 :

    HKR,UsageMappings,0203,,0115

Environment:

    Kernel mode

Revision History:

    Nov-98 : created by Ervin Peretz

--*/

#include "kbdhid.h"
#include <hidclass.h>



VOID LoadKeyboardUsageMappingList(PDEVICE_EXTENSION devExt)
{
    NTSTATUS status;
    HANDLE hRegDriver;
    UsageMappingList *mapList = NULL;
    KIRQL oldIrql;


    /*
     *  Open the driver registry key
     *  ( HKLM/System/CurrentControlSet/Control/Class/<GUID>/<#n> )
     */
    status = IoOpenDeviceRegistryKey(   devExt->PDO, 
                                        PLUGPLAY_REGKEY_DRIVER, 
                                        KEY_READ, 
                                        &hRegDriver);
    if (NT_SUCCESS(status)){
        UNICODE_STRING usageMappingsKeyName;
        HANDLE hRegUsageMappings;

        /*
         *  See if the Usage Mappings subkey exists.
         */
        RtlInitUnicodeString(&usageMappingsKeyName, L"UsageMappings"); 
        status = OpenSubkey(    &hRegUsageMappings,
                                hRegDriver,
                                &usageMappingsKeyName,
                                KEY_READ);

        if (NT_SUCCESS(status)){

            /*
             *  The registry DOES contain usage mappings
             *  for this keyboard.
             */
            UsageMappingList *mapListEntry, *lastMapListEntry = NULL;
            ULONG keyIndex = 0;

            /*
             *  The key value information struct is variable-length.
             *  The actual length is equal to:
             *      the length of the base PKEY_VALUE_FULL_INFORMATION struct +
             *      the length of the name of the key (4 wide chars) + 
             *      the length of the value (4 wchars + terminator = 5 wchars).
             */
            UCHAR keyValueBytes[sizeof(KEY_VALUE_FULL_INFORMATION)+4*sizeof(WCHAR)+5*sizeof(WCHAR)];
            PKEY_VALUE_FULL_INFORMATION keyValueInfo = (PKEY_VALUE_FULL_INFORMATION)keyValueBytes;
            ULONG actualLen;

            do {
                status = ZwEnumerateValueKey(
                            hRegUsageMappings,
                            keyIndex,
                            KeyValueFullInformation,
                            keyValueInfo,
                            sizeof(keyValueBytes),
                            &actualLen); 
                if (NT_SUCCESS(status)){
                    
                    /*
                     *  Add this usage mapping to the mapping list.
                     */
                    USHORT sourceUsage, mappedUsage;
                    PWCHAR valuePtr;
                    WCHAR nameBuf[5];
                    WCHAR valueBuf[5];

                    ASSERT(keyValueInfo->Type == REG_SZ);
                    ASSERT(keyValueInfo->DataLength == (4+1)*sizeof(WCHAR));
                    ASSERT(keyValueInfo->NameLength <= (4+1)*sizeof(WCHAR));

                    /*
                     *  keyValueInfo->Name is not NULL-terminated.
                     *  So copy it into a buffer and null-terminate.
                     */
                    memcpy(nameBuf, keyValueInfo->Name, 4*sizeof(WCHAR));
                    nameBuf[4] = L'\0';
                    
                    valuePtr = (PWCHAR)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset);
                    memcpy(valueBuf, valuePtr, 4*sizeof(WCHAR));
                    valueBuf[4] = L'\0';

                    sourceUsage = (USHORT)LAtoX(nameBuf);
                    mappedUsage = (USHORT)LAtoX(valueBuf);

                    /*
                     *  Create and queue a new map list entry.
                     */
                    mapListEntry = ExAllocatePool(NonPagedPool, sizeof(UsageMappingList));
                    if (mapListEntry){
                        mapListEntry->sourceUsage = sourceUsage;
                        mapListEntry->mappedUsage = mappedUsage;
                        mapListEntry->next = NULL;
                        if (lastMapListEntry){
                            lastMapListEntry->next = mapListEntry;
                            lastMapListEntry = mapListEntry;
                        }
                        else {
                            mapList = lastMapListEntry = mapListEntry;
                        }
                    }
                    else {
                        ASSERT(!(PVOID)"mem alloc failed");
                        break;
                    }

                    keyIndex++;
                }
            } while (NT_SUCCESS(status));


            ZwClose(hRegUsageMappings);
        }

        ZwClose(hRegDriver);
    }

    KeAcquireSpinLock(&devExt->usageMappingSpinLock, &oldIrql);
    devExt->usageMapping = mapList;
    KeReleaseSpinLock(&devExt->usageMappingSpinLock, oldIrql);

}


VOID FreeKeyboardUsageMappingList(PDEVICE_EXTENSION devExt)
{
    UsageMappingList *mapList;
    KIRQL oldIrql;

    KeAcquireSpinLock(&devExt->usageMappingSpinLock, &oldIrql);

    mapList = devExt->usageMapping;
    devExt->usageMapping = NULL;

    KeReleaseSpinLock(&devExt->usageMappingSpinLock, oldIrql);

    while (mapList){
        UsageMappingList *thisEntry = mapList;
        mapList = thisEntry->next;
        ExFreePool(thisEntry);
    }

}


USHORT MapUsage(PDEVICE_EXTENSION devExt, USHORT kbdUsage)
{
    UsageMappingList *mapList;
    KIRQL oldIrql;


    KeAcquireSpinLock(&devExt->usageMappingSpinLock, &oldIrql);

    mapList = devExt->usageMapping;
    while (mapList){
        if (mapList->sourceUsage == kbdUsage){
            kbdUsage = mapList->mappedUsage;
            break;
        }
        else {
            mapList = mapList->next;
        }
    }

    KeReleaseSpinLock(&devExt->usageMappingSpinLock, oldIrql);

    return kbdUsage;
}


NTSTATUS OpenSubkey(    OUT PHANDLE Handle,
                        IN HANDLE BaseHandle,
                        IN PUNICODE_STRING KeyName,
                        IN ACCESS_MASK DesiredAccess
                   )
{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenKey(Handle, DesiredAccess, &objectAttributes);

    return status;
}





ULONG LAtoX(PWCHAR wHexString)
/*++

Routine Description:

      Convert a hex string (without the '0x' prefix) to a ULONG.

Arguments:

    wHexString - null-terminated wide-char hex string 
                 (with no "0x" prefix)

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    for (i = 0; wHexString[i]; i++){
        if ((wHexString[i] >= L'0') && (wHexString[i] <= L'9')){
            result *= 0x10;
            result += (wHexString[i] - L'0');
        }
        else if ((wHexString[i] >= L'a') && (wHexString[i] <= L'f')){
            result *= 0x10;
            result += (wHexString[i] - L'a' + 0x0a);
        }
        else if ((wHexString[i] >= L'A') && (wHexString[i] <= L'F')){
            result *= 0x10;
            result += (wHexString[i] - L'A' + 0x0a);
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\kbdhid\read.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code for translating HID reports to keyboard
    reports.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <stdio.h>
#include "kbdhid.h"

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

#define KbdHid_RestartTimer(HidDevice)           \
    KeSetTimerEx (&(HidDevice)->AutoRepeatTimer, \
                   (HidDevice)->AutoRepeatDelay, \
                   (HidDevice)->AutoRepeatRate,  \
                  &(HidDevice)->AutoRepeatDPC);

#define KbdHid_CancelTimer(HidDevice) \
    KeCancelTimer (&(HidDevice)->AutoRepeatTimer);


#define KEYBOARD_INITIATED_KERNEL_EVENT FALSE
#if KEYBOARD_INITIATED_KERNEL_EVENT

typedef enum _HARDWARE_PROFILE_BUS_TYPE {
    HardwareProfileBusTypeACPI
} HARDWARE_PROFILE_BUS_TYPE, * PHARDWARE_PROFILE_BUS_TYPE;

// typedef struct _KBDHID_KERNEL_EVENT_WORK_ITEM {
//     PVOID   Data;
//     WORK_QUEUE_ITEM Item;
// } KBDHID_KERNEL_EVENT_WORK_ITEM, * PKBDHID_KERNEL_EVENT_WORK_ITEM;

NTSTATUS
IopExecuteHardwareProfileChange(
    IN  HARDWARE_PROFILE_BUS_TYPE   Bus,
    IN  PWCHAR                    * ProfileSerialNumbers,
    IN  ULONG                       SerialNumbersCount,
    OUT PHANDLE                     NewProfile,
    OUT PBOOLEAN                    ProfileChanged
    );

KSPIN_LOCK  KbdHid_KernelEventSpin;
ULONG KbdHid_KernelEventState = -1;

VOID
KbdHid_KernelEvent (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM Item
    )
{
    KIRQL   oldIrql;
    WCHAR   docked[] = L"1234\0";
    WCHAR   undocked[] = L"\0";
    PWCHAR  strings [2] = {docked, undocked};
    HANDLE  handle;
    BOOLEAN changed;

    UNREFERENCED_PARAMETER (DeviceObject);

    if (-1 == KbdHid_KernelEventState) {
        KeInitializeSpinLock (&KbdHid_KernelEventSpin);
        KbdHid_KernelEventState = 0;
    }

Beginning:
    switch (KbdHid_KernelEventState++) {
    case 0:
        IopExecuteHardwareProfileChange (HardwareProfileBusTypeACPI,
                                         strings,
                                         1,
                                         &handle,
                                         &changed);
        break;

    case 1:
        IopExecuteHardwareProfileChange (HardwareProfileBusTypeACPI,
                                         strings + 1,
                                         1,
                                         &handle,
                                         &changed);
        break;

    default:
        KbdHid_KernelEventState = 0;
        goto Beginning;
    }

    IoFreeWorkItem (Item);
}

#endif

NTSTATUS
KbdHid_ReadComplete (
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp,
    IN PDEVICE_EXTENSION    Data  // (PVOID Context)
    )
/*++
Routine Description:
   The read Completetion routine.

   The read came in.
   (a) Find the Buttons (usages) that are currently down
   (b) Diff to find the buttons that went up, and those that went down.
   (c) Convert the ups and downs to i8042 scan codes.
   (d) Swap the Previous Usage List and the Current Usage List.
   (d) If there are keys still down then we need to:
      (1) send another read to HidClass to wait for those keys to come back up
      (2) reset the autotimer.
--*/
{                                     
    ULONG           newUsages;
    NTSTATUS        status;
    PUSAGE_AND_PAGE usageList;
    PHID_EXTENSION  hid;
    KIRQL           oldirq;
    ULONG           i;
    PUSAGE_AND_PAGE usage;
    BOOLEAN         rollover;
    BOOLEAN         startRead;

    rollover = FALSE;
    status = Irp->IoStatus.Status;
    hid = Data->HidExtension;

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (KBDHID_START_READ !=
        InterlockedCompareExchange(&Data->ReadInterlock,
                                   KBDHID_IMMEDIATE_READ,
                                   KBDHID_START_READ));

    if (Data->EnableCount == 0) {
        goto SetEventAndBreak;
    }

    switch (status) {
    case STATUS_SUCCESS:
        //
        // Hopefully this means that the data found in the buffer of the
        // context contains a single hid packet read from the device.
        //
        ASSERT (Irp->IoStatus.Information == hid->Caps.InputReportByteLength);

        //
        // Find the current usages
        //

        newUsages = hid->MaxUsages;

        status = HidP_GetUsagesEx (
                     HidP_Input,
                     0, // Not interested in link collections
                     hid->CurrentUsageList,
                     &newUsages,
                     hid->Ppd,
                     hid->InputBuffer,
                     hid->Caps.InputReportByteLength);

        //
        // If the SysRq button is the only button down then
        // break.  This is to behave like the i8042prt driver, we clearly
        // have far less of an advantage since we have gone through MANY
        // drivers before we received the data, but let's check it anyway.
        //
        if ((1 == newUsages) &&
            (HID_USAGE_PAGE_KEYBOARD == hid->CurrentUsageList->UsagePage) &&
            (HID_USAGE_KEYBOARD_PRINT_SCREEN == hid->CurrentUsageList->Usage) &&
            (**((PUCHAR *)&KdDebuggerEnabled))) {
                DbgBreakPointWithStatus(DBG_STATUS_SYSRQ);
        }

#if KEYBOARD_INITIATED_KERNEL_EVENT
        if ((1 == newUsages) &&
            hid->ModifierState.ScollLock &
            (HID_USAGE_PAGE_KEYBOARD == hid->CurrentUsageList->UsagePage) &&
            (HID_USAGE_KEYBOARD_F12 == hid->CurrentUsageList->Usage)) {

            PIO_WORKITEM item;
            item = IoAllocateWorkItem (Data->Self);
            if (NULL != item) {
                // item->Data = NULL;
                // ExInitializeWorkItem (&item->Item, KbdHid_KernelEvent, item);
                // ExQueueWorkItem (&item->Item, DelayedWorkQueue);
                IoQueueWorkItem (item,
                                 KbdHid_KernelEvent,
                                 DelayedWorkQueue,
                                 item);
            }
        }
#endif

        for (i = 0, usage = hid->CurrentUsageList;
             i < hid->MaxUsages;
             i++, usage++) {

            if (HID_USAGE_PAGE_KEYBOARD != hid->CurrentUsageList->UsagePage) {
                continue;
            }

            //
            // If this is a broken keyboard, map the usage
            // to the correct value.
            //
            usage->Usage = MapUsage(Data, usage->Usage);

            //
            // If this packet contains the Rollover key then the packet should be
            // ignored.
            //
            if (HID_USAGE_KEYBOARD_ROLLOVER == usage->Usage) {
                rollover = TRUE;
                break;
            }
            if (0 == usage->Usage) {
                break;
            }
        }

        if (!rollover) {
            USAGE_AND_PAGE  zero = {0,0};
            
            //
            // First, check whether the keyboard is repeating keys in hardware.
            // If it is, then we'll ignore this package. To do this, diff the 
            // current and the previous usages. If the resulting make and break
            // usage lists have nothing in them, then ignore this package.
            //
            HidP_UsageAndPageListDifference (hid->PreviousUsageList,
                                             hid->CurrentUsageList,
                                             hid->ScrapBreakUsageList,
                                             hid->OldMakeUsageList,
                                             hid->MaxUsages);

            if (HidP_IsSameUsageAndPage(hid->OldMakeUsageList[0], zero) &&
                HidP_IsSameUsageAndPage(hid->ScrapBreakUsageList[0], zero)) {
                //
                // No new keys. The keyboard is trying 
                // to perform repeating in hardware.
                //
                goto Kbdhid_ReadComplete_Done;
            }

            //
            // Save the make usages temporarily
            //
            RtlCopyMemory(hid->OldMakeUsageList,
                          hid->MakeUsageList,
                          hid->MaxUsages * sizeof(USAGE_AND_PAGE));

            //
            // Diff the current and the previous usages
            //
            status = HidP_UsageAndPageListDifference (hid->PreviousUsageList,
                                                      hid->CurrentUsageList,
                                                      hid->BreakUsageList,
                                                      hid->MakeUsageList,
                                                      hid->MaxUsages);

            //
            // Convert the ups into scan codes and add to the ring buffer.
            // Convert the downs.
            //
            HidP_TranslateUsageAndPagesToI8042ScanCodes (hid->BreakUsageList,
                                                         hid->MaxUsages,
                                                         HidP_Keyboard_Break,
                                                         &hid->ModifierState,
                                                         KbdHid_InsertCodesIntoQueue,
                                                         Data);

            if (!HidP_IsSameUsageAndPage(hid->CurrentUsageList[0], zero) &&
                HidP_IsSameUsageAndPage(hid->MakeUsageList[0], zero)) {
                //
                // There are no new downs, but there may be some old ones
                // kicking around. We don't want to get rid of keys that are
                // still repeating.
                //
                HidP_UsageAndPageListDifference (hid->BreakUsageList,
                                                 hid->OldMakeUsageList,
                                                 hid->ScrapBreakUsageList,
                                                 hid->MakeUsageList,
                                                 hid->MaxUsages);
            } else {
                //
                // Only refresh the downs when there are new ones to add
                //
                HidP_TranslateUsageAndPagesToI8042ScanCodes (hid->MakeUsageList,
                                                             hid->MaxUsages,
                                                             HidP_Keyboard_Make,
                                                             &hid->ModifierState,
                                                             KbdHid_InsertCodesIntoQueue,
                                                             Data);
            }

            //
            // Swap previous with next.
            //
            usageList = hid->PreviousUsageList;
            hid->PreviousUsageList = hid->CurrentUsageList;
            hid->CurrentUsageList = usageList;

#if KEYBOARD_HW_CHATTERY_FIX
            //
            // [DAN]
            // Chattery Keyboard H/W Workaround -
            //    Only call StartRead() if this was a meaningful packet  (ie. it
            //    had a make or a break), otherwise "schedule" the StartRead for
            //    a later time.  Notify tester that this is a chattery keyboard.
            //
            if ((0 < newUsages) &&
                (0 == hid->BreakUsageList->Usage) &&
                (0 == hid->MakeUsageList->Usage)) {

                if (FALSE == Data->InitiateStartReadUserNotified) {
                    Data->InitiateStartReadUserNotified = TRUE;
                    DbgPrint("*****\n***** "
                             "CHATTERY   KEYBOARD : "
                             "Keyboard is sending useless reports.  "
                             "Tell 'em to fix it.\n*****\n"
                             );

                    Data->ProblemFlags |= PROBLEM_CHATTERY_KEYBOARD;

                    //
                    // Update ProblemFlags value in registry and log the problem.
                    //
                    KbdHid_UpdateRegistryProblemFlags (Data);

                    KbdHid_LogError(Data->Self->DriverObject,
                                    KBDHID_CHATTERY_KEYBOARD,
                                    NULL);
                }

                if (!Data->ShuttingDown &&
                    startRead) {
                    KeSetTimerEx(&Data->InitiateStartReadTimer,
                                 Data->InitiateStartReadDelay,
                                 0,
                                 &Data->InitiateStartReadDPC);
                }
                startRead = FALSE;
                IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);

                KbdHid_CancelTimer (Data);

                break;
            } else
#endif

            if (0 < newUsages) {
                //
                // Reset the auto repeat timer.
                //
                KbdHid_RestartTimer (Data);
            } else {
                KbdHid_CancelTimer (Data);
            }
        }

        //
        // Get the next packet from Hid Class.
        // Hid class has its own buffer so we do not need ping pong irps.
        //
        break;

    case STATUS_PRIVILEGE_NOT_HELD:
        //
        // The create didn't succeed
        //
    case STATUS_CANCELLED:
        //
        // The read IRP was cancelled.  Do not send any more read IRPs.
        //
    case STATUS_DELETE_PENDING:
    case STATUS_DEVICE_NOT_CONNECTED:
        //
        // The HID class device object is being deleted.  We will soon
        // receive Plug 'n Play notification of this device's removal,
        // if we have not received it already.
        //
SetEventAndBreak:
        if (startRead) {
            KeSetEvent (&Data->ReadCompleteEvent, 0, FALSE);
            IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
            startRead = FALSE;
        }
        break;

    default:
        //
        // We don't expect any other error codes.
        //
        TRAP();

   }

Kbdhid_ReadComplete_Done:
    //
    // Initiate the next read request to the HID class driver.
    //
    if (startRead) {
        Print(DBG_READ_TRACE, ("calling StartRead directly\n"));
        KbdHid_StartRead (Data);
    } else {
        Print(DBG_READ_TRACE, ("StartRead will loop\n"));
    }
   
    return STATUS_MORE_PROCESSING_REQUIRED;
#undef hidDevice
}

BOOLEAN
KbdHid_InsertCodesIntoQueue (
   PDEVICE_EXTENSION    Data,
   PCHAR                NewCodes,
   ULONG                Length
   )
/*++

[DAN]

RoutineDescription:
    Given a pointer to some i8042 Codes and the length of those codes.
    send those codes to KbdClass via KbdClassCallback.

    This routine is transmits the supplied I8042 scancodes to the keyboard
    class driver via a callback routine. This function was supplied in our
    call to HidP_TranslateUsagesToI8042ScanCodes.

Arguments:

    HidDevice - Pointer to the device context.

    NewCodes  - Pointer to the I8042 scancodes.

    Length    - Number of I8042 scancodes.

Return Value:

    Always returns TRUE.

--*/
{
    KIRQL                 oldIrql;
    ULONG                 index;
    PKEYBOARD_INPUT_DATA  input;
    PHID_EXTENSION        hid;
    ULONG                 inputDataConsumed;
    UCHAR                 scanCode;
    KEYBOARD_SCAN_STATE * scanState;

    hid         = Data->HidExtension;
    input       = &Data->InputData;
    scanState   = &Data->ScanState;

    for (index = 0; index < Length; index++, NewCodes++) {
        scanCode = *NewCodes;

        if (scanCode == (UCHAR) 0xFF) {
            Print (DBG_READ_TRACE, ("OVERRUN\n"));
            input->MakeCode = KEYBOARD_OVERRUN_MAKE_CODE;
            input->Flags = 0;
            *scanState = Normal;
        } else {

            switch (*scanState) {
            case Normal:

                if (scanCode == (UCHAR) 0xE0) {
                    input->Flags |= KEY_E0;
                    *scanState = GotE0;
                    break;
                } else if (scanCode == (UCHAR) 0xE1) {
                    input->Flags |= KEY_E1;
                    *scanState = GotE1;
                    break;
                }

                //
                // Fall through to the GotE0/GotE1 case for the rest of the
                // Normal case.
                //

            case GotE0:
            case GotE1:

                if (scanCode > 0x7F) {
                    //
                    // Got a break code.  Strip the high bit off
                    // to get the associated make code and set flags
                    // to indicate a break code.
                    //
                    input->MakeCode = scanCode & 0x7F;
                    input->Flags |= KEY_BREAK;
                } else {
                    //
                    // Got a make code.
                    //
                    input->MakeCode = scanCode;
                }

                //
                // Reset the state to Normal.
                //
                *scanState = Normal;
                break;

            default:

                ASSERT(FALSE);
                break;
            }

            //
            // In the Normal state, if the keyboard device is enabled,
            // add the data to the InputData queue and queue the ISR DPC.
            //
            if (*scanState == Normal) {

                if (Data->EnableCount) {

                    //
                    // Leave the remaining mouse input data fields as they were
                    // initialized (on the device's creation).  This includes:
                    //  o  UnitID
                    //  o  ExtraInformation
                    //
                    // Now send the data up to the keyboard class driver via
                    // our callback.
                    //
                    //
                    // Synchronization issue: it's not a big deal if .Enabled
                    // is set FALSE after the condition above, but before the
                    // callback below, so long as the .KbdClassCallback field
                    // is not nulled. This is guaranteed since the disconnect
                    // IOCTL is not implemented yet.
                    //
                    // Keyboard class callback assumes we are running at
                    // DISPATCH level, however this IoCompletion routine
                    // can be running <= DISPATCH. Raise the IRQL before
                    // calling the callback. [13.1]
                    //
                    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

                    //
                    // Call the callback.
                    //
                    (*(PSERVICE_CALLBACK_ROUTINE)
                     Data->ConnectData.ClassService) (
                            Data->ConnectData.ClassDeviceObject,
                            input,
                            input + 1,  // (one data element)
                            &inputDataConsumed);

                    //
                    // Restore the previous IRQL right away.
                    //
                    KeLowerIrql(oldIrql);

                    ASSERT (1 == inputDataConsumed);
                }

                //
                // Reset the input state.
                //
                input->Flags = 0;
            }
        }
    }

    return TRUE;
}

NTSTATUS
KbdHid_StartRead (
    PDEVICE_EXTENSION   Data
    )
/*++

Routine Description:

    Initiates a read to the HID class driver.

    Note that the routine does not verify that the device context is in the
    OperationPending state, but simply assumes it.

    Note the IoCount must be incremented before entering into this read loop.

Arguments:

    HidDeviceContext - Device context structure describing the HID device.

Return Value:

    NTSTATUS result code from IoCallDriver().

--*/
{
    PIRP                irp = Data->ReadIrp;
    NTSTATUS            status = irp->IoStatus.Status;
    PIO_STACK_LOCATION  stack;
    PHID_EXTENSION      hid;
    LONG                oldInterlock;

    Print (DBG_READ_TRACE, ("Start Read: Ente\n"));

    hid = Data->HidExtension;

    //
    // start this read.
    //

    while (1) {
        oldInterlock = InterlockedExchange(&Data->ReadInterlock,
                                           KBDHID_START_READ);
    
        //
        // END_READ should be the only value here!!!  If not, the state machine
        // of the interlock has been broken
        //
        ASSERT(oldInterlock == KBDHID_END_READ);
    
        if (NT_SUCCESS(status)) {
            //
            // Set the stack location for the Hid stack.
            // Remember to get the file pointer correct.
            // NOTE: we do not have any of the cool thread stuff set.
            //       therefore we need to make sure that we cut this IRP off
            //       at the knees when it returns. (STATUS_MORE_PROCESSING_REQUIRED)
            //
            // Note also that Hid class does direct IO.
            //
            IoReuseIrp (irp, STATUS_SUCCESS);
        
            irp->MdlAddress = hid->InputMdl;
        
            ASSERT (NULL != Data->ReadFile);
        
            stack = IoGetNextIrpStackLocation (irp);
            stack->Parameters.Read.Length = hid->Caps.InputReportByteLength;
            stack->Parameters.Read.Key = 0;
            stack->Parameters.Read.ByteOffset.QuadPart = 0;
            stack->MajorFunction = IRP_MJ_READ;
            stack->FileObject = Data->ReadFile;
        
            //
            // Hook a completion routine for when the device completes.
            //
        
            IoSetCompletionRoutine (irp,
                                    KbdHid_ReadComplete,
                                    Data,
                                    TRUE,
                                    TRUE,
                                    TRUE);
        
            //
            // Unset the fact that the read has been sent. Synchoronizing 
            // with remove and close code. Remove portion (data->Shuttingdown) 
            // only really relevant on 9X.
            //
            KeResetEvent(&Data->ReadSentEvent);
        
            if (!Data->EnableCount || Data->ShuttingDown) {
                IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
                status = Data->ShuttingDown ? STATUS_DELETE_PENDING : STATUS_UNSUCCESSFUL;
                KeSetEvent (&Data->ReadSentEvent, 0, FALSE);
                break;
            } else {
                status = IoCallDriver (Data->TopOfStack, irp);
            }
            KeSetEvent (&Data->ReadSentEvent, 0, FALSE);
            
            if (KBDHID_IMMEDIATE_READ != InterlockedExchange(&Data->ReadInterlock,
                                                             KBDHID_END_READ)) {
                //
                // The read is asynch, will call SerialMouseStartRead from the
                // completion routine
                //
                Print(DBG_READ_TRACE, ("read is pending\n"));
                break;
            } else {
                //
                // The read was synchronous (probably bytes in the buffer).  The
                // completion routine will not call SerialMouseStartRead, so we 
                // just loop here.  This is to prevent us from running out of stack
                // space if always call StartRead from the completion routine
                //
                Print(DBG_READ_TRACE, ("read is looping\n"));
            }
        } else if (status == STATUS_PRIVILEGE_NOT_HELD ||
                   status == STATUS_CANCELLED ||
                   status == STATUS_DELETE_PENDING ||
                   status == STATUS_DEVICE_NOT_CONNECTED) {
            //
            // The HID class device object is being deleted.  We will soon
            // receive Plug 'n Play notification of this device's removal,
            // if we have not received it already.
            //
            KeSetEvent (&Data->ReadCompleteEvent, 0, FALSE);
            IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
            break;
        } else {
            //
            // BUGBUG what shall we do with errors?
            //
            //
            // Panic
            //
            TRAP();
        }
    }

    return status;
}


VOID
KbdHid_AutoRepeat (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    )
/*++
Routine Description:
   The auto repeat time has gone off.  We should therefore duplicate the
   keystrokes that are currently down, by signalling them all going up,
   and then signaling them all going down.
   Afterwards we need to reset the timer to the repeat rate.

Arguments:
   DeferredContext is set to the HID_DEVICE structure.

--*/
{
    PUSAGE_AND_PAGE    previous;

    previous = Data->HidExtension->MakeUsageList; // PreviousUsageList;
    //
    // We really do not protect the previous list
    // But in order for the Previous list to be touched (written to),
    // the completion routine must fire, swap current with previous,
    // and the HIDCLASS must start writing on the list.
    // So we don't worry about this for now.
    //

    //
    // simulate a repeated key-down
    //
    HidP_TranslateUsageAndPagesToI8042ScanCodes (
                previous,
                Data->HidExtension->MaxUsages,
                HidP_Keyboard_Make,
                &Data->HidExtension->ModifierState,
                KbdHid_InsertCodesIntoQueue,
                Data);
}


#if KEYBOARD_HW_CHATTERY_FIX  // [DAN]

VOID
KbdHid_InitiateStartRead (
    IN PKDPC                DPC,
    IN PDEVICE_EXTENSION    Data,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    )
{
    IoAcquireRemoveLock (&Data->RemoveLock, Data->ReadIrp);
    KbdHid_StartRead(Data);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\mouhid\creatcls.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    creatcls.c

Abstract:

    This module contains the code for IRP_MJ_CREATE and IRP_MJ_CLOSE dispatch
    functions for the HID Mouse Filter Driver.

Environment:

    Kernel mode only.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian
    May-97 : Kenneth D. Ray converted to PnP filter
--*/

#include "mouhid.h"
NTSTATUS
MouHid_CreateComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;

    UNREFERENCED_PARAMETER (DeviceObject);

    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MouHid_Create (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for create/open requests.  This request
    completes successfully, unless the filename's length is non-zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION  irpSp  = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data = NULL;
    KEVENT              event;

    Print (DBG_CC_TRACE, ("DispatchCreate: Enter.\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Determine if request is trying to open a subdirectory of the
    // given device object.  This is not allowed.
    //
    if (0 != irpSp->FileObject->FileName.Length) {
        Print(DBG_CC_ERROR, ("ERROR: Create Access Denied.\n"));

        status = STATUS_ACCESS_DENIED;
        goto MouHid_CreateReject;
    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        goto MouHid_CreateReject;
    }

    ExAcquireFastMutex (&data->CreateCloseMutex);

    if (NULL == data->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: enable before connect!\n"));
        status = STATUS_UNSUCCESSFUL;
    } else {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                MouHid_CreateComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (data->TopOfStack, Irp);
        if (STATUS_PENDING == status) {

            KeWaitForSingleObject(&event,
                                  Executive, // Waiting for reason of a driver
                                  KernelMode, // Waiting in kernel mode
                                  FALSE, // No allert
                                  NULL); // No timeout
        }

        if (NT_SUCCESS (status)) {
            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS (status)) {
            InterlockedIncrement(&data->EnableCount);
            if (NULL == data->ReadFile && 
                (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA)) {
                //
                // We want to start the read pump.
                //
                Print (DBG_IOCTL_INFO, ("Enabling Mouse \n"));

                data->ReadFile = irpSp->FileObject;

                KeResetEvent (&data->ReadCompleteEvent);
            
                data->ReadInterlock = MOUHID_END_READ;
                
                // Acquire another time for the read irp.
                IoAcquireRemoveLock (&data->RemoveLock, data->ReadIrp);
                data->ReadIrp->IoStatus.Status = STATUS_SUCCESS;
                status = MouHid_StartRead (data);

                if (STATUS_PENDING == status) {
                    status = STATUS_SUCCESS;
                } else if (!NT_SUCCESS(status)) {
                    //
                    // Set it back to NULL so that a future open tries again
                    // Read should not fail if open passed. ASSERT!
                    //
                    ASSERT(NT_SUCCESS(status)); 
                    data->ReadFile = NULL;
                } 
            }

            ASSERT (data->EnableCount < 100);
            ASSERT (0 < data->EnableCount);
        }
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);
    
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;

MouHid_CreateReject:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    Print(DBG_CC_TRACE, ("DispatchCreate: Exit (%x).\n", status));
    return status;
}

NTSTATUS
MouHid_Close (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for close requests.  This request
    completes successfully, unless the file name length is zero.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION   data;
    PIO_STACK_LOCATION  stack;


    Print(DBG_CC_TRACE, ("DispatchClose: Enter\n"));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    ExAcquireFastMutex (&data->CreateCloseMutex);

    ASSERT (data->EnableCount < 100);
    ASSERT (0 < data->EnableCount);

    if (0 == InterlockedDecrement(&data->EnableCount)) {
        Print (DBG_IOCTL_INFO, ("Disabling Mouse \n"));
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );

        if (IoCancelIrp (data->ReadIrp)) {
            KeWaitForSingleObject (&data->ReadCompleteEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL
                                   );
        }

        ASSERT (NULL != data->ReadFile);
//        ASSERT (data->ReadFile == stack->FileObject);

        data->ReadFile = NULL;
    }

    ExReleaseFastMutex (&data->CreateCloseMutex);

    IoSkipCurrentIrpStackLocation (Irp);
    Print(DBG_CC_TRACE, ("DispatchClose: Exit \n"));
    return IoCallDriver (data->TopOfStack, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\mouhid\mouhid.h ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    mouhid.h

Abstract:

    This module contains the private definitions for the HID Mouse Filter
    Driver.

    Note: This is not a WDM driver as it will not run on Memphis (you need a
    vxd mapper to do mice for Memphis) and it uses event logs

Environment:

    Kernel mode only.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian

--*/

#ifndef _MOUHID_H
#define _MOUHID_H

#include "ntddk.h"
#include "hidusage.h"
#include "hidpi.h"
#include "ntddmou.h"
#include "kbdmou.h"
#include "mouhidm.h"
#include "wmilib.h"

//
// Allocate memory with our own pool tag.  Note that Windows 95/NT are little
// endian systems.
//
#define MOUHID_POOL_TAG (ULONG) 'lCdH'
#undef  ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, MOUHID_POOL_TAG);

//
// Sometimes we allocate a bunch of structures together and need to split the
// allocation among these different structures. Use this macro to get the
// lengths of the different structures aligned properly.
// 
#if defined(_WIN64)
#define ALIGNPTRLEN(x) ((x + 0x7) >> 3) << 3
#else // defined(_WIN64)
#define ALIGNPTRLEN(x) x
#endif // defined(_WIN64)

//
// Registry ProblemFlags masks.
//
#define PROBLEM_BAD_ABSOLUTE_FLAG_X_Y  0x00000001
#define PROBLEM_BAD_PHYSICAL_MIN_MAX_X 0x00000002
#define PROBLEM_BAD_PHYSICAL_MIN_MAX_Y 0x00000004
#define PROBLEM_BAD_PHYSICAL_MIN_MAX_Z 0x00000008

//
// Flags to indicate whether read completed synchronously or asynchronously
//
#define MOUHID_START_READ     0x01
#define MOUHID_END_READ       0x02
#define MOUHID_IMMEDIATE_READ 0x03

//
// I cannot find this constant after a bit of searching so I am making it up
// emperically for now.
//
// When we have an absolute mouse we need to scale its maximum value to the
// Raw Input User Thread's maximum value.
//
#define MOUHID_RIUT_ABSOLUTE_POINTER_MAX 0xFFFF


//
// Debug messaging and breakpoint macros.
//

#define DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define DBG_SS_NOISE               0x00000001
#define DBG_SS_TRACE               0x00000002
#define DBG_SS_INFO                0x00000004
#define DBG_SS_ERROR               0x00000008

#define DBG_CALL_MASK              0x000000F0
#define DBG_CALL_NOISE             0x00000010
#define DBG_CALL_TRACE             0x00000020
#define DBG_CALL_INFO              0x00000040
#define DBG_CALL_ERROR             0x00000080

#define DBG_IOCTL_MASK             0x00000F00
#define DBG_IOCTL_NOISE            0x00000100
#define DBG_IOCTL_TRACE            0x00000200
#define DBG_IOCTL_INFO             0x00000400
#define DBG_IOCTL_ERROR            0x00000800

#define DBG_READ_MASK              0x0000F000
#define DBG_READ_NOISE             0x00001000
#define DBG_READ_TRACE             0x00002000
#define DBG_READ_INFO              0x00004000
#define DBG_READ_ERROR             0x00008000

#define DBG_CREATE_CLOSE_MASK      0x000F0000
#define DBG_CC_NOISE               0x00010000
#define DBG_CC_TRACE               0x00020000
#define DBG_CC_INFO                0x00040000
#define DBG_CC_ERROR               0x00080000

#define DBG_POWER_MASK             0x00F00000
#define DBG_POWER_NOISE            0x00100000
#define DBG_POWER_TRACE            0x00200000
#define DBG_POWER_INFO             0x00400000
#define DBG_POWER_ERROR            0x00800000

#define DBG_PNP_MASK               0x0F000000
#define DBG_PNP_NOISE              0x01000000
#define DBG_PNP_TRACE              0x02000000
#define DBG_PNP_INFO               0x04000000
#define DBG_PNP_ERROR              0x08000000

#define DBG_CANCEL_MASK            0xF0000000
#define DBG_CANCEL_NOISE           0x10000000
#define DBG_CANCEL_TRACE           0x20000000
#define DBG_CANCEL_INFO            0x40000000
#define DBG_CANCEL_ERROR           0x80000000

#define DEFAULT_DEBUG_OUTPUT_LEVEL 0x88888888

#if DBG

#define Print(_l_, _x_) \
            if (Globals.DebugLevel & (_l_)) { \
               DbgPrint ("MouHid: "); \
               DbgPrint _x_; \
            }
#define TRAP() DbgBreakPoint()

#else
#define Print(_l_,_x_)
#define TRAP()
#endif

#define MAX(_A_,_B_) (((_A_) < (_B_)) ? (_B_) : (_A_))
#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))


#define FLIP_FLOP_WHEEL L"FlipFlopWheel" // should we change polarity of wheel
#define SCALING_FACTOR_WHEEL L"WheelScalingFactor" // The per-raden scaling factor



//
// Structures
//
typedef struct _GLOBALS {
#if DBG
    //
    // The level of trace output sent to the debugger. See HidCli_KdPrint above.
    //
    ULONG               DebugLevel;
#endif

    //
    // Configuration flag indicating that we must treat all mouse movement as
    // relative data.  Overrides .IsAbsolute flag reported by the HID device.
    // To set this switch, place a value of the same name into the parameters
    // key.
    //
    BOOLEAN             TreatAbsoluteAsRelative;

    //
    // When using a HID device of usage type HID_USAGE_GENERIC_POINTER (not
    // of HID_USAGE_GENERIC_MOUSE).
    // This switch overwrites the "TreatAbsoluteAsRelative" switch.
    //
    BOOLEAN             TreatAbsolutePointerAsAbsolute;

    //
    // Do not Accept HID_USAGE_GENERIC_POINTER as a device.  (AKA only 